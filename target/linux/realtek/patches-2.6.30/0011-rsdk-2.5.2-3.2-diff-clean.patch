diff --git a/Makefile b/Makefile
index 4fcb783..674b79b 100644
--- a/Makefile
+++ b/Makefile
@@ -180,8 +180,8 @@ export srctree objtree VPATH TOPDIR
 
 ARCH		  := rlx
 #ARCH		  := mips
-UTS_MACHINE 	:= $(ARCH)
-SRCARCH 	:= $(ARCH)
+UTS_MACHINE   := $(ARCH)
+SRCARCH       := $(ARCH)
 SUBARCH       := $(ARCH)
 ARCH_VMLINUX  := arch/$(ARCH)/bsp/vmlinux.lds
 #ARCH_VMLINUX  := arch/$(ARCH)/kernel/vmlinux.lds
@@ -455,7 +455,13 @@ include .config
 ifeq ($(CONFIG_RTK_VOIP),y)
 drivers-y	+= rtk_voip/
 endif
+ifeq ($(CONFIG_AUDIOCODES_VOIP),y)
+drivers-y	+= acmw_lx/
+endif
 
+ifeq ($(CONFIG_USB_UWIFI_HOST),y)
+UWIFI_INCLUDED = 1
+endif
 endif # KBUILD_EXTMOD
 
 ifeq ($(dot-config),1)
@@ -965,8 +971,27 @@ prepare0: archprepare FORCE
 	$(Q)$(MAKE) $(build)=.
 	$(Q)$(MAKE) $(build)=. missing-syscalls
 
+prepare_uWiFi:
+	rm -f ./include/linux/pm.h
+	rm -f ./include/linux/device.h
+	rm -f ./include/linux/pm_runtime.h
+	rm -f ./include/linux/usb.h
+ifeq ($(UWIFI_INCLUDED),1)
+	echo "<<<Apply uWiFi USB subsystem>>>"
+	cp -p ./drivers/staging/rtk_uWiFi/rtk_uWiFi_4181.obj ./drivers/staging/rtk_uWiFi/uWiFi.o
+	cp -p ./include/linux/device_uWiFi.h ./include/linux/device.h
+	cp -p ./include/linux/pm_uWiFi.h ./include/linux/pm.h
+	cp -p ./include/linux/pm_runtime_uWiFi.h ./include/linux/pm_runtime.h
+	cp -p ./include/linux/usb_uWiFi.h ./include/linux/usb.h
+else
+	echo "<<<Apply Orig USB subsystem>>>"
+	cp -p ./include/linux/device_sdk_orig.h ./include/linux/device.h
+	cp -p ./include/linux/pm_sdk_orig.h ./include/linux/pm.h
+	cp -p ./include/linux/usb_sdk_orig.h ./include/linux/usb.h
+endif
+
 # All the preparing..
-prepare: prepare0
+prepare: prepare_uWiFi prepare0
 
 # Leave this as default for preprocessing vmlinux.lds.S, which is now
 # done in arch/$(ARCH)/kernel/Makefile
@@ -1216,6 +1241,8 @@ clean: archclean $(clean-dirs)
 		-o -name '*.symtypes' -o -name 'modules.order' \
 		-o -name 'Module.markers' -o -name '.tmp_*.o.*' \) \
 		-type f -print | xargs rm -f
+	rm -f ./arch/rlx/bsp/*.o
+	rm -f ./arch/rlx/bsp/.*.cmd
 
 # mrproper - Delete all generated files, including .config
 #
diff --git a/arch/mips/include/asm/atomic.h b/arch/mips/include/asm/atomic.h
index 5af7d23..ed3445f 100644
--- a/arch/mips/include/asm/atomic.h
+++ b/arch/mips/include/asm/atomic.h
@@ -50,7 +50,7 @@ typedef struct {
  *
  * Atomically sets the value of @v to @i.
  */
-#define atomic_set(v, i)		((v)->counter = (i))
+#define atomic_set(v,i)		((v)->counter = (i))
 
 /*
  * atomic_add - add integer to atomic variable
@@ -339,8 +339,8 @@ static __inline__ int atomic_sub_if_positive(int i, atomic_t * v)
 })
 #define atomic_inc_not_zero(v) atomic_add_unless((v), 1, 0)
 
-#define atomic_dec_return(v) atomic_sub_return(1, (v))
-#define atomic_inc_return(v) atomic_add_return(1, (v))
+#define atomic_dec_return(v) atomic_sub_return(1,(v))
+#define atomic_inc_return(v) atomic_add_return(1,(v))
 
 /*
  * atomic_sub_and_test - subtract value from variable and test result
@@ -351,7 +351,7 @@ static __inline__ int atomic_sub_if_positive(int i, atomic_t * v)
  * true if the result is zero, or false for all
  * other cases.
  */
-#define atomic_sub_and_test(i, v) (atomic_sub_return((i), (v)) == 0)
+#define atomic_sub_and_test(i,v) (atomic_sub_return((i), (v)) == 0)
 
 /*
  * atomic_inc_and_test - increment and test
@@ -385,7 +385,7 @@ static __inline__ int atomic_sub_if_positive(int i, atomic_t * v)
  *
  * Atomically increments @v by 1.
  */
-#define atomic_inc(v) atomic_add(1, (v))
+#define atomic_inc(v) atomic_add(1,(v))
 
 /*
  * atomic_dec - decrement and test
@@ -393,7 +393,7 @@ static __inline__ int atomic_sub_if_positive(int i, atomic_t * v)
  *
  * Atomically decrements @v by 1.
  */
-#define atomic_dec(v) atomic_sub(1, (v))
+#define atomic_dec(v) atomic_sub(1,(v))
 
 /*
  * atomic_add_negative - add and test if negative
@@ -404,7 +404,7 @@ static __inline__ int atomic_sub_if_positive(int i, atomic_t * v)
  * if the result is negative, or false when
  * result is greater than or equal to zero.
  */
-#define atomic_add_negative(i, v) (atomic_add_return(i, (v)) < 0)
+#define atomic_add_negative(i,v) (atomic_add_return(i, (v)) < 0)
 
 #ifdef CONFIG_64BIT
 
@@ -424,7 +424,7 @@ typedef struct { volatile __s64 counter; } atomic64_t;
  * @v: pointer of type atomic64_t
  * @i: required value
  */
-#define atomic64_set(v, i)	((v)->counter = (i))
+#define atomic64_set(v,i)	((v)->counter = (i))
 
 /*
  * atomic64_add - add integer to atomic variable
@@ -691,8 +691,8 @@ static __inline__ long atomic64_sub_if_positive(long i, atomic64_t * v)
 	return result;
 }
 
-#define atomic64_dec_return(v) atomic64_sub_return(1, (v))
-#define atomic64_inc_return(v) atomic64_add_return(1, (v))
+#define atomic64_dec_return(v) atomic64_sub_return(1,(v))
+#define atomic64_inc_return(v) atomic64_add_return(1,(v))
 
 /*
  * atomic64_sub_and_test - subtract value from variable and test result
@@ -703,7 +703,7 @@ static __inline__ long atomic64_sub_if_positive(long i, atomic64_t * v)
  * true if the result is zero, or false for all
  * other cases.
  */
-#define atomic64_sub_and_test(i, v) (atomic64_sub_return((i), (v)) == 0)
+#define atomic64_sub_and_test(i,v) (atomic64_sub_return((i), (v)) == 0)
 
 /*
  * atomic64_inc_and_test - increment and test
@@ -737,7 +737,7 @@ static __inline__ long atomic64_sub_if_positive(long i, atomic64_t * v)
  *
  * Atomically increments @v by 1.
  */
-#define atomic64_inc(v) atomic64_add(1, (v))
+#define atomic64_inc(v) atomic64_add(1,(v))
 
 /*
  * atomic64_dec - decrement and test
@@ -745,7 +745,7 @@ static __inline__ long atomic64_sub_if_positive(long i, atomic64_t * v)
  *
  * Atomically decrements @v by 1.
  */
-#define atomic64_dec(v) atomic64_sub(1, (v))
+#define atomic64_dec(v) atomic64_sub(1,(v))
 
 /*
  * atomic64_add_negative - add and test if negative
@@ -756,7 +756,7 @@ static __inline__ long atomic64_sub_if_positive(long i, atomic64_t * v)
  * if the result is negative, or false when
  * result is greater than or equal to zero.
  */
-#define atomic64_add_negative(i, v) (atomic64_add_return(i, (v)) < 0)
+#define atomic64_add_negative(i,v) (atomic64_add_return(i, (v)) < 0)
 
 #endif /* CONFIG_64BIT */
 
diff --git a/arch/mips/include/asm/thread_info.h b/arch/mips/include/asm/thread_info.h
index 462c46e..68cc6fb 100644
--- a/arch/mips/include/asm/thread_info.h
+++ b/arch/mips/include/asm/thread_info.h
@@ -66,24 +66,24 @@ register struct thread_info *__current_thread_info __asm__("$28");
 #ifdef CONFIG_KERNEL_STACK_SIZE_ORDER
   #define THREAD_SIZE_ORDER (CONFIG_KERNEL_STACK_SIZE_ORDER)
 #else
-#if defined(CONFIG_PAGE_SIZE_4KB) && defined(CONFIG_32BIT)
+  #if defined(CONFIG_PAGE_SIZE_4KB) && defined(CONFIG_32BIT)
     #define THREAD_SIZE_ORDER (2)
-#endif
-#if defined(CONFIG_PAGE_SIZE_4KB) && defined(CONFIG_64BIT)
-#define THREAD_SIZE_ORDER (2)
-#endif
-#ifdef CONFIG_PAGE_SIZE_8KB
-#define THREAD_SIZE_ORDER (1)
-#endif
-#ifdef CONFIG_PAGE_SIZE_16KB
-#define THREAD_SIZE_ORDER (0)
-#endif
-#ifdef CONFIG_PAGE_SIZE_32KB
-#define THREAD_SIZE_ORDER (0)
-#endif
-#ifdef CONFIG_PAGE_SIZE_64KB
-#define THREAD_SIZE_ORDER (0)
-#endif
+  #endif
+  #if defined(CONFIG_PAGE_SIZE_4KB) && defined(CONFIG_64BIT)
+    #define THREAD_SIZE_ORDER (2)
+  #endif
+  #ifdef CONFIG_PAGE_SIZE_8KB
+    #define THREAD_SIZE_ORDER (1)
+  #endif
+  #ifdef CONFIG_PAGE_SIZE_16KB
+    #define THREAD_SIZE_ORDER (0)
+  #endif
+  #ifdef CONFIG_PAGE_SIZE_32KB
+    #define THREAD_SIZE_ORDER (0)
+  #endif
+  #ifdef CONFIG_PAGE_SIZE_64KB
+    #define THREAD_SIZE_ORDER (0)
+  #endif
 #endif
 
 #define THREAD_SIZE (PAGE_SIZE << THREAD_SIZE_ORDER)
diff --git a/arch/mips/kernel/cpu-probe.c b/arch/mips/kernel/cpu-probe.c
index 7de0717..32759dd 100644
--- a/arch/mips/kernel/cpu-probe.c
+++ b/arch/mips/kernel/cpu-probe.c
@@ -917,8 +917,8 @@ __cpuinit void cpu_probe(void)
         c->tlbsize      = 32;
         c->icache.ways = 2;
         c->dcache.ways = 2;
-
-	c->processor_id	= PRID_IMP_UNKNOWN;
+		
+	c->processor_id = PRID_IMP_UNKNOWN;
 	//c->options = MIPS_CPU_TLB | MIPS_CPU_3K_CACHE | MIPS_CPU_NOFPUEX;
 	//c->tlbsize = 32;  /* defined in bspcpu.h */
 	c->processor_id = read_c0_prid();
diff --git a/arch/mips/kernel/genex.S b/arch/mips/kernel/genex.S
index 9c62eb5..af00f68 100644
--- a/arch/mips/kernel/genex.S
+++ b/arch/mips/kernel/genex.S
@@ -516,4 +516,4 @@ NESTED(nmi_handler, PT_SIZE, sp)
 	__INIT
 
 	BUILD_HANDLER  daddi_ov daddi_ov none silent	/* #12 */
-#endif
+#endif
\ No newline at end of file
diff --git a/arch/mips/lib/csum_partial.S b/arch/mips/lib/csum_partial.S
index d78ada3..3480d47 100644
--- a/arch/mips/lib/csum_partial.S
+++ b/arch/mips/lib/csum_partial.S
@@ -229,7 +229,7 @@ LEAF(csum_partial)
 
 	andi	t0, a1, 4
 	beqz	t0, 1f
-	 andi	t0, a1, 2
+	andi	t0, a1, 2
 
 	/* Still a full word to go  */
 #ifndef CONFIG_REALTEK_CPU
diff --git a/arch/mips/lib/memcpy-inatomic.S b/arch/mips/lib/memcpy-inatomic.S
index ec4e617..58932e9 100644
--- a/arch/mips/lib/memcpy-inatomic.S
+++ b/arch/mips/lib/memcpy-inatomic.S
@@ -90,7 +90,7 @@
 #define SRA    sra
 #define SLLV   sllv
 #define SRLV   srlv
-#define LOG_NBYTES 2
+#define LOG_NBYTES  2
 
 #ifdef CONFIG_CPU_LITTLE_ENDIAN
 #define LDFIRST LOADR
@@ -156,7 +156,7 @@ LEAF(__copy_user_inatomic)
 	 * src and dst are aligned; need to compute rem
 	 */
 .Lboth_aligned:
-	 SRL	t0, len, LOG_NBYTES+3    	# +3 for 8 units/iter
+	 SRL	t0, len, LOG_NBYTES+3       # +3 for 8 units/iter
 	beqz	t0, .Lcleanup_both_aligned  # len < 8*LONGSIZE
 	 and	rem, len, (8*LONGSIZE-1)    # rem = len % (8*LONGSIZE)
 	.align	4
@@ -312,23 +312,23 @@ EXC(	LDREST	t0, REST(0)(src),	.Ll_exc_copy)
 	 ADD	dst, dst, LONGSIZE
 
 .Lcopy_bytes_checklen:
-	beqz	len, .Ldone
-	 nop
+    beqz    len, .Ldone
+     nop
 
 .Lcopy_bytes:
     /* 0 < len < LONGSIZE*/
-#define COPY_BYTE(N)			\
-EXC(	lb	t0, N(src), .Ll_exc);	\
-	SUB	len, len, 1;		\
-	beqz	len, .Ldone;		\
-	 sb	t0, N(dst)
-
-	COPY_BYTE(0)
-	COPY_BYTE(1)
+#define COPY_BYTE(N)            \
+EXC(    lb  t0, N(src), .Ll_exc);   \
+    SUB len, len, 1;        \
+    beqz    len, .Ldone;        \
+     sb t0, N(dst)
+                                                                                                    
+    COPY_BYTE(0)
+    COPY_BYTE(1)
 
 EXC(    lb  t0, LONGSIZE-2(src), .Ll_exc)
-	SUB	len, len, 1
-	jr	ra
+    SUB len, len, 1
+    jr  ra
      sb t0, LONGSIZE-2(dst)
 
 #else /* NO ULS */
diff --git a/arch/mips/lib/memcpy.S b/arch/mips/lib/memcpy.S
index a40011c..c279962 100644
--- a/arch/mips/lib/memcpy.S
+++ b/arch/mips/lib/memcpy.S
@@ -288,7 +288,7 @@ EXC(	STORE	t1, UNIT(1)(dst),	s_exc_p3u)
 EXC(	STORE	t2, UNIT(2)(dst),	s_exc_p2u)
 EXC(	STORE	t3, UNIT(3)(dst),	s_exc_p1u)
 	beqz	len, done
-	ADD	dst, dst, 4*NBYTES
+	 ADD	dst, dst, 4*NBYTES
 less_than_4units:
 	/*
 	 * rem = len % NBYTES
@@ -415,7 +415,7 @@ EXC(	sb      t0, 0(dst), s_exc_p1)
 	ADD	dst,    dst, 1
 	ADD src,        src, 1
 	bnez	len, 1b
-	 nop
+	nop
 #else
 	/* 0 < len < NBYTES  */
 #define COPY_BYTE(N)			\
@@ -480,7 +480,7 @@ l_exc:
 	 * might modify len.  An inefficient loop for these rare times...
 	 */
 	beqz	len, done
-	SUB	src, len, 1
+	 SUB	src, len, 1
 1:	sb	zero, 0(dst)
 	ADD	dst, dst, 1
 	bnez	src, 1b
@@ -489,9 +489,9 @@ l_exc:
 	 nop
 
 
-#define SEXC(n)							\
+#define SEXC(n)				\
 s_exc_p ## n ## u:			\
-	jr	ra;						\
+	jr	ra;			\
 	 ADD	len, len, n*NBYTES
 
 SEXC(8)
@@ -536,7 +536,7 @@ r_end_bytes:
 	sb	t0, -1(a0)
 	SUB	a1, a1, 0x1
 	bnez	a2, r_end_bytes
-	SUB	a0, a0, 0x1
+	 SUB	a0, a0, 0x1
 
 r_out:
 	jr	ra
@@ -548,7 +548,7 @@ r_end_bytes_up:
 	sb	t0, (a0)
 	ADD	a1, a1, 0x1
 	bnez	a2, r_end_bytes_up
-	ADD	a0, a0, 0x1
+	 ADD	a0, a0, 0x1
 
 	jr	ra
 	 move	a2, zero
diff --git a/arch/mips/rtl8196b/int.c b/arch/mips/rtl8196b/int.c
index fd8699a..d669e73 100644
--- a/arch/mips/rtl8196b/int.c
+++ b/arch/mips/rtl8196b/int.c
@@ -1,3 +1,12 @@
+/*
+ *
+ *  Copyright (c) 2011 Realtek Semiconductor Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
 #include <linux/config.h>
 #include <linux/irq.h>
 
diff --git a/arch/mips/rtl8196b/mem.c b/arch/mips/rtl8196b/mem.c
index 98644d9..420c2a5 100644
--- a/arch/mips/rtl8196b/mem.c
+++ b/arch/mips/rtl8196b/mem.c
@@ -1,3 +1,11 @@
+/*
+ *
+ *  Copyright (c) 2011 Realtek Semiconductor Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
 #include <linux/config.h>
 #include <linux/init.h>
 #include <linux/mm.h>
diff --git a/arch/mips/rtl8196b/pci-rtl8196.c b/arch/mips/rtl8196b/pci-rtl8196.c
index fffd6d5..a6f93d6 100644
--- a/arch/mips/rtl8196b/pci-rtl8196.c
+++ b/arch/mips/rtl8196b/pci-rtl8196.c
@@ -8,6 +8,12 @@
  * - Supports PCI devices through PCIE-to-PCI bridges
  * - If no PCI devices are connected to RC. Timeout monitor shall be 
  *   enabled to prevent bus hanging.
+ *
+ *  Copyright (c) 2011 Realtek Semiconductor Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
  */
 #include <linux/kernel.h>
 #include <linux/init.h>
diff --git a/arch/mips/rtl8196b/printf.c b/arch/mips/rtl8196b/printf.c
index 650f46d..65f5b4a 100644
--- a/arch/mips/rtl8196b/printf.c
+++ b/arch/mips/rtl8196b/printf.c
@@ -1,3 +1,11 @@
+/*
+ *
+ *  Copyright (c) 2011 Realtek Semiconductor Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/spinlock.h>
diff --git a/arch/mips/rtl8196b/setup.c b/arch/mips/rtl8196b/setup.c
index 7a25984..fbf5e2b 100644
--- a/arch/mips/rtl8196b/setup.c
+++ b/arch/mips/rtl8196b/setup.c
@@ -1,3 +1,11 @@
+/*
+ *
+ *  Copyright (c) 2011 Realtek Semiconductor Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
 #include <linux/config.h>
 #include <linux/init.h>
 #include <linux/string.h>
diff --git a/arch/mips/rtl8196c/int.c b/arch/mips/rtl8196c/int.c
index 4d00494..8c2c897 100644
--- a/arch/mips/rtl8196c/int.c
+++ b/arch/mips/rtl8196c/int.c
@@ -1,3 +1,11 @@
+/*
+ *
+ *  Copyright (c) 2011 Realtek Semiconductor Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
 #include <linux/config.h>
 #include <linux/irq.h>
 
diff --git a/arch/mips/rtl8196c/mem.c b/arch/mips/rtl8196c/mem.c
index 98644d9..420c2a5 100644
--- a/arch/mips/rtl8196c/mem.c
+++ b/arch/mips/rtl8196c/mem.c
@@ -1,3 +1,11 @@
+/*
+ *
+ *  Copyright (c) 2011 Realtek Semiconductor Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
 #include <linux/config.h>
 #include <linux/init.h>
 #include <linux/mm.h>
diff --git a/arch/mips/rtl8196c/pci-rtl8196.c b/arch/mips/rtl8196c/pci-rtl8196.c
index fffd6d5..a6f93d6 100644
--- a/arch/mips/rtl8196c/pci-rtl8196.c
+++ b/arch/mips/rtl8196c/pci-rtl8196.c
@@ -8,6 +8,12 @@
  * - Supports PCI devices through PCIE-to-PCI bridges
  * - If no PCI devices are connected to RC. Timeout monitor shall be 
  *   enabled to prevent bus hanging.
+ *
+ *  Copyright (c) 2011 Realtek Semiconductor Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
  */
 #include <linux/kernel.h>
 #include <linux/init.h>
diff --git a/arch/mips/rtl8196c/printf.c b/arch/mips/rtl8196c/printf.c
index 650f46d..65f5b4a 100644
--- a/arch/mips/rtl8196c/printf.c
+++ b/arch/mips/rtl8196c/printf.c
@@ -1,3 +1,11 @@
+/*
+ *
+ *  Copyright (c) 2011 Realtek Semiconductor Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/spinlock.h>
diff --git a/arch/mips/rtl8196c/setup.c b/arch/mips/rtl8196c/setup.c
index 7a25984..fbf5e2b 100644
--- a/arch/mips/rtl8196c/setup.c
+++ b/arch/mips/rtl8196c/setup.c
@@ -1,3 +1,11 @@
+/*
+ *
+ *  Copyright (c) 2011 Realtek Semiconductor Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
 #include <linux/config.h>
 #include <linux/init.h>
 #include <linux/string.h>
diff --git a/arch/rlx/Kconfig b/arch/rlx/Kconfig
index 856c33f..14f97b8 100644
--- a/arch/rlx/Kconfig
+++ b/arch/rlx/Kconfig
@@ -7,351 +7,7 @@
 # Dec. 07, 2008
 #
 
-#### BEGIN INCLUDE
-
-config RTL_819X
-	def_bool y
-
-config RTL_8196C
-	def_bool y
-
-#
-# Processor Config
-#
-config ARCH_32BIT
-  bool 
-  default y
-
-config ARCH_CPU_RLX4181
-  bool 
-  default y
-
-config ARCH_CPU_EB
-  bool 
-  default y
-
-config ARCH_CPU_EL
-  bool 
-  default n
-
-config ARCH_CPU_RADIAX
-  bool 
-  default n
-
-config ARCH_CPU_SLEEP
-  bool
-  default y
-
-config ARCH_CPU_ULS
-  bool 
-  default y
-
-config ARCH_CPU_LLSC
-  bool 
-  default n
-
-config ARCH_CPU_SYNC
-  bool
-  default n
-
-config ARCH_CACHE_WBC
-  bool 
-  default y
-
-config ARCH_CACHE_L2C
-  bool 
-  default n
-
-config ARCH_IRQ_CPU
-  bool 
-  default y
-
-config ARCH_IRQ_VEC
-  bool 
-  default y
-
-config ARCH_BUS_USB
-  bool 
-  default n
-
-config ARCH_BUS_PCI
-  bool 
-  default y
-
-config ARCH_BUS_PCI_MSI
-  bool
-  default n
-#
-# System Config
-#
-menu "System Configuration"
-choice
-	prompt "System Type"
-	default RTL_8196C_GW
-
-config RTL_8196C_GW
-        bool "RTL8196C Demo Board"
-        help
-          This enables support for Realtek RTL8196C demo board
-
-         
-endchoice
-
-config RTL8196C_REVISION_B
-	bool
-	default y if RTL_8196C_GW
-	default y if RTL_8196C_iNIC
-
-config RTL8196C_GREEN_ETHERNET
-	bool
-	default y if RTL_8196C_GW
-
-config FPGA_PLATFORM
-	bool
-
-config RTL_PCIE_SIMPLE_INIT
-	bool
-	default y if RTL8192SE
-	default y if RTL8192CD
-
-config RTL_WTDOG
-	bool "Enable watchdog timer support"
-
-config RTL_TIMER_ADJUSTMENT
-	bool "Enable timer adjustment support"
-	
-config RTL_WEBPAGES_IN_ROOTFS
-	bool "Webpages in rootfs support"
- 
-config RTL819X_SPI_FLASH
-	bool "SPI flash support"
-
-config RTL_FLASH_DUAL_IMAGE_ENABLE
-	bool "Enable Flash Dual Bank support"
-comment "Second Bank Offset"
-	depends on RTL_FLASH_DUAL_IMAGE_ENABLE
-config RTL_FLASH_DUAL_IMAGE_OFFSET
-	hex "offset of Flash"
-	depends on RTL_819X && RTL_FLASH_DUAL_IMAGE_ENABLE
-	default "0x200000"
-	help
-          offset of second bank, Normally should be 2M or 4M.
-config RTL_FLASH_MAPPING_ENABLE
-	bool "Enable Flash Mapping"
-
-config POCKET_ROUTER_SUPPORT
-	bool "Pocket router support"
-
-config POCKET_AP_SUPPORT
-	bool "Pocket AP support"
-
-config DOMAIN_NAME_QUERY_SUPPORT
-	bool "Domain name query support"
-
-config USB3G_SUPPORT
-	bool "USB3G support"
-	select HOTPLUG
-	#select UEVENT_HELPER_PATH
-	select FW_LOADER
-	select FIRMWARE_IN_KERNEL
-	#select EXTRA_FIRMWARE=""
-	select SCSI
-	select SCSI_DMA
-	select BLK_DEV_SD
-	select BLK_DEV_SR
-	select PPP
-	select PPP_MULTILINK
-	select PPP_FILTER
-	select PPP_DEFLATE
-	select PPP_BSDCOMP
-	select DEFAULTS_KERNEL_2_6
-	select USB_SUPPORT
-	select USB_ARCH_HAS_HCD
-	select USB_ARCH_HAS_OHCI
-	select USB_ARCH_HAS_EHCI
-	select USB
-	select USB_ANNOUNCE_NEW_DEVICES
-	select USB_DEVICEFS
-	select USB_DEVICE_CLASS
-	select USB_MON
-	select USB_EHCI_HCD
-	select USB_EHCI_ROOT_HUB_TT
-	select USB_EHCI_TT_NEWSCHED
-	select USB_OHCI_HCD
-	select USB_OHCI_LITTLE_ENDIAN
-	select USB_STORAGE
-	select USB_SERIAL
-	select USB_SERIAL_CONSOLE
-	select USB_SERIAL_GENERIC
-	select USB_SERIAL_OPTION
-	select CONFIGFS_FS
-	select ZLIB_DEFLATE
-	default n
-
-config HTTP_FILE_SERVER_SUPPORT
-	bool "Http File server support"
-
-comment "Support two spi flash"
-config RTL_TWO_SPI_FLASH_ENABLE
-        bool "two spi flash support"
-	default n
-config  RTL_SPI_FLASH1_SIZE
-        hex "Config 1st flash size"
-        depends on RTL_819X && RTL_TWO_SPI_FLASH_ENABLE
-        default "0x400000"
-        help
-          Normally should be 0x400000 or 0x800000.
-
-config  RTL_SPI_FLASH2_SIZE
-        hex "Config 2nd flash size"
-        depends on RTL_819X && RTL_TWO_SPI_FLASH_ENABLE
-        default "0x400000"
-        help
-          Normally should be 0x400000 or 0x800000.
-
-comment "Flash size 2M or 4M, default 2M"
-	depends on RTL_FLASH_MAPPING_ENABLE
-comment "USB3G is enable, please set to 0x400000"
-	depends on RTL_FLASH_MAPPING_ENABLE && USB3G_SUPPORT
-config RTL_FLASH_SIZE
-	hex "Size of Flash"
-	depends on RTL_819X && RTL_FLASH_MAPPING_ENABLE
-	default "0x200000"
-	help
-          Size of Flash, Normally should be 2M or 4M.
-
-comment "Hardware setting offset,should be 4K alignment"
-	depends on RTL_FLASH_MAPPING_ENABLE
-config RTL_HW_SETTING_OFFSET
-        hex "Hardware setting offset in flash."
-        depends on RTL_819X && RTL_FLASH_MAPPING_ENABLE
-        default "0x6000"
-        help
-	  Hardware Setting store in flash from the offset.
-	  it should be 4k alignment.
-
-comment "Default setting offset,should be 4K alignment."
-	depends on RTL_FLASH_MAPPING_ENABLE
-comment "size of default and current setting should be same."
-	depends on RTL_FLASH_MAPPING_ENABLE
-config RTL_DEFAULT_SETTING_OFFSET
-        hex "Default setting offset in flash."
-        depends on RTL_819X && RTL_FLASH_MAPPING_ENABLE
-        default "0x8000"
-        help
-	  Default Setting store in flash from the offset.
-	  normally the default setting shoud save before current settting.
-	  NOTE: make sure it's size is enough for default setting,
-		default size is 16K.
-
-comment "Current setting offset,should be 4K alignment."
-	depends on RTL_FLASH_MAPPING_ENABLE
-config RTL_CURRENT_SETTING_OFFSET
-        hex "Current setting offset in flash."
-        depends on RTL_819X  && RTL_FLASH_MAPPING_ENABLE
-        default "0xC000"
-        help
-	  Current Setting store in flash from the offset.
-	  normally the current setting saved after default setting.
-	  NOTE: make sure it's size is enough for current setting,
-		default size is 16K.
-
-comment "Webpage image offset,should be 4K alignment."
-	depends on RTL_FLASH_MAPPING_ENABLE
-comment "size of web page is normally about 100K."
-	depends on RTL_FLASH_MAPPING_ENABLE
-config RTL_WEB_PAGES_OFFSET
-	hex "webpages image offset in flash."
-	depends on RTL_819X && RTL_FLASH_MAPPING_ENABLE
-	default "0x10000"
-	help
-	  Webpages image store in flash from the offset.
-	  NOTE: default size is 128K.
-
-comment "Linux image offset,should be 4K alignment."
-	depends on RTL_FLASH_MAPPING_ENABLE
-comment "this offset MUST between 0x10000~0x40000."
-	depends on RTL_FLASH_MAPPING_ENABLE
-config RTL_LINUX_IMAGE_OFFSET
-        hex "linux image offset in flash."
-        depends on RTL_819X  && RTL_FLASH_MAPPING_ENABLE
-        default "0x30000"
-        help
-	  linux image store in flash from the offset.
-
-comment "Root image offset,should be 64K alignment."
-	depends on RTL_FLASH_MAPPING_ENABLE
-comment "USB3G is enable, please set to 0x130000."
-	depends on RTL_FLASH_MAPPING_ENABLE && USB3G_SUPPORT
-config RTL_ROOT_IMAGE_OFFSET
-        hex "root image offset in flash."
-        depends on RTL_819X  && RTL_FLASH_MAPPING_ENABLE
-        default "0xF0000"
-        help
-	  root image store in flash from the offset.
-
-# KERNE_STACK_SIZE = PAGE_SIZE<<KERNEL_STACK_SIZE_ORDER
-config KERNEL_STACK_SIZE_ORDER
-	int "Kenel Stack Size Order Configuration"
-	default "2"
-	help
-	  With Page Size 4K
-	  1 for 8K kenel stack size
-	  2 for 16K kernel stack size
-	  3 for 32K kernel stack size
-	  etc...
-
-config RTL_EAP_RELAY
-        bool
-
-config RTL_HOSTAPD_SUPPORT
-        bool
-
-#------------------------------------------------------------------------
-comment "Build rootfs options"
-
-choice
-	prompt "File system to mount root"
-	help
-		This option is mainly to assist to decide how to build rootfs, because
-		echo kind of file system for rootfs will uses different flow in our design. 
-
-config ROOTFS_RAMFS
-	bool "linux built-in ramfs"
-	depends on INITRAMFS_SOURCE != ""
-
-#config ROOTFS_RAMDISK
-#	bool "ramdisk"
-#	depends on BLK_DEV_RAM
-
-config ROOTFS_SQUASH
-	bool "squash fs"
-	depends on SQUASHFS
-
-config ROOTFS_JFFS2
-	bool "JFFS2 (work on u-boot only)"
-	depends on JFFS2_FS
-
-endchoice
-
-config JFFS2_ERASE_SIZE
-	hex "Erase size for JFFS2 tool"
-	depends on ROOTFS_JFFS2
-	default 0x10000
-	help 
-		This value is for mkfs.jffs2 tool, so bad value may cause kernel
-		boot failure. 
-		Given 0x1000 and 0x10000 for 4k and 64k flash respectively. 
-	
-#------------------------------------------------------------------------
-
-endmenu
-
-# remove this line when make SDK
-#source "../target/Kconfig.ictest"
-
-
-### END INCLUDE
+source "../target/config.in"
 
 config MIPS
     bool
diff --git a/arch/rlx/bsp/Makefile b/arch/rlx/bsp/Makefile
index 32d2cb0..4027108 100644
--- a/arch/rlx/bsp/Makefile
+++ b/arch/rlx/bsp/Makefile
@@ -20,8 +20,8 @@ obj-y := prom.o setup.o irq.o timer.o serial.o
 obj-$(CONFIG_PCI) += pci.o
 
 EXTRA_AFLAGS := $(CFLAGS)
-EXTRA_CFLAGS += -I$(TOPDIR)/drivers/net/rtl819x/AsicDriver
-EXTRA_CFLAGS += -I$(TOPDIR)/drivers/net/rtl819x/common
+EXTRA_CFLAGS += -I$(DIR_LINUX)/drivers/net/rtl819x/AsicDriver
+EXTRA_CFLAGS += -I$(DIR_LINUX)/drivers/net/rtl819x/common
 ifdef CONFIG_RTL_819X_SWCORE
 EXTRA_CFLAGS += -DCONFIG_RTL_819X_SWCORE
 endif
diff --git a/arch/rlx/bsp/pci.c b/arch/rlx/bsp/pci.c
index 11b295e..62f7b90 100644
--- a/arch/rlx/bsp/pci.c
+++ b/arch/rlx/bsp/pci.c
@@ -1,5 +1,5 @@
 /*
- * RTL8196B PCIE Host Controller Glue Driver
+ * RTL8196C PCIE Host Controller Glue Driver
  * Author: ghhuang@realtek.com.tw
  *
  * Notes:
@@ -14,7 +14,7 @@
 #include <linux/pci.h>
 #include <linux/interrupt.h>
 #include <linux/delay.h>
-#include <asm/rlxregs.h>
+//#include <asm/rlxregs.h>
 #include "bspchip.h"
 
 #define PCI_8BIT_ACCESS    1
@@ -26,48 +26,35 @@
 #define MAX_NUM_DEV  4
 
 #define DEBUG_PRINTK 0
-//#define PIN_208
+
+#define CLK_MANAGE 	0xb8000010
+#define SYS_PCIE_PHY0   (0xb8000000 +0x50)
+#define SYS_PCIE_PHY1   (0xb8000000 +0x54)
+#define PCIE_PHY0 	0xb8b01008
+#define PCIE_PHY1 	0xb8b21008
+
+#define MAX_PAYLOAD_SIZE_128B 0
 
 static int pci0_bus_number = 0xff;
-static int pci1_bus_number = 0xff;
 
 static struct resource rtl8196b_pci0_io_resource = {
-   .name   = "RTL8196B PCI0 IO",
+   .name   = "RTL8196C PCI0 IO",
    .flags  = IORESOURCE_IO,
    .start  = PADDR(BSP_PCIE0_D_IO),
    .end    = PADDR(BSP_PCIE0_D_IO + 0x1FFFFF)
 };
 
 static struct resource rtl8196b_pci0_mem_resource = {
-   .name   = "RTL8196B PCI0 MEM",
+   .name   = "RTL8196C PCI0 MEM",
    .flags  = IORESOURCE_MEM,
    .start  = PADDR(BSP_PCIE0_D_MEM),
    .end    = PADDR(BSP_PCIE0_D_MEM + 0xFFFFFF)
 };
 
-#ifdef PIN_208
-static struct resource rtl8196b_pci1_io_resource = {
-   .name   = "RTL8196B PCI1 IO",
-   .flags  = IORESOURCE_IO,
-   .start  = PADDR(BSP_PCIE1_D_IO),
-   .end    = PADDR(BSP_PCIE1_D_IO + 0x1FFFFF)
-};
-
-static struct resource rtl8196b_pci1_mem_resource = {
-   .name   = "RTL8196B PCI1 MEM",
-   .flags  = IORESOURCE_MEM,
-   .start  = PADDR(BSP_PCIE1_D_MEM),
-   .end    = PADDR(BSP_PCIE1_D_MEM + 0xFFFFFF)
-};
-#endif
-
-
- 
- 
 //HOST PCIE
 #define PCIE0_RC_EXT_BASE (0xb8b01000)
 //RC Extended register
-#define PCIE0_MDIO (PCIE0_RC_EXT_BASE+0x00)
+#define PCIE0_MDIO	(PCIE0_RC_EXT_BASE+0x00)
 //MDIO
 #define PCIE_MDIO_DATA_OFFSET (16)
 #define PCIE_MDIO_DATA_MASK (0xffff <<PCIE_MDIO_DATA_OFFSET)
@@ -75,153 +62,196 @@ static struct resource rtl8196b_pci1_mem_resource = {
 #define PCIE_MDIO_RDWR_OFFSET (0)
  
 
-void HostPCIe_SetPhyMdioWrite(unsigned int regaddr, unsigned short val)
+//------------------------------------------------------------------------
+unsigned int HostPCIe_SetPhyMdioRead(unsigned int portnum, unsigned int regaddr)
 {
- REG32(PCIE0_MDIO)= ( (regaddr&0x1f)<<PCIE_MDIO_REG_OFFSET) | ((val&0xffff)<<PCIE_MDIO_DATA_OFFSET)  | (1<<PCIE_MDIO_RDWR_OFFSET) ; 
- //delay 
-mdelay(1);//mdelay(10);
+	unsigned int mdioaddr=PCIE0_MDIO;
+/*
+	if(portnum==0)		mdioaddr=PCIE0_MDIO;	
+	else if(portnum==1)	mdioaddr=PCIE1_MDIO;
+	else return 0;
+*/	
+	REG32(mdioaddr)= ((regaddr&0x1f)<<PCIE_MDIO_REG_OFFSET)  | (0<<PCIE_MDIO_RDWR_OFFSET); 
+	//delay 
+	volatile int i;
+	for(i=0;i<5555;i++)  ;
+
+	int val;
+	val=REG32(mdioaddr)&  (0xffff <<PCIE_MDIO_DATA_OFFSET) ;
+	return ((val>>PCIE_MDIO_DATA_OFFSET)&0xffff);
+	
 }
 
-void PCIE_reset_procedure(int PCIE_Port0and1_8196B_208pin, int Use_External_PCIE_CLK, int mdio_reset)
+
+void HostPCIe_SetPhyMdioWrite(unsigned int portnum, unsigned int regaddr, unsigned short val)
 {
-        #define SYS_PCIE_PHY0   (0xb8000000 +0x50)
- //PCIE Register
-  #define CLK_MANAGE  0xb8000010
- 
-  #define PCIE_PHY0_REG  0xb8b01000
-  //#define PCIE_PHY1_REG  0xb8b21000
-  #define PCIE_PHY0  0xb8b01008
- // #define PCIE_PHY1  0xb8b21008
- 
+	unsigned int mdioaddr;
+
+	mdioaddr=PCIE0_MDIO;	
+	
+	REG32(mdioaddr)= ( (regaddr&0x1f)<<PCIE_MDIO_REG_OFFSET) | ((val&0xffff)<<PCIE_MDIO_DATA_OFFSET)  | (1<<PCIE_MDIO_RDWR_OFFSET) ; 
+	//delay 
+	volatile int i;
+	for(i=0;i<5555;i++)  ;
+}
 
-  
-//JSW:PCIE reset procedure
-#if 0
-        //1. "Enable internal PCIE PLL
-//#if Use_External_PCIE_CLK
-if(Use_External_PCIE_CLK)
-    REG32(PIE_PLL) = 0x358;                        //Use External PCIE CLK (clock chip)
-//#else  
-else
-    REG32(PCIE_PLL) = 0x9;                          //Use Internal PCIE CLK and PCIE fine-tune
-//#endif
- 
+//----------------------------------------------------------------------------
+
+void PCIE_MDIO_Reset(unsigned int portnum)
+{
+	unsigned int sys_pcie_phy;
+
+	if (portnum==0)
+		sys_pcie_phy=SYS_PCIE_PHY0;
+	else if (portnum==1)
+		sys_pcie_phy=SYS_PCIE_PHY1;
+	else
+		return;
+		
+	// 3.MDIO Reset
+	REG32(sys_pcie_phy) = (1<<3) |(0<<1) | (0<<0);     //mdio reset=0,     	    
+	REG32(sys_pcie_phy) = (1<<3) |(0<<1) | (1<<0);     //mdio reset=1, 
+	REG32(sys_pcie_phy) = (1<<3) |(1<<1) | (1<<0);     //bit1 load_done=1
+}
+//------------------------------------------------------------------------
+void PCIE_PHY_Reset(unsigned int portnum)
+{
+	unsigned int pcie_phy;
+
+	if(portnum==0)	pcie_phy=PCIE_PHY0;
+	else if(portnum==1)	pcie_phy=PCIE_PHY1;
+	else return;
 
-//prom_printf("\nPCIE_PLL(0x%x)=0x%x\n",PCIE_PLL,READ_MEM32(PCIE_PLL));
-    mdelay(100);//mdelay(10);
-#endif
- 
-        //2.Active LX & PCIE Clock
-    REG32(CLK_MANAGE) |=  (1<<11);        //enable active_pcie0
-    mdelay(100);
- 
-#if 1
- if(mdio_reset)
- {
-  printk("Do MDIO_RESET\n");
-        // 3.MDIO Reset  
-     REG32(SYS_PCIE_PHY0) = (1<<3) |(0<<1) | (0<<0);     //mdio reset=0,          
-     REG32(SYS_PCIE_PHY0) = (1<<3) |(0<<1) | (1<<0);     //mdio reset=1,   
-     REG32(SYS_PCIE_PHY0) = (1<<3) |(1<<1) | (1<<0);     //bit1 load_done=1
- } 
         //4. PCIE PHY Reset       
-    REG32(PCIE_PHY0) = 0x1; //bit7 PHY reset=0   bit0 Enable LTSSM=1
-    REG32(PCIE_PHY0) = 0x81;   //bit7 PHY reset=1   bit0 Enable LTSSM=1
-      mdelay(100);
-   
+	REG32(pcie_phy) = 0x01;	//bit7:PHY reset=0   bit0: Enable LTSSM=1
+	REG32(pcie_phy) = 0x81;   //bit7: PHY reset=1   bit0: Enable LTSSM=1
+	
+}
+//------------------------------------------------------------------------
+int PCIE_Check_Link(unsigned int portnum)
+{
+	unsigned int dbgaddr;
+	unsigned int cfgaddr;
+	
+	if(portnum==0)	dbgaddr=0xb8b00728;
+	else if(portnum==1)	dbgaddr=0xb8b20728;
+	else return;	
+
+  //wait for LinkUP
+#ifdef CONFIG_RTK_VOIP
+	// accelerate when no pcie card 
+	int i=3;
+#else
+	int i=20;
 #endif
+	while(--i)
+	{
+	      if( (REG32(dbgaddr)&0x1f)==0x11)
+		  	break;
+      		mdelay(300);		  
+
+	}
+	if(i==0)
+	{
+		printk("i=%x  Cannot LinkUP \n",i);
+		return 0;
+	}
+	else
+	{
+		printk("\nLink-UP OK\n");
+		cfgaddr=0xb8b10000;
+
+		REG32(cfgaddr+0x04)=0x00100007;
+
+		printk("Find Port=%x Device:Vender ID=%x\n", portnum, REG32(cfgaddr) );
+		REG32(cfgaddr);
+		mdelay(1);
+	}
+	return 1;
+}
+//------------------------------------------------------------------------
+void PCIE_Device_PERST(void)
+{
+	REG32(CLK_MANAGE) &= ~(1<<12);    //perst=0 off.  
+	mdelay(500);   //PCIE standadrd: poweron: 100us, after poweron: 100ms
+	mdelay(500);  		
+	REG32(CLK_MANAGE) |=  (1<<12);   //PERST=1
+	mdelay(500);
+}
+
+//=====================================================================
+int  PCIE_reset_procedure(int portnum, int Use_External_PCIE_CLK, int mdio_reset)
+{
+	int result;
+	 
+	REG32(CLK_MANAGE) |=  (1<<11);        //enable active_pcie0
+
+	mdelay(10);
+	REG32(0xb8b0100c)=(1<<3);  //set target Device Num=1;
+	mdelay(10);
+
+	if (mdio_reset) {
+		printk("Do MDIO_RESET\n");
+		// 3.MDIO Reset
+		PCIE_MDIO_Reset(portnum);
+		mdelay(10);
+	}
+	//4. PCIE PHY Reset       
+	PCIE_PHY_Reset(portnum);
+	mdelay(10);
+	mdelay(10);
  
-        mdelay(100);    
- 
-#if 0
- //#if Use_External_PCIE_CLK
- if(Use_External_PCIE_CLK)
- {
-  //5. PCIE P0 PHY external clock
-   mdelay(100); 
-   REG32(PCIE_PHY0_REG) = 0xC3930301; //bit[3] must be "0" for external clock
-   //REG32(PCIE_PHY0_REG) = 0xC39B0301; //20090304:RDC for for PCIE port 0 Refine-tune
-    mdelay(100);       
-   
-       
-          REG32(PCIE_PHY0_REG) = 0x3c011901; //close PHY 0 ,"0"=R,"1"=W
-          mdelay(100);
- } 
- //#endif
- #endif
- 
- 
-   //----------------------------------------
-   if(mdio_reset)
-    {
- //fix 8196C test chip pcie tx problem. 
-/* 
- HostPCIe_SetPhyMdioWrite( 8, HostPCIe_SetPhyMdioRead(8) | (1<<3) );
- HostPCIe_SetPhyMdioWrite(0x0d, HostPCIe_SetPhyMdioRead(0x0d) | (5<<5) );
- HostPCIe_SetPhyMdioWrite(0x0d,  HostPCIe_SetPhyMdioRead(0x0d) | (1<<4) );
- HostPCIe_SetPhyMdioWrite(0x0f, HostPCIe_SetPhyMdioRead(0x0f) & ~(1<<4));
- HostPCIe_SetPhyMdioWrite(0x06, HostPCIe_SetPhyMdioRead(0x06) | (1<<11) ); 
-*/ 
-  HostPCIe_SetPhyMdioWrite(0, 0x5027);
-  HostPCIe_SetPhyMdioWrite(2, 0x6d18);
-  HostPCIe_SetPhyMdioWrite(6, 0x8828);
-  HostPCIe_SetPhyMdioWrite(7, 0x30ff);
-  HostPCIe_SetPhyMdioWrite(8, 0x18d7);
-  HostPCIe_SetPhyMdioWrite(0xa, 0xe9);
-  HostPCIe_SetPhyMdioWrite(0xb, 0x0511);
-  HostPCIe_SetPhyMdioWrite(0xd, 0x15b6);  
-  HostPCIe_SetPhyMdioWrite(0xf, 0x0f0f);    
-#if 1 // PHY_EAT_40MHZ
-		HostPCIe_SetPhyMdioWrite(5, 0xbcb);    //[9:3]=1111001 (binary)   121 (10)
-		HostPCIe_SetPhyMdioWrite(6, 0x8128);  //[11]=0   [9:8]=01
-#endif  
-/* 
-emdiow 0 5027
-emdiow 2 6d18
-emdiow 6 8828
-emdiow 7 30ff
-emdiow 8 18dd
-emdiow a e9
-emdiow b 0511
-emdiow d 15b6
-emdiow f 0f0f
-*/
-    }
- 
- //---------------------------------------
-         // 6. PCIE Device Reset
-     REG32(CLK_MANAGE) &= ~(1<<12);    //perst=0 off.
-        mdelay(100);   
-        mdelay(100);   
-        mdelay(100);   
-  
-    REG32(CLK_MANAGE) |=  (1<<12);   //PERST=1
-    //prom_printf("\nCLK_MANAGE(0x%x)=0x%x\n\n",CLK_MANAGE,READ_MEM32(CLK_MANAGE));
- 
- 
-        //4. PCIE PHY Reset       
-    REG32(PCIE_PHY0) = 0x1; //bit7 PHY reset=0   bit0 Enable LTSSM=1
-    REG32(PCIE_PHY0) = 0x81;   //bit7 PHY reset=1   bit0 Enable LTSSM=1
-      mdelay(100);
-  mdelay(1000);
-  #if 1  //wait for LinkUP
- int i=100;
- while(--i)
- {
-       if( (REG32(0xb8b00728)&0x1f)==0x11)
-     break;
-          mdelay(100);
- }
- if(i==0)
-  printk("i=%x Cannot LinkUP \n",i);
+	//----------------------------------------
+	if (mdio_reset) {
+		HostPCIe_SetPhyMdioWrite(portnum, 0, 0xD087);  //bokai tell, and fix
+
+		HostPCIe_SetPhyMdioWrite(portnum, 1, 0x0003);
+		HostPCIe_SetPhyMdioWrite(portnum, 2, 0x4d18);
+#ifdef CONFIG_PHY_EAT_40MHZ
+#ifdef CONFIG_HIGH_POWER_EXT_PA
+		HostPCIe_SetPhyMdioWrite(portnum, 5, 0x0BF3);   //40M
+#else
+		HostPCIe_SetPhyMdioWrite(portnum, 5, 0x0BCB);   //40M
+#endif
+#endif
+
+#ifdef  CONFIG_PHY_EAT_40MHZ
+		HostPCIe_SetPhyMdioWrite(portnum, 6, 0xF148);  //40M
+#else
+		HostPCIe_SetPhyMdioWrite(portnum, 6, 0xf848);  //25M
 #endif
- 
-printk("devid=%x\n",REG32(0xb8b10000));
-   
- 
-}
 
+		HostPCIe_SetPhyMdioWrite(portnum, 7, 0x31ff);
+		HostPCIe_SetPhyMdioWrite(portnum, 8, 0x18d7);  //peisi tune
 
+#if 0       //old,		
+		HostPCIe_SetPhyMdioWrite(portnum, 9, 0x531c); 		
+		HostPCIe_SetPhyMdioWrite(portnum, 0xd, 0x1766); //peisi tune
+#else     //saving more power, 8196c pe-si tune
+		HostPCIe_SetPhyMdioWrite(portnum, 0x09, 0x539c); 	
+		HostPCIe_SetPhyMdioWrite(portnum, 0x0a, 0x20eb); 	
+		HostPCIe_SetPhyMdioWrite(portnum, 0x0d, 0x1764); 			
+#endif
+		HostPCIe_SetPhyMdioWrite(portnum, 0x0b, 0x0511);   //for sloving low performance
+
+		HostPCIe_SetPhyMdioWrite(portnum, 0xf, 0x0a00);	
+		HostPCIe_SetPhyMdioWrite(portnum, 0x19, 0xFCE0);
+		 
+		HostPCIe_SetPhyMdioWrite(portnum, 0x1e, 0xC280);	
+	}
+ 
+	//---------------------------------------
+	PCIE_Device_PERST();
+
+	PCIE_PHY_Reset(portnum);	  
+	mdelay(500);
+	REG32(0xb8b00000 + 0x04)= 0x00100007;
+	REG8(0xb8b00000 + 0x78)=((REG8(0xb8b00000 + 0x78) & (~0xE0)) | MAX_PAYLOAD_SIZE_128B);
+	mdelay(500);
+	result=PCIE_Check_Link(portnum);
+	return result;
+}
+//========================================================================================
 
 static int rtl8196b_pcibios_config_access(unsigned char access_type,
        unsigned int addr, unsigned int *data)
@@ -253,7 +283,7 @@ static int rtl8196b_pcibios_config_access(unsigned char access_type,
 }
 
 
-
+//========================================================================================
 /*
  * RTL8196b supports config word read access for 8/16/32 bit
  *
@@ -268,8 +298,8 @@ static int rtl8196b_pcibios0_read(struct pci_bus *bus, unsigned int devfn,
    if (pci0_bus_number == 0xff)
       pci0_bus_number = bus->number;
    #if DEBUG_PRINTK
-   printk("File: %s, Function: %s, Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
-   printk("Bus: %d, Slot: %d, Func: %d, Where: %d, Size: %d\n", bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn), where, size);
+	//printk("File: %s, Function: %s, Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
+   //printk("Bus: %d, Slot: %d, Func: %d, Where: %d, Size: %d\n", bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn), where, size);
    #endif
 
    if (bus->number == pci0_bus_number)
@@ -321,14 +351,14 @@ static int rtl8196b_pcibios0_read(struct pci_bus *bus, unsigned int devfn,
    }
 
    #if DEBUG_PRINTK
-   printk("File: %s, Function: %s, Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
-   printk("Read Value: 0x%08X\n", *val);
+	//printk("File: %s, Function: %s, Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
+   //printk("Read Value: 0x%08X\n", *val);
    #endif
 
    return PCIBIOS_SUCCESSFUL;
 }
 
-
+//========================================================================================
 static int rtl8196b_pcibios0_write(struct pci_bus *bus, unsigned int devfn,
                                    int where, int size, unsigned int val)
 {
@@ -340,8 +370,8 @@ static int rtl8196b_pcibios0_write(struct pci_bus *bus, unsigned int devfn,
       pci0_bus_number = bus->number;
 
    #if DEBUG_PRINTK
-   printk("File: %s, Function: %s, Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
-   printk("Bus: %d, Slot: %d, Func: %d, Where: %d, Size: %d\n", bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn), where, size);
+   //printk("File: %s, Function: %s, Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
+   //printk("Bus: %d, Slot: %d, Func: %d, Where: %d, Size: %d\n", bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn), where, size);
    #endif
 
    if (bus->number == pci0_bus_number)
@@ -397,183 +427,21 @@ static int rtl8196b_pcibios0_write(struct pci_bus *bus, unsigned int devfn,
 
    return PCIBIOS_SUCCESSFUL;
 }
+//========================================================================================
 
-
-/*
- * RTL8196b supports config word read access for 8/16/32 bit
- *
- * FIXME: currently only utilize 32bit access
- */
-#ifdef PIN_208
-static int rtl8196b_pcibios1_read(struct pci_bus *bus, unsigned int devfn,
-                                  int where, int size, unsigned int *val)
-{
-   unsigned int data = 0;
-   unsigned int addr = 0;
-
-   if (pci1_bus_number == 0xff)
-      pci1_bus_number = bus->number;
-
-   #if DEBUG_PRINTK
-   printk("File: %s, Function: %s, Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
-   printk("Bus: %d, Slot: %d, Func: %d, Where: %d, Size: %d\n", bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn), where, size);
-   #endif
-
-   if (bus->number == pci1_bus_number)
-   {
-      /* PCIE host controller */
-      if (PCI_SLOT(devfn) == 0)
-      {
-         addr = BSP_PCIE1_H_CFG + where;
-
-         if (rtl8196b_pcibios_config_access(PCI_ACCESS_READ | PCI_32BIT_ACCESS, addr & ~(0x3), &data))
-            return PCIBIOS_DEVICE_NOT_FOUND;
-
-         if (size == 1)
-            *val = (data >> ((where & 3) << 3)) & 0xff;
-         else if (size == 2)
-            *val = (data >> ((where & 3) << 3)) & 0xffff;
-         else
-            *val = data;
-      }
-      else
-         return PCIBIOS_DEVICE_NOT_FOUND;
-   }
-   else if (bus->number == (pci1_bus_number + 1))
-   {
-      /* PCIE devices directly connected */
-      if (PCI_SLOT(devfn) == 0)
-      {
-         addr = BSP_PCIE1_D_CFG0 + (PCI_FUNC(devfn) << 12) + where;
-
-         if (rtl8196b_pcibios_config_access(PCI_ACCESS_READ | size, addr, val))
-            return PCIBIOS_DEVICE_NOT_FOUND;
-      }
-      else
-         return PCIBIOS_DEVICE_NOT_FOUND;
-   }
-   else
-   {
-      /* Devices connected through bridge */
-      if (PCI_SLOT(devfn) < MAX_NUM_DEV)
-      {
-         WRITE_MEM32(BSP_PCIE1_H_IPCFG, ((bus->number) << 8) | (PCI_SLOT(devfn) << 3) | PCI_FUNC(devfn));
-         addr = BSP_PCIE1_D_CFG1 + where;
-
-         if (rtl8196b_pcibios_config_access(PCI_ACCESS_READ | size, addr, val))
-            return PCIBIOS_DEVICE_NOT_FOUND;
-      }
-      else
-         return PCIBIOS_DEVICE_NOT_FOUND;
-   }
-
-   #if DEBUG_PRINTK
-   printk("File: %s, Function: %s, Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
-   printk("Read Value: 0x%08X\n", *val);
-   #endif
-
-   return PCIBIOS_SUCCESSFUL;
-}
-
-
-static int rtl8196b_pcibios1_write(struct pci_bus *bus, unsigned int devfn,
-                                   int where, int size, unsigned int val)
-{
-   unsigned int data = 0;
-   unsigned int addr = 0;
-
-   static int pci1_bus_number = 0xff;
-
-   if (pci1_bus_number == 0xff)
-      pci1_bus_number = bus->number;
-
-   #if DEBUG_PRINTK
-   printk("File: %s, Function: %s, Line: %d\n", __FILE__, __FUNCTION__, __LINE__);
-   printk("Bus: %d, Slot: %d, Func: %d, Where: %d, Size: %d\n", bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn), where, size);
-   #endif
-
-
-   if (bus->number == pci1_bus_number)
-   {
-      /* PCIE host controller */
-      if (PCI_SLOT(devfn) == 0)
-      {
-         addr = BSP_PCIE1_H_CFG + where;
-
-         if (rtl8196b_pcibios_config_access(PCI_ACCESS_READ | PCI_32BIT_ACCESS, addr & ~(0x3), &data))
-            return PCIBIOS_DEVICE_NOT_FOUND;
-
-         if (size == 1)
-            data = (data & ~(0xff << ((where & 3) << 3))) | (val << ((where & 3) << 3));
-         else if (size == 2)
-            data = (data & ~(0xffff << ((where & 3) << 3))) | (val << ((where & 3) << 3));
-         else
-            data = val;
-
-         if (rtl8196b_pcibios_config_access(PCI_ACCESS_WRITE | PCI_32BIT_ACCESS, addr & ~(0x3), &data))
-            return PCIBIOS_DEVICE_NOT_FOUND;
-      }
-      else
-         return PCIBIOS_DEVICE_NOT_FOUND;
-   }
-   else if (bus->number == (pci1_bus_number + 1))
-   {
-      /* PCIE devices directly connected */
-      if (PCI_SLOT(devfn) == 0)
-      {
-         addr = BSP_PCIE1_D_CFG0 + (PCI_FUNC(devfn) << 12) + where;
-
-         if (rtl8196b_pcibios_config_access(PCI_ACCESS_WRITE | size, addr, &val))
-            return PCIBIOS_DEVICE_NOT_FOUND;
-      }
-      else
-         return PCIBIOS_DEVICE_NOT_FOUND;
-   }
-   else
-   {
-      /* Devices connected through bridge */
-      if (PCI_SLOT(devfn) < MAX_NUM_DEV)
-      {
-         WRITE_MEM32(BSP_PCIE1_H_IPCFG, ((bus->number) << 8) | (PCI_SLOT(devfn) << 3) | PCI_FUNC(devfn));
-         addr = BSP_PCIE1_D_CFG1 + where;
-
-         if (rtl8196b_pcibios_config_access(PCI_ACCESS_WRITE | size, addr, &val))
-            return PCIBIOS_DEVICE_NOT_FOUND;
-      }
-      else
-         return PCIBIOS_DEVICE_NOT_FOUND;
-   }
-
-   return PCIBIOS_SUCCESSFUL;
-}
-#endif
-
+//========================================================================================
 struct pci_ops rtl8196b_pci0_ops = {
    .read = rtl8196b_pcibios0_read,
    .write = rtl8196b_pcibios0_write
 };
 
-#ifdef PIN_208
-struct pci_ops rtl8196b_pci1_ops = {
-   .read = rtl8196b_pcibios1_read,
-   .write = rtl8196b_pcibios1_write
-};
-#endif
-
 static struct pci_controller rtl8196b_pci0_controller = {
    .pci_ops        = &rtl8196b_pci0_ops,
    .mem_resource   = &rtl8196b_pci0_mem_resource,
    .io_resource    = &rtl8196b_pci0_io_resource,
 };
 
-#ifdef PIN_208
-static struct pci_controller rtl8196b_pci1_controller = {
-   .pci_ops        = &rtl8196b_pci1_ops,
-   .mem_resource   = &rtl8196b_pci1_mem_resource,
-   .io_resource    = &rtl8196b_pci1_io_resource,
-};
-#endif
-
+//========================================================================================
 int pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
 {
    #if DEBUG_PRINTK
@@ -583,12 +451,9 @@ int pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
    printk("**Dev->BUS->Number: %d\n", dev->bus->number);
    #endif
 
-   if (dev->bus->number < pci1_bus_number)
-      return BSP_PCIE_IRQ;
-   else
-      return BSP_PCIE2_IRQ;
+   return BSP_PCIE_IRQ;
 }
-
+//========================================================================================
 /* Do platform specific device initialization at pci_enable_device() time */
 int pcibios_plat_dev_init(struct pci_dev *dev)
 {
@@ -601,21 +466,18 @@ int pcibios_plat_dev_init(struct pci_dev *dev)
 
 static __init int bsp_pcie_init(void)
 {
-   //rtl8196b_pci_reset();
-   PCIE_reset_procedure(0,0,1);
 
-#if DEBUG_PRINTK
-   printk("<<<<<Register 1st PCI Controller>>>>>\n");
-#ifdef PIN_208
-   printk("<<<<<Register 2nd PCI Controller>>>>>\n");
-#endif
-#endif
+	int result=0;
 
-   register_pci_controller(&rtl8196b_pci0_controller);
-#ifdef PIN_208
-   register_pci_controller(&rtl8196b_pci1_controller);
-#endif
-   return 0;
+	printk("<<<<<Register 1st PCI Controller>>>>>\n");
+	mdelay(1);
+
+	result=PCIE_reset_procedure(0, 0, 1);
+	if (result)
+		register_pci_controller(&rtl8196b_pci0_controller);
+	else
+		REG32(CLK_MANAGE) &=  (~(1<<11));        //disable active_pcie0
+	return 0;
 }
 
 arch_initcall(bsp_pcie_init);
diff --git a/arch/rlx/bsp/serial.c b/arch/rlx/bsp/serial.c
index 134a998..d2959b4 100644
--- a/arch/rlx/bsp/serial.c
+++ b/arch/rlx/bsp/serial.c
@@ -39,7 +39,7 @@ void __init bsp_serial_init(void)
 	s.uartclk = BSP_SYS_CLK_RATE;
     s.fifosize = 16;
 	//s.flags = UPF_SKIP_TEST | UPF_LOW_LATENCY;
-	s.flags = UPF_SKIP_TEST;
+	s.flags = UPF_SKIP_TEST; 
 	s.mapbase = BSP_UART0_MAP_BASE;
 	//s.membase = ioremap_nocache(s.mapbase, BSP_UART0_MAPSIZE);
 	s.membase = ioremap_nocache(s.mapbase, 0x20);
diff --git a/arch/rlx/include/asm/atomic.h b/arch/rlx/include/asm/atomic.h
index b042aa2..3cd0c4b 100644
--- a/arch/rlx/include/asm/atomic.h
+++ b/arch/rlx/include/asm/atomic.h
@@ -47,36 +47,35 @@
  *
  * Atomically adds @i to @v.
  */
+
 static __inline__ void atomic_add(int i, atomic_t * v)
 {
 #ifdef CONFIG_CPU_HAS_LLSC
-		int temp;
+	int temp;
 
     smp_llsc_mb();
 
-		__asm__ __volatile__(
-		"	.set	mips3					\n"
-		"1:	ll	%0, %1		# atomic_add		\n"
+	__asm__ __volatile__(
+		"1:	ll	%0, %1		# atomic_add    \n"
 #if defined(CONFIG_CPU_RLX4181) || defined(CONFIG_CPU_RLX5181) || defined(CONFIG_CPU_RLX5281)
                 "       nop                                             \n"
 #endif
 		"	addu	%0, %2					\n"
-		"	sc	%0, %1					\n"
+		"	sc	%0, %1                      \n"
 		"	beqz	%0, 2f					\n"
 		"	.subsection 2					\n"
-		"2:	b	1b					\n"
-		"	.previous					\n"
-		"	.set	mips0					\n"
+		"2:	b	1b                          \n"
+		"	.previous                       \n"
 		: "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter));
 
     smp_llsc_mb();
 #else
-		unsigned long flags;
+	unsigned long flags;
 
-		raw_local_irq_save(flags);
-		v->counter += i;
-		raw_local_irq_restore(flags);
+	raw_local_irq_save(flags);
+	v->counter += i;
+	raw_local_irq_restore(flags);
 #endif
 }
 
@@ -90,11 +89,11 @@ static __inline__ void atomic_add(int i, atomic_t * v)
 static __inline__ void atomic_sub(int i, atomic_t * v)
 {
 #ifdef CONFIG_CPU_HAS_LLSC
-		int temp;
+	int temp;
 
     smp_llsc_mb();
 
-		__asm__ __volatile__(
+	__asm__ __volatile__(
 		"1:	ll	    %0, %1		# atomic_sub		\n"
 #if defined(CONFIG_CPU_RLX4181) || defined(CONFIG_CPU_RLX5181) || defined(CONFIG_CPU_RLX5281)
                 "       nop                                             \n"
@@ -110,11 +109,11 @@ static __inline__ void atomic_sub(int i, atomic_t * v)
 
     smp_llsc_mb();
 #else
-		unsigned long flags;
+	unsigned long flags;
 
-		raw_local_irq_save(flags);
-		v->counter -= i;
-		raw_local_irq_restore(flags);
+	raw_local_irq_save(flags);
+	v->counter -= i;
+	raw_local_irq_restore(flags);
 #endif
 }
 
@@ -128,7 +127,7 @@ static __inline__ int atomic_add_return(int i, atomic_t * v)
     int temp;
 	smp_llsc_mb();
 
-		__asm__ __volatile__(
+	__asm__ __volatile__(
 		"1:	ll	%1, %2		# atomic_add_return	\n"
 #if defined(CONFIG_CPU_RLX4181) || defined(CONFIG_CPU_RLX5181) || defined(CONFIG_CPU_RLX5281)
                 "       nop                                             \n"
@@ -149,11 +148,11 @@ static __inline__ int atomic_add_return(int i, atomic_t * v)
 	int result;
     unsigned long flags;
 
-		raw_local_irq_save(flags);
-		result = v->counter;
-		result += i;
-		v->counter = result;
-		raw_local_irq_restore(flags);
+	raw_local_irq_save(flags);
+	result = v->counter;
+	result += i;
+	v->counter = result;
+	raw_local_irq_restore(flags);
 #endif
 
 	return result;
@@ -167,7 +166,7 @@ static __inline__ int atomic_sub_return(int i, atomic_t * v)
 
 	smp_llsc_mb();
 
-		__asm__ __volatile__(
+	__asm__ __volatile__(
 		"1:	ll	%1, %2		# atomic_sub_return	\n"
 #if defined(CONFIG_CPU_RLX4181) || defined(CONFIG_CPU_RLX5181) || defined(CONFIG_CPU_RLX5281)
                 "       nop                                             \n"
@@ -188,11 +187,11 @@ static __inline__ int atomic_sub_return(int i, atomic_t * v)
     unsigned long flags;
 	int result;
 
-		raw_local_irq_save(flags);
-		result = v->counter;
-		result -= i;
-		v->counter = result;
-		raw_local_irq_restore(flags);
+	raw_local_irq_save(flags);
+	result = v->counter;
+	result -= i;
+	v->counter = result;
+	raw_local_irq_restore(flags);
 
 #endif
 
@@ -215,7 +214,7 @@ static __inline__ int atomic_sub_if_positive(int i, atomic_t * v)
 
 	smp_llsc_mb();
 
-		__asm__ __volatile__(
+	__asm__ __volatile__(
 		"1:	ll	%1, %2		# atomic_sub_if_positive\n"
 #if defined(CONFIG_CPU_RLX4181) || defined(CONFIG_CPU_RLX5181) || defined(CONFIG_CPU_RLX5281)
                 "       nop                                             \n"
@@ -240,12 +239,12 @@ static __inline__ int atomic_sub_if_positive(int i, atomic_t * v)
     unsigned long flags;
 	int result;
 
-		raw_local_irq_save(flags);
-		result = v->counter;
-		result -= i;
-		if (result >= 0)
-			v->counter = result;
-		raw_local_irq_restore(flags);
+	raw_local_irq_save(flags);
+	result = v->counter;
+	result -= i;
+	if (result >= 0)
+		v->counter = result;
+	raw_local_irq_restore(flags);
 #endif
 
 	return result;
diff --git a/arch/rlx/include/asm/barrier.h b/arch/rlx/include/asm/barrier.h
index 0d897ce..8ae6695 100644
--- a/arch/rlx/include/asm/barrier.h
+++ b/arch/rlx/include/asm/barrier.h
@@ -74,7 +74,7 @@
 		: /* no input */		\
 		: "memory")
 #else
-#define __sync()	do { } while(0)
+#define __sync()	__asm__ __volatile__("" : : :"memory")
 #endif
 
 #define __fast_iob()				\
diff --git a/arch/rlx/include/asm/cmpxchg.h b/arch/rlx/include/asm/cmpxchg.h
index dbf73e8..ea95fdb 100644
--- a/arch/rlx/include/asm/cmpxchg.h
+++ b/arch/rlx/include/asm/cmpxchg.h
@@ -21,13 +21,10 @@
                 __asm__ __volatile__(                                   \
                 "       .set    push                            \n"     \
                 "       .set    noat                            \n"     \
-                "       .set    mips3                           \n"     \
                 "1:     " ld "  %0, %2          # __cmpxchg_asm \n"     \
 		"	nop					\n"	\
                 "       bne     %0, %z3, 2f                     \n"     \
-                "       .set    mips0                           \n"     \
                 "       move    $1, %z4                         \n"     \
-                "       .set    mips3                           \n"     \
                 "       " st "  $1, %1                          \n"     \
                 "       beqz    $1, 3f                          \n"     \
                 "2:                                             \n"     \
@@ -48,12 +45,9 @@
 		__asm__ __volatile__(					\
 		"	.set	push				\n"	\
 		"	.set	noat				\n"	\
-		"	.set	mips3				\n"	\
 		"1:	" ld "	%0, %2		# __cmpxchg_asm	\n"	\
 		"	bne	%0, %z3, 2f			\n"	\
-		"	.set	mips0				\n"	\
 		"	move	$1, %z4				\n"	\
-		"	.set	mips3				\n"	\
 		"	" st "	$1, %1				\n"	\
 		"	beqz	$1, 3f				\n"	\
 		"2:						\n"	\
@@ -71,13 +65,13 @@
 #define __cmpxchg_asm(ld, st, m, old, new)				\
 ({									\
 	__typeof(*(m)) __ret;						\
-		unsigned long __flags;					\
+	unsigned long __flags;					\
 									\
-		raw_local_irq_save(__flags);				\
-		__ret = *m;						\
-		if (__ret == old)					\
-			*m = new;					\
-		raw_local_irq_restore(__flags);				\
+	raw_local_irq_save(__flags);				\
+	__ret = *m;						\
+	if (__ret == old)					\
+		*m = new;					\
+	raw_local_irq_restore(__flags);				\
 									\
 	__ret;								\
 })
diff --git a/arch/rlx/include/asm/futex.h b/arch/rlx/include/asm/futex.h
index bab40d0..17cdbc9 100644
--- a/arch/rlx/include/asm/futex.h
+++ b/arch/rlx/include/asm/futex.h
@@ -21,23 +21,19 @@
 		__asm__ __volatile__(					\
 		"	.set	push				\n"	\
 		"	.set	noat				\n"	\
-		"	.set	mips3				\n"	\
-		"1:	ll	%1, %4	# __futex_atomic_op	\n"	\
+		"1:	ll	    %1, %4	# __futex_atomic_op	\n"	\
 #if defined(CONFIG_CPU_RLX4181) || defined(CONFIG_CPU_RLX5181) || defined(CONFIG_CPU_RLX5281)
                 "       nop                                     \n"	\
 #endif
-		"	.set	mips0				\n"	\
 		"	" insn	"				\n"	\
-		"	.set	mips3				\n"	\
-		"2:	sc	$1, %2				\n"	\
+		"2:	sc	    $1, %2				\n"	\
 		"	beqz	$1, 1b				\n"	\
 		__WEAK_LLSC_MB						\
 		"3:						\n"	\
 		"	.set	pop				\n"	\
-		"	.set	mips0				\n"	\
 		"	.section .fixup,\"ax\"			\n"	\
-		"4:	li	%0, %6				\n"	\
-		"	j	3b				\n"	\
+		"4:	li	    %0, %6				\n"	\
+		"	j	    3b				\n"	\
 		"	.previous				\n"	\
 		"	.section __ex_table,\"a\"		\n"	\
 		"	"__UA_ADDR "\t1b, 4b			\n"	\
@@ -50,7 +46,7 @@
 #else
 #define __futex_atomic_op(insn, ret, oldval, uaddr, oparg)		\
 {									\
-		ret = -ENOSYS;						\
+	ret = -ENOSYS;						\
 }
 #endif
 
@@ -124,15 +120,12 @@ futex_atomic_cmpxchg_inatomic(int __user *uaddr, int oldval, int newval)
 		"# futex_atomic_cmpxchg_inatomic			\n"
 		"	.set	push					\n"
 		"	.set	noat					\n"
-		"	.set	mips3					\n"
 		"1:	ll	%0, %2					\n"
 #if defined(CONFIG_CPU_RLX4181) || defined(CONFIG_CPU_RLX5181) || defined(CONFIG_CPU_RLX5281)
                 "       nop                                             \n"
 #endif
 		"	bne	%0, %z3, 3f				\n"
-		"	.set	mips0					\n"
 		"	move	$1, %z4					\n"
-		"	.set	mips3					\n"
 		"2:	sc	$1, %1					\n"
 		"	beqz	$1, 1b					\n"
 		__WEAK_LLSC_MB
diff --git a/arch/rlx/include/asm/local.h b/arch/rlx/include/asm/local.h
index 889cc4a..797a87e 100644
--- a/arch/rlx/include/asm/local.h
+++ b/arch/rlx/include/asm/local.h
@@ -26,13 +26,11 @@ typedef struct
  */
 static __inline__ long local_add_return(long i, local_t * l)
 {
-	unsigned long result;
-
 #ifdef CONFIG_CPU_HAS_LLSC
-		unsigned long temp;
+	unsigned long result;
+	unsigned long temp;
 
-		__asm__ __volatile__(
-		"	.set	mips3					\n"
+	__asm__ __volatile__(
 		"1: ll      %1, %2		# local_add_return	\n"
 #if defined(CONFIG_CPU_RLX4181) || defined(CONFIG_CPU_RLX5181) || defined(CONFIG_CPU_RLX5281)
                 "       nop                                             \n"
@@ -41,18 +39,18 @@ static __inline__ long local_add_return(long i, local_t * l)
 		"	sc      %0, %2					\n"
 		"	beqz	%0, 1b					\n"
 		"	addu	%0, %1, %3				\n"
-		"	.set	mips0					\n"
 		: "=&r" (result), "=&r" (temp), "=m" (l->a.counter)
 		: "Ir" (i), "m" (l->a.counter)
 		: "memory");
 #else
-		unsigned long flags;
+	unsigned long result;
+	unsigned long flags;
 
-		local_irq_save(flags);
-		result = l->a.counter;
-		result += i;
-		l->a.counter = result;
-		local_irq_restore(flags);
+	local_irq_save(flags);
+	result = l->a.counter;
+	result += i;
+	l->a.counter = result;
+	local_irq_restore(flags);
 #endif
 
 	return result;
@@ -60,13 +58,11 @@ static __inline__ long local_add_return(long i, local_t * l)
 
 static __inline__ long local_sub_return(long i, local_t * l)
 {
-	unsigned long result;
-
 #ifdef CONFIG_CPU_HAS_LLSC
-		unsigned long temp;
+	unsigned long result;
+	unsigned long temp;
 
-		__asm__ __volatile__(
-		"	.set	mips3					\n"
+	__asm__ __volatile__(
 		"1: ll      %1, %2		# local_sub_return	\n"
 #if defined(CONFIG_CPU_RLX4181) || defined(CONFIG_CPU_RLX5181) || defined(CONFIG_CPU_RLX5281)
                 "       nop                                             \n"
@@ -75,18 +71,18 @@ static __inline__ long local_sub_return(long i, local_t * l)
 		"	sc      %0, %2					\n"
 		"	beqz	%0, 1b					\n"
 		"	subu	%0, %1, %3				\n"
-		"	.set	mips0					\n"
 		: "=&r" (result), "=&r" (temp), "=m" (l->a.counter)
 		: "Ir" (i), "m" (l->a.counter)
 		: "memory");
 #else
-		unsigned long flags;
+	unsigned long result;
+	unsigned long flags;
 
-		local_irq_save(flags);
-		result = l->a.counter;
-		result -= i;
-		l->a.counter = result;
-		local_irq_restore(flags);
+	local_irq_save(flags);
+	result = l->a.counter;
+	result -= i;
+	l->a.counter = result;
+	local_irq_restore(flags);
 #endif
 
 	return result;
diff --git a/arch/rlx/include/asm/spinlock.h b/arch/rlx/include/asm/spinlock.h
index fc33c78..996c825 100644
--- a/arch/rlx/include/asm/spinlock.h
+++ b/arch/rlx/include/asm/spinlock.h
@@ -63,6 +63,9 @@ static inline void __raw_spin_lock(raw_spinlock_t *lock)
 		"	.set noreorder					\n"
 		"							\n"
 		"	ll	%[ticket], %[ticket_ptr]		\n"
+#if defined(CONFIG_CPU_RLX4181) || defined(CONFIG_CPU_RLX5181)
+		"	nop							\n"
+#endif
 		"1:	addiu	%[my_ticket], %[ticket], 0x4000		\n"
 		"	sc	%[my_ticket], %[ticket_ptr]		\n"
 		"	beqz	%[my_ticket], 3f			\n"
@@ -134,6 +137,9 @@ static inline unsigned int __raw_spin_trylock(raw_spinlock_t *lock)
 		"	.set noreorder					\n"
 		"							\n"
 		"	ll	%[ticket], %[ticket_ptr]		\n"
+#if defined(CONFIG_CPU_RLX4181) || defined(CONFIG_CPU_RLX5181)
+		"	nop							\n"
+#endif
 		"1:	srl	%[my_ticket], %[ticket], 14		\n"
 		"	andi	%[my_ticket], %[my_ticket], 0x1fff	\n"
 		"	andi	%[now_serving], %[ticket], 0x1fff	\n"
@@ -188,6 +194,9 @@ static inline void __raw_read_lock(raw_rwlock_t *rw)
 		__asm__ __volatile__(
 		"	.set	noreorder	# __raw_read_lock	\n"
 		"1:	ll	%1, %2					\n"
+#if defined(CONFIG_CPU_RLX4181) || defined(CONFIG_CPU_RLX5181)
+		"	nop							\n"
+#endif
 		"	bltz	%1, 2f					\n"
 		"	 addu	%1, 1					\n"
 		"	sc	%1, %0					\n"
@@ -195,6 +204,9 @@ static inline void __raw_read_lock(raw_rwlock_t *rw)
 		"	 nop						\n"
 		"	.subsection 2					\n"
 		"2:	ll	%1, %2					\n"
+#if defined(CONFIG_CPU_RLX4181) || defined(CONFIG_CPU_RLX5181)
+		"	nop							\n"
+#endif
 		"	bltz	%1, 2b					\n"
 		"	 addu	%1, 1					\n"
 		"	b	1b					\n"
@@ -220,6 +232,9 @@ static inline void __raw_read_unlock(raw_rwlock_t *rw)
 		__asm__ __volatile__(
 		"	.set	noreorder	# __raw_read_unlock	\n"
 		"1:	ll	%1, %2					\n"
+#if defined(CONFIG_CPU_RLX4181) || defined(CONFIG_CPU_RLX5181)
+		"	nop							\n"
+#endif
 		"	sub	%1, 1					\n"
 		"	sc	%1, %0					\n"
 		"	beqz	%1, 2f					\n"
@@ -241,6 +256,9 @@ static inline void __raw_write_lock(raw_rwlock_t *rw)
 		__asm__ __volatile__(
 		"	.set	noreorder	# __raw_write_lock	\n"
 		"1:	ll	%1, %2					\n"
+#if defined(CONFIG_CPU_RLX4181) || defined(CONFIG_CPU_RLX5181)
+		"	nop							\n"
+#endif
 		"	bnez	%1, 2f					\n"
 		"	 lui	%1, 0x8000				\n"
 		"	sc	%1, %0					\n"
@@ -248,6 +266,9 @@ static inline void __raw_write_lock(raw_rwlock_t *rw)
 		"	 nop						\n"
 		"	.subsection 2					\n"
 		"2:	ll	%1, %2					\n"
+#if defined(CONFIG_CPU_RLX4181) || defined(CONFIG_CPU_RLX5181)
+		"	nop							\n"
+#endif
 		"	bnez	%1, 2b					\n"
 		"	 lui	%1, 0x8000				\n"
 		"	b	1b					\n"
@@ -282,6 +303,9 @@ static inline int __raw_read_trylock(raw_rwlock_t *rw)
 		"	.set	noreorder	# __raw_read_trylock	\n"
 		"	li	%2, 0					\n"
 		"1:	ll	%1, %3					\n"
+#if defined(CONFIG_CPU_RLX4181) || defined(CONFIG_CPU_RLX5181)
+		"	nop							\n"
+#endif
 		"	bltz	%1, 2f					\n"
 		"	 addu	%1, 1					\n"
 		"	sc	%1, %0					\n"
@@ -307,6 +331,9 @@ static inline int __raw_write_trylock(raw_rwlock_t *rw)
 		"	.set	noreorder	# __raw_write_trylock	\n"
 		"	li	%2, 0					\n"
 		"1:	ll	%1, %3					\n"
+#if defined(CONFIG_CPU_RLX4181) || defined(CONFIG_CPU_RLX5181)
+		"	nop							\n"
+#endif
 		"	bnez	%1, 2f					\n"
 		"	lui	%1, 0x8000				\n"
 		"	sc	%1, %0					\n"
diff --git a/arch/rlx/include/asm/string.h b/arch/rlx/include/asm/string.h
index a25225f..4a587f7 100644
--- a/arch/rlx/include/asm/string.h
+++ b/arch/rlx/include/asm/string.h
@@ -82,7 +82,7 @@ static __inline__ int strcmp(__const__ char *__cs, __const__ char *__ct)
 	"addiu\t%1,1\n\t"
 	"bnez\t%2,1b\n\t"
 	"lbu\t%2,(%0)\n\t"
-#if defined(CONFIG_CPU_RLX4180) || defined(CONFIG_CPU_RLX4181) || defined(CONFIG_CPU_RLX5181)
+#if defined(CONFIG_CPU_RLX4181) || defined(CONFIG_CPU_RLX5181)
 	"nop\n\t"
 #endif
 	"move\t%2,$1\n"
@@ -115,7 +115,7 @@ strncmp(__const__ char *__cs, __const__ char *__ct, size_t __count)
 	"bnez\t%3,1b\n\t"
 	"addiu\t%1,1\n"
 	"2:\n\t"
-#if defined(CONFIG_CPU_RLX4180) || defined(CONFIG_CPU_RLX4181) || defined(CONFIG_CPU_RLX5181)
+#if defined(CONFIG_CPU_RLX4181) || defined(CONFIG_CPU_RLX5181)
 	"nop\n\t"
 #endif
 	"move\t%3,$1\n"
@@ -123,7 +123,7 @@ strncmp(__const__ char *__cs, __const__ char *__ct, size_t __count)
 	".set\tat\n\t"
 	".set\treorder"
 	: "=r" (__cs), "=r" (__ct), "=r" (__count), "=r" (__res)
-	: "0" (__cs), "1" (__ct), "2" (__count),  "m" (*__cs), "m" (*__ct));
+	: "0" (__cs), "1" (__ct), "2" (__count), "m" (*__cs), "m" (*__ct));
 
 	return __res;
 }
diff --git a/arch/rlx/kernel/irq.c b/arch/rlx/kernel/irq.c
index 51e9442..9637605 100644
--- a/arch/rlx/kernel/irq.c
+++ b/arch/rlx/kernel/irq.c
@@ -172,6 +172,13 @@ skip:
 		static int first_dump = 1;
 		static int hw_int_off, vec_int_off;
 #endif
+#ifdef CONFIG_RTL_819X_SWCORE
+		extern int cnt_swcore;
+		extern int cnt_swcore_tx;
+		extern int cnt_swcore_rx;
+		extern int cnt_swcore_link;
+		extern int cnt_swcore_err;
+#endif
 
 		seq_printf(p, "\n");
 #if defined(CONFIG_RTK_VOIP) || defined(CONFIG_RTL_819X)
@@ -213,6 +220,13 @@ skip:
 		seq_printf(p, "VEC: %10u\n", vec_int + vec_int_off);
 #endif
 
+#ifdef CONFIG_RTL_819X_SWCORE
+		seq_printf(p, "\n SW: %10u\n", cnt_swcore);
+		seq_printf(p, " TX: %10u\n", cnt_swcore_tx);
+		seq_printf(p, " RX: %10u\n", cnt_swcore_rx);
+		seq_printf(p, "LNK: %10u\n", cnt_swcore_link);
+		seq_printf(p, "ERR: %10u\n", cnt_swcore_err);
+#endif
 	}
 	return 0;
 }
diff --git a/arch/rlx/kernel/irq_vec.c b/arch/rlx/kernel/irq_vec.c
index 0fcda87..61394fc 100644
--- a/arch/rlx/kernel/irq_vec.c
+++ b/arch/rlx/kernel/irq_vec.c
@@ -33,7 +33,7 @@ static void mask_rlx_vec_irq(unsigned int irq)
 }
 
 static struct irq_chip rlx_vec_irq_controller = {
-	.typename	= "RLX LOPI",
+	.name		= "RLX LOPI",
 	.ack		= mask_rlx_vec_irq,
 	.mask		= mask_rlx_vec_irq,
 	.mask_ack	= mask_rlx_vec_irq,
@@ -47,6 +47,9 @@ void __init rlx_vec_irq_init(int irq_base)
 {
 	int i;
 	extern char rlx_vec_dispatch;
+	#ifdef CONFIG_RTL_8198_NFBI_BOARD
+	extern void setup_reboot_addr(unsigned long addr);
+	#endif
 
 	/* Mask interrupts. */
 	clear_lxc0_estatus(EST0_IM);
@@ -68,13 +71,20 @@ void __init rlx_vec_irq_init(int irq_base)
 	#endif
 	
 	#if defined(CONFIG_RTL8192CD)
-	#if (defined(CONFIG_RTL_8196C) || defined(CONFIG_RTL_8196CT) || defined(CONFIG_RTL_8196CS) || !defined(CONFIG_RTL_92D_DMDP))
+	#if defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+	REG32(BSP_GIMR) |= (BSP_PCIE_IE);
+	#if defined(CONFIG_RTL_8197D)
+	REG32(BSP_GIMR) |= (BSP_PCIE2_IE);
+	#endif
+	#else // !CONFIG_RTL_819XD
+	#if (defined(CONFIG_RTL_8196C) || defined(CONFIG_RTL_8196CT) || defined(CONFIG_RTL_8196CS) || !defined(CONFIG_RTL_92D_DMDP))|| defined(CONFIG_RTK_VOIP_BOARD)
 	REG32(BSP_GIMR) |= (BSP_PCIE_IE);
 	#endif
-	#if defined(CONFIG_RTL_DUAL_PCIESLOT_BIWLAN_D) || (defined(CONFIG_RTL_8198)&&defined(CONFIG_RTL_92D_SUPPORT))
+	#if defined(CONFIG_RTL_DUAL_PCIESLOT_BIWLAN_D) || (defined(CONFIG_RTL_8198)&&defined(CONFIG_RTL_92D_SUPPORT))&&!defined(CONFIG_RTK_VOIP_BOARD)
 	REG32(BSP_GIMR) |= (BSP_PCIE2_IE);
 	#endif
 	#endif
+	#endif
 	
 	#if defined(CONFIG_USB)
 	REG32(BSP_GIMR) |= BSP_USB_H_IE;
diff --git a/arch/rlx/kernel/unaligned.c b/arch/rlx/kernel/unaligned.c
index facf591..ed29817 100644
--- a/arch/rlx/kernel/unaligned.c
+++ b/arch/rlx/kernel/unaligned.c
@@ -115,6 +115,10 @@ static void emulate_load_store_insn(struct pt_regs *regs,
 	 */
 	__get_user(insn.word, pc);
 
+	#if 0
+	printk("emulate opcode 0x%x at %08lx \n", insn.i_format.opcode, regs->cp0_epc);
+	#endif
+
 	switch (insn.i_format.opcode) {
 	/*
 	 * These are instructions that a compiler doesn't generate.  We
@@ -143,11 +147,11 @@ static void emulate_load_store_insn(struct pt_regs *regs,
 
 		__asm__ __volatile__ (".set\tnoat\n"
 #ifdef __BIG_ENDIAN
-			"1:\tlb\t%0, 0(%2)\n"
+			"1:\tlbu\t%0, 0(%2)\n"
 			"2:\tlbu\t$1, 1(%2)\n\t"
 #endif
 #ifdef __LITTLE_ENDIAN
-			"1:\tlb\t%0, 1(%2)\n"
+			"1:\tlbu\t%0, 1(%2)\n"
 			"2:\tlbu\t$1, 0(%2)\n\t"
 #endif
 			"sll\t%0, 0x8\n\t"
@@ -180,14 +184,14 @@ static void emulate_load_store_insn(struct pt_regs *regs,
 			"1:\tlwl\t%0, (%2)\n"
 			"2:\tlwr\t%0, 3(%2)\n\t"
   #else
-            "1:  lb    %0,  0(%2)\n"
-            "    lb    %1,  1(%2)\n"
+            "1:  lbu   %0,  0(%2)\n"
+            "    lbu   %1,  1(%2)\n"
             "    sll   %0,  8\n"
             "    or    %0,  %1\n"
-            "    lb    %1,  2(%2)\n"
+            "    lbu   %1,  2(%2)\n"
             "    sll   %0,  8\n"
             "    or    %0,  %1\n"
-            "    lb    %1,  3(%2)\n"
+            "    lbu   %1,  3(%2)\n"
             "    sll   %0,  8\n"
             "    or    %0,  %1\n"
   #endif
@@ -197,14 +201,14 @@ static void emulate_load_store_insn(struct pt_regs *regs,
 			"1:\tlwl\t%0, 3(%2)\n"
 			"2:\tlwr\t%0, (%2)\n\t"
   #else
-            "1:  lb    %0,  3(%2)\n"
-            "    lb    %1,  2(%2)\n"
+            "1:  lbu   %0,  3(%2)\n"
+            "    lbu   %1,  2(%2)\n"
             "    sll   %0,  8\n"
             "    or    %0,  %1\n"
-            "    lb    %1,  1(%2)\n"
+            "    lbu   %1,  1(%2)\n"
             "    sll   %0,  8\n"
             "    or    %0,  %1\n"
-            "    lb    %1,  0(%2)\n"
+            "    lbu   %1,  0(%2)\n"
             "    sll   %0,  8\n"
             "    or    %0,  %1\n"
   #endif
@@ -218,7 +222,11 @@ static void emulate_load_store_insn(struct pt_regs *regs,
 			STR(PTR)"\t1b, 4b\n\t"
 			STR(PTR)"\t2b, 4b\n\t"
 			".previous"
+#ifdef CONFIG_CPU_HAS_ULS
 			: "=&r" (value), "=r" (res)
+#else
+			: "=&r" (value), "=&r" (res)
+#endif
 			: "r" (addr), "i" (-EFAULT));
 		if (res)
 			goto fault;
@@ -343,14 +351,17 @@ static void emulate_load_store_insn(struct pt_regs *regs,
 			STR(PTR)"\t1b, 4b\n\t"
 			STR(PTR)"\t2b, 4b\n\t"
 			".previous"
+#ifdef CONFIG_CPU_HAS_ULS
 		: "=r" (res)
+#else
+		: "=&r" (res)
+#endif
 		: "r" (value), "r" (addr), "i" (-EFAULT));
 		if (res)
 			goto fault;
 		compute_return_epc(regs);
 		break;
 
-	case lwu_op:
 	default:
 		/*
 		 * Pheeee...  We encountered an yet unknown instruction or
diff --git a/arch/rlx/mm/cache-rlx.c b/arch/rlx/mm/cache-rlx.c
index c183b95..2fca9b9 100644
--- a/arch/rlx/mm/cache-rlx.c
+++ b/arch/rlx/mm/cache-rlx.c
@@ -1,6 +1,10 @@
 /*
- * cache-rlx.c: RLX specific mmu/cache code.
  * Realtek Semiconductor Corp.
+ *
+ * cache-rlx.c: RLX specific mmu/cache code.
+ *
+ * Tony Wu (tonywu@realtek.com)
+ * Dec. 07, 2008
  */
 #include <linux/init.h>
 #include <linux/kernel.h>
@@ -11,12 +15,9 @@
 #include <asm/pgtable.h>
 #include <asm/mmu_context.h>
 #include <asm/system.h>
-#include <asm/isadep.h>
 #include <asm/io.h>
-#include <asm/bootinfo.h>
 #include <asm/cpu.h>
 #include <asm/cpu-features.h>
-#include <asm/wbflush.h>
 
 #include <asm/rlxbsp.h>
 
@@ -25,6 +26,369 @@
  */
 #if defined(CONFIG_CPU_RLX4181) || defined(CONFIG_CPU_RLX5181) || \
     defined(CONFIG_CPU_RLX4281) || defined(CONFIG_CPU_RLX5281)
+  #define CONFIG_CPU_HAS_DCACHE_OP
+#else
+  #undef CONFIG_CPU_HAS_DCACHE_OP
+#endif
+
+#if defined(CONFIG_CPU_RLX4281) || defined(CONFIG_CPU_RLX5281)
+  #define CONFIG_CPU_HAS_ICACHE_OP
+#else
+  #undef CONFIG_CPU_HAS_ICACHE_OP
+#endif
+
+/*
+ *  CACHE OP
+ *   0x10 = IInval
+ *   0x11 = DInval
+ *   0x15 = DWBInval
+ *   0x19 = DWB
+ *   0x1b = DWB_IInval
+ */
+#if defined(CONFIG_CPU_HAS_WBC) || defined(CONFIG_CPU_HAS_L2C)
+  #define CACHE_DCACHE_FLUSH	0x15
+  #define CACHE_DCACHE_WBACK	0x19
+#else
+  #define CACHE_DCACHE_FLUSH	0x11
+  #define CACHE_DCACHE_WBACK	0x11
+#endif
+
+#ifdef CONFIG_CPU_HAS_WBIC
+  #define CACHE_ICACHE_FLUSH	0x1b
+#else
+  #define CACHE_ICACHE_FLUSH	0x10
+#endif
+
+#define CACHE_OP(op, p)          \
+    __asm__ __volatile__ (       \
+         ".set  push\n"          \
+         ".set  noreorder\n"     \
+         "cache %0, 0x000(%1)\n" \
+         ".set  pop\n"           \
+         : : "i" (op), "r" (p)   \
+    )
+
+#define CACHE32_UNROLL4(op, p)   \
+    __asm__ __volatile__ (       \
+         ".set  push\n"          \
+         ".set  noreorder\n"     \
+         "cache %0, 0x000(%1)\n" \
+         "cache %0, 0x020(%1)\n" \
+         "cache %0, 0x040(%1)\n" \
+         "cache %0, 0x060(%1)\n" \
+         ".set  pop\n"           \
+         : : "i" (op), "r" (p)   \
+    )
+
+#define CACHE16_UNROLL8(op, p)   \
+    __asm__ __volatile__ (       \
+         ".set  push\n"          \
+         ".set  noreorder\n"     \
+         "cache %0, 0x000(%1)\n" \
+         "cache %0, 0x010(%1)\n" \
+         "cache %0, 0x020(%1)\n" \
+         "cache %0, 0x030(%1)\n" \
+         "cache %0, 0x040(%1)\n" \
+         "cache %0, 0x050(%1)\n" \
+         "cache %0, 0x060(%1)\n" \
+         "cache %0, 0x070(%1)\n" \
+         ".set  pop\n"           \
+         : : "i" (op), "r" (p)   \
+    )
+
+#if (cpu_dcache_line == 32)
+  #define DCACHE_OP(op,p)  CACHE32_UNROLL4(op,(p))
+#else
+  #define DCACHE_OP(op,p)  CACHE16_UNROLL8(op,(p))
+#endif
+
+#if (cpu_icache_line == 32)
+  #define ICACHE_OP(op,p)  CACHE32_UNROLL4(op,(p))
+#else
+  #define ICACHE_OP(op,p)  CACHE16_UNROLL8(op,(p))
+#endif
+
+/*
+ *  CCTL OP
+ *   0x1   = DInval
+ *   0x2   = IInval
+ *   0x100 = DWB
+ *   0x200 = DWB_Inval
+ */
+#define CCTL_ICACHE_FLUSH		0x2
+#if defined(CONFIG_CPU_HAS_WBC) || defined(CONFIG_CPU_HAS_L2C)
+  #define CCTL_DCACHE_WBACK		0x100
+  #define CCTL_DCACHE_FLUSH		0x200
+#else
+  #define CCTL_DCACHE_WBACK		0x1
+  #define CCTL_DCACHE_FLUSH		0x1
+#endif
+
+#if defined(CONFIG_CPU_RLX4281) || defined(CONFIG_CPU_RLX5281)
+#define CCTL_OP(op)		\
+    __asm__ __volatile__(	\
+       ".set  push\n"		\
+       ".set  noreorder\n"	\
+       "mtc0	$0, $20\n"	\
+       "li	$8, %0\n"	\
+       "mtc0	$8, $20\n"	\
+       ".set  pop\n"		\
+       : : "i" (op)		\
+   )
+#else
+#define CCTL_OP(op)		\
+    __asm__ __volatile__(	\
+       ".set  push\n"		\
+       ".set  noreorder\n"	\
+       "mfc0	$8, $20\n"	\
+       "ori	$8, %0\n"	\
+       "xori	$9, $8, %0\n"	\
+       "mtc0	$9, $20\n"	\
+       "mtc0	$8, $20\n"	\
+       ".set pop\n"		\
+       : : "i" (op)		\
+   )
+#endif
+
+#if 0//def CONFIG_RTL_819XD
+/*
+ * Dummy cache handling routines for machines without boardcaches
+ */
+static void cache_noop(void) {}
+
+static inline void rlx_flush_dcache_fast(unsigned long start, unsigned long end)
+{
+	unsigned long p;
+
+	for (p = start; p < end; p += 0x080) {
+		DCACHE_OP(CACHE_DCACHE_FLUSH, p);
+	}
+
+	p = p & ~(cpu_dcache_line -1);
+	if (p <= end)
+		CACHE_OP(CACHE_DCACHE_FLUSH, p);
+}
+
+static inline void rlx_wback_dcache_fast(unsigned long start, unsigned long end)
+{
+	unsigned long p;
+
+	for (p = start; p < end; p += 0x080) {
+		DCACHE_OP(CACHE_DCACHE_WBACK, p);
+	}
+
+	p = p & ~(cpu_dcache_line -1);
+	if (p <= end)
+		CACHE_OP(CACHE_DCACHE_WBACK, p);
+}
+
+static inline void rlx_flush_icache_fast(unsigned long start, unsigned long end)
+{
+	unsigned long p;
+
+	for (p = start; p < end; p += 0x080) {
+		ICACHE_OP(CACHE_ICACHE_FLUSH, p);
+	}
+
+	p = p & ~(cpu_icache_line -1);
+	if (p <= end)
+		CACHE_OP(CACHE_ICACHE_FLUSH, p);
+}
+
+/*
+ * DCACHE part
+ */
+static inline void rlx_flush_dcache_range(unsigned long start, unsigned long end)
+{
+#ifdef CONFIG_CPU_HAS_DCACHE_OP
+	if ((end - start) > cpu_dcache_size) {
+		CCTL_OP(CCTL_DCACHE_FLUSH);
+		return;
+	}
+	rlx_flush_dcache_fast(start, end);
+#else
+	CCTL_OP(CCTL_DCACHE_FLUSH)
+#endif
+}
+
+static inline void rlx_wback_dcache_range(unsigned long start, unsigned long end)
+{
+#ifdef CONFIG_CPU_HAS_DCACHE_OP
+	if ((end - start) > cpu_dcache_size) {
+		CCTL_OP(CCTL_DCACHE_WBACK);
+		return;
+	}
+	rlx_wback_dcache_fast(start, end);
+#else
+	CCTL_OP(CCTL_DCACHE_WBACK)
+#endif
+}
+
+/*
+ * ICACHE part
+ */
+static inline void local_rlx_flush_icache_range(unsigned long start, unsigned long end)
+{
+#ifdef CONFIG_CPU_HAS_ICACHE_OP
+	unsigned long size;
+
+  #if !defined(CONFIG_CPU_HAS_WBIC) \
+	&& (defined(CONFIG_CPU_HAS_WBC) \
+		|| defined(CONFIG_CPU_HAS_L2C))
+	rlx_flush_dcache_range(start, end);
+  #endif
+
+	size = end - start;
+	if (size > cpu_icache_size) {
+  #ifdef CONFIG_CPU_HAS_WBIC
+		if (size > cpu_dcache_size) {
+			CCTL_OP(CCTL_ICACHE_FLUSH | CCTL_DCACHE_FLUSH);
+			return;
+		} else
+			rlx_flush_dcache_fast(start, end);
+  #endif
+		CCTL_OP(CCTL_ICACHE_FLUSH);
+		return;
+	}
+
+	rlx_flush_icache_fast(start, end);
+#else
+	rlx_flush_dcache_range(start, end);
+	CCTL_OP(CCTL_ICACHE_FLUSH);
+#endif
+}
+
+static void rlx_flush_icache_range(unsigned long start, unsigned long end)
+{
+	preempt_disable();
+	local_rlx_flush_icache_range(start, end);
+	preempt_enable();
+}
+
+static inline void rlx___cache_flush_all(void)
+{
+#ifdef CONFIG_CPU_HAS_WBIC
+	CCTL_OP(CCTL_ICACHE_FLUSH | CCTL_DCACHE_FLUSH);
+#else
+	CCTL_OP(CCTL_DCACHE_FLUSH);
+	CCTL_OP(CCTL_ICACHE_FLUSH);
+#endif
+}
+
+static void rlx_cache_flush_page(struct vm_area_struct *vma,
+				 unsigned long addr, unsigned long pfn)
+{
+	unsigned long kaddr = KSEG0ADDR(pfn << PAGE_SHIFT);
+	int exec = vma->vm_flags & VM_EXEC;
+	struct mm_struct *mm = vma->vm_mm;
+	pgd_t *pgdp;
+	pud_t *pudp;
+	pmd_t *pmdp;
+	pte_t *ptep;
+
+	pr_debug("cpage[%08lx,%08lx]\n",
+		 cpu_context(smp_processor_id(), mm), addr);
+
+	/* No ASID => no such page in the cache.  */
+	if (cpu_context(smp_processor_id(), mm) == 0)
+		return;
+
+	pgdp = pgd_offset(mm, addr);
+	pudp = pud_offset(pgdp, addr);
+	pmdp = pmd_offset(pudp, addr);
+	ptep = pte_offset(pmdp, addr);
+
+	/* Invalid => no such page in the cache.  */
+	if (!(pte_val(*ptep) & _PAGE_PRESENT))
+		return;
+
+	preempt_disable();
+#ifdef CONFIG_CPU_HAS_WBIC
+	if (exec)
+		rlx_flush_icache_fast(kaddr, kaddr + PAGE_SIZE);
+	else
+		rlx_flush_dcache_fast(kaddr, kaddr + PAGE_SIZE);
+#else
+	rlx_flush_dcache_fast(kaddr, kaddr + PAGE_SIZE);
+	if (exec)
+		rlx_flush_icache_fast(kaddr, kaddr + PAGE_SIZE);
+#endif
+	preempt_enable();
+}
+
+static void rlx_cache_flush_sigtramp(unsigned long addr)
+{
+	pr_debug("csigtramp[%08lx]\n", addr);
+
+#ifdef CONFIG_CPU_HAS_WBIC
+	CACHE_OP(0x1b, addr);
+#else
+  #ifdef CONFIG_CPU_HAS_DCACHE_OP
+	CACHE_OP(CACHE_DCACHE_FLUSH, addr);
+  #else
+	CCTL_OP(CCTL_DCACHE_WBACK);
+  #endif
+
+  #ifdef CONFIG_CPU_HAS_ICACHE_OP
+	CACHE_OP(CACHE_ICACHE_FLUSH, addr);
+  #else
+	CCTL_OP(CCTL_ICACHE_FLUSH);
+  #endif
+#endif
+}
+
+static void rlx_dma_cache_wback_inv(unsigned long start, unsigned long size)
+{
+	/* Catch bad driver code */
+	BUG_ON(size == 0);
+
+	iob();
+	rlx_flush_dcache_range(start, start + size);
+}
+
+static void rlx_dma_cache_wback(unsigned long start, unsigned long size)
+{
+	/* Catch bad driver code */
+	BUG_ON(size == 0);
+
+	iob();
+	rlx_wback_dcache_range(start, start + size);
+}
+
+void __cpuinit rlx_cache_init(void)
+{
+	extern void build_clear_page(void);
+	extern void build_copy_page(void);
+
+          flush_cache_all     =   (void *) cache_noop;
+        __flush_cache_all     =   rlx___cache_flush_all;
+          flush_cache_mm      =   (void *) cache_noop;
+          flush_cache_range   =   (void *) cache_noop;
+          flush_cache_page    =   rlx_cache_flush_page;
+          flush_icache_range  =   rlx_flush_icache_range;
+    local_flush_icache_range  =   local_rlx_flush_icache_range;
+	local_flush_data_cache_page = (void *) cache_noop;
+	      flush_data_cache_page = (void *) cache_noop;
+	      flush_cache_sigtramp  = rlx_cache_flush_sigtramp;
+
+	_dma_cache_wback_inv = rlx_dma_cache_wback_inv;
+	_dma_cache_wback = rlx_dma_cache_wback;
+	_dma_cache_inv = rlx_dma_cache_wback_inv;
+
+	printk("icache: %dkB/%dB, dcache: %dkB/%dB, scache: %dkB/%dB\n",
+           cpu_icache_size >> 10, cpu_icache_line,
+           cpu_dcache_size >> 10, cpu_dcache_line,
+           cpu_scache_size >> 10, cpu_scache_line);
+
+	build_clear_page();
+	build_copy_page();
+}
+#else
+/*
+ * Determine whether CPU has CACHE OP
+ */
+#if defined(CONFIG_CPU_RLX4181) || defined(CONFIG_CPU_RLX5181) || \
+    defined(CONFIG_CPU_RLX4281) || defined(CONFIG_CPU_RLX5281)
 #define CONFIG_CPU_HAS_CACHE_OP
 #else
 #undef CONFIG_CPU_HAS_CACHE_OP
@@ -49,8 +413,8 @@ __attribute__  ((section(".iram-gen")))
 static void rlx_dcache_flush_range(unsigned long start, unsigned long end)
 {
 #ifdef CONFIG_CPU_HAS_CACHE_OP
-    unsigned long size, i, flags;
-    volatile unsigned char *p;
+    unsigned long size, flags;
+    unsigned long p;
 
     start &= ~cpu_dcache_line_mask;
     size = end - start;
@@ -60,7 +424,6 @@ static void rlx_dcache_flush_range(unsigned long start, unsigned long end)
         return;
       }
 
-    p = (char *)start;
     flags = read_c0_status();
 
     /* disable interrupt */
@@ -70,8 +433,7 @@ static void rlx_dcache_flush_range(unsigned long start, unsigned long end)
     /* 0x11 = DInval   */
     /* 0x15 = DWBInval */
     /* 0x19 = DWB      */
-
-    for (i = 0; i < size; i += 0x080) {
+    for (p = start; p < end; p += 0x080) {
         asm (
 #if (cpu_dcache_line == 16)
              "cache 0x15, 0x000(%0)\n\t"
@@ -89,9 +451,12 @@ static void rlx_dcache_flush_range(unsigned long start, unsigned long end)
              "cache 0x15, 0x060(%0)\n\t"
 #endif
              : : "r" (p) );
-        p += 0x080;
     }
 
+    p = p & ~(cpu_dcache_line -1);
+    if (p <= end)
+    	CACHE_OP(CACHE_DCACHE_FLUSH, p);
+
     /* restore interrupt */
     write_c0_status(flags);
 #else
@@ -113,8 +478,8 @@ void rlx_dcache_wb_all(void)
 static void rlx_dcache_wb_range(unsigned long start, unsigned long end)
 {
  #ifdef CONFIG_CPU_HAS_CACHE_OP
-    unsigned long size, i, flags;
-    volatile unsigned char *p;
+    unsigned long size, flags;
+    unsigned long p;
 
     start &= ~cpu_dcache_line_mask;
     size = end - start;
@@ -124,7 +489,6 @@ static void rlx_dcache_wb_range(unsigned long start, unsigned long end)
         return;
       }
 
-    p = (char *)start;
     flags = read_c0_status();
 
     /* disable interrupt */
@@ -134,7 +498,7 @@ static void rlx_dcache_wb_range(unsigned long start, unsigned long end)
     /* 0x11 = DInval   */
     /* 0x15 = DWBInval */
     /* 0x19 = DWB      */
-    for (i = 0; i < size; i += 0x080) {
+    for (p = start; p < end; p += 0x080) {
         asm (
 #if (cpu_dcache_line == 16)
              "cache 0x19, 0x000(%0)\n\t"
@@ -152,9 +516,12 @@ static void rlx_dcache_wb_range(unsigned long start, unsigned long end)
              "cache 0x19, 0x060(%0)\n\t"
 #endif
              : : "r" (p) );
-        p += 0x080;
     }
 
+    p = p & ~(cpu_dcache_line -1);
+    if (p <= end)
+    	CACHE_OP(CACHE_DCACHE_WBACK, p);
+
     /* restore interrupt */
     write_c0_status(flags);
  #else
@@ -178,8 +545,8 @@ static void rlx_dcache_flush_all(void)
 static void rlx_dcache_flush_range(unsigned long start, unsigned long end)
 {
 #ifdef CONFIG_CPU_HAS_CACHE_OP
-    unsigned long size, i, flags;
-    volatile unsigned char *p;
+    unsigned long size, flags;
+    unsigned long p;
 
     start &= ~cpu_dcache_line_mask;
     size = end - start;
@@ -189,7 +556,6 @@ static void rlx_dcache_flush_range(unsigned long start, unsigned long end)
         return;
       }
 
-    p = (char *)start;
     flags = read_c0_status();
 
     /* disable interrupt */
@@ -199,7 +565,7 @@ static void rlx_dcache_flush_range(unsigned long start, unsigned long end)
     /* 0x11 = DInval   */
     /* 0x15 = DWBInval */
     /* 0x19 = DWB      */
-    for (i = 0; i < size; i += 0x080) {
+    for (p = start; p < end; p += 0x080) {
         asm (
 #if (cpu_dcache_line == 16)
              "cache 0x11, 0x000(%0)\n\t"
@@ -217,9 +583,12 @@ static void rlx_dcache_flush_range(unsigned long start, unsigned long end)
              "cache 0x11, 0x060(%0)\n\t"
 #endif
              : : "r" (p) );
-        p += 0x080;
     }
 
+    p = p & ~(cpu_dcache_line -1);
+    if (p <= end)
+    	CACHE_OP(CACHE_DCACHE_FLUSH, p);
+
     /* restore interrupt */
     write_c0_status(flags);
 #else
@@ -253,8 +622,8 @@ static void rlx_icache_flush_all(void)
 static void rlx_icache_flush_range(unsigned long start, unsigned long end)
 {
 #if defined(CONFIG_CPU_RLX4281) || defined(CONFIG_CPU_RLX5281)
-    unsigned long size, i, flags;
-    volatile unsigned char *p;
+    unsigned long size, flags;
+    unsigned long p;
 
     rlx_dcache_wb_range(start, end);
 
@@ -266,7 +635,6 @@ static void rlx_icache_flush_range(unsigned long start, unsigned long end)
         return;
       }
 
-    p = (char *)start;
     flags = read_c0_status();
 
     /* disable interrupt */
@@ -276,7 +644,7 @@ static void rlx_icache_flush_range(unsigned long start, unsigned long end)
     /* 0x11 = DInval   */
     /* 0x15 = DWBInval */
     /* 0x19 = DWB      */
-    for (i = 0; i < size; i += 0x080) {
+    for (p = start; p < end; p += 0x080) {
         asm (
 #if (cpu_icache_line == 16)
              "cache 0x10, 0x000(%0)\n\t"
@@ -294,9 +662,12 @@ static void rlx_icache_flush_range(unsigned long start, unsigned long end)
              "cache 0x10, 0x060(%0)\n\t"
 #endif
              : : "r" (p) );
-        p += 0x080;
     }
 
+    p = p & ~(cpu_icache_line -1);
+    if (p <= end)
+    	CACHE_OP(CACHE_ICACHE_FLUSH, p);
+		
     /* restore interrupt */
     write_c0_status(flags);
 #else
@@ -430,3 +801,6 @@ void __cpuinit rlx_cache_init(void)
 	build_clear_page();
 	build_copy_page();
 }
+
+#endif
+
diff --git a/arch/rlx/mm/cache.c b/arch/rlx/mm/cache.c
index 26f90e5..104cfe4 100644
--- a/arch/rlx/mm/cache.c
+++ b/arch/rlx/mm/cache.c
@@ -163,7 +163,7 @@ int __weak __uncached_access(struct file *file, unsigned long addr)
 	return addr >= __pa(high_memory);
 }
 
-void __devinit cpu_cache_init(void)
+void __cpuinit cpu_cache_init(void)
 {
     extern void __weak rlx_cache_init(void);
 
diff --git a/arch/rlx/mm/imem-dmem.S b/arch/rlx/mm/imem-dmem.S
index c77cf53..7551d89 100644
--- a/arch/rlx/mm/imem-dmem.S
+++ b/arch/rlx/mm/imem-dmem.S
@@ -1,5 +1,33 @@
 #include <asm/asmmacro.h>
 
+#if defined(CONFIG_RTK_VOIP)
+		.macro refill_dmem	sel, addr
+		.set noreorder
+		la		t0, 0xB800B808		# CTRL 
+		sw		zero, 0(t0)
+		la		t1, ( 1 << 21 )
+		sw		t1, 0(t0)
+		la		t0, 0xB800B800		# SA 
+		sw		zero, 0(t0)
+		la		t0, \addr			# EXT SA
+		la		t1, 0x1ffffffc
+		and		t1, t0, t1
+		la		t0, 0xB800B804
+		sw		t1, 0(t0)
+		la		t0, 0xB800B808		# CTRL 
+		la		t1, ( \sel << 23 ) | ( 1 << 22 ) | ( 1 << 19 ) | ( ( ( 0x1000 ) >> 2 ) & 0x3FFFF )
+		sw		t1, 0(t0)
+		la		t4, ( 1 << 20 )
+		or		t1, t1, t4
+		sw		t1, 0(t0)
+1:
+		lw		t1, 0(t0)
+		and		t1, t1, t4
+		bne		t1, zero, 1b
+		nop		
+		.endm
+
+#endif
 	.text
         LEAF(_imem_dmem_init)
         .set noreorder
@@ -32,7 +60,11 @@
         nop
 
         #--- load iram base and top
+#ifdef CONFIG_RTL_819XD
+#define IMEM0_SIZE	4096*4
+#else
 #define IMEM0_SIZE	4096
+#endif
 #define IMEM1_SIZE	4096
         la              $8,__iram
         la              $9,0x0fffc000
@@ -41,7 +73,7 @@
         nop
         nop
 #ifdef CONFIG_ARCH_CPU_RLX5281
-#ifdef CONFIG_RTL8198_REVISION_B
+#if defined(CONFIG_RTL8198_REVISION_B)
         //jasonwang0413
         li	t6,0xb8000000
 	lw	t7,0(t6)
@@ -79,6 +111,7 @@ rev_end:
         mtc0    $8, $20
         nop
         nop
+#if !defined(CONFIG_RTL_819XD)
 	#--- load iram base1 and top1
         la              $8,__iram
 #ifdef CONFIG_RTL8198_REVISION_B
@@ -107,6 +140,7 @@ rev_end:
         nop
         li              $8,0x00000010 # IRAM Fill
         mtc0    $8, $20,1
+#endif
         nop
         nop
 
@@ -120,7 +154,13 @@ rev_end:
         mtc3    $8,$4                                                           # DW bas
         nop
         nop
+#if defined(CONFIG_RTL_819XD)
+        #define DMEM0_SIZE	4096*2
+
+	addiu   $8,$8,(DMEM0_SIZE-1)
+#else
         addiu   $8,$8,0xfff
+#endif
         mtc3    $8,$5                                                           # DW top
         nop
         nop
@@ -131,20 +171,33 @@ rev_end:
         #la              $9,0x0fffe000
         add		$8,$8,1
 	#and             $8,$8,$9
+#if !defined(CONFIG_RTL_819XD)
         mtc3    $8,$6                                                           # DW bas 1
         nop
         nop
         addiu   $8,$8,0xfff
         mtc3    $8,$7                                                           # DW top 1
+#endif
         nop
         nop
-		li		$8,0x00000400	# DMEM On	// pkshih: add to enable DMEM0 and DMEM1
-        mtc0    $8, $20			# DMEM0 ON
-        mtc0    $8, $20,1		# DMEM1 ON
+#if defined(CONFIG_RTK_VOIP) && !defined(CONFIG_RTL_89xxD)
+	#--- Refill the DRAM -----
+	refill_dmem 2, __dram_start				# DMEM 0 (4k)
+	refill_dmem 3, __dram_start + 0x1000	# DMEM 1 (4k)
+#endif
+#if !defined(CONFIG_RTL_89xxD)
+		mfc0	t0, $20
+		or		t0, 0x00000400	# DMEM On	// pkshih: add to enable DMEM0 and DMEM1
+        mtc0    t0, $20			# DMEM0 ON
+#endif
+#if !defined(CONFIG_RTL_819XD)
+        mfc0	t0, $20,1
+		or		t0, 0x00000400	# DMEM On	// pkshih: add to enable DMEM0 and DMEM1
+        mtc0    t0, $20,1		# DMEM1 ON
+#endif
 		nop
 		nop
 
-
 #else
         addiu   $8,$8,0x3fff
         mtc3    $8,$1                                                           # IW top
diff --git a/arch/x86/kernel/tlb_uv.c b/arch/x86/kernel/tlb_uv.c
index 8ccabb8..3b4b0d5 100644
--- a/arch/x86/kernel/tlb_uv.c
+++ b/arch/x86/kernel/tlb_uv.c
@@ -727,7 +727,7 @@ uv_activation_descriptor_init(int node, int pnode)
 	m = pa & uv_mmask;
 
 	uv_write_global_mmr64(pnode, UVH_LB_BAU_SB_DESCRIPTOR_BASE,
-			      (n << UV_DESC_BASE_PNODE_SHIFT | m));
+				      (n << UV_DESC_BASE_PNODE_SHIFT | m));
 
 	/*
 	 * initializing all 8 (UV_ITEMS_PER_DESCRIPTOR) descriptors for each
diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c
index 691f8e0..8a91cb3 100644
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@ -1207,8 +1207,8 @@ static __init int setup_vmcs_config(struct vmcs_config *vmcs_conf)
 		/* CR3 accesses and invlpg don't need to cause VM Exits when EPT
 		   enabled */
 		_cpu_based_exec_control &= ~(CPU_BASED_CR3_LOAD_EXITING |
-					     CPU_BASED_CR3_STORE_EXITING |
-					     CPU_BASED_INVLPG_EXITING);
+			 CPU_BASED_CR3_STORE_EXITING |
+			 CPU_BASED_INVLPG_EXITING);
 		rdmsr(MSR_IA32_VMX_EPT_VPID_CAP,
 		      vmx_capability.ept, vmx_capability.vpid);
 	}
diff --git a/arch/x86/mm/tlb.c b/arch/x86/mm/tlb.c
index c814e14..1f009ba 100644
--- a/arch/x86/mm/tlb.c
+++ b/arch/x86/mm/tlb.c
@@ -184,15 +184,15 @@ static void flush_tlb_others_ipi(const struct cpumask *cpumask,
 	f->flush_mm = mm;
 	f->flush_va = va;
 	if (cpumask_andnot(to_cpumask(f->flush_cpumask), cpumask, cpumask_of(smp_processor_id()))) {
-		/*
-		 * We have to send the IPI only to
-		 * CPUs affected.
-		 */
-		apic->send_IPI_mask(to_cpumask(f->flush_cpumask),
-			      INVALIDATE_TLB_VECTOR_START + sender);
+	/*
+	 * We have to send the IPI only to
+	 * CPUs affected.
+	 */
+	apic->send_IPI_mask(to_cpumask(f->flush_cpumask),
+		      INVALIDATE_TLB_VECTOR_START + sender);
 
-		while (!cpumask_empty(to_cpumask(f->flush_cpumask)))
-			cpu_relax();
+	while (!cpumask_empty(to_cpumask(f->flush_cpumask)))
+		cpu_relax();
 	}
 
 	f->flush_mm = NULL;
diff --git a/crypto/Makefile b/crypto/Makefile
index 673d9f7..d4bd2a8 100644
--- a/crypto/Makefile
+++ b/crypto/Makefile
@@ -89,3 +89,8 @@ obj-$(CONFIG_CRYPTO_TEST) += tcrypt.o
 #
 obj-$(CONFIG_XOR_BLOCKS) += xor.o
 obj-$(CONFIG_ASYNC_CORE) += async_tx/
+
+ifeq ($(CONFIG_CRYPTO_DEV_REALTEK),y)
+EXTRA_CFLAGS += -I./$(obj)/../drivers/crypto/realtek/
+endif
+
diff --git a/crypto/cbc.c b/crypto/cbc.c
index 61ac42e..155fd49 100644
--- a/crypto/cbc.c
+++ b/crypto/cbc.c
@@ -19,8 +19,15 @@
 #include <linux/scatterlist.h>
 #include <linux/slab.h>
 
+#ifdef CONFIG_CRYPTO_DEV_REALTEK
+#include "rtl_crypto_helper.h"
+#endif // CONFIG_CRYPTO_DEV_REALTEK
+
 struct crypto_cbc_ctx {
 	struct crypto_cipher *child;
+#ifdef CONFIG_CRYPTO_DEV_REALTEK
+	struct rtl_cipher_ctx rtl_ctx;
+#endif
 };
 
 static int crypto_cbc_setkey(struct crypto_tfm *parent, const u8 *key,
@@ -36,6 +43,10 @@ static int crypto_cbc_setkey(struct crypto_tfm *parent, const u8 *key,
 	err = crypto_cipher_setkey(child, key, keylen);
 	crypto_tfm_set_flags(parent, crypto_cipher_get_flags(child) &
 				     CRYPTO_TFM_RES_MASK);
+#ifdef CONFIG_CRYPTO_DEV_REALTEK
+	if (err == 0)
+		err = rtl_cipher_setkey(child, &ctx->rtl_ctx, key, keylen);
+#endif
 	return err;
 }
 
@@ -101,6 +112,27 @@ static int crypto_cbc_encrypt(struct blkcipher_desc *desc,
 	err = blkcipher_walk_virt(desc, &walk);
 
 	while ((nbytes = walk.nbytes)) {
+#ifdef CONFIG_CRYPTO_DEV_REALTEK_DBG
+		printk("%s: total=%d, walk=%d, blk=%d, src=%p, dst=%p\n", __FUNCTION__,
+			walk.total, walk.nbytes, crypto_cipher_blocksize(child),
+			walk.src.virt.addr, walk.dst.virt.addr
+		);
+#endif
+#ifdef CONFIG_CRYPTO_DEV_REALTEK
+		if (ctx->rtl_ctx.mode >= 0)
+		{
+			nbytes = rtl_cipher_crypt(child, 1,
+				&ctx->rtl_ctx, walk.src.virt.addr, nbytes,
+				walk.iv, walk.dst.virt.addr);
+
+			// cbc mode update
+			memcpy(walk.iv, walk.dst.virt.addr,
+				crypto_cipher_blocksize(child));
+
+			err = blkcipher_walk_done(desc, &walk, nbytes);
+			continue;
+		}
+#endif
 		if (walk.src.virt.addr == walk.dst.virt.addr)
 			nbytes = crypto_cbc_encrypt_inplace(desc, &walk, child);
 		else
@@ -180,6 +212,21 @@ static int crypto_cbc_decrypt(struct blkcipher_desc *desc,
 	err = blkcipher_walk_virt(desc, &walk);
 
 	while ((nbytes = walk.nbytes)) {
+#ifdef CONFIG_CRYPTO_DEV_REALTEK
+		if (ctx->rtl_ctx.mode >= 0)
+		{
+			nbytes = rtl_cipher_crypt(child, 0,
+				&ctx->rtl_ctx, walk.src.virt.addr, nbytes,
+				walk.iv, walk.dst.virt.addr);
+
+			// cbc mode update
+			memcpy(walk.iv, walk.dst.virt.addr,
+				crypto_cipher_blocksize(child));
+
+			err = blkcipher_walk_done(desc, &walk, nbytes);
+			continue;
+		}
+#endif
 		if (walk.src.virt.addr == walk.dst.virt.addr)
 			nbytes = crypto_cbc_decrypt_inplace(desc, &walk, child);
 		else
@@ -202,6 +249,9 @@ static int crypto_cbc_init_tfm(struct crypto_tfm *tfm)
 		return PTR_ERR(cipher);
 
 	ctx->child = cipher;
+#ifdef CONFIG_CRYPTO_DEV_REALTEK
+	rtl_cipher_init_ctx(tfm, &ctx->rtl_ctx);
+#endif
 	return 0;
 }
 
diff --git a/crypto/ctr.c b/crypto/ctr.c
index 2d7425f..130d875 100644
--- a/crypto/ctr.c
+++ b/crypto/ctr.c
@@ -20,8 +20,15 @@
 #include <linux/scatterlist.h>
 #include <linux/slab.h>
 
+#ifdef CONFIG_CRYPTO_DEV_REALTEK
+#include "rtl_crypto_helper.h"
+#endif // CONFIG_CRYPTO_DEV_REALTEK
+
 struct crypto_ctr_ctx {
 	struct crypto_cipher *child;
+#ifdef CONFIG_CRYPTO_DEV_REALTEK
+	struct rtl_cipher_ctx rtl_ctx;
+#endif
 };
 
 struct crypto_rfc3686_ctx {
@@ -43,6 +50,10 @@ static int crypto_ctr_setkey(struct crypto_tfm *parent, const u8 *key,
 	crypto_tfm_set_flags(parent, crypto_cipher_get_flags(child) &
 			     CRYPTO_TFM_RES_MASK);
 
+#ifdef CONFIG_CRYPTO_DEV_REALTEK
+	if (err == 0)
+		err = rtl_cipher_setkey(child, &ctx->rtl_ctx, key, keylen);
+#endif
 	return err;
 }
 
@@ -133,6 +144,25 @@ static int crypto_ctr_crypt(struct blkcipher_desc *desc,
 	err = blkcipher_walk_virt_block(desc, &walk, bsize);
 
 	while (walk.nbytes >= bsize) {
+
+#ifdef CONFIG_CRYPTO_DEV_REALTEK
+		if (ctx->rtl_ctx.mode >= 0)
+		{
+			int i;
+
+			nbytes = rtl_cipher_crypt(child, 1,
+				&ctx->rtl_ctx, walk.src.virt.addr, walk.nbytes,
+				walk.iv, walk.dst.virt.addr);
+
+			/* increment counter in counterblock */
+			for (i = 0; i < (walk.nbytes / bsize); i++)
+				crypto_inc(walk.iv, bsize);
+
+			err = blkcipher_walk_done(desc, &walk, nbytes);
+			continue;
+		}
+#endif
+
 		if (walk.src.virt.addr == walk.dst.virt.addr)
 			nbytes = crypto_ctr_crypt_inplace(&walk, child);
 		else
@@ -162,6 +192,9 @@ static int crypto_ctr_init_tfm(struct crypto_tfm *tfm)
 
 	ctx->child = cipher;
 
+#ifdef CONFIG_CRYPTO_DEV_REALTEK
+	rtl_cipher_init_ctx(tfm, &ctx->rtl_ctx);
+#endif
 	return 0;
 }
 
diff --git a/crypto/ecb.c b/crypto/ecb.c
index a46838e..fcb8664 100644
--- a/crypto/ecb.c
+++ b/crypto/ecb.c
@@ -18,8 +18,15 @@
 #include <linux/scatterlist.h>
 #include <linux/slab.h>
 
+#ifdef CONFIG_CRYPTO_DEV_REALTEK
+#include "rtl_crypto_helper.h"
+#endif // CONFIG_CRYPTO_DEV_REALTEK
+
 struct crypto_ecb_ctx {
 	struct crypto_cipher *child;
+#ifdef CONFIG_CRYPTO_DEV_REALTEK
+	struct rtl_cipher_ctx rtl_ctx;
+#endif
 };
 
 static int crypto_ecb_setkey(struct crypto_tfm *parent, const u8 *key,
@@ -35,6 +42,10 @@ static int crypto_ecb_setkey(struct crypto_tfm *parent, const u8 *key,
 	err = crypto_cipher_setkey(child, key, keylen);
 	crypto_tfm_set_flags(parent, crypto_cipher_get_flags(child) &
 				     CRYPTO_TFM_RES_MASK);
+#ifdef CONFIG_CRYPTO_DEV_REALTEK
+	if (err == 0)
+		err = rtl_cipher_setkey(child, &ctx->rtl_ctx, key, keylen);
+#endif
 	return err;
 }
 
@@ -46,6 +57,9 @@ static int crypto_ecb_crypt(struct blkcipher_desc *desc,
 	int bsize = crypto_cipher_blocksize(tfm);
 	unsigned int nbytes;
 	int err;
+#ifdef CONFIG_CRYPTO_DEV_REALTEK
+	struct crypto_ecb_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);
+#endif
 
 	err = blkcipher_walk_virt(desc, walk);
 
@@ -53,6 +67,18 @@ static int crypto_ecb_crypt(struct blkcipher_desc *desc,
 		u8 *wsrc = walk->src.virt.addr;
 		u8 *wdst = walk->dst.virt.addr;
 
+#ifdef CONFIG_CRYPTO_DEV_REALTEK
+		if (ctx->rtl_ctx.mode >= 0)
+		{
+			nbytes = rtl_cipher_crypt(tfm,
+				fn == crypto_cipher_alg(tfm)->cia_encrypt,
+				&ctx->rtl_ctx, wsrc, nbytes,
+				walk->iv, wdst);
+			err = blkcipher_walk_done(desc, walk, nbytes);
+			continue;
+		}
+#endif
+
 		do {
 			fn(crypto_cipher_tfm(tfm), wdst, wsrc);
 	
@@ -106,6 +132,9 @@ static int crypto_ecb_init_tfm(struct crypto_tfm *tfm)
 		return PTR_ERR(cipher);
 
 	ctx->child = cipher;
+#ifdef CONFIG_CRYPTO_DEV_REALTEK
+	rtl_cipher_init_ctx(tfm, &ctx->rtl_ctx);
+#endif
 	return 0;
 }
 
diff --git a/crypto/md5.c b/crypto/md5.c
index 83eb529..46ede30 100644
--- a/crypto/md5.c
+++ b/crypto/md5.c
@@ -22,6 +22,10 @@
 #include <linux/types.h>
 #include <asm/byteorder.h>
 
+#ifdef CONFIG_CRYPTO_DEV_REALTEK
+#include "rtl_crypto_helper.h"
+#endif // CONFIG_CRYPTO_DEV_REALTEK
+
 #define MD5_DIGEST_SIZE		16
 #define MD5_HMAC_BLOCK_SIZE	64
 #define MD5_BLOCK_WORDS		16
@@ -39,6 +43,9 @@ struct md5_ctx {
 	u32 hash[MD5_HASH_WORDS];
 	u32 block[MD5_BLOCK_WORDS];
 	u64 byte_count;
+#ifdef CONFIG_CRYPTO_DEV_REALTEK
+	struct rtl_hash_ctx rtl_ctx;
+#endif
 };
 
 static void md5_transform(u32 *hash, u32 const *in)
@@ -149,6 +156,12 @@ static inline void md5_transform_helper(struct md5_ctx *ctx)
 
 static int md5_init(struct shash_desc *desc)
 {
+#ifdef CONFIG_CRYPTO_DEV_REALTEK
+	struct md5_ctx *mctx = shash_desc_ctx(desc);
+
+	rtl_hash_init_ctx(crypto_shash_tfm(desc->tfm), &mctx->rtl_ctx);
+	return 0;
+#else
 	struct md5_ctx *mctx = shash_desc_ctx(desc);
 
 	mctx->hash[0] = 0x67452301;
@@ -158,10 +171,17 @@ static int md5_init(struct shash_desc *desc)
 	mctx->byte_count = 0;
 
 	return 0;
+#endif
 }
 
 static int md5_update(struct shash_desc *desc, const u8 *data, unsigned int len)
 {
+#ifdef CONFIG_CRYPTO_DEV_REALTEK
+	struct md5_ctx *mctx = shash_desc_ctx(desc);
+
+	rtl_hash_update(&mctx->rtl_ctx, (u8 *) data, len);
+	return 0;
+#else
 	struct md5_ctx *mctx = shash_desc_ctx(desc);
 	const u32 avail = sizeof(mctx->block) - (mctx->byte_count & 0x3f);
 
@@ -190,10 +210,26 @@ static int md5_update(struct shash_desc *desc, const u8 *data, unsigned int len)
 	memcpy(mctx->block, data, len);
 
 	return 0;
+#endif
 }
 
+#ifdef CONFIG_CRYPTO_DEV_REALTEK
+static int md5_digest(struct shash_desc *desc, const u8 *data,
+	unsigned int len, u8 *out)
+{
+	struct md5_ctx *mctx = shash_desc_ctx(desc);
+
+	return rtl_hash_digest(&mctx->rtl_ctx, (u8 *) data, len, out);
+}
+#endif
+
 static int md5_final(struct shash_desc *desc, u8 *out)
 {
+#ifdef CONFIG_CRYPTO_DEV_REALTEK
+	struct md5_ctx *mctx = shash_desc_ctx(desc);
+
+	return rtl_hash_final(&mctx->rtl_ctx, out);
+#else
 	struct md5_ctx *mctx = shash_desc_ctx(desc);
 	const unsigned int offset = mctx->byte_count & 0x3f;
 	char *p = (char *)mctx->block + offset;
@@ -218,6 +254,7 @@ static int md5_final(struct shash_desc *desc, u8 *out)
 	memset(mctx, 0, sizeof(*mctx));
 
 	return 0;
+#endif
 }
 
 static struct shash_alg alg = {
@@ -225,6 +262,9 @@ static struct shash_alg alg = {
 	.init		=	md5_init,
 	.update		=	md5_update,
 	.final		=	md5_final,
+#ifdef CONFIG_CRYPTO_DEV_REALTEK
+	.digest		=	md5_digest,
+#endif
 	.descsize	=	sizeof(struct md5_ctx),
 	.base		=	{
 		.cra_name	=	"md5",
diff --git a/crypto/sha1_generic.c b/crypto/sha1_generic.c
index 9efef20..8ca403f 100644
--- a/crypto/sha1_generic.c
+++ b/crypto/sha1_generic.c
@@ -25,14 +25,27 @@
 #include <crypto/sha.h>
 #include <asm/byteorder.h>
 
+#ifdef CONFIG_CRYPTO_DEV_REALTEK
+#include "rtl_crypto_helper.h"
+#endif // CONFIG_CRYPTO_DEV_REALTEK
+
 struct sha1_ctx {
         u64 count;
         u32 state[5];
         u8 buffer[64];
+#ifdef CONFIG_CRYPTO_DEV_REALTEK
+		struct rtl_hash_ctx rtl_ctx;
+#endif
 };
 
 static int sha1_init(struct shash_desc *desc)
 {
+#ifdef CONFIG_CRYPTO_DEV_REALTEK
+	struct sha1_ctx *sctx = shash_desc_ctx(desc);
+
+	rtl_hash_init_ctx(crypto_shash_tfm(desc->tfm), &sctx->rtl_ctx);
+	return 0;
+#else
 	struct sha1_ctx *sctx = shash_desc_ctx(desc);
 
 	static const struct sha1_ctx initstate = {
@@ -44,11 +57,18 @@ static int sha1_init(struct shash_desc *desc)
 	*sctx = initstate;
 
 	return 0;
+#endif
 }
 
 static int sha1_update(struct shash_desc *desc, const u8 *data,
 			unsigned int len)
 {
+#ifdef CONFIG_CRYPTO_DEV_REALTEK
+	struct sha1_ctx *sctx = shash_desc_ctx(desc);
+
+	rtl_hash_update(&sctx->rtl_ctx, (u8 *) data, len);
+	return 0;
+#else
 	struct sha1_ctx *sctx = shash_desc_ctx(desc);
 	unsigned int partial, done;
 	const u8 *src;
@@ -79,12 +99,27 @@ static int sha1_update(struct shash_desc *desc, const u8 *data,
 	memcpy(sctx->buffer + partial, src, len - done);
 
 	return 0;
+#endif
 }
 
+#ifdef CONFIG_CRYPTO_DEV_REALTEK
+static int sha1_digest(struct shash_desc *desc, const u8 *data,
+	unsigned int len, u8 *out)
+{
+	struct sha1_ctx *sctx = shash_desc_ctx(desc);
+
+	return rtl_hash_digest(&sctx->rtl_ctx, (u8 *) data, len, out);
+}
+#endif
 
 /* Add padding and return the message digest. */
 static int sha1_final(struct shash_desc *desc, u8 *out)
 {
+#ifdef CONFIG_CRYPTO_DEV_REALTEK
+	struct sha1_ctx *sctx = shash_desc_ctx(desc);
+
+	return rtl_hash_final(&sctx->rtl_ctx, out);
+#else
 	struct sha1_ctx *sctx = shash_desc_ctx(desc);
 	__be32 *dst = (__be32 *)out;
 	u32 i, index, padlen;
@@ -109,6 +144,7 @@ static int sha1_final(struct shash_desc *desc, u8 *out)
 	memset(sctx, 0, sizeof *sctx);
 
 	return 0;
+#endif
 }
 
 static struct shash_alg alg = {
@@ -116,6 +152,9 @@ static struct shash_alg alg = {
 	.init		=	sha1_init,
 	.update		=	sha1_update,
 	.final		=	sha1_final,
+#ifdef CONFIG_CRYPTO_DEV_REALTEK
+	.digest		=	sha1_digest,
+#endif
 	.descsize	=	sizeof(struct sha1_ctx),
 	.base		=	{
 		.cra_name	=	"sha1",
diff --git a/crypto/tcrypt.c b/crypto/tcrypt.c
index c3c9124..5cf9c27 100644
--- a/crypto/tcrypt.c
+++ b/crypto/tcrypt.c
@@ -477,6 +477,69 @@ static void do_test(int m)
 	case 0:
 		for (i = 1; i < 200; i++)
 			do_test(i);
+
+		sec = 2;
+
+#if 0
+		// md5
+		test_hash_speed("md5", sec, generic_hash_speed_template);
+		// sha1
+		test_hash_speed("sha1", sec, generic_hash_speed_template);
+#endif
+#if 0
+		// hmac-md5
+		test_hash_speed("hmac(md5)", sec, generic_hash_speed_template);
+		// hmac-sha1
+		test_hash_speed("hmac(sha1)", sec, generic_hash_speed_template);
+#endif
+#if 0
+		// ecb-des
+		test_cipher_speed("ecb(des)", ENCRYPT, sec, NULL, 0,
+				  speed_template_8);
+		test_cipher_speed("ecb(des)", DECRYPT, sec, NULL, 0,
+				  speed_template_8);
+		// ecb-3des
+		test_cipher_speed("ecb(des3_ede)", ENCRYPT, sec,
+				des3_speed_template, DES3_SPEED_VECTORS,
+				speed_template_24);
+		test_cipher_speed("ecb(des3_ede)", DECRYPT, sec,
+				des3_speed_template, DES3_SPEED_VECTORS,
+				speed_template_24);
+		// ecb-aes
+		test_cipher_speed("ecb(aes)", ENCRYPT, sec, NULL, 0,
+				speed_template_16_24_32);
+		test_cipher_speed("ecb(aes)", DECRYPT, sec, NULL, 0,
+				speed_template_16_24_32);
+#endif
+#if 0
+		// cbc-des
+		test_cipher_speed("cbc(des)", ENCRYPT, sec, NULL, 0,
+				  speed_template_8);
+		test_cipher_speed("cbc(des)", DECRYPT, sec, NULL, 0,
+				  speed_template_8);
+		// cbc-3des
+		test_cipher_speed("cbc(des3_ede)", ENCRYPT, sec,
+				des3_speed_template, DES3_SPEED_VECTORS,
+				speed_template_24);
+		test_cipher_speed("cbc(des3_ede)", DECRYPT, sec,
+				des3_speed_template, DES3_SPEED_VECTORS,
+				speed_template_24);
+		// cbc-aes
+		test_cipher_speed("cbc(aes)", ENCRYPT, sec, NULL, 0,
+				speed_template_16_24_32);
+		test_cipher_speed("cbc(aes)", DECRYPT, sec, NULL, 0,
+				speed_template_16_24_32);
+#endif
+#if 0
+		// ctr-aes
+		test_cipher_speed("ctr(aes)", ENCRYPT, sec, NULL, 0,
+				speed_template_16_24_32);
+		test_cipher_speed("ctr(aes)", DECRYPT, sec, NULL, 0,
+				speed_template_16_24_32);
+#endif
+		// TODO: aead
+
+		sec = 0;
 		break;
 
 	case 1:
@@ -524,6 +587,7 @@ static void do_test(int m)
 		tcrypt_test("cbc(aes)");
 		tcrypt_test("lrw(aes)");
 		tcrypt_test("xts(aes)");
+		tcrypt_test("ctr(aes)");
 		tcrypt_test("rfc3686(ctr(aes))");
 		break;
 
diff --git a/crypto/testmgr.c b/crypto/testmgr.c
index b50c3c6..6d557ec 100644
--- a/crypto/testmgr.c
+++ b/crypto/testmgr.c
@@ -1390,6 +1390,21 @@ static const struct alg_test_desc alg_test_descs[] = {
 			}
 		}
 	}, {
+		.alg = "ctr(aes)",
+		.test = alg_test_skcipher,
+		.suite = {
+			.cipher = {
+				.enc = {
+					.vecs = aes_ctr_enc_tv_template,
+					.count = AES_CTR_ENC_TEST_VECTORS
+				},
+				.dec = {
+					.vecs = aes_ctr_dec_tv_template,
+					.count = AES_CTR_DEC_TEST_VECTORS
+				}
+			}
+		}
+	}, {
 		.alg = "cts(cbc(aes))",
 		.test = alg_test_skcipher,
 		.suite = {
@@ -1839,12 +1854,12 @@ static const struct alg_test_desc alg_test_descs[] = {
 		.suite = {
 			.cipher = {
 				.enc = {
-					.vecs = aes_ctr_enc_tv_template,
-					.count = AES_CTR_ENC_TEST_VECTORS
+					.vecs = aes_ctr_rfc3686_enc_tv_template,
+					.count = AES_CTR_3686_ENC_TEST_VECTORS
 				},
 				.dec = {
-					.vecs = aes_ctr_dec_tv_template,
-					.count = AES_CTR_DEC_TEST_VECTORS
+					.vecs = aes_ctr_rfc3686_dec_tv_template,
+					.count = AES_CTR_3686_DEC_TEST_VECTORS
 				}
 			}
 		}
diff --git a/crypto/testmgr.h b/crypto/testmgr.h
index 526f00a..6c8875c 100644
--- a/crypto/testmgr.h
+++ b/crypto/testmgr.h
@@ -2841,8 +2841,10 @@ static struct cipher_testvec cast6_dec_tv_template[] = {
 #define AES_LRW_DEC_TEST_VECTORS 8
 #define AES_XTS_ENC_TEST_VECTORS 4
 #define AES_XTS_DEC_TEST_VECTORS 4
-#define AES_CTR_ENC_TEST_VECTORS 7
-#define AES_CTR_DEC_TEST_VECTORS 6
+#define AES_CTR_ENC_TEST_VECTORS 3
+#define AES_CTR_DEC_TEST_VECTORS 3
+#define AES_CTR_3686_ENC_TEST_VECTORS 7
+#define AES_CTR_3686_DEC_TEST_VECTORS 6
 #define AES_GCM_ENC_TEST_VECTORS 9
 #define AES_GCM_DEC_TEST_VECTORS 8
 #define AES_CCM_ENC_TEST_VECTORS 7
@@ -3983,6 +3985,164 @@ static struct cipher_testvec aes_xts_dec_tv_template[] = {
 
 
 static struct cipher_testvec aes_ctr_enc_tv_template[] = {
+	{ /* From NIST Special Publication 800-38A, Appendix F.5 */
+		.key	= "\x2b\x7e\x15\x16\x28\xae\xd2\xa6"
+			  "\xab\xf7\x15\x88\x09\xcf\x4f\x3c",
+		.klen	= 16,
+		.iv	= "\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7"
+			  "\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff",
+		.input	= "\x6b\xc1\xbe\xe2\x2e\x40\x9f\x96"
+			  "\xe9\x3d\x7e\x11\x73\x93\x17\x2a"
+			  "\xae\x2d\x8a\x57\x1e\x03\xac\x9c"
+			  "\x9e\xb7\x6f\xac\x45\xaf\x8e\x51"
+			  "\x30\xc8\x1c\x46\xa3\x5c\xe4\x11"
+			  "\xe5\xfb\xc1\x19\x1a\x0a\x52\xef"
+			  "\xf6\x9f\x24\x45\xdf\x4f\x9b\x17"
+			  "\xad\x2b\x41\x7b\xe6\x6c\x37\x10",
+		.ilen	= 64,
+		.result	= "\x87\x4d\x61\x91\xb6\x20\xe3\x26"
+			  "\x1b\xef\x68\x64\x99\x0d\xb6\xce"
+			  "\x98\x06\xf6\x6b\x79\x70\xfd\xff"
+			  "\x86\x17\x18\x7b\xb9\xff\xfd\xff"
+			  "\x5a\xe4\xdf\x3e\xdb\xd5\xd3\x5e"
+			  "\x5b\x4f\x09\x02\x0d\xb0\x3e\xab"
+			  "\x1e\x03\x1d\xda\x2f\xbe\x03\xd1"
+			  "\x79\x21\x70\xa0\xf3\x00\x9c\xee",
+		.rlen	= 64,
+	}, {
+		.key	= "\x8e\x73\xb0\xf7\xda\x0e\x64\x52"
+			  "\xc8\x10\xf3\x2b\x80\x90\x79\xe5"
+			  "\x62\xf8\xea\xd2\x52\x2c\x6b\x7b",
+		.klen	= 24,
+		.iv	= "\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7"
+			  "\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff",
+		.input	= "\x6b\xc1\xbe\xe2\x2e\x40\x9f\x96"
+			  "\xe9\x3d\x7e\x11\x73\x93\x17\x2a"
+			  "\xae\x2d\x8a\x57\x1e\x03\xac\x9c"
+			  "\x9e\xb7\x6f\xac\x45\xaf\x8e\x51"
+			  "\x30\xc8\x1c\x46\xa3\x5c\xe4\x11"
+			  "\xe5\xfb\xc1\x19\x1a\x0a\x52\xef"
+			  "\xf6\x9f\x24\x45\xdf\x4f\x9b\x17"
+			  "\xad\x2b\x41\x7b\xe6\x6c\x37\x10",
+		.ilen	= 64,
+		.result	= "\x1a\xbc\x93\x24\x17\x52\x1c\xa2"
+			  "\x4f\x2b\x04\x59\xfe\x7e\x6e\x0b"
+			  "\x09\x03\x39\xec\x0a\xa6\xfa\xef"
+			  "\xd5\xcc\xc2\xc6\xf4\xce\x8e\x94"
+			  "\x1e\x36\xb2\x6b\xd1\xeb\xc6\x70"
+			  "\xd1\xbd\x1d\x66\x56\x20\xab\xf7"
+			  "\x4f\x78\xa7\xf6\xd2\x98\x09\x58"
+			  "\x5a\x97\xda\xec\x58\xc6\xb0\x50",
+		.rlen	= 64,
+	}, {
+		.key	= "\x60\x3d\xeb\x10\x15\xca\x71\xbe"
+			  "\x2b\x73\xae\xf0\x85\x7d\x77\x81"
+			  "\x1f\x35\x2c\x07\x3b\x61\x08\xd7"
+			  "\x2d\x98\x10\xa3\x09\x14\xdf\xf4",
+		.klen	= 32,
+		.iv	= "\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7"
+			  "\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff",
+		.input	= "\x6b\xc1\xbe\xe2\x2e\x40\x9f\x96"
+			  "\xe9\x3d\x7e\x11\x73\x93\x17\x2a"
+			  "\xae\x2d\x8a\x57\x1e\x03\xac\x9c"
+			  "\x9e\xb7\x6f\xac\x45\xaf\x8e\x51"
+			  "\x30\xc8\x1c\x46\xa3\x5c\xe4\x11"
+			  "\xe5\xfb\xc1\x19\x1a\x0a\x52\xef"
+			  "\xf6\x9f\x24\x45\xdf\x4f\x9b\x17"
+			  "\xad\x2b\x41\x7b\xe6\x6c\x37\x10",
+		.ilen	= 64,
+		.result	= "\x60\x1e\xc3\x13\x77\x57\x89\xa5"
+			  "\xb7\xa7\xf5\x04\xbb\xf3\xd2\x28"
+			  "\xf4\x43\xe3\xca\x4d\x62\xb5\x9a"
+			  "\xca\x84\xe9\x90\xca\xca\xf5\xc5"
+			  "\x2b\x09\x30\xda\xa2\x3d\xe9\x4c"
+			  "\xe8\x70\x17\xba\x2d\x84\x98\x8d"
+			  "\xdf\xc9\xc5\x8d\xb6\x7a\xad\xa6"
+			  "\x13\xc2\xdd\x08\x45\x79\x41\xa6",
+		.rlen	= 64,
+	}
+};
+
+static struct cipher_testvec aes_ctr_dec_tv_template[] = {
+	{ /* From NIST Special Publication 800-38A, Appendix F.5 */
+		.key	= "\x2b\x7e\x15\x16\x28\xae\xd2\xa6"
+			  "\xab\xf7\x15\x88\x09\xcf\x4f\x3c",
+		.klen	= 16,
+		.iv	= "\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7"
+			  "\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff",
+		.input	= "\x87\x4d\x61\x91\xb6\x20\xe3\x26"
+			  "\x1b\xef\x68\x64\x99\x0d\xb6\xce"
+			  "\x98\x06\xf6\x6b\x79\x70\xfd\xff"
+			  "\x86\x17\x18\x7b\xb9\xff\xfd\xff"
+			  "\x5a\xe4\xdf\x3e\xdb\xd5\xd3\x5e"
+			  "\x5b\x4f\x09\x02\x0d\xb0\x3e\xab"
+			  "\x1e\x03\x1d\xda\x2f\xbe\x03\xd1"
+			  "\x79\x21\x70\xa0\xf3\x00\x9c\xee",
+		.ilen	= 64,
+		.result	= "\x6b\xc1\xbe\xe2\x2e\x40\x9f\x96"
+			  "\xe9\x3d\x7e\x11\x73\x93\x17\x2a"
+			  "\xae\x2d\x8a\x57\x1e\x03\xac\x9c"
+			  "\x9e\xb7\x6f\xac\x45\xaf\x8e\x51"
+			  "\x30\xc8\x1c\x46\xa3\x5c\xe4\x11"
+			  "\xe5\xfb\xc1\x19\x1a\x0a\x52\xef"
+			  "\xf6\x9f\x24\x45\xdf\x4f\x9b\x17"
+			  "\xad\x2b\x41\x7b\xe6\x6c\x37\x10",
+		.rlen	= 64,
+	}, {
+		.key	= "\x8e\x73\xb0\xf7\xda\x0e\x64\x52"
+			  "\xc8\x10\xf3\x2b\x80\x90\x79\xe5"
+			  "\x62\xf8\xea\xd2\x52\x2c\x6b\x7b",
+		.klen	= 24,
+		.iv	= "\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7"
+			  "\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff",
+		.input	= "\x1a\xbc\x93\x24\x17\x52\x1c\xa2"
+			  "\x4f\x2b\x04\x59\xfe\x7e\x6e\x0b"
+			  "\x09\x03\x39\xec\x0a\xa6\xfa\xef"
+			  "\xd5\xcc\xc2\xc6\xf4\xce\x8e\x94"
+			  "\x1e\x36\xb2\x6b\xd1\xeb\xc6\x70"
+			  "\xd1\xbd\x1d\x66\x56\x20\xab\xf7"
+			  "\x4f\x78\xa7\xf6\xd2\x98\x09\x58"
+			  "\x5a\x97\xda\xec\x58\xc6\xb0\x50",
+		.ilen	= 64,
+		.result	= "\x6b\xc1\xbe\xe2\x2e\x40\x9f\x96"
+			  "\xe9\x3d\x7e\x11\x73\x93\x17\x2a"
+			  "\xae\x2d\x8a\x57\x1e\x03\xac\x9c"
+			  "\x9e\xb7\x6f\xac\x45\xaf\x8e\x51"
+			  "\x30\xc8\x1c\x46\xa3\x5c\xe4\x11"
+			  "\xe5\xfb\xc1\x19\x1a\x0a\x52\xef"
+			  "\xf6\x9f\x24\x45\xdf\x4f\x9b\x17"
+			  "\xad\x2b\x41\x7b\xe6\x6c\x37\x10",
+		.rlen	= 64,
+	}, {
+		.key	= "\x60\x3d\xeb\x10\x15\xca\x71\xbe"
+			  "\x2b\x73\xae\xf0\x85\x7d\x77\x81"
+			  "\x1f\x35\x2c\x07\x3b\x61\x08\xd7"
+			  "\x2d\x98\x10\xa3\x09\x14\xdf\xf4",
+		.klen	= 32,
+		.iv	= "\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7"
+			  "\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff",
+		.input	= "\x60\x1e\xc3\x13\x77\x57\x89\xa5"
+			  "\xb7\xa7\xf5\x04\xbb\xf3\xd2\x28"
+			  "\xf4\x43\xe3\xca\x4d\x62\xb5\x9a"
+			  "\xca\x84\xe9\x90\xca\xca\xf5\xc5"
+			  "\x2b\x09\x30\xda\xa2\x3d\xe9\x4c"
+			  "\xe8\x70\x17\xba\x2d\x84\x98\x8d"
+			  "\xdf\xc9\xc5\x8d\xb6\x7a\xad\xa6"
+			  "\x13\xc2\xdd\x08\x45\x79\x41\xa6",
+		.ilen	= 64,
+		.result	= "\x6b\xc1\xbe\xe2\x2e\x40\x9f\x96"
+			  "\xe9\x3d\x7e\x11\x73\x93\x17\x2a"
+			  "\xae\x2d\x8a\x57\x1e\x03\xac\x9c"
+			  "\x9e\xb7\x6f\xac\x45\xaf\x8e\x51"
+			  "\x30\xc8\x1c\x46\xa3\x5c\xe4\x11"
+			  "\xe5\xfb\xc1\x19\x1a\x0a\x52\xef"
+			  "\xf6\x9f\x24\x45\xdf\x4f\x9b\x17"
+			  "\xad\x2b\x41\x7b\xe6\x6c\x37\x10",
+		.rlen	= 64,
+	}
+};
+
+static struct cipher_testvec aes_ctr_rfc3686_enc_tv_template[] = {
 	{ /* From RFC 3686 */
 		.key	= "\xae\x68\x52\xf8\x12\x10\x67\xcc"
 			  "\x4b\xf7\xa5\x76\x55\x77\xf3\x9e"
@@ -5114,7 +5274,7 @@ static struct cipher_testvec aes_ctr_enc_tv_template[] = {
 	},
 };
 
-static struct cipher_testvec aes_ctr_dec_tv_template[] = {
+static struct cipher_testvec aes_ctr_rfc3686_dec_tv_template[] = {
 	{ /* From RFC 3686 */
 		.key	= "\xae\x68\x52\xf8\x12\x10\x67\xcc"
 			  "\x4b\xf7\xa5\x76\x55\x77\xf3\x9e"
diff --git a/drivers/Makefile b/drivers/Makefile
index 1266ead..07366bb 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -24,7 +24,7 @@ obj-$(CONFIG_REGULATOR)		+= regulator/
 # char/ comes before serial/ etc so that the VT console is the boot-time
 # default.
 obj-y				+= char/
-
+obj-$(CONFIG_STAGING)		+= staging/
 # gpu/ comes after char for AGP vs DRM startup
 obj-y				+= gpu/
 
@@ -65,7 +65,7 @@ obj-$(CONFIG_USB_OTG_UTILS)	+= usb/otg/
 obj-$(CONFIG_USB)		+= usb/
 obj-$(CONFIG_USB_MUSB_HDRC)	+= usb/musb/
 obj-$(CONFIG_PCI)		+= usb/
-obj-$(CONFIG_USB_GADGET)	+= usb/gadget/
+## obj-$(CONFIG_USB_GADGET)	+= usb/gadget/
 obj-$(CONFIG_SERIO)		+= input/serio/
 obj-$(CONFIG_GAMEPORT)		+= input/gameport/
 obj-$(CONFIG_INPUT)		+= input/
@@ -105,5 +105,5 @@ obj-$(CONFIG_PPC_PS3)		+= ps3/
 obj-$(CONFIG_OF)		+= of/
 obj-$(CONFIG_SSB)		+= ssb/
 obj-$(CONFIG_VIRTIO)		+= virtio/
-obj-$(CONFIG_STAGING)		+= staging/
+
 obj-y				+= platform/
diff --git a/drivers/char/Makefile b/drivers/char/Makefile
index 060ae51..29adfc2 100644
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -100,6 +100,7 @@ obj-$(CONFIG_GPIO_TB0219)	+= tb0219.o
 obj-$(CONFIG_TELCLOCK)		+= tlclk.o
 obj-$(CONFIG_RTL_819X)		+= rtl_gpio.o
 obj-$(CONFIG_RTL_NFBI_MDIO)	+= rtl_mdio/
+obj-$(CONFIG_NFBI_HOST)		+= rtl_nfbi/
 
 obj-$(CONFIG_MWAVE)		+= mwave/
 obj-$(CONFIG_AGP)		+= agp/
diff --git a/drivers/char/rtl_gpio.c b/drivers/char/rtl_gpio.c
index 2269e7d..db5d5c5 100644
--- a/drivers/char/rtl_gpio.c
+++ b/drivers/char/rtl_gpio.c
@@ -6,27 +6,11 @@
  *
  *  Author: jimmylin@realtek.com.tw
  *
- * Copyright 2005 Realtek Semiconductor Corp.
+ *  Copyright (c) 2011 Realtek Semiconductor Corp.
  *
- *  This program is free software; you can redistribute  it and/or modify it
- *  under  the terms of  the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the  License, or (at your
- *  option) any later version.
- *
- *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
- *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
- *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
- *  NO  EVENT  SHALL   THE AUTHOR  BE	LIABLE FOR ANY   DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
- *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
- *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *  You should have received a copy of the  GNU General Public License along
- *  with this program; if not, write  to the Free Software Foundation, Inc.,
- *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
  */
 
 //#define CONFIG_USING_JTAG 1
@@ -49,27 +33,45 @@
 #include <linux/reboot.h>
 #include <linux/kmod.h>
 #include <linux/proc_fs.h>
-//#include  "bspchip.h"
+#include  "bspchip.h"
 #define AUTO_CONFIG
 
+#if defined (CONFIG_RTL_8196D) || defined(CONFIG_RTL_8196E)
+extern unsigned int get_8192cd_gpio0_7();
+#endif
+
 // 2009-0414
 //#define	DET_WPS_SPEC
 #ifndef CONFIG_RTK_VOIP_DRIVERS_ATA_DECT //DECT SPI use GPIO E interrupt, need refine code to share irq.
 #ifndef CONFIG_SERIAL_SC16IS7X0 //SC16IS7x0 use GPIO E interrupt, too.  
-#define USE_INTERRUPT_GPIO
+//#define USE_INTERRUPT_GPIO	//undefine USE_INTERRUPT_GPIO
 #endif
 #endif
 
-#if defined(CONFIG_RTL_8196C) || defined(CONFIG_RTL_8198)
-#ifndef CONFIG_RTK_VOIP
+/*
+enabled immediate mode pbc ; must enabled "USE_INTERRUPT_GPIO" and "IMMEDIATE_PBC"
+gpio will rx pbc event and trigger wscd by signal method
+note:also need enabled IMMEDIATE_PBC at wsc.h (sdk/users/wsc/src/)
+*/
+//#define USE_INTERRUPT_GPIO	//undefine USE_INTERRUPT_GPIO
+//#define IMMEDIATE_PBC 
+
+
+#ifdef IMMEDIATE_PBC
+int	wscd_pid = 0;
+struct pid *wscd_pid_Ptr=NULL;
+#endif
+
+#if defined(CONFIG_RTL_8196C) || defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+#ifndef CONFIG_RTK_VOIP_BOARD
 	#define READ_RF_SWITCH_GPIO
 #endif
 #endif
 
-#if defined(CONFIG_RTL_8196C) || defined(CONFIG_RTL_8198)
+#if defined(CONFIG_RTL_8196C) || defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 	#include "drivers/net/rtl819x/AsicDriver/rtl865xc_asicregs.h"
 /*define the GPIO physical address to customer_gpio.h*/
-#ifdef CONFIG_RTK_VOIP
+#ifdef CONFIG_RTK_VOIP_BOARD
 	#if defined (CONFIG_RTK_VOIP_GPIO_8954C_V100) || \
 		defined (CONFIG_RTK_VOIP_GPIO_8964C_QA)
 	
@@ -129,6 +131,81 @@
 		#define AUTOCFG_PIN_NO 11 				//pin number of the EFGH
 		#define AUTOCFG_PIN_IMR PEF_IMR
 		#define RTL_GPIO_MUX_DATA 0x00000300 	//MUX for GPIO
+
+	#elif defined(CONFIG_RTK_VOIP_GPIO_8954C_SOUNDWIN_XVN1420)
+		// GPIO F4 DEFAULT_Button
+		#define RESET_PIN_IOBASE PEFGH_CNR 		//RTL_GPIO_PEFGH_CNR
+		#define RESET_PIN_DIRBASE PEFGH_DIR		//RTL_GPIO_PEFGH_DIR 
+		#define RESET_PIN_DATABASE PEFGH_DAT 	//RTL_GPIO_PEFGH_DATA
+		#define RESET_PIN_NO 12 				//pin number of the EFGH
+		
+		// No SYS LED
+		
+		// No WPS LED
+		
+		// GPIO D1 WPS Button
+		#define AUTOCFG_PIN_IOBASE PABCD_CNR 	//RTL_GPIO_PEFGH_CNR
+		#define AUTOCFG_PIN_DIRBASE PABCD_DIR	//RTL_GPIO_PEFGH_DIR 
+		#define AUTOCFG_PIN_DATABASE PABCD_DAT  //RTL_GPIO_PEFGH_DATA
+		#define AUTOCFG_PIN_NO 25 				//pin number of the EFGH
+		#define AUTOCFG_PIN_IMR PCD_IMR
+		#define RTL_GPIO_MUX_DATA 0x00000300 	//MUX for GPIO
+
+	#elif defined(CONFIG_RTK_VOIP_GPIO_8954C_PMC)
+
+                // GPIO A3 DEFAULT_Button
+                #define RESET_PIN_IOBASE PABCD_CNR              //RTL_GPIO_PABCD_CNR
+                #define RESET_PIN_DIRBASE PABCD_DIR             //RTL_GPIO_PABCD_DIR
+                #define RESET_PIN_DATABASE PABCD_DAT    //RTL_GPIO_PABCD_DATA
+                #define RESET_PIN_NO 3                                 //pin number of the ABCD
+
+                // GPIO C1 SYS LED
+                #define RESET_LED_IOBASE PABCD_CNR              //RTL_GPIO_PABCD_CNR
+                #define RESET_LED_DIRBASE PABCD_DIR             //RTL_GPIO_PABCD_DIR
+                #define RESET_LED_DATABASE PABCD_DAT    //RTL_GPIO_PABCD_DATA
+                #define RESET_LED_NO 16                                  //number of the ABCD
+
+                // GPIO A1 WPS LED
+                #define AUTOCFG_LED_IOBASE PABCD_CNR    //RTL_GPIO_PABCD_CNR
+                #define AUTOCFG_LED_DIRBASE PABCD_DIR   //RTL_GPIO_PABCD_DIR
+                #define AUTOCFG_LED_DATABASE PABCD_DAT  //RTL_GPIO_PABCD_DATA
+                #define AUTOCFG_LED_NO 1                                //pin number of the ABCD
+
+                // GPIO A2 WPS Button
+                #define AUTOCFG_PIN_IOBASE PABCD_CNR    //RTL_GPIO_PABCD_CNR
+                #define AUTOCFG_PIN_DIRBASE PABCD_DIR   //RTL_GPIO_PABCD_DIR
+                #define AUTOCFG_PIN_DATABASE PABCD_DAT  //RTL_GPIO_PABCD_DATA
+                #define AUTOCFG_PIN_NO 2                               //pin number of the ABCD
+                #define AUTOCFG_PIN_IMR PEF_IMR
+                #define RTL_GPIO_MUX_DATA 0x00000018    //MUX for GPIO
+		#define RTL_GPIO_MUX2_DATA 0x00038000
+	#elif defined(CONFIG_RTK_VOIP_GPIO_8972D_V100)
+		// GPIO G2 DEFAULT_Button
+		#define RESET_PIN_IOBASE PEFGH_CNR 		//RTL_GPIO_PEFGH_CNR
+		#define RESET_PIN_DIRBASE PEFGH_DIR		//RTL_GPIO_PEFGH_DIR 
+		#define RESET_PIN_DATABASE PEFGH_DAT 	//RTL_GPIO_PEFGH_DATA
+		#define RESET_PIN_NO 18 				//pin number of the EFGH
+
+		// GPIO G3 SYS LED
+		#define RESET_LED_IOBASE PEFGH_CNR 		//RTL_GPIO_PEFGH_CNR
+		#define RESET_LED_DIRBASE PEFGH_DIR		//RTL_GPIO_PEFGH_DIR 
+		#define RESET_LED_DATABASE PEFGH_DAT 	//RTL_GPIO_PEFGH_DATA
+		#define RESET_LED_NO 19 					//number of the EFGH
+		
+		// GPIO G4 WPS LED
+		#define AUTOCFG_LED_IOBASE PEFGH_CNR 	//RTL_GPIO_PEFGH_CNR
+		#define AUTOCFG_LED_DIRBASE PEFGH_DIR	//RTL_GPIO_PEFGH_DIR 
+		#define AUTOCFG_LED_DATABASE PEFGH_DAT  //RTL_GPIO_PEFGH_DATA
+		#define AUTOCFG_LED_NO 20 				//pin number of the EFGH
+
+		// GPIO G1 WPS Button
+		#define AUTOCFG_PIN_IOBASE PEFGH_CNR 	//RTL_GPIO_PEFGH_CNR
+		#define AUTOCFG_PIN_DIRBASE PEFGH_DIR	//RTL_GPIO_PEFGH_DIR 
+		#define AUTOCFG_PIN_DATABASE PEFGH_DAT  //RTL_GPIO_PEFGH_DATA
+		#define AUTOCFG_PIN_NO 17 				//pin number of the EFGH
+		#define AUTOCFG_PIN_IMR PEF_IMR
+  
+    		#define RTL_GPIO_MUX_DATA 0x00000C00 	//MUX for GPIO
     #endif
 	
 	#define RTL_GPIO_MUX 0xB8000040
@@ -244,7 +321,7 @@
 #endif
 
 	
-#elif defined(CONFIG_RTL_8198)
+#elif defined(CONFIG_RTL_8198)// || defined(CONFIG_RTL_819XD) //LZQ
 	// GPIO H1
 	#define RESET_PIN_IOBASE PEFGH_CNR 	//RTL_GPIO_PABCD_CNR
 	#define RESET_PIN_DIRBASE PEFGH_DIR	//RTL_GPIO_PABCD_DIR 
@@ -269,7 +346,38 @@
 	#define AUTOCFG_PIN_DATABASE PEFGH_DAT //RTL_GPIO_PABCD_DATA
 	#define AUTOCFG_PIN_NO 1 /*number of the ABCD)*/
 	#define AUTOCFG_PIN_IMR PGH_IMR
+
 	
+#elif defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)	//LZQ
+	//V201 demo board 
+	#define RESET_PIN_IOBASE 	PABCD_CNR	//RTL_GPIO_PABCD_CNR
+	#define RESET_PIN_DIRBASE 	PABCD_DIR //RTL_GPIO_PABCD_DIR 
+	#define RESET_PIN_DATABASE 	PABCD_DAT //RTL_GPIO_PABCD_DATA
+	#define RESET_PIN_NO 25 /*number of the ABCD*/
+
+	#define RESET_LED_IOBASE 	PABCD_CNR	//RTL_GPIO_PABCD_CNR
+	#define RESET_LED_DIRBASE 	PABCD_DIR //RTL_GPIO_PABCD_DIR 
+	#define RESET_LED_DATABASE 	PABCD_DAT //RTL_GPIO_PABCD_DATA
+	#define RESET_LED_NO 27 /*number of the ABCD*/
+
+	#define AUTOCFG_LED_IOBASE 	PABCD_CNR	//RTL_GPIO_PABCD_CNR
+	#define AUTOCFG_LED_DIRBASE PABCD_DIR	//RTL_GPIO_PABCD_DIR 
+	#define AUTOCFG_LED_DATABASE PABCD_DAT //RTL_GPIO_PABCD_DATA
+	#define AUTOCFG_LED_NO 20 /*number of the ABCD*/
+
+	#define AUTOCFG_PIN_IOBASE 	PABCD_CNR	//RTL_GPIO_PABCD_CNR
+	#define AUTOCFG_PIN_DIRBASE PABCD_DIR	//RTL_GPIO_PABCD_DIR 
+	#define AUTOCFG_PIN_DATABASE PABCD_DAT 	//RTL_GPIO_PABCD_DATA
+	#define AUTOCFG_PIN_NO 1 					/*number of the ABCD)*/
+	#define AUTOCFG_PIN_IMR 	PAB_IMR
+	
+	#if defined (CONFIG_RTL_8197D)
+		#define USB_MODE_DETECT_PIN_NO			1
+		#define USB_MODE_DETECT_PIN_IOBASE		PABCD_DAT
+	#elif defined(CONFIG_RTL_8196D) || defined(CONFIG_RTL_8196E)
+		#define USB_MODE_DETECT_PIN_NO			4
+		//#define USB_MODE_DETECT_PIN_IOBASE		PABCD_DAT
+	#endif
 #endif
 	// GPIO C3
 	#define WIFI_ONOFF_PIN_IOBASE PABCD_CNR 	//RTL_GPIO_PABCD_CNR
@@ -311,11 +419,80 @@
 	 #define RESET_BTN_PIN           5
 	#endif
 	
-#elif defined(CONFIG_RTL_8198)
+#elif defined(CONFIG_RTL_8198) //|| defined(CONFIG_RTL_819XD) LZQ
 	 #define AUTOCFG_BTN_PIN         24
 	 #define AUTOCFG_LED_PIN         26
 	 #define RESET_LED_PIN           27
 	 #define RESET_BTN_PIN           25
+
+#elif defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+
+	#define RTL_GPIO_MUX_GPIOA2_6 (6<<0)
+	#define RTL_GPIO_MUX_GPIOA0_1 (3<<12)
+	#define RTL_GPIO_MUX_2_GPIOB7 (4<<15)	
+	#define RTL_GPIO_MUX_2_GPIOC0 (4<<18)
+	
+	#define RTL_GPIO_CNR_GPIOA1 (1<<1)
+	#define RTL_GPIO_CNR_GPIOA2 (1<<2)
+	#define RTL_GPIO_CNR_GPIOA3 (1<<3)
+	#define RTL_GPIO_CNR_GPIOA4 (1<<4)
+	#define RTL_GPIO_CNR_GPIOA5 (1<<5)
+	#define RTL_GPIO_CNR_GPIOA6 (1<<6)
+	#define RTL_GPIO_CNR_GPIOB7 (1<<15) 
+	#define RTL_GPIO_CNR_GPIOC0 (1<<16)
+
+	#define RTL_GPIO_DIR_GPIOA1 (1<<1) /* &- */
+	#define RTL_GPIO_DIR_GPIOA2 (1<<2) /* |*/
+	#define RTL_GPIO_DIR_GPIOA3 (1<<3) /* &-*/	
+	#define RTL_GPIO_DIR_GPIOA4 (1<<4) /* &- */
+	#define RTL_GPIO_DIR_GPIOA5 (1<<5) /* &- */
+	#define RTL_GPIO_DIR_GPIOA6 (1<<6) /* | */
+	#define RTL_GPIO_DIR_GPIOB7 (1<<15) /* &-*/	
+	#define RTL_GPIO_DIR_GPIOC0 (1<<16) /* &- */
+
+	#define RTL_GPIO_DAT_GPIOA1 (1<<1) 
+	#define RTL_GPIO_DAT_GPIOA2 (1<<2) 
+	#define RTL_GPIO_DAT_GPIOA3 (1<<3) 	
+	#define RTL_GPIO_DAT_GPIOA4 (1<<4) 
+	#define RTL_GPIO_DAT_GPIOA5 (1<<5) 
+	#define RTL_GPIO_DAT_GPIOA6 (1<<6) 
+	#define RTL_GPIO_DAT_GPIOB7 (1<<15) 	
+	#define RTL_GPIO_DAT_GPIOC0 (1<<16) 
+
+	#if defined(CONFIG_RTL_8197D)
+
+		#define RTL_GPIO_MUX_POCKETAP_DATA		(RTL_GPIO_MUX_GPIOA0_1 | RTL_GPIO_MUX_GPIOA2_6)
+		#define RTL_GPIO_MUX_2_POCKETAP_DATA	(RTL_GPIO_MUX_2_GPIOB7 | RTL_GPIO_MUX_2_GPIOC0)
+		#define RTL_GPIO_CNR_POCKETAP_DATA		(RTL_GPIO_CNR_GPIOA1 | \
+												 RTL_GPIO_CNR_GPIOA2 | \
+												 RTL_GPIO_CNR_GPIOA3 | \
+												 RTL_GPIO_CNR_GPIOA4 | \
+												 RTL_GPIO_CNR_GPIOA5 | \
+												 RTL_GPIO_CNR_GPIOA6 | \
+												 RTL_GPIO_CNR_GPIOB7 | \
+												 RTL_GPIO_CNR_GPIOC0)
+
+	
+		#define AUTOCFG_LED_PIN 			6
+		#define AUTOCFG_BTN_PIN         	3
+		#define RESET_LED_PIN           	6//reset led will be turn off by timer function
+		#define RESET_BTN_PIN           	5
+	#elif defined(CONFIG_RTL_8196D) || defined(CONFIG_RTL_8196E)
+
+		#define RTL_GPIO_MUX_POCKETAP_DATA	(RTL_GPIO_MUX_GPIOA2_6)
+		#define RTL_GPIO_CNR_POCKETAP_DATA	(RTL_GPIO_CNR_GPIOA2 | \
+											 RTL_GPIO_CNR_GPIOA4 | \
+											 RTL_GPIO_CNR_GPIOA5 | \
+											 RTL_GPIO_CNR_GPIOA6)
+
+	
+		#define AUTOCFG_LED_PIN 			6
+		#define AUTOCFG_BTN_PIN         	2
+		#define RESET_LED_PIN           	6
+		#define RESET_BTN_PIN           	5		
+		
+	
+	#endif
 #endif	 
 
 #endif // CONFIG_RTK_VOIP
@@ -361,7 +538,13 @@ int Reboot_Wait=0;
 
 static int get_dc_pwr_plugged_state();
 
-
+#if defined(USE_INTERRUPT_GPIO)
+struct gpio_wps_device
+{
+	unsigned int name;
+};
+struct gpio_wps_device priv_gpio_wps_device;
+#endif
 
 //#ifdef CONFIG_RTL865X_AC
 
@@ -369,10 +552,15 @@ static int get_dc_pwr_plugged_state();
 static struct timer_list pocket_ap_timer;
 #endif
 
-#ifdef	USE_INTERRUPT_GPIO
+#ifdef CONFIG_RTL_ULINKER
+static struct timer_list ulinker_timer;
+static struct timer_list ulinker_ap_cl_timer;
+#endif
+
+//#ifdef	USE_INTERRUPT_GPIO
 static int wps_button_push = 0;
+//#endif
 
-#endif
 #if defined(CONFIG_RTL_8196CS)
 void update_pcie_status(void)
 {
@@ -410,17 +598,21 @@ void autoconfig_gpio_init(void)
 	//printk("LINE: %x d:%x *  %x****R:%x\n",__LINE__,RTL_R32(0xb8b00728),RTL_R32(PCIE_PIN_MUX),RTL_R32(RESET_PIN_DATABASE));
 #else
 	RTL_W32(AUTOCFG_PIN_IOBASE,(RTL_R32(AUTOCFG_PIN_IOBASE)&(~(1 << AUTOCFG_BTN_PIN))));
+#ifdef AUTOCFG_LED_NO
 	RTL_W32(AUTOCFG_LED_IOBASE,(RTL_R32(AUTOCFG_LED_IOBASE)&(~(1 << AUTOCFG_LED_PIN))));
+   #endif
 
 	// Set GPIOA pin 1 as input pin for auto config button
 	RTL_W32(AUTOCFG_PIN_DIRBASE, (RTL_R32(AUTOCFG_PIN_DIRBASE) & (~(1 << AUTOCFG_BTN_PIN))));
 
+#ifdef AUTOCFG_LED_NO
 	// Set GPIOA ping 3 as output pin for auto config led
 	RTL_W32(AUTOCFG_LED_DIRBASE, (RTL_R32(AUTOCFG_LED_DIRBASE) | (1 << AUTOCFG_LED_PIN)));
 
 	// turn off auto config led in the beginning
 	RTL_W32(AUTOCFG_LED_DATABASE, (RTL_R32(AUTOCFG_LED_DATABASE) | (1 << AUTOCFG_LED_PIN)));
 #endif
+#endif
 }
 #ifdef CONFIG_RTL_8196C_GW_MP
 
@@ -491,27 +683,64 @@ void autoconfig_gpio_blink(void)
 
 }
 
+#elif defined(CONFIG_RTL_ULINKER)
+extern void set_sys_LED(int on);
+void autoconfig_gpio_off(void)
+{
+	set_sys_LED(0);
+	AutoCfg_LED_Blink = 0;
+}
+
+void autoconfig_gpio_on(void)
+{
+	set_sys_LED(1);
+	AutoCfg_LED_Blink = 0;
+}
+
+void autoconfig_gpio_blink(void)
+{
+	set_sys_LED(1);
+
+	AutoCfg_LED_Blink = 1;
+	AutoCfg_LED_Toggle = 1;
+	AutoCfg_LED_Slow_Blink = 0;
+
+}
+
+void autoconfig_gpio_slow_blink(void)
+{
+	set_sys_LED(1);
 
+	AutoCfg_LED_Blink = 1;
+	AutoCfg_LED_Toggle = 1;
+	AutoCfg_LED_Slow_Blink = 1;
+	AutoCfg_LED_Slow_Toggle = 1;
 
+}
 #else
 void autoconfig_gpio_off(void)
 {
+   #ifdef AUTOCFG_LED_NO
 	RTL_W32(AUTOCFG_LED_DATABASE, (RTL_R32(AUTOCFG_LED_DATABASE) | (1 << AUTOCFG_LED_PIN)));
+   #endif
 	AutoCfg_LED_Blink = 0;
 }
 
 
 void autoconfig_gpio_on(void)
 {
+   #ifdef AUTOCFG_LED_NO
 	RTL_W32(AUTOCFG_LED_DATABASE, (RTL_R32(AUTOCFG_LED_DATABASE) & (~(1 << AUTOCFG_LED_PIN))));
+   #endif
 	AutoCfg_LED_Blink = 0;
 }
 
 
 void autoconfig_gpio_blink(void)
 {
+   #ifdef AUTOCFG_LED_NO
 	RTL_W32(AUTOCFG_LED_DATABASE, (RTL_R32(AUTOCFG_LED_DATABASE) & (~(1 << AUTOCFG_LED_PIN))));
-
+   #endif
 	AutoCfg_LED_Blink = 1;
 	AutoCfg_LED_Toggle = 1;
 	AutoCfg_LED_Slow_Blink = 0;
@@ -520,8 +749,9 @@ void autoconfig_gpio_blink(void)
 
 void autoconfig_gpio_slow_blink(void)
 {
+   #ifdef AUTOCFG_LED_NO
 	RTL_W32(AUTOCFG_LED_DATABASE, (RTL_R32(AUTOCFG_LED_DATABASE) & (~(1 << AUTOCFG_LED_PIN))));
-	
+   #endif	
 	AutoCfg_LED_Blink = 1;
 	AutoCfg_LED_Toggle = 1;
 	AutoCfg_LED_Slow_Blink = 1;
@@ -546,18 +776,20 @@ static void rtl_gpio_timer(unsigned long data)
 #if defined(CONFIG_RTL_8196CS)
 	update_pcie_status();
 #endif
-#if  defined(CONFIG_RTL_8196C) || defined(CONFIG_RTL_8198)
+#if  defined(CONFIG_RTL_8196C) || defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 
 	if ((RTL_R32(RESET_PIN_DATABASE) & (1 << RESET_BTN_PIN)))
-
 #endif
 	{
 		pressed = 0;
-
+		#if !defined(CONFIG_RTL_819XD) && !defined(CONFIG_RTL_8196E) || defined(CONFIG_RTK_VOIP_BOARD)
 		//turn off LED0
+                #ifdef RESET_LED_NO
 		#ifndef CONFIG_RTL_8196C_GW_MP
 		RTL_W32(RESET_LED_DATABASE, (RTL_R32(RESET_LED_DATABASE) | ((1 << RESET_LED_PIN))));
 		#endif
+		#endif
+		#endif
 	}
 	else
 	{
@@ -565,9 +797,13 @@ static void rtl_gpio_timer(unsigned long data)
 	}
 
 	if (RTL_R32(AUTOCFG_PIN_DATABASE) & (1 << AUTOCFG_BTN_PIN)){
+#ifdef USE_INTERRUPT_GPIO
 		wps_button_push = 0;
+#endif
 	}else{
+#ifdef USE_INTERRUPT_GPIO
 		wps_button_push++;
+#endif
 	}
 
 	if (probe_state == PROBE_NULL)
@@ -590,17 +826,32 @@ static void rtl_gpio_timer(unsigned long data)
 			{
 				DPRINTK("2-5 turn on led\n");
 				//turn on LED0
+			#ifdef RESET_LED_NO
+			  #if defined(CONFIG_RTL_ULINKER)
+			  	set_sys_LED(1);
+			  #else
 				RTL_W32(RESET_LED_DATABASE, (RTL_R32(RESET_LED_DATABASE) & (~(1 << RESET_LED_PIN))));
+			  #endif
+            #endif
 			}
 			else if (probe_counter >= PROBE_TIME)
 			{
 				// sparkling LED0
 				DPRINTK(">5 \n");
 
+            #ifdef RESET_LED_NO
+			  #if defined(CONFIG_RTL_ULINKER)
+			  	if (probe_counter & 1)
+					set_sys_LED(0);
+				else
+					set_sys_LED(1);
+			  #else
 				if (probe_counter & 1)
 					RTL_W32(RESET_LED_DATABASE, (RTL_R32(RESET_LED_DATABASE) | ((1 << RESET_LED_PIN))));
 				else
 					RTL_W32(RESET_LED_DATABASE, (RTL_R32(RESET_LED_DATABASE) & (~(1 << RESET_LED_PIN))));
+			  #endif
+            #endif
 			}
 		}
 		else
@@ -649,19 +900,26 @@ static void rtl_gpio_timer(unsigned long data)
 	if (AutoCfg_LED_Blink==1)
 	{
 		if (AutoCfg_LED_Toggle) {
-		#if defined(CONFIG_RTL_8196CS)
+		#ifdef AUTOCFG_LED_NO
+		#if defined(CONFIG_RTL_8196CS)
 			RTL_W32(AUTOCFG_LED_DATABASE, (RTL_R32(AUTOCFG_LED_DATABASE) | ((1 << AUTOCFG_LED_PIN)<<OUT_MASK1)));
+		#elif defined(CONFIG_RTL_ULINKER)
+			set_sys_LED(0);
 		#else
 			RTL_W32(AUTOCFG_LED_DATABASE, (RTL_R32(AUTOCFG_LED_DATABASE) | (1 << AUTOCFG_LED_PIN)));
 		#endif
+		#endif
 		}
 		else {
+		#ifdef AUTOCFG_LED_NO
 			#if defined(CONFIG_RTL_8196CS)
 			RTL_W32(AUTOCFG_LED_DATABASE, (RTL_R32(AUTOCFG_LED_DATABASE) & (~((1 << AUTOCFG_LED_PIN)<<OUT_MASK1))));
+			#elif defined(CONFIG_RTL_ULINKER)
+			set_sys_LED(1);
 			#else
 			 RTL_W32(AUTOCFG_LED_DATABASE, (RTL_R32(AUTOCFG_LED_DATABASE) & (~(1 << AUTOCFG_LED_PIN))));
 			#endif
-			
+		#endif
 		}
 				
 		if(AutoCfg_LED_Slow_Blink)
diff --git a/drivers/char/rtl_mdio/rtl_mdio.c b/drivers/char/rtl_mdio/rtl_mdio.c
index 85cc3ff..2d41736 100644
--- a/drivers/char/rtl_mdio/rtl_mdio.c
+++ b/drivers/char/rtl_mdio/rtl_mdio.c
@@ -1,29 +1,12 @@
 /*
-################################################################################
-# 
-# RTL8198 MDIO char driver
-# 
-# Copyright(c) 2010 Realtek Semiconductor Corp. All rights reserved.
-# 
-# This program is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by the Free
-# Software Foundation; either version 2 of the License, or (at your option)
-# any later version.
-# 
-# This program is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
-# more details.
-# 
-# You should have received a copy of the GNU General Public License along with
-# this program; if not, see <http://www.gnu.org/licenses/>.
-# 
-# Author:
-# Realtek WiFi AP software team <cn_sd8@realtek.com>
-# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
-# 
-################################################################################
-*/
+ *
+ *  Copyright (c) 2011 Realtek Semiconductor Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
 /*================================================================*/
 /* System Include Files */
 
diff --git a/drivers/crypto/Kconfig b/drivers/crypto/Kconfig
index 01afd75..135f478 100644
--- a/drivers/crypto/Kconfig
+++ b/drivers/crypto/Kconfig
@@ -209,4 +209,26 @@ config CRYPTO_DEV_PPC4XX
 	help
 	  This option allows you to have support for AMCC crypto acceleration.
 
+config CRYPTO_DEV_REALTEK
+	tristate "Driver Realtek Crypto Engine"
+	select CRYPTO_HASH
+	select CRYPTO_ALGAPI
+	select CRYPTO_BLKCIPHER
+	select CRYPTO_CBC
+	select CRYPTO_CTR
+	select CRYPTO_ECB
+	select CRYPTO_MD5
+	select CRYPTO_SHA1
+	select CRYPTO_AES
+	select CRYPTO_DES
+	help
+	  This option allows you to have support for Realtek Crypto Engine.
+
+config CRYPTO_DEV_REALTEK_TEST
+	tristate "Driver Realtek Crypto Engine Test"
+	select CRYPTO_TEST
+	depends on CRYPTO_DEV_REALTEK
+	help
+	  This option for Realtek Crypto Engine Internal Test.
+
 endif # CRYPTO_HW
diff --git a/drivers/crypto/Makefile b/drivers/crypto/Makefile
index 9bf4a2b..b79f0c6 100644
--- a/drivers/crypto/Makefile
+++ b/drivers/crypto/Makefile
@@ -5,3 +5,4 @@ obj-$(CONFIG_CRYPTO_DEV_HIFN_795X) += hifn_795x.o
 obj-$(CONFIG_CRYPTO_DEV_TALITOS) += talitos.o
 obj-$(CONFIG_CRYPTO_DEV_IXP4XX) += ixp4xx_crypto.o
 obj-$(CONFIG_CRYPTO_DEV_PPC4XX) += amcc/
+obj-$(CONFIG_CRYPTO_DEV_REALTEK) += realtek/
diff --git a/drivers/gpu/drm/i915/intel_bios.c b/drivers/gpu/drm/i915/intel_bios.c
index cf2a971..cb9d85a 100644
--- a/drivers/gpu/drm/i915/intel_bios.c
+++ b/drivers/gpu/drm/i915/intel_bios.c
@@ -188,7 +188,7 @@ parse_general_features(struct drm_i915_private *dev_priv,
 			if (IS_I85X(dev_priv->dev))
 				dev_priv->lvds_ssc_freq =
 					general->ssc_freq ? 66 : 48;
-			else
+		  else
 				dev_priv->lvds_ssc_freq =
 					general->ssc_freq ? 100 : 96;
 		}
diff --git a/drivers/gpu/drm/i915/intel_fb.c b/drivers/gpu/drm/i915/intel_fb.c
index 7a66b91..c1c7ac1 100644
--- a/drivers/gpu/drm/i915/intel_fb.c
+++ b/drivers/gpu/drm/i915/intel_fb.c
@@ -859,7 +859,7 @@ void intelfb_restore(void)
 
 static void intelfb_restore_work_fn(struct work_struct *ignored)
 {
-	intelfb_restore();
+        intelfb_restore();
 }
 static DECLARE_WORK(intelfb_restore_work, intelfb_restore_work_fn);
 
diff --git a/drivers/hwmon/asus_atk0110.c b/drivers/hwmon/asus_atk0110.c
index fe4fa29..73fa891 100644
--- a/drivers/hwmon/asus_atk0110.c
+++ b/drivers/hwmon/asus_atk0110.c
@@ -594,7 +594,7 @@ static int atk_add_sensor(struct atk_data *data, union acpi_object *obj)
 	sensor->id = flags->integer.value;
 	sensor->limit1 = limit1->integer.value;
 	if (data->old_interface)
-		sensor->limit2 = limit2->integer.value;
+	sensor->limit2 = limit2->integer.value;
 	else
 		/* The upper limit is expressed as delta from lower limit */
 		sensor->limit2 = sensor->limit1 + limit2->integer.value;
diff --git a/drivers/i2c/chips/tsl2550.c b/drivers/i2c/chips/tsl2550.c
index b96f302..cc3a1cf 100644
--- a/drivers/i2c/chips/tsl2550.c
+++ b/drivers/i2c/chips/tsl2550.c
@@ -191,10 +191,10 @@ static int tsl2550_calculate_lux(u8 ch0, u8 ch1)
 	/* Avoid division by 0 and count 1 cannot be greater than count 0 */
 	if (c1 <= c0)
 		if (c0) {
-			r = c1 * 128 / c0;
+		r = c1 * 128 / c0;
 
-			/* Calculate LUX */
-			lux = ((c0 - c1) * ratio_lut[r]) / 256;
+	/* Calculate LUX */
+	lux = ((c0 - c1) * ratio_lut[r]) / 256;
 		} else
 			lux = 0;
 	else
diff --git a/drivers/input/joydev.c b/drivers/input/joydev.c
index 7ec7bcb..3808cff 100644
--- a/drivers/input/joydev.c
+++ b/drivers/input/joydev.c
@@ -557,7 +557,7 @@ static int joydev_ioctl_common(struct joydev *joydev,
 	case JSIOCGNAME(0):
 		name = dev->name;
 		if (!name)
-			return 0;
+				return 0;
 
 		len = min_t(size_t, _IOC_SIZE(cmd), strlen(name) + 1);
 		return copy_to_user(argp, name, len) ? -EFAULT : len;
diff --git a/drivers/md/dm-snap-persistent.c b/drivers/md/dm-snap-persistent.c
index aa02fe5..bcc76bd 100644
--- a/drivers/md/dm-snap-persistent.c
+++ b/drivers/md/dm-snap-persistent.c
@@ -334,10 +334,10 @@ static int read_header(struct pstore *ps, int *new_snapshot)
 		return 0;
 
 	if (chunk_size_supplied)
-		DMWARN("chunk size %llu in device metadata overrides "
-		       "table chunk size of %llu.",
-		       (unsigned long long)chunk_size,
-		       (unsigned long long)ps->store->chunk_size);
+	DMWARN("chunk size %llu in device metadata overrides "
+	       "table chunk size of %llu.",
+	       (unsigned long long)chunk_size,
+	       (unsigned long long)ps->store->chunk_size);
 
 	/* We had a bogus chunk_size. Fix stuff up. */
 	free_area(ps);
diff --git a/drivers/mtd/chips/cfi_cmdset_0001.c b/drivers/mtd/chips/cfi_cmdset_0001.c
index c240454..fd83c9f 100644
--- a/drivers/mtd/chips/cfi_cmdset_0001.c
+++ b/drivers/mtd/chips/cfi_cmdset_0001.c
@@ -1,20 +1,10 @@
 /*
- * Common Flash Interface support:
- *   Intel Extended Vendor Command Set (ID 0x0001)
  *
- * (C) 2000 Red Hat. GPL'd
+ *  Copyright (c) 2011 Realtek Semiconductor Corp.
  *
- *
- * 10/10/2000	Nicolas Pitre <nico@cam.org>
- * 	- completely revamped method functions so they are aware and
- * 	  independent of the flash geometry (buswidth, interleave, etc.)
- * 	- scalability vs code size is completely set at compile-time
- * 	  (see include/linux/mtd/cfi.h for selection)
- *	- optimized write buffer method
- * 02/05/2002	Christopher Hoover <ch@hpl.hp.com>/<ch@murgatroid.com>
- *	- reworked lock/unlock/erase support for var size flash
- * 21/03/2007   Rodolfo Giometti <giometti@linux.it>
- * 	- auto unlock sectors on resume for auto locking flash on power up
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
  */
 
 #include <linux/module.h>
diff --git a/drivers/mtd/chips/rtl819x/spi_common.c b/drivers/mtd/chips/rtl819x/spi_common.c
index 89c49ed..6ca0d0d 100644
--- a/drivers/mtd/chips/rtl819x/spi_common.c
+++ b/drivers/mtd/chips/rtl819x/spi_common.c
@@ -1,1208 +1,1232 @@
-/* SPI Flash driver
- *
- * Written by sam (sam@realtek.com)
- * 2010-05-01
- *
- */
-
-#define MTD_SPI_DEBUG		2
-#define MTD_SPI_TEST_CHIP	0
-#include "spi_common.h"
-
-#ifndef SPI_KERNEL
-// ****** spi flash driver in bootcode
-
-#include <asm/rtl8196x.h>
-#include <rtl_types.h>
-#if (MTD_SPI_DEBUG == 0)
-//0
-#define NDEBUG(args...) printf(args)
-#define KDEBUG(args...) printf(args)
-#define LDEBUG(args...) printf(args)
-#endif
-//1
-#if (MTD_SPI_DEBUG == 1)
-#define NDEBUG(args...) printf(args)
-#define KDEBUG(args...) printf(args)
-#define LDEBUG(args...)
-#endif
-//2
-#if (MTD_SPI_DEBUG == 2)
-#define NDEBUG(args...) printf(args)
-#define KDEBUG(args...)
-#define LDEBUG(args...)
-#endif
-//3
-#if (MTD_SPI_DEBUG == 3)
-#define NDEBUG(args...)
-#define KDEBUG(args...)
-#define LDEBUG(args...)
-#endif
-
-#else
-// ****** spi flash driver in kernel
-#include <linux/errno.h>
-#include <linux/kernel.h>
-#include <linux/string.h>
-#include <linux/vmalloc.h>
-#define malloc	vmalloc
-#define free	vfree
-//0
-#if (MTD_SPI_DEBUG == 0)
-#define NDEBUG(args...) printk(args)
-#define KDEBUG(args...) printk(args)
-#define LDEBUG(args...) printk(args)
-#endif
-//1
-#if (MTD_SPI_DEBUG == 1)
-#define NDEBUG(args...) printk(args)
-#define KDEBUG(args...) printk(args)
-#define LDEBUG(args...)
-#endif
-//2
-#if (MTD_SPI_DEBUG == 2)
-#define NDEBUG(args...) printk(args)
-#define KDEBUG(args...)
-#define LDEBUG(args...)
-#endif
-//3
-#if (MTD_SPI_DEBUG == 3)
-#define NDEBUG(args...)
-#define KDEBUG(args...)
-#define LDEBUG(args...)
-#endif
-
-#endif
-
-/* SPI Flash Configuration Register(SFCR) (0xb800-1200) */
-#define SFCR					0xb8001200			/*SPI Flash Configuration Register*/		
-#define SFCR_SPI_CLK_DIV(val)	((val) << 29)
-#define SFCR_RBO(val)			((val) << 28)
-#define SFCR_WBO(val)			((val) << 27)
-#define SFCR_SPI_TCS(val)		((val) << 23)			/*4 bit, 1111 */
-
-/* SPI Flash Configuration Register(SFCR2) (0xb800-1204) */
-#define SFCR2						0xb8001204
-#define SFCR2_SFCMD(val)			((val) << 24)			/*8 bit, 1111_1111 */
-#define SFCR2_SFSIZE(val)			((val) << 21)			/*3 bit, 111 */
-#define SFCR2_RD_OPT(val)			((val) << 20)
-#define SFCR2_CMD_IO(val)			((val) << 18)			/*2 bit, 11 */
-#define SFCR2_ADDR_IO(val)			((val) << 16)			/*2 bit, 11 */
-#define SFCR2_DUMMY_CYCLE(val)		((val) << 13)			/*3 bit, 111 */
-#define SFCR2_DATA_IO(val)			((val) << 11)			/*2 bit, 11 */
-#define SFCR2_HOLD_TILL_SFDR2(val)	((val) << 10)
-
-/* SPI Flash Control and Status Register(SFCSR)(0xb800-1208) */
-#define SFCSR					0xb8001208
-#define SFCSR_SPI_CSB0(val)		((val) << 31)
-#define SFCSR_SPI_CSB1(val)		((val) << 30)		
-#define SFCSR_LEN(val)			((val) << 28)			/*2 bits*/
-#define SFCSR_SPI_RDY(val)		((val) << 27)
-#define SFCSR_IO_WIDTH(val)		((val) << 25)			/*2 bits*/
-#define SFCSR_CHIP_SEL(val)		((val) << 24)
-#define SFCSR_CMD_BYTE(val)		((val) << 16)			/*8 bit, 1111_1111 */
-
-#define SFCSR_SPI_CSB(val)		((val) << 30)
-
-/* SPI Flash Data Register(SFDR)(0xb800-120c) */
-#define SFDR					0xb800120c
-
-/* SPI Flash Data Register(SFDR2)(0xb8001210) */
-#define SFDR2					0xb8001210
-
-#define SPI_BLOCK_SIZE			0x10000				/* 64KB */
-#define SPI_SECTOR_SIZE			0x1000				/* 4KB */
-#define SPI_PAGE_SIZE			0x100				/* 256B */
-
-#define SPICMD_WREN			(0x06 << 24)	/* 06 xx xx xx xx sets the (WEL) write enable latch bit */
-#define SPICMD_WRDI			(0x04 << 24)	/* 04 xx xx xx xx resets the (WEL) write enable latch bit*/
-#define SPICMD_RDID			(0x9f << 24)	/* 9f xx xx xx xx outputs JEDEC ID: 1 byte manufacturer ID & 2 byte device ID */
-#define SPICMD_RDSR			(0x05 << 24)	/* 05 xx xx xx xx to read out the values of the status register */
-#define SPICMD_WRSR			(0x01 << 24)	/* 01 xx xx xx xx to write new values to the status register */
-#define SPICMD_READ			(0x03 << 24)	/* 03 a1 a2 a3 xx n bytes read out until CS# goes high */
-#define SPICMD_FASTREAD		(0x0b << 24)	/* 0b a1 a2 a3 dd n bytes read out until CS# goes high */
-#define SPICMD_2READ		(0xbb << 24)	/* bb 12 3d xx xx n bytes read out by 2 I/O until CS# goes high */
-#define SPICMD_4READ		(0xeb << 24)	/* eb 3a 3d xx xx n bytes read out by 4 x I/O until CS# goes high */
-#define SPICMD_SE			(0x20 << 24)	/* 20 a1 a2 a3 xx to erase the selected sector */
-#define SPICMD_BE			(0xd8 << 24)	/* d8 a1 a2 a3 xx to erase the selected block */
-#define SPICMD_CE			(0x60 << 24)	/* 60 xx xx xx xx to erase whole chip (cmd or 0xc7) */
-#define SPICMD_PP			(0x02 << 24)	/* 02 a1 a2 a3 xx to program the selected page */
-#define SPICMD_4PP			(0x38 << 24)	/* 38 3a 3d xx xx quad input to program the selected page */
-#define SPICMD_CP			(0xad << 24)	/* ad a1 a2 a3 xx continously program whole chip, the address is automaticlly increase */
-#define SPICMD_DP			(0xb9 << 24)	/* b9 xx xx xx xx enters deep power down mode */
-#define SPICMD_RDP			(0xab << 24)	/* ab xx xx xx xx release from deep power down mode */
-#define SPICMD_RES			(0xab << 24)	/* ab ?? ?? ?? xx to read out 1 byte device ID */
-#define SPICMD_REMS_90		(0x90 << 24)	/* 90 ?? ?? ?? xx output the manufacter ID & device ID */
-#define SPICMD_REMS_EF		(0xef << 24)	/* ef ?? ?? ?? xx output the manufacter ID & device ID */
-#define SPICMD_REMS_DF		(0xdf << 24)	/* df ?? ?? ?? ?? output the manufacture ID & device ID */
-#define SPICMD_ENSO			(0xb1 << 24)	/* b1 xx xx xx xx to enter the 512 bit secured OTP mode */
-#define SPICMD_EXSO			(0xc1 << 24)	/* c1 xx xx xx xx to exit the 512 bit secured OTP mode */
-#define SPICMD_RDSCUR		(0x2b << 24)	/* 2b xx xx xx xx to read value of secured register */
-#define SPICMD_WRSCUR		(0x2f << 24)	/* 2f xx xx xx xx to set the lock down bit as "1" (once lock down, can not be updated) */
-#define SPICMD_ESRY			(0x70 << 24)	/* 70 xx xx xx xx to enable SO to output RY/BY# during CP mode */
-#define SPICMD_DSRY			(0x80 << 24)	/* 80 xx xx xx xx to disable SO to output RY/BY# during CP mode */
-
-#define SPI_STATUS_REG_SRWD		0x07	/* status register write protect */
-#define SPI_STATUS_CP			0x06	/* continously program mode */
-#define SPI_STATUS_QE			0x06	/* quad enable */
-#define SPI_STATUS_BP3			0x05	/* level of protected block */
-#define SPI_STATUS_BP2			0x04	/* level of protected block */
-#define SPI_STATUS_BP1			0x03	/* level of protected block */
-#define SPI_STATUS_BP0			0x02	/* level of protected block */
-#define SPI_STATUS_WEL			0x01	/* write enable latch */
-#define SPI_STATUS_WIP			0x00	/* write in process bit */
-
-/****** EON ******/
-
-/****** SPANSION ******/
-#define SPICMD_SPAN_QOR			(0x6b << 24)	/* 3 0 1 (1 to ) Quad Ou// write sector use malloc buffer */
-#define SPICMD_SPAN_QPP			(0x32 << 24)	/* Quad Page Programming */
-#define SPAN_CONF_QUAD			0x01
-
-/****** WINBOND ******/
-#define WB_STATUS_QE		0x09	/* QUAD ENABLE (non-volatile) */
-#define SPICMD_WB_QPP		(0x32 << 24)		/* Quad Page Program */
-
-/****** SST ******/
-
-/****** GigaDevice ******/
-#define GD_STATUS_QE		0x09	/* 9 When the QE bit is set to 0 (Default) the WP# pin and HOLD# pin are enable */
-#define SPICMD_GD_HPM		(0xA3 << 24)	/*  High Performance Mode A3H dummy   dummy      dummy */
-#define SPICMD_GD_QPP		0x32
-
-/****** ATMEL ******/
-//                                                                                                Clock         Address    Dummy  Data
-//Command                                                                     Opcode           Frequency         Bytes      Bytes Bytes
-#define SPICMD_AT_READ2		(0x3b << 24)	//Dual-Output Read Array				3Bh   0011 1011    Up to 85 MHz           3         1    1+
-#define SPICMD_AT_PP2		(0xa2 << 24)	//Dual-Input Byte/Page Program 			A2h   1010 0010    Up to 100 MHz          3         0    1+
-
-/* Spanson Flash */
-#define S25FL004A		0x00010212
-#define S25FL016A		0x00010214
-#define S25FL032A		0x00010215
-#define S25FL064A		0x00010216		/*supposed support*/
-#define S25FL128P		0x00012018		/*only S25FL128P0XMFI001, Uniform 64KB secotr*/
-										/*not support S25FL128P0XMFI011, Uniform 256KB secotr*/
-										/*because #define SPI_BLOCK_SIZE 65536 */
-#define S25FL032P		0x00010215
-
-/* MICRONIX Flash */
-#define MX25L4005		0x00C22013
-#define MX25L1605D		0x00C22015
-#define MX25L1605E		0x00C22015
-#define MX25L3205D		0x00C22016		/*supposed support*/
-#define MX25L3205E		0x00C22016		/*supposed support*/
-#define MX25L6405D		0x00C22017
-#define MX25L6405E		0x00C22017
-#define MX25L6445E		0x00C22017
-#define MX25L12805D		0x00C22018
-#define MX25L12845E		0x00C22018
-
-#define MX25L1635D		0x00C22415
-#define MX25L1635E		0x00C22515
-#define MX25L1636E		0x00C22515
-#define MX25L3235D		0x00C25E16
-
-/* SST Flash */
-#define SST25VF032B		0x00BF254A		//4MB
-#define SST26VF016		0x00BF2601
-#define SST26VF032		0x00BF2602
-
-/* WinBond Flash */
-#define W25Q80			0x00EF4014
-#define W25Q16			0x00EF4015
-#define W25Q32			0x00EF4016
-
-/* Eon Flash */
-#define EN25F32			0x001c3116
-#define EN25F16			0x001c3115
-#define EN25Q32			0x001c3016
-#define EN25Q16			0x001c3015
-
-/* GigaDevice Flash */
-#define GD25Q16			0x00c84015
-#define GD25Q32			0x00c84016
-#define GD25Q64			0x00c84017
-
-/* Atmel Flash */
-#define AT25DF161		0x001f4602
-
-#define SIZE2N_128K	0x11
-#define SIZE2N_256K	0x12
-#define SIZE2N_512K	0x13
-#define SIZE2N_01MB	0x14
-#define SIZE2N_02MB	0x15
-#define SIZE2N_04MB	0x16
-#define SIZE2N_08MB	0x17
-#define SIZE2N_16MB	0x18
-#define SIZE2N_32MB	0x19
-#define SIZE2N_64MB	0x20
-#define SIZE2N_128M	0x21
-
-#define SIZE_256B	0x100
-#define SIZE_004K	0x1000
-#define SIZE_064K	0x10000
-
-#define SPI_REG_READ(reg)		*((volatile unsigned int *)(reg))
-#define SPI_REG_LOAD(reg,val)	while((*((volatile unsigned int *)SFCSR) & (SFCSR_SPI_RDY(1))) == 0); *((volatile unsigned int *)(reg)) = (val)
-
-#define IOWIDTH_SINGLE			0x00
-#define IOWIDTH_DUAL			0x01
-#define IOWIDTH_QUAD			0x02
-#define DATA_LENTH1				0x00
-#define DATA_LENTH2				0x01
-#define DATA_LENTH4				0x02
-#define ISFAST_NO				0x00
-#define ISFAST_YES				0x01
-#define ISFAST_ALL				0x02
-#define DUMMYCOUNT_0			0x00
-#define DUMMYCOUNT_1			0x01
-#define DUMMYCOUNT_2			0x02
-#define DUMMYCOUNT_3			0x03
-#define DUMMYCOUNT_4			0x04
-#define DUMMYCOUNT_5			0x05
-#define DUMMYCOUNT_6			0x06
-#define DUMMYCOUNT_7			0x07
-#define DUMMYCOUNT_8			0x08
-#define DUMMYCOUNT_9			0x09
-
-struct spi_flash_type spi_flash_info[2];
-//unsigned char ucDispCount = 0;
-unsigned char ucSFCR2 = 154;
-#if (MTD_SPI_TEST_CHIP == 1)
-unsigned int test_spi_flash(unsigned char ucChip);
-#endif
-
-struct spi_flash_known spi_flash_registed[] = {
-/****************************************** Micronix Flash ******************************************/
-//#define MX25L1605D		0x00C22015
-{0x00C22015, 0x00, SIZE2N_02MB, SIZE_064K, SIZE_004K, SIZE_256B, "MX25L1605D/E"
-#if (SPI_DRIVER_MODE == 1)
-, 86, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
-#else
-, 86, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
-#endif
-},
-//#define MX25L3205D		0x00C22016
-{0x00C22016, 0x00, SIZE2N_04MB, SIZE_064K, SIZE_004K, SIZE_256B, "MX25L3205D/E"
-#if (SPI_DRIVER_MODE == 1)
-, 86, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
-#else
-, 86, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
-#endif
-},
-//#define MX25L6405D		0x00C22017
-//#define MX25L6405E		0x00C22017
-//#define MX25L6445E		0x00C22017
-{0x00C22017, 0x00, SIZE2N_08MB, SIZE_064K, SIZE_004K, SIZE_256B, "MX6405D/05E/45E"
-#if (SPI_DRIVER_MODE == 1)
-, 86, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
-#else
-, 86, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
-#endif
-},
-//#defien MX25L12805D		0x00C22018
-//#define MX25L12845E		0x00C22018
-{0x00C22018, 0x00, SIZE2N_16MB, SIZE_064K, SIZE_004K, SIZE_256B, "MX25L12805D/45E"
-#if (SPI_DRIVER_MODE == 1)
-, 86, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
-#else
-, 86, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
-#endif
-},
-//#define MX25L1635D		0x00C22415
-{0x00C22415, 0x00, SIZE2N_02MB, SIZE_064K, SIZE_004K, SIZE_256B, "MX25L1635D"
-#if (SPI_DRIVER_MODE == 1)
-, 75, ComSrlCmd_SE,  SpiRead_1443EB, mxic_spi_setQEBit,  PageWrite_144038
-#else
-, 75, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
-#endif
-},
-//#define MX25L1635E		0x00C22515 (clock 108 down to 54)
-{0x00C22515, 0x00, SIZE2N_02MB, SIZE_064K, SIZE_004K, SIZE_256B, "MX25L1635E/36E"
-#if (SPI_DRIVER_MODE == 1)
-, 108, ComSrlCmd_SE,  SpiRead_1443EB, mxic_spi_setQEBit,  PageWrite_144038
-#else
-, 108, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
-#endif
-},
-//#define MX25L3235D		0x00C25E16
-{0x00C25E16, 0x00, SIZE2N_04MB, SIZE_064K, SIZE_004K, SIZE_256B, "MX25L3235D"
-#if (SPI_DRIVER_MODE == 1)
-, 75, ComSrlCmd_SE,  SpiRead_1443EB, mxic_spi_setQEBit,  PageWrite_144038
-#else
-, 104, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
-#endif
-},
-/****************************************** Spanson Flash ******************************************/
-//#define S25FL016A		0x00010214
-{0x00010214, 0x00, SIZE2N_02MB, SIZE_064K, SIZE_064K, SIZE_256B, "S25FL016A"
-#if (SPI_DRIVER_MODE == 1)
-, 50, ComSrlCmd_BE, SpiRead_11110B, ComSrlCmd_NoneQeBit, PageWrite_111002
-#else
-, 50, ComSrlCmd_BE, SpiRead_11110B, ComSrlCmd_NoneQeBit, PageWrite_111002
-#endif
-},
-//#define S25FL032A		0x00010215
-{0x00010215, 0x00, SIZE2N_04MB, SIZE_064K, SIZE_064K, SIZE_256B, "S25FL032A"
-#if (SPI_DRIVER_MODE == 1)
-, 50, ComSrlCmd_BE, SpiRead_11110B, ComSrlCmd_NoneQeBit, PageWrite_111002
-#else
-, 50, ComSrlCmd_BE, SpiRead_11110B, ComSrlCmd_NoneQeBit, PageWrite_111002
-#endif
-},
-//#define S25FL064A		0x00010216
-{0x00010216, 0x00, SIZE2N_08MB, SIZE_064K, SIZE_064K, SIZE_256B, "S25FL064P"
-#if (SPI_DRIVER_MODE == 1)
-, 80, ComSrlCmd_BE, SpiRead_1443EB, span_spi_setQEBit, PageWrite_114032
-#else
-, 104, ComSrlCmd_BE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
-#endif
-},
-/****************************************** Eon Flash ******************************************/
-//#define EN25F16			0x001c3115
-{0x001c3115, 0x00, SIZE2N_02MB, SIZE_064K, SIZE_004K, SIZE_256B, "EN25F16"
-#if (SPI_DRIVER_MODE == 1)
-, 100, ComSrlCmd_SE, SpiRead_11110B, ComSrlCmd_NoneQeBit, PageWrite_111002
-#else
-, 100, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
-#endif
-},
-//#define EN25F32			0x001c3116
-{0x001c3116, 0x00, SIZE2N_04MB, SIZE_064K, SIZE_004K, SIZE_256B, "EN25F32-100"
-#if (SPI_DRIVER_MODE == 1)
-, 100, ComSrlCmd_SE, SpiRead_11110B, ComSrlCmd_NoneQeBit, PageWrite_111002
-#else
-, 100, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
-#endif
-},
-//#define EN25Q16			0x001c3015
-{0x001c3015, 0x00, SIZE2N_02MB, SIZE_064K, SIZE_004K, SIZE_256B, "EN25Q16A"
-#if (SPI_DRIVER_MODE == 1)
-, 80, ComSrlCmd_SE, SpiRead_1443EB, ComSrlCmd_NoneQeBit, PageWrite_111002
-#else
-, 80, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
-#endif
-},
-//#define EN25Q32			0x001c3016
-{0x001c3016, 0x00, SIZE2N_04MB, SIZE_064K, SIZE_004K, SIZE_256B, "EN25Q32A"
-#if (SPI_DRIVER_MODE == 1)
-, 80, ComSrlCmd_SE, SpiRead_1443EB, ComSrlCmd_NoneQeBit, PageWrite_111002
-#else
-, 80, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
-#endif
-},
-/****************************************** SST Flash ******************************************/
-//#define SST25VF032B		0x00BF254A (clock 80 down to 40)
-{0x00BF254A, 0x00, SIZE2N_04MB, SIZE_064K, SIZE_004K, SIZE_256B, "SST25VF032B"
-#if (SPI_DRIVER_MODE == 1)
-, 40, ComSrlCmd_SE, SpiRead_11110B, ComSrlCmd_NoneQeBit, sst_PageWrite_s1
-#else
-, 40, ComSrlCmd_SE, SpiRead_11110B, ComSrlCmd_NoneQeBit, sst_PageWrite_s1
-#endif
-},
-/****************************************** GigaDevice Flash ******************************************/
-//#define GD25Q16			0x00c84015
-{0x00c84015, 0x00, SIZE2N_02MB, SIZE_064K, SIZE_004K, SIZE_256B, "GD25Q16"
-#if (SPI_DRIVER_MODE == 1)
-, 90, ComSrlCmd_SE, SpiRead_1443EB, gd_spi_setQEBit, PageWrite_111002
-#else
-, 120, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
-#endif
-},
-//#define GD25Q32			0x00c84016
-{0x00c84016, 0x00, SIZE2N_04MB, SIZE_064K, SIZE_004K, SIZE_256B, "GD25Q32"
-#if (SPI_DRIVER_MODE == 1)
-, 80, ComSrlCmd_SE, SpiRead_1443EB, gd_spi_setQEBit, PageWrite_114032
-#else
-, 100, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
-#endif
-},
-//#define GD25Q64			0x00c84017
-{0x00c84017, 0x00, SIZE2N_08MB, SIZE_064K, SIZE_004K, SIZE_256B, "GD25Q64"
-#if (SPI_DRIVER_MODE == 1)
-, 80, ComSrlCmd_SE, SpiRead_1443EB, gd_spi_setQEBit, PageWrite_114032
-#else
-, 100, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
-#endif
-},
-/****************************************** WinBond Flash ******************************************/
-//#define W25Q16			0x00EF4015
-{0x00EF4015, 0x00, SIZE2N_02MB, SIZE_064K, SIZE_004K, SIZE_256B, "W25Q16"
-#if (SPI_DRIVER_MODE == 1)
-, 104, ComSrlCmd_SE, SpiRead_1443EB, wb_spi_setQEBit, PageWrite_114032
-#else
-, 104, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
-#endif
-},
-//#define W25Q32			0x00EF4016
-{0x00EF4016, 0x00, SIZE2N_04MB, SIZE_064K, SIZE_004K, SIZE_256B, "W25Q32"
-#if (SPI_DRIVER_MODE == 1)
-, 104, ComSrlCmd_SE, SpiRead_1443EB, wb_spi_setQEBit, PageWrite_114032
-#else
-, 104, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
-#endif
-},
-//#define W25X16			0x00EF3015
-{0x00EF3015, 0x00, SIZE2N_02MB, SIZE_064K, SIZE_004K, SIZE_256B, "W25X16"
-#if (SPI_DRIVER_MODE == 1)
-, 104, ComSrlCmd_SE, SpiRead_11213B, ComSrlCmd_NoneQeBit,  PageWrite_111002
-#else
-, 104, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
-#endif
-},
-//#define W25X32			0x00EF3016
-{0x00EF3016, 0x00, SIZE2N_04MB, SIZE_064K, SIZE_004K, SIZE_256B, "W25X32"
-#if (SPI_DRIVER_MODE == 1)
-, 104, ComSrlCmd_SE, SpiRead_11213B, ComSrlCmd_NoneQeBit,  PageWrite_111002
-#else
-, 104, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
-#endif
-},
-//#define W25X64			0x00EF3017
-{0x00EF3016, 0x00, SIZE2N_08MB, SIZE_064K, SIZE_004K, SIZE_256B, "W25X64"
-#if (SPI_DRIVER_MODE == 1)
-, 104, ComSrlCmd_SE, SpiRead_11213B, ComSrlCmd_NoneQeBit,  PageWrite_111002
-#else
-, 104, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
-#endif
-},
-/****************************************** ATMEL Flash ******************************************/
-//#define AT25DF161		0x001f4602
-{0x001f4602, 0x00, SIZE2N_02MB, SIZE_064K, SIZE_004K, SIZE_256B, "AT25DF161"
-#if (SPI_DRIVER_MODE == 1)
-, 85, ComSrlCmd_SE, SpiRead_11213B, ComSrlCmd_NoneQeBit, PageWrite_1120A2
-#else
-, 85, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
-#endif
-},
-/****************************************** Qingistek ******************************************/
-//#define PM25LQ032		0x007f9d46
-{0x007f9d46, 0x00, SIZE2N_04MB, SIZE_064K, SIZE_004K, SIZE_256B, "PM25LQ032"
-#if (SPI_DRIVER_MODE == 1)
-, 85, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
-#else
-, 85, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
-#endif
-},
-/****************************************** ESMT ******************************************/
-//#define PM25LQ032		0x007f9d46
-{0x008c2016, 0x00, SIZE2N_04MB, SIZE_064K, SIZE_004K, SIZE_256B, "F25L32PA-100"
-#if (SPI_DRIVER_MODE == 1)
-, 100, ComSrlCmd_SE,  SpiRead_1221BB, ComSrlCmd_NoneQeBit,  PageWrite_111002
-#else
-, 50, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
-#endif
-}
-};
-
-// spi flash probe
-void spi_regist(unsigned char ucChip)
-{
-	unsigned int ui, i, uiCount, uiRems;
-	unsigned char pucBuffer[4];
-
-	ui = ComSrlCmd_RDID(ucChip, 4);
-	ui = ComSrlCmd_RDID(ucChip, 4);
-	ui = ui >> 8;
-
-	uiCount = sizeof(spi_flash_registed) / sizeof(struct spi_flash_known);
-
-	for (i = 0; i < uiCount; i++)
-	{
-		if(spi_flash_registed[i].uiChipId == ui)
-		{
-			break;
-		}
-	}
-	if(i == uiCount)
-	{
-		// default setting
-		i = ui & 0xff;
-		if((i < SIZE2N_128K) || (i > SIZE2N_128M))
-		{
-			i = SIZE2N_04MB;
-		}
-		setFSCR(ucChip, 40, 1, 1, 15);
-		set_flash_info(ucChip, ui, i, SIZE_064K, SIZE_004K, SIZE_256B, "UNKNOWN", ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002, 40);
-	}
-	else
-	{
-		// have registed
-		setFSCR(ucChip, spi_flash_registed[i].chipClock, 1, 1, 15);
-		set_flash_info(ucChip, ui, spi_flash_registed[i].uiCapacityId, spi_flash_registed[i].uiBlockSize, spi_flash_registed[i].uiSectorSize, spi_flash_registed[i].uiPageSize, spi_flash_registed[i].pcChipName, spi_flash_registed[i].pfErase, spi_flash_registed[i].pfRead, spi_flash_registed[i].pfQeBit, spi_flash_registed[i].pfPageWrite, spi_flash_registed[i].chipClock);
-	}
-	spi_flash_info[ucChip].pfQeBit(ucChip);
-	prnFlashInfo(ucChip, spi_flash_info[ucChip]);
-	ui = spi_flash_info[ucChip].pfRead(ucChip, 0x00, 4, pucBuffer);
-#if (MTD_SPI_TEST_CHIP == 1)
-	ui = test_spi_flash(ucChip);
-#endif
-	LDEBUG("spi_regist: ucChip=%x; i=%x; uiCount=%x\n", ucChip, i, uiCount);
-}
-// set spi_flash_info struction content
-void set_flash_info(unsigned char ucChip, unsigned int chip_id, unsigned int device_cap, unsigned int block_size, unsigned int sector_size, unsigned int page_size, char* chip_name, FUNC_ERASE pfErase, FUNC_READ pfRead, FUNC_SETQEBIT pfQeBit, FUNC_PAGEWRITE pfPageWrite, unsigned int chipClock)
-{
-	unsigned int ui = 1 << device_cap;
-	spi_flash_info[ucChip].chip_id = chip_id;
-	spi_flash_info[ucChip].mfr_id = (chip_id >> 16) & 0xff;
-	spi_flash_info[ucChip].dev_id = (chip_id >> 8) & 0xff;
-	spi_flash_info[ucChip].capacity_id = (chip_id) & 0xff;
-	spi_flash_info[ucChip].size_shift = calShift(spi_flash_info[ucChip].capacity_id, device_cap);
-	spi_flash_info[ucChip].device_size = device_cap;			// 2 ^ N (bytes)
-	spi_flash_info[ucChip].chip_size =  ui;
-	spi_flash_info[ucChip].block_size = block_size;
-	spi_flash_info[ucChip].block_cnt = ui / block_size;
-	spi_flash_info[ucChip].sector_size = sector_size;
-	spi_flash_info[ucChip].sector_cnt = ui / sector_size;
-	spi_flash_info[ucChip].page_size = page_size;
-	spi_flash_info[ucChip].page_cnt = sector_size / page_size;
-	spi_flash_info[ucChip].chip_name = chip_name;
-	spi_flash_info[ucChip].pfErase = pfErase;
-	spi_flash_info[ucChip].pfWrite = ComSrlCmd_ComWriteData;
-	spi_flash_info[ucChip].pfRead = pfRead;
-	spi_flash_info[ucChip].pfQeBit = pfQeBit;
-	spi_flash_info[ucChip].pfPageWrite = pfPageWrite;
-	spi_flash_info[ucChip].chipClock = chipClock;
-	//SPI_REG_LOAD(SFCR2, 0x0bb08000);
-	LDEBUG("set_flash_info: ucChip=%x; chip_id=%x; device_cap=%x; block_size=%x; sector_size=%x; page_size=%x; chip_name=%s\n", ucChip, chip_id, device_cap, block_size, sector_size, page_size, chip_name);
-}
-
-/****************************** Common function ******************************/
-// get Dram Frequence
-unsigned int CheckDramFreq(void)                       //JSW:For 8196C
-{
-	unsigned short usFreqBit;
-#ifdef CONFIG_RTL8198
-	unsigned short usFreqVal[] = {65, 181, 150, 125, 156, 168, 237, 193};
-#else
-	unsigned short usFreqVal[] = {65, 78, 125, 150, 156, 168, 193, 193};
-#endif
-	usFreqBit = (0x00001C00 & (*(unsigned int*)0xb8000008)) >> 10 ;
-	LDEBUG("CheckDramFreq:usFreqVal=%dMHZ; usFreqBit=%x; B8000008=%x;\n", usFreqVal[usFreqBit], usFreqBit, (*(unsigned int*)0xb8000008));
-	NDEBUG("SDRAM CLOCK:%dMHZ\n", usFreqVal[usFreqBit]);
-	return usFreqVal[usFreqBit];
-}
-// Set FSCR register, disable this function in kernel
-void setFSCR(unsigned char ucChip, unsigned int uiClkMhz, unsigned int uiRBO, unsigned int uiWBO, unsigned int uiTCS)
-{
-#ifndef SPI_KERNEL
-	unsigned int ui, uiClk;
-	uiClk = CheckDramFreq();
-#ifdef CONFIG_AUTO_PROBE_LIMITED_SPI_CLK_UNDER_40MHZ
-	uiClkMhz = 40;
-#endif
-	ui = uiClk / uiClkMhz;
-	if((uiClk % uiClkMhz) > 0)
-	{
-		ui = ui + 1;
-	}
-	if((ui % 2) > 0)
-	{
-		ui = ui + 1;
-	}
-	spi_flash_info[ucChip].chip_clk = uiClk / ui;
-	SPI_REG_LOAD(SFCR, SFCR_SPI_CLK_DIV((ui-2)/2) | SFCR_RBO(uiRBO) | SFCR_WBO(uiWBO) | SFCR_SPI_TCS(uiTCS));
-	LDEBUG("setFSCR:uiClkMhz=%d, uiRBO=%d, uiWBO=%d, uiTCS=%d, resMhz=%d, vale=%8x\n", uiClkMhz, uiRBO, uiWBO, uiTCS, spi_flash_info[ucChip].chip_clk, SPI_REG_READ(SFCR));
-#endif
-}
-// Calculate write address group
-void calAddr(unsigned int uiStart, unsigned int uiLenth, unsigned int uiSectorSize, unsigned int* uiStartAddr, unsigned int*  uiStartLen, unsigned int* uiSectorAddr, unsigned int* uiSectorCount, unsigned int* uiEndAddr, unsigned int* uiEndLen)
-{
-	unsigned int ui;
-	// only one sector
-	if ((uiStart + uiLenth) < ((uiStart / uiSectorSize + 1) * uiSectorSize))
-	{	// start	
-		*uiStartAddr = uiStart;
-		*uiStartLen = uiLenth;
-		//middle
-		*uiSectorAddr = 0x00;
-		*uiSectorCount = 0x00;
-		// end
-		*uiEndAddr = 0x00;
-		*uiEndLen = 0x00;
-	}
-	//more then one sector
-	else
-	{
-		// start
-		*uiStartAddr = uiStart;
-		*uiStartLen = uiSectorSize - (uiStart % uiSectorSize);
-		if(*uiStartLen == uiSectorSize)
-		{
-			*uiStartLen = 0x00;
-		}
-		// middle
-		ui = uiLenth - *uiStartLen;
-		*uiSectorAddr = *uiStartAddr + *uiStartLen;
-		*uiSectorCount = ui / uiSectorSize;
-		//end
-		*uiEndAddr = *uiSectorAddr + (*uiSectorCount * uiSectorSize);
-		*uiEndLen = ui % uiSectorSize;
-	}
-	LDEBUG("calAddr:uiStart=%x; uiSectorSize=%x; uiLenth=%x;-> uiStartAddr=%x; uiStartLen=%x; uiSectorAddr=%x; uiSectorCount=%x; uiEndAddr=%x; uiEndLen=%x;\n",uiStart, uiSectorSize, uiLenth, *uiStartAddr, *uiStartLen, *uiSectorAddr, *uiSectorCount, *uiEndAddr, *uiEndLen);	
-}
-// Calculate chip capacity shift bit 
-unsigned char calShift(unsigned char ucCapacityId, unsigned char ucChipSize)
-{
-	unsigned int ui;
-	if(ucChipSize > ucCapacityId)
-	{
-		ui = ucChipSize - ucCapacityId;
-	}
-	else
-	{
-		ui = ucChipSize + 0x100 -ucCapacityId;
-	}
-	LDEBUG("calShift: ucCapacityId=%x; ucChipSize=%x; ucReturnVal=%x\n", ucCapacityId, ucChipSize, ui);
-	return (unsigned char)ui;	
-}
-// Print spi_flash_type
-void prnFlashInfo(unsigned char ucChip, struct spi_flash_type sftInfo)
-{
-#if (SPI_DRIVER_MODE == 1)
-	NDEBUG(" ========================= Registed SPI Flash Model ========================= \n");
-	NDEBUG("|No chipID  Sft chipSize blkSize secSize pageSize sdCk opCk      chipName    |\n");
-	NDEBUG("|%2d %6xh %2xh %7xh %6xh %6xh %7xh %4d %4d %17s|\n", ucChip, sftInfo.chip_id, sftInfo.size_shift, sftInfo.chip_size, sftInfo.block_size, sftInfo.sector_size, sftInfo.page_size, sftInfo.chipClock, sftInfo.chip_clk, sftInfo.chip_name);
-	////////1111 2222 3333 4444 5555 6666 7777 8888 9999 aaaa
-	NDEBUG(" ============================================================================ \n");
-#else
-	NDEBUG(" ------------------------- Force into Single IO Mode ------------------------ \n");
-	NDEBUG("|No chipID  Sft chipSize blkSize secSize pageSize sdCk opCk      chipName    |\n");
-	NDEBUG("|%2d %6xh %2xh %7xh %6xh %6xh %7xh %4d %4d %17s|\n", ucChip, sftInfo.chip_id, sftInfo.size_shift, sftInfo.chip_size, sftInfo.block_size, sftInfo.sector_size, sftInfo.page_size, sftInfo.chipClock, sftInfo.chip_clk, sftInfo.chip_name);
-	////////1111 2222 3333 4444 5555 6666 7777 8888 9999 aaaa
-	NDEBUG(" ---------------------------------------------------------------------------- \n");
-#endif
-}
-
-// Check WIP bit
-unsigned int spiFlashReady(unsigned char ucChip)
-{
-	unsigned int uiCount, ui;	
-	uiCount = 0;
-	while (1)
-	{
-		uiCount++;
-		ui = SeqCmd_Read(ucChip, IOWIDTH_SINGLE, SPICMD_RDSR, 1);
-		if ((ui & (1 << SPI_STATUS_WIP)) == 0)
-		{
-			break;
-		}
-	}
-	KDEBUG("spiFlashReady: uiCount=%x\n", uiCount);	
-	return uiCount;
-}
-//toggle CS
-void rstSPIFlash(unsigned char ucChip)
-{
-	SFCSR_CS_L(ucChip, 0, IOWIDTH_SINGLE);
-	SFCSR_CS_H(ucChip, 0, IOWIDTH_SINGLE);
-	SFCSR_CS_L(ucChip, 0, IOWIDTH_SINGLE);
-	SFCSR_CS_H(ucChip, 0, IOWIDTH_SINGLE);
-	LDEBUG("rstFPIFlash: ucChip=%x;\n", ucChip);	
-}
-
-/****************************** Layer 1 ******************************/
-// set cs high
-void SFCSR_CS_L(unsigned char ucChip, unsigned char ucLen, unsigned char ucIOWidth)
-{
-	LDEBUG("SFCSR_CS_L: ucChip=%x; uiLen=%x; ucIOWidth=%x;\n", ucChip, ucLen, ucIOWidth);
-	while((*((volatile unsigned int *)SFCSR) & (SFCSR_SPI_RDY(1))) == 0);
-	//*((volatile unsigned int *)(SFCSR)) = SFCSR_SPI_CSB(1 + (ucChip)) | SFCSR_LEN(uiLen) | SFCSR_SPI_RDY(1) |  SFCSR_IO_WIDTH(ucIOWidth) | SFCSR_CHIP_SEL(0) | SFCSR_CMD_BYTE(0);
-	*((volatile unsigned int *)(SFCSR)) = SFCSR_SPI_CSB(1 + (ucChip)) | SFCSR_LEN(ucLen) | SFCSR_SPI_RDY(1) |  SFCSR_IO_WIDTH(ucIOWidth);	
-}
-// set cs low
-void SFCSR_CS_H(unsigned char ucChip, unsigned char ucLen, unsigned char ucIOWidth)
-{
-	LDEBUG("SFCSR_CS_H: ucChip=%x; uiLen=%x; ucIOWidth=%x;\n", ucChip, ucLen, ucIOWidth);
-	while((*((volatile unsigned int *)SFCSR) & (SFCSR_SPI_RDY(1))) == 0);
-	//*((volatile unsigned int *)(SFCSR)) = SFCSR_SPI_CSB(3) | SFCSR_LEN(uiLen) | SFCSR_SPI_RDY(1) |  SFCSR_IO_WIDTH(ucIOWidth) | SFCSR_CHIP_SEL(0) | SFCSR_CMD_BYTE(0);
-	*((volatile unsigned int *)(SFCSR)) = SFCSR_SPI_CSB(3) | SFCSR_LEN(ucLen) | SFCSR_SPI_RDY(1) |  SFCSR_IO_WIDTH(ucIOWidth);	
-}
-// Read Identification (RDID) Sequence (Command 9F)
-unsigned int ComSrlCmd_RDID(unsigned char ucChip, unsigned int uiLen)
-{
-	unsigned int ui;
-	SPI_REG_LOAD(SFCR, (SFCR_SPI_CLK_DIV(7) | SFCR_RBO(1) | SFCR_WBO(1) | SFCR_SPI_TCS(15)));		//SFCR default setting
-	rstSPIFlash(ucChip);
-	SFCSR_CS_L(ucChip, 0, IOWIDTH_SINGLE);
-	SPI_REG_LOAD(SFDR, SPICMD_RDID);
-	SFCSR_CS_L(ucChip, (uiLen - 1), IOWIDTH_SINGLE);
-	ui = SPI_REG_READ(SFDR);
-	SFCSR_CS_H(ucChip, 0, IOWIDTH_SINGLE);
-	LDEBUG("ComSrlCmd_RDID: ucChip=%x; uiLen=%x; returnValue=%x; SPICMD_RDID=%x;\n", ucChip, uiLen, ui, SPICMD_RDID);
-	return ui;
-}
-// One byte Command
-void SeqCmd_Order(unsigned char ucChip,  unsigned char ucIOWidth, unsigned int uiCmd)
-{
-	LDEBUG("SeqCmd_Type1: ucChip=%x; ucIOWidth=%x; SPICMD=%x;\n", ucChip, ucIOWidth, uiCmd);
-	SFCSR_CS_L(ucChip, ucIOWidth, IOWIDTH_SINGLE);
-	SPI_REG_LOAD(SFDR, uiCmd);
-	SFCSR_CS_H(ucChip, ucIOWidth, IOWIDTH_SINGLE);
-}
-// One byte Command Write
-void SeqCmd_Write(unsigned char ucChip,  unsigned char ucIOWidth, unsigned int uiCmd, unsigned int uiValue, unsigned char ucValueLen)
-{
-	SFCSR_CS_L(ucChip, DATA_LENTH1, ucIOWidth);
-	SPI_REG_LOAD(SFDR, uiCmd);
-	SFCSR_CS_L(ucChip, ucValueLen - 1, ucIOWidth);
-	SPI_REG_LOAD(SFDR, (uiValue << ((4 - ucValueLen) * 8)));
-	SFCSR_CS_H(ucChip, DATA_LENTH1, IOWIDTH_SINGLE);
-	LDEBUG("SeqCmd_Write: ucChip=%x; ucIOWidth=%x; uiCmd=%x; uiValue=%x; ucValueLen=%x;\n", ucChip, ucIOWidth, uiCmd, uiValue, ucValueLen);
-}
-// One byte Command Read
-unsigned int SeqCmd_Read(unsigned char ucChip,  unsigned char ucIOWidth, unsigned int uiCmd, unsigned char ucRDLen)
-{
-	unsigned int ui;	
-	SFCSR_CS_L(ucChip, DATA_LENTH1, ucIOWidth);
-	SPI_REG_LOAD(SFDR, uiCmd);
-	SFCSR_CS_L(ucChip, ucRDLen-1, ucIOWidth);
-	ui = SPI_REG_READ(SFDR);
-	SFCSR_CS_H(ucChip, DATA_LENTH1, ucIOWidth);
-	ui = ui >> ((4 - ucRDLen) * 8);	
-	LDEBUG("SeqCmd_Read: ucChip=%x; ucIOWidth=%x; uiCmd=%x; ucRDLen=%x; RetVal=%x\n", ucChip, ucIOWidth, uiCmd, ucRDLen, ui);
-	return ui;
-}
-
-/****************************** Layer 2 ******************************/
-// Sector Erase (SE) Sequence (Command 20)
-unsigned int ComSrlCmd_SE(unsigned char ucChip, unsigned int uiAddr)
-{
-	SeqCmd_Order(ucChip,  IOWIDTH_SINGLE, SPICMD_WREN);
-	SeqCmd_Write(ucChip,  IOWIDTH_SINGLE, SPICMD_SE, uiAddr, 3);
-	KDEBUG("ComSrlCmd_SE: ucChip=%x; uiSector=%x; uiSectorSize=%x; SPICMD_SE=%x\n", ucChip, uiAddr, spi_flash_info[ucChip].sector_size, SPICMD_SE);	
-	return spiFlashReady(ucChip);
-}
-// Block Erase (BE) Sequence (Command D8)
-unsigned int ComSrlCmd_BE(unsigned char ucChip, unsigned int uiAddr)
-{
-	SeqCmd_Order(ucChip,  IOWIDTH_SINGLE, SPICMD_WREN);
-	SeqCmd_Write(ucChip,  IOWIDTH_SINGLE, SPICMD_BE, uiAddr, 3);	
-	KDEBUG("ComSrlCmd_BE: ucChip=%x; uiBlock=%x; uiBlockSize=%x; SPICMD_BE=%x\n", ucChip, uiAddr, spi_flash_info[ucChip].block_size, SPICMD_BE);
-	return spiFlashReady(ucChip);
-}
-// Chip Erase (CE) Sequence (Command 60 or C7)
-unsigned int ComSrlCmd_CE(unsigned char ucChip)
-{
-	SeqCmd_Order(ucChip,  IOWIDTH_SINGLE, SPICMD_WREN);
-	SeqCmd_Order(ucChip,  IOWIDTH_SINGLE, SPICMD_CE);	
-	KDEBUG("ComSrlCmd_CE: ucChip=%x; SPICMD_CE=%x\n", ucChip, SPICMD_CE);
-	return spiFlashReady(ucChip);
-}
-// without QE bit
-unsigned int ComSrlCmd_NoneQeBit(unsigned char ucChip)
-{
-	KDEBUG("ComSrlCmd_NoneQeBit: ucChip=%x;\n", ucChip);
-	return 0;
-}
-// ucIsFast: = 0 cmd, address, dummy single IO ; =1 cmd single IO, address and dummy multi IO; =2 cmd, address and dummy multi IO;
-void ComSrlCmd_InputCommand(unsigned char ucChip, unsigned int uiAddr, unsigned int uiCmd, unsigned char ucIsFast, unsigned char ucIOWidth, unsigned char ucDummyCount)
-{
-	int i;
-	LDEBUG("ComSrlCmd_InputCommand: ucChip=%x; uiAddr=%x; uiCmd=%x; uiIsfast=%x; ucIOWidth=%x; ucDummyCount=%x\n", ucChip, uiAddr, uiCmd, ucIsFast, ucIOWidth, ucDummyCount);
-
-	// input command
-	if(ucIsFast == ISFAST_ALL)
-	{
-		SFCSR_CS_L(ucChip, 0, ucIOWidth);
-	}
-	else
-	{
-		SFCSR_CS_L(ucChip, 0, IOWIDTH_SINGLE);
-	}
-	SPI_REG_LOAD(SFDR, uiCmd);				// Read Command
-
-	// input 3 bytes address
-	if(ucIsFast == ISFAST_NO)
-	{
-		SFCSR_CS_L(ucChip, 0, IOWIDTH_SINGLE);
-	}
-	else
-	{
-		SFCSR_CS_L(ucChip, 0, ucIOWidth);
-	}
-	SPI_REG_LOAD(SFDR,(uiAddr << 8));
-	SPI_REG_LOAD(SFDR,(uiAddr << 16));
-	SPI_REG_LOAD(SFDR,(uiAddr << 24));
-
-	//input dummy cycle
-	for (i = 0; i < ucDummyCount; i++)
-	{
-		SPI_REG_LOAD(SFDR, 0);
-	}
-	
-	SFCSR_CS_L(ucChip, 3, ucIOWidth);
-}
-
-// Set SFCR2 for memery map read
-unsigned int SetSFCR2(unsigned int uiCmd, unsigned char ucIsFast, unsigned char ucIOWidth, unsigned char ucDummyCount)
-{
-	unsigned int ui, uiDy;
-	ucSFCR2 = 0;
-	ui = SFCR2_SFCMD(uiCmd) | SFCR2_SFSIZE(spi_flash_info[0].device_size - 17) | SFCR2_RD_OPT(0) | SFCR2_HOLD_TILL_SFDR2(0);
-	switch (ucIsFast)
-	{
-		case ISFAST_NO:
-		{
-			ui = ui | SFCR2_CMD_IO(IOWIDTH_SINGLE) | SFCR2_ADDR_IO(IOWIDTH_SINGLE) | SFCR2_DATA_IO(ucIOWidth);
-			uiDy = 1;
-			break;
-		}
-		case ISFAST_YES:
-		{
-			ui = ui | SFCR2_CMD_IO(IOWIDTH_SINGLE) | SFCR2_ADDR_IO(ucIOWidth) | SFCR2_DATA_IO(ucIOWidth);
-			uiDy = ucIOWidth * 2;
-			break;
-		}
-		case ISFAST_ALL:
-		{
-			ui = ui | SFCR2_CMD_IO(ucIOWidth) | SFCR2_ADDR_IO(ucIOWidth) | SFCR2_DATA_IO(ucIOWidth);
-			uiDy = ucIOWidth * 2;
-			break;
-		}
-		default:
-		{
-			ui = ui | SFCR2_CMD_IO(IOWIDTH_SINGLE) | SFCR2_ADDR_IO(IOWIDTH_SINGLE) | SFCR2_DATA_IO(ucIOWidth);
-			uiDy = 1;
-			break;
-		}
-	}
-	if (uiDy == 0)
-	{
-		uiDy = 1;
-	}
-	ui = ui | SFCR2_DUMMY_CYCLE((ucDummyCount * 4 / uiDy));		// ucDummyCount is Byte Count ucDummyCount*8 / (uiDy*2)
-	SPI_REG_LOAD(SFCR2, ui);
-	LDEBUG("SetSFCR2: uiCmd=%x; ucIsFast=%; ucIOWidth=%x; ucDummyCount=%x; ucSFCR2=%x; SFCR2=%x\n;", uiCmd, ucIsFast, ucIOWidth, ucDummyCount, ucSFCR2, ui);
-	return ui;	
-}
-
-// read template
-unsigned int ComSrlCmd_ComRead(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer,unsigned int uiCmd, unsigned char ucIsFast, unsigned char ucIOWidth, unsigned char ucDummyCount)
-{
-
-	unsigned int ui, uiCount, i;
-	unsigned char* puc = pucBuffer;
-	LDEBUG("ComSrlCmd_ComRead: ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x; uiCmd=%x; uiIsfast=%x; ucIOWidth=%x; ucDummyCount=%x\n", ucChip, uiAddr, uiLen, (unsigned int)pucBuffer, uiCmd, ucIsFast, ucIOWidth, ucDummyCount);
-	ComSrlCmd_InputCommand(ucChip, uiAddr, uiCmd, ucIsFast, ucIOWidth, ucDummyCount);
-	if(ucSFCR2 != 0)	// set SFCR2
-	{
-		ui = SetSFCR2((uiCmd >> 24), ucIsFast, ucIOWidth, ucDummyCount);
-	}
-
-	uiCount = uiLen / 4;							
-	for( i = 0; i< uiCount; i++)					// Read 4 bytes every time.
-	{
-		ui = SPI_REG_READ(SFDR);
-		memcpy(puc, &ui, 4);
-		puc += 4;
-	}
-
-	i = uiLen % 4;
-	if(i > 0)
-	{
-		ui = SPI_REG_READ(SFDR);					// another bytes.
-		memcpy(puc, &ui, i);
-		puc += i;
-	}
-	SFCSR_CS_H(ucChip, 0, IOWIDTH_SINGLE);
-	return uiLen;
-	
-}
-
-// write template
-unsigned int ComSrlCmd_ComWrite(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer, unsigned int uiCmd, unsigned char ucIsFast, unsigned char ucIOWidth, unsigned char ucDummyCount)
-{
-	unsigned int ui, uiCount, i;
-	unsigned char* puc = pucBuffer;
-	LDEBUG("ComSrlCmd_ComWrite: ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x; uiCmd=%x; uiIsfast=%x; ucIOWidth=%x; ucDummyCount=%x\n", ucChip, uiAddr, uiLen, (unsigned int)pucBuffer, uiCmd, ucIsFast, ucIOWidth, ucDummyCount);
-	SeqCmd_Order(ucChip,  IOWIDTH_SINGLE, SPICMD_WREN);
-
-	ComSrlCmd_InputCommand(ucChip, uiAddr, uiCmd, ucIsFast, ucIOWidth, ucDummyCount);
-
-	uiCount = uiLen / 4;
-	for (i = 0; i <  uiCount; i++)
-	{
-		memcpy(&ui, puc, 4);
-		puc += 4;
-		SPI_REG_LOAD(SFDR, ui);
-	}
-
-	i = uiLen % 4;
-	if(i > 0)
-	{
-		memcpy(&ui, puc, i);
-		puc += i;
-		SFCSR_CS_L(ucChip, i-1, ucIOWidth);
-		SPI_REG_LOAD(SFDR, ui);
-	}
-	SFCSR_CS_H(ucChip, 0, IOWIDTH_SINGLE);
-	ui = spiFlashReady(ucChip);
-	return uiLen;
-}
-
-// write a whole sector once
-unsigned int ComSrlCmd_ComWriteSector(unsigned char ucChip, unsigned int uiAddr, unsigned char* pucBuffer)
-{
-	unsigned int i, ui;
-	unsigned char* puc = pucBuffer;
-	LDEBUG("ComSrlCmd_ComWriteSector: ucChip=%x; uiAddr=%x; pucBuffer=%x; returnValue=%x;\n", ucChip, uiAddr, (unsigned int)pucBuffer, spi_flash_info[ucChip].sector_size);
-	//prnDispAddr(uiAddr);
-	NDEBUG(".");
-	ui = spi_flash_info[ucChip].pfErase(ucChip, uiAddr);
-	for (i = 0; i < spi_flash_info[ucChip].page_cnt; i++)
-	{
-		ui = spi_flash_info[ucChip].pfPageWrite(ucChip, uiAddr, spi_flash_info[ucChip].page_size, puc);
-		uiAddr += spi_flash_info[ucChip].page_size;
-		puc += spi_flash_info[ucChip].page_size;
-	}
-	return spi_flash_info[ucChip].sector_size;
-}
-
-// write sector use malloc buffer
-unsigned int ComSrlCmd_BufWriteSector(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer)
-{
-	unsigned char pucSector[spi_flash_info[ucChip].sector_size];
-	unsigned int ui, uiStartAddr, uiOffset;
-	LDEBUG("ComSrlCmd_BufWriteSector:ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x;\n", ucChip, uiAddr, uiLen, pucBuffer);
-	uiOffset = uiAddr % spi_flash_info[ucChip].sector_size;
-	uiStartAddr = uiAddr - uiOffset;
-	// get
-	ui = spi_flash_info[ucChip].pfRead(ucChip, uiStartAddr, spi_flash_info[ucChip].sector_size, pucSector);
-	// modify
-	memcpy(pucSector + uiOffset, pucBuffer, uiLen);
-	//write back
-	ui = ComSrlCmd_ComWriteSector(ucChip, uiStartAddr, pucSector);
-	return ui;
-}
-
-// write data, any address any lenth
-unsigned int ComSrlCmd_ComWriteData(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer)
-{
-	unsigned int uiStartAddr, uiStartLen, uiSectorAddr, uiSectorCount, uiEndAddr, uiEndLen, i;
-	unsigned char* puc = pucBuffer;
-	LDEBUG("ComSrlCmd_ComWriteData:ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x\n", ucChip, uiAddr, uiLen, (unsigned int)pucBuffer);
-	calAddr(uiAddr, uiLen, spi_flash_info[ucChip].sector_size, &uiStartAddr, &uiStartLen, &uiSectorAddr, &uiSectorCount, &uiEndAddr, &uiEndLen);
-	if((uiSectorCount == 0x00) && (uiEndLen == 0x00))	// all data in the same sector
-	{
-		ComSrlCmd_BufWriteSector(ucChip, uiStartAddr, uiStartLen, puc);
-	}
-	else
-	{
-		if(uiStartLen > 0)
-		{
-			ComSrlCmd_BufWriteSector(ucChip, uiStartAddr, uiStartLen, puc);
-			puc += uiStartLen;
-		}
-		for(i = 0; i < uiSectorCount; i++)
-		{
-			ComSrlCmd_ComWriteSector(ucChip, uiSectorAddr, puc);
-			puc += spi_flash_info[ucChip].sector_size;
-			uiSectorAddr += spi_flash_info[ucChip].sector_size;
-		}
-		if(uiEndLen > 0)
-		{
-			ComSrlCmd_BufWriteSector(ucChip, uiEndAddr, uiEndLen, puc);
-		}
-	}
-	SeqCmd_Order(ucChip,  IOWIDTH_SINGLE, SPICMD_WRDI);
-	return uiLen;
-}
-
-/****************************** Macronix ******************************/
-// MX25L1605 MX25L3205 Read at High Speed (FAST_READ) Sequence (Command 0B)
-unsigned int  SpiRead_11110B(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer)
-{
-	KDEBUG(" SpiRead_11110B: ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x; SPICMD_FASTREAD=%x;\n", ucChip, uiAddr, uiLen, (unsigned int)pucBuffer, SPICMD_FASTREAD);
-	return ComSrlCmd_ComRead(ucChip, uiAddr, uiLen, pucBuffer, SPICMD_FASTREAD, ISFAST_NO, IOWIDTH_SINGLE, DUMMYCOUNT_1);
-}
-// Page Program (PP) Sequence (Command 02)
-unsigned int  PageWrite_111002(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer)
-{
-	KDEBUG(" PageWrite_111002: ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x; SPICMD_PP=%x;\n", ucChip, uiAddr, uiLen, (unsigned int)pucBuffer, SPICMD_PP);
-	return ComSrlCmd_ComWrite(ucChip, uiAddr, uiLen, pucBuffer, SPICMD_PP, ISFAST_NO, IOWIDTH_SINGLE, DUMMYCOUNT_0);
-}
-#if (SPI_DRIVER_MODE == 1)
-// Set quad enable bit
-unsigned int mxic_spi_setQEBit(unsigned char ucChip)
-{
-	unsigned int ui;
-	SeqCmd_Order(ucChip,  IOWIDTH_SINGLE, SPICMD_WREN);
-	ui = 1 << SPI_STATUS_QE;
-	SeqCmd_Write(ucChip, IOWIDTH_SINGLE, SPICMD_WRSR, ui, 1);
-	KDEBUG("MxicSetQEBit: ucChip=%d; statusRegister=%x; returnValue=%x\n", ucChip, SeqCmd_Read(ucChip, IOWIDTH_SINGLE, SPICMD_RDSR, 1), ui);
-	return ui;
-}
-// MX25L1605 MX25L3205 Read at Dual IO Mode Sequence (Command BB)
-unsigned int  SpiRead_1221BB(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer)
-{
-	KDEBUG(" SpiRead_1221BB: ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x; SPICMD_2READ=%x;\n", ucChip, uiAddr, uiLen, (unsigned int)pucBuffer, SPICMD_2READ);
-	return ComSrlCmd_ComRead(ucChip, uiAddr, uiLen, pucBuffer, SPICMD_2READ, ISFAST_YES, IOWIDTH_DUAL, DUMMYCOUNT_1);
-}
-// MX25L1635 MX25L3235 4 x I/O Read Mode Sequence (Command EB)
-unsigned int  SpiRead_1443EB(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer)
-{
-	KDEBUG(" SpiRead_1443EB: ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x; SPICMD_4READ=%x;\n", ucChip, uiAddr, uiLen, (unsigned int)pucBuffer, SPICMD_4READ);
-	return ComSrlCmd_ComRead(ucChip, uiAddr, uiLen, pucBuffer, SPICMD_4READ, ISFAST_YES, IOWIDTH_QUAD, DUMMYCOUNT_3);
-}
-// 4 x I/O Page Program (4PP) Sequence (Command 38)
-unsigned int  PageWrite_144038(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer)
-{
-	KDEBUG(" PageWrite_144038: ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x; SPICMD_4PP=%x;\n", ucChip, uiAddr, uiLen, (unsigned int)pucBuffer, SPICMD_4PP);
-	return ComSrlCmd_ComWrite(ucChip, uiAddr, uiLen, pucBuffer, SPICMD_4PP, ISFAST_YES, IOWIDTH_QUAD, DUMMYCOUNT_0);
-}
-#endif
-
-/****************************** SST ******************************/
-// Layer1 SST Byte-Program
-void SstComSrlCmd_BP(unsigned char ucChip, unsigned int uiAddr, unsigned char ucValue)
-{
-	unsigned int ui;
-	ui = SPICMD_PP | (uiAddr & 0x00ffffff);
-	SFCSR_CS_L(ucChip, 3, 0);
-	SPI_REG_LOAD(SFDR, ui);
-	SFCSR_CS_L(ucChip, 0, IOWIDTH_SINGLE);
-	SPI_REG_LOAD(SFDR, (ucValue<< 24));
-	SFCSR_CS_H(ucChip, 0, IOWIDTH_SINGLE);
-	LDEBUG("SstComSrlCmd_BP: ucChip=%x; uiAddr=%x; ucValue=%x; SPICMD_SST_BP=%x;\n", ucChip, uiAddr, ucValue, SPICMD_PP);
-}
-// Layer2 Sector Write Use BP Mode
-unsigned int sst_PageWrite_s1(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer)
-{
-	unsigned int i, ui;
-	unsigned char* puc = pucBuffer;
-	KDEBUG("sst_cmd_write_s1: ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x; returnValue=%x;\n", ucChip, uiAddr, uiLen, (unsigned int)pucBuffer, uiLen);
-	for (i = 0; i < uiLen; i++)
-	{
-		SeqCmd_Order(ucChip,  IOWIDTH_SINGLE, SPICMD_WREN);
-		SstComSrlCmd_BP(ucChip, uiAddr, *puc);
-		ui = spiFlashReady(ucChip);
-		puc += 1;
-		uiAddr = uiAddr + 1;
-	}
-	return uiLen;
-}
-
-/****************************** Spansion ******************************/
-// Layer2 Spansion Set QE bit
-#if (SPI_DRIVER_MODE == 1)
-unsigned int span_spi_setQEBit(unsigned char ucChip)
-{
-	unsigned int ui;
-	SeqCmd_Order(ucChip,  IOWIDTH_SINGLE, SPICMD_WREN);
-	ui = 1 << SPAN_CONF_QUAD;
-	SeqCmd_Write(ucChip, IOWIDTH_SINGLE, SPICMD_WRSR, ui, 2);
-	KDEBUG("SpanSetQEBit: ucChip=%d; statusRegister=%x; returnValue=%x\n", ucChip, SeqCmd_Read(ucChip, IOWIDTH_SINGLE, SPICMD_RDSR, 2), ui);
-	return spiFlashReady(ucChip);
-}
-#endif
-
-/****************************** Winbond ******************************/
-// Layer3 Winbond Set QE Bit
-#if (SPI_DRIVER_MODE == 1)
-unsigned int wb_spi_setQEBit(unsigned char ucChip)
-{
-	unsigned int ui;
-	SeqCmd_Order(ucChip,  IOWIDTH_SINGLE, SPICMD_WREN);
-	ui = 1 << (WB_STATUS_QE - 8);
-	SeqCmd_Write(ucChip, IOWIDTH_SINGLE, SPICMD_WRSR, ui, 2);
-	KDEBUG("WBSetQEBit: ucChip=%d; statusRegister=%x; returnValue=%x\n", ucChip, SeqCmd_Read(ucChip, IOWIDTH_SINGLE, SPICMD_RDSR, 1), ui);
-	return spiFlashReady(ucChip);
-}
-// Quad Program Page Program (Command 32)
-unsigned int PageWrite_114032(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer)
-{
-	KDEBUG("PageWrite_114032: ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x; SPICMD_WB_QPP=%x;\n", ucChip, uiAddr, uiLen, (unsigned int)pucBuffer, SPICMD_WB_QPP);
-	return ComSrlCmd_ComWrite(ucChip, uiAddr, uiLen, pucBuffer, SPICMD_WB_QPP, ISFAST_NO, IOWIDTH_QUAD, DUMMYCOUNT_0);
-}
-#endif
-
-/****************************** Giga Device ******************************/
-// Set quad enable bit
-#if (SPI_DRIVER_MODE == 1)
-unsigned int gd_spi_setQEBit(unsigned char ucChip)
-{
-	unsigned int ui;
-	SeqCmd_Order(ucChip,  IOWIDTH_SINGLE, SPICMD_WREN);
-	ui = 1 << (GD_STATUS_QE - 8);
-	SeqCmd_Write(ucChip, IOWIDTH_SINGLE, SPICMD_WRSR, ui, 2);	// set Giga Devcie QE bit
-	KDEBUG("gd_spi_setQEBit: ucChip=%d; statusRegister=%x; returnValue=%x\n", ucChip, SeqCmd_Read(ucChip, IOWIDTH_SINGLE, SPICMD_RDSR, 2));
-	GdCmdSrl_HPM(ucChip);
-	return ui;
-}
-// High Performance Mode (HPM) (A3H)
-unsigned int GdCmdSrl_HPM(unsigned char ucChip)
-{
-	SeqCmd_Write(ucChip,  IOWIDTH_SINGLE, SPICMD_GD_HPM, 0x00, 3);	// command add 3 dummy
-	KDEBUG("GdCmdSrl_HPM: ucChip=%d; SPICMD_GD_HPM=%x; \n", ucChip, SPICMD_GD_HPM);
-	return spiFlashReady(ucChip);
-}
-#endif
-
-/****************************** ATMEL ******************************/
-// AT25DF161 Dual-Output Read Array(Command 3B)
-#if (SPI_DRIVER_MODE == 1)
-unsigned int SpiRead_11213B(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer)
-{
-	KDEBUG("SpiRead_11213B: ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x; SPICMD_AT_READ2=%x;\n", ucChip, uiAddr, uiLen, (unsigned int)pucBuffer, SPICMD_AT_READ2);
-	return ComSrlCmd_ComRead(ucChip, uiAddr, uiLen, pucBuffer, SPICMD_AT_READ2, ISFAST_NO, IOWIDTH_DUAL, DUMMYCOUNT_1);
-}
-// AT25DF161 Dual-Input Byte/Page Program(Command A2)
-unsigned int PageWrite_1120A2(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer)
-{
-	KDEBUG("PageWrite_1120A2: ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x; SPICMD_AT_PP2=%x;\n", ucChip, uiAddr, uiLen, (unsigned int)pucBuffer, SPICMD_AT_PP2);
-	return ComSrlCmd_ComWrite(ucChip, uiAddr, uiLen, pucBuffer, SPICMD_AT_PP2, ISFAST_NO, IOWIDTH_DUAL, DUMMYCOUNT_0);
-}
-#endif
-
-#if (MTD_SPI_TEST_CHIP == 1)
-unsigned int test_spi_flash(unsigned char ucChip)
-{
-	unsigned char pucSrc[0x100] = {0};
-	unsigned char pucDst[0x100] = {0};
-	unsigned int uiOffset = 0x10000;
-	unsigned int uiAddr = 0x10000;
-	unsigned int uiCount = spi_flash_info[ucChip].sector_cnt - (uiOffset) / spi_flash_info[ucChip].sector_size;
-	unsigned int uiRet = 0;
-	unsigned int uiLine = 0;
-	unsigned int uiStep = 0;
-	int i = 0, j = 0;
-	if(uiCount > 0x1f0)
-	{
-		uiStep = uiCount / 0x1f0;
-	}
-	else
-	{
-		uiStep = 1;
-	}
-	for (i = 0; i< 0x100; i++) pucSrc[i] = i;
-	NDEBUG("\nTest SPI flash: offset->0x%x, step->0x%x\n", (uiOffset - 0x80), (spi_flash_info[ucChip].sector_size * uiStep));
-	uiCount = 1;	// Delete
-	for (j = 0; j < uiCount; j += uiStep)
-	{
-		uiAddr = uiOffset + j * spi_flash_info[ucChip].sector_size - 0x80;
-		spi_flash_info[ucChip].pfWrite(ucChip, uiAddr, 0x100, pucSrc);
-		memset(pucDst, 0, 0x100);
-		spi_flash_info[ucChip].pfRead(ucChip, uiAddr, 0x100, pucDst);
-		for( i = 0; i < 0x100; i++)
-		{
-			if(pucDst[i] != pucSrc[i])
-			{
-				NDEBUG("%07x-ER", uiAddr);
-				uiRet += 1;
-				break;
-			}
-		}
-		if(i == 0x100) NDEBUG("%07x-OK", uiAddr);
-		uiLine++;
-		if(uiLine == 6)
-		{
-			NDEBUG("\n");
-			uiLine = 0;
-		}
-	}
-	NDEBUG("\nTotal Count = 0x%x; OK Count = 0x%x; Error Count = 0x%x\n", uiCount, (uiCount - uiRet), uiRet);
-	return uiRet;
-}
-#endif
+/*
+ *
+ *  Copyright (c) 2011 Realtek Semiconductor Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+/* SPI Flash driver
+ *
+ * Written by sam (sam@realtek.com)
+ * 2010-05-01
+ *
+ */
+
+#define MTD_SPI_DEBUG		2
+#define MTD_SPI_TEST_CHIP	0
+#include "spi_common.h"
+
+#ifndef SPI_KERNEL
+// ****** spi flash driver in bootcode
+
+#include <asm/rtl8196x.h>
+#include <rtl_types.h>
+#if (MTD_SPI_DEBUG == 0)
+//0
+#define NDEBUG(args...) printf(args)
+#define KDEBUG(args...) printf(args)
+#define LDEBUG(args...) printf(args)
+#endif
+//1
+#if (MTD_SPI_DEBUG == 1)
+#define NDEBUG(args...) printf(args)
+#define KDEBUG(args...) printf(args)
+#define LDEBUG(args...)
+#endif
+//2
+#if (MTD_SPI_DEBUG == 2)
+#define NDEBUG(args...) printf(args)
+#define KDEBUG(args...)
+#define LDEBUG(args...)
+#endif
+//3
+#if (MTD_SPI_DEBUG == 3)
+#define NDEBUG(args...)
+#define KDEBUG(args...)
+#define LDEBUG(args...)
+#endif
+
+#else
+// ****** spi flash driver in kernel
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/vmalloc.h>
+#define malloc	vmalloc
+#define free	vfree
+//0
+#if (MTD_SPI_DEBUG == 0)
+#define NDEBUG(args...) printk(args)
+#define KDEBUG(args...) printk(args)
+#define LDEBUG(args...) printk(args)
+#endif
+//1
+#if (MTD_SPI_DEBUG == 1)
+#define NDEBUG(args...) printk(args)
+#define KDEBUG(args...) printk(args)
+#define LDEBUG(args...)
+#endif
+//2
+#if (MTD_SPI_DEBUG == 2)
+#define NDEBUG(args...) printk(args)
+#define KDEBUG(args...)
+#define LDEBUG(args...)
+#endif
+//3
+#if (MTD_SPI_DEBUG == 3)
+#define NDEBUG(args...)
+#define KDEBUG(args...)
+#define LDEBUG(args...)
+#endif
+
+#endif
+
+/* SPI Flash Configuration Register(SFCR) (0xb800-1200) */
+#define SFCR					0xb8001200			/*SPI Flash Configuration Register*/		
+#define SFCR_SPI_CLK_DIV(val)	((val) << 29)
+#define SFCR_RBO(val)			((val) << 28)
+#define SFCR_WBO(val)			((val) << 27)
+#define SFCR_SPI_TCS(val)		((val) << 23)			/*4 bit, 1111 */
+
+/* SPI Flash Configuration Register(SFCR2) (0xb800-1204) */
+#define SFCR2						0xb8001204
+#define SFCR2_SFCMD(val)			((val) << 24)			/*8 bit, 1111_1111 */
+#define SFCR2_SFSIZE(val)			((val) << 21)			/*3 bit, 111 */
+#define SFCR2_RD_OPT(val)			((val) << 20)
+#define SFCR2_CMD_IO(val)			((val) << 18)			/*2 bit, 11 */
+#define SFCR2_ADDR_IO(val)			((val) << 16)			/*2 bit, 11 */
+#define SFCR2_DUMMY_CYCLE(val)		((val) << 13)			/*3 bit, 111 */
+#define SFCR2_DATA_IO(val)			((val) << 11)			/*2 bit, 11 */
+#define SFCR2_HOLD_TILL_SFDR2(val)	((val) << 10)
+
+/* SPI Flash Control and Status Register(SFCSR)(0xb800-1208) */
+#define SFCSR					0xb8001208
+#define SFCSR_SPI_CSB0(val)		((val) << 31)
+#define SFCSR_SPI_CSB1(val)		((val) << 30)		
+#define SFCSR_LEN(val)			((val) << 28)			/*2 bits*/
+#define SFCSR_SPI_RDY(val)		((val) << 27)
+#define SFCSR_IO_WIDTH(val)		((val) << 25)			/*2 bits*/
+#define SFCSR_CHIP_SEL(val)		((val) << 24)
+#define SFCSR_CMD_BYTE(val)		((val) << 16)			/*8 bit, 1111_1111 */
+
+#define SFCSR_SPI_CSB(val)		((val) << 30)
+
+/* SPI Flash Data Register(SFDR)(0xb800-120c) */
+#define SFDR					0xb800120c
+
+/* SPI Flash Data Register(SFDR2)(0xb8001210) */
+#define SFDR2					0xb8001210
+
+#define SPI_BLOCK_SIZE			0x10000				/* 64KB */
+#define SPI_SECTOR_SIZE			0x1000				/* 4KB */
+#define SPI_PAGE_SIZE			0x100				/* 256B */
+
+#define SPICMD_WREN			(0x06 << 24)	/* 06 xx xx xx xx sets the (WEL) write enable latch bit */
+#define SPICMD_WRDI			(0x04 << 24)	/* 04 xx xx xx xx resets the (WEL) write enable latch bit*/
+#define SPICMD_RDID			(0x9f << 24)	/* 9f xx xx xx xx outputs JEDEC ID: 1 byte manufacturer ID & 2 byte device ID */
+#define SPICMD_RDSR			(0x05 << 24)	/* 05 xx xx xx xx to read out the values of the status register */
+#define SPICMD_WRSR			(0x01 << 24)	/* 01 xx xx xx xx to write new values to the status register */
+#define SPICMD_READ			(0x03 << 24)	/* 03 a1 a2 a3 xx n bytes read out until CS# goes high */
+#define SPICMD_FASTREAD		(0x0b << 24)	/* 0b a1 a2 a3 dd n bytes read out until CS# goes high */
+#define SPICMD_2READ		(0xbb << 24)	/* bb 12 3d xx xx n bytes read out by 2 I/O until CS# goes high */
+#define SPICMD_4READ		(0xeb << 24)	/* eb 3a 3d xx xx n bytes read out by 4 x I/O until CS# goes high */
+#define SPICMD_SE			(0x20 << 24)	/* 20 a1 a2 a3 xx to erase the selected sector */
+#define SPICMD_BE			(0xd8 << 24)	/* d8 a1 a2 a3 xx to erase the selected block */
+#define SPICMD_CE			(0x60 << 24)	/* 60 xx xx xx xx to erase whole chip (cmd or 0xc7) */
+#define SPICMD_PP			(0x02 << 24)	/* 02 a1 a2 a3 xx to program the selected page */
+#define SPICMD_4PP			(0x38 << 24)	/* 38 3a 3d xx xx quad input to program the selected page */
+#define SPICMD_CP			(0xad << 24)	/* ad a1 a2 a3 xx continously program whole chip, the address is automaticlly increase */
+#define SPICMD_DP			(0xb9 << 24)	/* b9 xx xx xx xx enters deep power down mode */
+#define SPICMD_RDP			(0xab << 24)	/* ab xx xx xx xx release from deep power down mode */
+#define SPICMD_RES			(0xab << 24)	/* ab ?? ?? ?? xx to read out 1 byte device ID */
+#define SPICMD_REMS_90		(0x90 << 24)	/* 90 ?? ?? ?? xx output the manufacter ID & device ID */
+#define SPICMD_REMS_EF		(0xef << 24)	/* ef ?? ?? ?? xx output the manufacter ID & device ID */
+#define SPICMD_REMS_DF		(0xdf << 24)	/* df ?? ?? ?? ?? output the manufacture ID & device ID */
+#define SPICMD_ENSO			(0xb1 << 24)	/* b1 xx xx xx xx to enter the 512 bit secured OTP mode */
+#define SPICMD_EXSO			(0xc1 << 24)	/* c1 xx xx xx xx to exit the 512 bit secured OTP mode */
+#define SPICMD_RDSCUR		(0x2b << 24)	/* 2b xx xx xx xx to read value of secured register */
+#define SPICMD_WRSCUR		(0x2f << 24)	/* 2f xx xx xx xx to set the lock down bit as "1" (once lock down, can not be updated) */
+#define SPICMD_ESRY			(0x70 << 24)	/* 70 xx xx xx xx to enable SO to output RY/BY# during CP mode */
+#define SPICMD_DSRY			(0x80 << 24)	/* 80 xx xx xx xx to disable SO to output RY/BY# during CP mode */
+
+#define SPI_STATUS_REG_SRWD		0x07	/* status register write protect */
+#define SPI_STATUS_CP			0x06	/* continously program mode */
+#define SPI_STATUS_QE			0x06	/* quad enable */
+#define SPI_STATUS_BP3			0x05	/* level of protected block */
+#define SPI_STATUS_BP2			0x04	/* level of protected block */
+#define SPI_STATUS_BP1			0x03	/* level of protected block */
+#define SPI_STATUS_BP0			0x02	/* level of protected block */
+#define SPI_STATUS_WEL			0x01	/* write enable latch */
+#define SPI_STATUS_WIP			0x00	/* write in process bit */
+
+/****** EON ******/
+
+/****** SPANSION ******/
+#define SPICMD_SPAN_QOR			(0x6b << 24)	/* 3 0 1 (1 to ) Quad Ou// write sector use malloc buffer */
+#define SPICMD_SPAN_QPP			(0x32 << 24)	/* Quad Page Programming */
+#define SPAN_CONF_QUAD			0x01
+
+/****** WINBOND ******/
+#define WB_STATUS_QE		0x09	/* QUAD ENABLE (non-volatile) */
+#define SPICMD_WB_QPP		(0x32 << 24)		/* Quad Page Program */
+
+/****** SST ******/
+
+/****** GigaDevice ******/
+#define GD_STATUS_QE		0x09	/* 9 When the QE bit is set to 0 (Default) the WP# pin and HOLD# pin are enable */
+#define SPICMD_GD_HPM		(0xA3 << 24)	/*  High Performance Mode A3H dummy   dummy      dummy */
+#define SPICMD_GD_QPP		0x32
+
+/****** ATMEL ******/
+//                                                                                                Clock         Address    Dummy  Data
+//Command                                                                     Opcode           Frequency         Bytes      Bytes Bytes
+#define SPICMD_AT_READ2		(0x3b << 24)	//Dual-Output Read Array				3Bh   0011 1011    Up to 85 MHz           3         1    1+
+#define SPICMD_AT_PP2		(0xa2 << 24)	//Dual-Input Byte/Page Program 			A2h   1010 0010    Up to 100 MHz          3         0    1+
+
+/* Spanson Flash */
+#define S25FL004A		0x00010212
+#define S25FL016A		0x00010214
+#define S25FL032A		0x00010215
+#define S25FL064A		0x00010216		/*supposed support*/
+#define S25FL128P		0x00012018		/*only S25FL128P0XMFI001, Uniform 64KB secotr*/
+										/*not support S25FL128P0XMFI011, Uniform 256KB secotr*/
+										/*because #define SPI_BLOCK_SIZE 65536 */
+#define S25FL032P		0x00010215
+
+/* MICRONIX Flash */
+#define MX25L4005		0x00C22013
+#define MX25L1605D		0x00C22015
+#define MX25L1605E		0x00C22015
+#define MX25L3205D		0x00C22016		/*supposed support*/
+#define MX25L3205E		0x00C22016		/*supposed support*/
+#define MX25L6405D		0x00C22017
+#define MX25L6405E		0x00C22017
+#define MX25L6445E		0x00C22017
+#define MX25L12805D		0x00C22018
+#define MX25L12845E		0x00C22018
+
+#define MX25L1635D		0x00C22415
+#define MX25L1635E		0x00C22515
+#define MX25L1636E		0x00C22515
+#define MX25L3235D		0x00C25E16
+
+/* SST Flash */
+#define SST25VF032B		0x00BF254A		//4MB
+#define SST26VF016		0x00BF2601
+#define SST26VF032		0x00BF2602
+
+/* WinBond Flash */
+#define W25Q80			0x00EF4014
+#define W25Q16			0x00EF4015
+#define W25Q32			0x00EF4016
+#define W25Q64			0x00EF4017
+
+/* Eon Flash */
+#define EN25F32			0x001c3116
+#define EN25F16			0x001c3115
+#define EN25Q32			0x001c3016
+#define EN25Q16			0x001c3015
+
+/* GigaDevice Flash */
+#define GD25Q16			0x00c84015
+#define GD25Q32			0x00c84016
+#define GD25Q64			0x00c84017
+
+/* Atmel Flash */
+#define AT25DF161		0x001f4602
+
+#define SIZE2N_128K	0x11
+#define SIZE2N_256K	0x12
+#define SIZE2N_512K	0x13
+#define SIZE2N_01MB	0x14
+#define SIZE2N_02MB	0x15
+#define SIZE2N_04MB	0x16
+#define SIZE2N_08MB	0x17
+#define SIZE2N_16MB	0x18
+#define SIZE2N_32MB	0x19
+#define SIZE2N_64MB	0x20
+#define SIZE2N_128M	0x21
+
+#define SIZE_256B	0x100
+#define SIZE_004K	0x1000
+#define SIZE_064K	0x10000
+
+#define SPI_REG_READ(reg)	*((volatile unsigned int *)(reg))
+#define SPI_REG_LOAD(reg,val)	\
+do { \
+	while((*((volatile unsigned int *)SFCSR) & (SFCSR_SPI_RDY(1))) == 0) \
+		; \
+	*((volatile unsigned int *)(reg)) = (val); \
+} while(0)
+
+#define IOWIDTH_SINGLE			0x00
+#define IOWIDTH_DUAL			0x01
+#define IOWIDTH_QUAD			0x02
+#define DATA_LENTH1				0x00
+#define DATA_LENTH2				0x01
+#define DATA_LENTH4				0x02
+#define ISFAST_NO				0x00
+#define ISFAST_YES				0x01
+#define ISFAST_ALL				0x02
+#define DUMMYCOUNT_0			0x00
+#define DUMMYCOUNT_1			0x01
+#define DUMMYCOUNT_2			0x02
+#define DUMMYCOUNT_3			0x03
+#define DUMMYCOUNT_4			0x04
+#define DUMMYCOUNT_5			0x05
+#define DUMMYCOUNT_6			0x06
+#define DUMMYCOUNT_7			0x07
+#define DUMMYCOUNT_8			0x08
+#define DUMMYCOUNT_9			0x09
+
+struct spi_flash_type spi_flash_info[2];
+//unsigned char ucDispCount = 0;
+unsigned char ucSFCR2 = 154;
+#if (MTD_SPI_TEST_CHIP == 1)
+unsigned int test_spi_flash(unsigned char ucChip);
+#endif
+
+struct spi_flash_known spi_flash_registed[] = {
+/****************************************** Micronix Flash ******************************************/
+//#define MX25L1605D		0x00C22015
+{0x00C22015, 0x00, SIZE2N_02MB, SIZE_064K, SIZE_004K, SIZE_256B, "MX25L1605D/E"
+#if (SPI_DRIVER_MODE == 1)
+, 86, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#else
+, 86, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#endif
+},
+//#define MX25L3205D		0x00C22016
+{0x00C22016, 0x00, SIZE2N_04MB, SIZE_064K, SIZE_004K, SIZE_256B, "MX25L3205D/E"
+#if (SPI_DRIVER_MODE == 1)
+, 86, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#else
+, 86, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#endif
+},
+//#define MX25L6405D		0x00C22017
+//#define MX25L6405E		0x00C22017
+//#define MX25L6445E		0x00C22017
+{0x00C22017, 0x00, SIZE2N_08MB, SIZE_064K, SIZE_004K, SIZE_256B, "MX6405D/05E/45E"
+#if (SPI_DRIVER_MODE == 1)
+, 86, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#else
+, 86, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#endif
+},
+//#defien MX25L12805D		0x00C22018
+//#define MX25L12845E		0x00C22018
+{0x00C22018, 0x00, SIZE2N_16MB, SIZE_064K, SIZE_004K, SIZE_256B, "MX25L12805D/45E"
+#if (SPI_DRIVER_MODE == 1)
+, 86, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#else
+, 86, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#endif
+},
+//#define MX25L1635D		0x00C22415
+{0x00C22415, 0x00, SIZE2N_02MB, SIZE_064K, SIZE_004K, SIZE_256B, "MX25L1635D"
+#if (SPI_DRIVER_MODE == 1)
+, 75, ComSrlCmd_SE,  SpiRead_1443EB, mxic_spi_setQEBit,  PageWrite_144038
+#else
+, 75, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#endif
+},
+//#define MX25L1635E		0x00C22515 (clock 108 down to 54)
+{0x00C22515, 0x00, SIZE2N_02MB, SIZE_064K, SIZE_004K, SIZE_256B, "MX25L1635E/36E"
+#if (SPI_DRIVER_MODE == 1)
+, 108, ComSrlCmd_SE,  SpiRead_1443EB, mxic_spi_setQEBit,  PageWrite_144038
+#else
+, 108, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#endif
+},
+//#define MX25L3235D		0x00C25E16
+{0x00C25E16, 0x00, SIZE2N_04MB, SIZE_064K, SIZE_004K, SIZE_256B, "MX25L3235D"
+#if (SPI_DRIVER_MODE == 1)
+, 75, ComSrlCmd_SE,  SpiRead_1443EB, mxic_spi_setQEBit,  PageWrite_144038
+#else
+, 104, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#endif
+},
+/****************************************** Spanson Flash ******************************************/
+//#define S25FL016A		0x00010214
+{0x00010214, 0x00, SIZE2N_02MB, SIZE_064K, SIZE_064K, SIZE_256B, "S25FL016A"
+#if (SPI_DRIVER_MODE == 1)
+, 50, ComSrlCmd_BE, SpiRead_11110B, ComSrlCmd_NoneQeBit, PageWrite_111002
+#else
+, 50, ComSrlCmd_BE, SpiRead_11110B, ComSrlCmd_NoneQeBit, PageWrite_111002
+#endif
+},
+//#define S25FL032A		0x00010215
+{0x00010215, 0x00, SIZE2N_04MB, SIZE_064K, SIZE_064K, SIZE_256B, "S25FL032A"
+#if (SPI_DRIVER_MODE == 1)
+, 50, ComSrlCmd_BE, SpiRead_11110B, ComSrlCmd_NoneQeBit, PageWrite_111002
+#else
+, 50, ComSrlCmd_BE, SpiRead_11110B, ComSrlCmd_NoneQeBit, PageWrite_111002
+#endif
+},
+//#define S25FL064A		0x00010216
+{0x00010216, 0x00, SIZE2N_08MB, SIZE_064K, SIZE_064K, SIZE_256B, "S25FL064P"
+#if (SPI_DRIVER_MODE == 1)
+, 80, ComSrlCmd_BE, SpiRead_1443EB, span_spi_setQEBit, PageWrite_114032
+#else
+, 104, ComSrlCmd_BE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#endif
+},
+/****************************************** Eon Flash ******************************************/
+//#define EN25F16			0x001c3115
+{0x001c3115, 0x00, SIZE2N_02MB, SIZE_064K, SIZE_004K, SIZE_256B, "EN25F16"
+#if (SPI_DRIVER_MODE == 1)
+, 100, ComSrlCmd_SE, SpiRead_11110B, ComSrlCmd_NoneQeBit, PageWrite_111002
+#else
+, 100, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#endif
+},
+//#define EN25F32			0x001c3116
+{0x001c3116, 0x00, SIZE2N_04MB, SIZE_064K, SIZE_004K, SIZE_256B, "EN25F32-100"
+#if (SPI_DRIVER_MODE == 1)
+, 100, ComSrlCmd_SE, SpiRead_11110B, ComSrlCmd_NoneQeBit, PageWrite_111002
+#else
+, 100, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#endif
+},
+//#define EN25Q16			0x001c3015
+{0x001c3015, 0x00, SIZE2N_02MB, SIZE_064K, SIZE_004K, SIZE_256B, "EN25Q16A"
+#if (SPI_DRIVER_MODE == 1)
+, 80, ComSrlCmd_SE, SpiRead_1443EB, ComSrlCmd_NoneQeBit, PageWrite_111002
+#else
+, 80, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#endif
+},
+//#define EN25Q32			0x001c3016
+{0x001c3016, 0x00, SIZE2N_04MB, SIZE_064K, SIZE_004K, SIZE_256B, "EN25Q32A"
+#if (SPI_DRIVER_MODE == 1)
+, 80, ComSrlCmd_SE, SpiRead_1443EB, ComSrlCmd_NoneQeBit, PageWrite_111002
+#else
+, 80, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#endif
+},
+/****************************************** SST Flash ******************************************/
+//#define SST25VF032B		0x00BF254A (clock 80 down to 40)
+{0x00BF254A, 0x00, SIZE2N_04MB, SIZE_064K, SIZE_004K, SIZE_256B, "SST25VF032B"
+#if (SPI_DRIVER_MODE == 1)
+, 40, ComSrlCmd_SE, SpiRead_11110B, ComSrlCmd_NoneQeBit, sst_PageWrite_s1
+#else
+, 40, ComSrlCmd_SE, SpiRead_11110B, ComSrlCmd_NoneQeBit, sst_PageWrite_s1
+#endif
+},
+/****************************************** GigaDevice Flash ******************************************/
+//#define GD25Q16			0x00c84015
+{0x00c84015, 0x00, SIZE2N_02MB, SIZE_064K, SIZE_004K, SIZE_256B, "GD25Q16"
+#if (SPI_DRIVER_MODE == 1)
+, 90, ComSrlCmd_SE, SpiRead_1443EB, gd_spi_setQEBit, PageWrite_111002
+#else
+, 120, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#endif
+},
+//#define GD25Q32			0x00c84016
+{0x00c84016, 0x00, SIZE2N_04MB, SIZE_064K, SIZE_004K, SIZE_256B, "GD25Q32"
+#if (SPI_DRIVER_MODE == 1)
+, 80, ComSrlCmd_SE, SpiRead_1443EB, gd_spi_setQEBit, PageWrite_114032
+#else
+, 100, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#endif
+},
+//#define GD25Q64			0x00c84017
+{0x00c84017, 0x00, SIZE2N_08MB, SIZE_064K, SIZE_004K, SIZE_256B, "GD25Q64"
+#if (SPI_DRIVER_MODE == 1)
+, 80, ComSrlCmd_SE, SpiRead_1443EB, gd_spi_setQEBit, PageWrite_114032
+#else
+, 100, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#endif
+},
+/****************************************** WinBond Flash ******************************************/
+//#define W25Q16			0x00EF4015
+{0x00EF4015, 0x00, SIZE2N_02MB, SIZE_064K, SIZE_004K, SIZE_256B, "W25Q16"
+#if (SPI_DRIVER_MODE == 1)
+, 104, ComSrlCmd_SE, SpiRead_1443EB, wb_spi_setQEBit, PageWrite_114032
+#else
+, 104, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#endif
+},
+//#define W25Q32			0x00EF4016
+{0x00EF4016, 0x00, SIZE2N_04MB, SIZE_064K, SIZE_004K, SIZE_256B, "W25Q32"
+#if (SPI_DRIVER_MODE == 1)
+, 104, ComSrlCmd_SE, SpiRead_1443EB, wb_spi_setQEBit, PageWrite_114032
+#else
+, 104, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#endif
+},
+//#define W25Q64                        0x00EF4017
+{0x00EF4017, 0x00, SIZE2N_08MB, SIZE_064K, SIZE_004K, SIZE_256B, "W25Q64"
+#if (SPI_DRIVER_MODE == 1)
+, 104, ComSrlCmd_SE, SpiRead_1443EB, wb_spi_setQEBit, PageWrite_114032
+#else
+, 104, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#endif
+},
+//#define W25X16			0x00EF3015
+{0x00EF3015, 0x00, SIZE2N_02MB, SIZE_064K, SIZE_004K, SIZE_256B, "W25X16"
+#if (SPI_DRIVER_MODE == 1)
+, 104, ComSrlCmd_SE, SpiRead_11213B, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#else
+, 104, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#endif
+},
+//#define W25X32			0x00EF3016
+{0x00EF3016, 0x00, SIZE2N_04MB, SIZE_064K, SIZE_004K, SIZE_256B, "W25X32"
+#if (SPI_DRIVER_MODE == 1)
+, 104, ComSrlCmd_SE, SpiRead_11213B, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#else
+, 104, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#endif
+},
+//#define W25X64			0x00EF3017
+{0x00EF3016, 0x00, SIZE2N_08MB, SIZE_064K, SIZE_004K, SIZE_256B, "W25X64"
+#if (SPI_DRIVER_MODE == 1)
+, 104, ComSrlCmd_SE, SpiRead_11213B, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#else
+, 104, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#endif
+},
+/****************************************** ATMEL Flash ******************************************/
+//#define AT25DF161		0x001f4602
+{0x001f4602, 0x00, SIZE2N_02MB, SIZE_064K, SIZE_004K, SIZE_256B, "AT25DF161"
+#if (SPI_DRIVER_MODE == 1)
+, 85, ComSrlCmd_SE, SpiRead_11213B, ComSrlCmd_NoneQeBit, PageWrite_1120A2
+#else
+, 85, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#endif
+},
+/****************************************** Qingistek ******************************************/
+//#define PM25LQ032		0x007f9d46
+{0x007f9d46, 0x00, SIZE2N_04MB, SIZE_064K, SIZE_004K, SIZE_256B, "PM25LQ032"
+#if (SPI_DRIVER_MODE == 1)
+, 85, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#else
+, 85, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#endif
+},
+/****************************************** ESMT ******************************************/
+//#define PM25LQ032		0x007f9d46
+{0x008c2016, 0x00, SIZE2N_04MB, SIZE_064K, SIZE_004K, SIZE_256B, "F25L32PA-100"
+#if (SPI_DRIVER_MODE == 1)
+, 100, ComSrlCmd_SE,  SpiRead_1221BB, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#else
+, 50, ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002
+#endif
+}
+};
+
+// spi flash probe
+void spi_regist(unsigned char ucChip)
+{
+	unsigned int ui, i, uiCount;
+	unsigned char pucBuffer[4];
+
+	ui = ComSrlCmd_RDID(ucChip, 4);
+	ui = ComSrlCmd_RDID(ucChip, 4);
+	ui = ui >> 8;
+
+	uiCount = sizeof(spi_flash_registed) / sizeof(struct spi_flash_known);
+
+	for (i = 0; i < uiCount; i++)
+	{
+		if(spi_flash_registed[i].uiChipId == ui)
+		{
+			break;
+		}
+	}
+	if(i == uiCount)
+	{
+		// default setting
+		i = ui & 0xff;
+		if((i < SIZE2N_128K) || (i > SIZE2N_128M))
+		{
+			i = SIZE2N_04MB;
+		}
+		setFSCR(ucChip, 40, 1, 1, 15);
+		set_flash_info(ucChip, ui, i, SIZE_064K, SIZE_004K, SIZE_256B, "UNKNOWN", ComSrlCmd_SE,  SpiRead_11110B, ComSrlCmd_NoneQeBit,  PageWrite_111002, 40);
+	}
+	else
+	{
+		// have registed
+		setFSCR(ucChip, spi_flash_registed[i].chipClock, 1, 1, 15);
+		set_flash_info(ucChip, ui, spi_flash_registed[i].uiCapacityId, spi_flash_registed[i].uiBlockSize, spi_flash_registed[i].uiSectorSize, spi_flash_registed[i].uiPageSize, spi_flash_registed[i].pcChipName, spi_flash_registed[i].pfErase, spi_flash_registed[i].pfRead, spi_flash_registed[i].pfQeBit, spi_flash_registed[i].pfPageWrite, spi_flash_registed[i].chipClock);
+	}
+	spi_flash_info[ucChip].pfQeBit(ucChip);
+	prnFlashInfo(ucChip, spi_flash_info[ucChip]);
+	ui = spi_flash_info[ucChip].pfRead(ucChip, 0x00, 4, pucBuffer);
+#if (MTD_SPI_TEST_CHIP == 1)
+	ui = test_spi_flash(ucChip);
+#endif
+	LDEBUG("spi_regist: ucChip=%x; i=%x; uiCount=%x\n", ucChip, i, uiCount);
+}
+// set spi_flash_info struction content
+void set_flash_info(unsigned char ucChip, unsigned int chip_id, unsigned int device_cap, unsigned int block_size, unsigned int sector_size, unsigned int page_size, char* chip_name, FUNC_ERASE pfErase, FUNC_READ pfRead, FUNC_SETQEBIT pfQeBit, FUNC_PAGEWRITE pfPageWrite, unsigned int chipClock)
+{
+	unsigned int ui = 1 << device_cap;
+	spi_flash_info[ucChip].chip_id = chip_id;
+	spi_flash_info[ucChip].mfr_id = (chip_id >> 16) & 0xff;
+	spi_flash_info[ucChip].dev_id = (chip_id >> 8) & 0xff;
+	spi_flash_info[ucChip].capacity_id = (chip_id) & 0xff;
+	spi_flash_info[ucChip].size_shift = calShift(spi_flash_info[ucChip].capacity_id, device_cap);
+	spi_flash_info[ucChip].device_size = device_cap;			// 2 ^ N (bytes)
+	spi_flash_info[ucChip].chip_size =  ui;
+	spi_flash_info[ucChip].block_size = block_size;
+	spi_flash_info[ucChip].block_cnt = ui / block_size;
+	spi_flash_info[ucChip].sector_size = sector_size;
+	spi_flash_info[ucChip].sector_cnt = ui / sector_size;
+	spi_flash_info[ucChip].page_size = page_size;
+	spi_flash_info[ucChip].page_cnt = sector_size / page_size;
+	spi_flash_info[ucChip].chip_name = chip_name;
+	spi_flash_info[ucChip].pfErase = pfErase;
+	spi_flash_info[ucChip].pfWrite = ComSrlCmd_ComWriteData;
+	spi_flash_info[ucChip].pfRead = pfRead;
+	spi_flash_info[ucChip].pfQeBit = pfQeBit;
+	spi_flash_info[ucChip].pfPageWrite = pfPageWrite;
+	spi_flash_info[ucChip].chipClock = chipClock;
+	//SPI_REG_LOAD(SFCR2, 0x0bb08000);
+	LDEBUG("set_flash_info: ucChip=%x; chip_id=%x; device_cap=%x; block_size=%x; sector_size=%x; page_size=%x; chip_name=%s\n", ucChip, chip_id, device_cap, block_size, sector_size, page_size, chip_name);
+}
+
+/****************************** Common function ******************************/
+// get Dram Frequence
+unsigned int CheckDramFreq(void)                       //JSW:For 8196C
+{
+	unsigned short usFreqBit;
+#if defined(CONFIG_RTL8198)
+	unsigned short usFreqVal[] = {65, 181, 150, 125, 156, 168, 237, 193};
+#elif defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+	unsigned short usFreqVal[] = {156, 193, 181, 231, 212, 125, 237, 168};
+#else
+	unsigned short usFreqVal[] = {65, 78, 125, 150, 156, 168, 193, 193};
+#endif
+	usFreqBit = (0x00001C00 & (*(unsigned int*)0xb8000008)) >> 10 ;
+	LDEBUG("CheckDramFreq:usFreqVal=%dMHZ; usFreqBit=%x; B8000008=%x;\n", usFreqVal[usFreqBit], usFreqBit, (*(unsigned int*)0xb8000008));
+	NDEBUG("SDRAM CLOCK:%dMHZ\n", usFreqVal[usFreqBit]);
+	return usFreqVal[usFreqBit];
+}
+// Set FSCR register, disable this function in kernel
+void setFSCR(unsigned char ucChip, unsigned int uiClkMhz, unsigned int uiRBO, unsigned int uiWBO, unsigned int uiTCS)
+{
+#ifndef SPI_KERNEL
+	unsigned int ui, uiClk;
+	uiClk = CheckDramFreq();
+#ifdef CONFIG_AUTO_PROBE_LIMITED_SPI_CLK_UNDER_40MHZ
+	uiClkMhz = 40;
+#endif
+	ui = uiClk / uiClkMhz;
+	if((uiClk % uiClkMhz) > 0)
+	{
+		ui = ui + 1;
+	}
+	if((ui % 2) > 0)
+	{
+		ui = ui + 1;
+	}
+	spi_flash_info[ucChip].chip_clk = uiClk / ui;
+	SPI_REG_LOAD(SFCR, SFCR_SPI_CLK_DIV((ui-2)/2) | SFCR_RBO(uiRBO) | SFCR_WBO(uiWBO) | SFCR_SPI_TCS(uiTCS));
+	LDEBUG("setFSCR:uiClkMhz=%d, uiRBO=%d, uiWBO=%d, uiTCS=%d, resMhz=%d, vale=%8x\n", uiClkMhz, uiRBO, uiWBO, uiTCS, spi_flash_info[ucChip].chip_clk, SPI_REG_READ(SFCR));
+#endif
+}
+// Calculate write address group
+void calAddr(unsigned int uiStart, unsigned int uiLenth, unsigned int uiSectorSize, unsigned int* uiStartAddr, unsigned int*  uiStartLen, unsigned int* uiSectorAddr, unsigned int* uiSectorCount, unsigned int* uiEndAddr, unsigned int* uiEndLen)
+{
+	unsigned int ui;
+	// only one sector
+	if ((uiStart + uiLenth) < ((uiStart / uiSectorSize + 1) * uiSectorSize))
+	{	// start	
+		*uiStartAddr = uiStart;
+		*uiStartLen = uiLenth;
+		//middle
+		*uiSectorAddr = 0x00;
+		*uiSectorCount = 0x00;
+		// end
+		*uiEndAddr = 0x00;
+		*uiEndLen = 0x00;
+	}
+	//more then one sector
+	else
+	{
+		// start
+		*uiStartAddr = uiStart;
+		*uiStartLen = uiSectorSize - (uiStart % uiSectorSize);
+		if(*uiStartLen == uiSectorSize)
+		{
+			*uiStartLen = 0x00;
+		}
+		// middle
+		ui = uiLenth - *uiStartLen;
+		*uiSectorAddr = *uiStartAddr + *uiStartLen;
+		*uiSectorCount = ui / uiSectorSize;
+		//end
+		*uiEndAddr = *uiSectorAddr + (*uiSectorCount * uiSectorSize);
+		*uiEndLen = ui % uiSectorSize;
+	}
+	LDEBUG("calAddr:uiStart=%x; uiSectorSize=%x; uiLenth=%x;-> uiStartAddr=%x; uiStartLen=%x; uiSectorAddr=%x; uiSectorCount=%x; uiEndAddr=%x; uiEndLen=%x;\n",uiStart, uiSectorSize, uiLenth, *uiStartAddr, *uiStartLen, *uiSectorAddr, *uiSectorCount, *uiEndAddr, *uiEndLen);	
+}
+// Calculate chip capacity shift bit 
+unsigned char calShift(unsigned char ucCapacityId, unsigned char ucChipSize)
+{
+	unsigned int ui;
+	if(ucChipSize > ucCapacityId)
+	{
+		ui = ucChipSize - ucCapacityId;
+	}
+	else
+	{
+		ui = ucChipSize + 0x100 -ucCapacityId;
+	}
+	LDEBUG("calShift: ucCapacityId=%x; ucChipSize=%x; ucReturnVal=%x\n", ucCapacityId, ucChipSize, ui);
+	return (unsigned char)ui;	
+}
+// Print spi_flash_type
+void prnFlashInfo(unsigned char ucChip, struct spi_flash_type sftInfo)
+{
+#if (SPI_DRIVER_MODE == 1)
+	NDEBUG(" ========================= Registed SPI Flash Model ========================= \n");
+	NDEBUG("|No chipID  Sft chipSize blkSize secSize pageSize sdCk opCk      chipName    |\n");
+	NDEBUG("|%2d %6xh %2xh %7xh %6xh %6xh %7xh %4d %4d %17s|\n", ucChip, sftInfo.chip_id, sftInfo.size_shift, sftInfo.chip_size, sftInfo.block_size, sftInfo.sector_size, sftInfo.page_size, sftInfo.chipClock, sftInfo.chip_clk, sftInfo.chip_name);
+	////////1111 2222 3333 4444 5555 6666 7777 8888 9999 aaaa
+	NDEBUG(" ============================================================================ \n");
+#else
+	NDEBUG(" ------------------------- Force into Single IO Mode ------------------------ \n");
+	NDEBUG("|No chipID  Sft chipSize blkSize secSize pageSize sdCk opCk      chipName    |\n");
+	NDEBUG("|%2d %6xh %2xh %7xh %6xh %6xh %7xh %4d %4d %17s|\n", ucChip, sftInfo.chip_id, sftInfo.size_shift, sftInfo.chip_size, sftInfo.block_size, sftInfo.sector_size, sftInfo.page_size, sftInfo.chipClock, sftInfo.chip_clk, sftInfo.chip_name);
+	////////1111 2222 3333 4444 5555 6666 7777 8888 9999 aaaa
+	NDEBUG(" ---------------------------------------------------------------------------- \n");
+#endif
+}
+
+// Check WIP bit
+unsigned int spiFlashReady(unsigned char ucChip)
+{
+	unsigned int uiCount, ui;	
+	uiCount = 0;
+	while (1)
+	{
+		uiCount++;
+		ui = SeqCmd_Read(ucChip, IOWIDTH_SINGLE, SPICMD_RDSR, 1);
+		if ((ui & (1 << SPI_STATUS_WIP)) == 0)
+		{
+			break;
+		}
+	}
+	KDEBUG("spiFlashReady: uiCount=%x\n", uiCount);	
+	return uiCount;
+}
+//toggle CS
+void rstSPIFlash(unsigned char ucChip)
+{
+	SFCSR_CS_L(ucChip, 0, IOWIDTH_SINGLE);
+	SFCSR_CS_H(ucChip, 0, IOWIDTH_SINGLE);
+	SFCSR_CS_L(ucChip, 0, IOWIDTH_SINGLE);
+	SFCSR_CS_H(ucChip, 0, IOWIDTH_SINGLE);
+	LDEBUG("rstFPIFlash: ucChip=%x;\n", ucChip);	
+}
+
+/****************************** Layer 1 ******************************/
+// set cs high
+void SFCSR_CS_L(unsigned char ucChip, unsigned char ucLen, unsigned char ucIOWidth)
+{
+	LDEBUG("SFCSR_CS_L: ucChip=%x; uiLen=%x; ucIOWidth=%x;\n", ucChip, ucLen, ucIOWidth);
+	while((*((volatile unsigned int *)SFCSR) & (SFCSR_SPI_RDY(1))) == 0);
+	//*((volatile unsigned int *)(SFCSR)) = SFCSR_SPI_CSB(1 + (ucChip)) | SFCSR_LEN(uiLen) | SFCSR_SPI_RDY(1) |  SFCSR_IO_WIDTH(ucIOWidth) | SFCSR_CHIP_SEL(0) | SFCSR_CMD_BYTE(0);
+	*((volatile unsigned int *)(SFCSR)) = SFCSR_SPI_CSB(1 + (ucChip)) | SFCSR_LEN(ucLen) | SFCSR_SPI_RDY(1) |  SFCSR_IO_WIDTH(ucIOWidth);	
+}
+// set cs low
+void SFCSR_CS_H(unsigned char ucChip, unsigned char ucLen, unsigned char ucIOWidth)
+{
+	LDEBUG("SFCSR_CS_H: ucChip=%x; uiLen=%x; ucIOWidth=%x;\n", ucChip, ucLen, ucIOWidth);
+	while((*((volatile unsigned int *)SFCSR) & (SFCSR_SPI_RDY(1))) == 0);
+	//*((volatile unsigned int *)(SFCSR)) = SFCSR_SPI_CSB(3) | SFCSR_LEN(uiLen) | SFCSR_SPI_RDY(1) |  SFCSR_IO_WIDTH(ucIOWidth) | SFCSR_CHIP_SEL(0) | SFCSR_CMD_BYTE(0);
+	*((volatile unsigned int *)(SFCSR)) = SFCSR_SPI_CSB(3) | SFCSR_LEN(ucLen) | SFCSR_SPI_RDY(1) |  SFCSR_IO_WIDTH(ucIOWidth);	
+}
+// Read Identification (RDID) Sequence (Command 9F)
+unsigned int ComSrlCmd_RDID(unsigned char ucChip, unsigned int uiLen)
+{
+	unsigned int ui;
+	SPI_REG_LOAD(SFCR, (SFCR_SPI_CLK_DIV(7) | SFCR_RBO(1) | SFCR_WBO(1) | SFCR_SPI_TCS(15)));		//SFCR default setting
+	rstSPIFlash(ucChip);
+	SFCSR_CS_L(ucChip, 0, IOWIDTH_SINGLE);
+	SPI_REG_LOAD(SFDR, SPICMD_RDID);
+	SFCSR_CS_L(ucChip, (uiLen - 1), IOWIDTH_SINGLE);
+	ui = SPI_REG_READ(SFDR);
+	SFCSR_CS_H(ucChip, 0, IOWIDTH_SINGLE);
+	LDEBUG("ComSrlCmd_RDID: ucChip=%x; uiLen=%x; returnValue=%x; SPICMD_RDID=%x;\n", ucChip, uiLen, ui, SPICMD_RDID);
+	return ui;
+}
+// One byte Command
+void SeqCmd_Order(unsigned char ucChip,  unsigned char ucIOWidth, unsigned int uiCmd)
+{
+	LDEBUG("SeqCmd_Type1: ucChip=%x; ucIOWidth=%x; SPICMD=%x;\n", ucChip, ucIOWidth, uiCmd);
+	SFCSR_CS_L(ucChip, ucIOWidth, IOWIDTH_SINGLE);
+	SPI_REG_LOAD(SFDR, uiCmd);
+	SFCSR_CS_H(ucChip, ucIOWidth, IOWIDTH_SINGLE);
+}
+// One byte Command Write
+void SeqCmd_Write(unsigned char ucChip,  unsigned char ucIOWidth, unsigned int uiCmd, unsigned int uiValue, unsigned char ucValueLen)
+{
+	SFCSR_CS_L(ucChip, DATA_LENTH1, ucIOWidth);
+	SPI_REG_LOAD(SFDR, uiCmd);
+	SFCSR_CS_L(ucChip, ucValueLen - 1, ucIOWidth);
+	SPI_REG_LOAD(SFDR, (uiValue << ((4 - ucValueLen) * 8)));
+	SFCSR_CS_H(ucChip, DATA_LENTH1, IOWIDTH_SINGLE);
+	LDEBUG("SeqCmd_Write: ucChip=%x; ucIOWidth=%x; uiCmd=%x; uiValue=%x; ucValueLen=%x;\n", ucChip, ucIOWidth, uiCmd, uiValue, ucValueLen);
+}
+// One byte Command Read
+unsigned int SeqCmd_Read(unsigned char ucChip,  unsigned char ucIOWidth, unsigned int uiCmd, unsigned char ucRDLen)
+{
+	unsigned int ui;	
+	SFCSR_CS_L(ucChip, DATA_LENTH1, ucIOWidth);
+	SPI_REG_LOAD(SFDR, uiCmd);
+	SFCSR_CS_L(ucChip, ucRDLen-1, ucIOWidth);
+	ui = SPI_REG_READ(SFDR);
+	SFCSR_CS_H(ucChip, DATA_LENTH1, ucIOWidth);
+	ui = ui >> ((4 - ucRDLen) * 8);	
+	LDEBUG("SeqCmd_Read: ucChip=%x; ucIOWidth=%x; uiCmd=%x; ucRDLen=%x; RetVal=%x\n", ucChip, ucIOWidth, uiCmd, ucRDLen, ui);
+	return ui;
+}
+
+/****************************** Layer 2 ******************************/
+// Sector Erase (SE) Sequence (Command 20)
+unsigned int ComSrlCmd_SE(unsigned char ucChip, unsigned int uiAddr)
+{
+	SeqCmd_Order(ucChip,  IOWIDTH_SINGLE, SPICMD_WREN);
+	SeqCmd_Write(ucChip,  IOWIDTH_SINGLE, SPICMD_SE, uiAddr, 3);
+	KDEBUG("ComSrlCmd_SE: ucChip=%x; uiSector=%x; uiSectorSize=%x; SPICMD_SE=%x\n", ucChip, uiAddr, spi_flash_info[ucChip].sector_size, SPICMD_SE);	
+	return spiFlashReady(ucChip);
+}
+// Block Erase (BE) Sequence (Command D8)
+unsigned int ComSrlCmd_BE(unsigned char ucChip, unsigned int uiAddr)
+{
+	SeqCmd_Order(ucChip,  IOWIDTH_SINGLE, SPICMD_WREN);
+	SeqCmd_Write(ucChip,  IOWIDTH_SINGLE, SPICMD_BE, uiAddr, 3);	
+	KDEBUG("ComSrlCmd_BE: ucChip=%x; uiBlock=%x; uiBlockSize=%x; SPICMD_BE=%x\n", ucChip, uiAddr, spi_flash_info[ucChip].block_size, SPICMD_BE);
+	return spiFlashReady(ucChip);
+}
+// Chip Erase (CE) Sequence (Command 60 or C7)
+unsigned int ComSrlCmd_CE(unsigned char ucChip)
+{
+	SeqCmd_Order(ucChip,  IOWIDTH_SINGLE, SPICMD_WREN);
+	SeqCmd_Order(ucChip,  IOWIDTH_SINGLE, SPICMD_CE);	
+	KDEBUG("ComSrlCmd_CE: ucChip=%x; SPICMD_CE=%x\n", ucChip, SPICMD_CE);
+	return spiFlashReady(ucChip);
+}
+// without QE bit
+unsigned int ComSrlCmd_NoneQeBit(unsigned char ucChip)
+{
+	KDEBUG("ComSrlCmd_NoneQeBit: ucChip=%x;\n", ucChip);
+	return 0;
+}
+// ucIsFast: = 0 cmd, address, dummy single IO ; =1 cmd single IO, address and dummy multi IO; =2 cmd, address and dummy multi IO;
+void ComSrlCmd_InputCommand(unsigned char ucChip, unsigned int uiAddr, unsigned int uiCmd, unsigned char ucIsFast, unsigned char ucIOWidth, unsigned char ucDummyCount)
+{
+	int i;
+	LDEBUG("ComSrlCmd_InputCommand: ucChip=%x; uiAddr=%x; uiCmd=%x; uiIsfast=%x; ucIOWidth=%x; ucDummyCount=%x\n", ucChip, uiAddr, uiCmd, ucIsFast, ucIOWidth, ucDummyCount);
+
+	// input command
+	if(ucIsFast == ISFAST_ALL)
+	{
+		SFCSR_CS_L(ucChip, 0, ucIOWidth);
+	}
+	else
+	{
+		SFCSR_CS_L(ucChip, 0, IOWIDTH_SINGLE);
+	}
+	SPI_REG_LOAD(SFDR, uiCmd);				// Read Command
+
+	// input 3 bytes address
+	if(ucIsFast == ISFAST_NO)
+	{
+		SFCSR_CS_L(ucChip, 0, IOWIDTH_SINGLE);
+	}
+	else
+	{
+		SFCSR_CS_L(ucChip, 0, ucIOWidth);
+	}
+	SPI_REG_LOAD(SFDR,(uiAddr << 8));
+	SPI_REG_LOAD(SFDR,(uiAddr << 16));
+	SPI_REG_LOAD(SFDR,(uiAddr << 24));
+
+	//input dummy cycle
+	for (i = 0; i < ucDummyCount; i++)
+	{
+		SPI_REG_LOAD(SFDR, 0);
+	}
+	
+	SFCSR_CS_L(ucChip, 3, ucIOWidth);
+}
+
+// Set SFCR2 for memery map read
+unsigned int SetSFCR2(unsigned int uiCmd, unsigned char ucIsFast, unsigned char ucIOWidth, unsigned char ucDummyCount)
+{
+	unsigned int ui, uiDy;
+	ucSFCR2 = 0;
+	ui = SFCR2_SFCMD(uiCmd) | SFCR2_SFSIZE(spi_flash_info[0].device_size - 17) | SFCR2_RD_OPT(0) | SFCR2_HOLD_TILL_SFDR2(0);
+	switch (ucIsFast)
+	{
+		case ISFAST_NO:
+		{
+			ui = ui | SFCR2_CMD_IO(IOWIDTH_SINGLE) | SFCR2_ADDR_IO(IOWIDTH_SINGLE) | SFCR2_DATA_IO(ucIOWidth);
+			uiDy = 1;
+			break;
+		}
+		case ISFAST_YES:
+		{
+			ui = ui | SFCR2_CMD_IO(IOWIDTH_SINGLE) | SFCR2_ADDR_IO(ucIOWidth) | SFCR2_DATA_IO(ucIOWidth);
+			uiDy = ucIOWidth * 2;
+			break;
+		}
+		case ISFAST_ALL:
+		{
+			ui = ui | SFCR2_CMD_IO(ucIOWidth) | SFCR2_ADDR_IO(ucIOWidth) | SFCR2_DATA_IO(ucIOWidth);
+			uiDy = ucIOWidth * 2;
+			break;
+		}
+		default:
+		{
+			ui = ui | SFCR2_CMD_IO(IOWIDTH_SINGLE) | SFCR2_ADDR_IO(IOWIDTH_SINGLE) | SFCR2_DATA_IO(ucIOWidth);
+			uiDy = 1;
+			break;
+		}
+	}
+	if (uiDy == 0)
+	{
+		uiDy = 1;
+	}
+	ui = ui | SFCR2_DUMMY_CYCLE((ucDummyCount * 4 / uiDy));		// ucDummyCount is Byte Count ucDummyCount*8 / (uiDy*2)
+	SPI_REG_LOAD(SFCR2, ui);
+	LDEBUG("SetSFCR2: uiCmd=%x; ucIsFast=%; ucIOWidth=%x; ucDummyCount=%x; ucSFCR2=%x; SFCR2=%x\n;", uiCmd, ucIsFast, ucIOWidth, ucDummyCount, ucSFCR2, ui);
+	return ui;	
+}
+
+// read template
+unsigned int ComSrlCmd_ComRead(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer,unsigned int uiCmd, unsigned char ucIsFast, unsigned char ucIOWidth, unsigned char ucDummyCount)
+{
+
+	unsigned int ui, uiCount, i;
+	unsigned char* puc = pucBuffer;
+	LDEBUG("ComSrlCmd_ComRead: ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x; uiCmd=%x; uiIsfast=%x; ucIOWidth=%x; ucDummyCount=%x\n", ucChip, uiAddr, uiLen, (unsigned int)pucBuffer, uiCmd, ucIsFast, ucIOWidth, ucDummyCount);
+	ComSrlCmd_InputCommand(ucChip, uiAddr, uiCmd, ucIsFast, ucIOWidth, ucDummyCount);
+	if(ucSFCR2 != 0)	// set SFCR2
+	{
+		ui = SetSFCR2((uiCmd >> 24), ucIsFast, ucIOWidth, ucDummyCount);
+	}
+
+	uiCount = uiLen / 4;							
+	for( i = 0; i< uiCount; i++)					// Read 4 bytes every time.
+	{
+		ui = SPI_REG_READ(SFDR);
+		memcpy(puc, &ui, 4);
+		puc += 4;
+	}
+
+	i = uiLen % 4;
+	if(i > 0)
+	{
+		ui = SPI_REG_READ(SFDR);					// another bytes.
+		memcpy(puc, &ui, i);
+		puc += i;
+	}
+	SFCSR_CS_H(ucChip, 0, IOWIDTH_SINGLE);
+	return uiLen;
+	
+}
+
+// write template
+unsigned int ComSrlCmd_ComWrite(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer, unsigned int uiCmd, unsigned char ucIsFast, unsigned char ucIOWidth, unsigned char ucDummyCount)
+{
+	unsigned int ui, uiCount, i;
+	unsigned char* puc = pucBuffer;
+	LDEBUG("ComSrlCmd_ComWrite: ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x; uiCmd=%x; uiIsfast=%x; ucIOWidth=%x; ucDummyCount=%x\n", ucChip, uiAddr, uiLen, (unsigned int)pucBuffer, uiCmd, ucIsFast, ucIOWidth, ucDummyCount);
+	SeqCmd_Order(ucChip,  IOWIDTH_SINGLE, SPICMD_WREN);
+
+	ComSrlCmd_InputCommand(ucChip, uiAddr, uiCmd, ucIsFast, ucIOWidth, ucDummyCount);
+
+	uiCount = uiLen / 4;
+	for (i = 0; i <  uiCount; i++)
+	{
+		memcpy(&ui, puc, 4);
+		puc += 4;
+		SPI_REG_LOAD(SFDR, ui);
+	}
+
+	i = uiLen % 4;
+	if(i > 0)
+	{
+		memcpy(&ui, puc, i);
+		puc += i;
+		SFCSR_CS_L(ucChip, i-1, ucIOWidth);
+		SPI_REG_LOAD(SFDR, ui);
+	}
+	SFCSR_CS_H(ucChip, 0, IOWIDTH_SINGLE);
+	ui = spiFlashReady(ucChip);
+	return uiLen;
+}
+
+// write a whole sector once
+unsigned int ComSrlCmd_ComWriteSector(unsigned char ucChip, unsigned int uiAddr, unsigned char* pucBuffer)
+{
+	unsigned int i, ui;
+	unsigned char* puc = pucBuffer;
+	LDEBUG("ComSrlCmd_ComWriteSector: ucChip=%x; uiAddr=%x; pucBuffer=%x; returnValue=%x;\n", ucChip, uiAddr, (unsigned int)pucBuffer, spi_flash_info[ucChip].sector_size);
+	//prnDispAddr(uiAddr);
+	NDEBUG(".");
+	ui = spi_flash_info[ucChip].pfErase(ucChip, uiAddr);
+	for (i = 0; i < spi_flash_info[ucChip].page_cnt; i++)
+	{
+		ui = spi_flash_info[ucChip].pfPageWrite(ucChip, uiAddr, spi_flash_info[ucChip].page_size, puc);
+		uiAddr += spi_flash_info[ucChip].page_size;
+		puc += spi_flash_info[ucChip].page_size;
+	}
+	return spi_flash_info[ucChip].sector_size;
+}
+
+// write sector use malloc buffer
+unsigned int ComSrlCmd_BufWriteSector(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer)
+{
+	unsigned char pucSector[spi_flash_info[ucChip].sector_size];
+	unsigned int ui, uiStartAddr, uiOffset;
+	LDEBUG("ComSrlCmd_BufWriteSector:ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x;\n", ucChip, uiAddr, uiLen, pucBuffer);
+	uiOffset = uiAddr % spi_flash_info[ucChip].sector_size;
+	uiStartAddr = uiAddr - uiOffset;
+	// get
+	ui = spi_flash_info[ucChip].pfRead(ucChip, uiStartAddr, spi_flash_info[ucChip].sector_size, pucSector);
+	// modify
+	memcpy(pucSector + uiOffset, pucBuffer, uiLen);
+	//write back
+	ui = ComSrlCmd_ComWriteSector(ucChip, uiStartAddr, pucSector);
+	return ui;
+}
+
+// write data, any address any lenth
+unsigned int ComSrlCmd_ComWriteData(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer)
+{
+	unsigned int uiStartAddr, uiStartLen, uiSectorAddr, uiSectorCount, uiEndAddr, uiEndLen, i;
+	unsigned char* puc = pucBuffer;
+	LDEBUG("ComSrlCmd_ComWriteData:ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x\n", ucChip, uiAddr, uiLen, (unsigned int)pucBuffer);
+	calAddr(uiAddr, uiLen, spi_flash_info[ucChip].sector_size, &uiStartAddr, &uiStartLen, &uiSectorAddr, &uiSectorCount, &uiEndAddr, &uiEndLen);
+	if((uiSectorCount == 0x00) && (uiEndLen == 0x00))	// all data in the same sector
+	{
+		ComSrlCmd_BufWriteSector(ucChip, uiStartAddr, uiStartLen, puc);
+	}
+	else
+	{
+		if(uiStartLen > 0)
+		{
+			ComSrlCmd_BufWriteSector(ucChip, uiStartAddr, uiStartLen, puc);
+			puc += uiStartLen;
+		}
+		for(i = 0; i < uiSectorCount; i++)
+		{
+			ComSrlCmd_ComWriteSector(ucChip, uiSectorAddr, puc);
+			puc += spi_flash_info[ucChip].sector_size;
+			uiSectorAddr += spi_flash_info[ucChip].sector_size;
+		}
+		if(uiEndLen > 0)
+		{
+			ComSrlCmd_BufWriteSector(ucChip, uiEndAddr, uiEndLen, puc);
+		}
+	}
+	SeqCmd_Order(ucChip,  IOWIDTH_SINGLE, SPICMD_WRDI);
+	return uiLen;
+}
+
+/****************************** Macronix ******************************/
+// MX25L1605 MX25L3205 Read at High Speed (FAST_READ) Sequence (Command 0B)
+unsigned int  SpiRead_11110B(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer)
+{
+	KDEBUG(" SpiRead_11110B: ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x; SPICMD_FASTREAD=%x;\n", ucChip, uiAddr, uiLen, (unsigned int)pucBuffer, SPICMD_FASTREAD);
+	return ComSrlCmd_ComRead(ucChip, uiAddr, uiLen, pucBuffer, SPICMD_FASTREAD, ISFAST_NO, IOWIDTH_SINGLE, DUMMYCOUNT_1);
+}
+// Page Program (PP) Sequence (Command 02)
+unsigned int  PageWrite_111002(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer)
+{
+	KDEBUG(" PageWrite_111002: ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x; SPICMD_PP=%x;\n", ucChip, uiAddr, uiLen, (unsigned int)pucBuffer, SPICMD_PP);
+	return ComSrlCmd_ComWrite(ucChip, uiAddr, uiLen, pucBuffer, SPICMD_PP, ISFAST_NO, IOWIDTH_SINGLE, DUMMYCOUNT_0);
+}
+#if (SPI_DRIVER_MODE == 1)
+// Set quad enable bit
+unsigned int mxic_spi_setQEBit(unsigned char ucChip)
+{
+	unsigned int ui;
+	SeqCmd_Order(ucChip,  IOWIDTH_SINGLE, SPICMD_WREN);
+	ui = 1 << SPI_STATUS_QE;
+	SeqCmd_Write(ucChip, IOWIDTH_SINGLE, SPICMD_WRSR, ui, 1);
+	KDEBUG("MxicSetQEBit: ucChip=%d; statusRegister=%x; returnValue=%x\n", ucChip, SeqCmd_Read(ucChip, IOWIDTH_SINGLE, SPICMD_RDSR, 1), ui);
+	return ui;
+}
+// MX25L1605 MX25L3205 Read at Dual IO Mode Sequence (Command BB)
+unsigned int  SpiRead_1221BB(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer)
+{
+	KDEBUG(" SpiRead_1221BB: ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x; SPICMD_2READ=%x;\n", ucChip, uiAddr, uiLen, (unsigned int)pucBuffer, SPICMD_2READ);
+	return ComSrlCmd_ComRead(ucChip, uiAddr, uiLen, pucBuffer, SPICMD_2READ, ISFAST_YES, IOWIDTH_DUAL, DUMMYCOUNT_1);
+}
+// MX25L1635 MX25L3235 4 x I/O Read Mode Sequence (Command EB)
+unsigned int  SpiRead_1443EB(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer)
+{
+	KDEBUG(" SpiRead_1443EB: ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x; SPICMD_4READ=%x;\n", ucChip, uiAddr, uiLen, (unsigned int)pucBuffer, SPICMD_4READ);
+	return ComSrlCmd_ComRead(ucChip, uiAddr, uiLen, pucBuffer, SPICMD_4READ, ISFAST_YES, IOWIDTH_QUAD, DUMMYCOUNT_3);
+}
+// 4 x I/O Page Program (4PP) Sequence (Command 38)
+unsigned int  PageWrite_144038(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer)
+{
+	KDEBUG(" PageWrite_144038: ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x; SPICMD_4PP=%x;\n", ucChip, uiAddr, uiLen, (unsigned int)pucBuffer, SPICMD_4PP);
+	return ComSrlCmd_ComWrite(ucChip, uiAddr, uiLen, pucBuffer, SPICMD_4PP, ISFAST_YES, IOWIDTH_QUAD, DUMMYCOUNT_0);
+}
+#endif
+
+/****************************** SST ******************************/
+// Layer1 SST Byte-Program
+void SstComSrlCmd_BP(unsigned char ucChip, unsigned int uiAddr, unsigned char ucValue)
+{
+	unsigned int ui;
+	ui = SPICMD_PP | (uiAddr & 0x00ffffff);
+	SFCSR_CS_L(ucChip, 3, 0);
+	SPI_REG_LOAD(SFDR, ui);
+	SFCSR_CS_L(ucChip, 0, IOWIDTH_SINGLE);
+	SPI_REG_LOAD(SFDR, (ucValue<< 24));
+	SFCSR_CS_H(ucChip, 0, IOWIDTH_SINGLE);
+	LDEBUG("SstComSrlCmd_BP: ucChip=%x; uiAddr=%x; ucValue=%x; SPICMD_SST_BP=%x;\n", ucChip, uiAddr, ucValue, SPICMD_PP);
+}
+// Layer2 Sector Write Use BP Mode
+unsigned int sst_PageWrite_s1(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer)
+{
+	unsigned int i, ui;
+	unsigned char* puc = pucBuffer;
+	KDEBUG("sst_cmd_write_s1: ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x; returnValue=%x;\n", ucChip, uiAddr, uiLen, (unsigned int)pucBuffer, uiLen);
+	for (i = 0; i < uiLen; i++)
+	{
+		SeqCmd_Order(ucChip,  IOWIDTH_SINGLE, SPICMD_WREN);
+		SstComSrlCmd_BP(ucChip, uiAddr, *puc);
+		ui = spiFlashReady(ucChip);
+		puc += 1;
+		uiAddr = uiAddr + 1;
+	}
+	return uiLen;
+}
+
+/****************************** Spansion ******************************/
+// Layer2 Spansion Set QE bit
+#if (SPI_DRIVER_MODE == 1)
+unsigned int span_spi_setQEBit(unsigned char ucChip)
+{
+	unsigned int ui;
+	SeqCmd_Order(ucChip,  IOWIDTH_SINGLE, SPICMD_WREN);
+	ui = 1 << SPAN_CONF_QUAD;
+	SeqCmd_Write(ucChip, IOWIDTH_SINGLE, SPICMD_WRSR, ui, 2);
+	KDEBUG("SpanSetQEBit: ucChip=%d; statusRegister=%x; returnValue=%x\n", ucChip, SeqCmd_Read(ucChip, IOWIDTH_SINGLE, SPICMD_RDSR, 2), ui);
+	return spiFlashReady(ucChip);
+}
+#endif
+
+/****************************** Winbond ******************************/
+// Layer3 Winbond Set QE Bit
+#if (SPI_DRIVER_MODE == 1)
+unsigned int wb_spi_setQEBit(unsigned char ucChip)
+{
+	unsigned int ui;
+	SeqCmd_Order(ucChip,  IOWIDTH_SINGLE, SPICMD_WREN);
+	ui = 1 << (WB_STATUS_QE - 8);
+	SeqCmd_Write(ucChip, IOWIDTH_SINGLE, SPICMD_WRSR, ui, 2);
+	KDEBUG("WBSetQEBit: ucChip=%d; statusRegister=%x; returnValue=%x\n", ucChip, SeqCmd_Read(ucChip, IOWIDTH_SINGLE, SPICMD_RDSR, 1), ui);
+	return spiFlashReady(ucChip);
+}
+// Quad Program Page Program (Command 32)
+unsigned int PageWrite_114032(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer)
+{
+	KDEBUG("PageWrite_114032: ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x; SPICMD_WB_QPP=%x;\n", ucChip, uiAddr, uiLen, (unsigned int)pucBuffer, SPICMD_WB_QPP);
+	return ComSrlCmd_ComWrite(ucChip, uiAddr, uiLen, pucBuffer, SPICMD_WB_QPP, ISFAST_NO, IOWIDTH_QUAD, DUMMYCOUNT_0);
+}
+#endif
+
+/****************************** Giga Device ******************************/
+// Set quad enable bit
+#if (SPI_DRIVER_MODE == 1)
+unsigned int gd_spi_setQEBit(unsigned char ucChip)
+{
+	unsigned int ui;
+	SeqCmd_Order(ucChip,  IOWIDTH_SINGLE, SPICMD_WREN);
+	ui = 1 << (GD_STATUS_QE - 8);
+	SeqCmd_Write(ucChip, IOWIDTH_SINGLE, SPICMD_WRSR, ui, 2);	// set Giga Devcie QE bit
+	KDEBUG("gd_spi_setQEBit: ucChip=%d; statusRegister=%x; returnValue=%x\n", ucChip, SeqCmd_Read(ucChip, IOWIDTH_SINGLE, SPICMD_RDSR, 2));
+	GdCmdSrl_HPM(ucChip);
+	return ui;
+}
+// High Performance Mode (HPM) (A3H)
+unsigned int GdCmdSrl_HPM(unsigned char ucChip)
+{
+	SeqCmd_Write(ucChip,  IOWIDTH_SINGLE, SPICMD_GD_HPM, 0x00, 3);	// command add 3 dummy
+	KDEBUG("GdCmdSrl_HPM: ucChip=%d; SPICMD_GD_HPM=%x; \n", ucChip, SPICMD_GD_HPM);
+	return spiFlashReady(ucChip);
+}
+#endif
+
+/****************************** ATMEL ******************************/
+// AT25DF161 Dual-Output Read Array(Command 3B)
+#if (SPI_DRIVER_MODE == 1)
+unsigned int SpiRead_11213B(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer)
+{
+	KDEBUG("SpiRead_11213B: ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x; SPICMD_AT_READ2=%x;\n", ucChip, uiAddr, uiLen, (unsigned int)pucBuffer, SPICMD_AT_READ2);
+	return ComSrlCmd_ComRead(ucChip, uiAddr, uiLen, pucBuffer, SPICMD_AT_READ2, ISFAST_NO, IOWIDTH_DUAL, DUMMYCOUNT_1);
+}
+// AT25DF161 Dual-Input Byte/Page Program(Command A2)
+unsigned int PageWrite_1120A2(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer)
+{
+	KDEBUG("PageWrite_1120A2: ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x; SPICMD_AT_PP2=%x;\n", ucChip, uiAddr, uiLen, (unsigned int)pucBuffer, SPICMD_AT_PP2);
+	return ComSrlCmd_ComWrite(ucChip, uiAddr, uiLen, pucBuffer, SPICMD_AT_PP2, ISFAST_NO, IOWIDTH_DUAL, DUMMYCOUNT_0);
+}
+#endif
+
+#if (MTD_SPI_TEST_CHIP == 1)
+unsigned int test_spi_flash(unsigned char ucChip)
+{
+	unsigned char pucSrc[0x100] = {0};
+	unsigned char pucDst[0x100] = {0};
+	unsigned int uiOffset = 0x10000;
+	unsigned int uiAddr = 0x10000;
+	unsigned int uiCount = spi_flash_info[ucChip].sector_cnt - (uiOffset) / spi_flash_info[ucChip].sector_size;
+	unsigned int uiRet = 0;
+	unsigned int uiLine = 0;
+	unsigned int uiStep = 0;
+	int i = 0, j = 0;
+	if(uiCount > 0x1f0)
+	{
+		uiStep = uiCount / 0x1f0;
+	}
+	else
+	{
+		uiStep = 1;
+	}
+	for (i = 0; i< 0x100; i++) pucSrc[i] = i;
+	NDEBUG("\nTest SPI flash: offset->0x%x, step->0x%x\n", (uiOffset - 0x80), (spi_flash_info[ucChip].sector_size * uiStep));
+	uiCount = 1;	// Delete
+	for (j = 0; j < uiCount; j += uiStep)
+	{
+		uiAddr = uiOffset + j * spi_flash_info[ucChip].sector_size - 0x80;
+		spi_flash_info[ucChip].pfWrite(ucChip, uiAddr, 0x100, pucSrc);
+		memset(pucDst, 0, 0x100);
+		spi_flash_info[ucChip].pfRead(ucChip, uiAddr, 0x100, pucDst);
+		for( i = 0; i < 0x100; i++)
+		{
+			if(pucDst[i] != pucSrc[i])
+			{
+				NDEBUG("%07x-ER", uiAddr);
+				uiRet += 1;
+				break;
+			}
+		}
+		if(i == 0x100) NDEBUG("%07x-OK", uiAddr);
+		uiLine++;
+		if(uiLine == 6)
+		{
+			NDEBUG("\n");
+			uiLine = 0;
+		}
+	}
+	NDEBUG("\nTotal Count = 0x%x; OK Count = 0x%x; Error Count = 0x%x\n", uiCount, (uiCount - uiRet), uiRet);
+	return uiRet;
+}
+#endif
diff --git a/drivers/mtd/chips/rtl819x/spi_common.h b/drivers/mtd/chips/rtl819x/spi_common.h
index c1fa7df..525ef3a 100644
--- a/drivers/mtd/chips/rtl819x/spi_common.h
+++ b/drivers/mtd/chips/rtl819x/spi_common.h
@@ -1,203 +1,209 @@
-/* SPI Flash driver
- *
- * Written by sam (sam@realtek.com)
- * 2010-05-01
- *
- */
-
-#include "../../../../include/linux/autoconf.h"
-
-#if defined(CONFIG_RTL_8198)
-	#define CONFIG_RTL8198 1
-#endif
-
-//#define CONFIG_SPI_STD_MODE 1
-//#define SPI_KERNEL 1
-#ifdef SPI_KERNEL
-	#ifdef CONFIG_RTL8198
-		#define SPI_DRIVER_MODE	0
-	#elif defined(CONFIG_RTL_8196CS)
-		#define SPI_DRIVER_MODE 0
-	#else
-		#define SPI_DRIVER_MODE	1
-	#endif
-#else
-	#ifdef CONFIG_RTL8198
-		#define SPI_DRIVER_MODE	0
-	#else
-		#ifdef CONFIG_SPI_STD_MODE
-			#define SPI_DRIVER_MODE	0
-		#else
-			#define SPI_DRIVER_MODE	1
-		#endif
-	#endif
-#endif
-
-typedef unsigned int (*FUNC_ERASE)(unsigned char ucChip, unsigned int uiAddr);
-typedef unsigned int (*FUNC_READ)(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer);
-typedef unsigned int (*FUNC_WRITE)(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer);
-typedef unsigned int (*FUNC_SETQEBIT)(unsigned char ucChip);
-typedef unsigned int (*FUNC_PAGEWRITE)(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer);
-
-struct spi_flash_type
-{
-	unsigned int	chip_id;
-	unsigned char	mfr_id;
-	unsigned char	dev_id;
-
-	unsigned char	capacity_id;
-	unsigned char	size_shift;
-
-	unsigned char	device_size;        // 2 ^ N (bytes)
-	unsigned int	chip_size;
-
-	unsigned int	block_size;
-	unsigned int	block_cnt;
-
-	unsigned int	sector_size;
-	unsigned int	sector_cnt;
-
-	unsigned int	page_size;
-	unsigned int	page_cnt;
-	unsigned int	chip_clk;
-	char*			chip_name;
-
-	unsigned int	chipClock;
-	FUNC_ERASE		pfErase;
-	FUNC_WRITE		pfWrite;
-	FUNC_READ		pfRead;
-	FUNC_SETQEBIT	pfQeBit;
-	FUNC_PAGEWRITE	pfPageWrite;
-};
-
-struct spi_flash_known
-{
-	unsigned int	uiChipId;
-	unsigned int	uiDistinguish;
-	unsigned int	uiCapacityId;
-	unsigned int	uiBlockSize;
-	unsigned int	uiSectorSize;
-	unsigned int	uiPageSize;
-	char*			pcChipName;
-	unsigned int	chipClock;
-
-	FUNC_ERASE		pfErase;
-	FUNC_READ		pfRead;
-	FUNC_SETQEBIT	pfQeBit;
-	FUNC_PAGEWRITE	pfPageWrite;
-};
-
-
-/****************************** Common0 ******************************/
-void spi_regist(unsigned char ucChip);
-void set_flash_info(unsigned char ucChip, unsigned int chip_id, unsigned int device_cap, unsigned int block_size, unsigned int sector_size, unsigned int page_size, char* chip_name, FUNC_ERASE pfErase, FUNC_READ pfRead, FUNC_SETQEBIT pfQeBit, FUNC_PAGEWRITE pfPageWrite, unsigned int chipClock);
-
-/****************************** Common ******************************/
-// get Dram Frequence
-unsigned int CheckDramFreq(void);                       //JSW:For 8196C
-// Set FSCR register
-void setFSCR(unsigned char ucChip, unsigned int uiClkMhz, unsigned int uiRBO, unsigned int uiWBO, unsigned int uiTCS);
-// Calculate write address group
-void calAddr(unsigned int uiStart, unsigned int uiLenth, unsigned int uiSectorSize, unsigned int* uiStartAddr, unsigned int*  uiStartLen, unsigned int* uiSectorAddr, unsigned int* uiSectorCount, unsigned int* uiEndAddr, unsigned int* uiEndLen);
-// Calculate chip capacity shift bit 
-unsigned char calShift(unsigned char ucCapacityId, unsigned char ucChipSize);
-// Print spi_flash_type
-void prnFlashInfo(unsigned char ucChip, struct spi_flash_type sftInfo);
-// Check WIP bit
-unsigned int spiFlashReady(unsigned char ucChip);
-//toggle CS
-void rstSPIFlash(unsigned char ucChip);
-
-/****************************** Layer 1 ******************************/
-//set cs low
-void SFCSR_CS_L(unsigned char ucChip, unsigned char ucLen, unsigned char ucIOWidth);
-// set cs high
-void SFCSR_CS_H(unsigned char ucChip, unsigned char ucLen, unsigned char ucIOWidth);
-// Read Identification (RDID) Sequence (Command 9F)
-unsigned int ComSrlCmd_RDID(unsigned char ucChip, unsigned int uiLen);
-// One byte Command
-void SeqCmd_Order(unsigned char ucChip,  unsigned char ucIOWidth, unsigned int uiCmd);
-// One byte Command Write
-void SeqCmd_Write(unsigned char ucChip,  unsigned char ucIOWidth, unsigned int uiCmd, unsigned int uiValue, unsigned char ucValueLen);
-// One byte Command Read
-unsigned int SeqCmd_Read(unsigned char ucChip,  unsigned char ucIOWidth, unsigned int uiCmd, unsigned char ucRDLen);
-
-/****************************** Layer 2 ******************************/
-// Sector Erase (SE) Sequence (Command 20)
-unsigned int ComSrlCmd_SE(unsigned char ucChip, unsigned int uiAddr);
-// Block Erase (BE) Sequence (Command D8)
-unsigned int ComSrlCmd_BE(unsigned char ucChip, unsigned int uiAddr);
-// Chip Erase (CE) Sequence (Command 60 or C7)
-unsigned int ComSrlCmd_CE(unsigned char ucChip);
-// without QE bit
-unsigned int ComSrlCmd_NoneQeBit(unsigned char ucChip);
-// uiIsFast: = 0 cmd, address, dummy single IO ; =1 cmd single IO, address and dummy multi IO; =2 cmd, address and dummy multi IO;
-void ComSrlCmd_InputCommand(unsigned char ucChip, unsigned int uiAddr, unsigned int uiCmd, unsigned char ucIsFast, unsigned char ucIOWidth, unsigned char ucDummyCount);
-// Set SFCR2 for memery map read
-unsigned int SetSFCR2(unsigned int uiCmd, unsigned char ucIsFast, unsigned char ucIOWidth, unsigned char ucDummyCount);
-// read function template
-unsigned int ComSrlCmd_ComRead(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer,unsigned int uiCmd, unsigned char ucIsFast, unsigned char ucIOWidth, unsigned char ucDummyCount);
-// write template
-unsigned int ComSrlCmd_ComWrite(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer, unsigned int uiCmd, unsigned char ucIsFast, unsigned char ucIOWidth, unsigned char ucDummyCount);
-// write a sector once
-unsigned int ComSrlCmd_ComWriteSector(unsigned char ucChip, unsigned int uiAddr, unsigned char* pucBuffer);
-// write sector use malloc buffer
-unsigned int ComSrlCmd_BufWriteSector(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer);
-// write function
-unsigned int ComSrlCmd_ComWriteData(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer);
-
-/****************************** Macronix ******************************/
-// MX25L1605 MX25L3205 Read at High Speed (FAST_READ) Sequence (Command 0B)
-unsigned int SpiRead_11110B(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer);
-// Page Program (PP) Sequence (Command 02)
-unsigned int PageWrite_111002(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer);
-
-#if (SPI_DRIVER_MODE == 1)
-// Set quad enable bit
-unsigned int mxic_spi_setQEBit(unsigned char ucChip);
-// MX25L1605 MX25L3205 Read at Dual IO Mode Sequence (Command BB)
-unsigned int SpiRead_1221BB(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer);
-// MX25L1635 MX25L3235 4 x I/O Read Mode Sequence (Command EB)
-unsigned int SpiRead_1443EB(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer);
-// 4 x I/O Page Program (4PP) Sequence (Command 38)
-unsigned int PageWrite_144038(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer);
-#endif
-
-/****************************** SST ******************************/
-// Layer1 SST Byte-Program
-void SstComSrlCmd_BP(unsigned char ucChip, unsigned int uiAddr, unsigned char ucValue);
-// Layer2 Sector Write Use BP Mode
-unsigned int sst_PageWrite_s1(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer);
-
-/****************************** Spansion ******************************/
-#if (SPI_DRIVER_MODE == 1)
-// Layer2 Spansion Set QE bit
-unsigned int span_spi_setQEBit(unsigned char ucChip);
-// Quad Page Programming (Command 32)
-unsigned int PageWrite_114032(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer);
-#endif
-
-/****************************** Winbond ******************************/
-#if (SPI_DRIVER_MODE == 1)
-// Layer3 Winbond Set QE Bit
-unsigned int wb_spi_setQEBit(unsigned char ucChip);
-#endif
-
-/****************************** Eon ******************************/
-
-
-/****************************** Giga Device ******************************/
-#if (SPI_DRIVER_MODE == 1)
-// Set quad enable bit
-unsigned int gd_spi_setQEBit(unsigned char ucChip);
-// High Performance Mode (HPM) (A3H)
-unsigned int GdCmdSrl_HPM(unsigned char ucChip);
-#endif
-
-/****************************** ATMEL ******************************/
-#if (SPI_DRIVER_MODE == 1)
-// AT25DF161 Dual-Output Read Array(Command 3B)
-unsigned int SpiRead_11213B(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer);
-// AT25DF161 Dual-Input Byte/Page Program(Command A2)
-unsigned int PageWrite_1120A2(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer);
-#endif
+/* SPI Flash driver
+ *
+ * Written by sam (sam@realtek.com)
+ * 2010-05-01
+ *
+ *
+ *  Copyright (c) 2011 Realtek Semiconductor Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include "../../../../include/linux/autoconf.h"
+
+#if defined(CONFIG_RTL_8198)
+	#define CONFIG_RTL8198 1
+#endif
+
+//#define CONFIG_SPI_STD_MODE 1
+//#define SPI_KERNEL 1
+#ifdef SPI_KERNEL
+	#if defined(CONFIG_RTL8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+		#define SPI_DRIVER_MODE	0
+	#elif defined(CONFIG_RTL_8196CS)
+		#define SPI_DRIVER_MODE 0
+	#else
+		#define SPI_DRIVER_MODE	1
+	#endif
+#else
+	#if defined(CONFIG_RTL8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+		#define SPI_DRIVER_MODE	0
+	#else
+		#ifdef CONFIG_SPI_STD_MODE
+			#define SPI_DRIVER_MODE	0
+		#else
+			#define SPI_DRIVER_MODE	1
+		#endif
+	#endif
+#endif
+
+typedef unsigned int (*FUNC_ERASE)(unsigned char ucChip, unsigned int uiAddr);
+typedef unsigned int (*FUNC_READ)(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer);
+typedef unsigned int (*FUNC_WRITE)(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer);
+typedef unsigned int (*FUNC_SETQEBIT)(unsigned char ucChip);
+typedef unsigned int (*FUNC_PAGEWRITE)(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer);
+
+struct spi_flash_type
+{
+	unsigned int	chip_id;
+	unsigned char	mfr_id;
+	unsigned char	dev_id;
+
+	unsigned char	capacity_id;
+	unsigned char	size_shift;
+
+	unsigned char	device_size;        // 2 ^ N (bytes)
+	unsigned int	chip_size;
+
+	unsigned int	block_size;
+	unsigned int	block_cnt;
+
+	unsigned int	sector_size;
+	unsigned int	sector_cnt;
+
+	unsigned int	page_size;
+	unsigned int	page_cnt;
+	unsigned int	chip_clk;
+	char*			chip_name;
+
+	unsigned int	chipClock;
+	FUNC_ERASE		pfErase;
+	FUNC_WRITE		pfWrite;
+	FUNC_READ		pfRead;
+	FUNC_SETQEBIT	pfQeBit;
+	FUNC_PAGEWRITE	pfPageWrite;
+};
+
+struct spi_flash_known
+{
+	unsigned int	uiChipId;
+	unsigned int	uiDistinguish;
+	unsigned int	uiCapacityId;
+	unsigned int	uiBlockSize;
+	unsigned int	uiSectorSize;
+	unsigned int	uiPageSize;
+	char*			pcChipName;
+	unsigned int	chipClock;
+
+	FUNC_ERASE		pfErase;
+	FUNC_READ		pfRead;
+	FUNC_SETQEBIT	pfQeBit;
+	FUNC_PAGEWRITE	pfPageWrite;
+};
+
+
+/****************************** Common0 ******************************/
+void spi_regist(unsigned char ucChip);
+void set_flash_info(unsigned char ucChip, unsigned int chip_id, unsigned int device_cap, unsigned int block_size, unsigned int sector_size, unsigned int page_size, char* chip_name, FUNC_ERASE pfErase, FUNC_READ pfRead, FUNC_SETQEBIT pfQeBit, FUNC_PAGEWRITE pfPageWrite, unsigned int chipClock);
+
+/****************************** Common ******************************/
+// get Dram Frequence
+unsigned int CheckDramFreq(void);                       //JSW:For 8196C
+// Set FSCR register
+void setFSCR(unsigned char ucChip, unsigned int uiClkMhz, unsigned int uiRBO, unsigned int uiWBO, unsigned int uiTCS);
+// Calculate write address group
+void calAddr(unsigned int uiStart, unsigned int uiLenth, unsigned int uiSectorSize, unsigned int* uiStartAddr, unsigned int*  uiStartLen, unsigned int* uiSectorAddr, unsigned int* uiSectorCount, unsigned int* uiEndAddr, unsigned int* uiEndLen);
+// Calculate chip capacity shift bit 
+unsigned char calShift(unsigned char ucCapacityId, unsigned char ucChipSize);
+// Print spi_flash_type
+void prnFlashInfo(unsigned char ucChip, struct spi_flash_type sftInfo);
+// Check WIP bit
+unsigned int spiFlashReady(unsigned char ucChip);
+//toggle CS
+void rstSPIFlash(unsigned char ucChip);
+
+/****************************** Layer 1 ******************************/
+//set cs low
+void SFCSR_CS_L(unsigned char ucChip, unsigned char ucLen, unsigned char ucIOWidth);
+// set cs high
+void SFCSR_CS_H(unsigned char ucChip, unsigned char ucLen, unsigned char ucIOWidth);
+// Read Identification (RDID) Sequence (Command 9F)
+unsigned int ComSrlCmd_RDID(unsigned char ucChip, unsigned int uiLen);
+// One byte Command
+void SeqCmd_Order(unsigned char ucChip,  unsigned char ucIOWidth, unsigned int uiCmd);
+// One byte Command Write
+void SeqCmd_Write(unsigned char ucChip,  unsigned char ucIOWidth, unsigned int uiCmd, unsigned int uiValue, unsigned char ucValueLen);
+// One byte Command Read
+unsigned int SeqCmd_Read(unsigned char ucChip,  unsigned char ucIOWidth, unsigned int uiCmd, unsigned char ucRDLen);
+
+/****************************** Layer 2 ******************************/
+// Sector Erase (SE) Sequence (Command 20)
+unsigned int ComSrlCmd_SE(unsigned char ucChip, unsigned int uiAddr);
+// Block Erase (BE) Sequence (Command D8)
+unsigned int ComSrlCmd_BE(unsigned char ucChip, unsigned int uiAddr);
+// Chip Erase (CE) Sequence (Command 60 or C7)
+unsigned int ComSrlCmd_CE(unsigned char ucChip);
+// without QE bit
+unsigned int ComSrlCmd_NoneQeBit(unsigned char ucChip);
+// uiIsFast: = 0 cmd, address, dummy single IO ; =1 cmd single IO, address and dummy multi IO; =2 cmd, address and dummy multi IO;
+void ComSrlCmd_InputCommand(unsigned char ucChip, unsigned int uiAddr, unsigned int uiCmd, unsigned char ucIsFast, unsigned char ucIOWidth, unsigned char ucDummyCount);
+// Set SFCR2 for memery map read
+unsigned int SetSFCR2(unsigned int uiCmd, unsigned char ucIsFast, unsigned char ucIOWidth, unsigned char ucDummyCount);
+// read function template
+unsigned int ComSrlCmd_ComRead(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer,unsigned int uiCmd, unsigned char ucIsFast, unsigned char ucIOWidth, unsigned char ucDummyCount);
+// write template
+unsigned int ComSrlCmd_ComWrite(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer, unsigned int uiCmd, unsigned char ucIsFast, unsigned char ucIOWidth, unsigned char ucDummyCount);
+// write a sector once
+unsigned int ComSrlCmd_ComWriteSector(unsigned char ucChip, unsigned int uiAddr, unsigned char* pucBuffer);
+// write sector use malloc buffer
+unsigned int ComSrlCmd_BufWriteSector(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer);
+// write function
+unsigned int ComSrlCmd_ComWriteData(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer);
+
+/****************************** Macronix ******************************/
+// MX25L1605 MX25L3205 Read at High Speed (FAST_READ) Sequence (Command 0B)
+unsigned int SpiRead_11110B(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer);
+// Page Program (PP) Sequence (Command 02)
+unsigned int PageWrite_111002(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer);
+
+#if (SPI_DRIVER_MODE == 1)
+// Set quad enable bit
+unsigned int mxic_spi_setQEBit(unsigned char ucChip);
+// MX25L1605 MX25L3205 Read at Dual IO Mode Sequence (Command BB)
+unsigned int SpiRead_1221BB(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer);
+// MX25L1635 MX25L3235 4 x I/O Read Mode Sequence (Command EB)
+unsigned int SpiRead_1443EB(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer);
+// 4 x I/O Page Program (4PP) Sequence (Command 38)
+unsigned int PageWrite_144038(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer);
+#endif
+
+/****************************** SST ******************************/
+// Layer1 SST Byte-Program
+void SstComSrlCmd_BP(unsigned char ucChip, unsigned int uiAddr, unsigned char ucValue);
+// Layer2 Sector Write Use BP Mode
+unsigned int sst_PageWrite_s1(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer);
+
+/****************************** Spansion ******************************/
+#if (SPI_DRIVER_MODE == 1)
+// Layer2 Spansion Set QE bit
+unsigned int span_spi_setQEBit(unsigned char ucChip);
+// Quad Page Programming (Command 32)
+unsigned int PageWrite_114032(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer);
+#endif
+
+/****************************** Winbond ******************************/
+#if (SPI_DRIVER_MODE == 1)
+// Layer3 Winbond Set QE Bit
+unsigned int wb_spi_setQEBit(unsigned char ucChip);
+#endif
+
+/****************************** Eon ******************************/
+
+
+/****************************** Giga Device ******************************/
+#if (SPI_DRIVER_MODE == 1)
+// Set quad enable bit
+unsigned int gd_spi_setQEBit(unsigned char ucChip);
+// High Performance Mode (HPM) (A3H)
+unsigned int GdCmdSrl_HPM(unsigned char ucChip);
+#endif
+
+/****************************** ATMEL ******************************/
+#if (SPI_DRIVER_MODE == 1)
+// AT25DF161 Dual-Output Read Array(Command 3B)
+unsigned int SpiRead_11213B(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer);
+// AT25DF161 Dual-Input Byte/Page Program(Command A2)
+unsigned int PageWrite_1120A2(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer);
+#endif
diff --git a/drivers/mtd/chips/rtl819x/spi_flash.c b/drivers/mtd/chips/rtl819x/spi_flash.c
index 6f21f79..13b803c 100644
--- a/drivers/mtd/chips/rtl819x/spi_flash.c
+++ b/drivers/mtd/chips/rtl819x/spi_flash.c
@@ -1,146 +1,154 @@
-#include <linux/config.h>
-#include <linux/mtd/map.h>
-#include <linux/mtd/gen_probe.h>
-#include <linux/spinlock.h>
-
-#include "spi_flash.h"
-#include "spi_common.h"
-
-#define MTD_SPI_DEBUG 0
-#if (MTD_SPI_DEBUG)
-#define KDEBUG(args...) printk(args)
-#else
-#define KDEBUG(args...)
-#endif
-
-struct spi_chip_mtd spi_probe_mtd;
-extern struct spi_flash_type spi_flash_info[2];
-
-// uiAddr = from; pucBuffer = to; uiLen = size
-static unsigned int do_spi_read(unsigned int from, unsigned int to, unsigned int size, unsigned int uiChip)
-{
-	unsigned int uiRet;
-	uiRet = spi_flash_info[uiChip].pfRead(uiChip, from, size, (unsigned char*)to);
-	KDEBUG("do_spi_read: from=%x; to=%x; size=%x; uiRet=%x\n", from, to, size, uiRet);
-	return 0;
-}
-/*
-// uiAddr = to; pucBuffer = from; uiLen = size
-static unsigned int do_spi_write(unsigned int  from, unsigned int  to, unsigned int  size)
-{
-	unsigned int uiRet;
-	uiRet = spi_flash_info[0].pfWrite(0, to, size, (unsigned char*)from);
-	KDEBUG("do_spi_write: from=%x; to=%x; size=%x; uiRet=%x\n", from, to, size, uiRet);
-	return 0;
-}
-*/
-// uiAddr = to; pucBuffer = from; uiLen = size (stupid!!!)
-static unsigned int do_spi_write(unsigned int from, unsigned int to, unsigned int size, unsigned int uiChip)
-{
-	unsigned int uiStartAddr, uiStartLen, uiPageAddr, uiPageCount, uiEndAddr, uiEndLen, i, uiRet;
-	unsigned char* puc = (unsigned char*)from;
-	KDEBUG("do_spi_write:from=%x; to=%x; size=%x;\n", from, to, size);
-	calAddr(to, size, spi_flash_info[uiChip].page_size, &uiStartAddr, &uiStartLen, &uiPageAddr, &uiPageCount, &uiEndAddr, &uiEndLen);
-	if((uiPageCount == 0x00) && (uiEndLen == 0x00))	// all data in the same page
-	{
-		uiRet = spi_flash_info[uiChip].pfPageWrite(uiChip, uiStartAddr, uiStartLen, puc);
-	}
-	else
-	{
-		if(uiStartLen > 0)
-		{
-			uiRet = spi_flash_info[uiChip].pfPageWrite(uiChip, uiStartAddr, uiStartLen, puc);
-			puc += uiStartLen;
-		}
-		for(i = 0; i < uiPageCount; i++)
-		{
-			uiRet = spi_flash_info[uiChip].pfPageWrite(uiChip, uiPageAddr, spi_flash_info[uiChip].page_size, puc);
-			puc += spi_flash_info[uiChip].page_size;
-			uiPageAddr += spi_flash_info[uiChip].page_size;
-		}
-		if(uiEndLen > 0)
-		{
-			uiRet = spi_flash_info[uiChip].pfPageWrite(uiChip, uiEndAddr, uiEndLen, puc);
-		}
-	}
-	//ComSrlCmd_WRDI(0);
-	return 0;
-}
-// uiAddr = addr
-static int do_spi_erase(unsigned int  addr, unsigned int uiChip)
-{
-	unsigned int uiRet;
-	uiRet = spi_flash_info[uiChip].pfErase(uiChip, addr);
-	KDEBUG("do_spi_erase: addr=%x;\n", addr);
-	return 0;
-}
-// SPI flash destroy
-static void spi_suzaku_destroy(struct spi_chip_info *chip_info)
-{
-	KDEBUG("spi_suzaku_destroy:\n");
-	return;
-}
-
-// SPI flash probe
-int spi_cp_probe(unsigned int uiChip)
-{
-	spi_regist(uiChip);
-	
-	spi_probe_mtd.chip_id = spi_flash_info[uiChip].chip_id;
-	spi_probe_mtd.extra_id = spi_flash_info[uiChip].dev_id;
-	spi_probe_mtd.sectorSize = spi_flash_info[uiChip].sector_size;
-	spi_probe_mtd.deviceSize = spi_flash_info[uiChip].chip_size;
-	spi_probe_mtd.uiClkMhz = 0;
-	spi_probe_mtd.name = spi_flash_info[uiChip].chip_name;
-
-	KDEBUG("spi_cp_probe:uiChip=%x\n", uiChip);
-	return 0;
-}
-
-// malloc mtd
-static struct spi_chip_info *spi_suzaku_setup(struct map_info *map)
-{
-	struct spi_chip_info *chip_info;
-	chip_info = kmalloc(sizeof(*chip_info), GFP_KERNEL);
-	if (!chip_info)
-	{
-		printk(KERN_WARNING "Failed to allocate memory for MTD device\n");
-		return NULL;
-	}
-	memset(chip_info, 0, sizeof(struct spi_chip_info));
-	KDEBUG("spi_suzaku_setup\n");
-	return chip_info;
-}
-
-
-struct spi_chip_info *spi_probe_flash_chip(struct map_info *map, struct chip_probe *cp)
-{
-	struct spi_chip_info *chip_info = NULL;
-	unsigned int chip_select=0; // 0 or 1
-
-	if (!strcmp(cp->name,"SPI2"))
-		chip_select=1;
-	
-	spi_cp_probe(chip_select);
-	chip_info = spi_suzaku_setup(map);
-	KDEBUG("spi_probe_flash_chip\n");
-	if (chip_info) 
-	{
-		chip_info->name = cp->name;
-		chip_info->chip_select = chip_select;
-		chip_info->flash	= &spi_probe_mtd;
-		chip_info->destroy	= spi_suzaku_destroy; 
-	 	chip_info->read		= do_spi_read;
-		chip_info->write	= do_spi_write;
-		chip_info->erase	= do_spi_erase;
-		return chip_info;
-	}
-	else
-	{
-		return NULL;
-	}
-}
-
-EXPORT_SYMBOL(spi_probe_flash_chip);
-
-
+/*
+ *
+ *  Copyright (c) 2011 Realtek Semiconductor Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+#include <linux/config.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/gen_probe.h>
+#include <linux/spinlock.h>
+
+#include "spi_flash.h"
+#include "spi_common.h"
+
+#define MTD_SPI_DEBUG 0
+#if (MTD_SPI_DEBUG)
+#define KDEBUG(args...) printk(args)
+#else
+#define KDEBUG(args...)
+#endif
+
+struct spi_chip_mtd spi_probe_mtd;
+extern struct spi_flash_type spi_flash_info[2];
+
+// uiAddr = from; pucBuffer = to; uiLen = size
+static unsigned int do_spi_read(unsigned int from, unsigned int to, unsigned int size, unsigned int uiChip)
+{
+	unsigned int uiRet;
+	uiRet = spi_flash_info[uiChip].pfRead(uiChip, from, size, (unsigned char*)to);
+	KDEBUG("do_spi_read: from=%x; to=%x; size=%x; uiRet=%x\n", from, to, size, uiRet);
+	return 0;
+}
+/*
+// uiAddr = to; pucBuffer = from; uiLen = size
+static unsigned int do_spi_write(unsigned int  from, unsigned int  to, unsigned int  size)
+{
+	unsigned int uiRet;
+	uiRet = spi_flash_info[0].pfWrite(0, to, size, (unsigned char*)from);
+	KDEBUG("do_spi_write: from=%x; to=%x; size=%x; uiRet=%x\n", from, to, size, uiRet);
+	return 0;
+}
+*/
+// uiAddr = to; pucBuffer = from; uiLen = size (stupid!!!)
+static unsigned int do_spi_write(unsigned int from, unsigned int to, unsigned int size, unsigned int uiChip)
+{
+	unsigned int uiStartAddr, uiStartLen, uiPageAddr, uiPageCount, uiEndAddr, uiEndLen, i, uiRet;
+	unsigned char* puc = (unsigned char*)from;
+	KDEBUG("do_spi_write:from=%x; to=%x; size=%x;\n", from, to, size);
+	calAddr(to, size, spi_flash_info[uiChip].page_size, &uiStartAddr, &uiStartLen, &uiPageAddr, &uiPageCount, &uiEndAddr, &uiEndLen);
+	if((uiPageCount == 0x00) && (uiEndLen == 0x00))	// all data in the same page
+	{
+		uiRet = spi_flash_info[uiChip].pfPageWrite(uiChip, uiStartAddr, uiStartLen, puc);
+	}
+	else
+	{
+		if(uiStartLen > 0)
+		{
+			uiRet = spi_flash_info[uiChip].pfPageWrite(uiChip, uiStartAddr, uiStartLen, puc);
+			puc += uiStartLen;
+		}
+		for(i = 0; i < uiPageCount; i++)
+		{
+			uiRet = spi_flash_info[uiChip].pfPageWrite(uiChip, uiPageAddr, spi_flash_info[uiChip].page_size, puc);
+			puc += spi_flash_info[uiChip].page_size;
+			uiPageAddr += spi_flash_info[uiChip].page_size;
+		}
+		if(uiEndLen > 0)
+		{
+			uiRet = spi_flash_info[uiChip].pfPageWrite(uiChip, uiEndAddr, uiEndLen, puc);
+		}
+	}
+	//ComSrlCmd_WRDI(0);
+	return 0;
+}
+// uiAddr = addr
+static int do_spi_erase(unsigned int  addr, unsigned int uiChip)
+{
+	unsigned int uiRet;
+	uiRet = spi_flash_info[uiChip].pfErase(uiChip, addr);
+	KDEBUG("do_spi_erase: addr=%x;\n", addr);
+	return 0;
+}
+// SPI flash destroy
+static void spi_suzaku_destroy(struct spi_chip_info *chip_info)
+{
+	KDEBUG("spi_suzaku_destroy:\n");
+	return;
+}
+
+// SPI flash probe
+int spi_cp_probe(unsigned int uiChip)
+{
+	spi_regist(uiChip);
+	
+	spi_probe_mtd.chip_id = spi_flash_info[uiChip].chip_id;
+	spi_probe_mtd.extra_id = spi_flash_info[uiChip].dev_id;
+	spi_probe_mtd.sectorSize = spi_flash_info[uiChip].sector_size;
+	spi_probe_mtd.deviceSize = spi_flash_info[uiChip].chip_size;
+	spi_probe_mtd.uiClkMhz = 0;
+	spi_probe_mtd.name = spi_flash_info[uiChip].chip_name;
+
+	KDEBUG("spi_cp_probe:uiChip=%x\n", uiChip);
+	return 0;
+}
+
+// malloc mtd
+static struct spi_chip_info *spi_suzaku_setup(struct map_info *map)
+{
+	struct spi_chip_info *chip_info;
+	chip_info = kmalloc(sizeof(*chip_info), GFP_KERNEL);
+	if (!chip_info)
+	{
+		printk(KERN_WARNING "Failed to allocate memory for MTD device\n");
+		return NULL;
+	}
+	memset(chip_info, 0, sizeof(struct spi_chip_info));
+	KDEBUG("spi_suzaku_setup\n");
+	return chip_info;
+}
+
+
+struct spi_chip_info *spi_probe_flash_chip(struct map_info *map, struct chip_probe *cp)
+{
+	struct spi_chip_info *chip_info = NULL;
+	unsigned int chip_select=0; // 0 or 1
+
+	if (!strcmp(cp->name,"SPI2"))
+		chip_select=1;
+	
+	spi_cp_probe(chip_select);
+	chip_info = spi_suzaku_setup(map);
+	KDEBUG("spi_probe_flash_chip\n");
+	if (chip_info) 
+	{
+		chip_info->name = cp->name;
+		chip_info->chip_select = chip_select;
+		chip_info->flash	= &spi_probe_mtd;
+		chip_info->destroy	= spi_suzaku_destroy; 
+	 	chip_info->read		= do_spi_read;
+		chip_info->write	= do_spi_write;
+		chip_info->erase	= do_spi_erase;
+		return chip_info;
+	}
+	else
+	{
+		return NULL;
+	}
+}
+
+EXPORT_SYMBOL(spi_probe_flash_chip);
+
+
diff --git a/drivers/mtd/chips/rtl819x/spi_probe.c b/drivers/mtd/chips/rtl819x/spi_probe.c
index 857a441..709c8b0 100644
--- a/drivers/mtd/chips/rtl819x/spi_probe.c
+++ b/drivers/mtd/chips/rtl819x/spi_probe.c
@@ -1,209 +1,214 @@
-/**
- *  SPI Flash probe code.
- *  (C) 2006 Atmark Techno, Inc.
- */
-
-
-#include <linux/init.h>
-#include <linux/kernel.h>
-//#include <linux/config.h>
-#include <linux/module.h>
-#include <linux/types.h>
-
-#include <linux/mtd/map.h>
-#include <linux/mtd/gen_probe.h>
-#include "spi_flash.h"
-#include <linux/autoconf.h>
-//#include "spi_common.h"
-
-#include <linux/mtd/mtd.h>
-//#define MTD_SPI_DEBUG
-#define REG32(reg)   (*(volatile unsigned int *)((unsigned int)reg))
-
-#if defined(MTD_SPI_DEBUG)
-#define KDEBUG(args...) printk(args)
-#else
-#define KDEBUG(args...)
-#endif
-
-typedef struct spi_chip_info *(spi_probe_func)(struct map_info *, struct chip_probe *);
-
-//extern spi_probe_func spi_probe_suzaku;
-struct spi_chip_info *spi_probe_flash_chip(struct map_info *map, struct chip_probe *cp);
-static spi_probe_func *probe_func[] = {
-//#if defined(CONFIG_MTD_SPI_SUZAKU) || defined(CONFIG_MTD_SPI_SUZAKU_MODULE)
-	spi_probe_flash_chip,  
-//#endif
-	NULL
-};
-
-extern int mtd_spi_erase(struct mtd_info *mtd, struct erase_info *instr);
-extern int mtd_spi_read(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
-extern int mtd_spi_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf);
-extern void mtd_spi_sync(struct mtd_info *mtd);
-extern int mtd_spi_lock(struct mtd_info *mtd, loff_t ofs, size_t len);
-extern int mtd_spi_unlock(struct mtd_info *mtd, loff_t ofs, size_t len);
-extern int mtd_spi_suspend(struct mtd_info *mtd);
-extern void mtd_spi_resume(struct mtd_info *mtd);
-
-static struct mtd_info *spi_chip_setup(struct map_info *map, struct spi_chip_info *chip_info);
-static struct mtd_info *spi_probe_chip(struct map_info *map, struct chip_probe *cp);
-
-struct mtd_info *spi_probe1(struct map_info *map);
-static void spi_destroy1(struct mtd_info *mtd);
-#ifdef CONFIG_RTL_TWO_SPI_FLASH_ENABLE
-struct mtd_info *spi_probe2(struct map_info *map);
-static void spi_destroy2(struct mtd_info *mtd);
-#endif
-
-
-
-
-static struct mtd_chip_driver spi_chipdrv1 = {
-	probe:   spi_probe1,
-	destroy: spi_destroy1,
-	name:    "flash_bank_1",
-	module:  THIS_MODULE,
-};
-#ifdef CONFIG_RTL_TWO_SPI_FLASH_ENABLE
-static struct mtd_chip_driver spi_chipdrv2 = {
-	probe:   spi_probe2,
-	destroy: spi_destroy2,
-	name:    "flash_bank_2",
-	module:  THIS_MODULE,
-};
-#endif
-static struct mtd_info *spi_chip_setup(struct map_info *map, struct spi_chip_info *chip_info)
-{
-	struct mtd_info *mtd;
-
-	mtd = kmalloc(sizeof(*mtd), GFP_KERNEL);
-	if (!mtd) {
-		printk(KERN_WARNING "Failed to allocate memory for MTD device\n");
-		return NULL;
-	}
-
-	memset(mtd, 0, sizeof(struct mtd_info));
-	
-	mtd->type                = MTD_NORFLASH;//MTD_OTHER;
-	mtd->flags               = MTD_CAP_NORFLASH;
-
-	mtd->name                = map->name;
-
-	mtd->size                = chip_info->flash->deviceSize;
-	mtd->erasesize           = chip_info->flash->sectorSize;
-
-	mtd->erase               = mtd_spi_erase;
-	mtd->read                = mtd_spi_read;
-	mtd->write               = mtd_spi_write;
-	mtd->sync                = mtd_spi_sync;
-	mtd->lock                = mtd_spi_lock;
-	mtd->unlock              = mtd_spi_unlock;
-	mtd->suspend             = mtd_spi_suspend;
-	mtd->resume              = mtd_spi_resume;
-
-	mtd->priv                = (void *)map;
-#ifdef CONFIG_RTL_TWO_SPI_FLASH_ENABLE
-	if (0 == chip_info->chip_select) map->fldrv = &spi_chipdrv1; 
-	else map->fldrv          = &spi_chipdrv2;
-#else
-	map->fldrv = &spi_chipdrv1;
-#endif
-
-	map->fldrv_priv          = chip_info;
- 	mtd->writesize 			 = 1;
-	
-	printk(KERN_INFO "SPI flash(%s) was found at CS%d, size 0x%x\n", 
-		chip_info->flash->name, chip_info->chip_select, chip_info->flash->deviceSize );
-
-	return mtd;
-}
-
-static struct mtd_info *spi_probe_chip(struct map_info *map, struct chip_probe *cp)
-{
-	struct mtd_info *mtd = NULL;
-	struct spi_chip_info *chip_info = NULL;
-	int i;
-	
-	for (i = 0; probe_func[i]; i++) {
-		chip_info = probe_func[i](map, cp);
-		if (!chip_info) continue;
-
- 		mtd = spi_chip_setup(map, chip_info);
-	
-		if (!mtd) {
-			kfree(chip_info);
-			continue;
-		}
-
-		return mtd;
-	}
-	return NULL;
-}
-
-static struct chip_probe spi_chip_probe1 = {
-	name: "SPI1",
-};
-#ifdef CONFIG_RTL_TWO_SPI_FLASH_ENABLE
-static struct chip_probe spi_chip_probe2 = {
-	name: "SPI2",
-};
-#endif
-struct mtd_info *spi_probe1(struct map_info *map)
-{
-	KDEBUG("SPI flash 1\n");
-	return spi_probe_chip(map, &spi_chip_probe1);
-}
-#ifdef CONFIG_RTL_TWO_SPI_FLASH_ENABLE
-struct mtd_info *spi_probe2(struct map_info *map)
-{
-	KDEBUG("SPI flash 2\n");
-	return spi_probe_chip(map, &spi_chip_probe2);
-}
-#endif
-static void spi_destroy1(struct mtd_info *mtd)
-{
-	KDEBUG("SPI flash 1\n");
-	struct map_info *map = (struct map_info *)mtd->priv;
-	struct spi_chip_info *chip_info = (struct spi_chip_info *)map->fldrv_priv;
-
-	if (chip_info->destroy) {
-		chip_info->destroy(chip_info);
-	}
-}
-#ifdef CONFIG_RTL_TWO_SPI_FLASH_ENABLE
-static void spi_destroy2(struct mtd_info *mtd)
-{
-	KDEBUG("SPI flash 2\n");
-	struct map_info *map = (struct map_info *)mtd->priv;
-	struct spi_chip_info *chip_info = (struct spi_chip_info *)map->fldrv_priv;
-
-	if (chip_info->destroy) {
-		chip_info->destroy(chip_info);
-	}
-}
-#endif
-int __init spi_probe_init(void)
-{
-	printk("SPI INIT\n");
-	register_mtd_chip_driver(&spi_chipdrv1);
-#ifdef CONFIG_RTL_TWO_SPI_FLASH_ENABLE
-	register_mtd_chip_driver(&spi_chipdrv2);
-#endif
-	return 0;
-}
-
-void __exit spi_probe_exit(void)
-{
-	unregister_mtd_chip_driver(&spi_chipdrv1);
-#ifdef CONFIG_RTL_TWO_SPI_FLASH_ENABLE
-	unregister_mtd_chip_driver(&spi_chipdrv2);
-#endif
-}
-
-module_init(spi_probe_init);
-module_exit(spi_probe_exit);
-
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Masahiro Nakai <nakai@atmark-techno.com> et al.");
-MODULE_DESCRIPTION("Probe code for SPI flash chips");
+/**
+ *  SPI Flash probe code.
+ *  (C) 2006 Atmark Techno, Inc.
+ *
+ *  Copyright (c) 2011 Realtek Semiconductor Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+//#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+
+#include <linux/mtd/map.h>
+#include <linux/mtd/gen_probe.h>
+#include "spi_flash.h"
+#include <linux/autoconf.h>
+//#include "spi_common.h"
+
+#include <linux/mtd/mtd.h>
+//#define MTD_SPI_DEBUG
+#define REG32(reg)   (*(volatile unsigned int *)((unsigned int)reg))
+
+#if defined(MTD_SPI_DEBUG)
+#define KDEBUG(args...) printk(args)
+#else
+#define KDEBUG(args...)
+#endif
+
+typedef struct spi_chip_info *(spi_probe_func)(struct map_info *, struct chip_probe *);
+
+//extern spi_probe_func spi_probe_suzaku;
+struct spi_chip_info *spi_probe_flash_chip(struct map_info *map, struct chip_probe *cp);
+static spi_probe_func *probe_func[] = {
+//#if defined(CONFIG_MTD_SPI_SUZAKU) || defined(CONFIG_MTD_SPI_SUZAKU_MODULE)
+	spi_probe_flash_chip,  
+//#endif
+	NULL
+};
+
+extern int mtd_spi_erase(struct mtd_info *mtd, struct erase_info *instr);
+extern int mtd_spi_read(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
+extern int mtd_spi_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf);
+extern void mtd_spi_sync(struct mtd_info *mtd);
+extern int mtd_spi_lock(struct mtd_info *mtd, loff_t ofs, size_t len);
+extern int mtd_spi_unlock(struct mtd_info *mtd, loff_t ofs, size_t len);
+extern int mtd_spi_suspend(struct mtd_info *mtd);
+extern void mtd_spi_resume(struct mtd_info *mtd);
+
+static struct mtd_info *spi_chip_setup(struct map_info *map, struct spi_chip_info *chip_info);
+static struct mtd_info *spi_probe_chip(struct map_info *map, struct chip_probe *cp);
+
+struct mtd_info *spi_probe1(struct map_info *map);
+static void spi_destroy1(struct mtd_info *mtd);
+#ifdef CONFIG_RTL_TWO_SPI_FLASH_ENABLE
+struct mtd_info *spi_probe2(struct map_info *map);
+static void spi_destroy2(struct mtd_info *mtd);
+#endif
+
+
+
+
+static struct mtd_chip_driver spi_chipdrv1 = {
+	probe:   spi_probe1,
+	destroy: spi_destroy1,
+	name:    "flash_bank_1",
+	module:  THIS_MODULE,
+};
+#ifdef CONFIG_RTL_TWO_SPI_FLASH_ENABLE
+static struct mtd_chip_driver spi_chipdrv2 = {
+	probe:   spi_probe2,
+	destroy: spi_destroy2,
+	name:    "flash_bank_2",
+	module:  THIS_MODULE,
+};
+#endif
+static struct mtd_info *spi_chip_setup(struct map_info *map, struct spi_chip_info *chip_info)
+{
+	struct mtd_info *mtd;
+
+	mtd = kmalloc(sizeof(*mtd), GFP_KERNEL);
+	if (!mtd) {
+		printk(KERN_WARNING "Failed to allocate memory for MTD device\n");
+		return NULL;
+	}
+
+	memset(mtd, 0, sizeof(struct mtd_info));
+	
+	mtd->type                = MTD_NORFLASH;//MTD_OTHER;
+	mtd->flags               = MTD_CAP_NORFLASH;
+
+	mtd->name                = map->name;
+
+	mtd->size                = chip_info->flash->deviceSize;
+	mtd->erasesize           = chip_info->flash->sectorSize;
+
+	mtd->erase               = mtd_spi_erase;
+	mtd->read                = mtd_spi_read;
+	mtd->write               = mtd_spi_write;
+	mtd->sync                = mtd_spi_sync;
+	mtd->lock                = mtd_spi_lock;
+	mtd->unlock              = mtd_spi_unlock;
+	mtd->suspend             = mtd_spi_suspend;
+	mtd->resume              = mtd_spi_resume;
+
+	mtd->priv                = (void *)map;
+#ifdef CONFIG_RTL_TWO_SPI_FLASH_ENABLE
+	if (0 == chip_info->chip_select) map->fldrv = &spi_chipdrv1; 
+	else map->fldrv          = &spi_chipdrv2;
+#else
+	map->fldrv = &spi_chipdrv1;
+#endif
+
+	map->fldrv_priv          = chip_info;
+ 	mtd->writesize 			 = 1;
+	
+	printk(KERN_INFO "SPI flash(%s) was found at CS%d, size 0x%x\n", 
+		chip_info->flash->name, chip_info->chip_select, chip_info->flash->deviceSize );
+
+	return mtd;
+}
+
+static struct mtd_info *spi_probe_chip(struct map_info *map, struct chip_probe *cp)
+{
+	struct mtd_info *mtd = NULL;
+	struct spi_chip_info *chip_info = NULL;
+	int i;
+	
+	for (i = 0; probe_func[i]; i++) {
+		chip_info = probe_func[i](map, cp);
+		if (!chip_info) continue;
+
+ 		mtd = spi_chip_setup(map, chip_info);
+	
+		if (!mtd) {
+			kfree(chip_info);
+			continue;
+		}
+
+		return mtd;
+	}
+	return NULL;
+}
+
+static struct chip_probe spi_chip_probe1 = {
+	name: "SPI1",
+};
+#ifdef CONFIG_RTL_TWO_SPI_FLASH_ENABLE
+static struct chip_probe spi_chip_probe2 = {
+	name: "SPI2",
+};
+#endif
+struct mtd_info *spi_probe1(struct map_info *map)
+{
+	KDEBUG("SPI flash 1\n");
+	return spi_probe_chip(map, &spi_chip_probe1);
+}
+#ifdef CONFIG_RTL_TWO_SPI_FLASH_ENABLE
+struct mtd_info *spi_probe2(struct map_info *map)
+{
+	KDEBUG("SPI flash 2\n");
+	return spi_probe_chip(map, &spi_chip_probe2);
+}
+#endif
+static void spi_destroy1(struct mtd_info *mtd)
+{
+	KDEBUG("SPI flash 1\n");
+	struct map_info *map = (struct map_info *)mtd->priv;
+	struct spi_chip_info *chip_info = (struct spi_chip_info *)map->fldrv_priv;
+
+	if (chip_info->destroy) {
+		chip_info->destroy(chip_info);
+	}
+}
+#ifdef CONFIG_RTL_TWO_SPI_FLASH_ENABLE
+static void spi_destroy2(struct mtd_info *mtd)
+{
+	KDEBUG("SPI flash 2\n");
+	struct map_info *map = (struct map_info *)mtd->priv;
+	struct spi_chip_info *chip_info = (struct spi_chip_info *)map->fldrv_priv;
+
+	if (chip_info->destroy) {
+		chip_info->destroy(chip_info);
+	}
+}
+#endif
+int __init spi_probe_init(void)
+{
+	printk("SPI INIT\n");
+	register_mtd_chip_driver(&spi_chipdrv1);
+#ifdef CONFIG_RTL_TWO_SPI_FLASH_ENABLE
+	register_mtd_chip_driver(&spi_chipdrv2);
+#endif
+	return 0;
+}
+
+void __exit spi_probe_exit(void)
+{
+	unregister_mtd_chip_driver(&spi_chipdrv1);
+#ifdef CONFIG_RTL_TWO_SPI_FLASH_ENABLE
+	unregister_mtd_chip_driver(&spi_chipdrv2);
+#endif
+}
+
+module_init(spi_probe_init);
+module_exit(spi_probe_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Masahiro Nakai <nakai@atmark-techno.com> et al.");
+MODULE_DESCRIPTION("Probe code for SPI flash chips");
diff --git a/drivers/mtd/devices/doc2001.c b/drivers/mtd/devices/doc2001.c
index cfde274..149bb21 100644
--- a/drivers/mtd/devices/doc2001.c
+++ b/drivers/mtd/devices/doc2001.c
@@ -38,12 +38,12 @@ extern int flash_hw_start, flash_hw_len, flash_ds_start, flash_ds_len, flash_wri
 static struct mtd_partition rtl8196_partitions[ ] = {
         {
                 name:         "boot+cfg+linux",
-                size:           (CONFIG_RTL_ROOT_IMAGE_OFFSET - 0),
+                size:           (CONFIG_RTL_ROOT_IMAGE_OFFSET-0),
                 offset:         0x00000000,
         },
         {
                 name:           "root fs",
-                   size:        (CONFIG_RTL_FLASH_SIZE - CONFIG_RTL_ROOT_IMAGE_OFFSET),
+                   size:        (CONFIG_RTL_FLASH_SIZE-CONFIG_RTL_ROOT_IMAGE_OFFSET),
                 offset:         (CONFIG_RTL_ROOT_IMAGE_OFFSET),
         }
 };
diff --git a/drivers/mtd/devices/docprobe.c b/drivers/mtd/devices/docprobe.c
index da51b6a..e87d325 100644
--- a/drivers/mtd/devices/docprobe.c
+++ b/drivers/mtd/devices/docprobe.c
@@ -634,7 +634,7 @@ static int probeChip(struct DiskOnChip *doc, struct mtd_info *mtd)
 		       "memory for MTD erase region info\n");
 		kfree(mtd);
 		return -1;
-}
+	}
 
 	for (k=0, chipsize=0; interleave>0; interleave--, chipsize+=table[i].size) {
 		for (j=0; j<table[i].numeraseregions; j++, k++) {
diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index 51f134f..da41b4f 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -3025,10 +3025,18 @@ config PPP_MPPE_MPPC
          avoid legal problems.
 
          For more information please visit http://mppe-mppc.alphacron.de
-
+ 
          To compile this driver as a module, choose M here. The module will
          be called ppp_mppe_mppc.ko.
 
+
+config PPP_IDLE_TIMEOUT_REFINE
+	tristate "PPP idle timeout refine"
+	depends on PPP
+	help
+	  skip some kinds of packets from DUT to WAN or WAN to DUT that will cause PPPoE/PPTP/L2TP idle timeout 
+          can't work well
+
 config PPPOE
 	tristate "PPP over Ethernet (EXPERIMENTAL)"
 	depends on EXPERIMENTAL && PPP
@@ -3183,5 +3191,22 @@ config VIRTIO_NET
 	  This is the virtual network driver for virtio.  It can be used with
           lguest or QEMU based VMMs (like KVM or Xen).  Say Y or M.
 
+config R8198EP
+        bool "Realtek 8198 slave pcie support"
+        ---help---
+          Say Y here if you have a Realtek 8198 slave pcie Ethernet adapter.
+
+config R8198EP_HOST
+        tristate "Host site view for slave PCIe RTL8198"
+        depends on R8198EP
+        ---help---
+          Say Y here if you have a Realtek 8198 slave pcie Ethernet adapter.
+config R8198EP_DEVICE
+        tristate "Device site view for salve PCIe RTL8198"
+        depends on R8198EP
+        ---help---
+          Say Y here if you have a Realtek 8198 slave pcie Ethernet adapter.
+
+
 source "drivers/net/rtl819x/Kconfig"
 endif # NETDEVICES
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index b214ac8..4227bae 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -277,6 +277,7 @@ obj-$(CONFIG_RTL_819X_SWCORE) += rtl819x/built-in.o
 subdir-$(CONFIG_RTL_819X_SWCORE) += rtl819x
 
 obj-$(CONFIG_RTK_VLAN_SUPPORT) += rtk_vlan.o
+obj-$(CONFIG_R8198EP) += r8198ep/
 
 #DIR_RTLASIC = $(DIR_LINUX)/drivers/net/rtl819x/
 #EXTRA_CFLAGS += -I$(DIR_RTLASIC)
diff --git a/drivers/net/ppp_generic.c b/drivers/net/ppp_generic.c
index 6a057cc..4c8bc4d 100644
--- a/drivers/net/ppp_generic.c
+++ b/drivers/net/ppp_generic.c
@@ -55,6 +55,7 @@
 #include <linux/nsproxy.h>
 #include <net/net_namespace.h>
 #include <net/netns/generic.h>
+#include <linux/icmp.h>
 
 #ifdef CONFIG_RTL_PPPOE_HWACC
 #include <linux/if_pppox.h>
@@ -1208,8 +1209,8 @@ out:
  * Network interface unit routines.
  */
  #if defined(FAST_L2TP)
-extern int fast_l2tp_to_wan(struct sk_buff *skb);
-extern int check_for_fast_l2tp_to_wan(struct sk_buff *skb);
+extern int fast_l2tp_to_wan(void *skb);
+extern int check_for_fast_l2tp_to_wan(void *skb);
 extern void event_ppp_dev_down(const char * name);
 #endif
 #if defined(FAST_PPTP) || defined(FAST_L2TP)
@@ -1252,8 +1253,8 @@ static int ppp_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		}
 		else {
 			extern int is_pptp_device(char *ppp_device);	// sync from voip customer for multiple ppp
-			extern int fast_pptp_to_wan(struct sk_buff *skb);
-			if (is_pptp_device(ppp->dev->name) && fast_pptp_to_wan(skb))	// sync from voip customer for multiple ppp
+			extern int fast_pptp_to_wan(void *skb);
+			if (is_pptp_device(ppp->dev->name) && fast_pptp_to_wan((void*)skb))	// sync from voip customer for multiple ppp
 				return 0;
 		}
 	}
@@ -1349,7 +1350,7 @@ static int ppp_start_xmit(struct sk_buff *skb, struct net_device *dev)
 #ifdef FAST_L2TP
 			skb_pull(skb,2);
 			extern int is_l2tp_device(char *ppp_device);	// sync from voip customer for multiple ppp
-			if (is_l2tp_device(ppp->dev->name) && (check_for_fast_l2tp_to_wan(skb)==1) && (fast_l2tp_to_wan(skb) == 1)) // sync from voip customer for multiple ppp
+			if (is_l2tp_device(ppp->dev->name) && (check_for_fast_l2tp_to_wan((void*)skb)==1) && (fast_l2tp_to_wan((void*)skb) == 1)) // sync from voip customer for multiple ppp
 			{
 				/* Note: if pkt go here, l2tp dial-on-demand will not be triggered,
 				so some risk exist here! -- 2010/04/25 zj */
@@ -1530,6 +1531,59 @@ pad_compress_skb(struct ppp *ppp, struct sk_buff *skb)
 #endif
 
 /*
+ * some kinds of packets from DUT to WAN will cause ppp interface active when lan==>wan traffic is off, 
+ * so we skip these packets. otherwise the ppp idletime out can't work well 
+ * return value 1 means this packet won't set the ppp to active
+ */
+#if defined(CONFIG_PPP_IDLE_TIMEOUT_REFINE)
+int timeoutCheck_skipp_pkt(struct iphdr *iph)
+{
+	
+	if(iph == NULL)
+	{
+		printk("the iphdr for PPP_IDLE_TIMEOUT_REFINE is NULL, is may cause some isses\n");
+		return 0;
+	}
+
+	if(iph->protocol == IPPROTO_ICMP)
+	{
+		struct icmphdr *icmph= (void *)iph + iph->ihl*4;
+		// we don't care dest unreacheable pkts(to wan) while recode last tx time
+		if(icmph->type==ICMP_DEST_UNREACH)
+		{
+			printk("it is ICMP dest unreacheable packet\n");
+			//if(net_ratelimit())printk("skip a icmp dest unreachable pkt from lan to wan\n");
+			return 1;
+		}
+	}
+	else if(iph->protocol == IPPROTO_TCP)
+	{
+		struct tcphdr *tcph;
+		tcph = (void *)iph + iph->ihl*4;
+		// we don't care tcp fin/rst pkts(to wan) while recode last tx time
+		if(tcph->fin || tcph->rst)
+		{
+			//if(net_ratelimit())printk("skip a tcp fin/rst pkt fin: %d rst :%d from lan to wan\n", tcph->fin, tcph->rst);
+			return 1;
+		}
+	}	
+	else if(iph->protocol == IPPROTO_IGMP)
+	{
+		// we don't care IGMP packets
+		printk("it is ICMP packet\n");
+		return 1;
+	}
+		
+	return 0;
+}
+#else //fastpath assemble code will call this function anyway.
+int timeoutCheck_skipp_pkt(struct iphdr *iph)
+{
+	return 0;
+}
+#endif
+
+/*
  * Compress and send a frame.
  * The caller should have locked the xmit path,
  * and xmit_pending should be 0.
@@ -1545,6 +1599,10 @@ static void ppp_send_frame(struct ppp *ppp, struct sk_buff *skb)
 	struct sk_buff *new_skb;
 	int len;
 	unsigned char *cp;
+#if defined(CONFIG_PPP_IDLE_TIMEOUT_REFINE)
+	struct iphdr *iphp;
+	iphp = (struct iphdr *)((unsigned char *)(skb->data+2));
+#endif
 
 	if (proto < 0x8000) {
 #ifdef CONFIG_PPP_FILTER
@@ -1568,7 +1626,10 @@ static void ppp_send_frame(struct ppp *ppp, struct sk_buff *skb)
 		skb_pull(skb, 2);
 #else
 		/* for data packets, record the time */
-		ppp->last_xmit = jiffies;
+#if defined(CONFIG_PPP_IDLE_TIMEOUT_REFINE)
+		if(timeoutCheck_skipp_pkt(iphp)!=1)
+#endif
+			ppp->last_xmit = jiffies;
 #endif /* CONFIG_PPP_FILTER */
 	}
 
@@ -1899,22 +1960,22 @@ static int ppp_mp_explode(struct ppp *ppp, struct sk_buff *skb)
 		*of the channel we are going to transmit on
 		*/
 		if (nfree > 0) {
-			if (pch->speed == 0) {
-				flen = totlen/nfree	;
-				if (nbigger > 0) {
-					flen++;
-					nbigger--;
-				}
-			} else {
-				flen = (((totfree - nzero)*(totlen + hdrlen*totfree)) /
-					((totspeed*totfree)/pch->speed)) - hdrlen;
-				if (nbigger > 0) {
-					flen += ((totfree - nzero)*pch->speed)/totspeed;
-					nbigger -= ((totfree - nzero)*pch->speed)/
+		if (pch->speed == 0) {
+			flen = totlen/nfree	;
+			if (nbigger > 0) {
+				flen++;
+				nbigger--;
+			}
+		} else {
+			flen = (((totfree - nzero)*(totlen + hdrlen*totfree)) /
+				((totspeed*totfree)/pch->speed)) - hdrlen;
+			if (nbigger > 0) {
+				flen += ((totfree - nzero)*pch->speed)/totspeed;
+				nbigger -= ((totfree - nzero)*pch->speed)/
 							totspeed;
-				}
 			}
-			nfree--;
+		}
+		nfree--;
 		}
 
 		/*
@@ -2391,7 +2452,7 @@ ppp_decompress_frame(struct ppp *ppp, struct sk_buff *skb)
             * If decompression protocol isn't MPPE/MPPC or LZS, we set
             * SC_DC_ERROR flag and wait for CCP_RESETACK
             */
-	ppp->rstate |= SC_DC_ERROR;
+           ppp->rstate |= SC_DC_ERROR;
        }
  #else
 	ppp->rstate |= SC_DC_ERROR;
diff --git a/drivers/net/pppoe.c b/drivers/net/pppoe.c
index ff42948..d015c29 100644
--- a/drivers/net/pppoe.c
+++ b/drivers/net/pppoe.c
@@ -954,7 +954,7 @@ static int __pppoe_xmit(struct sock *sk, struct sk_buff *skb)
 #if defined(CONFIG_NET_SCHED)
 	if (gQosEnabled) 
 	{
-	dev_queue_xmit(skb);
+		dev_queue_xmit(skb);
 	}
 	else
 #endif
diff --git a/drivers/net/rtk_vlan.c b/drivers/net/rtk_vlan.c
index 97b78ab..0314690 100644
--- a/drivers/net/rtk_vlan.c
+++ b/drivers/net/rtk_vlan.c
@@ -1,207 +1,508 @@
-/*
- *      Realtek VLAN handler 
- *
- *      $Id: rtk_vlan.c,v 1.5 2009/06/09 12:58:30 davidhsu Exp $
- */
- 
-#include <linux/config.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/compiler.h>
-#include <linux/netdevice.h>
-#include <linux/if_ether.h>
-#include <linux/if_vlan.h>
-#include <asm/string.h>
-#include <net/rtl/rtk_vlan.h>
-
-
-//---------------------------------------------------------------------------
-
-#if 0
-#define DEBUG_ERR(format, args...) panic_printk("%s [%s]: "format, __FUNCTION__, dev->name, ## args)
-#else
-#define DEBUG_ERR(format, args...)
-#endif
-
-
-#if 0
-#define DEBUG_TRACE(format, args...) panic_printk("%s [%s]: "format, __FUNCTION__, dev->name, ## args)
-#else
-#define DEBUG_TRACE(format, args...)
-#endif
-
-
-//---------------------------------------------------------------------------
-
-#define COPY_TAG(tag, info) { \
-	tag.f.tpid =  htons(ETH_P_8021Q); \
-	tag.f.pci = (unsigned short) (((((unsigned char)info->pri)&0x7) << 13) | \
-					((((unsigned char)info->cfi)&0x1) << 12) |((unsigned short)info->id&0xfff)); \
-	tag.f.pci =  htons(tag.f.pci);	\
-}
-
-
-#define STRIP_TAG(skb) { \
-	memmove(skb->data+VLAN_HLEN, skb->data, ETH_ALEN*2); \
-	skb_pull(skb, VLAN_HLEN); \
-}
-
-
-//---------------------------------------------------------------------------
-
-#if defined(CONFIG_RTK_VLAN_FOR_CABLE_MODEM)
-extern int rtk_vlan_support_enable;
-#endif
-
-int  rx_vlan_process(struct net_device *dev, struct vlan_info *info, struct sk_buff *skb) 
-{
-	struct vlan_tag tag;
-	unsigned short vid;
-
-	DEBUG_TRACE("==> Process Rx packet\n");
-
-	if (!info->global_vlan) {
-		DEBUG_TRACE("<== Return w/o change due to gvlan not enabled\n");
-		return 0;
-	}
-
-	memcpy(&tag, skb->data+ETH_ALEN*2, VLAN_HLEN);
-
-	// When port-vlan is disabled, discard tag packet
-	if (!info->vlan) {
-		if (tag.f.tpid == htons(ETH_P_8021Q)) {
-			DEBUG_ERR("<Drop> due to packet w/ tag!\n");
-			return 1;
-		}
-		DEBUG_TRACE("<== Return w/o change, and indicate not from vlan port enabled\n");
-		skb->tag.f.tpid = 1; // indicate this packet come from the port w/o vlan enabled
-		return 0;
-	}
-
-	// Drop all no-tag packet if port-tag is enabled
-	#if 1
-	if (info->tag && tag.f.tpid != htons(ETH_P_8021Q)) {
-		DEBUG_ERR("<Drop> due to packet w/o tag but port-tag is enabled!\n");
-		return 1;
-	}
-	#endif
-
-	if (tag.f.tpid == htons(ETH_P_8021Q)) { // tag existed in incoming packet	
-		if (info->is_lan) {	
-			// Drop all tag packets if VID is not matched
-			vid = ntohs(tag.f.pci & 0xfff);
-			if (vid != (unsigned short)info->id) {
-				DEBUG_ERR("<Drop> due to VID not matched!\n");
-				return 1;			
-			}		
-		}
-		memcpy(&skb->tag, &tag, sizeof(struct vlan_tag));
-		STRIP_TAG(skb);
-		#if	defined(CONFIG_RTL_QOS_8021P_SUPPORT)
-		skb->srcVlanPriority = ntohs(tag.f.pci>>13)&0x7;
-		#endif
-		DEBUG_ERR("<==%s(%d)   Tag [%x, vid=%d] existed in Rx packet, strip it and pass up\n", __FUNCTION__,__LINE__,
-			tag.v, (int)ntohs(tag.f.pci&0xfff));	
-	}
-	else	 {		
-		// Store port tag to skb and then pass up
-		COPY_TAG(skb->tag, info);		
-		DEBUG_TRACE("<== No tag existed, carry port tag [%x, vid=%d] and pass up\n", 
-			skb->tag.v, (int)ntohs(skb->tag.f.pci&0xfff));
-	}
-	return 0;
-}
-EXPORT_SYMBOL(rx_vlan_process);
-int  tx_vlan_process(struct net_device *dev, struct vlan_info *info, struct sk_buff *skb, int wlan_pri) 
-{
-	struct vlan_tag tag, *adding_tag;
-
-	DEBUG_TRACE("==> Process Tx packet\n");
-
-	//printk("---------%s(%d), dev(%s),skb->tag.f.tpid(0x%x)\n",__FUNCTION__,__LINE__,dev->name,skb->tag.f.tpid);
-	if (wlan_pri)
-		skb->cb[0] = '\0';		// for WMM priority
-	
-	if (!info->global_vlan) {
-		DEBUG_TRACE("<== Return w/o change due to gvlan not enabled\n");
-		return 0;
-	}
-
-	if (!info->vlan) {
-		// When port-vlan is disabled, discard packet if packet come from source port w/ vlan enabled
-		if (skb->tag.f.tpid == htons(ETH_P_8021Q)) {
-			DEBUG_ERR("<Drop> due to port-vlan is disabled but Tx packet w/o vlan enabled!\n");
-			return 1;
-		}
-		DEBUG_TRACE("<== Return w/o change because both Tx port and source vlan not enabled\n");
-		return 0;
-	}
-
-	// Discard packet if packet come from source port w/o vlan enabled except from protocol stack
-	if (skb->tag.f.tpid != 0) {
-		if (skb->tag.f.tpid != htons(ETH_P_8021Q)) {
-			DEBUG_ERR("<Drop> due to port-vlan is enabled but not from vlan enabled port!\n");
-			return 1;
-		}
-		
-		// Discard packet if its vid not matched, except it come from protocol stack or lan
-		if (info->is_lan && ntohs(skb->tag.f.pci&0xfff) != ((unsigned short)info->id)) {
-			DEBUG_ERR("<Drop> due to VID is not matched!\n");	
-			return 1;			
-		}	
-	}
-
-#if defined(CONFIG_RTK_VLAN_FOR_CABLE_MODEM)
-	if(rtk_vlan_support_enable == 1)
-#endif
-		if (!info->tag)
-		{
-			DEBUG_TRACE("<== Return w/o tagging\n");
-			if (wlan_pri) {
-				if (!info->is_lan &&  skb->tag.f.tpid == htons(ETH_P_8021Q)) 
-					skb->cb[0] = (unsigned char)((ntohs(skb->tag.f.pci)>>13)&0x7);
-				else 
-					skb->cb[0] = (unsigned char)info->pri;		
-			}		
-			return 0;		
-		}
-	
-	// Add tagging
-	if (!info->is_lan && skb->tag.f.tpid != 0) { // WAN port and not from local, add source tag
-		adding_tag = &skb->tag;
-		DEBUG_TRACE("---%s(%d) source port tagging [vid=%d]\n",__FUNCTION__,__LINE__, (int)ntohs(skb->tag.f.pci&0xfff));
-	}
-	else {			
-		adding_tag = NULL;
-		DEBUG_TRACE("---%s(%d)   Return w/ port tagging [vid=%d]\n", __FUNCTION__,__LINE__,info->id);
-	}
-
-#if defined(CONFIG_RTK_VLAN_FOR_CABLE_MODEM)
-	if(rtk_vlan_support_enable == 2 && adding_tag == NULL)
-		return 0;
-#endif
-
-	memcpy(&tag, skb->data+ETH_ALEN*2, VLAN_HLEN);	
-	if (tag.f.tpid !=  htons(ETH_P_8021Q)) { // tag not existed, insert tag
-		if (skb_headroom(skb) < VLAN_HLEN && skb_cow(skb, VLAN_HLEN) !=0 ) {		
-			printk("%s-%d: error! (skb_headroom(skb) == %d < 4). Enlarge it!\n",
-			__FUNCTION__, __LINE__, skb_headroom(skb));
-			while (1) ;
-		}
-		skb_push(skb, VLAN_HLEN);
-		memmove(skb->data, skb->data+VLAN_HLEN, ETH_ALEN*2);
-	}	
-
-	if (!adding_tag)	{ // add self-tag
-		COPY_TAG(tag, info);
-		adding_tag = &tag;		
-	}
-
-	memcpy(skb->data+ETH_ALEN*2, adding_tag, VLAN_HLEN);
-
-	if (wlan_pri) 
-		skb->cb[0] = (unsigned char)((ntohs(adding_tag->f.pci)>>13)&0x7);	
-	return 0;	
-}
-EXPORT_SYMBOL(tx_vlan_process);
-	
+/*
+ *      Realtek VLAN handler
+ *
+ *      $Id: rtk_vlan.c,v 1.5 2009/06/09 12:58:30 davidhsu Exp $
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/compiler.h>
+#include <linux/netdevice.h>
+#include <linux/if_ether.h>
+#include <linux/if_vlan.h>
+#include <asm/string.h>
+#include <net/rtl/rtk_vlan.h>
+
+
+//---------------------------------------------------------------------------
+
+#if 0
+#define DEBUG_ERR(format, args...) panic_printk("%s [%s]: "format, __FUNCTION__, dev->name, ## args)
+#else
+#define DEBUG_ERR(format, args...)
+#endif
+
+
+#if 0
+#define DEBUG_TRACE(format, args...) panic_printk("%s [%s]: "format, __FUNCTION__, dev->name, ## args)
+#else
+#define DEBUG_TRACE(format, args...)
+#endif
+
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+#define MAX_IFACE_VLAN_CONFIG 17
+#define WAN_IFACE_INDEX MAX_IFACE_VLAN_CONFIG-1
+#define VIRTUAL_IFACE_INDEX MAX_IFACE_VLAN_CONFIG-2
+static struct vlan_info_item vlan_info_items[MAX_IFACE_VLAN_CONFIG];
+static unsigned char wan_macaddr[6] = {0};
+unsigned char lan_macaddr[6] = {0};
+
+unsigned char BRCST_MAC[6] = {0xff,0xff,0xff,0xff,0xff,0xff};
+static unsigned short eth_arp = 0x0806;
+
+int is_management_packets(struct sk_buff *skb)
+{
+	/*add code to check whether skb is management pacekts*/
+	return 0;
+}
+
+
+struct net_device *rtl_get_wan_from_vlan_info(void)
+{
+	return vlan_info_items[WAN_IFACE_INDEX].dev;
+}
+
+struct net_device* rtl_get_virtual_dev_from_vlan_info(void)
+{
+	return vlan_info_items[VIRTUAL_IFACE_INDEX].dev;
+}
+struct net_device *rtl_get_dev_bridged_with_wan(void)
+{
+	int index;
+
+	for(index=0 ;index<VIRTUAL_IFACE_INDEX ; index++) {
+		if( vlan_info_items[index].info.forwarding_rule == 1 )		/*forwarding_rule = 1 means dev bridged with wan dev*/
+			return vlan_info_items[index].dev;
+	}
+
+	return NULL;
+}
+
+
+struct vlan_info_item *rtl_get_vlan_info_item_by_vid(int vid)
+{
+	struct vlan_info_item *item = NULL;
+	int index;
+
+	for(index=0; index<VIRTUAL_IFACE_INDEX; index++) {
+		item = &vlan_info_items[index];
+		if( item->dev && item->info.id == vid )
+			return item;
+	}
+
+	return NULL;
+}
+
+struct vlan_info_item *rtl_get_vlan_info_item_by_dev(struct net_device *dev)
+{
+	struct vlan_info_item *item = NULL;
+	int index;
+
+	for(index=0; index<MAX_IFACE_VLAN_CONFIG; index++) {
+		item = &vlan_info_items[index];
+		if( item->dev && (memcmp(dev->name, item->dev->name,16) == 0) ) {	// IFNAMSIZ = 16
+			DEBUG_TRACE("found in list id:%d, is LAN:%d, enable:%d\n",item->info.id,item->info.is_lan,item->info.vlan);
+			return item;
+		}
+	}
+
+	return NULL;
+}
+
+
+int rtl_add_vlan_info(struct vlan_info *info, struct net_device *dev)
+{
+	struct vlan_info_item *item = NULL;
+	int index;
+
+	if( memcmp(dev->name,"eth0",4) == 0 ){
+		memcpy(lan_macaddr, dev->dev_addr, 6);
+	}
+
+
+	if( memcmp(dev->name,"eth1",4) == 0 ){
+		item = &vlan_info_items[WAN_IFACE_INDEX];
+
+		memset(item, 0, sizeof(struct vlan_info_item));
+		memcpy(&item->info, info, sizeof(struct vlan_info));
+		item->dev = dev;
+		memcpy(wan_macaddr, dev->dev_addr, 6);
+
+		DEBUG_TRACE("WAN port vlan id:%d, is LAN:%d, fowarding:%d\n",item->info.id,item->info.is_lan,item->info.forwarding_rule);
+		return 0;
+	}
+
+	if( memcmp(dev->name,"eth7",4) == 0 ){
+		item = &vlan_info_items[VIRTUAL_IFACE_INDEX];
+
+		memset(item, 0, sizeof(struct vlan_info_item));
+		#if 0
+		for(index=0; index<VIRTUAL_IFACE_INDEX; index++) {
+			if( vlan_info_items[index].info.forwarding_rule == 1 ) {
+				memcpy(info,&vlan_info_items[index].info,sizeof(*info));
+				info = &vlan_info_items[index].info;
+				break;
+			}
+		}
+		#endif
+		memcpy(&item->info, info, sizeof(struct vlan_info));
+		item->dev = dev;
+		DEBUG_TRACE("Virtual port vlan id:%d, is LAN:%d, fowarding:%d\n",item->info.id,item->info.is_lan,item->info.forwarding_rule);
+		return 0;
+	}
+
+	if((item = rtl_get_vlan_info_item_by_dev(dev)) != NULL){
+                memcpy(&item->info, info, sizeof(struct vlan_info));
+                return 0;
+        }
+
+	for(index=0; index<MAX_IFACE_VLAN_CONFIG; index++) {
+		if( vlan_info_items[index].dev == NULL ) {
+			item = &vlan_info_items[index];
+
+			memset(item, 0, sizeof(*item));
+			memcpy(&item->info, info, sizeof(*info));
+			item->dev = dev;
+
+			DEBUG_TRACE("insert vlan id:%d, is LAN:%d, enable:%d\n",item->info.id,item->info.is_lan,item->info.vlan);
+			return 0;
+		}
+	}
+
+	if( item == NULL ) {
+		DEBUG_ERR("VLAN info. list is FULL\n");
+		return -1;
+	}
+}
+
+int rtl_delete_vlan_info(struct net_device *dev)
+{
+	struct vlan_info_item *item = NULL;
+
+	if((item = rtl_get_vlan_info_item_by_dev(dev)) != NULL){
+		memset(item, 0, sizeof(struct vlan_info_item));
+		return 0;
+	} else {
+		DEBUG_ERR("Delete dev from vlan_info_items failed\n");
+		return -1;
+	}
+}
+
+#endif
+
+
+//---------------------------------------------------------------------------
+
+
+#define COPY_TAG(tag, info) { \
+	tag.f.tpid =  htons(ETH_P_8021Q); \
+	tag.f.pci = (unsigned short) (((((unsigned char)info->pri)&0x7) << 13) | \
+					((((unsigned char)info->cfi)&0x1) << 12) |((unsigned short)info->id&0xfff)); \
+	tag.f.pci =  htons(tag.f.pci);	\
+}
+
+
+#define STRIP_TAG(skb) { \
+	memmove(skb->data+VLAN_HLEN, skb->data, ETH_ALEN*2); \
+	skb_pull(skb, VLAN_HLEN); \
+}
+
+
+//---------------------------------------------------------------------------
+
+#if defined(CONFIG_RTK_VLAN_FOR_CABLE_MODEM)
+extern int rtk_vlan_support_enable;
+#endif
+
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+int  rx_vlan_process(struct net_device *dev, struct vlan_info *info_ori, struct sk_buff *skb, struct sk_buff **new_skb)
+#else
+int  rx_vlan_process(struct net_device *dev, struct vlan_info *info, struct sk_buff *skb)
+#endif
+{
+	struct vlan_tag tag;
+	unsigned short vid;
+
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+	struct vlan_info_item *item = NULL;
+	struct vlan_info *info, info_backup;
+	memcpy(&info_backup, info_ori, sizeof(struct vlan_info)); //because may need to modify info,so create a info_backup
+	info= &info_backup;
+	if(new_skb)
+		*new_skb = NULL;
+#endif
+
+	DEBUG_TRACE("==> Process Rx packet\n");
+
+	if (!info->global_vlan) {
+		DEBUG_TRACE("<== Return w/o change due to gvlan not enabled\n");
+		return 0;
+	}
+
+	memcpy(&tag, skb->data+ETH_ALEN*2, VLAN_HLEN);
+
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+	if (info->is_lan) {
+		skb->src_info = info_ori;
+	}
+#endif
+
+	// When port-vlan is disabled, discard tag packet
+	if (!info->vlan) {
+		if (tag.f.tpid == htons(ETH_P_8021Q)) {
+			DEBUG_ERR("<Drop> due to packet w/ tag!\n");
+			return 1;
+		}
+		DEBUG_TRACE("<== Return w/o change, and indicate not from vlan port enabled\n");
+		skb->tag.f.tpid = 1; // indicate this packet come from the port w/o vlan enabled
+		return 0;
+	}
+
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+	if (!info->is_lan && (info->tag&0x1))   //wan port do not need to select tag
+	{
+		info->tag = 1;
+	}
+	else
+		info->tag = 0;
+#endif
+
+	// Drop all no-tag packet if port-tag is enabled
+	#if 1
+	if (info->tag && tag.f.tpid != htons(ETH_P_8021Q)) {
+		DEBUG_ERR("<Drop> due to packet w/o tag but port-tag is enabled!\n");
+		return 1;
+	}
+	#endif
+
+	if (tag.f.tpid == htons(ETH_P_8021Q)) { // tag existed in incoming packet
+		if (info->is_lan) {
+			// Drop all tag packets if VID is not matched
+			vid = ntohs(tag.f.pci & 0xfff);
+			DEBUG_TRACE("rx from lan!\n");
+			if (vid != (unsigned short)info->id) {
+				DEBUG_ERR("<Drop> due to VID not matched!\n");
+				return 1;
+			}
+		}
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+		else {	//wan interface
+				vid = ntohs(tag.f.pci & 0xfff);
+				item = rtl_get_vlan_info_item_by_vid(vid);
+
+				if( item ) {
+					if( item->info.forwarding_rule == 1 ){
+						skb->dev = rtl_get_virtual_dev_from_vlan_info(); //return virtual interface
+						DEBUG_TRACE("vid is bridge vid\n");
+						if(skb->dev == NULL)
+							return 1;
+					} else if ( item->info.forwarding_rule == 0 ) {
+						DEBUG_TRACE("<Drop> due to VLAN is disabled\n");
+						return 1;
+					} else {  //forwarding_rule is nat
+						DEBUG_TRACE("Recv from WAN normally\n");
+					}
+				}
+			}
+#endif
+		memcpy(&skb->tag, &tag, sizeof(struct vlan_tag));
+		STRIP_TAG(skb);
+		#if	defined(CONFIG_RTL_QOS_8021P_SUPPORT)
+		skb->srcVlanPriority = ntohs(tag.f.pci>>13)&0x7;
+		#endif
+			DEBUG_TRACE("<==%s(%d)	 Tag [vid=%d] existed in Rx packet, strip it and pass up\n", __FUNCTION__,__LINE__,
+				(int)ntohs(tag.f.pci&0xfff));
+		}
+	else	 {
+		if( info->is_lan ) {
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+			if(is_management_packets(skb)){
+				COPY_TAG(skb->tag, (&management_vlan));
+				DEBUG_TRACE("<== Management packet from lan, carry port tag [vid=%d] and pass up\n",
+					(int)ntohs(skb->tag.f.pci&0xfff));
+			}else
+#endif
+			{
+				COPY_TAG(skb->tag, info);
+				DEBUG_TRACE("<== No tag existed, carry port tag [vid=%d] and pass up\n",
+					(int)ntohs(skb->tag.f.pci&0xfff));
+			}
+		} else {
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+				if (!memcmp(wan_macaddr, skb->data, 6)){  /*unicast for nat*/
+					 if(is_management_packets(skb)){
+						COPY_TAG(skb->tag, (&management_vlan));
+						DEBUG_TRACE("<== Management packet from wan to nat, carry port tag [vid=%d] and pass up\n",
+							(int)ntohs(skb->tag.f.pci&0xfff));
+					 }
+				}else if (skb->data[0] & 0x01){  /*multicast*/
+					if (new_skb) {
+						*new_skb = skb_clone(skb, GFP_ATOMIC);
+						if (*new_skb == NULL) {
+							DEBUG_ERR("skb_clone() failed!\n");
+						}
+						else {
+							struct vlan_info *new_info =  &vlan_info_items[VIRTUAL_IFACE_INDEX].info;
+							(*new_skb)->dev = rtl_get_virtual_dev_from_vlan_info();
+							if((*new_skb)->dev == NULL)
+								return 2;
+							COPY_TAG((*new_skb)->tag, new_info);
+							(*new_skb)->src_info = new_info;
+							(*new_skb)->src_info->index=1;
+						}
+					}
+				}else if(memcmp(BRCST_MAC, skb->data, 6)){	 /*unicast for bridge*/
+					/*management packest are unicast!!!!*/
+					 if(is_management_packets(skb)){
+							COPY_TAG(skb->tag, (&management_vlan));
+							DEBUG_TRACE("<== Management packet from wan to bridge, carry port tag [vid=%d] and pass up\n",
+								(int)ntohs(skb->tag.f.pci&0xfff));
+							}
+					skb->dev = rtl_get_virtual_dev_from_vlan_info();
+					if(skb->dev == NULL)
+						return 1;
+				}
+#endif
+			}
+
+	}
+
+	return 0;
+}
+
+EXPORT_SYMBOL(rx_vlan_process);
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+int  tx_vlan_process(struct net_device *dev, struct vlan_info *info_ori, struct sk_buff *skb, int wlan_pri)
+#else
+int  tx_vlan_process(struct net_device *dev, struct vlan_info *info, struct sk_buff *skb, int wlan_pri)
+#endif
+{
+	struct vlan_tag tag, *adding_tag;
+
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+	struct vlan_info *info, info_backup;
+
+	if (skb->src_info != NULL && !info_ori->is_lan) {
+		memcpy(&info_backup, skb->src_info, sizeof(struct vlan_info));    //use lan port vlan info
+		info_backup.is_lan = info_ori->is_lan;		//info is wan port
+	}
+	else{
+		memcpy(&info_backup, info_ori, sizeof(struct vlan_info));
+	}
+	info= &info_backup;
+#endif
+
+	DEBUG_TRACE("==> Process Tx packet\n");
+
+	//printk("---------%s(%d), dev(%s),skb->tag.f.tpid(0x%x)\n",__FUNCTION__,__LINE__,dev->name,skb->tag.f.tpid);
+	if (wlan_pri)
+		skb->cb[0] = '\0';		// for WMM priority
+
+	if (!info->global_vlan) {
+		DEBUG_TRACE("<== Return w/o change due to gvlan not enabled\n");
+		return 0;
+	}
+
+
+	if (!info->vlan) {
+		// When port-vlan is disabled, discard packet if packet come from source port w/ vlan enabled
+		if (skb->tag.f.tpid == htons(ETH_P_8021Q)) {
+			DEBUG_ERR("<Drop> due to port-vlan is disabled but Tx packet w/o vlan enabled!\n");
+			return 1;
+		}
+		DEBUG_TRACE("<== Return w/o change because both Tx port and source vlan not enabled\n");
+		return 0;
+	 }
+
+	// Discard packet if packet come from source port w/o vlan enabled except from protocol stack
+	if (skb->tag.f.tpid != 0) {
+		if (skb->tag.f.tpid != htons(ETH_P_8021Q)) {
+			DEBUG_ERR("<Drop> due to port-vlan is enabled but not from vlan enabled port!\n");
+			return 1;
+		}
+
+		// Discard packet if its vid not matched, except it come from protocol stack or lan
+		if (info->is_lan && ((ntohs(skb->tag.f.pci&0xfff) != ((unsigned short)info->id)) && (ntohs(skb->tag.f.pci&0xfff) != 0xd1))) {
+			DEBUG_ERR("<Drop> due to VID is not matched!\n");
+			return 1;
+		}
+	}
+
+
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+	 if (!info->is_lan)
+	{
+		/*
+		  lan->wan: if the lan port receive this packet is tagged or this packet is original tagged,
+		  it will go out of wan port as tagged
+		 */
+		if (info->tag&0x1)
+			info->tag = 1;
+	}
+	else {
+		/*wan->lan: all packets are untag to lan, no matter lan port is tagged or not*/
+		info->tag = 0;
+	}
+	if(!memcmp(lan_macaddr,skb->data+6, 6) && info->forwarding_rule==1) {
+		return 1;
+	}
+#endif
+#if defined(CONFIG_RTK_VLAN_FOR_CABLE_MODEM)
+	if(rtk_vlan_support_enable == 1)
+#endif
+			if (!info->tag)
+			{
+				//printk("[%s][%d]-skb->dev[%s],proto(0x%x)\n", __FUNCTION__, __LINE__, skb->dev->name,skb->protocol);
+				DEBUG_TRACE("<== Return w/o tagging\n");
+				if (wlan_pri) {
+					if (!info->is_lan &&  skb->tag.f.tpid == htons(ETH_P_8021Q))
+						skb->cb[0] = (unsigned char)((ntohs(skb->tag.f.pci)>>13)&0x7);
+					else
+						skb->cb[0] = (unsigned char)info->pri;
+				}
+
+				return 0;
+			}
+
+		// Add tagging
+
+	//	if (!info->is_lan && skb->tag && skb->tag.f.tpid != 0) { // WAN port and not from local, add source tag
+		if (skb->tag.f.tpid != 0) { // WAN port and not from local, add source tag
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+			struct vlan_info_item *item = rtl_get_vlan_info_item_by_vid(skb->tag.f.pci & 0xfff);
+			if( item && item->info.forwarding_rule == 0 ) { //check if packet form VLAN that disable traffic to/from  WAN
+				DEBUG_ERR("<Drop> due to VLAN is disabled\n");
+				return 1;
+			} else
+#endif
+			{
+				adding_tag = &skb->tag;
+				DEBUG_TRACE("---%s(%d) source port tagging [vid=%d]\n",__FUNCTION__,__LINE__, (int)ntohs(skb->tag.f.pci&0xfff));
+			}
+		}
+		else {
+			adding_tag = NULL;
+			DEBUG_TRACE("---%s(%d)	 Return w/ port tagging [vid=%d]\n", __FUNCTION__,__LINE__,info->id);
+		}
+
+#if defined(CONFIG_RTK_VLAN_FOR_CABLE_MODEM)
+		if(rtk_vlan_support_enable == 2 && adding_tag == NULL)
+			return 0;
+#endif
+
+		memcpy(&tag, skb->data+ETH_ALEN*2, VLAN_HLEN);
+		if (tag.f.tpid !=  htons(ETH_P_8021Q)) { // tag not existed, insert tag
+			if (skb_headroom(skb) < VLAN_HLEN && skb_cow(skb, VLAN_HLEN) !=0 ) {
+				printk("%s-%d: error! (skb_headroom(skb) == %d < 4). Enlarge it!\n",
+				__FUNCTION__, __LINE__, skb_headroom(skb));
+				while (1) ;
+			}
+			skb_push(skb, VLAN_HLEN);
+			memmove(skb->data, skb->data+VLAN_HLEN, ETH_ALEN*2);
+		}
+
+		if (!adding_tag)	{ // add self-tag
+			COPY_TAG(tag, info);
+			adding_tag = &tag;
+		}
+
+		memcpy(skb->data+ETH_ALEN*2, adding_tag, VLAN_HLEN);
+
+		if (wlan_pri)
+			skb->cb[0] = (unsigned char)((ntohs(adding_tag->f.pci)>>13)&0x7);
+		return 0;
+}
+
+EXPORT_SYMBOL(tx_vlan_process);
+
diff --git a/drivers/net/rtl819x/AsicDriver/96C/rtl865x_asicBasic.S b/drivers/net/rtl819x/AsicDriver/96C/rtl865x_asicBasic.S
index 9f3d9d6..d7639e0 100644
--- a/drivers/net/rtl819x/AsicDriver/96C/rtl865x_asicBasic.S
+++ b/drivers/net/rtl819x/AsicDriver/96C/rtl865x_asicBasic.S
@@ -617,32 +617,50 @@ $L57:
 	.set	macro
 	.set	reorder
 	.end	rtl865x_accessAsicTable
+	.rdata
+	.align	2
+$LC1:
+	.ascii	"\n"
+	.ascii	"Assert Fail: %s %d\000"
+	.align	2
+$LC2:
+	.ascii	"drivers/net/rtl819x/rtl865x/../AsicDriver/rtl865x_asicBa"
+	.ascii	"sic.c\000"
 	.section	.text._rtl8651_asicTableAccessForward,"ax",@progbits
 	.align	2
 	.ent	_rtl8651_asicTableAccessForward
 	.type	_rtl8651_asicTableAccessForward, @function
 _rtl8651_asicTableAccessForward:
 	.set	nomips16
-	.frame	$sp,0,$31		# vars= 0, regs= 0/0, args= 0, gp= 0
-	.mask	0x00000000,0
+	.frame	$sp,24,$31		# vars= 0, regs= 1/0, args= 16, gp= 0
+	.mask	0x80000000,-8
 	.fmask	0x00000000,0
 	.set	noreorder
 	.set	nomacro
 	
+	addiu	$sp,$sp,-24
 	bne	$6,$0,$L74
-	li	$2,-1149239296			# 0xffffffffbb800000
+	sw	$31,16($sp)
+
+	lui	$4,%hi($LC1)
+	addiu	$4,$4,%lo($LC1)
+	lui	$5,%hi($LC2)
+	addiu	$5,$5,%lo($LC2)
+	jal	panic_printk
+	li	$6,306			# 0x132
 
-$L76:
-	j	$L76
+$L75:
+	j	$L75
 	nop
 
 $L74:
+	li	$2,-1149239296			# 0xffffffffbb800000
 	ori	$3,$2,0x4d00
-$L78:
+$L77:
 	lw	$2,0($3)
 	nop
 	andi	$2,$2,0x1
-	bne	$2,$0,$L78
+	bne	$2,$0,$L77
 	sll	$2,$4,2
 
 	move	$8,$2
@@ -651,13 +669,13 @@ $L78:
 	addu	$2,$2,$3
 	lw	$2,0($2)
 	nop
-	beq	$2,$0,$L85
+	beq	$2,$0,$L84
 	move	$7,$0
 
 	li	$9,-1149239296			# 0xffffffffbb800000
 	addu	$8,$8,$3
 	sll	$2,$7,2
-$L86:
+$L85:
 	addu	$3,$2,$9
 	addu	$2,$2,$6
 	lw	$2,0($2)
@@ -667,10 +685,10 @@ $L86:
 	lw	$2,0($8)
 	nop
 	sltu	$2,$7,$2
-	bne	$2,$0,$L86
+	bne	$2,$0,$L85
 	sll	$2,$7,2
 
-$L85:
+$L84:
 	sll	$3,$4,16
 	sll	$2,$5,5
 	addu	$3,$3,$2
@@ -679,8 +697,10 @@ $L85:
 	li	$2,-1149239296			# 0xffffffffbb800000
 	ori	$2,$2,0x4d08
 	sw	$3,0($2)
-	j	$31
+	lw	$31,16($sp)
 	nop
+	j	$31
+	addiu	$sp,$sp,24
 
 	.set	macro
 	.set	reorder
@@ -711,7 +731,7 @@ _rtl8651_addAsicEntry:
 
 	lw	$2,16($sp)
 	nop
-	beq	$2,$0,$L87
+	beq	$2,$0,$L86
 	li	$3,-1			# 0xffffffffffffffff
 
 	move	$4,$16
@@ -722,28 +742,28 @@ _rtl8651_addAsicEntry:
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
 	lw	$3,%lo(RtkHomeGatewayChipNameID)($2)
 	li	$2,2			# 0x2
-	bne	$3,$2,$L103
+	bne	$3,$2,$L102
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
 
 	lui	$2,%hi(RtkHomeGatewayChipRevisionID)
 	lw	$2,%lo(RtkHomeGatewayChipRevisionID)($2)
 	nop
-	bgtz	$2,$L104
+	bgtz	$2,$L103
 	li	$3,-1149239296			# 0xffffffffbb800000
 
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
-$L103:
+$L102:
 	lw	$3,%lo(RtkHomeGatewayChipNameID)($2)
 	li	$2,3			# 0x3
-	beq	$3,$2,$L90
+	beq	$3,$2,$L89
 	li	$2,4			# 0x4
 
-	bne	$3,$2,$L105
+	bne	$3,$2,$L104
 	li	$2,3			# 0x3
 
-$L90:
+$L89:
 	li	$3,-1149239296			# 0xffffffffbb800000
-$L104:
+$L103:
 	ori	$3,$3,0x4418
 	lw	$2,0($3)
 	li	$4,262144			# 0x40000
@@ -751,52 +771,52 @@ $L104:
 	sw	$2,0($3)
 	move	$4,$3
 	li	$3,524288			# 0x80000
-$L92:
+$L91:
 	lw	$2,0($4)
 	nop
 	and	$2,$2,$3
-	beq	$2,$0,$L92
+	beq	$2,$0,$L91
 	li	$2,3			# 0x3
 
-$L105:
+$L104:
 	li	$3,-1149239296			# 0xffffffffbb800000
 	ori	$3,$3,0x4d00
 	sw	$2,0($3)
-$L94:
+$L93:
 	lw	$2,0($3)
 	nop
 	andi	$2,$2,0x1
-	bne	$2,$0,$L94
+	bne	$2,$0,$L93
 	li	$2,-1149239296			# 0xffffffffbb800000
 
 	ori	$2,$2,0x4d04
 	lw	$2,0($2)
 	nop
 	andi	$2,$2,0x1
-	beq	$2,$0,$L96
+	beq	$2,$0,$L95
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
 
 	lw	$3,%lo(RtkHomeGatewayChipNameID)($2)
 	li	$2,2			# 0x2
-	bne	$3,$2,$L106
+	bne	$3,$2,$L105
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
 
 	lui	$2,%hi(RtkHomeGatewayChipRevisionID)
 	lw	$2,%lo(RtkHomeGatewayChipRevisionID)($2)
 	nop
-	bgtz	$2,$L98
+	bgtz	$2,$L97
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
 
-$L106:
+$L105:
 	lw	$3,%lo(RtkHomeGatewayChipNameID)($2)
 	li	$2,3			# 0x3
-	beq	$3,$2,$L98
+	beq	$3,$2,$L97
 	li	$2,4			# 0x4
 
-	bne	$3,$2,$L97
+	bne	$3,$2,$L96
 	nop
 
-$L98:
+$L97:
 	li	$4,-1149239296			# 0xffffffffbb800000
 	ori	$4,$4,0x4418
 	lw	$3,0($4)
@@ -804,35 +824,35 @@ $L98:
 	ori	$2,$2,0xffff
 	and	$3,$3,$2
 	sw	$3,0($4)
-$L97:
-	j	$L87
+$L96:
+	j	$L86
 	li	$3,-1			# 0xffffffffffffffff
 
-$L96:
+$L95:
 	lw	$3,%lo(RtkHomeGatewayChipNameID)($2)
 	li	$2,2			# 0x2
-	bne	$3,$2,$L107
+	bne	$3,$2,$L106
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
 
 	lui	$2,%hi(RtkHomeGatewayChipRevisionID)
 	lw	$2,%lo(RtkHomeGatewayChipRevisionID)($2)
 	nop
-	bgtz	$2,$L108
+	bgtz	$2,$L107
 	li	$4,-1149239296			# 0xffffffffbb800000
 
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
-$L107:
+$L106:
 	lw	$3,%lo(RtkHomeGatewayChipNameID)($2)
 	li	$2,3			# 0x3
-	beq	$3,$2,$L101
+	beq	$3,$2,$L100
 	li	$2,4			# 0x4
 
-	bne	$3,$2,$L87
+	bne	$3,$2,$L86
 	move	$3,$0
 
-$L101:
+$L100:
 	li	$4,-1149239296			# 0xffffffffbb800000
-$L108:
+$L107:
 	ori	$4,$4,0x4418
 	lw	$3,0($4)
 	li	$2,-327680			# 0xfffffffffffb0000
@@ -840,7 +860,7 @@ $L108:
 	and	$3,$3,$2
 	sw	$3,0($4)
 	move	$3,$0
-$L87:
+$L86:
 	move	$2,$3
 	lw	$31,36($sp)
 	lw	$18,32($sp)
@@ -905,11 +925,11 @@ _rtl8651_forceAddAsicEntry:
 
 	lw	$2,16($sp)
 	nop
-	beq	$2,$0,$L110
+	beq	$2,$0,$L109
 	li	$3,-1			# 0xffffffffffffffff
 
 	li	$2,3			# 0x3
-	bne	$16,$2,$L123
+	bne	$16,$2,$L122
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
 
 	lui	$3,%hi(mcastForceAddOpCnt)
@@ -918,31 +938,31 @@ _rtl8651_forceAddAsicEntry:
 	addiu	$2,$2,1
 	sw	$2,%lo(mcastForceAddOpCnt)($3)
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
-$L123:
+$L122:
 	lw	$3,%lo(RtkHomeGatewayChipNameID)($2)
 	li	$2,2			# 0x2
-	bne	$3,$2,$L124
+	bne	$3,$2,$L123
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
 
 	lui	$2,%hi(RtkHomeGatewayChipRevisionID)
 	lw	$2,%lo(RtkHomeGatewayChipRevisionID)($2)
 	nop
-	bgtz	$2,$L125
+	bgtz	$2,$L124
 	li	$3,-1149239296			# 0xffffffffbb800000
 
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
-$L124:
+$L123:
 	lw	$3,%lo(RtkHomeGatewayChipNameID)($2)
 	li	$2,3			# 0x3
-	beq	$3,$2,$L114
+	beq	$3,$2,$L113
 	li	$2,4			# 0x4
 
-	bne	$3,$2,$L126
+	bne	$3,$2,$L125
 	move	$4,$16
 
-$L114:
+$L113:
 	li	$3,-1149239296			# 0xffffffffbb800000
-$L125:
+$L124:
 	ori	$3,$3,0x4418
 	lw	$2,0($3)
 	li	$4,262144			# 0x40000
@@ -950,15 +970,15 @@ $L125:
 	sw	$2,0($3)
 	move	$4,$3
 	li	$3,524288			# 0x80000
-$L116:
+$L115:
 	lw	$2,0($4)
 	nop
 	and	$2,$2,$3
-	beq	$2,$0,$L116
+	beq	$2,$0,$L115
 	nop
 
 	move	$4,$16
-$L126:
+$L125:
 	move	$5,$17
 	jal	_rtl8651_asicTableAccessForward
 	move	$6,$18
@@ -967,37 +987,37 @@ $L126:
 	li	$3,-1149239296			# 0xffffffffbb800000
 	ori	$3,$3,0x4d00
 	sw	$2,0($3)
-$L118:
+$L117:
 	lw	$2,0($3)
 	nop
 	andi	$2,$2,0x1
-	bne	$2,$0,$L118
+	bne	$2,$0,$L117
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
 
 	lw	$3,%lo(RtkHomeGatewayChipNameID)($2)
 	li	$2,2			# 0x2
-	bne	$3,$2,$L127
+	bne	$3,$2,$L126
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
 
 	lui	$2,%hi(RtkHomeGatewayChipRevisionID)
 	lw	$2,%lo(RtkHomeGatewayChipRevisionID)($2)
 	nop
-	bgtz	$2,$L128
+	bgtz	$2,$L127
 	li	$4,-1149239296			# 0xffffffffbb800000
 
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
-$L127:
+$L126:
 	lw	$3,%lo(RtkHomeGatewayChipNameID)($2)
 	li	$2,3			# 0x3
-	beq	$3,$2,$L121
+	beq	$3,$2,$L120
 	li	$2,4			# 0x4
 
-	bne	$3,$2,$L110
+	bne	$3,$2,$L109
 	move	$3,$0
 
-$L121:
+$L120:
 	li	$4,-1149239296			# 0xffffffffbb800000
-$L128:
+$L127:
 	ori	$4,$4,0x4418
 	lw	$3,0($4)
 	li	$2,-327680			# 0xfffffffffffb0000
@@ -1005,7 +1025,7 @@ $L128:
 	and	$3,$3,$2
 	sw	$3,0($4)
 	move	$3,$0
-$L110:
+$L109:
 	move	$2,$3
 	lw	$31,36($sp)
 	lw	$18,32($sp)
@@ -1037,47 +1057,54 @@ _rtl8651_readAsicEntry:
 	sw	$18,96($sp)
 	sw	$17,92($sp)
 	sw	$16,88($sp)
-	move	$17,$4
-	move	$18,$5
-	move	$19,$6
+	move	$18,$4
+	move	$19,$5
+	move	$20,$6
 	li	$16,2			# 0x2
-	li	$20,10			# 0xa
+	li	$17,10			# 0xa
 	jal	rtl865x_accessAsicTable
 	addiu	$5,$sp,80
 
 	lw	$2,80($sp)
 	nop
-	beq	$2,$0,$L129
+	beq	$2,$0,$L128
 	li	$3,-1			# 0xffffffffffffffff
 
-	bne	$19,$0,$L131
-	sll	$10,$17,16
+	bne	$20,$0,$L130
+	sll	$10,$18,16
 
-$L133:
-	j	$L133
-	nop
+	lui	$4,%hi($LC1)
+	addiu	$4,$4,%lo($LC1)
+	lui	$5,%hi($LC2)
+	addiu	$5,$5,%lo($LC2)
+	jal	panic_printk
+	li	$6,444			# 0x1bc
 
 $L131:
-	sll	$2,$18,5
+	j	$L131
+	nop
+
+$L130:
+	sll	$2,$19,5
 	addu	$10,$10,$2
 	li	$2,-1157627904			# 0xffffffffbb000000
 	addu	$10,$10,$2
 	li	$2,-1149239296			# 0xffffffffbb800000
 	ori	$3,$2,0x4d00
-$L135:
+$L133:
 	lw	$2,0($3)
 	nop
 	andi	$2,$2,0x1
-	bne	$2,$0,$L135
-	addiu	$12,$sp,16
+	bne	$2,$0,$L133
+	addiu	$13,$sp,16
 
-$L137:
+$L135:
 	move	$9,$0
-$L144:
-	beq	$16,$9,$L142
+$L142:
+	beq	$16,$9,$L140
 	sll	$3,$9,5
 
-	addu	$3,$3,$12
+	addu	$3,$3,$13
 	lw	$2,0($10)
 	nop
 	sw	$2,0($3)
@@ -1103,26 +1130,26 @@ $L144:
 	nop
 	sw	$2,28($3)
 	move	$16,$9
-$L142:
+$L140:
 	addiu	$9,$9,1
 	sltu	$2,$9,2
-	bne	$2,$0,$L144
+	bne	$2,$0,$L142
 	move	$11,$0
 
 	move	$9,$0
-	addiu	$13,$sp,16
+	addiu	$12,$sp,16
 	sltu	$2,$9,2
-$L173:
-	beq	$2,$0,$L167
+$L171:
+	beq	$2,$0,$L165
 	move	$8,$9
 
 	sll	$7,$9,3
-	move	$5,$13
-$L157:
+	move	$5,$12
+$L155:
 	move	$4,$0
 	sll	$6,$8,3
 	addu	$3,$7,$4
-$L172:
+$L170:
 	sll	$3,$3,2
 	addu	$3,$3,$5
 	addu	$2,$6,$4
@@ -1131,53 +1158,53 @@ $L172:
 	lw	$3,0($3)
 	lw	$2,0($2)
 	nop
-	beq	$3,$2,$L153
+	beq	$3,$2,$L151
 	addiu	$4,$4,1
 
 	addiu	$4,$4,-1
-	j	$L155
+	j	$L153
 	li	$11,1			# 0x1
 
-$L153:
+$L151:
 	slt	$2,$4,8
-	bne	$2,$0,$L172
+	bne	$2,$0,$L170
 	addu	$3,$7,$4
 
 	addiu	$8,$8,1
 	sltu	$2,$8,2
-	bne	$2,$0,$L157
+	bne	$2,$0,$L155
 	nop
 
-$L167:
+$L165:
 	addiu	$9,$9,1
 	sltu	$2,$9,2
-	bne	$2,$0,$L173
+	bne	$2,$0,$L171
 	nop
 
-$L155:
-	bne	$11,$0,$L138
-	addiu	$20,$20,-1
+$L153:
+	bne	$11,$0,$L136
+	addiu	$17,$17,-1
 
-	bne	$20,$0,$L137
+	bne	$17,$0,$L135
 	nop
 
-$L138:
+$L136:
 	sll	$3,$16,5
 	addiu	$2,$sp,16
 	addu	$10,$2,$3
-	sll	$3,$17,2
+	sll	$3,$18,2
 	lui	$2,%hi(_rtl8651_asicTableSize)
 	addiu	$2,$2,%lo(_rtl8651_asicTableSize)
 	addu	$3,$3,$2
 	lw	$2,0($3)
 	nop
-	beq	$2,$0,$L171
+	beq	$2,$0,$L169
 	move	$5,$0
 
 	move	$4,$3
 	sll	$2,$5,2
-$L174:
-	addu	$3,$2,$19
+$L172:
+	addu	$3,$2,$20
 	addu	$2,$2,$10
 	lw	$2,0($2)
 	nop
@@ -1186,12 +1213,12 @@ $L174:
 	lw	$2,0($4)
 	nop
 	sltu	$2,$5,$2
-	bne	$2,$0,$L174
+	bne	$2,$0,$L172
 	sll	$2,$5,2
 
-$L171:
+$L169:
 	move	$3,$0
-$L129:
+$L128:
 	move	$2,$3
 	lw	$31,108($sp)
 	lw	$20,104($sp)
@@ -1231,17 +1258,24 @@ _rtl8651_readAsicEntryStopTLU:
 
 	lw	$2,16($sp)
 	nop
-	beq	$2,$0,$L175
+	beq	$2,$0,$L173
 	li	$3,-1			# 0xffffffffffffffff
 
-	bne	$18,$0,$L177
+	bne	$18,$0,$L175
 	sll	$6,$16,16
 
-$L179:
-	j	$L179
+	lui	$4,%hi($LC1)
+	addiu	$4,$4,%lo($LC1)
+	lui	$5,%hi($LC2)
+	addiu	$5,$5,%lo($LC2)
+	jal	panic_printk
+	li	$6,550			# 0x226
+
+$L176:
+	j	$L176
 	nop
 
-$L177:
+$L175:
 	sll	$2,$17,5
 	addu	$6,$6,$2
 	li	$2,-1157627904			# 0xffffffffbb000000
@@ -1249,47 +1283,47 @@ $L177:
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
 	lw	$3,%lo(RtkHomeGatewayChipNameID)($2)
 	li	$2,2			# 0x2
-	bne	$3,$2,$L193
+	bne	$3,$2,$L190
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
 
 	lui	$2,%hi(RtkHomeGatewayChipRevisionID)
 	lw	$2,%lo(RtkHomeGatewayChipRevisionID)($2)
 	nop
-	bgtz	$2,$L194
+	bgtz	$2,$L191
 	li	$2,-1149239296			# 0xffffffffbb800000
 
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
-$L193:
+$L190:
 	lw	$3,%lo(RtkHomeGatewayChipNameID)($2)
 	li	$2,3			# 0x3
-	beq	$3,$2,$L182
+	beq	$3,$2,$L179
 	li	$2,4			# 0x4
 
-	bne	$3,$2,$L195
+	bne	$3,$2,$L192
 	sll	$2,$16,2
 
-$L182:
+$L179:
 	li	$2,-1149239296			# 0xffffffffbb800000
-$L194:
+$L191:
 	ori	$2,$2,0x4418
 	lw	$3,0($2)
 	li	$4,262144			# 0x40000
 	or	$3,$3,$4
 	sw	$3,0($2)
 	sll	$2,$16,2
-$L195:
+$L192:
 	move	$4,$2
 	lui	$3,%hi(_rtl8651_asicTableSize)
 	addiu	$3,$3,%lo(_rtl8651_asicTableSize)
 	addu	$2,$2,$3
 	lw	$2,0($2)
 	nop
-	beq	$2,$0,$L192
+	beq	$2,$0,$L189
 	move	$5,$0
 
 	addu	$4,$4,$3
 	sll	$2,$5,2
-$L196:
+$L193:
 	addu	$3,$2,$18
 	addu	$2,$2,$6
 	lw	$2,0($2)
@@ -1299,32 +1333,32 @@ $L196:
 	lw	$2,0($4)
 	nop
 	sltu	$2,$5,$2
-	bne	$2,$0,$L196
+	bne	$2,$0,$L193
 	sll	$2,$5,2
 
-$L192:
+$L189:
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
 	lw	$3,%lo(RtkHomeGatewayChipNameID)($2)
 	li	$2,2			# 0x2
-	bne	$3,$2,$L197
+	bne	$3,$2,$L194
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
 
 	lui	$2,%hi(RtkHomeGatewayChipRevisionID)
 	lw	$2,%lo(RtkHomeGatewayChipRevisionID)($2)
 	nop
-	bgtz	$2,$L189
+	bgtz	$2,$L186
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
 
-$L197:
+$L194:
 	lw	$3,%lo(RtkHomeGatewayChipNameID)($2)
 	li	$2,3			# 0x3
-	beq	$3,$2,$L189
+	beq	$3,$2,$L186
 	li	$2,4			# 0x4
 
-	bne	$3,$2,$L175
+	bne	$3,$2,$L173
 	move	$3,$0
 
-$L189:
+$L186:
 	li	$4,-1149239296			# 0xffffffffbb800000
 	ori	$4,$4,0x4418
 	lw	$3,0($4)
@@ -1333,7 +1367,7 @@ $L189:
 	and	$3,$3,$2
 	sw	$3,0($4)
 	move	$3,$0
-$L175:
+$L173:
 	move	$2,$3
 	lw	$31,36($sp)
 	lw	$18,32($sp)
@@ -1360,11 +1394,11 @@ _rtl8651_delAsicEntry:
 	
 	li	$2,-1149239296			# 0xffffffffbb800000
 	ori	$3,$2,0x4d00
-$L199:
+$L196:
 	lw	$2,0($3)
 	nop
 	andi	$2,$2,0x1
-	bne	$2,$0,$L199
+	bne	$2,$0,$L196
 	sll	$2,$4,2
 
 	move	$7,$2
@@ -1373,7 +1407,7 @@ $L199:
 	addu	$2,$2,$3
 	lw	$2,0($2)
 	nop
-	beq	$2,$0,$L212
+	beq	$2,$0,$L209
 	move	$3,$0
 
 	li	$8,-1149239296			# 0xffffffffbb800000
@@ -1381,19 +1415,19 @@ $L199:
 	addiu	$2,$2,%lo(_rtl8651_asicTableSize)
 	addu	$7,$7,$2
 	sll	$2,$3,2
-$L215:
+$L212:
 	addu	$2,$2,$8
 	sw	$0,19744($2)
 	addiu	$3,$3,1
 	lw	$2,0($7)
 	nop
 	sltu	$2,$3,$2
-	bne	$2,$0,$L215
+	bne	$2,$0,$L212
 	sll	$2,$3,2
 
-$L212:
+$L209:
 	sltu	$2,$6,$5
-	bne	$2,$0,$L214
+	bne	$2,$0,$L211
 	nop
 
 	li	$2,-1149239296			# 0xffffffffbb800000
@@ -1403,35 +1437,35 @@ $L212:
 	ori	$3,$2,0x4d00
 	li	$8,9			# 0x9
 	ori	$7,$2,0x4d04
-$L210:
+$L207:
 	sll	$2,$5,5
 	addu	$2,$4,$2
 	addu	$2,$2,$9
 	sw	$2,0($10)
 	sw	$8,0($3)
-$L207:
+$L204:
 	lw	$2,0($3)
 	nop
 	andi	$2,$2,0x1
-	bne	$2,$0,$L207
+	bne	$2,$0,$L204
 	nop
 
 	lw	$2,0($7)
 	nop
 	andi	$2,$2,0x1
-	beq	$2,$0,$L209
+	beq	$2,$0,$L206
 	addiu	$5,$5,1
 
 	addiu	$5,$5,-1
 	j	$31
 	li	$2,-1			# 0xffffffffffffffff
 
-$L209:
+$L206:
 	sltu	$2,$6,$5
-	beq	$2,$0,$L210
+	beq	$2,$0,$L207
 	nop
 
-$L214:
+$L211:
 	j	$31
 	move	$2,$0
 
diff --git a/drivers/net/rtl819x/AsicDriver/98/rtl865x_asicBasic.S b/drivers/net/rtl819x/AsicDriver/98/rtl865x_asicBasic.S
index f846701..c72838a 100644
--- a/drivers/net/rtl819x/AsicDriver/98/rtl865x_asicBasic.S
+++ b/drivers/net/rtl819x/AsicDriver/98/rtl865x_asicBasic.S
@@ -596,31 +596,49 @@ $L57:
 	.set	macro
 	.set	reorder
 	.end	rtl865x_accessAsicTable
+	.rdata
+	.align	2
+$LC1:
+	.ascii	"\n"
+	.ascii	"Assert Fail: %s %d\000"
+	.align	2
+$LC2:
+	.ascii	"drivers/net/rtl819x/rtl865x/../AsicDriver/rtl865x_asicBa"
+	.ascii	"sic.c\000"
 	.section	.text._rtl8651_asicTableAccessForward,"ax",@progbits
 	.align	2
 	.ent	_rtl8651_asicTableAccessForward
 	.type	_rtl8651_asicTableAccessForward, @function
 _rtl8651_asicTableAccessForward:
 	.set	nomips16
-	.frame	$sp,0,$31		# vars= 0, regs= 0/0, args= 0, gp= 0
-	.mask	0x00000000,0
+	.frame	$sp,24,$31		# vars= 0, regs= 1/0, args= 16, gp= 0
+	.mask	0x80000000,-8
 	.fmask	0x00000000,0
 	.set	noreorder
 	.set	nomacro
 	
+	addiu	$sp,$sp,-24
 	bne	$6,$0,$L74
-	li	$2,-1149239296			# 0xbb800000
+	sw	$31,16($sp)
+
+	lui	$4,%hi($LC1)
+	addiu	$4,$4,%lo($LC1)
+	lui	$5,%hi($LC2)
+	addiu	$5,$5,%lo($LC2)
+	jal	panic_printk
+	li	$6,306			# 0x132
 
-$L76:
-	j	$L76
+$L75:
+	j	$L75
 	nop
 
 $L74:
+	li	$2,-1149239296			# 0xbb800000
 	ori	$3,$2,0x4d00
-$L78:
+$L77:
 	lw	$2,0($3)
 	andi	$2,$2,0x1
-	bne	$2,$0,$L78
+	bne	$2,$0,$L77
 	sll	$2,$4,2
 
 	move	$8,$2
@@ -628,13 +646,13 @@ $L78:
 	addiu	$3,$3,%lo(_rtl8651_asicTableSize)
 	addu	$2,$2,$3
 	lw	$2,0($2)
-	beq	$2,$0,$L85
+	beq	$2,$0,$L84
 	move	$7,$0
 
 	li	$9,-1149239296			# 0xbb800000
 	addu	$8,$8,$3
 	sll	$2,$7,2
-$L86:
+$L85:
 	addu	$3,$2,$9
 	addu	$2,$2,$6
 	lw	$2,0($2)
@@ -642,10 +660,10 @@ $L86:
 	addiu	$7,$7,1
 	lw	$2,0($8)
 	sltu	$2,$7,$2
-	bne	$2,$0,$L86
+	bne	$2,$0,$L85
 	sll	$2,$7,2
 
-$L85:
+$L84:
 	sll	$3,$4,16
 	sll	$2,$5,5
 	addu	$3,$3,$2
@@ -654,8 +672,9 @@ $L85:
 	li	$2,-1149239296			# 0xbb800000
 	ori	$2,$2,0x4d08
 	sw	$3,0($2)
+	lw	$31,16($sp)
 	j	$31
-	nop
+	addiu	$sp,$sp,24
 
 	.set	macro
 	.set	reorder
@@ -685,7 +704,7 @@ _rtl8651_addAsicEntry:
 	addiu	$5,$sp,16
 
 	lw	$2,16($sp)
-	beq	$2,$0,$L87
+	beq	$2,$0,$L86
 	li	$3,-1			# 0xffffffff
 
 	move	$4,$16
@@ -696,27 +715,27 @@ _rtl8651_addAsicEntry:
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
 	lw	$3,%lo(RtkHomeGatewayChipNameID)($2)
 	li	$2,2			# 0x2
-	bne	$3,$2,$L103
+	bne	$3,$2,$L102
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
 
 	lui	$2,%hi(RtkHomeGatewayChipRevisionID)
 	lw	$2,%lo(RtkHomeGatewayChipRevisionID)($2)
-	bgtz	$2,$L104
+	bgtz	$2,$L103
 	li	$3,-1149239296			# 0xbb800000
 
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
-$L103:
+$L102:
 	lw	$3,%lo(RtkHomeGatewayChipNameID)($2)
 	li	$2,3			# 0x3
-	beq	$3,$2,$L90
+	beq	$3,$2,$L89
 	li	$2,4			# 0x4
 
-	bne	$3,$2,$L105
+	bne	$3,$2,$L104
 	li	$2,3			# 0x3
 
-$L90:
+$L89:
 	li	$3,-1149239296			# 0xbb800000
-$L104:
+$L103:
 	ori	$3,$3,0x4418
 	lw	$2,0($3)
 	li	$4,262144			# 0x40000
@@ -724,48 +743,48 @@ $L104:
 	sw	$2,0($3)
 	move	$4,$3
 	li	$3,524288			# 0x80000
-$L92:
+$L91:
 	lw	$2,0($4)
 	and	$2,$2,$3
-	beq	$2,$0,$L92
+	beq	$2,$0,$L91
 	li	$2,3			# 0x3
 
-$L105:
+$L104:
 	li	$3,-1149239296			# 0xbb800000
 	ori	$3,$3,0x4d00
 	sw	$2,0($3)
-$L94:
+$L93:
 	lw	$2,0($3)
 	andi	$2,$2,0x1
-	bne	$2,$0,$L94
+	bne	$2,$0,$L93
 	li	$2,-1149239296			# 0xbb800000
 
 	ori	$2,$2,0x4d04
 	lw	$2,0($2)
 	andi	$2,$2,0x1
-	beq	$2,$0,$L96
+	beq	$2,$0,$L95
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
 
 	lw	$3,%lo(RtkHomeGatewayChipNameID)($2)
 	li	$2,2			# 0x2
-	bne	$3,$2,$L106
+	bne	$3,$2,$L105
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
 
 	lui	$2,%hi(RtkHomeGatewayChipRevisionID)
 	lw	$2,%lo(RtkHomeGatewayChipRevisionID)($2)
-	bgtz	$2,$L98
+	bgtz	$2,$L97
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
 
-$L106:
+$L105:
 	lw	$3,%lo(RtkHomeGatewayChipNameID)($2)
 	li	$2,3			# 0x3
-	beq	$3,$2,$L98
+	beq	$3,$2,$L97
 	li	$2,4			# 0x4
 
-	bne	$3,$2,$L97
+	bne	$3,$2,$L96
 	nop
 
-$L98:
+$L97:
 	li	$4,-1149239296			# 0xbb800000
 	ori	$4,$4,0x4418
 	lw	$3,0($4)
@@ -773,34 +792,34 @@ $L98:
 	ori	$2,$2,0xffff
 	and	$3,$3,$2
 	sw	$3,0($4)
-$L97:
-	j	$L87
+$L96:
+	j	$L86
 	li	$3,-1			# 0xffffffff
 
-$L96:
+$L95:
 	lw	$3,%lo(RtkHomeGatewayChipNameID)($2)
 	li	$2,2			# 0x2
-	bne	$3,$2,$L107
+	bne	$3,$2,$L106
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
 
 	lui	$2,%hi(RtkHomeGatewayChipRevisionID)
 	lw	$2,%lo(RtkHomeGatewayChipRevisionID)($2)
-	bgtz	$2,$L108
+	bgtz	$2,$L107
 	li	$4,-1149239296			# 0xbb800000
 
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
-$L107:
+$L106:
 	lw	$3,%lo(RtkHomeGatewayChipNameID)($2)
 	li	$2,3			# 0x3
-	beq	$3,$2,$L101
+	beq	$3,$2,$L100
 	li	$2,4			# 0x4
 
-	bne	$3,$2,$L87
+	bne	$3,$2,$L86
 	move	$3,$0
 
-$L101:
+$L100:
 	li	$4,-1149239296			# 0xbb800000
-$L108:
+$L107:
 	ori	$4,$4,0x4418
 	lw	$3,0($4)
 	li	$2,-327680			# 0xfffb0000
@@ -808,7 +827,7 @@ $L108:
 	and	$3,$3,$2
 	sw	$3,0($4)
 	move	$3,$0
-$L87:
+$L86:
 	move	$2,$3
 	lw	$31,36($sp)
 	lw	$18,32($sp)
@@ -872,11 +891,11 @@ _rtl8651_forceAddAsicEntry:
 	addiu	$5,$sp,16
 
 	lw	$2,16($sp)
-	beq	$2,$0,$L110
+	beq	$2,$0,$L109
 	li	$3,-1			# 0xffffffff
 
 	li	$2,3			# 0x3
-	bne	$16,$2,$L123
+	bne	$16,$2,$L122
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
 
 	lui	$3,%hi(mcastForceAddOpCnt)
@@ -884,30 +903,30 @@ _rtl8651_forceAddAsicEntry:
 	addiu	$2,$2,1
 	sw	$2,%lo(mcastForceAddOpCnt)($3)
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
-$L123:
+$L122:
 	lw	$3,%lo(RtkHomeGatewayChipNameID)($2)
 	li	$2,2			# 0x2
-	bne	$3,$2,$L124
+	bne	$3,$2,$L123
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
 
 	lui	$2,%hi(RtkHomeGatewayChipRevisionID)
 	lw	$2,%lo(RtkHomeGatewayChipRevisionID)($2)
-	bgtz	$2,$L125
+	bgtz	$2,$L124
 	li	$3,-1149239296			# 0xbb800000
 
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
-$L124:
+$L123:
 	lw	$3,%lo(RtkHomeGatewayChipNameID)($2)
 	li	$2,3			# 0x3
-	beq	$3,$2,$L114
+	beq	$3,$2,$L113
 	li	$2,4			# 0x4
 
-	bne	$3,$2,$L126
+	bne	$3,$2,$L125
 	move	$4,$16
 
-$L114:
+$L113:
 	li	$3,-1149239296			# 0xbb800000
-$L125:
+$L124:
 	ori	$3,$3,0x4418
 	lw	$2,0($3)
 	li	$4,262144			# 0x40000
@@ -915,14 +934,14 @@ $L125:
 	sw	$2,0($3)
 	move	$4,$3
 	li	$3,524288			# 0x80000
-$L116:
+$L115:
 	lw	$2,0($4)
 	and	$2,$2,$3
-	beq	$2,$0,$L116
+	beq	$2,$0,$L115
 	nop
 
 	move	$4,$16
-$L126:
+$L125:
 	move	$5,$17
 	jal	_rtl8651_asicTableAccessForward
 	move	$6,$18
@@ -931,35 +950,35 @@ $L126:
 	li	$3,-1149239296			# 0xbb800000
 	ori	$3,$3,0x4d00
 	sw	$2,0($3)
-$L118:
+$L117:
 	lw	$2,0($3)
 	andi	$2,$2,0x1
-	bne	$2,$0,$L118
+	bne	$2,$0,$L117
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
 
 	lw	$3,%lo(RtkHomeGatewayChipNameID)($2)
 	li	$2,2			# 0x2
-	bne	$3,$2,$L127
+	bne	$3,$2,$L126
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
 
 	lui	$2,%hi(RtkHomeGatewayChipRevisionID)
 	lw	$2,%lo(RtkHomeGatewayChipRevisionID)($2)
-	bgtz	$2,$L128
+	bgtz	$2,$L127
 	li	$4,-1149239296			# 0xbb800000
 
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
-$L127:
+$L126:
 	lw	$3,%lo(RtkHomeGatewayChipNameID)($2)
 	li	$2,3			# 0x3
-	beq	$3,$2,$L121
+	beq	$3,$2,$L120
 	li	$2,4			# 0x4
 
-	bne	$3,$2,$L110
+	bne	$3,$2,$L109
 	move	$3,$0
 
-$L121:
+$L120:
 	li	$4,-1149239296			# 0xbb800000
-$L128:
+$L127:
 	ori	$4,$4,0x4418
 	lw	$3,0($4)
 	li	$2,-327680			# 0xfffb0000
@@ -967,7 +986,7 @@ $L128:
 	and	$3,$3,$2
 	sw	$3,0($4)
 	move	$3,$0
-$L110:
+$L109:
 	move	$2,$3
 	lw	$31,36($sp)
 	lw	$18,32($sp)
@@ -999,45 +1018,52 @@ _rtl8651_readAsicEntry:
 	sw	$18,96($sp)
 	sw	$17,92($sp)
 	sw	$16,88($sp)
-	move	$17,$4
-	move	$18,$5
-	move	$19,$6
+	move	$18,$4
+	move	$19,$5
+	move	$20,$6
 	li	$16,2			# 0x2
-	li	$20,10			# 0xa
+	li	$17,10			# 0xa
 	jal	rtl865x_accessAsicTable
 	addiu	$5,$sp,80
 
 	lw	$2,80($sp)
-	beq	$2,$0,$L129
+	beq	$2,$0,$L128
 	li	$3,-1			# 0xffffffff
 
-	bne	$19,$0,$L131
-	sll	$10,$17,16
+	bne	$20,$0,$L130
+	sll	$10,$18,16
 
-$L133:
-	j	$L133
-	nop
+	lui	$4,%hi($LC1)
+	addiu	$4,$4,%lo($LC1)
+	lui	$5,%hi($LC2)
+	addiu	$5,$5,%lo($LC2)
+	jal	panic_printk
+	li	$6,444			# 0x1bc
 
 $L131:
-	sll	$2,$18,5
+	j	$L131
+	nop
+
+$L130:
+	sll	$2,$19,5
 	addu	$10,$10,$2
 	li	$2,-1157627904			# 0xbb000000
 	addu	$10,$10,$2
 	li	$2,-1149239296			# 0xbb800000
 	ori	$3,$2,0x4d00
-$L135:
+$L133:
 	lw	$2,0($3)
 	andi	$2,$2,0x1
-	bne	$2,$0,$L135
-	addiu	$12,$sp,16
+	bne	$2,$0,$L133
+	addiu	$13,$sp,16
 
-$L137:
+$L135:
 	move	$9,$0
-$L144:
-	beq	$16,$9,$L142
+$L142:
+	beq	$16,$9,$L140
 	sll	$3,$9,5
 
-	addu	$3,$3,$12
+	addu	$3,$3,$13
 	lw	$2,0($10)
 	sw	$2,0($3)
 	lw	$2,4($10)
@@ -1055,26 +1081,26 @@ $L144:
 	lw	$2,28($10)
 	sw	$2,28($3)
 	move	$16,$9
-$L142:
+$L140:
 	addiu	$9,$9,1
 	sltu	$2,$9,2
-	bne	$2,$0,$L144
+	bne	$2,$0,$L142
 	move	$11,$0
 
 	move	$9,$0
-	addiu	$13,$sp,16
+	addiu	$12,$sp,16
 	sltu	$2,$9,2
-$L173:
-	beq	$2,$0,$L167
+$L171:
+	beq	$2,$0,$L165
 	move	$8,$9
 
 	sll	$7,$9,3
-	move	$5,$13
-$L157:
+	move	$5,$12
+$L155:
 	move	$4,$0
 	sll	$6,$8,3
 	addu	$3,$7,$4
-$L172:
+$L170:
 	sll	$3,$3,2
 	addu	$3,$3,$5
 	addu	$2,$6,$4
@@ -1082,64 +1108,64 @@ $L172:
 	addu	$2,$2,$5
 	lw	$3,0($3)
 	lw	$2,0($2)
-	beq	$3,$2,$L153
+	beq	$3,$2,$L151
 	addiu	$4,$4,1
 
 	addiu	$4,$4,-1
-	j	$L155
+	j	$L153
 	li	$11,1			# 0x1
 
-$L153:
+$L151:
 	slt	$2,$4,8
-	bne	$2,$0,$L172
+	bne	$2,$0,$L170
 	addu	$3,$7,$4
 
 	addiu	$8,$8,1
 	sltu	$2,$8,2
-	bne	$2,$0,$L157
+	bne	$2,$0,$L155
 	nop
 
-$L167:
+$L165:
 	addiu	$9,$9,1
 	sltu	$2,$9,2
-	bne	$2,$0,$L173
+	bne	$2,$0,$L171
 	nop
 
-$L155:
-	bne	$11,$0,$L138
-	addiu	$20,$20,-1
+$L153:
+	bne	$11,$0,$L136
+	addiu	$17,$17,-1
 
-	bne	$20,$0,$L137
+	bne	$17,$0,$L135
 	nop
 
-$L138:
+$L136:
 	sll	$3,$16,5
 	addiu	$2,$sp,16
 	addu	$10,$2,$3
-	sll	$3,$17,2
+	sll	$3,$18,2
 	lui	$2,%hi(_rtl8651_asicTableSize)
 	addiu	$2,$2,%lo(_rtl8651_asicTableSize)
 	addu	$3,$3,$2
 	lw	$2,0($3)
-	beq	$2,$0,$L171
+	beq	$2,$0,$L169
 	move	$5,$0
 
 	move	$4,$3
 	sll	$2,$5,2
-$L174:
-	addu	$3,$2,$19
+$L172:
+	addu	$3,$2,$20
 	addu	$2,$2,$10
 	lw	$2,0($2)
 	sw	$2,0($3)
 	addiu	$5,$5,1
 	lw	$2,0($4)
 	sltu	$2,$5,$2
-	bne	$2,$0,$L174
+	bne	$2,$0,$L172
 	sll	$2,$5,2
 
-$L171:
+$L169:
 	move	$3,$0
-$L129:
+$L128:
 	move	$2,$3
 	lw	$31,108($sp)
 	lw	$20,104($sp)
@@ -1178,17 +1204,24 @@ _rtl8651_readAsicEntryStopTLU:
 	addiu	$5,$sp,16
 
 	lw	$2,16($sp)
-	beq	$2,$0,$L175
+	beq	$2,$0,$L173
 	li	$3,-1			# 0xffffffff
 
-	bne	$18,$0,$L177
+	bne	$18,$0,$L175
 	sll	$6,$16,16
 
-$L179:
-	j	$L179
+	lui	$4,%hi($LC1)
+	addiu	$4,$4,%lo($LC1)
+	lui	$5,%hi($LC2)
+	addiu	$5,$5,%lo($LC2)
+	jal	panic_printk
+	li	$6,550			# 0x226
+
+$L176:
+	j	$L176
 	nop
 
-$L177:
+$L175:
 	sll	$2,$17,5
 	addu	$6,$6,$2
 	li	$2,-1157627904			# 0xbb000000
@@ -1196,45 +1229,45 @@ $L177:
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
 	lw	$3,%lo(RtkHomeGatewayChipNameID)($2)
 	li	$2,2			# 0x2
-	bne	$3,$2,$L193
+	bne	$3,$2,$L190
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
 
 	lui	$2,%hi(RtkHomeGatewayChipRevisionID)
 	lw	$2,%lo(RtkHomeGatewayChipRevisionID)($2)
-	bgtz	$2,$L194
+	bgtz	$2,$L191
 	li	$2,-1149239296			# 0xbb800000
 
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
-$L193:
+$L190:
 	lw	$3,%lo(RtkHomeGatewayChipNameID)($2)
 	li	$2,3			# 0x3
-	beq	$3,$2,$L182
+	beq	$3,$2,$L179
 	li	$2,4			# 0x4
 
-	bne	$3,$2,$L195
+	bne	$3,$2,$L192
 	sll	$2,$16,2
 
-$L182:
+$L179:
 	li	$2,-1149239296			# 0xbb800000
-$L194:
+$L191:
 	ori	$2,$2,0x4418
 	lw	$3,0($2)
 	li	$4,262144			# 0x40000
 	or	$3,$3,$4
 	sw	$3,0($2)
 	sll	$2,$16,2
-$L195:
+$L192:
 	move	$4,$2
 	lui	$3,%hi(_rtl8651_asicTableSize)
 	addiu	$3,$3,%lo(_rtl8651_asicTableSize)
 	addu	$2,$2,$3
 	lw	$2,0($2)
-	beq	$2,$0,$L192
+	beq	$2,$0,$L189
 	move	$5,$0
 
 	addu	$4,$4,$3
 	sll	$2,$5,2
-$L196:
+$L193:
 	addu	$3,$2,$18
 	addu	$2,$2,$6
 	lw	$2,0($2)
@@ -1242,31 +1275,31 @@ $L196:
 	addiu	$5,$5,1
 	lw	$2,0($4)
 	sltu	$2,$5,$2
-	bne	$2,$0,$L196
+	bne	$2,$0,$L193
 	sll	$2,$5,2
 
-$L192:
+$L189:
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
 	lw	$3,%lo(RtkHomeGatewayChipNameID)($2)
 	li	$2,2			# 0x2
-	bne	$3,$2,$L197
+	bne	$3,$2,$L194
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
 
 	lui	$2,%hi(RtkHomeGatewayChipRevisionID)
 	lw	$2,%lo(RtkHomeGatewayChipRevisionID)($2)
-	bgtz	$2,$L189
+	bgtz	$2,$L186
 	lui	$2,%hi(RtkHomeGatewayChipNameID)
 
-$L197:
+$L194:
 	lw	$3,%lo(RtkHomeGatewayChipNameID)($2)
 	li	$2,3			# 0x3
-	beq	$3,$2,$L189
+	beq	$3,$2,$L186
 	li	$2,4			# 0x4
 
-	bne	$3,$2,$L175
+	bne	$3,$2,$L173
 	move	$3,$0
 
-$L189:
+$L186:
 	li	$4,-1149239296			# 0xbb800000
 	ori	$4,$4,0x4418
 	lw	$3,0($4)
@@ -1275,7 +1308,7 @@ $L189:
 	and	$3,$3,$2
 	sw	$3,0($4)
 	move	$3,$0
-$L175:
+$L173:
 	move	$2,$3
 	lw	$31,36($sp)
 	lw	$18,32($sp)
@@ -1302,10 +1335,10 @@ _rtl8651_delAsicEntry:
 	
 	li	$2,-1149239296			# 0xbb800000
 	ori	$3,$2,0x4d00
-$L199:
+$L196:
 	lw	$2,0($3)
 	andi	$2,$2,0x1
-	bne	$2,$0,$L199
+	bne	$2,$0,$L196
 	sll	$2,$4,2
 
 	move	$7,$2
@@ -1313,7 +1346,7 @@ $L199:
 	addiu	$3,$3,%lo(_rtl8651_asicTableSize)
 	addu	$2,$2,$3
 	lw	$2,0($2)
-	beq	$2,$0,$L212
+	beq	$2,$0,$L209
 	move	$3,$0
 
 	li	$8,-1149239296			# 0xbb800000
@@ -1321,18 +1354,18 @@ $L199:
 	addiu	$2,$2,%lo(_rtl8651_asicTableSize)
 	addu	$7,$7,$2
 	sll	$2,$3,2
-$L215:
+$L212:
 	addu	$2,$2,$8
 	sw	$0,19744($2)
 	addiu	$3,$3,1
 	lw	$2,0($7)
 	sltu	$2,$3,$2
-	bne	$2,$0,$L215
+	bne	$2,$0,$L212
 	sll	$2,$3,2
 
-$L212:
+$L209:
 	sltu	$2,$6,$5
-	bne	$2,$0,$L214
+	bne	$2,$0,$L211
 	nop
 
 	li	$2,-1149239296			# 0xbb800000
@@ -1342,33 +1375,33 @@ $L212:
 	ori	$3,$2,0x4d00
 	li	$8,9			# 0x9
 	ori	$7,$2,0x4d04
-$L210:
+$L207:
 	sll	$2,$5,5
 	addu	$2,$4,$2
 	addu	$2,$2,$9
 	sw	$2,0($10)
 	sw	$8,0($3)
-$L207:
+$L204:
 	lw	$2,0($3)
 	andi	$2,$2,0x1
-	bne	$2,$0,$L207
+	bne	$2,$0,$L204
 	nop
 
 	lw	$2,0($7)
 	andi	$2,$2,0x1
-	beq	$2,$0,$L209
+	beq	$2,$0,$L206
 	addiu	$5,$5,1
 
 	addiu	$5,$5,-1
 	j	$31
 	li	$2,-1			# 0xffffffff
 
-$L209:
+$L206:
 	sltu	$2,$6,$5
-	beq	$2,$0,$L210
+	beq	$2,$0,$L207
 	nop
 
-$L214:
+$L211:
 	j	$31
 	move	$2,$0
 
diff --git a/drivers/net/rtl819x/AsicDriver/Makefile b/drivers/net/rtl819x/AsicDriver/Makefile
index 42ee723..4157846 100644
--- a/drivers/net/rtl819x/AsicDriver/Makefile
+++ b/drivers/net/rtl819x/AsicDriver/Makefile
@@ -23,13 +23,19 @@ ifdef CONFIG_RTL_8198T
 L4_SUPPORT=1
 endif
 
-ifeq ($(CONFIG_RTL_8198),y)
-TARGET = 98
-else
+ifeq ($(CONFIG_RTL_819XD),y)
+TARGET = 9xD
+endif
+ifeq ($(CONFIG_RTL_8196E),y)
+TARGET = 96E
+endif
+ifeq ($(CONFIG_RTL_8196C),y)
 TARGET = 96C
 endif
 
-
+ifeq ($(CONFIG_RTL_8198),y)
+TARGET = 98
+endif
 
 ifeq ($(CONFIG_RTK_IPTABLES_FAST_PATH),m)
 EXTRA_CFLAGS += -DCONFIG_FAST_PATH_MODULE
diff --git a/drivers/net/rtl819x/AsicDriver/asicTabs.h b/drivers/net/rtl819x/AsicDriver/asicTabs.h
index 4a811ba..12260a0 100644
--- a/drivers/net/rtl819x/AsicDriver/asicTabs.h
+++ b/drivers/net/rtl819x/AsicDriver/asicTabs.h
@@ -9,65 +9,6 @@
 *
 * $Author: davidhsu $
 *
-* $Log: not supported by cvs2svn $
-* Revision 1.2  2006/07/03 03:05:03  chenyl
-* *: convert files from DOS format to UNIX format
-*
-* Revision 1.1  2004/02/25 14:26:33  chhuang
-* *** empty log message ***
-*
-* Revision 1.1  2004/02/16 01:50:49  chhuang
-* *** empty log message ***
-*
-* Revision 1.2  2004/01/08 07:47:10  cfliu
-* update wiith new data structure definition.
-*
-* Revision 1.1  2003/12/30 14:16:23  cfliu
-* initial version
-*
-* Revision 1.1  2003/12/26 05:26:40  chhuang
-* init
-*
-* Revision 1.13  2003/12/19 01:20:13  danwu
-* little endian definitions for acl, next hop, rate limit tables
-*
-* Revision 1.12  2003/12/18 02:30:56  danwu
-* define _LITTLE_ENDIAN for Veri plateform
-*
-* Revision 1.11  2003/10/27 06:54:38  danwu
-* no message
-*
-* Revision 1.10  2003/10/21 02:53:09  danwu
-* update pktOpApp
-*
-* Revision 1.9  2003/09/23 09:55:17  danwu
-* update ACL table structure for 51B
-*
-* Revision 1.8  2003/09/03 09:22:07  danwu
-* modify for 51b
-*
-* Revision 1.7  2003/08/26 09:56:31  cfliu
-* no message
-*
-* Revision 1.6  2003/08/12 09:57:10  danwu
-* no message
-*
-* Revision 1.5  2003/08/12 06:47:18  danwu
-* to ensure backward compatibility, every table structure is extended to eight
-* words, and unused bits must be cleared before setting
-*
-* Revision 1.4  2003/08/11 14:53:20  cfliu
-* add col2 bit for Hash2 collision
-*
-* Revision 1.3  2003/07/16 06:47:43  cfliu
-* no message
-*
-* Revision 1.2  2003/06/17 12:09:53  cfliu
-* no message
-*
-* Revision 1.1  2003/06/16 03:41:01  danwu
-* init
-*
 * ---------------------------------------------------------------
 */
 
diff --git a/drivers/net/rtl819x/AsicDriver/rtl865x_asicCom.c b/drivers/net/rtl819x/AsicDriver/rtl865x_asicCom.c
index d8fcf08..294636d 100644
--- a/drivers/net/rtl819x/AsicDriver/rtl865x_asicCom.c
+++ b/drivers/net/rtl819x/AsicDriver/rtl865x_asicCom.c
@@ -1,10 +1,13 @@
 /*
-* Copyright c                  Realtek Semiconductor Corporation, 2009  
-* All rights reserved.
-* 
 * Program : Switch table basic operation driver
 * Abstract :
 * Author : hyking (hyking_liu@realsil.com.cn)  
+*
+*  Copyright (c) 2011 Realtek Semiconductor Corp.
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License version 2 as
+*  published by the Free Software Foundation.
 */
 
 #include <linux/delay.h>
@@ -17,6 +20,8 @@
 #include "rtl865x_asicBasic.h"
 #include "rtl865x_asicCom.h"
 
+
+
 #define tick_Delay10ms(x) { int i=x; while(i--) __delay(5000); }
 
 static int32 _rtl865xC_lockTLUCounter	=	0;
@@ -50,6 +55,10 @@ int32 rtl8651_setAsicVlan(uint16 vid, rtl865x_tblAsicDrv_vlanParam_t *vlanp)
 	entry.memberPort = vlanp->memberPortMask & RTL8651_PHYSICALPORTMASK;
 	entry.egressUntag = vlanp->untagPortMask & RTL8651_PHYSICALPORTMASK;
 	entry.fid=vlanp->fid;
+
+#if defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+	entry.vid=vid;
+#endif
 	_rtl8651_forceAddAsicEntry(TYPE_VLAN_TABLE, vid, &entry);
 	
 	return SUCCESS;
@@ -78,6 +87,10 @@ int32 rtl8651_getAsicVlan(uint16 vid, rtl865x_tblAsicDrv_vlanParam_t *vlanp) {
 	vlanp->memberPortMask = (entry.extMemberPort<<RTL8651_PORT_NUMBER) | entry.memberPort;
 	vlanp->untagPortMask = (entry.extEgressUntag<<RTL8651_PORT_NUMBER) |entry.egressUntag;
 	vlanp->fid=entry.fid;
+
+#if defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+	vlanp->vid=entry.vid;
+#endif	
 	return SUCCESS;
 }
 
@@ -860,7 +873,7 @@ int32 rtl8651_getChipVersion(int8 *name,uint32 size, int32 *rev)
 int32 rtl8651_getChipNameID(int32 *id)
 {
 
-#if defined(CONFIG_RTL_8196C) || defined (CONFIG_RTL_8198)
+#if defined(CONFIG_RTL_8196C) || defined (CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 	*id = RTL865X_CHIP_VER_RTL8196C;
 #elif defined(CONFIG_RTL8196B)
 	*id = RTL865X_CHIP_VER_RTL8196B;
@@ -952,7 +965,7 @@ void rtl8651_clearRegister(void)
 	WRITE_MEM32(PBVR5_4,  0x00000000);	/* User-defined 2 */
 	WRITE_MEM32(MSCR,0);   
 	
-#if defined(CONFIG_RTL_8196C) || defined(CONFIG_RTL_8198)
+#if defined(CONFIG_RTL_8196C) || defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 	WRITE_MEM32(PCRP0, (1 | MacSwReset));
 	TOGGLE_BIT_IN_REG_TWICE(PCRP0,EnForceMode);
 	WRITE_MEM32(PCRP1, (1 | MacSwReset));  
@@ -1086,7 +1099,7 @@ int32 rtl8651_clearAsicCommTable(void)
 	//rtl8651_clearSpecifiedAsicTable(TYPE_L2_SWITCH_TABLE, RTL8651_L2TBL_ROW*RTL8651_L2TBL_COLUMN);
 	//rtl8651_clearSpecifiedAsicTable(TYPE_RATE_LIMIT_TABLE, RTL8651_RATELIMITTBL_SIZE);
 	rtl8651_clearSpecifiedAsicTable(TYPE_NETINTERFACE_TABLE, RTL865XC_NETINTERFACE_NUMBER);
-	rtl8651_clearSpecifiedAsicTable(TYPE_VLAN_TABLE, RTL865XC_VLAN_NUMBER);
+	rtl8651_clearSpecifiedAsicTable(TYPE_VLAN_TABLE, RTL865XC_VLANTBL_SIZE);
 	rtl8651_clearSpecifiedAsicTable(TYPE_ACL_RULE_TABLE, RTL8651_ACLTBL_SIZE);
 
 	/*
@@ -1290,6 +1303,13 @@ int32 rtl8651_getAsicAgingFunction(int8 * l2Enable, int8 * l4Enable) {
    #define BSP_SW_IE           (1 << 15)
 void rtl865x_start(void)
 {
+#ifdef CONFIG_RTL_8198
+	{
+	extern void disable_phy_power_down(void);
+	disable_phy_power_down();
+	}
+#endif
+
 	REG32(CPUICR) = TXCMD | RXCMD | BUSBURST_32WORDS | MBUF_2048BYTES;
 	REG32(CPUIISR) = REG32(CPUIISR);
 #if 1
@@ -1723,10 +1743,13 @@ int32 rtl865xC_dumpAsicDiagCounter(void)
 			rtlglue_printf("<Port: %d>\n", i);
 
 		rtlglue_printf("Rx counters\n");
-		rtlglue_printf("   Rcv %llu bytes, Drop %u pkts, CRCAlignErr %u, FragErr %u, JabberErr %u\n", 
+		rtlglue_printf("   Rcv %llu bytes, Drop %u pkts,etherStatsDropEvents %u\n", 
 			rtl865xC_returnAsicCounter64( OFFSET_IFINOCTETS_P0 + addrOffset_fromP0 ), 
 			rtl8651_returnAsicCounter( OFFSET_DOT1DTPPORTINDISCARDS_P0 + addrOffset_fromP0 ), 
+			rtl8651_returnAsicCounter(OFFSET_ETHERSTATSDROPEVENTS_P0 + addrOffset_fromP0 ));
+		rtlglue_printf("   CRCAlignErr %u, SymbolErr %u, FragErr %u, JabberErr %u\n",
 			rtl8651_returnAsicCounter( OFFSET_DOT3STATSFCSERRORS_P0 + addrOffset_fromP0 ), 
+			rtl8651_returnAsicCounter( OFFSET_DOT3STATSSYMBOLERRORS_P0 + addrOffset_fromP0 ), 
 			rtl8651_returnAsicCounter( OFFSET_ETHERSTATSFRAGMEMTS_P0 + addrOffset_fromP0 ), 
 			rtl8651_returnAsicCounter( OFFSET_ETHERSTATSJABBERS_P0 + addrOffset_fromP0 ));
 		rtlglue_printf("   Unicast %u pkts, Multicast %u pkts, Broadcast %u pkts\n", 
@@ -1935,23 +1958,35 @@ int32 rtl8651_getAsicCounter(uint32 counterIdx, rtl865x_tblAsicDrv_basicCounterP
 //sync from rtl865x kernel 2.4
 void FullAndSemiReset( void )
 {
-#if 1//#ifdef CONFIG_RTL865XC
-
-	/* FIXME: Currently workable for FPGA, may need further modification for real chip */
+#if defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 
-	/* Perform full-reset for sw-core. */ 
-	#ifdef CONFIG_RTL8196B_TLD
-	if ((REG32(CPUSSR) & 0x0000ffff) != _MAGIC_FORM_BOOT) 
-	#endif
+	REG32(SYS_CLK_MAG) |= CM_PROTECT;
+	REG32(SYS_CLK_MAG) &= ~CM_ACTIVE_SWCORE;
+	mdelay(300);
+	
+	REG32(SYS_CLK_MAG) |= CM_ACTIVE_SWCORE;
+	REG32(SYS_CLK_MAG) &= ~CM_PROTECT;
+	mdelay(50);
+	
+#elif defined(CONFIG_RTL8198_REVISION_B) 
+ 	if (REG32(BSP_REVR) >= BSP_RTL8198_REVISION_B)
 	{
-
+	  	REG32(SYS_CLK_MAG)&=(~(SYS_SW_RESET));
+		mdelay(300);
+		REG32(SYS_CLK_MAG)|=(SYS_SW_RESET);
+		mdelay(50);
+	}
+	else {
 		REG32(SIRR) |= FULL_RST;
 		tick_Delay10ms(50);
 	}
+#else
+	/* Perform full-reset for sw-core. */ 
+	REG32(SIRR) |= FULL_RST;
+	tick_Delay10ms(50);
+#endif
 
 	/* Enable TRXRDY */
 	REG32(SIRR) |= TRXRDY;
-
-#endif /* CONFIG_RTL865XC */
 }
 
diff --git a/drivers/net/rtl819x/AsicDriver/rtl865x_asicCom.h b/drivers/net/rtl819x/AsicDriver/rtl865x_asicCom.h
index 083ae24..24ffa14 100644
--- a/drivers/net/rtl819x/AsicDriver/rtl865x_asicCom.h
+++ b/drivers/net/rtl819x/AsicDriver/rtl865x_asicCom.h
@@ -10,6 +10,12 @@
 #ifndef RTL865X_ASICCOM_H
 #define RTL865X_ASICCOM_H
 
+#if defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+#define RTL865XC_VLANTBL_SIZE				16
+#else
+#define RTL865XC_VLANTBL_SIZE				4096
+#endif
+
 #define RTL865XC_NETIFTBL_SIZE			8
 #define RTL8651_ACLTBL_SIZE			125
 #define RTL8651_ACLHWTBL_SIZE			128
@@ -224,7 +230,11 @@ typedef struct {
 typedef struct {
 #ifndef _LITTLE_ENDIAN
 	 /* word 0 */
+#if defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+	uint32	vid:12;
+#else
 	uint32	reserved1:12;
+#endif
 	uint32	fid:2;
 	uint32     extEgressUntag  : 3;
 	uint32     egressUntag : 6;
@@ -608,6 +618,9 @@ typedef struct rtl865x_tblAsicDrv_vlanParam_s {
 	uint32 	memberPortMask; /*extension ports [rtl8651_totalExtPortNum-1:0] are located at bits [RTL8651_PORT_NUMBER+rtl8651_totalExtPortNum-1:RTL8651_PORT_NUMBER]*/
 	uint32 	untagPortMask; /*extension ports [rtl8651_totalExtPortNum-1:0] are located at bits [RTL8651_PORT_NUMBER+rtl8651_totalExtPortNum-1:RTL8651_PORT_NUMBER]*/
 	uint32  fid:2;
+#if defined(CONFIG_RTL_819XD)  || defined(CONFIG_RTL_8196E)
+	uint32  vid:12;
+#endif
 } rtl865x_tblAsicDrv_vlanParam_t;
 
 typedef struct rtl865x_tblAsicDrv_intfParam_s {
diff --git a/drivers/net/rtl819x/AsicDriver/rtl865x_asicL2.c b/drivers/net/rtl819x/AsicDriver/rtl865x_asicL2.c
index 2b6b9e9..016e8d4 100644
--- a/drivers/net/rtl819x/AsicDriver/rtl865x_asicL2.c
+++ b/drivers/net/rtl819x/AsicDriver/rtl865x_asicL2.c
@@ -1,11 +1,11 @@
 /*
-* Copyright c                  Realtek Semiconductor Corporation, 2009  
+* Copyright c                  Realtek Semiconductor Corporation, 2009
 * All rights reserved.
-* 
+*
 * Program : Switch table Layer2 switch driver,following features are included:
 *	PHY/MII/Port/STP/QOS
 * Abstract :
-* Author : hyking (hyking_liu@realsil.com.cn)  
+* Author : hyking (hyking_liu@realsil.com.cn)
 */
 #include <net/rtl/rtl_types.h>
 #include <net/rtl/rtl_glue.h>
@@ -19,10 +19,6 @@
 
 #include <linux/delay.h>
 
-#if defined(CONFIG_RTL_8198)
-#define RTL8198_EEE_MAC 	1
-#endif
-
 static uint8 fidHashTable[]={0x00,0x0f,0xf0,0xff};
 
 __DRAM_FWD int32		rtl865x_wanPortMask;
@@ -62,12 +58,12 @@ static uint32 _rtl865xC_BandwidthCtrlNum[] = {	0,	/* BW_FULL_RATE */
 extern uint32 port_link_sts, port_linkpartner_eee;
 #endif
 
-#if defined(RTL8196C_EEE_MAC)
+#if defined(RTL8196C_EEE_MAC) && !defined(CONFIG_MP_PSD_SUPPORT)
 int eee_enabled = 1;
 void eee_phy_enable(void);
 void eee_phy_disable(void);
 void eee_phy_enable_by_port(int port);
-#elif defined(RTL8198_EEE_MAC)
+#elif defined(RTL8198_EEE_MAC) && !defined(CONFIG_MP_PSD_SUPPORT)
 int eee_enabled = 1;
 void eee_phy_enable_98(void);
 void eee_phy_disable_98(void);
@@ -75,7 +71,7 @@ void eee_phy_disable_98(void);
 int eee_enabled = 0;
 #endif
 
-#if defined(CONFIG_RTL_8198_NFBI_BOARD) 
+#if defined(CONFIG_RTL_8198_NFBI_BOARD)
 #define RTL8198_NFBI_PORT5_GMII 1 //mark_nfbi , default port5 set to GMII , you can undef here to set to MII mode!!!
 //#undef RTL8198_NFBI_PORT5_GMII  //mark_nfbi , default port5 set to GMII , you can undef here to set to MII mode!!!
 #endif
@@ -282,7 +278,7 @@ static const unsigned short phy_data[]={
 };
 
 static int ram_code_done=0;
- 
+
 void set_ram_code(void)
 {
 	uint32 reg;
@@ -290,9 +286,9 @@ void set_ram_code(void)
 
 	if (ram_code_done)
 		return;
-	
+
 	rtl8651_getAsicEthernetPHYReg( 4, 0x19, &reg );
-	
+
 	// turn on rg_eeeprg_rst
 	rtl8651_setAsicEthernetPHYReg(4, 0x19, ((reg & ~(P4R25_rg_eeeprg_en)) | P4R25_rg_eeeprg_rst));
 
@@ -303,11 +299,11 @@ void set_ram_code(void)
 	for(i=0;i<len;i++) {
 		rtl8651_setAsicEthernetPHYReg(4, 0x1d, phy_data[i]);
 	}
-	
+
 	for(i=0;i<63;i++) {
 		rtl8651_setAsicEthernetPHYReg(4, 0x1d, 0);
-	}	
-	
+	}
+
 	// finish reading all RAM
 	// turn off mem_mdio_mode
 	rtl8651_setAsicEthernetPHYReg(4, 0x1c, 0x0080);
@@ -399,13 +395,13 @@ void set_ram_code_b(void)
 		return;
 
 	rtl8651_getAsicEthernetPHYReg(4, 0x19, &reg );
-	rtl8651_setAsicEthernetPHYReg(4, 0x19, ((reg & ~(P4R25_rg_eeeprg_en)) | P4R25_rg_eeeprg_rst));	
+	rtl8651_setAsicEthernetPHYReg(4, 0x19, ((reg & ~(P4R25_rg_eeeprg_en)) | P4R25_rg_eeeprg_rst));
 	rtl8651_setAsicEthernetPHYReg(4, 0x1c, 0x0180);
 
 	for(i=0;i<len;i++) {
 		rtl8651_setAsicEthernetPHYReg(4, 0x1d, phy_data_b[i]);
 	}
-	
+
 	rtl8651_setAsicEthernetPHYReg(4, 0x1c, 0x0080);
 	rtl8651_setAsicEthernetPHYReg(4, 0x19, ((reg & ~(P4R25_rg_eeeprg_rst)) | P4R25_rg_eeeprg_en));
 
@@ -423,7 +419,7 @@ void eee_phy_enable_by_port(int port)
 	rtl8651_getAsicEthernetPHYReg( port, 16, &reg );
 	reg |= (P4R16_eee_nway_en | P4R16_tx_quiet_en | P4R16_rx_quiet_en);
 
-#ifdef CONFIG_RTL8196C_ETH_IOT	
+#ifdef CONFIG_RTL8196C_ETH_IOT
 	reg |= P4R16_eee_10_cap;	// enable 10M_EEE also.
 #endif
 	rtl8651_setAsicEthernetPHYReg( port, 16, reg );
@@ -432,7 +428,7 @@ void eee_phy_enable_by_port(int port)
 	rtl8651_getAsicEthernetPHYReg( port, 25, &reg );
 //	reg = reg & 0xF9FF | P4R25_rg_dacquiet_en | P4R25_rg_ldvquiet_en;
 	reg |= (P4R25_rg_dacquiet_en | P4R25_rg_ldvquiet_en | P4R25_rg_eeeprg_en);
-	
+
 	rtl8651_setAsicEthernetPHYReg( port, 25, reg );
 
 	rtl8651_setAsicEthernetPHYReg( port, 17, 0xa2a2 );
@@ -445,7 +441,7 @@ void eee_phy_enable_by_port(int port)
 	else if ((REG32(REVR) == RTL8196C_REVISION_B) && (port == 4)) {
 		set_ram_code_b();
 	}
-	
+
 	// switch to page 0
 	rtl8651_setAsicEthernetPHYReg(port, 31, 0 );
 }
@@ -509,11 +505,11 @@ void eee_phy_disable(void)
 		// switch to page 0
 		rtl8651_setAsicEthernetPHYReg(i, 31, 0 );
 
-		rtl8651_restartAsicEthernetPHYNway(i+1);				
+		rtl8651_restartAsicEthernetPHYNway(i+1);
 	}
 
 	// EEE MAC disable
-	
+
 }
 #endif
 
@@ -525,9 +521,9 @@ void eee_phy_enable_98(void)
 {
 	int i;
 
-	for(i=0; i<5; i++)        
+	for(i=0; i<5; i++)
 		REG32(PCRP0+i*4) |= (EnForceMode);
-	
+
 	// EEE PHY enable
 	for (i=0; i<5; i++)
 	{
@@ -536,19 +532,23 @@ void eee_phy_enable_98(void)
 		Set_GPHYWB(i,32,21,0xffff - 0xffff,0x0100);
 		Set_GPHYWB(i,5,5,0xffff - 0xffff,0x8b84);
 		Set_GPHYWB(i,5,6,0xffff - 0xffff,0x0062);
-		
+
+		/* enable "EEE auto off" for JMicron's bug */
+		Set_GPHYWB(i,5,5,0,0x857a);
+		Set_GPHYWB(i,5,6,0,0x0770);
+
 		rtl8651_restartAsicEthernetPHYNway(i+1);
 	}
-	
-	for(i=0; i<5; i++)            
-		REG32(PCRP0+i*4) &= ~(EnForceMode);
+
+//	for(i=0; i<5; i++)
+//		REG32(PCRP0+i*4) &= ~(EnForceMode);
 }
 
 void eee_phy_disable_98(void)
 {
 	int i;
-	
-	for(i=0; i<5; i++)        
+
+	for(i=0; i<5; i++)
 		REG32(PCRP0+i*4) |= (EnForceMode);
 
 	for (i=0; i<5; i++)
@@ -558,22 +558,114 @@ void eee_phy_disable_98(void)
 		Set_GPHYWB(i,32,21,0xffff - 0xffff,0x0);
 		Set_GPHYWB(i,5,5,0xffff - 0xffff,0x8b84);
 		Set_GPHYWB(i,5,6,0xffff - 0xffff,0x0042);
-		
+
 		rtl8651_restartAsicEthernetPHYNway(i+1);
 	}
 	// EEE PHY disable
 
-	for(i=0; i<5; i++)            
-		REG32(PCRP0+i*4) &= ~(EnForceMode);	
+//	for(i=0; i<5; i++)
+//		REG32(PCRP0+i*4) &= ~(EnForceMode);
+}
+#endif
+
+#if defined(CONFIG_RTL_8198)
+int rtl8198_power_saving_config(uint32 mode)
+{
+	unsigned long flags;
+	int i, _8198_ALDPS, _8198_green_eth;
+
+	if(mode == 0)
+	{
+		// 8198 green ethernet / EEE / ALDPS off
+		eee_enabled = 0;
+		_8198_green_eth = 0;
+		_8198_ALDPS = 0;
+	}
+	else if(mode == 1)
+	{
+		// 8198 green ethernet / EEE / ALDPS on
+		eee_enabled = 1;
+		_8198_green_eth = 1;
+		_8198_ALDPS = 1;
+	}
+	else if(mode == 2)
+	{
+		// 8198 green ethernet on / EEE off
+		eee_enabled = 0;
+		_8198_green_eth = 1;
+		_8198_ALDPS = 1;
+	}
+	else if(mode == 3)
+	{
+		// 8198 green ethernet off / EEE on
+		eee_enabled = 1;
+		_8198_green_eth = 0;
+		_8198_ALDPS = 1;
+	}
+	else {
+		return (-1);
+	}
+
+	local_irq_save(flags);
+
+	for(i=0; i<5; i++)
+		REG32(PCRP0+i*4) |= (EnForceMode);
+
+	/*
+		8198 ALDPS feature is on by default.
+		It is in PHY page 44, reg 21, bit 0: 1 enable, 0 disable
+	*/
+	if (_8198_ALDPS) {
+		Set_GPHYWB(999, 44, 21, 0xfffe, 1);
+	}
+	else {
+		Set_GPHYWB(999, 44, 21, 0xfffe, 0);
+	}
+
+	/*
+		write Page 5 Reg 5 = 0x85E4
+		read Page 5 Reg 6; #bit0 = 1, for enable green Rx
+		write Page 5 Reg 5 = 0x85E7
+		read Page 5 Reg 6; #bit0 = 1, for enable green Tx
+
+	*/
+	if (_8198_green_eth) {
+		Set_GPHYWB(999, 5, 5, 0, 0x85e4);
+		Set_GPHYWB(999, 5, 6, 0xfffe, 1);
+
+		Set_GPHYWB(999, 5, 5, 0, 0x85e7);
+		Set_GPHYWB(999, 5, 6, 0xfffe, 1);
+	}
+	else {
+		Set_GPHYWB(999, 5, 5, 0, 0x85e4);
+		Set_GPHYWB(999, 5, 6, 0xfffe, 0);
+
+		Set_GPHYWB(999, 5, 5, 0, 0x85e7);
+		Set_GPHYWB(999, 5, 6, 0xfffe, 0);
+	}
+
+	if (eee_enabled) {
+		eee_phy_enable_98();
+	}
+	else {
+		eee_phy_disable_98();
+	}
+
+	for(i=0; i<5; i++)
+		REG32(PCRP0+i*4) &= ~(EnForceMode);
+
+	local_irq_restore(flags);
+
+	return 0;
 }
 #endif
 
 #ifdef CONFIG_RTL8196C_GREEN_ETHERNET
 void set_phy_pwr_save(int id, int val)
 {
-	uint32 reg_val;	
+	uint32 reg_val;
 	int i, start, end;
-	
+
 	if (id == 99)
 		{ start=0; end=4; }
 	else if (id <= 4)
@@ -586,20 +678,37 @@ void set_phy_pwr_save(int id, int val)
 
 		if (val == 1)
 			rtl8651_setAsicEthernetPHYReg( i, 24, (reg_val | BIT(15)) );
-		else 
+		else
 			rtl8651_setAsicEthernetPHYReg( i, 24, (reg_val & (~BIT(15))) );
 	}
 }
 #endif
 
-uint32 rtl8651_filterDbIndex(ether_addr_t * macAddr,uint16 fid) 
+int32 mmd_read(uint32 phyId, uint32 devId, uint32 regId, uint32 *rData)
+{
+	rtl8651_setAsicEthernetPHYReg( phyId, 13, devId);
+	rtl8651_setAsicEthernetPHYReg( phyId, 14, regId);
+	rtl8651_setAsicEthernetPHYReg( phyId, 13, (devId | 0x4000));
+	return (rtl8651_getAsicEthernetPHYReg(phyId, 14, rData));
+}
+
+int32 mmd_write(uint32 phyId, uint32 devId, uint32 regId, uint32 wData)
+{
+	rtl8651_setAsicEthernetPHYReg( phyId, 13, devId);
+	rtl8651_setAsicEthernetPHYReg( phyId, 14, regId);
+	rtl8651_setAsicEthernetPHYReg( phyId, 13, (devId | 0x4000));
+	rtl8651_setAsicEthernetPHYReg( phyId, 14, wData);
+	return SUCCESS;
+}
+
+uint32 rtl8651_filterDbIndex(ether_addr_t * macAddr,uint16 fid)
 {
     return ( macAddr->octet[0] ^ macAddr->octet[1] ^
                     macAddr->octet[2] ^ macAddr->octet[3] ^
                     macAddr->octet[4] ^ macAddr->octet[5] ^fidHashTable[fid]) & 0xFF;
 }
 
-int32 rtl8651_setAsicL2Table(uint32 row, uint32 column, rtl865x_tblAsicDrv_l2Param_t *l2p) 
+int32 rtl8651_setAsicL2Table(uint32 row, uint32 column, rtl865x_tblAsicDrv_l2Param_t *l2p)
 {
 	rtl865xc_tblAsic_l2Table_t entry;
 
@@ -616,7 +725,7 @@ int32 rtl8651_setAsicL2Table(uint32 row, uint32 column, rtl865x_tblAsicDrv_l2Par
 
 #if 1 //chhuang: #ifdef CONFIG_RTL8650B
 	if( l2p->memberPortMask  > RTL8651_PHYSICALPORTMASK) //this MAC is on extension port
-		entry.extMemberPort = (l2p->memberPortMask >>RTL8651_PORT_NUMBER);   
+		entry.extMemberPort = (l2p->memberPortMask >>RTL8651_PORT_NUMBER);
 #endif /* CONFIG_RTL8650B */
 
 	entry.memberPort = l2p->memberPortMask & RTL8651_PHYSICALPORTMASK;
@@ -626,14 +735,14 @@ int32 rtl8651_setAsicL2Table(uint32 row, uint32 column, rtl865x_tblAsicDrv_l2Par
 
 	/* RTL865xC: modification of age from ( 2 -> 3 -> 1 -> 0 ) to ( 3 -> 2 -> 1 -> 0 ). modification of granularity 100 sec to 150 sec. */
 	entry.agingTime = ( l2p->ageSec > 300 )? 0x03: ( l2p->ageSec <= 300 && l2p->ageSec > 150 )? 0x02: (l2p->ageSec <= 150 && l2p->ageSec > 0 )? 0x01: 0x00;
-	
+
 	entry.srcBlock = (l2p->srcBlk==TRUE)? 1: 0;
 	entry.fid=l2p->fid;
 	entry.auth=l2p->auth;
 	return _rtl8651_forceAddAsicEntry(TYPE_L2_SWITCH_TABLE, row<<2 | column, &entry);
 }
 
-int32 rtl8651_delAsicL2Table(uint32 row, uint32 column) 
+int32 rtl8651_delAsicL2Table(uint32 row, uint32 column)
 {
 	rtl865xc_tblAsic_l2Table_t entry;
 
@@ -651,7 +760,7 @@ unsigned int rtl8651_asicL2DAlookup(uint8 *dmac){
 	uint32 column;
 //	rtl8651_tblAsic_l2Table_t   entry;
 	rtl865xc_tblAsic_l2Table_t	entry;
-	
+
 //	unsigned int row = dmac[0]^dmac[1]^dmac[2]^dmac[3]^dmac[4]^dmac[5];
 	uint32 row = rtl8651_filterDbIndex((ether_addr_t *)dmac, 0);
 	//rtlglue_printf("mac %02x %02x %02x %02x %02x %02x \n",	mac[0],mac[1],mac[2],mac[3],mac[4],mac[5]);
@@ -691,7 +800,7 @@ unsigned int rtl8651_asicL2DAlookup(uint8 *dmac){
 
 int32 rtl8651_getAsicL2Table(uint32 row, uint32 column, rtl865x_tblAsicDrv_l2Param_t *l2p) {
 	rtl865xc_tblAsic_l2Table_t   entry;
- 
+
 	if((row >= RTL8651_L2TBL_ROW) || (column >= RTL8651_L2TBL_COLUMN) || (l2p == NULL))
 		return FAILED;
 
@@ -731,7 +840,7 @@ int32 rtl8651_setAsicPortMirror(uint32 mRxMask, uint32 mTxMask,uint32 mPortMask)
 	pmcr = ((mTxMask<<MirrorTxPrtMsk_OFFSET)&MirrorTxPrtMsk_MASK) |
 		((mRxMask << MirrorRxPrtMsk_OFFSET) & MirrorRxPrtMsk_MASK)|
 		((mPortMask<<MirrorPortMsk_OFFSET) & MirrorPortMsk_MASK);
-	
+
 	WRITE_MEM32(PMCR,pmcr);
 
 	return SUCCESS;
@@ -755,7 +864,7 @@ int32 rtl8651_getAsicPortMirror(uint32 *mRxMask, uint32 *mTxMask, uint32 *mPortM
 	{
 		*mTxMask = ( pmcr & MirrorTxPrtMsk_MASK ) >> MirrorTxPrtMsk_OFFSET;
 	}
-	
+
 	return SUCCESS;
 }
 
@@ -766,7 +875,7 @@ int32 rtl8651_clearAsicL2Table(void)
 	return SUCCESS;
 }
 
-inline int32 convert_setAsicL2Table(uint32 row, uint32 column, ether_addr_t * mac, int8 cpu, 
+inline int32 convert_setAsicL2Table(uint32 row, uint32 column, ether_addr_t * mac, int8 cpu,
 		int8 srcBlk, uint32 mbr, uint32 ageSec, int8 isStatic, int8 nhFlag,int8 fid, int8 auth)
 {
 	rtl865x_tblAsicDrv_l2Param_t l2;
@@ -775,15 +884,15 @@ inline int32 convert_setAsicL2Table(uint32 row, uint32 column, ether_addr_t * ma
 
 	l2.ageSec				= ageSec;
 	l2.cpu				= cpu;
-	l2.isStatic				= isStatic; 
+	l2.isStatic				= isStatic;
 	l2.memberPortMask		= mbr;
 	l2.nhFlag				= nhFlag;
 	l2.srcBlk				= srcBlk;
 //#ifdef RTL865XC_LAN_PORT_NUM_RESTRIT
 //	if(enable4LanPortNumRestrict == TRUE)
-	l2.fid=fid; 
+	l2.fid=fid;
 	l2.auth = auth;
-//#endif	
+//#endif
 	memcpy(&l2.macAddr, mac, 6);
 	return rtl8651_setAsicL2Table(row, column, &l2);
 }
@@ -791,21 +900,21 @@ inline int32 convert_setAsicL2Table(uint32 row, uint32 column, ether_addr_t * ma
 /*
  * <<RTL8651 version B Bug>>
  * RTL8651 L2 entry bug:
- *		For each L2 entry added by driver table as a static entry, the aging time 
+ *		For each L2 entry added by driver table as a static entry, the aging time
  *		will not be updated by ASIC
  * Bug fixed:
- *		To patch this bug, set the entry is a dynamic entry and turn on the 'nhFlag', 
+ *		To patch this bug, set the entry is a dynamic entry and turn on the 'nhFlag',
  *		then the aging time of this entry will be updated and once aging time expired,
  *		it won't be removed by ASIC automatically.
  */
-int32 rtl8651_setAsicL2Table_Patch(uint32 row, uint32 column, ether_addr_t * mac, int8 cpu, 
-		int8 srcBlk, uint32 mbr, uint32 ageSec, int8 isStatic, int8 nhFlag, int8 fid,int8 auth) 
+int32 rtl8651_setAsicL2Table_Patch(uint32 row, uint32 column, ether_addr_t * mac, int8 cpu,
+		int8 srcBlk, uint32 mbr, uint32 ageSec, int8 isStatic, int8 nhFlag, int8 fid,int8 auth)
 {
-#if 0	
+#if 0
 	ether_addr_t bcast_mac = { {0xff, 0xff, 0xff, 0xff, 0xff, 0xff} };
 	ether_addr_t cpu_mac = {{0x00,0x00,0x0a,0x00,0x00,0x0f}};
 
-	/* 
+	/*
 		In RTL865xC, we need to turn on the CPU bit of broadcast mac to let broadcast packets being trapped to CPU.
 	*/
 
@@ -840,7 +949,7 @@ int32 rtl8651_setAsicL2Table_Patch(uint32 row, uint32 column, ether_addr_t * mac
 				fid,
 				TRUE
 		);
-	}	
+	}
 	else {
 		int8 dStatic=isStatic/*, dnhFlag=(isStatic==TRUE? TRUE: FALSE)*/;
 		int8 dnhFlag = nhFlag;
@@ -851,7 +960,7 @@ int32 rtl8651_setAsicL2Table_Patch(uint32 row, uint32 column, ether_addr_t * mac
 			dStatic = TRUE;
 			dnhFlag = FALSE;
 		}
-#endif		
+#endif
 		return convert_setAsicL2Table(
 				row,
 				column,
@@ -874,16 +983,16 @@ int32 rtl8651_setAsicL2Table_Patch(uint32 row, uint32 column, ether_addr_t * mac
 /*
  * <<RTL8651 version B Bug>>
  * RTL8651 L2 entry bug:
- *		For each L2 entry added by driver table as a static entry, the aging time 
+ *		For each L2 entry added by driver table as a static entry, the aging time
  *		will not be updated by ASIC
  * Bug fixed:
- *		To patch this bug, set the entry as a dynamic entry and turn on the 'nhFlag', 
+ *		To patch this bug, set the entry as a dynamic entry and turn on the 'nhFlag',
  *		then the aging time of this entry will be updated and once aging time expired,
  *		it won't be removed by ASIC automatically.
  */
 #if 0
-int32 rtl8651_getAsicL2Table_Patch(uint32 row, uint32 column, ether_addr_t * mac, int8 * cpu, 
-	int8 * srcBlk, int8 * isStatic, uint32 * mbr, uint32 * ageSec, int8 *nhFlag) 
+int32 rtl8651_getAsicL2Table_Patch(uint32 row, uint32 column, ether_addr_t * mac, int8 * cpu,
+	int8 * srcBlk, int8 * isStatic, uint32 * mbr, uint32 * ageSec, int8 *nhFlag)
 {
 	rtl865x_tblAsicDrv_l2Param_t l2;
 
@@ -955,7 +1064,7 @@ static inline unsigned int rtl865x_probeP5GigaPHYChip(void)
 	/* Read */
 	rtl8651_getAsicEthernetPHYReg( CONFIG_EXTRTL8212_PHYID_P5, 0, &tmp );
 	rtl8651_setAsicEthernetPHYReg(CONFIG_EXTRTL8212_PHYID_P5,0x10,0x01FE);
-	
+
 	/* Read */
 	rtl8651_getAsicEthernetPHYReg( CONFIG_EXTRTL8212_PHYID_P5, 2, &tmp );
 	uid=tmp<<16;
@@ -965,7 +1074,7 @@ static inline unsigned int rtl865x_probeP5GigaPHYChip(void)
 	if( uid==0x001CC912 )  //0x001cc912 is 8212 two giga port , 0x001cc940 is 8214 four giga port
 	{	//printk("Find Port5   have 8211 PHY Chip! \r\n");
 		return 1;
-	}	
+	}
 
 	return 0;
 }
@@ -1115,13 +1224,13 @@ static int32 _rtl8651_initAsicPara( rtl8651_tblAsic_InitPara_t *para )
 	return SUCCESS;
 }
 
-#if defined(CONFIG_RTL8196C_REVISION_B) || defined(CONFIG_RTL_8198)
+#if defined(CONFIG_RTL8196C_REVISION_B) || defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 void Set_GPHYWB(unsigned int phyid, unsigned int page, unsigned int reg, unsigned int mask, unsigned int val)
 {
 	unsigned int data=0;
 	unsigned int wphyid=0;	//start
 	unsigned int wphyid_end=1;   //end
-	
+
 	if(phyid==999)
 	{	wphyid=0;
 		wphyid_end=5;    //total phyid=0~4
@@ -1133,7 +1242,7 @@ void Set_GPHYWB(unsigned int phyid, unsigned int page, unsigned int reg, unsigne
 
 	for(; wphyid<wphyid_end; wphyid++)
 	{
-		//change page 
+		//change page
 		if(page>=31)
 		{	rtl8651_setAsicEthernetPHYReg( wphyid, 31, 7  );
 			rtl8651_setAsicEthernetPHYReg( wphyid, 30, page  );
@@ -1163,20 +1272,20 @@ void Set_GPHYWB(unsigned int phyid, unsigned int page, unsigned int reg, unsigne
 void set_gray_code_by_port(int port)
 {
         uint32 val;
- 
+
         rtl8651_setAsicEthernetPHYReg( 4, 31, 1  );
- 
+
         rtl8651_getAsicEthernetPHYReg( 4, 20, &val  );
         rtl8651_setAsicEthernetPHYReg( 4, 20, val + (0x1 << port)  );
- 
+
         rtl8651_setAsicEthernetPHYReg( port, 31, 1  );
- 
+
         rtl8651_setAsicEthernetPHYReg( port, 19,  0x5400 );
         if (port<4) rtl8651_setAsicEthernetPHYReg( port, 19,  0x5440 );
         if (port<3) rtl8651_setAsicEthernetPHYReg( port, 19,  0x54c0 );
         if (port<2) rtl8651_setAsicEthernetPHYReg( port, 19,  0x5480 );
         if (port<1) rtl8651_setAsicEthernetPHYReg( port, 19,  0x5580 );
- 
+
         rtl8651_setAsicEthernetPHYReg( 4, 20, 0xb20  );
        rtl8651_setAsicEthernetPHYReg( port, 31, 0  );
 
@@ -1193,54 +1302,54 @@ void Setting_RTL8196C_PHY(void)
 	/*
 	  #=========ADC Bias Current =========================
 	  #RG1X_P4~0 [12:10] = Reg_pi_fix [2:0], 5 ->7
-	  phywb all 1 17 12-10 0x7      
+	  phywb all 1 17 12-10 0x7
 	*/
 	Set_GPHYWB(999, 1, 17, 0xffff-(7<<10), 0x7<<10);
 
 	/*
 	  #=========patch for eee============================
-	  #1. page4Breg24Glpi_rx_ti_timer_cnt change to f3     
+	  #1. page4Breg24Glpi_rx_ti_timer_cnt change to f3
 	  phywb all 4 24 7-0 0xf3
 
-	  #2. page4Breg16Grg_txqt_ps_sel change to 1    
-	  phywb all 4 16 3 1  
+	  #2. page4Breg16Grg_txqt_ps_sel change to 1
+	  phywb all 4 16 3 1
 	*/
 	Set_GPHYWB(999, 4, 24, 0xff00, 0xf3);
 	Set_GPHYWB(999, 4, 16, 0xffff-(1<<3), 1<<3);
-	/*	
-	  #=========patch for IOL Tx amp.=====================      
+	/*
+	  #=========patch for IOL Tx amp.=====================
 	  #<a>modify 100M DAC current default value:
 	  #Port#0~#4(per port control)
-	  #Page1,Reg19,bit[13:11]: 
+	  #Page1,Reg19,bit[13:11]:
 	  #original value 200uA(3b'100),--> change to 205u(3b'000)   => change to 205u(3b010)
 
 	  phywb all 1 19 13-11 0x2
 
-	  #<b>modify bandgap voltage default value:  
+	  #<b>modify bandgap voltage default value:
 	  #Port#0~#4 (Global all ports contorl setting),
-	  #Page1,Reg23,bit[8:6],                            
+	  #Page1,Reg23,bit[8:6],
 
-	  #original value 1.312V(3b'110),-->change to 1.212V(3b'100).       
+	  #original value 1.312V(3b'110),-->change to 1.212V(3b'100).
 
 	  phywb all 1 23 8-6 0x4
 
-	  #<c>modify TX CS cap default value:                                   
+	  #<c>modify TX CS cap default value:
 	  #Port#0~#4 (Global all ports contorl setting),
-	  #Page1,Reg18,bit[5:3],                                               
+	  #Page1,Reg18,bit[5:3],
 
-	  #original value Reserved bits(3b'000),-->change to 600fF(3b'011). =>change to 750fF(3b'110) 
+	  #original value Reserved bits(3b'000),-->change to 600fF(3b'011). =>change to 750fF(3b'110)
 	  phywb all 1 18 5-3 0x6
 	*/
 
 	Set_GPHYWB(999, 1, 19, 0xffff-(7<<11), 0x2<<11);
 	Set_GPHYWB(999, 1, 23, 0xffff-(7<<6)  , 0x4<<6);
 	Set_GPHYWB(999, 1, 18, 0xffff-(7<<3), 0x6<<3);
-	
+
 
 	/* 20100223 from Maxod: 100M half duplex enhancement */
  	REG32(MACCR)= (REG32(MACCR) & ~CF_RXIPG_MASK) | 0x05;
 
-	/* fix the link down / link up issue with SmartBit 3101B when DUT(8196c) set to Auto-negotiation 
+	/* fix the link down / link up issue with SmartBit 3101B when DUT(8196c) set to Auto-negotiation
 	    and SmartBit force to 100M Full-duplex */
  	REG32(MACCR)= (REG32(MACCR) & ~SELIPG_MASK) | SELIPG_11;
 
@@ -1257,7 +1366,7 @@ void Setting_RTL8196C_PHY(void)
 	*/
 	//rtl8651_setAsicEthernetPHYReg( i, 0x15, 0x232 );
 	//Set_GPHYWB(999, 0, 21, 0xffff-(0xff<<0), 0x32<<0);
-	// test 96C to 96C restart AN 100 times, result is pass ==> page0 reg21.14(disable the equlizar)=1      
+	// test 96C to 96C restart AN 100 times, result is pass ==> page0 reg21.14(disable the equlizar)=1
 #ifdef CONFIG_RTL8196C_ETH_IOT
 	// enable "equalizer reset", i.e. page 0 , reg21, bit14= 0
 	Set_GPHYWB(999, 0, 21, (~0x40ff), 0x0032);
@@ -1268,17 +1377,17 @@ void Setting_RTL8196C_PHY(void)
 	//rtl8651_setAsicEthernetPHYReg( i, 0x16, 0x5b45 );
 	//Set_GPHYWB(999, 0, 22, 0xffff-(7<<4), 0x4<<4);
 	Set_GPHYWB(999, 0, 22, 0xffff-(7<<4), 0x5<<4);
-	//rtl8651_setAsicEthernetPHYReg( i, 0x0, 0x1300 );						
+	//rtl8651_setAsicEthernetPHYReg( i, 0x0, 0x1300 );
 	Set_GPHYWB(999, 0, 0, 0xffff-(1<<9), 0x1<<9);
-	
+
 	/*20100225 from Anson:Switch Force cailibration
 	#change calibration update method for patch first pkt no update impedance
 	phywb all 1 29 1 0
-	#--------------Patch for impedance update fail cause rx crc error with long calbe-------- 
+	#--------------Patch for impedance update fail cause rx crc error with long calbe--------
 	#Froce cailibration
 	phywb all 1 29 2 1
 	#Force impedance value = 0x8888
-	phywb all 1 28 15-0 0x8888			 	
+	phywb all 1 28 15-0 0x8888
 	#-----------------------------------------------------------------------------------------
 	#Select clock (ckt125[4]) edge trigger mlt3[1:0] = negative for patch four corner fail issue(only tx timing)
 	phywb all 1 17 2-1 0x3
@@ -1287,21 +1396,21 @@ void Setting_RTL8196C_PHY(void)
 	//Set_GPHYWB(999, 1, 29, 0xffff-(1<<2), 0x1<<2);
 	//Set_GPHYWB(999, 1, 28, 0xffff-(0xffff), 0x8888);
 	Set_GPHYWB(999, 1, 17, 0xffff-(3<<1), 0x3<<1);
-		 		 
+
 	/*20100222 from Yozen:AOI TEST pass setting*/
-	Set_GPHYWB(999, 1, 18, 0xffff-(0xffff), 0x9004);				
-		
+	Set_GPHYWB(999, 1, 18, 0xffff-(0xffff), 0x9004);
+
 	// for "DSP recovery fail when link partner = force 100F"
-	Set_GPHYWB(999, 4, 26, 0xffff-(0xfff<<4), 0xff8<<4);	
-	
+	Set_GPHYWB(999, 4, 26, 0xffff-(0xfff<<4), 0xff8<<4);
+
 	for(i=0; i<5; i++)
 		REG32(PCRP0+i*4) &= ~(EnForceMode);
-	
+
 #ifdef CONFIG_RTL8196C_ETH_IOT
         for(i=0; i<5; i++) {
                 set_gray_code_by_port(i);
         }
-#endif	
+#endif
 	printk("  Set 8196C PHY Patch OK\n");
 
 }
@@ -1318,7 +1427,7 @@ static const unsigned int phy_para[]={
 	0x1f,0x0002,//Page 2
 	0x04,0x80C2,//Page 2 Reg 4 0x80C2, Fix 100M re-link fail issue (20100110)
 	0x05,0x0938,//Page 2 Reg 5 0x0938, Disable 10M standby mode (20100112)
-	
+
 	0x1F,0x0003,//Page 3
 	0x12,0xC4D2,//Page 3 Reg 18 = 0xC4D2, GAIN upper bond=24
 	0x0D,0x0207,//Page 3 Reg 13 = 0x0207 (20100112)
@@ -1326,20 +1435,20 @@ static const unsigned int phy_para[]={
 	0x02,0x63E8, //#Page 3 Reg  2 = 0x63E8 (20100423)
 	0x03,0x99C2, //#Page 3 Reg  3 = 0x99C2 (20100423)
 	0x04,0x0113, //#Page 3 Reg  4 = 0x0113 (20100423)
-	
+
 	0x1f,0x0001,//Page 1
 	0x07,0x267E,//Page 1 Reg  7 = 0x267E, Channel Gain offset (20100111)
 	0x1C,0xE5F7,//Page 1 Reg 28 = 0xE5F7, Cable length offset (20100111)
 	0x1B,0x0424,//Page 1 Reg 27 = 0x0424, SD threshold (20100111)
-	
-	//#Add by Gary for Channel Estimation fine tune 20100430            
+
+	//#Add by Gary for Channel Estimation fine tune 20100430
 	//0x1f,0x0002, //# change to Page 1 (Global)
 	//0x08,0x0574, //# Page1 Reg8 (CG_INITIAL_MASTER)
-	//0x09,0x2724, //# Page1 Reg9 (CB0_INITIAL_GIGA) 
+	//0x09,0x2724, //# Page1 Reg9 (CB0_INITIAL_GIGA)
 	//0x1f,0x0003, //# change to Page 3 (Global)
 	//0x1a,0x06f6, //# Page3 Reg26 (CG_INITIAL_SLAVE)
-	
-	//#Add by Gary for Channel Estimation fine tune 20100430            
+
+	//#Add by Gary for Channel Estimation fine tune 20100430
 	//#Page1 Reg8 (CG_INITIAL_MASTER)
 	//0x1f, 0x0005,
 	//0x05, 0x83dd,
@@ -1352,47 +1461,47 @@ static const unsigned int phy_para[]={
 	//0x1f, 0x0005,
 	//0x05, 0x843d,
 	//0x06, 0x06f6 ,
-	
+
 	//#NC FIFO
 	0x1f,0x0007,//ExtPage
 	0x1e,0x0042,//ExtPage 66
 	0x18,0x0000,//Page 66 Reg 24 = 0x0000, NC FIFO (20100111)
 	0x1e,0x002D,//ExtPage 45
 	0x18,0xF010,//Page 45 Reg 24 = 0xF010, Enable Giga Down Shift to 100M (20100118)
-	
+
 	0x1e,0x002c, //#ExtPage 44
 	0x18,0x008B, //#Page 44 Reg 24 = 0x008B, Enable deglitch circuit (20100426)
-		
+
 	//############################ EEE giga patch ################################
-	
-	//0x1f 0x0007;   
+
+	//0x1f 0x0007;
 	0x1e,0x0028,
 	0x16,0xf640,//phywb $phyID 40 22 15-0 0xF640
-	
-	0x1e,0x0021,	
+
+	0x1e,0x0021,
 	0x19,0x2929,//phywb $phyID 33 25 15-0 0x2929
-	
+
 	0x1a,0x1005,//phywb $phyID 33 26 15-0 0x1005
-	
-	0x1e,0x0020,	
+
+	0x1e,0x0020,
 	0x17,0x000a,//phywb $phyID 32 23 15-0 0x000a
-	
+
 	0x1b,0x2f4a,//Disable EEE PHY mode
 	0x15,0x0100,//EEE ability, Disable EEEP
-	
+
 	0x1e,0x0040,//
 	0x1a,0x5110,//	phywb $phyID 64 26 15-0 0x5110
 	0x18,0x0000,// programable mode
-	
+
 	0x1e,0x0041,//
 	0x15,0x0e02,//phywb $phyID 65 21 15-0 0x0e02
-	
+
 	0x16,0x2185,//phywb $phyID 65 22 15-0 0x2185
 	0x17,0x000c,//phywb $phyID 65 23 15-0 0x000c
 	0x1c,0x0008,//phywb $phyID 65 28 15-0 0x0008
 	0x1e,0x0042,//
 	0x15,0x0d00,//phywb $phyID 66 21 15-0 0x0d00
-		
+
 	#if 1
 	//############################ EEE Run code patch #################################
 	//###proc 67R_ram_code_20100211_inrx_uc_98_1
@@ -1403,18 +1512,18 @@ static const unsigned int phy_para[]={
 	6,  0x0080,
 	5,  0x8b6e,
 	6,  0x0000,
-	15, 0x0100,	
-	
+	15, 0x0100,
+
 	//### force MDI/MDIX
 	0x1f, 0x0007,
 	0x1e, 0x002d,
 	0x18, 0xf030,
-	
+
 	//### pcs nctl patch code (0423)
-	0x1f, 0x0007,  
-	0x1e, 0x0023,    
-	0x16, 0x0005,    
-	
+	0x1f, 0x0007,
+	0x1e, 0x0023,
+	0x16, 0x0005,
+
 	//### startpoint
 	 0x15, 0x005c,
 	0x19, 0x0068,
@@ -1447,10 +1556,10 @@ static const unsigned int phy_para[]={
 	0x15, 0x01e0,
 	0x19, 0x0080,
 	//### endpoint
-	
-	0x16, 0x0000,    
-	//### end of pcs nctl patch code  	
-	
+
+	0x16, 0x0000,
+	//### end of pcs nctl patch code
+
 	//inrx
 	0x1f, 0x0007,
 	0x1e, 0x0040,
@@ -1459,7 +1568,7 @@ static const unsigned int phy_para[]={
 	0x17,0x2160,
 	0x1f,0x0007,
 	0x1e,0x0040,
-	
+
 	//### startpoint
 	0x18,0x0004,
 	0x19,0x4000,
@@ -2828,14 +2937,14 @@ static const unsigned int phy_para[]={
 	0x18,0x2a84,
 	0x19,0x4800,
 	//### endpoint
-	
+
 	0x1f,0x0000,
 	0x17,0x2100,
 	0x1f,0x0007,
 	0x1e,0x0040,
 	0x18,0x0000,
 	//### end of inrx dspctl patch code
-	
+
 	//### inrx eyesch patch code
 	0x1f,0x0007,
 	0x1e,0x0042,
@@ -2846,7 +2955,7 @@ static const unsigned int phy_para[]={
 	0x10,0xf25e,
 	0x1f,0x0007,
 	0x1e,0x0042,
-	
+
 	//### startpoint
 	0x15,0x0f00,
 	0x16,0x7408,
@@ -2877,7 +2986,7 @@ static const unsigned int phy_para[]={
 	0x15,0x0e06,
 	0x15,0x0f06,
 	//### endpoint
-	
+
 	0x1f, 0x0001,
 	0x10, 0xf05e,
 	0x1f, 0x0007,
@@ -2887,16 +2996,16 @@ static const unsigned int phy_para[]={
 	0x1f,0x0000,
 	0x17,0x2100,
 	//### end of inrx eyesch patch code
-	  		
+
 	//### release MDI/MDIX force mode
 	0x1f, 0x0007,
 	0x1e, 0x002d,
-	0x18, 0xf010,	
-	
+	0x18, 0xf010,
+
 	//### uc patch code (20110103 add foce giga mode)
 	0x1f,0x0005,
-	//### startpoint	
-	
+	//### startpoint
+
 	5, 0x8000,
 	6, 0xeeff,
 	6, 0xfc8b,
@@ -3519,21 +3628,21 @@ static const unsigned int phy_para[]={
 	6, 0x6f7a,
 	6, 0x06a6,
 	//### endpoint
-	                                  
-	//#unlock uc ramcode version                 
+
+	//#unlock uc ramcode version
 	5,  0xe142,
 	6,  0x0701,
 	5,  0xe140,
 	6,  0x0405,
 	15, 0x0000,
-	
+
 	//### end of uc patch code
 	//#Enable negear EEE Nway ability autooff
 	0x1f,0x0005,
 	0x05,0x8b84,
 	0x06,0x0026,
 	0x1f,0x0000,
-	
+
 	//#lpi patch code-maxod-20110103
 	31, 0x0007,
 	30, 0x0023,
@@ -3546,7 +3655,7 @@ static const unsigned int phy_para[]={
 	25, 0x26,
 	22, 0x0002,
 	31, 0x0000,
-	
+
 	//#Add by Gary for Channel Estimation fine tune 20100430
 	//#Page1 Reg8 (CG_INITIAL_MASTER)
 	0x1f, 0x0005,
@@ -3560,16 +3669,16 @@ static const unsigned int phy_para[]={
 	0x1f, 0x0005,
 	0x05, 0x843d,
 	0x06, 0x06f6 ,
-	
+
 	0x1f, 0x0000,
-	#endif				
+	#endif
 };
 
 static const unsigned int default_val[]={
 	999,0x1f,0x0002,
-	
+
 	2,0x11,0x7e00,
-	
+
 	3,0x1f,0x0002,
 	3,0x17,0xff00,
 	3,0x18,0x0005,
@@ -3577,7 +3686,7 @@ static const unsigned int default_val[]={
 	3,0x1a,0x0005,
 	3,0x1b,0x0005,
 	3,0x1c,0x0005,
-	
+
 	4,0x1f,0x0002,
 	4,0x13,0x00aa,
 	4,0x14,0x00aa,
@@ -3588,18 +3697,18 @@ static const unsigned int default_val[]={
 	4,0x19,0x50ab,
 	4,0x1a,0x0000,
 	4,0x1b,0x0f0f,
-	
+
 	999,0x1f,0x0000,
 };
-  
+
 void Setting_RTL8198_GPHY(void)
 {
 	int i=0, port =0, len=0;
-    
+
 	for(i=0; i<5; i++)
 		REG32(PCRP0+i*4) |= (EnForceMode);
 
-	if (REG32(BSP_REVR) == BSP_RTL8198_REVISION_A) 	
+	if (REG32(BSP_REVR) == BSP_RTL8198_REVISION_A)
 	{
 		/*
 		 #Access command format: phywb {all: phyID=0,1,2,3,4} {page} {RegAddr} {Bit location} {Bit value}
@@ -3613,77 +3722,77 @@ void Setting_RTL8198_GPHY(void)
 		*/
 
 		//	Set_GPHYWB(3, 2, 20, 0, 0x2000);
-	
+
 		Set_GPHYWB(999, 72, 21, 0, 0x7092);
 		Set_GPHYWB(999, 72, 22, 0, 0x7092);
 		Set_GPHYWB(999, 72, 23, 0, 0x7092);
 		Set_GPHYWB(999, 72, 24, 0, 0x7092);
-		Set_GPHYWB(999, 72, 25, 0, 0x7092);	
-		Set_GPHYWB(999, 72, 26, 0, 0x7092);	
-	
+		Set_GPHYWB(999, 72, 25, 0, 0x7092);
+		Set_GPHYWB(999, 72, 26, 0, 0x7092);
+
 		/*
 		 set PageNum 2; #All of GPHY register in the Page#2
 		 #Array format = {{PhyID List1}  {RegAddr1 RegData1 RegAddr2 RegData2}, ...}
-	
+
 		set AFE_Reg     {{0 1 2 3 4} { 0 0x0000 1  0x065a 2 0x8c01  3  0x0428 4 0x80c8  5   0x0978  6  0x0678 7  0x3620 8 0x0000 9 0x0007 10 0x0000}
 	       	               {2}         {11 0x0063 12 0xeb65 13 0x51d1 14 0x5dcb 15 0x3044 16 0x1000 17  0x7e00 18 0x0000}
 	              	        {3}         {19 0x3d22 20 0x2000 21 0x6040 22 0x0000 23 0xff00 24 0x0005 25 0x0005 26 0x0005 27 0x0005 28 0x0005}
 	                     	 {4}         {19 0x00aa 20 0x00aa 21 0x00aa 22 0x00aa 23 0x00aa 24 0x0f0a 25 0x5050 26 0x0000 27 0x0f0f }}
 		*/
-	
+
 	       //phyid=all
-		Set_GPHYWB(999, 2,  0, 0, 0x0000);  
-		Set_GPHYWB(999, 2,  1, 0, 0x065a);  
-		Set_GPHYWB(999, 2,  2, 0, 0x8c01);  
-		Set_GPHYWB(999, 2,  3, 0, 0x0428);  
-		Set_GPHYWB(999, 2,  4, 0, 0x80c8);  
-		Set_GPHYWB(999, 2,  5, 0, 0x0978);  
+		Set_GPHYWB(999, 2,  0, 0, 0x0000);
+		Set_GPHYWB(999, 2,  1, 0, 0x065a);
+		Set_GPHYWB(999, 2,  2, 0, 0x8c01);
+		Set_GPHYWB(999, 2,  3, 0, 0x0428);
+		Set_GPHYWB(999, 2,  4, 0, 0x80c8);
+		Set_GPHYWB(999, 2,  5, 0, 0x0978);
 		Set_GPHYWB(999, 2,  6, 0, 0x0678);
-		Set_GPHYWB(999, 2,  7, 0, 0x3620);	
-		Set_GPHYWB(999, 2,  8, 0, 0x0000);  
-		Set_GPHYWB(999, 2,  9, 0, 0x0007);  
-		Set_GPHYWB(999, 2,  10, 0, 0x0000);  
-	
+		Set_GPHYWB(999, 2,  7, 0, 0x3620);
+		Set_GPHYWB(999, 2,  8, 0, 0x0000);
+		Set_GPHYWB(999, 2,  9, 0, 0x0007);
+		Set_GPHYWB(999, 2,  10, 0, 0x0000);
+
 	       //phyid=2
-		Set_GPHYWB( 2,   2, 11, 0, 0x0063);	
-		Set_GPHYWB( 2,   2, 12, 0, 0xeb65);	
-		Set_GPHYWB( 2,   2, 13, 0, 0x51d1);	
-		Set_GPHYWB( 2,   2, 14, 0, 0x5dcb);	
-		Set_GPHYWB( 2,   2, 15, 0, 0x3044);	
-		Set_GPHYWB( 2,   2, 16, 0, 0x1000);		
-		Set_GPHYWB( 2,   2, 17, 0, 0x7e00);		
-		Set_GPHYWB( 2,   2, 18, 0, 0x0000);	
-		
+		Set_GPHYWB( 2,   2, 11, 0, 0x0063);
+		Set_GPHYWB( 2,   2, 12, 0, 0xeb65);
+		Set_GPHYWB( 2,   2, 13, 0, 0x51d1);
+		Set_GPHYWB( 2,   2, 14, 0, 0x5dcb);
+		Set_GPHYWB( 2,   2, 15, 0, 0x3044);
+		Set_GPHYWB( 2,   2, 16, 0, 0x1000);
+		Set_GPHYWB( 2,   2, 17, 0, 0x7e00);
+		Set_GPHYWB( 2,   2, 18, 0, 0x0000);
+
 	       //phyid=3
-		Set_GPHYWB( 3,   2, 19, 0, 0x3d22);	
-		Set_GPHYWB( 3,   2, 20, 0, 0x2000);	
-	   	Set_GPHYWB( 3,   2, 21, 0, 0x6040);	
-		Set_GPHYWB( 3,   2, 22, 0, 0x0000);		   
-		Set_GPHYWB( 3,   2, 23, 0, 0xff00);	
-		Set_GPHYWB( 3,   2, 24, 0, 0x0005);	
-		Set_GPHYWB( 3,   2, 25, 0, 0x0005);		
-		Set_GPHYWB( 3,   2, 26, 0, 0x0005);	
-		Set_GPHYWB( 3,   2, 27, 0, 0x0005);	
-		Set_GPHYWB( 3,   2, 28, 0, 0x0005);		
-	
+		Set_GPHYWB( 3,   2, 19, 0, 0x3d22);
+		Set_GPHYWB( 3,   2, 20, 0, 0x2000);
+	   	Set_GPHYWB( 3,   2, 21, 0, 0x6040);
+		Set_GPHYWB( 3,   2, 22, 0, 0x0000);
+		Set_GPHYWB( 3,   2, 23, 0, 0xff00);
+		Set_GPHYWB( 3,   2, 24, 0, 0x0005);
+		Set_GPHYWB( 3,   2, 25, 0, 0x0005);
+		Set_GPHYWB( 3,   2, 26, 0, 0x0005);
+		Set_GPHYWB( 3,   2, 27, 0, 0x0005);
+		Set_GPHYWB( 3,   2, 28, 0, 0x0005);
+
 	       //phyid=4
-		Set_GPHYWB( 4,   2, 19, 0, 0x00aa);	
-		Set_GPHYWB( 4,   2, 20, 0, 0x00aa);	
-		Set_GPHYWB( 4,   2, 21, 0, 0x00aa);	
-		Set_GPHYWB( 4,   2, 22, 0, 0x00aa);	
-		Set_GPHYWB( 4,   2, 23, 0, 0x00aa);	
-		Set_GPHYWB( 4,   2, 24, 0, 0x0f0a);	
-		Set_GPHYWB( 4,   2, 25, 0, 0x5050);	
-		Set_GPHYWB( 4,   2, 26, 0, 0x0000);	
-		Set_GPHYWB( 4,   2, 27, 0, 0x0f0f);			
-	
+		Set_GPHYWB( 4,   2, 19, 0, 0x00aa);
+		Set_GPHYWB( 4,   2, 20, 0, 0x00aa);
+		Set_GPHYWB( 4,   2, 21, 0, 0x00aa);
+		Set_GPHYWB( 4,   2, 22, 0, 0x00aa);
+		Set_GPHYWB( 4,   2, 23, 0, 0x00aa);
+		Set_GPHYWB( 4,   2, 24, 0, 0x0f0a);
+		Set_GPHYWB( 4,   2, 25, 0, 0x5050);
+		Set_GPHYWB( 4,   2, 26, 0, 0x0000);
+		Set_GPHYWB( 4,   2, 27, 0, 0x0f0f);
+
 		/*
-		 #=========== INRX Para. =================================                                                                 
-	
+		 #=========== INRX Para. =================================
+
 		 phywb all 0 21 0x1006
 	           #dfse_mode[15:14]=3(full), Fine tune aagc_lvl_fnet[10:0]
 	           phywb all 1 12 15-0 0xdbf0
-	           
+
 	           #cb0_i_giga[12:0]
 	           phywb all 1 9  15-0 0x2576
 	           phywb all 1 7  15-0 0x287E
@@ -3697,68 +3806,70 @@ void Setting_RTL8198_GPHY(void)
 	           phywb all 1 16 15-0 0xF05E
 	           phywb all 1 27 15-0 0xB414
 		*/
-	           
-		Set_GPHYWB( 999,   1, 12, 0, 0xdbf0);	
-	
-		Set_GPHYWB( 999,   1, 9, 0, 0x2576);	
-		Set_GPHYWB( 999,   1, 7, 0, 0x287E);	
-		Set_GPHYWB( 999,   1, 10, 0, 0x68E5);	
-		Set_GPHYWB( 999,   1, 29, 0, 0x3DA4);		
-		Set_GPHYWB( 999,   1, 28, 0, 0xE7F7);	
-		Set_GPHYWB( 999,   1, 20, 0, 0x7F52);	
-		Set_GPHYWB( 999,   1, 24, 0, 0x7FCE);	
-		Set_GPHYWB( 999,   1, 8, 0, 0x04B7);		
-		Set_GPHYWB( 999,   1, 6, 0, 0x4072);	
-		Set_GPHYWB( 999,   1, 16, 0, 0xF05E);	
-		Set_GPHYWB( 999,   1, 27, 0, 0xB414);		
-	
+
+		Set_GPHYWB( 999,   1, 12, 0, 0xdbf0);
+
+		Set_GPHYWB( 999,   1, 9, 0, 0x2576);
+		Set_GPHYWB( 999,   1, 7, 0, 0x287E);
+		Set_GPHYWB( 999,   1, 10, 0, 0x68E5);
+		Set_GPHYWB( 999,   1, 29, 0, 0x3DA4);
+		Set_GPHYWB( 999,   1, 28, 0, 0xE7F7);
+		Set_GPHYWB( 999,   1, 20, 0, 0x7F52);
+		Set_GPHYWB( 999,   1, 24, 0, 0x7FCE);
+		Set_GPHYWB( 999,   1, 8, 0, 0x04B7);
+		Set_GPHYWB( 999,   1, 6, 0, 0x4072);
+		Set_GPHYWB( 999,   1, 16, 0, 0xF05E);
+		Set_GPHYWB( 999,   1, 27, 0, 0xB414);
+
 		/*
 		 #=========== Cable Test =================================
-	
+
 		  phywb all 3 26 15-0 0x06A6
 		  phywb all 3 16 15-0 0xF05E
 		  phywb all 3 19 15-0 0x06EB
 		  phywb all 3 18 15-0 0xF4D2
 		  phywb all 3 14 15-0 0xE120
 		  phywb all 3 0  15-0 0x7C00
-	
+
 		  phywb all 3 2  15-0 0x5FD0
 		  phywb all 3 13 15-0 0x0207
-		 
-		  #disable jabber detect         
+
+		  #disable jabber detect
 		   phywb all 0 16 15-0 0x05EF
-	
+
 		  #Patch for EEE GMII issue
 		  phywb all 32 26 15-0 0x0103
 		  phywb all 32 22 15-0 0x0004
 		*/
-		Set_GPHYWB( 999,   3, 26, 0, 0x06A6);	 
-		Set_GPHYWB( 999,   3, 16, 0, 0xF05E);	
-		Set_GPHYWB( 999,   3, 19, 0, 0x06EB);	
-		Set_GPHYWB( 999,   3, 18, 0, 0xF4D2);	
-		Set_GPHYWB( 999,   3, 14, 0, 0xE120);	
-		Set_GPHYWB( 999,   3, 00, 0, 0x7C00);	
-		
-		Set_GPHYWB( 999,   3, 02, 0, 0x5FD0);	
-		Set_GPHYWB( 999,   3, 13, 0, 0x0207);	
-		
-		Set_GPHYWB( 999,   0, 16, 0, 0x05EF);	
-		
-		Set_GPHYWB( 999,   3, 26, 0, 0x0103);	
-		Set_GPHYWB( 999,   3, 22, 0, 0x0004);	
-	
-		/*	
+		Set_GPHYWB( 999,   3, 26, 0, 0x06A6);
+		Set_GPHYWB( 999,   3, 16, 0, 0xF05E);
+		Set_GPHYWB( 999,   3, 19, 0, 0x06EB);
+		Set_GPHYWB( 999,   3, 18, 0, 0xF4D2);
+		Set_GPHYWB( 999,   3, 14, 0, 0xE120);
+		Set_GPHYWB( 999,   3, 00, 0, 0x7C00);
+
+		Set_GPHYWB( 999,   3, 02, 0, 0x5FD0);
+		Set_GPHYWB( 999,   3, 13, 0, 0x0207);
+
+		Set_GPHYWB( 999,   0, 16, 0, 0x05EF);
+
+		Set_GPHYWB( 999,   3, 26, 0, 0x0103);
+		Set_GPHYWB( 999,   3, 22, 0, 0x0004);
+
+		/*
 		 disable aldps_en, for power measurement
 		 hywb all 44 21 15-0 0x0350
 		*/
-		Set_GPHYWB( 999,   44, 21, 0, 0x0350);	
+		Set_GPHYWB( 999,   44, 21, 0, 0x0350);
 	}
 	else
 	{
+		Set_GPHYWB(999, 0, 0, 0xffff-POWER_DOWN, POWER_DOWN); // set power down
+	
 		len=sizeof(default_val)/sizeof(unsigned int);
 		for(i=0;i<len;i=i+3)
-		{	
-		
+		{
+
 			if(default_val[i]==999)
 			{
 				for(port=0; port<5; port++)
@@ -3774,25 +3885,25 @@ void Setting_RTL8198_GPHY(void)
 		for(port=0; port<5; port++)
 		{
 			for(i=0;i<len;i=i+2)
-			{	
+			{
 				rtl8651_setAsicEthernetPHYReg(port, phy_para[i], phy_para[i+1]);
 			}
 		}
-		Set_GPHYWB( 999,   5, 5, 0, 0x8b84);		
-		Set_GPHYWB( 999,   5, 6, 0, 0x0006);		
+		Set_GPHYWB( 999,   5, 5, 0, 0x8b84);
+		Set_GPHYWB( 999,   5, 6, 0, 0x0006);
 		Set_GPHYWB( 999,   2, 8, 0, 0x0020);
 
 		// for the IOT issue with IC+ when EEE N-way.
 		Set_GPHYWB( 999,   172, 24, 0, 0x0006);
 
 #ifdef CONFIG_RTL_8198_ESD
-		Set_GPHYWB(999, 44, 27, 0xffff-(0xf<<12), 0x4<<12);	
-#endif		
+		Set_GPHYWB(999, 44, 27, 0xffff-(0xf<<12), 0x4<<12);
+#endif
 	}
 
-	for(i=0; i<5; i++)
-		REG32(PCRP0+i*4) &= ~(EnForceMode);
-	
+//	for(i=0; i<5; i++)
+//		REG32(PCRP0+i*4) &= ~(EnForceMode);
+
 	printk("==Set GPHY Parameter OK\n");
 }
 
@@ -3800,14 +3911,14 @@ int rtl8198_force_giga(int port)
 {
 	if (port < 0 || port > 4)
 		return 0;
-	
+
 	REG32(PCRP0+ port*4) |= (EnForceMode);
 
 	rtl8651_setAsicEthernetPHYReg(port, 31, 0x5);
 	rtl8651_setAsicEthernetPHYReg(port, 5, 0x8b86);
 	rtl8651_setAsicEthernetPHYReg(port, 6, 0x0040);
 	rtl8651_setAsicEthernetPHYReg(port, 31, 0x0);
-	
+
 	REG32(PCRP0+ port*4) = REG32(PCRP0+ port*4) & ~(EnForceMode | NwayAbility100MF | NwayAbility100MH | NwayAbility10MF | NwayAbility10MH); // disable Nway 10/100 ability
 
 	rtl8651_restartAsicEthernetPHYNway(port);
@@ -3818,14 +3929,14 @@ int rtl8198_disable_force(int port)
 {
 	if (port < 0 || port > 4)
 		return 0;
-	
+
 	REG32(PCRP0+ port*4) |= (EnForceMode);
 
 	rtl8651_setAsicEthernetPHYReg(port, 31, 0x5);
 	rtl8651_setAsicEthernetPHYReg(port, 5, 0x8b86);
 	rtl8651_setAsicEthernetPHYReg(port, 6, 0x0000);
 	rtl8651_setAsicEthernetPHYReg(port, 31, 0x0);
-	
+
 	REG32(PCRP0+ port*4) = (REG32(PCRP0+ port*4) & ~(EnForceMode)) | NwayAbility100MF | NwayAbility100MH | NwayAbility10MF | NwayAbility10MH; // enable Nway 10/100 ability
 
 	rtl8651_restartAsicEthernetPHYNway(port);
@@ -3834,7 +3945,7 @@ int rtl8198_disable_force(int port)
 
 #if defined(PORT5_RGMII_GMII)
 unsigned int ExtP5GigaPhyMode=0;
-void ProbeP5GigaPHYChip(void)	
+void ProbeP5GigaPHYChip(void)
 {
 	unsigned int uid,tmp;
 	unsigned int i;
@@ -3861,49 +3972,244 @@ void ProbeP5GigaPHYChip(void)
 	uid=uid | tmp;
 
 	if( uid==0x001CC912 )  //0x001cc912 is 8212 two giga port , 0x001cc940 is 8214 four giga port
-	{	
+	{
 		//printk("Find Port5   have 8211 PHY Chip! \r\n");
 		ExtP5GigaPhyMode=1;
 		//return 1;
-	}	
+	}
 	else
-	{	
+	{
 		//printk("NO Find Port5 8211 PHY Chip! \r\n");
 		//ExtP5GigaPhyMode=0;
 		//return 1;
-	}	
+	}
 	for(i=0; i<=5; i++)
 		REG32(PCRP0+i*4) &= ~(EnForceMode);
 
 }
 #endif
+
+void disable_phy_power_down(void)
+{
+	int i;
+	uint32 statCtrlReg0;
+
+	for (i=0; i<5; i++)
+	{
+		rtl8651_getAsicEthernetPHYReg( i, 0, &statCtrlReg0 );
+ 
+		statCtrlReg0 &= (~POWER_DOWN);
+ 
+		/* write PHY reg 0 */
+		rtl8651_setAsicEthernetPHYReg( i, 0, statCtrlReg0 );
+
+		REG32(PCRP0+i*4) &= ~(EnForceMode);
+	}
+}
 #endif
 
 int32 rtl865x_platform_check(void)
 {
-	uint32 bondOptReg=0;	
+	uint32 bondOptReg=0;
 	bondOptReg=REG32(0xB800000C);
 	if(((bondOptReg&0x0F)!=0x7) && ((bondOptReg&0x0F)!=0x9))
 	{
 		printk("current chip doesn't supported,system halt...\n");
-		while(1);		
+		while(1);
 	}
-	
+
 	return SUCCESS;
 }
 
+#if defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+unsigned int Get_P0_PhyMode(void)
+{
+	/*
+		00: External  phy
+		01: embedded phy
+		10: olt
+		11: deb_sel
+	*/
+	#define GET_BITVAL(v,bitpos,pat) ((v& ((unsigned int)pat<<bitpos))>>bitpos)
+	#define RANG1 1
+	#define RANG2 3
+	#define RANG3  7
+	#define RANG4 0xf
+
+	#define SYS_HW_STRAP   (0xb8000000 +0x08)
+
+	unsigned int v=REG32(SYS_HW_STRAP);
+	unsigned int mode=GET_BITVAL(v, 6, RANG1) *2 + GET_BITVAL(v, 7, RANG1);
+
+	return (mode&3);
+}
+
+unsigned int Get_P0_MiiMode(void)
+{
+	/*
+		0: MII-PHY
+		1: MII-MAC
+		2: GMII-MAC
+		3: RGMII
+	*/
+	#define GET_BITVAL(v,bitpos,pat) ((v& ((unsigned int)pat<<bitpos))>>bitpos)
+	#define RANG1 1
+	#define RANG2 3
+	#define RANG3  7
+	#define RANG4 0xf
+
+	#define SYS_HW_STRAP   (0xb8000000 +0x08)
+
+	unsigned int v=REG32(SYS_HW_STRAP);
+	unsigned int mode=GET_BITVAL(v, 27, RANG2);
+
+	return mode;
+}
+
+unsigned int Get_P0_RxDelay(void)
+{
+	#define GET_BITVAL(v,bitpos,pat) ((v& ((unsigned int)pat<<bitpos))>>bitpos)
+	#define RANG1 1
+	#define RANG2 3
+	#define RANG3  7
+	#define RANG4 0xf
+
+	#define SYS_HW_STRAP   (0xb8000000 +0x08)
+
+	unsigned int v=REG32(SYS_HW_STRAP);
+	unsigned int val=GET_BITVAL(v, 29, RANG3);
+	return val;
+}
+
+unsigned int Get_P0_TxDelay(void)
+{
+	#define GET_BITVAL(v,bitpos,pat) ((v& ((unsigned int)pat<<bitpos))>>bitpos)
+	#define RANG1 1
+	#define RANG2 3
+	#define RANG3  7
+	#define RANG4 0xf
+
+	#define SYS_HW_STRAP   (0xb8000000 +0x08)
+
+	unsigned int v=REG32(SYS_HW_STRAP);
+	unsigned int val=GET_BITVAL(v, 17, RANG1);
+	return val;
+}
+
+int Setting_RTL8197D_PHY(void)
+{
+	int i;
+
+	for(i=0; i<5; i++)
+		REG32(PCRP0+i*4) |= (EnForceMode);
+
+	/*
+	  page 	addr rtl8197d-default 	rtl8197d-new value Purpose
+	  0 		21 	0x02c5 			0x0232 			Green: up/low bond to 3/2
+	  0 		22 	0x5b85 			0x5bd5 			Green: ad current from 2 to 3
+	  1 		18 	0x901c 			0x9004 			finetune AOI waveform
+	  1 		19 	0x4400 			0x5400 			finetune 100M DAC current
+	  1 		25 	0x00da 			0x00d0 			enable pwdn10rx at pwr saving enable snr threshold = 18dB
+
+	  4 		16 	0x4007 			0x737f 			enable EEE, fine tune EEE parameter
+	  4 		24 	0xc0a0 			0xc0f3 			change EEE wake idle to 10us
+	  4 		25 	0x0130 			0x0730 			turn off tx/rx pwr at LPI state
+	*/
+
+	// only do the PHY setting in this revision IC, no need for the new one.
+	if (REG32(REVR) == 0x8197C000) {
+
+		Set_GPHYWB(999, 0, 21, 0, 0x0232);
+
+		/* purpose: to avoid 100M N-way link fail issue Set_p="1" */
+		Set_GPHYWB(999, 0, 22, 0, 0x5bd5);
+
+	 	/* purpose: to adjust AOI waveform */
+		Set_GPHYWB(999, 1, 18, 0, 0x9004);
+
+		/* purpose: to enhance ethernet 100Mhz output voltage about 1.0(v) */
+		Set_GPHYWB(999, 1, 19, 0, 0x5400);
+
+		Set_GPHYWB(999, 1, 25, 0, 0x00d0);  //enable pwdn10rx at pwr saving enable snr threshold = 18dB
+
+		Set_GPHYWB(999, 4, 16, 0, 0x737f);// enable EEE, fine tune EEE parameter
+		Set_GPHYWB(999, 4, 24, 0, 0xc0f3);	//change EEE wake idle to 10us
+		Set_GPHYWB(999, 4, 25, 0, 0x0730);	 // turn off tx/rx pwr at LPI state
+	}
+
+	/* fine tune port on/off threshold to 160/148 */
+	REG32(PBFCR0) = 0x009400A0;
+	REG32(PBFCR1) = 0x009400A0;
+	REG32(PBFCR2) = 0x009400A0;
+	REG32(PBFCR3) = 0x009400A0;
+	REG32(PBFCR4) = 0x009400A0;
+	REG32(PBFCR6) = 0x009400A0;
+
+	/* modify egress leaky bucket parameter, default inaccuracy is 5~10%, the new one is 1~2% after modification */
+	REG32(ELBPCR) = 0x0000400B;
+	REG32(ELBTTCR) = 0x000000C0;
+
+	/* Fine tune minRx IPG from 6 to 5 byte */
+	REG32(MACCR) = 0x80420185;
+
+	/* default enable MAC EEE */
+	REG32(EEECR) = 0x28739ce7;
+
+	for(i=0; i<5; i++)
+		REG32(PCRP0+i*4) &= ~(EnForceMode);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_RTL_8196E
+int Setting_RTL8196E_PHY(void)
+{
+	int i;
+
+	for(i=0; i<5; i++)
+		REG32(PCRP0+i*4) |= (EnForceMode);
+
+	// write page1, reg16, bit[15:13] Iq Current 110:175uA (default 100: 125uA)
+	Set_GPHYWB(999, 1, 16, 0xffff-(0x7<<13), 0x6<<13);
+
+	// disable power saving mode in A-cut only
+	if (REG32(REVR) == 0x8196e000)
+		Set_GPHYWB(999, 0, 0x18, 0xffff-(1<<15), 0<<15);
+
+	/* B-cut and later,
+	    just increase a little power in long RJ45 cable case for Green Ethernet feature.
+	 */
+	else 
+	{
+		// adtune_lb setting
+		Set_GPHYWB(999, 0, 22, 0xffff-(0x7<<4), 0x4<<4);
+		//Setting SNR lb and hb
+		Set_GPHYWB(999, 0, 21, 0xffff-(0xff<<0), 0xc2<<0);
+		//auto bais current
+		Set_GPHYWB(999, 1, 19, 0xffff-(0x1<<0), 0x0<<0);
+		Set_GPHYWB(999, 0, 22, 0xffff-(0x1<<3), 0x0<<3);
+	}
+	
+	for(i=0; i<5; i++)
+		REG32(PCRP0+i*4) &= ~(EnForceMode);
+
+	return 0;
+}
+#endif
+
 /*patch for LED showing*/
 #define BICOLOR_LED 1
 /*=========================================
   * init Layer2 Asic
   * rtl865x_initAsicL2 mainly configure basic&L2 Asic.
   * =========================================*/
-int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para) 
+int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
 {
 	int32 index;
 
 #ifdef BICOLOR_LED
-#if defined (CONFIG_RTL_8196C) || defined(CONFIG_RTL_8198)
+#if defined (CONFIG_RTL_8196C) || defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 #else
 	unsigned int hw_val;
 #endif
@@ -4001,7 +4307,7 @@ int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
 
 		/*
 			# According to Hardware SD: David & Maxod,
-			
+
 			Set Port5_GMII Configuration Register.
 			- RGMII Output Timing compensation control : 0 ns
 			- RGMII Input Timing compensation control : 0 ns
@@ -4018,7 +4324,7 @@ int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
 
 		/*
 			# According to Hardware SD: David & Maxod,
-			
+
 			Set Port5_GMII Configuration Register.
 			- RGMII Output Timing compensation control : 0 ns
 			- RGMII Input Timing compensation control : 0 ns
@@ -4029,13 +4335,19 @@ int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
 #ifdef CONFIG_RTL8196C_REVISION_B
 	if (REG32(REVR) == RTL8196C_REVISION_B)
 		Setting_RTL8196C_PHY();
-	
+
+#elif defined(CONFIG_RTL_8196E)
+	Setting_RTL8196E_PHY();
+
+#elif defined(CONFIG_RTL_819XD)
+	Setting_RTL8197D_PHY();
+
 #elif defined(CONFIG_RTL_8198)
 #if 0//def PORT5_RGMII_GMII
 	ProbeP5GigaPHYChip();
 #endif
+
 	Setting_RTL8198_GPHY();
-	
 #endif
 
 #ifdef CONFIG_8198_PORT5_RGMII
@@ -4054,7 +4366,7 @@ int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
 	GPIO_PORT_I,
 	GPIO_PORT_MAX,
 	};
-	
+
 	#define REG_IOCFG_GPIO		0x00000018
 
 	extern int32 smi_init(uint32 port, uint32 pinSCK, uint32 pinSDA);
@@ -4068,13 +4380,13 @@ int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
 	WRITE_MEM32(PABCD_DIR, READ_MEM32(PABCD_DIR) | ((0x0000000C))); //output pin
 
 	smi_init(GPIO_PORT_A, 3, 2);
-	
+
 	RTL8370_init();
 	}
 #endif
 
 	/* 	2006.12.12
-		We turn on bit.10 (ENATT2LOG). 
+		We turn on bit.10 (ENATT2LOG).
 
 		* Current implementation of unnumbered pppoe in multiple session
 		When wan type is multiple-session, and one session is unnumbered pppoe, WAN to unnumbered LAN is RP --> NPI.
@@ -4082,11 +4394,11 @@ int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
 
 		However, when pktOpApp of this ACL rule is set, it seems that this toCPU ACL does not work.
 		Therefore, we turn on this bit (ENATT2LOG) to trap pkts (WAN --> unnumbered LAN) to CPU.
-		
+
 	*/
 	WRITE_MEM32( SWTCR1, READ_MEM32( SWTCR1 ) | EnNATT2LOG );
 
-	/* 
+	/*
 	  * Turn on ENFRAG2ACLPT for Rate Limit. For those packets which need to be trapped to CPU, we turn on
 	  * this bit to tell ASIC ACL and Protocol Trap to process these packets. If this bit is not turnned on, packets
 	  * which need to be trapped to CPU will not be processed by ASIC ACL and Protocol Trap.
@@ -4094,19 +4406,19 @@ int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
 	  *																- chhuang
 	  */
 	WRITE_MEM32( SWTCR1, READ_MEM32( SWTCR1 ) | ENFRAGTOACLPT );
-	
+
 #ifdef CONFIG_RTL865X_LIGHT_ROMEDRV
 	WRITE_MEM32( SWTCR1, READ_MEM32( SWTCR1 ) | L4EnHash1 );    /*Turn on Napt Enhanced hash1*/
 #endif
 
-	/* 
+	/*
 	  * Cannot turn on EnNAP8651B due to:
 	  * If turn on, NAT/LP/ServerPort will reference nexthop. This will result in referecing wrong L2 entry when
 	  * the destination host is in the same subnet as WAN.
 	  */
 
 
-	/*Although chip is in 8650 compatible mode, 
+	/*Although chip is in 8650 compatible mode,
 	some 865XB features are independent to compatibility register*/
 	/*Initialize them here if needed*/
 
@@ -4114,7 +4426,7 @@ int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
 		 int rev;
 		char chipVersion[16];
 		rtl8651_getChipVersion(chipVersion, sizeof(chipVersion), &rev);
-		if(chipVersion[strlen(chipVersion)-1]=='B' 
+		if(chipVersion[strlen(chipVersion)-1]=='B'
 			|| chipVersion[strlen(chipVersion) - 1] == 'C' )
 		{
 			rtl8651_totalExtPortNum=3; //this replaces all RTL8651_EXTPORT_NUMBER defines
@@ -4123,7 +4435,7 @@ int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
 			rtl8651_asicEthernetCableMeterInit();
 #endif
 		}
-		
+
 	}
 	//Disable layer2, layer3 and layer4 function
 	//Layer 2 enabled automatically when a VLAN is added
@@ -4157,15 +4469,30 @@ int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
 #if defined(CONFIG_RTL8186_KB) && defined(CONFIG_RTL8186_KB_N)
     hw_val = read_gpio_hw_setting();
     REG32(PIN_MUX_SEL) =0x0fffff80;/*For Belkin_n board, not for demo board*/
-    REG32(LEDCREG)=0; 
-#else
-#if defined (CONFIG_RTL_8196C) || defined(CONFIG_RTL_8198)
+    REG32(LEDCREG)=0;
+
+#elif defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+	/*
+		#LED = direct mode
+		set mode 0x0
+		swwb 0xbb804300 21-20 0x2 19-18 $mode 17-16 $mode 15-14 $mode 13-12 $mode 11-10 $mode 9-8 $mode
+	*/
+	#ifdef 	CONFIG_RTK_VOIP_BOARD	
+	//for GMII/RGMII
+	//REG32(PIN_MUX_SEL) &= ~( (3<<8) | (3<<10) | (3<<3) | (1<<15) );  //let P0 to mii mode
+	REG32(PIN_MUX_SEL2) &= ~ ((3<<0) | (3<<3) | (3<<6) | (3<<9) | (3<<12) );  //LED0~LED4
+	#else
+	REG32(PIN_MUX_SEL) &= ~( (3<<8) | (3<<10) | (3<<3) | (1<<15) );  //let P0 to mii mode
+	REG32(PIN_MUX_SEL2) &= ~ ((3<<0) | (3<<3) | (3<<6) | (3<<9) | (3<<12) | (7<<15) );  //S0-S3, P0-P1
+	#endif
+	REG32(LEDCREG)  = (2<<20) | (0<<18) | (0<<16) | (0<<14) | (0<<12) | (0<<10) | (0<<8);  //P0-P5
+
+#elif defined (CONFIG_RTL_8196C) || defined(CONFIG_RTL_8198)
 #else
     hw_val = read_gpio_hw_setting();
     REG32(PIN_MUX_SEL) =0x00000380;
     REG32(LEDCREG)=0;
 #endif
-#endif
 #else
      hw_val = read_gpio_hw_setting();
     if (hw_val == 0x2 || hw_val == 0x3 || hw_val == 0x6 || hw_val == 0x7)  // LED in matrix mode
@@ -4195,12 +4522,15 @@ int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
     #endif /* BICOLOR_LED_VENDOR_BXXX */
 #endif
 #endif
+
+#if !defined(CONFIG_RTL_819XD) && !defined(CONFIG_RTL_8196E)
 	//MAC Control (0xBC803000)
 /*	WRITE_MEM32(MACCR,READ_MEM32(MACCR)&~DIS_IPG);//Set IFG range as 96+-4bit time*/
 	WRITE_MEM32(MACCR,READ_MEM32(MACCR)&~NORMAL_BACKOFF);//Normal backoff
 	WRITE_MEM32(MACCR,READ_MEM32(MACCR)&~BACKOFF_EXPONENTIAL_3);//Exponential parameter is 9
 	WRITE_MEM32(MACCR,READ_MEM32(MACCR)|INFINITE_PAUSE_FRAMES);//send pause frames infinitely.
 	WRITE_MEM32(MACCR,READ_MEM32(MACCR)|DIS_MASK_CGST);
+#endif
 
 	miiPhyAddress = -1;		/* not ready to use mii port 5 */
 
@@ -4260,7 +4590,7 @@ int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
 	if(RTL865X_PHY6_DSP_BUG)
 		WRITE_MEM32(PCRP6, (6<<ExtPHYID_OFFSET)|AcptMaxLen_16K|EnablePHYIf );
 	/* Set PHYID 6 to PCRP6. (By default, PHYID of PCRP6 is 0. It will collide with PHYID of port 0. */
-#endif	
+#endif
 
 
 
@@ -4306,26 +4636,26 @@ int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
 	WRITE_MEM32(MISCCR,READ_MEM32(MISCCR)&~MULTICAST_L2_MTU_MASK);
 	WRITE_MEM32(MISCCR,READ_MEM32(MISCCR)|(1522&MULTICAST_L2_MTU_MASK));//Multicast packet layer2 size 1522 at most*/
 	/* follow RTL865xB's convention, we use 1522 as default multicast MTU */
-	
+
 	/*FIXME:Hyking init in Layer3 1*/
 	//rtl8651_setAsicMulticastMTU(1522);
 
 	//Set all Protocol-Based Reg. to 0
 
 	for (index=0;index<32;index++)
-		WRITE_MEM32(PBVCR0+index*4,  0x00000000);	
+		WRITE_MEM32(PBVCR0+index*4,  0x00000000);
 	//Enable TTL-1
 	/*FIXME:Hyking init in Layer3 1*/
 	//WRITE_MEM32(TTLCR,READ_MEM32(TTLCR)|(uint32)EN_TTL1);//Don't hide this router. enable TTL-1 when routing on this gateway.
 
-	
+
 	for (index=0; index<RTL8651_PORT_NUMBER+rtl8651_totalExtPortNum; index++) {
 
-		
-		
+
+
 		if(	rtl8651_setAsicMulticastSpanningTreePortState(index, RTL8651_PORTSTA_FORWARDING))
 			return FAILED;
-		
+
 		rtl865xC_setAsicSpanningTreePortState(index, RTL8651_PORTSTA_FORWARDING);
 
 		rtl8651_setAsicEthernetBandwidthControl(index, TRUE, RTL8651_BC_FULL);
@@ -4349,11 +4679,11 @@ int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
 		/* Sync the configuration to ASIC */
 		_rtl8651_syncToAsicEthernetBandwidthControl();
 	}
-	
+
 
 
 	/* ==================================================================================================
-		Embedded PHY patch -- According to the designer, internal PHY's parameters need to be adjusted. 
+		Embedded PHY patch -- According to the designer, internal PHY's parameters need to be adjusted.
 	 ================================================================================================== */
 	if(RTL865X_PHY6_DSP_BUG) /*modified by Mark*/
 	{
@@ -4377,14 +4707,14 @@ int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
 #endif
 
 		for ( port = 0 ; port < maxPort ; port ++ )
-		{	
-		
+		{
+
 #if defined(RTL8196C_EEE_MAC)
 			if (eee_enabled) {
-				uint32 reg; 		
+				uint32 reg;
 				eee_phy_enable_by_port(port);
 
-				if (REG32(REVR) == RTL8196C_REVISION_B) {
+				if (REG32(REVR) >= RTL8196C_REVISION_B) {
 					// enable EEE MAC
 					reg = REG32(EEECR);
 //					REG32(EEECR) = (reg & ~(0x1f << (port * 5)) )
@@ -4403,7 +4733,7 @@ int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
 		if (eee_enabled == 0) {
 			REG32(EEECR) = 0;
 		}
-		#elif defined(CONFIG_RTL_8198)
+		#elif defined(CONFIG_RTL_8198) && !defined(CONFIG_RTL_819XD)
 		if (eee_enabled) {
 			eee_phy_enable_98();
 		}
@@ -4414,10 +4744,10 @@ int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
 	}
 
 
-	
+
 	/* ===============================
 	 	(1) Handling port 0.
-	    =============================== */	
+	    =============================== */
 	rtl8651_restartAsicEthernetPHYNway(0);	/* Restart N-way of port 0 to let embedded phy patch take effect. */
 
 	/* ===============================
@@ -4425,7 +4755,7 @@ int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
 	    =============================== */
 	if (rtl8651_tblAsicDrvPara.externalPHYProperty & RTL8651_TBLASIC_EXTPHYPROPERTY_PORT1234_RTL8212)
 	{
-		
+
 	} else
 	{
 		/* Restart N-way of port 1 - port 4 to let embedded phy patch take effect. */
@@ -4446,7 +4776,7 @@ int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
 
 
 	/* =====================
-		QoS-related patch 
+		QoS-related patch
 	    ===================== */
 	{
 		#define DEFAULT_ILB_UBOUND 0x3FBE  /*added by Mark for suggested Leacky Bucket value*/
@@ -4460,7 +4790,7 @@ int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
 		WRITE_MEM32( ILBPCR1, DEFAULT_ILB_UBOUND << UpperBound_OFFSET | DEFAULT_ILB_LBOUND << LowerBound_OFFSET );
 		for(i=0;i<=(RTL8651_PHY_NUMBER/2);i++) /*Current Token Register is 2 bytes per port*/
 			WRITE_MEM32( ILB_CURRENT_TOKEN + 4*i , DEFAULT_ILB_UBOUND << UpperBound_OFFSET | DEFAULT_ILB_UBOUND );
-		
+
 	}
 
 	#if defined(CONFIG_RTL_HW_QOS_SUPPORT)
@@ -4472,7 +4802,7 @@ int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
 		Init QUEUE Number configuration for RTL865xC : For Port 0~5 and CPU Port - All ports have 1 queue for each.
 	*/
 	{
-#if 1
+#if !defined(CONFIG_RTL_819XD	) && !defined(CONFIG_RTL_8196E)
 	/*	The default value was just as same as what we want	*/
 		rtl865xC_lockSWCore();
 
@@ -4504,7 +4834,7 @@ int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
 					*/
 					rtl8651_setAsicQueueFlowControlConfigureRegister( port, queue, FALSE);
 					#endif
-				}	
+				}
 			}
 		}
 
@@ -4512,7 +4842,6 @@ int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
 		rtl8651_resetAsicOutputQueue();
 		rtl865xC_unLockSWCore();
 #endif
-		
 		/* DSP bug (PHY-ID for DSP controller is set same as PHY 0 ) in RTL865xC A-Cut */
 		if(RTL865X_PHY6_DSP_BUG)
 		/* correct the default value of input queue flow control threshold */
@@ -4532,8 +4861,11 @@ int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
 		rtl8651_setAsicPriorityDecision(2, 1, 1, 1, 1);
 
 		WRITE_MEM32(PBPCR, 0);
+
+#if !defined(CONFIG_RTL_819XD	) && !defined(CONFIG_RTL_8196E)
 		/* Set the threshold value for qos sytem */
 		_rtl865x_setQosThresholdByQueueIdx(QNUM_IDX_123);
+#endif
 
 	/*	clear dscp priority assignment, otherwise, pkt with dscp value 0 will be assign priority 1		*/
 		WRITE_MEM32(DSCPCR0,0);
@@ -4542,9 +4874,9 @@ int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
 		WRITE_MEM32(DSCPCR3,0);
 		WRITE_MEM32(DSCPCR4,0);
 		WRITE_MEM32(DSCPCR5,0);
-		WRITE_MEM32(DSCPCR6,0);			
+		WRITE_MEM32(DSCPCR6,0);
 	}
-			
+
 
 #if defined(RTL865X_TEST) || defined(RTL865X_MODEL_USER)
 #if defined(VERA)||defined(VSV)||defined(MIILIKE)
@@ -4554,12 +4886,12 @@ int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
 	memset( &naptIcmp, 0, sizeof(naptIcmp) );
 	naptIcmp.isCollision = 1;
 	for(flowTblIdx=0; flowTblIdx<RTL8651_ICMPTBL_SIZE; flowTblIdx++)
-		rtl8651_setAsicNaptIcmpTable( TRUE, flowTblIdx, &naptIcmp );	
+		rtl8651_setAsicNaptIcmpTable( TRUE, flowTblIdx, &naptIcmp );
 #endif
 #endif
 
-#if 1  
-#if defined(CONFIG_RTL_8198_NFBI_BOARD) 
+#if 1
+#if defined(CONFIG_RTL_8198_NFBI_BOARD)
     //WRITE_MEM32(PIN_MUX_SEL_2, 0); //for led control
 
 	REG32(PCRP0) &= (0xFFFFFFFF-(0x00000000|MacSwReset));
@@ -4575,30 +4907,38 @@ int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
 	REG32(PCRP3) = REG32(PCRP3) | (3 << ExtPHYID_OFFSET) | EnablePHYIf | MacSwReset;
 	REG32(PCRP4) = REG32(PCRP4) | (4 << ExtPHYID_OFFSET) | EnablePHYIf | MacSwReset;
 
-	//port5 STP forwarding?	
+	//port5 STP forwarding?
 	REG32(PITCR) = REG32(PITCR) & 0xFFFFF3FF; //configure port 5 to be a MII interface
 	rtl865xC_setAsicEthernetMIIMode(5, LINK_MII_PHY); //port 5 MII PHY mode
 	REG32(P5GMIICR) = REG32(P5GMIICR) | 0x40; //Conf_done=1
-	
+
 #if defined(RTL8198_NFBI_PORT5_GMII) //GMII mode
            #define GMII_PIN_MUX 0xc0
            REG32(PIN_MUX_SEL)= REG32(PIN_MUX_SEL)&(~(GMII_PIN_MUX));
 	REG32(PCRP5) = 0 | (0x10<<ExtPHYID_OFFSET) |
 			EnForceMode| ForceLink|ForceSpeed1000M|ForceDuplex |
-			MIIcfg_RXER | EnablePHYIf | MacSwReset; 
+			MIIcfg_RXER | EnablePHYIf | MacSwReset;
 #else //MII mode
 	REG32(PCRP5) = 0 | (0x10<<ExtPHYID_OFFSET) |
 			EnForceMode| ForceLink|ForceSpeed100M |ForceDuplex |
-			MIIcfg_RXER | EnablePHYIf | MacSwReset; 
+			MIIcfg_RXER | EnablePHYIf | MacSwReset;
 #endif
 
-#elif defined(CONFIG_RTL_8198) 
+#elif defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 	#define GMII_PIN_MUX 0xf00
        #if defined(CONFIG_8198_PORT5_GMII) || defined(CONFIG_8198_PORT5_RGMII)
            REG32(PIN_MUX_SEL)= REG32(PIN_MUX_SEL)&(~(GMII_PIN_MUX));
        #endif
 	//WRITE_MEM32(PIN_MUX_SEL_2, 0);
 
+#ifdef CONFIG_RTK_VOIP_GIGABYTE_PHY_LINK_MODE_100 // use 10/100 only
+       WRITE_MEM32(PCRP0, READ_MEM32(PCRP0) & ~(1<<22));
+       WRITE_MEM32(PCRP1, READ_MEM32(PCRP1) & ~(1<<22));
+       WRITE_MEM32(PCRP2, READ_MEM32(PCRP2) & ~(1<<22));
+       WRITE_MEM32(PCRP3, READ_MEM32(PCRP3) & ~(1<<22));
+       WRITE_MEM32(PCRP4, READ_MEM32(PCRP4) & ~(1<<22));
+#endif
+
        WRITE_MEM32(PCRP0, READ_MEM32(PCRP0) & ~MacSwReset);
        WRITE_MEM32(PCRP1, READ_MEM32(PCRP1) & ~MacSwReset);
        WRITE_MEM32(PCRP2, READ_MEM32(PCRP2) & ~MacSwReset);
@@ -4610,7 +4950,7 @@ int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
        WRITE_MEM32(PCRP2, READ_MEM32(PCRP2) | ((2<<ExtPHYID_OFFSET)|EnablePHYIf|MacSwReset) ); /* Jumbo Frame */
        WRITE_MEM32(PCRP3, READ_MEM32(PCRP3) | ((3<<ExtPHYID_OFFSET)|EnablePHYIf|MacSwReset) ); /* Jumbo Frame */
        WRITE_MEM32(PCRP4, READ_MEM32(PCRP4) | ((4<<ExtPHYID_OFFSET)|EnablePHYIf|MacSwReset) ); /* Jumbo Frame */
-		
+
 #if defined(PORT5_RGMII_GMII)
 		if(ExtP5GigaPhyMode)
 		{
@@ -4648,6 +4988,98 @@ int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
 	Set_GPHYWB(999, 0, 9, 0, 0);
 #endif
 
+#if defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+	{
+	#define REG32_ANDOR(x,y,z)   (REG32(x)=(REG32(x)& (y))|(z))
+
+#if defined(CONFIG_RTL_8211DS_SUPPORT)&&defined(CONFIG_RTL_8197D)
+	int i;
+	uint32 reg_tmp=0;
+#endif
+
+	//unsigned int rtl96d_P0phymode=Get_P0_PhyMode();
+	unsigned int rtl96d_P0phymode=1;
+
+#if defined(CONFIG_RTL_8211DS_SUPPORT)&&defined(CONFIG_RTL_8197D)
+	rtl96d_P0phymode = 3;
+#endif
+
+	if(rtl96d_P0phymode==1)  //embedded phy
+	{
+		REG32(PCRP0) |=  (0 << ExtPHYID_OFFSET) | EnablePHYIf | MacSwReset;	//emabedded
+	}
+	else //external phy
+	{
+		unsigned int rtl96d_P0miimode=Get_P0_MiiMode();
+
+	#if defined(CONFIG_RTL_8211DS_SUPPORT)&&defined(CONFIG_RTL_8197D)
+		rtl96d_P0miimode = 3;
+	#endif
+
+		REG32(PCRP0) |=  (0x10 << ExtPHYID_OFFSET) | MIIcfg_RXER |  EnablePHYIf | MacSwReset;	//external
+
+		if(rtl96d_P0miimode==0)
+			REG32_ANDOR(P0GMIICR, ~(3<<23)  , LINK_MII_PHY<<23);
+		else if(rtl96d_P0miimode==1)
+			REG32_ANDOR(P0GMIICR, ~(3<<23)  , LINK_MII_MAC<<23);
+		else if(rtl96d_P0miimode==2)
+			REG32_ANDOR(P0GMIICR, ~(3<<23)  , LINK_MII_MAC<<23);  //GMII
+		else if(rtl96d_P0miimode==3)
+			REG32_ANDOR(P0GMIICR, ~(3<<23)  , LINK_RGMII<<23);
+
+		if(rtl96d_P0miimode==3)
+		{
+			unsigned int rtl96d_P0txdly=Get_P0_TxDelay();
+			unsigned int rtl96d_P0rxdly=Get_P0_RxDelay();
+			REG32_ANDOR(P0GMIICR, ~((1<<4)|(3<<0)) , (rtl96d_P0txdly<<4) | (rtl96d_P0rxdly<<0) );
+
+			#if defined(CONFIG_RTL_8211DS_SUPPORT)&&defined(CONFIG_RTL_8197D)
+				//Set GPIOC0 to PHY reset.
+				REG32_ANDOR(0xb8000044, 0xFFFFFFFF, (1<<20));
+				REG32_ANDOR(0xb8003500, ~(1<<16), 0);
+				REG32_ANDOR(0xb8003508, 0xFFFFFFFF, (1<<16));
+				REG32_ANDOR(0xb800350c, ~(1<<16), 0); //Set Reset to low
+
+				REG32(0xbb804104) &=0x3FFFFFF;
+				REG32(0xbb804104) |=0x18FF0000;	//set PCR0 phyid
+				REG32(0xbb80414c) =0x37d55;			//set port MII
+				REG32(0xbb804100) =0x1;
+
+				for(i=0; i<5; i++)
+					REG32(PCRP0+i*4) |= (EnForceMode);
+
+				REG32_ANDOR(0xb800350c, 0xFFFFFFFF, (1<<16));//Set Reset to high
+				mdelay(30);
+				//__delay(50000);
+
+				rtl8651_getAsicEthernetPHYReg(0x6, 0, &reg_tmp);//Learning PHY ID
+
+				for(i=0; i<5; i++)
+					REG32(PCRP0+i*4) &= ~(EnForceMode);
+			#endif
+		}
+
+		if(rtl96d_P0miimode==0)
+			REG32_ANDOR(PCRP0, ~AutoNegoSts_MASK, EnForceMode| ForceLink|ForceSpeed100M |ForceDuplex) ;
+		else if(rtl96d_P0miimode==1)
+			REG32_ANDOR(PCRP0, ~AutoNegoSts_MASK, EnForceMode| ForceLink|ForceSpeed100M |ForceDuplex) ;
+		else if(rtl96d_P0miimode==2)
+			REG32_ANDOR(PCRP0, ~AutoNegoSts_MASK, EnForceMode| ForceLink|ForceSpeed1000M |ForceDuplex );
+		#if !defined(CONFIG_RTL_8211DS_SUPPORT)
+		else if(rtl96d_P0miimode==3)
+			REG32_ANDOR(PCRP0, ~AutoNegoSts_MASK, EnForceMode| ForceLink|ForceSpeed1000M |ForceDuplex );
+		#endif
+
+		REG32(P0GMIICR) |=(Conf_done);
+		REG32(PITCR) |= (1<<0);   //00: embedded , 01L GMII/MII/RGMII
+
+		if((rtl96d_P0miimode==2)  ||(rtl96d_P0miimode==3)) {
+			REG32(MACCR) |= (1<<12);   //giga link
+		}
+	}
+	}
+#endif
+
 #elif defined(CONFIG_RTL_8196C)
     WRITE_MEM32(PCRP0, (READ_MEM32(PCRP0)&(0xFFFFFFFF-(0x00400000|MacSwReset))) );
 	TOGGLE_BIT_IN_REG_TWICE(PCRP0,EnForceMode);
@@ -4677,14 +5109,14 @@ int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
     WRITE_MEM32(PCRP2, (READ_MEM32(PCRP2)|(rtl8651AsicEthernetTable[2].phyId<<ExtPHYID_OFFSET)|EnablePHYIf ) ); /* Jumbo Frame */
     WRITE_MEM32(PCRP3, (READ_MEM32(PCRP3)|(rtl8651AsicEthernetTable[3].phyId<<ExtPHYID_OFFSET)|EnablePHYIf ) ); /* Jumbo Frame */
     WRITE_MEM32(PCRP4, (READ_MEM32(PCRP4)|(rtl8651AsicEthernetTable[4].phyId<<ExtPHYID_OFFSET)|EnablePHYIf ) ); /* Jumbo Frame */
-#endif 
+#endif
+
 
-			
     if (rtl8651_tblAsicDrvPara.externalPHYProperty & RTL8651_TBLASIC_EXTPHYPROPERTY_PORT5_RTL8211B)
     {
         WRITE_MEM32(PCRP5, ( (READ_MEM32(PCRP5))|(rtl8651AsicEthernetTable[5].phyId<<ExtPHYID_OFFSET)|EnablePHYIf ) ); /* Jumbo Frame */
     }
- 
+
 #if 0  /* No need to set PHYID of port 6. Just use ASIC default value. */
        /*  Due to MSb of phyid has been added an inverter in b-cut,
          *  although we want to set 6(0b00110) as phyid, we have to write 22(0b10110) instead. */
@@ -4698,11 +5130,11 @@ int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
 #if defined(CONFIG_RTL865X_DIAG_LED)
 	/* diagnosis led (gpio-porta-6) on */
 	/* pull high by set portA-0(bit 30) as gpio-output-1, meaning: diag led OFF */
-	REG32(PABDAT) |=  0x40000000; 
+	REG32(PABDAT) |=  0x40000000;
 #endif /* CONFIG_RTL865X_DIAG_LED */
 
 #if !defined(CONFIG_RTL_8196C) && !defined(CONFIG_RTL_8198)
-	REG32(MDCIOCR) = 0x96181441;	// enable Giga port 8211B LED
+	//REG32(MDCIOCR) = 0x96181441;	// enable Giga port 8211B LED
 #endif
 
 	/*disable pattern match*/
@@ -4735,19 +5167,52 @@ int32 rtl865x_initAsicL2(rtl8651_tblAsic_InitPara_t *para)
 	// Configure LED-SIG0/LED-SIG1/LED-SIG2/LED-SIG3/LED-PHASE0/LED-PHASE1/LED-PHASE2/LED-PHASE3 PAD as LED-SW
 
 #ifndef CONFIG_POCKET_ROUTER_SUPPORT
-	REG32(PIN_MUX_SEL) &= ~(0xFFFF);	
+	REG32(PIN_MUX_SEL) &= ~(0xFFFF);
 #endif
 
 #if defined(PATCH_GPIO_FOR_LED)
 	REG32(PIN_MUX_SEL) |= (0xFFFF);
 #endif
 
+#ifdef CONFIG_POCKET_ROUTER_SUPPORT
+	#define ETH_PORT_START		4
+	#define ETH_PORT_END		4
+#else
+	#define ETH_PORT_START		0
+	#define ETH_PORT_END		4
+#endif
+	if (eee_enabled == 1) {
+		for ( index = ETH_PORT_START ; index <= ETH_PORT_END; index++ ) {
+			/* enable phy 100 eee ability */
+			mmd_write(index, 7, 60, 0x2);
+		}
+	}
+
 #endif  // end of defined(CONFIG_RTL_8196C)
 
-#if defined(CONFIG_RTL_8198)
+#if defined(CONFIG_RTL_8198) && !defined(CONFIG_RTL_819XD)
         REG32(MPMR) |= PM_MODE_ENABLE_AUTOMATIC_POWER_DOWN;
 #endif
 
+
+#if defined(CONFIG_RTL_8196E) && defined(CONFIG_RTL_ULINKER) /* disable unused port for saving power */
+	{
+	uint32 statCtrlReg0;
+
+	for (index=0; index<4; index++) {
+		/* read current PHY reg 0 value */
+		rtl8651_getAsicEthernetPHYReg( index, 0, &statCtrlReg0 );
+
+		REG32(PCRP0+(index*4)) |= EnForceMode;
+		statCtrlReg0 |= POWER_DOWN;
+
+		/* write PHY reg 0 */
+		rtl8651_setAsicEthernetPHYReg( index, 0, statCtrlReg0 );
+	}
+	}
+#endif
+
+
 	return SUCCESS;
 }
 
@@ -4767,7 +5232,7 @@ int32 rtl8651_setAsicPortPatternMatch(uint32 port, uint32 pattern, uint32 patter
 		return SUCCESS;
 	}
 	if(operation>3)
-		return FAILED; //valid operations: 0(drop), 1(mirror to cpu),2(fwd to cpu), 3(to mirror port) 
+		return FAILED; //valid operations: 0(drop), 1(mirror to cpu),2(fwd to cpu), 3(to mirror port)
 	WRITE_MEM32(PPMAR,READ_MEM32(PPMAR)|((1<<(port+26))|(1<<13))); //turn on system pattern match and turn on pattern match on indicated port.
 	WRITE_MEM32(PPMAR,(READ_MEM32(PPMAR) & (~(0x3<<(14+2*port))))|(operation<<(14+2*port)));   //specify operation
 	WRITE_MEM32(PATP0+4*port,pattern);
@@ -4775,7 +5240,7 @@ int32 rtl8651_setAsicPortPatternMatch(uint32 port, uint32 pattern, uint32 patter
 	return SUCCESS;
 }
 
-int32 rtl8651_getAsicPortPatternMatch(uint32 port, uint32 *pattern, uint32 *patternMask, int32 *operation) 
+int32 rtl8651_getAsicPortPatternMatch(uint32 port, uint32 *pattern, uint32 *patternMask, int32 *operation)
 {
 	//not for ext port
 	if(port>=RTL8651_PORT_NUMBER)
@@ -4788,7 +5253,7 @@ int32 rtl8651_getAsicPortPatternMatch(uint32 port, uint32 *pattern, uint32 *patt
 		*patternMask=READ_MEM32(MASKP0+4*port);
 	if(operation)
 		*operation=(READ_MEM32(PPMAR)>>(14+2*port))&0x3;
-	return SUCCESS;		
+	return SUCCESS;
 }
 
 /*
@@ -4807,7 +5272,7 @@ int32 rtl8651_setAsicSpanningEnable(int8 spanningTreeEnabled)
 	if(spanningTreeEnabled == TRUE)
 	{
 		WRITE_MEM32(MSCR,READ_MEM32(MSCR)|(EN_STP));
-		WRITE_MEM32(RMACR ,READ_MEM32(RMACR)|MADDR00);		
+		WRITE_MEM32(RMACR ,READ_MEM32(RMACR)|MADDR00);
 
 	}else
 	{
@@ -4848,7 +5313,7 @@ Config IEEE 802.1D spanning tree port sate into ASIC.
 int32 rtl865xC_setAsicSpanningTreePortState(uint32 port, uint32 portState)
 {
 	uint32 offset = port * 4;
-	
+
 	if ( port >= RTL865XC_PORT_NUMBER )
 		return FAILED;
 
@@ -4888,7 +5353,7 @@ int32 rtl865xC_getAsicSpanningTreePortState(uint32 port, uint32 *portState)
 {
 	uint32 reg;
 	uint32 offset = port * 4;
-	
+
 	if ( port >= RTL865XC_PORT_NUMBER || portState == NULL )
 		return FAILED;
 
@@ -4929,7 +5394,7 @@ int32 rtl8651_setAsicMulticastSpanningTreePortState(uint32 port, uint32 portStat
 {
 #if 0	//Note: 96C/98 have remove these bits!!!
 	uint32 offset = port * 4;
-	
+
 	if ( port >= RTL865XC_PORT_NUMBER )
 	{
 		return FAILED;
@@ -4974,12 +5439,12 @@ int32 rtl8651_getAsicMulticastSpanningTreePortState(uint32 port, uint32 *portSta
 {
 	uint32 reg;
 	uint32 offset = port * 4;
-	
+
 	if ( port >= RTL865XC_PORT_NUMBER || portState == NULL )
 		return FAILED;
 
 	reg = ( READ_MEM32( PCRP0 + offset ) & IPMSTP_PortST_MASK );
-	
+
 	switch(reg)
 	{
 		case IPMSTP_PortST_DISABLE:
@@ -5007,15 +5472,15 @@ int32 rtl8651_getAsicMulticastSpanningTreePortState(uint32 port, uint32 *portSta
 int32 rtl8651_getAsicEthernetPHYReg(uint32 phyId, uint32 regId, uint32 *rData)
 {
 	uint32 status;
-	
+
 	WRITE_MEM32( MDCIOCR, COMMAND_READ | ( phyId << PHYADD_OFFSET ) | ( regId << REGADD_OFFSET ) );
 
 #if defined(CONFIG_RTL_8198)
-	if (REG32(REVR) == BSP_RTL8198_REVISION_A) 
-		mdelay(10);   
+	if (REG32(REVR) == BSP_RTL8198_REVISION_A)
+		mdelay(10);
 #elif defined(CONFIG_RTL8196C_REVISION_B)
 	if (REG32(REVR) == RTL8196C_REVISION_A)
-		mdelay(10);	//wei add, for 8196C revision A. mdio data read will delay 1 mdc clock.	
+		mdelay(10);	//wei add, for 8196C revision A. mdio data read will delay 1 mdc clock.
 #endif
 
 	do { status = READ_MEM32( MDCIOSR ); } while ( ( status & MDC_STATUS ) != 0 );
@@ -5038,7 +5503,7 @@ int32 rtl8651_setAsicEthernetPHYReg(uint32 phyId, uint32 regId, uint32 wData)
 int32 rtl8651_getAsicEthernetPHYStatus(uint32 port, uint32 *rData)
 {
 	uint32 statCtrlReg1, phyid;
-	
+
 	/* port number validation */
 	if (rtl8651_tblAsicDrvPara.externalPHYProperty & RTL8651_TBLASIC_EXTPHYPROPERTY_PORT5_RTL8211B)
 	{
@@ -5167,7 +5632,7 @@ int32 rtl8651_setAsicEthernetPHYAdvCapality(uint32 port, uint32 capality)
 
 	/*Clear Duplex and Speed bits*/
 	statCtrlReg4 &= ~(0xF<<5);
-	
+
 	if (capality & (1<<DUPLEX_100M))
 	{
 		statCtrlReg4 |= (1<<8);
@@ -5189,7 +5654,7 @@ int32 rtl8651_setAsicEthernetPHYAdvCapality(uint32 port, uint32 capality)
 		/*Set All Duplex and Speed All Supported*/
 		statCtrlReg4 |=(0xF <<5);
 	}
-	
+
 	/* write PHY reg 4 */
 	rtl8651_setAsicEthernetPHYReg( phyid, 4, statCtrlReg4 );
 
@@ -5325,7 +5790,7 @@ int32 rtl865xC_setAsicPortPauseFlowControl(uint32 port, uint8 rxEn, uint8 txEn)
 		pauseFC |= PauseFlowControlDtxErx;
 	if(txEn!=0)
 		pauseFC |= PauseFlowControlEtxDrx;
-	
+
 	WRITE_MEM32(PCRP0+offset, (~(PauseFlowControl_MASK)&(READ_MEM32(PCRP0+offset)))|pauseFC);
 
 	TOGGLE_BIT_IN_REG_TWICE(PCRP0 + offset,EnForceMode);
@@ -5336,7 +5801,7 @@ int32 rtl865xC_getAsicPortPauseFlowControl(uint32 port, uint8 *rxEn, uint8 *txEn
 {
 	uint32 offset = port<<2;
 	uint32 pauseFC = 0;
-	
+
 	pauseFC = ((PauseFlowControl_MASK)&(READ_MEM32(PCRP0+offset)));
 
 	if (pauseFC&PauseFlowControlDtxErx)
@@ -5353,7 +5818,7 @@ int32 rtl8651_asicEthernetCableMeterInit(void)
 {
 	rtlglue_printf("NOT YET\n");
 
-#if 0	
+#if 0
 	uint32 old_value;
 	//set PHY6 Reg0 TxD latch internal clock phase
 	WRITE_MEM32(SWTAA, 0xbc8020c0);
@@ -5419,7 +5884,7 @@ int32 rtl865xC_setAsicEthernetRGMIITiming(uint32 port, uint32 Tcomp, uint32 Rcom
 		return FAILED;
 	if ( Tcomp < RGMII_TCOMP_0NS || Tcomp > RGMII_TCOMP_7NS || Rcomp < RGMII_RCOMP_0NS || Rcomp > RGMII_RCOMP_2DOT5NS )
 		return FAILED;
-	
+
 	if ( port == 0 )
 	{
 		WRITE_MEM32(P0GMIICR, ( ( ( READ_MEM32(P0GMIICR) & ~RGMII_TCOMP_MASK ) | Tcomp ) & ~RGMII_RCOMP_MASK ) | Rcomp );
@@ -5440,7 +5905,7 @@ int32 rtl8651_setAsicEthernetMII(uint32 phyAddress, int32 mode, int32 enabled)
 		return FAILED;
 	if ( mode != P5_LINK_RGMII && mode != P5_LINK_MII_MAC && mode != P5_LINK_MII_PHY )
 		return FAILED;
-	
+
 	/* Configure driver level information about mii port 5 */
 	if ( enabled )
 	{
@@ -5467,8 +5932,90 @@ int32 rtl8651_getAsicEthernetMII(uint32 *phyAddress)
 }
 
 
+/*vlan remark*/
+int32 rtl8651_setAsicVlanRemark(enum PORTID port, enum PRIORITYVALUE priority, int remark)
+{
+	int regValue;
+	if ((port < PHY0) || (port > CPU) || (priority < PRI0) || (priority > PRI7) ||(remark < PRI0) || (remark > PRI7))
+		return FAILED;
+
+	WRITE_MEM32(RLRC, (READ_MEM32(RLRC) &~(0x7)) |0x7);
+
+	regValue = READ_MEM32(RMCR1P) & ~((0x7<<(3*priority)) |(0x1 << (24 + port)));
+	regValue |= ((remark << (3*priority)) |(0x1 << (24 + port)));
+	WRITE_MEM32( RMCR1P, regValue);
+
+	return SUCCESS;
+}
+
+int32 rtl8651_getAsicVlanRemark(enum PORTID port, enum PRIORITYVALUE priority, int* remark)
+{
+	int regValue;
+	if ((port < PHY0) || (port > CPU) || (priority < PRI0) || (priority > PRI7) ||(remark == NULL))
+		return FAILED;
+
+	regValue = READ_MEM32(RMCR1P);
+	if(regValue & (0x1<<(24+port))){
+		*remark = (regValue>>(3*priority)) & 0x7;
+	}else{
+			return FAILED;
+	}
+
+	return SUCCESS;
+}
+
+
+/*vlan remark*/
+int32 rtl8651_setAsicDscpRemark(enum PORTID port, enum PRIORITYVALUE priority, int remark)
+{
+	int regValue0;
+	if ((port < PHY0) || (port > CPU) || (priority < PRI0) || (priority > PRI7) ||(remark < 0) ||(remark > 63))
+		return FAILED;
+
+	WRITE_MEM32(RLRC, (READ_MEM32(RLRC) &~(0x7<<3)) |(0x7<<3));
+
+	if(priority < 5){
+		regValue0 = READ_MEM32(DSCPRM0) &~(0x3f<<(6*priority));
+		regValue0 |= remark << (6*priority);
+		WRITE_MEM32( DSCPRM0, regValue0);
+
+		regValue0 = READ_MEM32(DSCPRM1) &~(0x1 << (23 + port));
+		regValue0 |= 0x1 << (23 + port);
+		WRITE_MEM32( DSCPRM1, regValue0);
+	}else{
+		regValue0 = READ_MEM32(DSCPRM1) & ~((0x3f<<(6*(priority -5))) |(0x1 << (23 + port)));
+		regValue0 |= ((remark<<(6*(priority -5))) |(0x1 << (23 + port)));
+		WRITE_MEM32( DSCPRM1, regValue0);
+	}
+
+	return SUCCESS;
+}
+
+int32 rtl8651_getAsicDscpRemark(enum PORTID port, enum PRIORITYVALUE priority, int* remark)
+{
+	int regValue0, regValue1;
+	if ((port < PHY0) || (port > CPU) || (priority < PRI0) || (priority > PRI7) || (remark == NULL))
+		return FAILED;
+
+	regValue1 = READ_MEM32(DSCPRM1);
+	if(regValue1 & (0x1 << (23 + port))){
+		if(priority < 5){
+			regValue0 = READ_MEM32(DSCPRM0);
+			*remark = (regValue0>>(6*priority)) & 0x3f;
+		}else{
+			*remark = (regValue1>>(6*(priority-5))) & 0x3f;
+		}
+	}else{
+			return FAILED;
+	}
+
+	return SUCCESS;
+}
+
+
+
 /*=========================================
-  * ASIC DRIVER API: Packet Scheduling Control Register 
+  * ASIC DRIVER API: Packet Scheduling Control Register
   *=========================================*/
 /*
 @func int32 | rtl8651_setAsicPriorityDecision | set priority selection
@@ -5477,25 +6024,42 @@ int32 rtl8651_getAsicEthernetMII(uint32 *phyAddress)
 @parm uint32 | dscppri | output queue decision priority assign for DSCP Based Priority
 @parm uint32 | aclpri | output queue decision priority assign for ACL Based Priority.
 @parm uint32 | natpri | output queue decision priority assign for NAT Based Priority.
-@rvalue SUCCESS | 
+@rvalue SUCCESS |
 @rvalue FAILED | invalid parameter
 @comm
- */ 
+ */
 int32 rtl8651_setAsicPriorityDecision( uint32 portpri, uint32 dot1qpri, uint32 dscppri, uint32 aclpri, uint32 natpri )
 {
 	/* Invalid input parameter */
-	if ((portpri < 0) || (portpri > 0xF) || (dot1qpri < 0) || (dot1qpri > 0xF) || 
+	if ((portpri < 0) || (portpri > 0xF) || (dot1qpri < 0) || (dot1qpri > 0xF) ||
 		(dscppri < 0) || (dscppri > 0xF) || (aclpri < 0) || (aclpri > 0xF) ||
-		(natpri < 0) || (natpri > 0xF)) 
+		(natpri < 0) || (natpri > 0xF))
 		return FAILED;
 
-	WRITE_MEM32(QIDDPCR, (portpri << PBP_PRI_OFFSET) | (dot1qpri << BP8021Q_PRI_OFFSET) | 
-		                 (dscppri << DSCP_PRI_OFFSET) | (aclpri << ACL_PRI_OFFSET) | 
+	WRITE_MEM32(QIDDPCR, (portpri << PBP_PRI_OFFSET) | (dot1qpri << BP8021Q_PRI_OFFSET) |
+		                 (dscppri << DSCP_PRI_OFFSET) | (aclpri << ACL_PRI_OFFSET) |
 		                 (natpri << NAPT_PRI_OFFSET));
 
 	return SUCCESS;
 }
 
+int32 rtl8651_getAsicPriorityDecision( uint32* portpri, uint32* dot1qpri, uint32* dscppri, uint32* aclpri, uint32* natpri )
+{
+	uint32 temp;
+	if((portpri == NULL) ||(dot1qpri == NULL) ||(dscppri == NULL) ||(aclpri == NULL) ||(natpri == NULL))
+		return FAILED;
+
+	temp = READ_MEM32(QIDDPCR);
+	*portpri = (temp >> PBP_PRI_OFFSET) & 0xf;
+	*dot1qpri = (temp >> BP8021Q_PRI_OFFSET) & 0xf;
+	*dscppri = (temp >> DSCP_PRI_OFFSET) & 0xf;
+	*aclpri = (temp >> ACL_PRI_OFFSET) & 0xf;
+	*natpri  = (temp >> NAPT_PRI_OFFSET) & 0xf;
+
+	return SUCCESS;
+}
+
+
 int32 rtl8651_setAsicQueueFlowControlConfigureRegister(enum PORTID port, enum QUEUEID queue, uint32 enable)
 {
 	switch (port)
@@ -5554,7 +6118,7 @@ int32 rtl8651_getAsicQueueFlowControlConfigureRegister(enum PORTID port, enum QU
 @parm uint32 | token | Token is used for adding budget in each time slot.
 @parm uint32 | tick | Tick is used for time slot size slot.
 @parm uint32 | hiThreshold | leaky bucket token high-threshold register
-@rvalue SUCCESS | 
+@rvalue SUCCESS |
 @rvalue FAILED | invalid parameter
 @comm
  */
@@ -5572,7 +6136,7 @@ int32 rtl8651_setAsicLBParameter( uint32 token, uint32 tick, uint32 hiThreshold
 @parm uint32* | pToken | pointer to return token
 @parm uint32* | pTick | pointer to return tick
 @parm uint32* | pHiThreshold | pointer to return hiThreshold
-@rvalue SUCCESS | 
+@rvalue SUCCESS |
 @rvalue FAILED | invalid parameter
 @comm
  */
@@ -5588,19 +6152,43 @@ int32 rtl8651_getAsicLBParameter( uint32* pToken, uint32* pTick, uint32* pHiThre
 		*pTick = (regValue & Tick_MASK) >> Tick_OFFSET;
 	if (pHiThreshold != NULL)
 		*pHiThreshold = (READ_MEM32(ELBTTCR) & 0xFF) >> L2_OFFSET;
-	
+
+	return SUCCESS;
+}
+
+/*port based priority*/
+int32 rtl8651_setAsicPortBasedPriority( enum PORTID port, enum PRIORITYVALUE priority )
+{
+	/* Invalid input parameter */
+	if ((priority < PRI0) || (priority > PRI7) ||(port < PHY0) || (port> EXT3) )
+		return FAILED;
+
+	WRITE_MEM32(PBPCR, (READ_MEM32(PBPCR) & ~(0x7 << (port*3))) | (priority << (port*3)));
+
+	return SUCCESS;
+}
+
+int32 rtl8651_getAsicPortBasedPriority( enum PORTID port, enum PRIORITYVALUE* priority )
+{
+	/* Invalid input parameter */
+	if ((port < PHY0) || (port> EXT3) ||(priority == NULL))
+		return FAILED;
+
+	*priority = (READ_MEM32(PBPCR) >> (3*port)) & 0x7;
+
 	return SUCCESS;
 }
 
 
+
 /*
 @func int32 | rtl8651_setAsicQueueRate | set per queue rate
 @parm enum PORTID | port | the port number
 @parm enum QUEUEID | queueid | the queue ID wanted to set
-@parm uint32 | pprTime | Peak Packet Rate (in times of APR). 0~6: PPR = (2^pprTime)*apr. 7: disable PPR 
+@parm uint32 | pprTime | Peak Packet Rate (in times of APR). 0~6: PPR = (2^pprTime)*apr. 7: disable PPR
 @parm uint32 | aprBurstSize | Bucket Burst Size of Average Packet Rate (unit: 1KByte). 0xFF: disable
 @parm uint32 | apr | Average Packet Rate (unit: 64Kbps). 0x3FFF: unlimited rate
-@rvalue SUCCESS | 
+@rvalue SUCCESS |
 @rvalue FAILED | invalid parameter
 @comm
  */
@@ -5624,10 +6212,10 @@ int32 rtl8651_setAsicQueueRate( enum PORTID port, enum QUEUEID queueid, uint32 p
 @func int32 | rtl8651_getAsicQueueRate | get per queue rate configuration
 @parm enum PORTID | port | the port number
 @parm enum QUEUEID | queueid | the queue ID wanted to set
-@parm uint32* | pPprTime | pointer to Peak Packet Rate (in times of APR). 0~6: PPR = (2^pprTime)*apr. 7: disable PPR 
+@parm uint32* | pPprTime | pointer to Peak Packet Rate (in times of APR). 0~6: PPR = (2^pprTime)*apr. 7: disable PPR
 @parm uint32* | pAprBurstSize | pointer to APR Burst Size (unit: 1KBytes). 0xff: disable
 @parm uint32* | pApr | pointer to Average Packet Rate (unit: 64Kbps). 0x3FFF: unlimited rate
-@rvalue SUCCESS | 
+@rvalue SUCCESS |
 @rvalue FAILED | invalid parameter
 @comm
  */
@@ -5654,7 +6242,7 @@ int32 rtl8651_getAsicQueueRate( enum PORTID port, enum QUEUEID queueid, uint32*
 @func int32 | rtl8651_setAsicPortIngressBandwidth | set per-port total ingress bandwidth
 @parm enum PORTID | port | the port number
 @parm uint32 | bandwidth | the total ingress bandwidth (unit: 16Kbps), 0:disable
-@rvalue SUCCESS | 
+@rvalue SUCCESS |
 @rvalue FAILED | invalid parameter
 @comm
  */
@@ -5684,7 +6272,7 @@ int32 rtl8651_setAsicPortIngressBandwidth( enum PORTID port, uint32 bandwidth)
 @func int32 | rtl8651_getAsicPortIngressBandwidth | get per-port total ingress bandwidth
 @parm enum PORTID | port | the port number
 @parm uint32* | pBandwidth | pointer to the returned total ingress bandwidth (unit: 16Kbps), 0:disable
-@rvalue SUCCESS | 
+@rvalue SUCCESS |
 @rvalue FAILED | invalid parameter
 @comm
  */
@@ -5714,8 +6302,8 @@ int32 rtl8651_getAsicPortIngressBandwidth( enum PORTID port, uint32* pBandwidth
 /*
 @func int32 | rtl8651_setAsicPortEgressBandwidth | set per-port total egress bandwidth
 @parm enum PORTID | port | the port number
-@parm uint32 | bandwidth | the total egress bandwidth (unit: 64kbps). 0x3FFF: disable 
-@rvalue SUCCESS | 
+@parm uint32 | bandwidth | the total egress bandwidth (unit: 64kbps). 0x3FFF: disable
+@rvalue SUCCESS |
 @rvalue FAILED | invalid parameter
 @comm
  */
@@ -5736,8 +6324,8 @@ int32 rtl8651_setAsicPortEgressBandwidth( enum PORTID port, uint32 bandwidth )
 /*
 @func int32 | rtl8651_getAsicPortEgressBandwidth | get per-port total egress bandwidth
 @parm enum PORTID | port | the port number
-@parm uint32* | pBandwidth | pointer to the returned total egress bandwidth (unit: 64kbps). 0x3FFF: disable 
-@rvalue SUCCESS | 
+@parm uint32* | pBandwidth | pointer to the returned total egress bandwidth (unit: 64kbps). 0x3FFF: disable
+@rvalue SUCCESS |
 @rvalue FAILED | invalid parameter
 @comm
  */
@@ -5757,6 +6345,42 @@ int32 rtl8651_getAsicPortEgressBandwidth( enum PORTID port, uint32* pBandwidth )
 	return SUCCESS;
 }
 
+/*set queue type as STRICT*/
+int32 rtl8651_setAsicQueueStrict( enum PORTID port, enum QUEUEID queueid, enum QUEUETYPE queueType)
+{
+	uint32 reg1, regOFFSET, regValue;
+
+	if ((port < PHY0) || (port > CPU) || (queueid < QUEUE0) || (queueid > QUEUE5))
+		return FAILED;
+	if ((queueType < STR_PRIO) || (queueType > WFQ_PRIO))
+		return FAILED;
+
+	reg1 = WFQWCR0P0 + (port * 0xC) + ((queueid >> 2) * 0x4);	/* offset to get corresponding register */
+	regOFFSET = (queueid % 4) * 0x8;	/* used to offset register value */
+
+	regValue = READ_MEM32(reg1) & ~((WEIGHT0_MASK | SCHE0_MASK) << regOFFSET);
+	regValue |= (queueType << (SCHE0_OFFSET + regOFFSET));
+	WRITE_MEM32( reg1, regValue);
+	return SUCCESS;
+}
+
+int32 rtl8651_getAsicQueueStrict( enum PORTID port, enum QUEUEID queueid, enum QUEUETYPE *pQueueType)
+{
+	uint32 reg1, regOFFSET, regValue;
+
+	if ((port < PHY0) || (port > CPU) || (queueid < QUEUE0) || (queueid > QUEUE5) ||(pQueueType == NULL))
+		return FAILED;
+
+	reg1 = WFQWCR0P0 + (port * 0xC) + ((queueid >> 2) * 0x4);  /* offset to get corresponding register */
+	regOFFSET = (queueid % 4) * 0x8;	/* used to offset register value */
+	regValue = READ_MEM32(reg1);
+
+	if (pQueueType != NULL)
+		*pQueueType = ((regValue & (SCHE0_MASK << regOFFSET)) >> SCHE0_OFFSET) >> regOFFSET;
+
+	return SUCCESS;
+}
+
 
 /*
 @func int32 | rtl8651_setAsicQueueWeight | set WFQ weighting
@@ -5764,21 +6388,23 @@ int32 rtl8651_getAsicPortEgressBandwidth( enum PORTID port, uint32* pBandwidth )
 @parm enum QUEUEID | queueid | the queue ID wanted to set
 @parm enum QUEUETYPE | queueType | the specified queue type
 @parm uint32 | weight | the weight value wanted to set (valid:0~127)
-@rvalue SUCCESS | 
+@rvalue SUCCESS |
 @rvalue FAILED | invalid parameter
 @comm
  */
 int32 rtl8651_setAsicQueueWeight( enum PORTID port, enum QUEUEID queueid, enum QUEUETYPE queueType, uint32 weight )
 {
 	uint32 reg1, regOFFSET, regValue;
-	
+
 	if ((port < PHY0) || (port > CPU) || (queueid < QUEUE0) || (queueid > QUEUE5))
 		return FAILED;
 	if ((queueType < STR_PRIO) || (queueType > WFQ_PRIO))
 		return FAILED;
+	if((weight < 0) && (weight > 127))
+		return FAILED;
 
 	reg1 = WFQWCR0P0 + (port * 0xC) + ((queueid >> 2) * 0x4);	/* offset to get corresponding register */
-	regOFFSET = (queueid % 4) * 0x8;	/* used to offset register value */	 	 
+	regOFFSET = (queueid % 4) * 0x8;	/* used to offset register value */
 
 	regValue = READ_MEM32(reg1) & ~((WEIGHT0_MASK | SCHE0_MASK) << regOFFSET);
 	regValue |= ((queueType << (SCHE0_OFFSET + regOFFSET)) | (weight << (WEIGHT0_OFFSET + regOFFSET)));
@@ -5793,19 +6419,19 @@ int32 rtl8651_setAsicQueueWeight( enum PORTID port, enum QUEUEID queueid, enum Q
 @parm enum QUEUEID | queueid | the queue ID wanted to set
 @parm enum QUEUETYPE* | pQueueType | pointer to the returned queue type
 @parm uint32* | pWeight | pointer to the returned weight value
-@rvalue SUCCESS | 
+@rvalue SUCCESS |
 @rvalue FAILED | invalid parameter
 @comm
  */
 int32 rtl8651_getAsicQueueWeight( enum PORTID port, enum QUEUEID queueid, enum QUEUETYPE *pQueueType, uint32 *pWeight )
 {
 	uint32 reg1, regOFFSET, regValue;
-	
+
 	if ((port < PHY0) || (port > CPU) || (queueid < QUEUE0) || (queueid > QUEUE5))
 		return FAILED;
 
 	reg1 = WFQWCR0P0 + (port * 0xC) + ((queueid >> 2) * 0x4);  /* offset to get corresponding register */
-	regOFFSET = (queueid % 4) * 0x8;	/* used to offset register value */	 
+	regOFFSET = (queueid % 4) * 0x8;	/* used to offset register value */
 	regValue = READ_MEM32(reg1);
 
 	if (pQueueType != NULL)
@@ -5820,7 +6446,7 @@ int32 rtl8651_getAsicQueueWeight( enum PORTID port, enum QUEUEID queueid, enum Q
 @func int32 | rtl8651_setAsicOutputQueueNumber | set output queue number for a specified port
 @parm enum PORTID | port | the port number (valid: physical ports(0~5) and CPU port(6) )
 @parm enum QUEUENUM | qnum | the output queue number
-@rvalue SUCCESS | 
+@rvalue SUCCESS |
 @rvalue FAILED | invalid parameter
 @comm
  */
@@ -5831,7 +6457,7 @@ int32 rtl8651_setAsicOutputQueueNumber( enum PORTID port, enum QUEUENUM qnum )
 	enum QUEUENUM orgQnum;
 
 	if ((port < PHY0) || (port > CPU) || (qnum < QNUM1) || (qnum > QNUM6))
-		return FAILED; 
+		return FAILED;
 
 	orgQnum = (READ_MEM32(QNUMCR) >> (3*port)) & 0x7;
 	WRITE_MEM32(QNUMCR, (READ_MEM32(QNUMCR) & ~(0x7 << (3*port))) | (qnum << (3*port)));
@@ -5860,7 +6486,7 @@ int32 rtl8651_setAsicOutputQueueNumber( enum PORTID port, enum QUEUENUM qnum )
 @func int32 | rtl8651_getAsicOutputQueueNumber | get output queue number for a specified port
 @parm enum PORTID | port | the port number (valid: physical ports(0~5) and CPU port(6) )
 @parm enum QUEUENUM | qnum | the output queue number
-@rvalue SUCCESS | 
+@rvalue SUCCESS |
 @rvalue FAILED | invalid parameter
 @comm
  */
@@ -5868,11 +6494,11 @@ int32 rtl8651_getAsicOutputQueueNumber( enum PORTID port, enum QUEUENUM *qnum )
 {
 	/* Invalid input parameter */
 	if ((port < PHY0) || (port > CPU))
-		return FAILED; 
+		return FAILED;
 
 	if (qnum != NULL)
 		*qnum = (READ_MEM32(QNUMCR) >> (3*port)) & 0x7;
-	
+
 	return SUCCESS;
 }
 
@@ -5881,19 +6507,19 @@ int32 rtl8651_getAsicOutputQueueNumber( enum PORTID port, enum QUEUENUM *qnum )
 @parm enum QUEUENUM | qnum | the output queue number
 @parm enum PRIORITYVALUE | priority | priority
 @parm enum QUEUEID | qid | queue ID
-@rvalue SUCCESS | 
+@rvalue SUCCESS |
 @rvalue FAILED | invalid parameter
 @comm
  */
 int32 rtl8651_setAsicPriorityToQIDMappingTable( enum QUEUENUM qnum, enum PRIORITYVALUE priority, enum QUEUEID qid )
 {
 	/* Invalid input parameter */
-	if ((priority < PRI0) || (priority > PRI7)) 
+	if ((priority < PRI0) || (priority > PRI7))
 		return FAILED;
-	if ((qid < QUEUE0) || (qid > QUEUE5)) 
+	if ((qid < QUEUE0) || (qid > QUEUE5))
 		return FAILED;
 
-	switch (qnum) 
+	switch (qnum)
 	{
 		case QNUM1:
 			WRITE_MEM32(UPTCMCR0, (READ_MEM32(UPTCMCR0) & ~(0x7 << (priority*3))) | (qid << (priority*3))); break;
@@ -5907,19 +6533,53 @@ int32 rtl8651_setAsicPriorityToQIDMappingTable( enum QUEUENUM qnum, enum PRIORIT
 			WRITE_MEM32(UPTCMCR4, (READ_MEM32(UPTCMCR4) & ~(0x7 << (priority*3))) | (qid << (priority*3))); break;
 		case QNUM6:
 			WRITE_MEM32(UPTCMCR5, (READ_MEM32(UPTCMCR5) & ~(0x7 << (priority*3))) | (qid << (priority*3))); break;
-		default: 
+		default:
+			return FAILED;
+	}
+
+	return SUCCESS;
+}
+
+int32 rtl8651_getAsicPriorityToQIDMappingTable( enum QUEUENUM qnum, enum PRIORITYVALUE priority, enum QUEUEID* qid )
+{
+	/* Invalid input parameter */
+	if ((priority < PRI0) || (priority > PRI7) ||(qid == NULL))
+		return FAILED;
+
+	switch (qnum)
+	{
+		case QNUM1:
+			*qid = (READ_MEM32(UPTCMCR0) >> (priority*3)) & 0x7;
+			break;
+		case QNUM2:
+			*qid = (READ_MEM32(UPTCMCR1) >> (priority*3)) & 0x7;
+			break;
+		case QNUM3:
+			*qid = (READ_MEM32(UPTCMCR2) >> (priority*3)) & 0x7;
+			break;
+		case QNUM4:
+			*qid = (READ_MEM32(UPTCMCR3) >> (priority*3)) & 0x7;
+			break;
+		case QNUM5:
+			*qid = (READ_MEM32(UPTCMCR4) >> (priority*3)) & 0x7;
+			break;
+		case QNUM6:
+			*qid = (READ_MEM32(UPTCMCR5) >> (priority*3)) & 0x7;
+			break;
+		default:
 			return FAILED;
 	}
 
 	return SUCCESS;
 }
 
+
 /*
 @func int32 | rtl8651_setAsicCPUPriorityToQIDMappingTable | set user priority to QID mapping table parameter based on destination port & priority information
 @parm enum PORTID | port | the destination port
 @parm enum PRIORITYVALUE | priority | priority
 @parm enum QUEUEID | qid | queue ID
-@rvalue SUCCESS | 
+@rvalue SUCCESS |
 @rvalue FAILED | invalid parameter
 @comm
  */
@@ -5927,16 +6587,16 @@ int32 rtl8651_setAsicCPUPriorityToQIDMappingTable( enum PORTID port, enum PRIORI
 {
 	uint32	reg;
 	/* Invalid input parameter */
-	if ((priority < PRI0) || (priority > PRI7)) 
+	if ((priority < PRI0) || (priority > PRI7))
 		return FAILED;
-	if ((qid < QUEUE0) || (qid > QUEUE5)) 
+	if ((qid < QUEUE0) || (qid > QUEUE5))
 		return FAILED;
 	if (port<CPU || port>MULTEXT)
 		return FAILED;
 
 	reg = (uint32)(((uint32*)CPUQIDMCR0) + (port-CPU));
 
-	WRITE_MEM32(reg, (READ_MEM32(reg) & ~(0x7 << (priority<<2))) | (qid << (priority<<2))); 
+	WRITE_MEM32(reg, (READ_MEM32(reg) & ~(0x7 << (priority<<2))) | (qid << (priority<<2)));
 
 	return SUCCESS;
 }
@@ -5945,12 +6605,12 @@ int32 rtl8651_setAsicCPUPriorityToQIDMappingTable( enum PORTID port, enum PRIORI
 int32 rtl8651_setAsicSystemBasedFlowControlRegister(uint32 sharedON, uint32 sharedOFF, uint32 fcON, uint32 fcOFF, uint32 drop)
 {
 	/* Invalid input parameter */
-	if ((sharedON > (SDC_FCON_MASK >> SDC_FCON_OFFSET)) || 
-		(sharedOFF > (S_DSC_FCOFF_MASK >> S_DSC_FCOFF_OFFSET)) || 
-		(fcON > ((S_Max_SBuf_FCON_MASK >> S_Max_SBuf_FCON_OFFSET))) || 
-		(fcOFF > (S_Max_SBuf_FCOFF_MASK >> S_Max_SBuf_FCOFF_OFFSET)) || 
+	if ((sharedON > (SDC_FCON_MASK >> SDC_FCON_OFFSET)) ||
+		(sharedOFF > (S_DSC_FCOFF_MASK >> S_DSC_FCOFF_OFFSET)) ||
+		(fcON > ((S_Max_SBuf_FCON_MASK >> S_Max_SBuf_FCON_OFFSET))) ||
+		(fcOFF > (S_Max_SBuf_FCOFF_MASK >> S_Max_SBuf_FCOFF_OFFSET)) ||
 		(drop > (S_DSC_RUNOUT_MASK >> S_DSC_RUNOUT_OFFSET)))
-		return FAILED; 
+		return FAILED;
 
 	WRITE_MEM32(SBFCR0, (READ_MEM32(SBFCR0) & ~(S_DSC_RUNOUT_MASK)) | (drop << S_DSC_RUNOUT_OFFSET));
 	WRITE_MEM32(SBFCR1, (READ_MEM32(SBFCR1) & ~(S_DSC_FCON_MASK | S_DSC_FCOFF_MASK)) | ( fcON<< S_DSC_FCON_OFFSET) | (fcOFF << S_DSC_FCOFF_OFFSET));
@@ -5962,26 +6622,26 @@ int32 rtl8651_setAsicQueueDescriptorBasedFlowControlRegister(enum PORTID port, e
 {
 	/* Invalid input parameter */
 	if ((port < PHY0) || (port > CPU))
-		return FAILED; 
+		return FAILED;
 
-	if ((fcON > (QG_DSC_FCON_MASK >> QG_DSC_FCON_OFFSET)) || 
+	if ((fcON > (QG_DSC_FCON_MASK >> QG_DSC_FCON_OFFSET)) ||
 		(fcOFF > (QG_DSC_FCOFF_MASK >> QG_DSC_FCOFF_OFFSET)))
-		return FAILED; 
+		return FAILED;
 
 
 	switch (queue)
 	{
 		case QUEUE0:
-			WRITE_MEM32((QDBFCRP0G0+(port*0xC)), (READ_MEM32(QDBFCRP0G0+(port*0xC)) & ~(QG_DSC_FCON_MASK | QG_DSC_FCOFF_MASK)) | (fcON << QG_DSC_FCON_OFFSET) | (fcOFF << QG_DSC_FCOFF_OFFSET)); 		
+			WRITE_MEM32((QDBFCRP0G0+(port*0xC)), (READ_MEM32(QDBFCRP0G0+(port*0xC)) & ~(QG_DSC_FCON_MASK | QG_DSC_FCOFF_MASK)) | (fcON << QG_DSC_FCON_OFFSET) | (fcOFF << QG_DSC_FCOFF_OFFSET));
 			break;
 		case QUEUE1:
 		case QUEUE2:
 		case QUEUE3:
-		case QUEUE4:		
-			WRITE_MEM32((QDBFCRP0G1+(port*0xC)), (READ_MEM32(QDBFCRP0G1+(port*0xC)) & ~(QG_DSC_FCON_MASK | QG_DSC_FCOFF_MASK)) | (fcON << QG_DSC_FCON_OFFSET) | (fcOFF << QG_DSC_FCOFF_OFFSET)); 		
+		case QUEUE4:
+			WRITE_MEM32((QDBFCRP0G1+(port*0xC)), (READ_MEM32(QDBFCRP0G1+(port*0xC)) & ~(QG_DSC_FCON_MASK | QG_DSC_FCOFF_MASK)) | (fcON << QG_DSC_FCON_OFFSET) | (fcOFF << QG_DSC_FCOFF_OFFSET));
 			break;
 		case QUEUE5:
-			WRITE_MEM32((QDBFCRP0G2+(port*0xC)), (READ_MEM32(QDBFCRP0G2+(port*0xC)) & ~(QG_DSC_FCON_MASK | QG_DSC_FCOFF_MASK)) | (fcON << QG_DSC_FCON_OFFSET) | (fcOFF << QG_DSC_FCOFF_OFFSET)); 		
+			WRITE_MEM32((QDBFCRP0G2+(port*0xC)), (READ_MEM32(QDBFCRP0G2+(port*0xC)) & ~(QG_DSC_FCON_MASK | QG_DSC_FCOFF_MASK)) | (fcON << QG_DSC_FCON_OFFSET) | (fcOFF << QG_DSC_FCOFF_OFFSET));
 			break;
 		default:
 			return FAILED;
@@ -5993,25 +6653,25 @@ int32 rtl8651_setAsicQueuePacketBasedFlowControlRegister(enum PORTID port, enum
 {
 	/* Invalid input parameter */
 	if ((port < PHY0) || (port > CPU))
-		return FAILED; 
+		return FAILED;
 
-	if ((fcON > (QG_QLEN_FCON_MASK>> QG_QLEN_FCON_OFFSET)) || 
+	if ((fcON > (QG_QLEN_FCON_MASK>> QG_QLEN_FCON_OFFSET)) ||
 		(fcOFF > (QG_QLEN_FCOFF_MASK >> QG_QLEN_FCOFF_OFFSET)))
-		return FAILED; 
+		return FAILED;
 
 	switch (queue)
 	{
 		case QUEUE0:
-			WRITE_MEM32((QPKTFCRP0G0+(port*0xC)), (READ_MEM32(QPKTFCRP0G0+(port*0xC)) & ~(QG_QLEN_FCON_MASK | QG_QLEN_FCOFF_MASK)) | (fcON << QG_QLEN_FCON_OFFSET) | (fcOFF << QG_QLEN_FCOFF_OFFSET)); 		
+			WRITE_MEM32((QPKTFCRP0G0+(port*0xC)), (READ_MEM32(QPKTFCRP0G0+(port*0xC)) & ~(QG_QLEN_FCON_MASK | QG_QLEN_FCOFF_MASK)) | (fcON << QG_QLEN_FCON_OFFSET) | (fcOFF << QG_QLEN_FCOFF_OFFSET));
 			break;
 		case QUEUE1:
 		case QUEUE2:
 		case QUEUE3:
-		case QUEUE4:		
-			WRITE_MEM32((QPKTFCRP0G1+(port*0xC)), (READ_MEM32(QPKTFCRP0G1+(port*0xC)) & ~(QG_QLEN_FCON_MASK | QG_QLEN_FCOFF_MASK)) | (fcON << QG_QLEN_FCON_OFFSET) | (fcOFF << QG_QLEN_FCOFF_OFFSET)); 
+		case QUEUE4:
+			WRITE_MEM32((QPKTFCRP0G1+(port*0xC)), (READ_MEM32(QPKTFCRP0G1+(port*0xC)) & ~(QG_QLEN_FCON_MASK | QG_QLEN_FCOFF_MASK)) | (fcON << QG_QLEN_FCON_OFFSET) | (fcOFF << QG_QLEN_FCOFF_OFFSET));
 			break;
 		case QUEUE5:
-			WRITE_MEM32((QPKTFCRP0G2+(port*0xC)), (READ_MEM32(QPKTFCRP0G2+(port*0xC)) & ~(QG_QLEN_FCON_MASK | QG_QLEN_FCOFF_MASK)) | (fcON << QG_QLEN_FCON_OFFSET) | (fcOFF << QG_QLEN_FCOFF_OFFSET)); 
+			WRITE_MEM32((QPKTFCRP0G2+(port*0xC)), (READ_MEM32(QPKTFCRP0G2+(port*0xC)) & ~(QG_QLEN_FCON_MASK | QG_QLEN_FCOFF_MASK)) | (fcON << QG_QLEN_FCON_OFFSET) | (fcOFF << QG_QLEN_FCOFF_OFFSET));
 			break;
 		default:
 			return FAILED;
@@ -6023,9 +6683,9 @@ int32 rtl8651_setAsicQueuePacketBasedFlowControlRegister(enum PORTID port, enum
 int32 rtl8651_setAsicPortBasedFlowControlRegister(enum PORTID port, uint32 fcON, uint32 fcOFF)
 {
 	/* Invalid input parameter */
-	if ((fcON > (P_MaxDSC_FCON_MASK >> P_MaxDSC_FCON_OFFSET)) || 
+	if ((fcON > (P_MaxDSC_FCON_MASK >> P_MaxDSC_FCON_OFFSET)) ||
 		(fcOFF > (P_MaxDSC_FCOFF_MASK >> P_MaxDSC_FCOFF_OFFSET)))
-		return FAILED; 
+		return FAILED;
 
 	switch (port)
 	{
@@ -6056,10 +6716,52 @@ int32 rtl8651_setAsicPerQueuePhysicalLengthGapRegister(uint32 gap)
 	if (gap > (QLEN_GAP_MASK >> QLEN_GAP_OFFSET))
 		return FAILED;
 
-	WRITE_MEM32(PQPLGR, (READ_MEM32(PQPLGR) & ~(QLEN_GAP_MASK)) | (gap << QLEN_GAP_OFFSET)); 		
+	WRITE_MEM32(PQPLGR, (READ_MEM32(PQPLGR) & ~(QLEN_GAP_MASK)) | (gap << QLEN_GAP_OFFSET));
 	return SUCCESS;
 }
 
+/* 	note: the dynamic mechanism: adjust the flow control threshold value according to the number of Ethernet link up ports.
+	buffer threshold setting:
+	sys on = 208, share on = 192 for link port <=3
+	0xbb804504 = 0x00c000d0
+	0xbb804508 = 0x00b000c0
+
+	sys on = 172, share on = 98 , for link port > 3
+	0xbb804504 = 0x00A000AC
+	0xbb804508 = 0x004A0062
+
+	1. default threshold setting is link port <=3
+	2. got link change interrupt and link port > 3, then change threhosld for link port > 3
+	3. got link change interrupt and link port <= 3, then change threhosld for link port <= 3
+ */
+
+#ifdef CONFIG_RTL_8197D_DYN_THR
+int32 rtl819x_setQosThreshold(uint32 old_sts, uint32 new_sts)
+{
+	int32 i, link_up_ports=0;
+	uint32 j = new_sts;
+
+	if (old_sts == new_sts)
+		return SUCCESS;
+
+	for (i=0; i<5; i++) {
+		if ((j & 0x1) == 1)
+			link_up_ports++;
+		j = j >> 1;
+	}
+
+	if (link_up_ports <= DYN_THR_LINK_UP_PORTS) {
+		WRITE_MEM32(SBFCR1, (READ_MEM32(SBFCR1) & ~(S_DSC_FCON_MASK | S_DSC_FCOFF_MASK)) | ( DYN_THR_AGG_fcON<< S_DSC_FCON_OFFSET) | (DYN_THR_AGG_fcOFF << S_DSC_FCOFF_OFFSET));
+		WRITE_MEM32(SBFCR2, (READ_MEM32(SBFCR2) & ~(S_Max_SBuf_FCON_MASK | S_Max_SBuf_FCOFF_MASK)) | (DYN_THR_AGG_sharedON << S_Max_SBuf_FCON_OFFSET) | (DYN_THR_AGG_sharedOFF << S_Max_SBuf_FCOFF_OFFSET));
+	}
+	else {
+		WRITE_MEM32(SBFCR1, (READ_MEM32(SBFCR1) & ~(S_DSC_FCON_MASK | S_DSC_FCOFF_MASK)) | ( DYN_THR_DEF_fcON<< S_DSC_FCON_OFFSET) | (DYN_THR_DEF_fcOFF << S_DSC_FCOFF_OFFSET));
+		WRITE_MEM32(SBFCR2, (READ_MEM32(SBFCR2) & ~(S_Max_SBuf_FCON_MASK | S_Max_SBuf_FCOFF_MASK)) | (DYN_THR_DEF_sharedON << S_Max_SBuf_FCON_OFFSET) | (DYN_THR_DEF_sharedOFF << S_Max_SBuf_FCOFF_OFFSET));
+	}
+
+	return SUCCESS;
+}
+#endif
 
 static int32 _rtl865x_setQosThresholdByQueueIdx(uint32 qidx)
 {
@@ -6074,7 +6776,7 @@ static int32 _rtl865x_setQosThresholdByQueueIdx(uint32 qidx)
 		rtlglue_printf("Set System Base Flow Control Para Error.\n");
 		return retval;
 	}
-	
+
 	for(i =0; i < RTL8651_OUTPUTQUEUE_SIZE; i++)
 	{
 		retval = rtl8651_setAsicQueueDescriptorBasedFlowControlRegister(0, i, outputQueuePara[qidx].queueDescFCON, outputQueuePara[qidx].queueDescFCOFF);
@@ -6106,7 +6808,7 @@ static int32 _rtl865x_setQosThresholdByQueueIdx(uint32 qidx)
 	}
 	for(j=1;j<=CPU;j++)
 		rtl8651_setAsicPortBasedFlowControlRegister(PHY0+j, outputQueuePara[qidx].portFCON, outputQueuePara[qidx].portFCOFF);
-	
+
 	retval = rtl8651_setAsicPerQueuePhysicalLengthGapRegister(outputQueuePara[qidx].gap);
 	if (retval!= SUCCESS)
 	{
@@ -6133,14 +6835,14 @@ static int32 _rtl865xC_QM_init( void )
  	rtl865xC_lockSWCore();
 
 	_rtl865xC_QM_orgDescUsage = 0;	/* by default, set it to 0 */
-	
+
 	do
 	{
 		int32 idx;
 
 		originalDescGetReady = TRUE;	/* by default, set it to TRUE */
 		cnt = 0;
-		
+
 		for ( idx = 0 ; idx < RTL865XC_QM_DESC_READROBUSTPARAMETER ; idx ++ )
 		{
 			uint32 currentDescUsage;
@@ -6164,14 +6866,14 @@ static int32 _rtl865xC_QM_init( void )
 		_rtl865xC_QM_orgDescUsage = 12;
 
 	rtl865xC_unLockSWCore();
-#endif	
+#endif
 	return SUCCESS;
 }
 #endif
 
 /*
 @func int32 | rtl865xC_waitForOutputQueueEmpty | wait until output queue empty
-@rvalue SUCCESS | 
+@rvalue SUCCESS |
 @comm
 	The function will not return until all the output queue is empty.
  */
@@ -6187,7 +6889,7 @@ int32 rtl865xC_waitForOutputQueueEmpty(void)
 	while ( ((READ_MEM32(LAGCR0)&OUTPUTQUEUE_STAT_MASK_CR0)^OUTPUTQUEUE_STAT_MASK_CR0) ||
        	((READ_MEM32(LAGCR1)&OUTPUTQUEUE_STAT_MASK_CR1)^OUTPUTQUEUE_STAT_MASK_CR1) );
 	#endif
-	
+
 	/*	There are something wrong when check the input queue is empty or not	*/
 	currentDescUsage = (READ_MEM32( GDSR0 ) & USEDDSC_MASK) >> USEDDSC_OFFSET;
 	cnt = (currentDescUsage-_rtl865xC_QM_orgDescUsage)<<10;
@@ -6205,10 +6907,10 @@ int32 rtl865xC_waitForOutputQueueEmpty(void)
 #endif
        return SUCCESS;
 }
- 
+
 /*
 @func int32 | rtl8651_resetAsicOutputQueue | reset output queue
-@rvalue SUCCESS | 
+@rvalue SUCCESS |
 @comm
 	When reset is done, all queue pointer will be reset to the initial base address.
  */
@@ -6217,7 +6919,7 @@ int32 rtl865xC_waitForOutputQueueEmpty(void)
  {
 	uint32	i;
 	uint32	scr, pauseTicks;
-	
+
  	WRITE_MEM32(QRR, 0x0);
 	scr = (REG32(SCCR) & 0x00000070) >> 4;
 	switch( scr )
@@ -6235,14 +6937,14 @@ int32 rtl865xC_waitForOutputQueueEmpty(void)
 	/* waiting 500ms */
 
 	pauseTicks = pauseTicks<<2;
-	
+
 	for(i=pauseTicks;i<0;i--)
 	{
 		i = i;
 	}
-	
+
  	WRITE_MEM32(QRR, 0x1);
-	
+
 	for(i=pauseTicks;i<0;i--)
 	{
 		i = i;
@@ -6288,7 +6990,7 @@ static void _rtl8651_syncToAsicEthernetBandwidthControl(void)
 			uint32 currentSwBandwidthCtrlMultiplier;
 			uint32 currentSwBandwidthCtrlSetting;
 			uint32 currentAsicBandwidthCtrlSetting;
-			
+
 			/*
 				We would check for rate and _rtl865xB_BandwidthCtrlMultiplier for the rate-multiply.
 
@@ -6343,20 +7045,20 @@ static void _rtl8651_syncToAsicEthernetBandwidthControl(void)
 			if (	(!( (currentSwBandwidthCtrlSetting) == 0 && (currentAsicBandwidthCtrlSetting == 0x3fff) ) /* for FULL Rate case */) ||
 				( currentSwBandwidthCtrlSetting != currentAsicBandwidthCtrlSetting ))
 			{
-#if 0			
+#if 0
 				if (cfgTypeIdx==0)
 				{
 					rtlglue_printf("set ingress bandwidth port %d, %d.\n", port, (currentSwBandwidthCtrlSetting == 0)?
 																(0	/* For Ingress Bandwidth control, 0 means "disabled" */):
 																(currentSwBandwidthCtrlSetting));
 				}
-				else 
+				else
 				{
 					rtlglue_printf("set ingress bandwidth port %d, %d.\n", port, (currentSwBandwidthCtrlSetting == 0)?
 																(0x3fff	/* For Egress Bandwidth control, 0x3fff means "disabled" */):
 																(currentSwBandwidthCtrlSetting));
 				}
-#endif				
+#endif
 				retval = (cfgTypeIdx == 0)?
 					/* Ingress */
 					(rtl8651_setAsicPortIngressBandwidth(	port,
@@ -6388,7 +7090,7 @@ out:
 @parm uint32 | port | the port number
 @parm int8 | input | Ingress or egress control to <p port>
 @parm uint32 | rate | rate to set.
-@rvalue SUCCESS | 
+@rvalue SUCCESS |
 @rvalue FAILED | invalid parameter
 @comm
 The <p rate> can be set to several different values:
@@ -6470,7 +7172,7 @@ int32 rtl8651_setAsicFlowControlRegister(uint32 port, uint32 enable)
 
 	if ( enable && ( statCtrlReg4 & CAPABLE_PAUSE ) == 0 )
 	{
-		statCtrlReg4 |= CAPABLE_PAUSE;		
+		statCtrlReg4 |= CAPABLE_PAUSE;
 	}
 	else if ( enable == 0 && ( statCtrlReg4 & CAPABLE_PAUSE ) )
 	{
@@ -6480,7 +7182,7 @@ int32 rtl8651_setAsicFlowControlRegister(uint32 port, uint32 enable)
 		return SUCCESS;	/* The configuration does not change. Do nothing. */
 
 	rtl8651_setAsicEthernetPHYReg( phyid, 4, statCtrlReg4 );
-	
+
 	/* restart N-way. */
 	rtl8651_restartAsicEthernetPHYNway(port);
 
@@ -6519,7 +7221,7 @@ int32 rtl8651_getAsicFlowControlRegister(uint32 port, uint32 *enable)
 @func int32 | rtl8651_setAsicSystemInputFlowControlRegister | Set System input queue flow control register
 @parm uint32 | fcON		| Threshold for Flow control OFF
 @parm uint32 | fcOFF		| Threshold for Flow control ON
-@rvalue SUCCESS | 
+@rvalue SUCCESS |
 @comm
 Set input-queue flow control threshold on RTL865xC platform.
  */
@@ -6543,7 +7245,7 @@ int32 rtl8651_setAsicSystemInputFlowControlRegister(uint32 fcON, uint32 fcOFF)
 @func int32 | rtl8651_getAsicSystemInputFlowControlRegister | Get System input queue flow control register
 @parm uint32* | fcON		| pointer to get Threshold for Flow control OFF
 @parm uint32* | fcOFF		| pointer to get Threshold for Flow control ON
-@rvalue SUCCESS | 
+@rvalue SUCCESS |
 @comm
 Set input-queue flow control threshold on RTL865xC platform.
  */
@@ -6571,7 +7273,7 @@ int32 rtl865xC_setAsicEthernetForceModeRegs(uint32 port, uint32 enForceMode, uin
 {
 	uint32 offset = port * 4;
 	uint32 PCR = READ_MEM32( PCRP0 + offset );
-	
+
 	if (rtl8651_tblAsicDrvPara.externalPHYProperty & RTL8651_TBLASIC_EXTPHYPROPERTY_PORT5_RTL8211B)
 	{
 		if ( port > RTL8651_MAC_NUMBER )
@@ -6595,7 +7297,7 @@ int32 rtl865xC_setAsicEthernetForceModeRegs(uint32 port, uint32 enForceMode, uin
 	{
 		PCR |= EnForceMode;
 
-#if defined(CONFIG_RTL_8196C) || defined(CONFIG_RTL_8198)
+#if defined(CONFIG_RTL_8196C) || defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
                 //ForceMode with polling link status, disable Auto-Negotiation but polling phy's link status
                 PCR |= PollLinkStatus;
 #endif
@@ -6613,7 +7315,7 @@ int32 rtl865xC_setAsicEthernetForceModeRegs(uint32 port, uint32 enForceMode, uin
 		if ( forceDuplex )
 			PCR |= ForceDuplex;
 	}
-	
+
 	WRITE_MEM32( PCRP0 + offset, PCR );
 	mdelay(10);
 	TOGGLE_BIT_IN_REG_TWICE(PCRP0 + offset,EnForceMode);
@@ -6641,19 +7343,19 @@ static int32 rtl8651_perPortStormControl(uint32 type, uint32 portNum, uint32 ena
 	uint32 oldRegValue;
 	uint32 newRegValue;
 	uint32 totalExtPortNum=3;
-	
+
 	if(portNum>=RTL8651_PORT_NUMBER + totalExtPortNum)
 	{
 		rtlglue_printf("wrong port number\n");
 		return FAILED;
 	}
-	
+
 	regAddress=PCRP0 + portNum * 4;
-		
+
 	oldRegValue=READ_MEM32(regAddress);
-	
+
 	newRegValue=oldRegValue;
-	
+
 	if((type & BROADCAST_STORM_CONTROL) !=0)
 	{
 		if(enable == TRUE)
@@ -6665,9 +7367,9 @@ static int32 rtl8651_perPortStormControl(uint32 type, uint32 portNum, uint32 ena
 		{
 			newRegValue = newRegValue & (~BCSC_ENBROADCAST);
 		}
-		
+
 	}
-	
+
 	if((type & MULTICAST_STORM_CONTROL) !=0)
 	{
 		if(enable == TRUE)
@@ -6679,7 +7381,7 @@ static int32 rtl8651_perPortStormControl(uint32 type, uint32 portNum, uint32 ena
 		{
 			newRegValue = newRegValue & (~BCSC_ENMULTICAST);
 		}
-		
+
 	}
 
 	if((newRegValue & (BCSC_ENMULTICAST |BCSC_ENBROADCAST ))==0)
@@ -6687,17 +7389,17 @@ static int32 rtl8651_perPortStormControl(uint32 type, uint32 portNum, uint32 ena
 		/*no needn't storm control*/
 		newRegValue = newRegValue & (~ENBCSC);
 	}
-		
+
 	if(newRegValue!=oldRegValue)
 	{
 		WRITE_MEM32(regAddress, newRegValue);
 	}
-	
+
 	TOGGLE_BIT_IN_REG_TWICE(regAddress,EnForceMode);
-	
+
 	return SUCCESS;
 
-	
+
 }
 
 int32 rtl865x_setStormControl(uint32 type,uint32 enable,uint32 percentage)
@@ -6717,18 +7419,18 @@ int32 rtl865x_setStormControl(uint32 type,uint32 enable,uint32 percentage)
 			{
 				rtl865xC_setBrdcstStormCtrlRate(percentage);
 			}
-			
+
 			rtl8651_perPortStormControl(type, port, TRUE);
 		}
 		else
 		{
 			rtl865xC_setBrdcstStormCtrlRate(100);
 			rtl8651_perPortStormControl(type, port, FALSE);
-			
+
 		}
-			
+
 	}
-	
+
 	return SUCCESS;
 }
 
@@ -6736,73 +7438,73 @@ int32 rtl865x_setStormControl(uint32 type,uint32 enable,uint32 percentage)
 @func int32 | rtl8651_setAsic802D1xMacBaseAbility | set 802.1x mac based ability
 @parm enum PORTID | port | the port number (physical port: 0~5, extension port: 6~8)
 @parm uint32* | isEnable | 1: enabled, 0: disabled.
-@rvalue SUCCESS | 
+@rvalue SUCCESS |
 @rvalue FAILED | invalid parameter
 @comm
  */
 int32 rtl8651_setAsic802D1xMacBaseAbility( enum PORTID port, uint32 isEnable )
 {
 	/* Invalid input parameter */
-	if ((port < PHY0) || (port > EXT2)) 
+	if ((port < PHY0) || (port > EXT2))
 		return FAILED;
-	
+
 	/* Invalid input parameter */
 	if ((isEnable != TRUE) && (isEnable != FALSE))
-		return FAILED; 
+		return FAILED;
 
 	switch (port)
 	{
 		case PHY0:
 		WRITE_MEM32(DOT1XMACCR, isEnable == TRUE ? (READ_MEM32(DOT1XMACCR) | ( Dot1xMAC_P0En)):
-											(READ_MEM32(DOT1XMACCR) & ~( Dot1xMAC_P0En))); 
+											(READ_MEM32(DOT1XMACCR) & ~( Dot1xMAC_P0En)));
 			break;
-			
+
 		case PHY1:
 		WRITE_MEM32(DOT1XMACCR, isEnable == TRUE ? (READ_MEM32(DOT1XMACCR) | ( Dot1xMAC_P1En)):
-											(READ_MEM32(DOT1XMACCR) & ~( Dot1xMAC_P1En)));  
-			break;	
-			
+											(READ_MEM32(DOT1XMACCR) & ~( Dot1xMAC_P1En)));
+			break;
+
 		case PHY2:
 		WRITE_MEM32(DOT1XMACCR, isEnable == TRUE ? (READ_MEM32(DOT1XMACCR) | ( Dot1xMAC_P2En)):
 											(READ_MEM32(DOT1XMACCR) & ~( Dot1xMAC_P2En)));
 			break;
-			
+
 		case PHY3:
 		WRITE_MEM32(DOT1XMACCR, isEnable == TRUE ? (READ_MEM32(DOT1XMACCR) | ( Dot1xMAC_P3En)):
-											(READ_MEM32(DOT1XMACCR) & ~( Dot1xMAC_P3En)));  
+											(READ_MEM32(DOT1XMACCR) & ~( Dot1xMAC_P3En)));
 			break;
-			
+
 		case PHY4:
 		WRITE_MEM32(DOT1XMACCR, isEnable == TRUE ? (READ_MEM32(DOT1XMACCR) | ( Dot1xMAC_P4En)):
-											(READ_MEM32(DOT1XMACCR) & ~( Dot1xMAC_P4En)));  											
-			break;		
-			
+											(READ_MEM32(DOT1XMACCR) & ~( Dot1xMAC_P4En)));
+			break;
+
 		case PHY5:
 		WRITE_MEM32(DOT1XMACCR, isEnable == TRUE ? (READ_MEM32(DOT1XMACCR) | ( Dot1xMAC_P5En)):
 											(READ_MEM32(DOT1XMACCR) & ~( Dot1xMAC_P5En)));
 			break;
-											
+
 		case CPU:
 		WRITE_MEM32(DOT1XMACCR, isEnable == TRUE ? (READ_MEM32(DOT1XMACCR) | ( Dot1xMAC_P6En)):
 											(READ_MEM32(DOT1XMACCR) & ~( Dot1xMAC_P6En)));
 			break;
-			
+
 		case EXT1:
 		WRITE_MEM32(DOT1XMACCR, isEnable == TRUE ? (READ_MEM32(DOT1XMACCR) | ( Dot1xMAC_P7En)):
-											(READ_MEM32(DOT1XMACCR) & ~( Dot1xMAC_P7En)));  
+											(READ_MEM32(DOT1XMACCR) & ~( Dot1xMAC_P7En)));
 			break;
-			
+
 		case EXT2:
 		WRITE_MEM32(DOT1XMACCR, isEnable == TRUE ? (READ_MEM32(DOT1XMACCR) | ( Dot1xMAC_P8En)):
-											(READ_MEM32(DOT1XMACCR) & ~( Dot1xMAC_P8En))); 
+											(READ_MEM32(DOT1XMACCR) & ~( Dot1xMAC_P8En)));
 			break;
-			
+
 		case EXT3:
 			return FAILED;
 
 		case MULTEXT:
 			return FAILED;
-											
+
 	}
 	return SUCCESS;
 }
@@ -6810,7 +7512,7 @@ int32 rtl8651_setAsic802D1xMacBaseAbility( enum PORTID port, uint32 isEnable )
 /*
 @func int32 | rtl8651_setAsic802D1xMacBaseDirection | set 802.1x mac based direction
 @parm enum uint32 | dir | OperCOnntrolledDirections for MAC-Based ACCESS Control. 0:BOTH, 1:IN
-@rvalue SUCCESS | 
+@rvalue SUCCESS |
 @rvalue FAILED | invalid parameter
 @comm
  */
@@ -6830,7 +7532,7 @@ int32 rtl8651_setAsic802D1xMacBaseDirection(int32 dir)
 	}
 	else
 	{
-		WRITE_MEM32(DOT1XMACCR,(READ_MEM32(DOT1XMACCR)) &(~Dot1xMAC_OPDIR));	
+		WRITE_MEM32(DOT1XMACCR,(READ_MEM32(DOT1XMACCR)) &(~Dot1xMAC_OPDIR));
 	}
 	return SUCCESS;
 }
@@ -6838,34 +7540,34 @@ int32 rtl8651_setAsic802D1xMacBaseDirection(int32 dir)
 /*
 @func int32 | rtl8651_setAsicGuestVlanProcessControl | set guest vlan process control
 @parm enum  uint32 | process |default process for unauthenticated client  (00~11)<<12
-@rvalue SUCCESS 
+@rvalue SUCCESS
 @rvalue FAILED | invalid parameter
 @comm
  */
 int32 rtl8651_setAsicGuestVlanProcessControl( uint32 process)
 {
-	/* Invalid input parameter */	
+	/* Invalid input parameter */
 	if((process < Dot1xUNAUTHBH_DROP) || (process > Dot1xUNAUTHBH_RESERVED))
-		return FAILED;	
-	
+		return FAILED;
+
 	WRITE_MEM32(GVGCR, ((READ_MEM32(GVGCR)) & 0x0fff) | process);
 
 	return SUCCESS;
 }
 
-#if	defined(CONFIG_RTL_QOS_8021P_SUPPORT)
+
 /*
 @func int32 | rtl8651_setAsicDot1qAbsolutelyPriority | set 802.1Q absolutely priority
 @parm enum PRIORITYVALUE | srcpriority | priority value
-@parm enum PRIORITYVALUE | priority | absolute priority value 
-@rvalue SUCCESS | 
+@parm enum PRIORITYVALUE | priority | absolute priority value
+@rvalue SUCCESS |
 @rvalue FAILED | invalid parameter
 @comm
  */
 int32 rtl8651_setAsicDot1qAbsolutelyPriority( enum PRIORITYVALUE srcpriority, enum PRIORITYVALUE priority )
 {
 	/* Invalid input parameter */
-	if ((srcpriority < PRI0) || (srcpriority > PRI7) || (priority < PRI0) || (priority > PRI7)) 
+	if ((srcpriority < PRI0) || (srcpriority > PRI7) || (priority < PRI0) || (priority > PRI7))
 		return FAILED;
 
 	switch (srcpriority)
@@ -6893,10 +7595,10 @@ int32 rtl8651_setAsicDot1qAbsolutelyPriority( enum PRIORITYVALUE srcpriority, en
 
 
 /*
-@func int32 | rtl8651_getAsicDot1qAbsolutelyPriority | get 802.1Q absolutely priority 
+@func int32 | rtl8651_getAsicDot1qAbsolutelyPriority | get 802.1Q absolutely priority
 @parm enum PRIORITYVALUE | srcpriority | priority value
-@parm enum PRIORITYVALUE* | pPriority | pPriority will return the absolute priority value 
-@rvalue SUCCESS | 
+@parm enum PRIORITYVALUE* | pPriority | pPriority will return the absolute priority value
+@rvalue SUCCESS |
 @rvalue FAILED | invalid parameter
 @comm
  */
@@ -6904,7 +7606,7 @@ int32 rtl8651_getAsicDot1qAbsolutelyPriority( enum PRIORITYVALUE srcpriority, en
 {
 
 	/* Invalid input parameter */
-	if ((srcpriority < PRI0) || (srcpriority > PRI7)) 
+	if ((srcpriority < PRI0) || (srcpriority > PRI7))
 		return FAILED;
 
 	if (pPriority != NULL)
@@ -6934,10 +7636,12 @@ int32 rtl8651_getAsicDot1qAbsolutelyPriority( enum PRIORITYVALUE srcpriority, en
 }
 
 
+#if	defined(CONFIG_RTL_QOS_8021P_SUPPORT)
+
 /*
 @func int32 | rtl8651_flushAsicDot1qAbsolutelyPriority | set 802.1Q absolutely priority the default value 0
 @parm void
-@rvalue SUCCESS | 
+@rvalue SUCCESS |
 @comm
  */
 int32 rtl8651_flushAsicDot1qAbsolutelyPriority(void)
@@ -6958,22 +7662,22 @@ RTL865x provides an aggregator port. This API updates the table which maps hashe
 If portmask = 0: clear all aggregation port mappings.
 Rearrange policy is round-robin. ie. if port a,b,c is in portmask, then hash block 0~7's port number is a,b,c,a,b,c,a,b
 */
-int32  rtl8651_updateAsicLinkAggregatorLMPR(int32 portmask) 
+int32  rtl8651_updateAsicLinkAggregatorLMPR(int32 portmask)
 {
 	uint32 hIdx, portIdx, reg;
 
 	/* Clear all mappings */
-	WRITE_MEM32( LAGHPMR0, 0 );	
-	
+	WRITE_MEM32( LAGHPMR0, 0 );
+
 	if ( portmask == 0 )
 	{
 		return SUCCESS;
 	}
 
 	reg = 0;
-	portIdx = 0;	
+	portIdx = 0;
 	for ( hIdx = 0; hIdx < RTL865XC_LAGHASHIDX_NUMBER; hIdx++ )
-	{		
+	{
 		while ( ( ( 1 << portIdx ) & portmask ) == 0 )	/* Don't worry about infinite loop because portmask won't be 0. */
 		{
 			portIdx = ( portIdx + 1 ) % ( RTL8651_PORT_NUMBER + rtl8651_totalExtPortNum );
@@ -7017,8 +7721,8 @@ int32 rtl8651_setAsicEthernetLinkStatus(uint32 port, int8 linkUp)
 
 	rtl8651AsicEthernetTable[port].linkUp = (linkUp == TRUE)? TRUE: FALSE;
 
-	/* 
-		If the specified port is a member of the aggregator, 
+	/*
+		If the specified port is a member of the aggregator,
 		update the table which maps hashed index to the port
 		because the member port of the aggregator link changes.
 	*/
@@ -7054,7 +7758,7 @@ int32 rtl8651_setAsicRateLimitTable(uint32 index, rtl865x_tblAsicDrv_rateLimitPa
 int32 rtl8651_delAsicRateLimitTable(uint32 index)
 {
 	rtl8651_tblAsic_rateLimitTable_t entry;
-	
+
 	if (index >= RTL8651_RATELIMITTBL_SIZE)
 		return FAILED;
 	memset(&entry,0,sizeof(rtl8651_tblAsic_rateLimitTable_t));
@@ -7079,54 +7783,54 @@ int32 rtl8651_getAsicRateLimitTable(uint32 index, rtl865x_tblAsicDrv_rateLimitPa
 	return SUCCESS;
 }
 #endif
-#ifdef CONFIG_RTK_VOIP_QOS
+
 /*
- * @func int32 | rtl8651_setAsicDscpPriority | set DSCP-based priority 
+ * @func int32 | rtl8651_setAsicDscpPriority | set DSCP-based priority
  * @parm uint32 | dscp | DSCP value
- * @parm enum PRIORITYVALUE | priority | priority value 
- * @rvalue SUCCESS | 
+ * @parm enum PRIORITYVALUE | priority | priority value
+ * @rvalue SUCCESS |
  * @rvalue FAILED | invalid parameter
  * @comm
  *  */
 int32 rtl8651_setAsicDscpPriority( uint32 dscp, enum PRIORITYVALUE priority )
 {
 	/* Invalid input parameter */
-	if ((dscp < 0) || (dscp > 63)) 
+	if ((dscp < 0) || (dscp > 63))
 		return FAILED;
-	if ((priority < PRI0) || (priority > PRI7)) 
+	if ((priority < PRI0) || (priority > PRI7))
 		return FAILED;
 
 	if ((0 <= dscp) && (dscp <= 9))
-		WRITE_MEM32(DSCPCR0, (READ_MEM32(DSCPCR0) & ~(0x7 << (dscp*3))) | (priority << (dscp*3))); 
+		WRITE_MEM32(DSCPCR0, (READ_MEM32(DSCPCR0) & ~(0x7 << (dscp*3))) | (priority << (dscp*3)));
 	else if ((10 <= dscp) && (dscp <= 19))
-		WRITE_MEM32(DSCPCR1, (READ_MEM32(DSCPCR1) & ~(0x7 << ((dscp%10)*3))) | (priority << ((dscp%10)*3))); 
+		WRITE_MEM32(DSCPCR1, (READ_MEM32(DSCPCR1) & ~(0x7 << ((dscp%10)*3))) | (priority << ((dscp%10)*3)));
 	else if ((20 <= dscp) && (dscp <= 29))
-		WRITE_MEM32(DSCPCR2, (READ_MEM32(DSCPCR2) & ~(0x7 << ((dscp%10)*3))) | (priority << ((dscp%10)*3))); 
+		WRITE_MEM32(DSCPCR2, (READ_MEM32(DSCPCR2) & ~(0x7 << ((dscp%10)*3))) | (priority << ((dscp%10)*3)));
 	else if ((30 <= dscp) && (dscp <= 39))
-		WRITE_MEM32(DSCPCR3, (READ_MEM32(DSCPCR3) & ~(0x7 << ((dscp%10)*3))) | (priority << ((dscp%10)*3))); 
+		WRITE_MEM32(DSCPCR3, (READ_MEM32(DSCPCR3) & ~(0x7 << ((dscp%10)*3))) | (priority << ((dscp%10)*3)));
 	else if ((40 <= dscp) && (dscp <= 49))
-		WRITE_MEM32(DSCPCR4, (READ_MEM32(DSCPCR4) & ~(0x7 << ((dscp%10)*3))) | (priority << ((dscp%10)*3))); 
+		WRITE_MEM32(DSCPCR4, (READ_MEM32(DSCPCR4) & ~(0x7 << ((dscp%10)*3))) | (priority << ((dscp%10)*3)));
 	else if ((50 <= dscp) && (dscp <= 59))
-		WRITE_MEM32(DSCPCR5, (READ_MEM32(DSCPCR5) & ~(0x7 << ((dscp%10)*3))) | (priority << ((dscp%10)*3))); 
+		WRITE_MEM32(DSCPCR5, (READ_MEM32(DSCPCR5) & ~(0x7 << ((dscp%10)*3))) | (priority << ((dscp%10)*3)));
 	else if ((60 <= dscp) && (dscp <= 63))
-		WRITE_MEM32(DSCPCR6, (READ_MEM32(DSCPCR6) & ~(0x7 << ((dscp%10)*3))) | (priority << ((dscp%10)*3))); 
+		WRITE_MEM32(DSCPCR6, (READ_MEM32(DSCPCR6) & ~(0x7 << ((dscp%10)*3))) | (priority << ((dscp%10)*3)));
 
 	return SUCCESS;
 }
 
 
 /*
- * @func int32 | rtl8651_setAsicDscpPriority | set DSCP-based priority 
+ * @func int32 | rtl8651_setAsicDscpPriority | set DSCP-based priority
  * @parm uint32 | dscp | DSCP value
  * @parm enum PRIORITYVALUE* | pPriority | pPriority will return the priority of the specified DSCP
- * @rvalue SUCCESS | 
+ * @rvalue SUCCESS |
  * @rvalue FAILED | invalid parameter
  * @comm
  *  */
 int32 rtl8651_getAsicDscpPriority( uint32 dscp, enum PRIORITYVALUE *pPriority )
 {
 	/* Invalid input parameter */
-	if ((dscp < 0) || (dscp > 63)) 
+	if ((dscp < 0) || (dscp > 63))
 		return FAILED;
 
 	if (pPriority != NULL)
@@ -7150,17 +7854,19 @@ int32 rtl8651_getAsicDscpPriority( uint32 dscp, enum PRIORITYVALUE *pPriority )
 	return SUCCESS;
 }
 
-int32 rtl8651_reset_dscp_priority(void) 
+#ifdef CONFIG_RTK_VOIP_QOS
+
+int32 rtl8651_reset_dscp_priority(void)
 {
-	//clear dscp priority assignment, otherwise pkt with dscp value 0 will be assign priority 1		
+	//clear dscp priority assignment, otherwise pkt with dscp value 0 will be assign priority 1
 	WRITE_MEM32(DSCPCR0,0);
 	WRITE_MEM32(DSCPCR1,0);
 	WRITE_MEM32(DSCPCR2,0);
 	WRITE_MEM32(DSCPCR3,0);
 	WRITE_MEM32(DSCPCR4,0);
 	WRITE_MEM32(DSCPCR5,0);
-	WRITE_MEM32(DSCPCR6,0);	       
-	return 0; 
+	WRITE_MEM32(DSCPCR6,0);
+	return 0;
 }
 int32 rtl8651_cpu_tx_fc(int enable)
 {
@@ -7179,7 +7885,7 @@ int32 rtl8651_setQueueNumber(int port, int qnum)
         rtl865xC_unLockSWCore();
         return SUCCESS;
 }
-#endif 
+#endif
 #ifdef CONFIG_RTK_VOIP_PORT_LINK
 int rtl8651_getAsicEthernetLinkStatus(uint32 port, int8 *linkUp)
 {
diff --git a/drivers/net/rtl819x/AsicDriver/rtl865x_asicL2.h b/drivers/net/rtl819x/AsicDriver/rtl865x_asicL2.h
index abe8978..e51ddc8 100644
--- a/drivers/net/rtl819x/AsicDriver/rtl865x_asicL2.h
+++ b/drivers/net/rtl819x/AsicDriver/rtl865x_asicL2.h
@@ -88,6 +88,12 @@ enum PORTID
 	EXT3 = 9,
 	MULTEXT = 10,
 };
+enum GROUP
+{
+	GR0 = 0,
+	GR1 = 1,
+	GR2 = 2,
+};
 
 /* enum for queue ID */
 enum QUEUEID
@@ -341,11 +347,26 @@ int32 rtl865xC_waitForOutputQueueEmpty(void);
 int32 rtl8651_setAsic802D1xMacBaseAbility( enum PORTID port, uint32 isEnable );
 int32 rtl8651_setAsic802D1xMacBaseDirection(int32 dir);
 int32 rtl8651_setAsicGuestVlanProcessControl( uint32 process);
+int32 rtl8651_setAsicPortBasedPriority( enum PORTID port, enum PRIORITYVALUE priority );
+int32 rtl8651_setAsicQueueStrict( enum PORTID port, enum QUEUEID queueid, enum QUEUETYPE queueType);
+int32 rtl8651_setAsicVlanRemark(enum PORTID port, enum PRIORITYVALUE priority, int remark);
+int32 rtl8651_setAsicDscpRemark(enum PORTID port, enum PRIORITYVALUE priority, int remark);
+int32 rtl8651_getAsicPortBasedPriority( enum PORTID port, enum PRIORITYVALUE* priority );
+int32 rtl8651_getAsicQueueStrict( enum PORTID port, enum QUEUEID queueid, enum QUEUETYPE *pQueueType);
+int32 rtl8651_getAsicPriorityToQIDMappingTable( enum QUEUENUM qnum, enum PRIORITYVALUE priority, enum QUEUEID* qid );
+int32 rtl8651_getAsicPriorityDecision( uint32* portpri, uint32* dot1qpri, uint32* dscppri, uint32* aclpri, uint32* natpri );
+int32 rtl8651_getAsicVlanRemark(enum PORTID port, enum PRIORITYVALUE priority, int* remark);
+int32 rtl8651_getAsicDscpRemark(enum PORTID port, enum PRIORITYVALUE priority, int* remark);
+
 
-#if	defined(CONFIG_RTL_QOS_8021P_SUPPORT)
 /* for vlan base qos */
 int32 rtl8651_setAsicDot1qAbsolutelyPriority( enum PRIORITYVALUE srcpriority, enum PRIORITYVALUE priority );
 int32 rtl8651_getAsicDot1qAbsolutelyPriority( enum PRIORITYVALUE srcpriority, enum PRIORITYVALUE *pPriority );
+
+#if	defined(CONFIG_RTL_QOS_8021P_SUPPORT)
+/* for vlan base qos */
+//int32 rtl8651_setAsicDot1qAbsolutelyPriority( enum PRIORITYVALUE srcpriority, enum PRIORITYVALUE priority );
+//int32 rtl8651_getAsicDot1qAbsolutelyPriority( enum PRIORITYVALUE srcpriority, enum PRIORITYVALUE *pPriority );
 int32 rtl8651_flushAsicDot1qAbsolutelyPriority(void);
 #endif
 
@@ -355,11 +376,18 @@ int32 rtl8651_delAsicRateLimitTable(uint32 index);
 int32 rtl8651_getAsicRateLimitTable(uint32 index, rtl865x_tblAsicDrv_rateLimitParam_t *rateLimit_t);
 #endif
 
-#ifdef CONFIG_RTK_VOIP_QOS
+
 int32 rtl8651_setAsicDscpPriority( uint32 dscp, enum PRIORITYVALUE priority );
 int32 rtl8651_getAsicDscpPriority( uint32 dscp, enum PRIORITYVALUE *pPriority );
+
+#ifdef CONFIG_RTK_VOIP_QOS
 int32 rtl8651_reset_dscp_priority(void);
 int32 rtl8651_cpu_tx_fc(int enable);
+int32 rtl8651_setQueueNumber(int port, int qnum);
+#endif
+
+#ifdef CONFIG_RTL_8197D_DYN_THR	
+int32 rtl819x_setQosThreshold(uint32 old_sts, uint32 new_sts);
 #endif
 
 #endif
diff --git a/drivers/net/rtl819x/AsicDriver/rtl865x_asicL3.h b/drivers/net/rtl819x/AsicDriver/rtl865x_asicL3.h
index 5afd2da..3dbf8ee 100644
--- a/drivers/net/rtl819x/AsicDriver/rtl865x_asicL3.h
+++ b/drivers/net/rtl819x/AsicDriver/rtl865x_asicL3.h
@@ -17,9 +17,17 @@
 #define RTL8651_ROUTINGTBL_SIZE		8
 #define RTL8651_ARPTBL_SIZE			512
 
-#if defined (CONFIG_RTL8196C_REVISION_B) || defined (CONFIG_RTL8198_REVISION_B) 
+#if defined(CONFIG_RTL_8196E)
+
+#define RTL8651_MULTICASTTBL_SIZE			256
+#define RTL8651_IPMULTICASTTBL_SIZE		256
+#define RTL8651_IPMCAST_CAM_SIZE			32
+
+#elif defined (CONFIG_RTL8196C_REVISION_B) || defined (CONFIG_RTL8198_REVISION_B) || defined(CONFIG_RTL_819XD)
 #define RTL8651_IPMULTICASTTBL_SIZE		128
 #define RTL8651_MULTICASTTBL_SIZE		128
+#define RTL8651_IPMCAST_CAM_SIZE			32
+
 #else
 #define RTL8651_IPMULTICASTTBL_SIZE		64
 #define RTL8651_MULTICASTTBL_SIZE		64
@@ -321,7 +329,7 @@ typedef struct {
 } rtl865xc_tblAsic_arpTable_t;
 
 typedef struct {
-#if defined (CONFIG_RTL8196C_REVISION_B) || defined (CONFIG_RTL8198_REVISION_B)
+#if defined (CONFIG_RTL8196C_REVISION_B) || defined (CONFIG_RTL8198_REVISION_B) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
     /* word 0 */
     ipaddr_t        srcIPAddr;
     /* word 1 */
diff --git a/drivers/net/rtl819x/AsicDriver/rtl865xc_asicregs.h b/drivers/net/rtl819x/AsicDriver/rtl865xc_asicregs.h
index 5454a46..55da054 100644
--- a/drivers/net/rtl819x/AsicDriver/rtl865xc_asicregs.h
+++ b/drivers/net/rtl819x/AsicDriver/rtl865xc_asicregs.h
@@ -174,7 +174,7 @@ extern int8						*pVirtualSWTable;
 #define HSA_BASE			REAL_HSA_BASE
 #endif
 
-#ifdef CONFIG_RTL_8198
+#if defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 #define PIN_MUX_SEL_2                           (SYSTEM_BASE + 0x0044)
 #endif
 
@@ -504,6 +504,11 @@ link partner ability registers field definitions
 #define CPUTPDCR1					(0x024 + CPU_IFACE_BASE)		/* Tx pkthdr descriptor control High */
 #define CPUTPDCR(idx)				(CPUTPDCR0 + (idx << 2))		/* Tx pkthdr descriptor control with index */
 
+#if defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+#define CPUTPDCR2					(0x060 + CPU_IFACE_BASE)    /* Tx Pkthdr Descriptor 2 Control Register */
+#define CPUTPDCR3					(0x064 + CPU_IFACE_BASE)    /* Tx Pkthdr Descriptor 3 Control Register */
+#endif
+
 #define CPUIIMR						(0x028 + CPU_IFACE_BASE)		/* Interrupt mask control */
 #define CPUIISR						(0x02c + CPU_IFACE_BASE)		/* Interrupt status control */
 #define CPUQDM0						(0x030 + CPU_IFACE_BASE)		/* Queue ID 0 and Descriptor Ring Mapping Register */
@@ -622,8 +627,8 @@ link partner ability registers field definitions
 #define PKTHDR_DESC_RUNOUT_IP_ALL	(0x3f << 17)			/* Run out anyone pkthdr descriptor interrupt pending */
 #define PKTHDR_DESC_RUNOUT_IP(idx)		(1 << (17+(idx)))		/* Run out pkthdr descriptor [IDX] interrupt pending */
 
-#define MBUF_DESC_RUNOUT_IP_ALL		(1 << 11)			/* Run out anyone mbuf interrupt pending */
-#define MBUF_DESC_RUNOUT_IP0			(1 << 11)			/* Run out mbuf descriptor 0 interrupt pending */
+#define MBUF_DESC_RUNOUT_IP_ALL		(1 << 16)			/* Run out anyone mbuf interrupt pending */
+#define MBUF_DESC_RUNOUT_IP0			(1 << 16)			/* Run out mbuf descriptor 0 interrupt pending */
 
 #define TX_DONE_IP0						(1 << 9)				/* Tx one packet done interrupt for descriptor 0 pending */
 #define TX_DONE_IP1						(1 << 10)			/* Tx one packet done interrupt for descriptor 1 pending */
@@ -760,7 +765,7 @@ link partner ability registers field definitions
 #define USEDDSC_MASK				(0x3ff<<16)				/* Total Used Descriptor */
 #define SharedBufFCON_Flag			(1<<14)					/* SharedBufFCON threshold triggerred flag */
 #define MaxUsedDsc_OFFSET			0						/* Max Used Descriptor Count History */
-#define MaxUsedDsc_MASK			(0x3ff<<0)				/* Max Used Descriptor Count History */
+#define MaxUsedDsc_MASK			(0x3fff<<0)				/* Max Used Descriptor Count History */
 
 /* PCSR0 - Port Congestion Status Register 0 */
 #define P3OQCgst_OFFSET			(24)
@@ -1028,6 +1033,8 @@ to forward packet to the unauthorized node. Otherwise, it is not allowed.
 #define SELIPG_11                    		(2<<18)     			/* 11, unit: byte-time */
 #define SELIPG_12                    		(3<<18)     			/* 12, unit: byte-time */
 #define SPDUP_100       	                    (1 << 16)                /* 10000 times speed up aging timer */
+#define CF_SYSCLK_SEL_MASK					(0x3 << 12)
+#define CF_SYSCLK_SEL_OFFSET				(12)
 #define CF_FCDSC_OFFSET                    (4)                     	/* Flow control DSC tolerance, default: 24 pages ( also minimum value ) */
 #define CF_FCDSC_MASK                       (0x7f << 4)                /* Flow control DSC tolerance, default: 24 pages ( also minimum value ) */
 #define CF_RXIPG_MASK                       (0xf << 0)                /* Min. IPG limitation for RX receiving packetMinimum value is 6. Maximum value is 12. */
@@ -1107,7 +1114,7 @@ to forward packet to the unauthorized node. Otherwise, it is not allowed.
 /* CSCR, CCR - Checksum Control Register */
 #define EnL4ChkCal                          (1<<5)                   /* Enable L4 Checksum Re-calculation */
 #define EnL3ChkCal                          (1<<4)                   /* Enable L3 Checksum Re-calculation */
-#if defined(CONFIG_RTL_8196C) || defined(CONFIG_RTL_8198)
+#if defined(CONFIG_RTL_8196C) || defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 #define AcceptL2Err                          (1<<3)                   /* CPU port L2 CRC Error Allow; 0: Not Allowed, 1: Allowed (default) */
 #endif
 #define L4ChkSErrAllow                      (1<<2)                   /* L4 Checksum Error Allow */
@@ -1154,7 +1161,7 @@ to forward packet to the unauthorized node. Otherwise, it is not allowed.
 #define Port0_TypeCfg_UTP                   (0<< 0)
 #define Port0_TypeCfg_GMII_MII_RGMII        (1<< 0)
 
-#if defined(CONFIG_RTL_8196C) || defined(CONFIG_RTL_8198)
+#if defined(CONFIG_RTL_8196C) || defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 
 #define GIGA_P5_PHYID	0x16
 /* 0xBB804104 ~ 0xBB804124 */
@@ -1312,6 +1319,8 @@ to forward packet to the unauthorized node. Otherwise, it is not allowed.
 #endif
 
 /* PSRP0,PSRP1,PSRP2,PSRP3,PSRP4,PSRP5,PSRP6,PSRP7,PSRP8 - Port Status Register Port 0~8 */
+#define PortEEEStatus_MASK					(3<<12)
+#define PortEEEStatus_OFFSET				12
 #define LinkDownEventFlag                   (1<<8)      /* Port Link Down Event detecting monitor flag */
 #define PortStatusNWayEnable                (1<<7)      /* N-Way Enable */
 #define PortStatusRXPAUSE                   (1<<6)      /* Rx PAUSE */
@@ -1386,7 +1395,7 @@ to forward packet to the unauthorized node. Otherwise, it is not allowed.
 #define CVIDR                               (0x00+SWMISC_BASE)     /* Chip Version ID Register */
 #define SSIR						        (0x04+SWMISC_BASE)     /* System Initial and Reset Registe*/
 
-#if defined(CONFIG_RTL_8196C) || defined(CONFIG_RTL_8198)
+#if defined(CONFIG_RTL_8196C) || defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 #define CRMR                                (0x08+SWMISC_BASE)     /* Chip Revision Management Register */
 #define BISTCR                              (0x0C+SWMISC_BASE)     /* BIST control */
 #define BISTTSDR0                           (0x38+SWMISC_BASE)     /* BIST Test Status Diagnostic Register 0 */
@@ -1419,6 +1428,10 @@ to forward packet to the unauthorized node. Otherwise, it is not allowed.
 #endif
 #define SIRR						        (SSIR)                 /* Alias Name */
 
+#if defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+#define MEMCR                              (0x34+SWMISC_BASE)     /* MEM CTRL Register */
+#endif
+
 /* 	SIRR, SSIR - System Initial and Reset Register*/
 #define SwitchFullRst                       (1 << 2)   /* Reset all tables & queues */
 #define SwitchSemiRst                       (1 << 1)   /* Reset queues */
@@ -1701,6 +1714,10 @@ to forward packet to the unauthorized node. Otherwise, it is not allowed.
 #define QPKTFCRP5G0                         (0x0B8+SBFCTR)        /* Queue-Packet-Based Flow Control Register for Port 5 Group 0 */
 #define QPKTFCRP5G1                         (0x0BC+SBFCTR)        /* Queue-Packet-Based Flow Control Register for Port 5 Group 1 */
 #define QPKTFCRP5G2                         (0x0C0+SBFCTR)        /* Queue-Packet-Based Flow Control Register for Port 5 Group 2 */
+#define QPKTFCRP6G0							(0x0C4+SBFCTR)		  /* Queue-Packet-Based Flow Control Register for Port 6 Group 0 */
+#define QPKTFCRP6G1							(0x0C8+SBFCTR)		  /* Queue-Packet-Based Flow Control Register for Port 6 Group 1 */
+#define QPKTFCRP6G2							(0x0CC+SBFCTR)		  /* Queue-Packet-Based Flow Control Register for Port 6 Group 2 */
+
 #define FCCR0                               (0x0d0+SBFCTR)        /* Flow Control Configuration Register 0 */
 #define FCCR1                               (0x0d4+SBFCTR)        /* Flow Control Configuration Register 1 */
 #define PQPLGR                              (0x0d8+SBFCTR)        /* Per Queue Physical Length Gap Register */
@@ -3090,6 +3107,7 @@ enum FDB_FLAGS
 	#define PIN_MUX_SEL     (SYSTEM_BASE+0x30)      /* 0xB8000030 - 0xB8000033 */
 #else
 	#define PIN_MUX_SEL 0xb8000040
+	#define PIN_MUX_SEL2 	0xb8000044
 #endif
 
 /* Shared Pin Register field definitions */
@@ -3496,6 +3514,9 @@ void rtl865x_wireCompBlinkAmber(void);
 #define SYS_CLK_MAG 0xb8000010
 #define SYS_SW_CLK_ENABLE  0x200
 #define SYS_SW_RESET 0x800
+#define CM_ACTIVE_SWCORE			(1<<11)
+#define CM_PROTECT					(1<<27)
+
 #endif   /* _ASICREGS_H */
 
 
diff --git a/drivers/net/rtl819x/Kconfig b/drivers/net/rtl819x/Kconfig
index e90cb13..251c511 100644
--- a/drivers/net/rtl819x/Kconfig
+++ b/drivers/net/rtl819x/Kconfig
@@ -31,6 +31,7 @@ config RTL_IGMP_PROXY
 config RTL_IGMP_SNOOPING
 	bool
 	default y
+	depends on BRIDGE
 
 config RTL_MLD_SNOOPING
 	bool 
@@ -41,6 +42,10 @@ config RTL_LINKCHG_PROCESS
 	bool
 	default y
 
+config RTL_DEBUG_TOOL
+	bool
+	default y
+
 menu "Config MIPS16-Inst Option for Kernel Modules"
 	config RTL865X_KERNEL_MIPS16
 		bool "Enable MIPS16 Encoding for Linux Kernel"
@@ -346,6 +351,10 @@ config RTL_PROC_DEBUG
 	default n
 	depends on RTL_819X
 
+config RTL_LOG_DEBUG
+	bool "Enable log print system for debug"
+	default n
+
 config RTL865X_ROMEPERF
 	bool "Enable rome perf"
 	default n
@@ -356,11 +365,27 @@ config RTK_VLAN_SUPPORT
 	default y
 	depends on RTL_819X
 
+config RTK_VLAN_WAN_TAG_SUPPORT
+	bool "Support rtk vlan wan tag feature"
+	default n
+	depends on RTK_VLAN_SUPPORT`
+	depends on RTL_819X
+
 config RTK_VLAN_FOR_CABLE_MODEM
 	bool "rtk vlan for cable modem"
 	default n
 	depends on RTK_VLAN_SUPPORT
 
+config RTK_VLAN_NEW_FEATURE
+        bool "add rtk vlan bridge feature"
+        default n
+        depends on RTK_VLAN_SUPPORT
+
+config RTL_HW_VLAN_SUPPORT
+        bool "Support rtl hw vlan feature"
+        default n
+        depends on RTK_VLAN_SUPPORT
+	depends on RTL_8196CT || RTL_8198T
 #config NMS
 #	bool "Enable NMS"
 #	default n
@@ -399,7 +424,11 @@ config RTL_EEE_DISABLED
 config RTL_REINIT_SWITCH_CORE
 	bool
 	default y
-	depends on RTL_8196C
+	depends on RTL_8196C || RTL_819XD || RTL_8196E
+
+config RTL_SOCK_DEBUG
+	bool
+	default n
 endif #RTL_819X_SWCORE
 #endmenu
 #============================= End of Kconfig ===============================#
diff --git a/drivers/net/rtl819x/Makefile b/drivers/net/rtl819x/Makefile
index 584a163..7a08142 100644
--- a/drivers/net/rtl819x/Makefile
+++ b/drivers/net/rtl819x/Makefile
@@ -10,7 +10,7 @@
 
 #obj-y := mmap.o
 
-DIR_RTLASIC = $(TOPDIR)/drivers/net/rtl819x/
+DIR_RTLASIC = $(DIR_LINUX)/drivers/net/rtl819x/
 EXTRA_CFLAGS += -DCONFIG_RTL865X_MODULE_INTERNAL
 
 #obj-y := rtl_glue.o
@@ -27,6 +27,7 @@ endif
 #
 obj-y += rtl865xc_swNic.o
 obj-y += rtl_nic.o
+obj-$(CONFIG_RTL_DEBUG_TOOL) += rtl865x_proc_debug.o
 obj-$(CONFIG_RTL_PROC_DEBUG) += rtl865x_proc_debug.o
 obj-$(CONFIG_RTL865X_ROMEPERF) += romeperf.o
 
@@ -57,8 +58,8 @@ endif
 #
 ########################################################################################################
 
-EXTRA_CFLAGS += -I$(TOPDIR)/include
-EXTRA_CFLAGS += -I$(TOPDIR)/arch/rlx/bsp
+EXTRA_CFLAGS += -I$(DIR_LINUX)/include
+EXTRA_CFLAGS += -I$(DIR_ROOT)/target/bsp
 EXTRA_CFLAGS += -I$(DIR_RTLASIC)
 EXTRA_CFLAGS += -I$(DIR_BOARD)
 EXTRA_CFLAGS += -D__KERNEL__ 
diff --git a/drivers/net/rtl819x/common/Makefile b/drivers/net/rtl819x/common/Makefile
index 5414e6f..36e5d28 100644
--- a/drivers/net/rtl819x/common/Makefile
+++ b/drivers/net/rtl819x/common/Makefile
@@ -9,7 +9,7 @@
 
 #Add mips16 Support
 
-DIR_RTLASIC = $(TOPDIR)/drivers/net/rtl819x/
+DIR_RTLASIC = $(DIR_LINUX)/drivers/net/rtl819x/
 
 ifeq ($(CONFIG_RTK_IPTABLES_FAST_PATH),m)
 EXTRA_CFLAGS += -DCONFIG_FAST_PATH_MODULE
diff --git a/drivers/net/rtl819x/common/mbuf.h b/drivers/net/rtl819x/common/mbuf.h
index dfe886b..7317a1c 100644
--- a/drivers/net/rtl819x/common/mbuf.h
+++ b/drivers/net/rtl819x/common/mbuf.h
@@ -174,7 +174,13 @@ struct rtl_pktHdr
 												(PKTHDR_VLAN_P3_AUTOADD)|	\
 												(PKTHDR_VLAN_P4_AUTOADD)|	\
 												(PKTHDR_VLAN_P5_AUTOADD)	)
-
+#if defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+	uint8	ph_ptpResv:1;
+	uint8	ph_ptpMsgType:4;	/* message type */
+	uint8	ph_ptpVer:2;		/* PTP version, 0: 1588v1; 1: 1588v2 or 802.1as; others: reserved */
+	uint8	ph_ptpPkt:1;			/* 1: PTP */
+	int8		ph_reserved[3];		/* padding */
+#endif
 };
 
 	//property for ph_unnumber		: cw_du 
diff --git a/drivers/net/rtl819x/common/rtl8651_tblDrvProto.h b/drivers/net/rtl819x/common/rtl8651_tblDrvProto.h
index 8dbb848..5b1d362 100644
--- a/drivers/net/rtl819x/common/rtl8651_tblDrvProto.h
+++ b/drivers/net/rtl819x/common/rtl8651_tblDrvProto.h
@@ -1,12 +1,15 @@
 /*
-* Copyright c                  Realtek Semiconductor Corporation, 2002  
-* All rights reserved.
-* 
 * Program : Protocol Header rtl8651_proto.h
 * Abstract : 
 * Author : Chih-Hua Huang (chhuang@realtek.com.tw)               
 * $Id: rtl8651_tblDrvProto.h,v 1.1 2007-12-21 10:29:52 davidhsu Exp $
 *
+*  Copyright (c) 2011 Realtek Semiconductor Corp.
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License version 2 as
+*  published by the Free Software Foundation.
+
 */
 
 #ifndef RTL8651_TBLDRV_PROTO_H
diff --git a/drivers/net/rtl819x/common/rtl865x_netif.c b/drivers/net/rtl819x/common/rtl865x_netif.c
index 1fe0f0d..a885b69 100644
--- a/drivers/net/rtl819x/common/rtl865x_netif.c
+++ b/drivers/net/rtl819x/common/rtl865x_netif.c
@@ -1,10 +1,10 @@
 /*
-* Copyright c                  Realtek Semiconductor Corporation, 2008  
+* Copyright c                  Realtek Semiconductor Corporation, 2008
 * All rights reserved.
-* 
+*
 * Program : network interface driver
-* Abstract : 
-* Author : hyking (hyking_liu@realsil.com.cn)  
+* Abstract :
+* Author : hyking (hyking_liu@realsil.com.cn)
 */
 
 /*      @doc RTL_LAYEREDDRV_API
@@ -18,7 +18,7 @@
 
         @head3 List of Symbols |
         Here is a list of all functions and variables in this module.
-        
+
         @index | RTL_LAYEREDDRV_API
 */
 #include <net/rtl/rtl_types.h>
@@ -69,8 +69,8 @@ int32 rtl865x_show_allAclChains(void)
 	rtl865x_acl_chain_t *chain;
 	rtl865x_AclRule_t *rule;
 	int32 i,j;
-	int8 *actionT[] = { "permit", "redirect to ether", "drop", "to cpu", "legacy drop", 
-					"drop for log", "mirror", "redirect to pppoe", "default redirect", "mirror keep match", 
+	int8 *actionT[] = { "permit", "redirect to ether", "drop", "to cpu", "legacy drop",
+					"drop for log", "mirror", "redirect to pppoe", "default redirect", "mirror keep match",
 					"drop rate exceed pps", "log rate exceed pps", "drop rate exceed bps", "log rate exceed bps","priority "
 					};
 
@@ -84,7 +84,7 @@ int32 rtl865x_show_allAclChains(void)
 				printk("netif(%s),isEgress(%d):\n",netif->name,j);
 				chain = netif->chainListHead[j];
 				while(chain)
-				{					
+				{
 					printk("\tchain:priority(%d),rulecnt(%d)\n",chain->priority,chain->ruleCnt);
 					printk("===========================\n");
 					rule = chain->head;
@@ -101,7 +101,7 @@ int32 rtl865x_show_allAclChains(void)
 										rule->dstMacMask_.octet[0], rule->dstMacMask_.octet[1], rule->dstMacMask_.octet[2],
 										rule->dstMacMask_.octet[3], rule->dstMacMask_.octet[4], rule->dstMacMask_.octet[5]
 										);
-								
+
 								printk( "\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n",
 										rule->srcMac_.octet[0], rule->srcMac_.octet[1], rule->srcMac_.octet[2],
 										rule->srcMac_.octet[3], rule->srcMac_.octet[4], rule->srcMac_.octet[5],
@@ -125,14 +125,14 @@ int32 rtl865x_show_allAclChains(void)
 								printk("\tTos: %x   TosM: %x   ipProto: %x   ipProtoM: %x   ipFlag: %x   ipFlagM: %x\n",
 										rule->tos_, rule->tosMask_, rule->ipProto_, rule->ipProtoMask_, rule->ipFlag_, rule->ipFlagMask_
 									);
-								
+
 								printk("\t<FOP:%x> <FOM:%x> <http:%x> <httpM:%x> <IdentSdip:%x> <IdentSdipM:%x> \n",
 										rule->ipFOP_, rule->ipFOM_, rule->ipHttpFilter_, rule->ipHttpFilterM_, rule->ipIdentSrcDstIp_,
 										rule->ipIdentSrcDstIpM_
 										);
-								printk( "\t<DF:%x> <MF:%x>\n", rule->ipDF_, rule->ipMF_); 
+								printk( "\t<DF:%x> <MF:%x>\n", rule->ipDF_, rule->ipMF_);
 									break;
-									
+
 							case RTL865X_ACL_IP_RANGE:
 								printk(" [%d] rule type: %s   rule action: %s\n", rule->aclIdx, "IP Range", actionT[rule->actionType_]);
 								printk("\tdipU: %d.%d.%d.%d dipL: %d.%d.%d.%d\n", (rule->dstIpAddr_>>24),
@@ -152,8 +152,8 @@ int32 rtl865x_show_allAclChains(void)
 										rule->ipFOP_, rule->ipFOM_, rule->ipHttpFilter_, rule->ipHttpFilterM_, rule->ipIdentSrcDstIp_,
 										rule->ipIdentSrcDstIpM_
 										);
-									printk("\t<DF:%x> <MF:%x>\n", rule->ipDF_, rule->ipMF_); 
-									break;			
+									printk("\t<DF:%x> <MF:%x>\n", rule->ipDF_, rule->ipMF_);
+									break;
 							case RTL865X_ACL_ICMP:
 								printk(" [%d] rule type: %s   rule action: %s\n", rule->aclIdx, "ICMP", actionT[rule->actionType_]);
 								printk("\tdip: %d.%d.%d.%d dipM: %d.%d.%d.%d\n", (rule->dstIpAddr_>>24),
@@ -167,7 +167,7 @@ int32 rtl865x_show_allAclChains(void)
 										((rule->srcIpAddrMask_&0x0000ff00)>>8), (rule->srcIpAddrMask_&0xff)
 										);
 								printk("\tTos: %x   TosM: %x   type: %x   typeM: %x   code: %x   codeM: %x\n",
-										rule->tos_, rule->tosMask_, rule->icmpType_, rule->icmpTypeMask_, 
+										rule->tos_, rule->tosMask_, rule->icmpType_, rule->icmpTypeMask_,
 										rule->icmpCode_, rule->icmpCodeMask_);
 								break;
 							case RTL865X_ACL_ICMP_IPRANGE:
@@ -183,7 +183,7 @@ int32 rtl865x_show_allAclChains(void)
 										((rule->srcIpAddrMask_&0x0000ff00)>>8), (rule->srcIpAddrMask_&0xff)
 										);
 								printk("\tTos: %x   TosM: %x   type: %x   typeM: %x   code: %x   codeM: %x\n",
-										rule->tos_, rule->tosMask_, rule->icmpType_, rule->icmpTypeMask_, 
+										rule->tos_, rule->tosMask_, rule->icmpType_, rule->icmpTypeMask_,
 										rule->icmpCode_, rule->icmpCodeMask_);
 								break;
 							case RTL865X_ACL_IGMP:
@@ -280,7 +280,7 @@ int32 rtl865x_show_allAclChains(void)
 										rule->tos_, rule->tosMask_, rule->udpSrcPortLB_, rule->udpSrcPortUB_,
 										rule->udpDstPortLB_, rule->udpDstPortUB_
 										);
-								break;				
+								break;
 							case RTL865X_ACL_UDP_IPRANGE:
 								printk(" [%d] rule type: %s   rule action: %s\n", rule->aclIdx, "UDP IP RANGE", actionT[rule->actionType_]);
 								printk("\tdipU: %d.%d.%d.%d dipL: %d.%d.%d.%d\n", (rule->dstIpAddr_>>24),
@@ -297,13 +297,13 @@ int32 rtl865x_show_allAclChains(void)
 										rule->tos_, rule->tosMask_, rule->udpSrcPortLB_, rule->udpSrcPortUB_,
 										rule->udpDstPortLB_, rule->udpDstPortUB_
 									);
-								break;				
+								break;
+
 
-							
 							case RTL865X_ACL_SRCFILTER:
 								printk(" [%d] rule type: %s   rule action: %s\n", rule->aclIdx, "Source Filter", actionT[rule->actionType_]);
-								printk("\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n", 
-										rule->srcFilterMac_.octet[0], rule->srcFilterMac_.octet[1], rule->srcFilterMac_.octet[2], 
+								printk("\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n",
+										rule->srcFilterMac_.octet[0], rule->srcFilterMac_.octet[1], rule->srcFilterMac_.octet[2],
 										rule->srcFilterMac_.octet[3], rule->srcFilterMac_.octet[4], rule->srcFilterMac_.octet[5],
 										rule->srcFilterMacMask_.octet[0], rule->srcFilterMacMask_.octet[1], rule->srcFilterMacMask_.octet[2],
 										rule->srcFilterMacMask_.octet[3], rule->srcFilterMacMask_.octet[4], rule->srcFilterMacMask_.octet[5]
@@ -323,8 +323,8 @@ int32 rtl865x_show_allAclChains(void)
 
 							case RTL865X_ACL_SRCFILTER_IPRANGE:
 								printk(" [%d] rule type: %s   rule action: %s\n", rule->aclIdx, "Source Filter(IP RANGE)", actionT[rule->actionType_]);
-								printk("\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n", 
-										rule->srcFilterMac_.octet[0], rule->srcFilterMac_.octet[1], rule->srcFilterMac_.octet[2], 
+								printk("\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n",
+										rule->srcFilterMac_.octet[0], rule->srcFilterMac_.octet[1], rule->srcFilterMac_.octet[2],
 										rule->srcFilterMac_.octet[3], rule->srcFilterMac_.octet[4], rule->srcFilterMac_.octet[5],
 										rule->srcFilterMacMask_.octet[0], rule->srcFilterMacMask_.octet[1], rule->srcFilterMacMask_.octet[2],
 										rule->srcFilterMacMask_.octet[3], rule->srcFilterMacMask_.octet[4], rule->srcFilterMacMask_.octet[5]
@@ -344,15 +344,15 @@ int32 rtl865x_show_allAclChains(void)
 
 							case RTL865X_ACL_DSTFILTER:
 								printk(" [%d] rule type: %s   rule action: %s\n", rule->aclIdx, "Deatination Filter", actionT[rule->actionType_]);
-								printk("\tDMAC: %x:%x:%x:%x:%x:%x  DMACM: %x:%x:%x:%x:%x:%x\n", 
-										rule->dstFilterMac_.octet[0], rule->dstFilterMac_.octet[1], rule->dstFilterMac_.octet[2], 
+								printk("\tDMAC: %x:%x:%x:%x:%x:%x  DMACM: %x:%x:%x:%x:%x:%x\n",
+										rule->dstFilterMac_.octet[0], rule->dstFilterMac_.octet[1], rule->dstFilterMac_.octet[2],
 										rule->dstFilterMac_.octet[3], rule->dstFilterMac_.octet[4], rule->dstFilterMac_.octet[5],
 										rule->dstFilterMacMask_.octet[0], rule->dstFilterMacMask_.octet[1], rule->dstFilterMacMask_.octet[2],
 										rule->dstFilterMacMask_.octet[3], rule->dstFilterMacMask_.octet[4], rule->dstFilterMacMask_.octet[5]
 										);
 								printk("\tdvidx: %d   dvidxM: %x  ProtoType: %x   dportL: %d   dportU: %d\n",
-										rule->dstFilterVlanIdx_, rule->dstFilterVlanIdxMask_, 
-										(rule->dstFilterIgnoreL3L4_==TRUE? 2: (rule->dstFilterIgnoreL4_ == 1? 1: 0)), 
+										rule->dstFilterVlanIdx_, rule->dstFilterVlanIdxMask_,
+										(rule->dstFilterIgnoreL3L4_==TRUE? 2: (rule->dstFilterIgnoreL4_ == 1? 1: 0)),
 										rule->dstFilterPortLowerBound_, rule->dstFilterPortUpperBound_
 										);
 								printk("\tdip: %d.%d.%d.%d   dipM: %d.%d.%d.%d\n", (rule->dstFilterIpAddr_>>24),
@@ -364,15 +364,15 @@ int32 rtl865x_show_allAclChains(void)
 								break;
 							case RTL865X_ACL_DSTFILTER_IPRANGE:
 								printk(" [%d] rule type: %s   rule action: %s\n", rule->aclIdx, "Deatination Filter(IP Range)", actionT[rule->actionType_]);
-								printk("\tDMAC: %x:%x:%x:%x:%x:%x  DMACM: %x:%x:%x:%x:%x:%x\n", 
-										rule->dstFilterMac_.octet[0], rule->dstFilterMac_.octet[1], rule->dstFilterMac_.octet[2], 
+								printk("\tDMAC: %x:%x:%x:%x:%x:%x  DMACM: %x:%x:%x:%x:%x:%x\n",
+										rule->dstFilterMac_.octet[0], rule->dstFilterMac_.octet[1], rule->dstFilterMac_.octet[2],
 										rule->dstFilterMac_.octet[3], rule->dstFilterMac_.octet[4], rule->dstFilterMac_.octet[5],
 										rule->dstFilterMacMask_.octet[0], rule->dstFilterMacMask_.octet[1], rule->dstFilterMacMask_.octet[2],
 										rule->dstFilterMacMask_.octet[3], rule->dstFilterMacMask_.octet[4], rule->dstFilterMacMask_.octet[5]
 										);
 								printk("\tdvidx: %d   dvidxM: %x  ProtoType: %x   dportL: %d   dportU: %d\n",
-										rule->dstFilterVlanIdx_, rule->dstFilterVlanIdxMask_, 
-										(rule->dstFilterIgnoreL3L4_==TRUE? 2: (rule->dstFilterIgnoreL4_ == 1? 1: 0)), 
+										rule->dstFilterVlanIdx_, rule->dstFilterVlanIdxMask_,
+										(rule->dstFilterIgnoreL3L4_==TRUE? 2: (rule->dstFilterIgnoreL4_ == 1? 1: 0)),
 										rule->dstFilterPortLowerBound_, rule->dstFilterPortUpperBound_
 										);
 								printk("\tdipU: %d.%d.%d.%d   dipL: %d.%d.%d.%d\n", (rule->dstFilterIpAddr_>>24),
@@ -386,9 +386,9 @@ int32 rtl865x_show_allAclChains(void)
 								default:
 									printk("rule->ruleType_(0x%x)\n", rule->ruleType_);
 
-						}	
+						}
 
-						switch (rule->actionType_) 
+						switch (rule->actionType_)
 						{
 							case RTL865X_ACL_PERMIT:
 							case RTL865X_ACL_REDIRECT_ETHER:
@@ -402,10 +402,10 @@ int32 rtl865x_show_allAclChains(void)
 								printk("\tnetifIdx: %d   pppoeIdx: %d   l2Idx:%d  ", rule->netifIdx_, rule->pppoeIdx_, rule->L2Idx_);
 								break;
 
-							case RTL865X_ACL_PRIORITY: 
+							case RTL865X_ACL_PRIORITY:
 								printk("\tprioirty: %d   ",  rule->priority_) ;
 								break;
-								
+
 							case RTL865X_ACL_DEFAULT_REDIRECT:
 								printk("\tnextHop:%d  ",  rule->nexthopIdx_);
 								break;
@@ -416,12 +416,12 @@ int32 rtl865x_show_allAclChains(void)
 							case RTL865X_ACL_LOG_RATE_EXCEED_BPS:
 								printk("\tratelimitIdx: %d  ",  rule->ratelimtIdx_);
 								break;
-							default: 
+							default:
 								;
-							
+
 							}
 						printk("pktOpApp: %d\n",  rule->pktOpApp_);
-						
+
 						rule = rule->next;
 					}
 					printk("===========================\n");
@@ -429,10 +429,10 @@ int32 rtl865x_show_allAclChains(void)
 				}
 				printk("--------------------------------\n\n");
 			}
-			
+
 		}
 	}
-	
+
 #if defined (CONFIG_RTL_LOCAL_PUBLIC)
 	{
 		if(virtualNetIf.valid == 1)
@@ -443,7 +443,7 @@ int32 rtl865x_show_allAclChains(void)
 				printk("netif(%s),isEgress(%d):\n",netif->name,j);
 				chain = netif->chainListHead[j];
 				while(chain)
-				{					
+				{
 					printk("\tchain:priority(%d),rulecnt(%d)\n",chain->priority,chain->ruleCnt);
 					printk("===========================\n");
 					rule = chain->head;
@@ -460,7 +460,7 @@ int32 rtl865x_show_allAclChains(void)
 										rule->dstMacMask_.octet[0], rule->dstMacMask_.octet[1], rule->dstMacMask_.octet[2],
 										rule->dstMacMask_.octet[3], rule->dstMacMask_.octet[4], rule->dstMacMask_.octet[5]
 										);
-								
+
 								printk( "\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n",
 										rule->srcMac_.octet[0], rule->srcMac_.octet[1], rule->srcMac_.octet[2],
 										rule->srcMac_.octet[3], rule->srcMac_.octet[4], rule->srcMac_.octet[5],
@@ -484,14 +484,14 @@ int32 rtl865x_show_allAclChains(void)
 								printk("\tTos: %x   TosM: %x   ipProto: %x   ipProtoM: %x   ipFlag: %x   ipFlagM: %x\n",
 										rule->tos_, rule->tosMask_, rule->ipProto_, rule->ipProtoMask_, rule->ipFlag_, rule->ipFlagMask_
 									);
-								
+
 								printk("\t<FOP:%x> <FOM:%x> <http:%x> <httpM:%x> <IdentSdip:%x> <IdentSdipM:%x> \n",
 										rule->ipFOP_, rule->ipFOM_, rule->ipHttpFilter_, rule->ipHttpFilterM_, rule->ipIdentSrcDstIp_,
 										rule->ipIdentSrcDstIpM_
 										);
-								printk( "\t<DF:%x> <MF:%x>\n", rule->ipDF_, rule->ipMF_); 
+								printk( "\t<DF:%x> <MF:%x>\n", rule->ipDF_, rule->ipMF_);
 									break;
-									
+
 							case RTL865X_ACL_IP_RANGE:
 								printk(" [%d] rule type: %s   rule action: %s\n", rule->aclIdx, "IP Range", actionT[rule->actionType_]);
 								printk("\tdipU: %d.%d.%d.%d dipL: %d.%d.%d.%d\n", (rule->dstIpAddr_>>24),
@@ -511,8 +511,8 @@ int32 rtl865x_show_allAclChains(void)
 										rule->ipFOP_, rule->ipFOM_, rule->ipHttpFilter_, rule->ipHttpFilterM_, rule->ipIdentSrcDstIp_,
 										rule->ipIdentSrcDstIpM_
 										);
-									printk("\t<DF:%x> <MF:%x>\n", rule->ipDF_, rule->ipMF_); 
-									break;			
+									printk("\t<DF:%x> <MF:%x>\n", rule->ipDF_, rule->ipMF_);
+									break;
 							case RTL865X_ACL_ICMP:
 								printk(" [%d] rule type: %s   rule action: %s\n", rule->aclIdx, "ICMP", actionT[rule->actionType_]);
 								printk("\tdip: %d.%d.%d.%d dipM: %d.%d.%d.%d\n", (rule->dstIpAddr_>>24),
@@ -526,7 +526,7 @@ int32 rtl865x_show_allAclChains(void)
 										((rule->srcIpAddrMask_&0x0000ff00)>>8), (rule->srcIpAddrMask_&0xff)
 										);
 								printk("\tTos: %x   TosM: %x   type: %x   typeM: %x   code: %x   codeM: %x\n",
-										rule->tos_, rule->tosMask_, rule->icmpType_, rule->icmpTypeMask_, 
+										rule->tos_, rule->tosMask_, rule->icmpType_, rule->icmpTypeMask_,
 										rule->icmpCode_, rule->icmpCodeMask_);
 								break;
 							case RTL865X_ACL_ICMP_IPRANGE:
@@ -542,7 +542,7 @@ int32 rtl865x_show_allAclChains(void)
 										((rule->srcIpAddrMask_&0x0000ff00)>>8), (rule->srcIpAddrMask_&0xff)
 										);
 								printk("\tTos: %x   TosM: %x   type: %x   typeM: %x   code: %x   codeM: %x\n",
-										rule->tos_, rule->tosMask_, rule->icmpType_, rule->icmpTypeMask_, 
+										rule->tos_, rule->tosMask_, rule->icmpType_, rule->icmpTypeMask_,
 										rule->icmpCode_, rule->icmpCodeMask_);
 								break;
 							case RTL865X_ACL_IGMP:
@@ -639,7 +639,7 @@ int32 rtl865x_show_allAclChains(void)
 										rule->tos_, rule->tosMask_, rule->udpSrcPortLB_, rule->udpSrcPortUB_,
 										rule->udpDstPortLB_, rule->udpDstPortUB_
 										);
-								break;				
+								break;
 							case RTL865X_ACL_UDP_IPRANGE:
 								printk(" [%d] rule type: %s   rule action: %s\n", rule->aclIdx, "UDP IP RANGE", actionT[rule->actionType_]);
 								printk("\tdipU: %d.%d.%d.%d dipL: %d.%d.%d.%d\n", (rule->dstIpAddr_>>24),
@@ -656,13 +656,13 @@ int32 rtl865x_show_allAclChains(void)
 										rule->tos_, rule->tosMask_, rule->udpSrcPortLB_, rule->udpSrcPortUB_,
 										rule->udpDstPortLB_, rule->udpDstPortUB_
 									);
-								break;				
+								break;
+
 
-							
 							case RTL865X_ACL_SRCFILTER:
 								printk(" [%d] rule type: %s   rule action: %s\n", rule->aclIdx, "Source Filter", actionT[rule->actionType_]);
-								printk("\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n", 
-										rule->srcFilterMac_.octet[0], rule->srcFilterMac_.octet[1], rule->srcFilterMac_.octet[2], 
+								printk("\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n",
+										rule->srcFilterMac_.octet[0], rule->srcFilterMac_.octet[1], rule->srcFilterMac_.octet[2],
 										rule->srcFilterMac_.octet[3], rule->srcFilterMac_.octet[4], rule->srcFilterMac_.octet[5],
 										rule->srcFilterMacMask_.octet[0], rule->srcFilterMacMask_.octet[1], rule->srcFilterMacMask_.octet[2],
 										rule->srcFilterMacMask_.octet[3], rule->srcFilterMacMask_.octet[4], rule->srcFilterMacMask_.octet[5]
@@ -682,8 +682,8 @@ int32 rtl865x_show_allAclChains(void)
 
 							case RTL865X_ACL_SRCFILTER_IPRANGE:
 								printk(" [%d] rule type: %s   rule action: %s\n", rule->aclIdx, "Source Filter(IP RANGE)", actionT[rule->actionType_]);
-								printk("\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n", 
-										rule->srcFilterMac_.octet[0], rule->srcFilterMac_.octet[1], rule->srcFilterMac_.octet[2], 
+								printk("\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n",
+										rule->srcFilterMac_.octet[0], rule->srcFilterMac_.octet[1], rule->srcFilterMac_.octet[2],
 										rule->srcFilterMac_.octet[3], rule->srcFilterMac_.octet[4], rule->srcFilterMac_.octet[5],
 										rule->srcFilterMacMask_.octet[0], rule->srcFilterMacMask_.octet[1], rule->srcFilterMacMask_.octet[2],
 										rule->srcFilterMacMask_.octet[3], rule->srcFilterMacMask_.octet[4], rule->srcFilterMacMask_.octet[5]
@@ -703,15 +703,15 @@ int32 rtl865x_show_allAclChains(void)
 
 							case RTL865X_ACL_DSTFILTER:
 								printk(" [%d] rule type: %s   rule action: %s\n", rule->aclIdx, "Deatination Filter", actionT[rule->actionType_]);
-								printk("\tDMAC: %x:%x:%x:%x:%x:%x  DMACM: %x:%x:%x:%x:%x:%x\n", 
-										rule->dstFilterMac_.octet[0], rule->dstFilterMac_.octet[1], rule->dstFilterMac_.octet[2], 
+								printk("\tDMAC: %x:%x:%x:%x:%x:%x  DMACM: %x:%x:%x:%x:%x:%x\n",
+										rule->dstFilterMac_.octet[0], rule->dstFilterMac_.octet[1], rule->dstFilterMac_.octet[2],
 										rule->dstFilterMac_.octet[3], rule->dstFilterMac_.octet[4], rule->dstFilterMac_.octet[5],
 										rule->dstFilterMacMask_.octet[0], rule->dstFilterMacMask_.octet[1], rule->dstFilterMacMask_.octet[2],
 										rule->dstFilterMacMask_.octet[3], rule->dstFilterMacMask_.octet[4], rule->dstFilterMacMask_.octet[5]
 										);
 								printk("\tdvidx: %d   dvidxM: %x  ProtoType: %x   dportL: %d   dportU: %d\n",
-										rule->dstFilterVlanIdx_, rule->dstFilterVlanIdxMask_, 
-										(rule->dstFilterIgnoreL3L4_==TRUE? 2: (rule->dstFilterIgnoreL4_ == 1? 1: 0)), 
+										rule->dstFilterVlanIdx_, rule->dstFilterVlanIdxMask_,
+										(rule->dstFilterIgnoreL3L4_==TRUE? 2: (rule->dstFilterIgnoreL4_ == 1? 1: 0)),
 										rule->dstFilterPortLowerBound_, rule->dstFilterPortUpperBound_
 										);
 								printk("\tdip: %d.%d.%d.%d   dipM: %d.%d.%d.%d\n", (rule->dstFilterIpAddr_>>24),
@@ -723,15 +723,15 @@ int32 rtl865x_show_allAclChains(void)
 								break;
 							case RTL865X_ACL_DSTFILTER_IPRANGE:
 								printk(" [%d] rule type: %s   rule action: %s\n", rule->aclIdx, "Deatination Filter(IP Range)", actionT[rule->actionType_]);
-								printk("\tDMAC: %x:%x:%x:%x:%x:%x  DMACM: %x:%x:%x:%x:%x:%x\n", 
-										rule->dstFilterMac_.octet[0], rule->dstFilterMac_.octet[1], rule->dstFilterMac_.octet[2], 
+								printk("\tDMAC: %x:%x:%x:%x:%x:%x  DMACM: %x:%x:%x:%x:%x:%x\n",
+										rule->dstFilterMac_.octet[0], rule->dstFilterMac_.octet[1], rule->dstFilterMac_.octet[2],
 										rule->dstFilterMac_.octet[3], rule->dstFilterMac_.octet[4], rule->dstFilterMac_.octet[5],
 										rule->dstFilterMacMask_.octet[0], rule->dstFilterMacMask_.octet[1], rule->dstFilterMacMask_.octet[2],
 										rule->dstFilterMacMask_.octet[3], rule->dstFilterMacMask_.octet[4], rule->dstFilterMacMask_.octet[5]
 										);
 								printk("\tdvidx: %d   dvidxM: %x  ProtoType: %x   dportL: %d   dportU: %d\n",
-										rule->dstFilterVlanIdx_, rule->dstFilterVlanIdxMask_, 
-										(rule->dstFilterIgnoreL3L4_==TRUE? 2: (rule->dstFilterIgnoreL4_ == 1? 1: 0)), 
+										rule->dstFilterVlanIdx_, rule->dstFilterVlanIdxMask_,
+										(rule->dstFilterIgnoreL3L4_==TRUE? 2: (rule->dstFilterIgnoreL4_ == 1? 1: 0)),
 										rule->dstFilterPortLowerBound_, rule->dstFilterPortUpperBound_
 										);
 								printk("\tdipU: %d.%d.%d.%d   dipL: %d.%d.%d.%d\n", (rule->dstFilterIpAddr_>>24),
@@ -745,9 +745,9 @@ int32 rtl865x_show_allAclChains(void)
 								default:
 									printk("rule->ruleType_(0x%x)\n", rule->ruleType_);
 
-						}	
+						}
 
-						switch (rule->actionType_) 
+						switch (rule->actionType_)
 						{
 							case RTL865X_ACL_PERMIT:
 							case RTL865X_ACL_REDIRECT_ETHER:
@@ -761,10 +761,10 @@ int32 rtl865x_show_allAclChains(void)
 								printk("\tnetifIdx: %d   pppoeIdx: %d   l2Idx:%d  ", rule->netifIdx_, rule->pppoeIdx_, rule->L2Idx_);
 								break;
 
-							case RTL865X_ACL_PRIORITY: 
+							case RTL865X_ACL_PRIORITY:
 								printk("\tprioirty: %d   ",  rule->priority_) ;
 								break;
-								
+
 							case RTL865X_ACL_DEFAULT_REDIRECT:
 								printk("\tnextHop:%d  ",  rule->nexthopIdx_);
 								break;
@@ -775,12 +775,12 @@ int32 rtl865x_show_allAclChains(void)
 							case RTL865X_ACL_LOG_RATE_EXCEED_BPS:
 								printk("\tratelimitIdx: %d  ",  rule->ratelimtIdx_);
 								break;
-							default: 
+							default:
 								;
-							
+
 							}
 						printk("pktOpApp: %d\n",  rule->pktOpApp_);
-						
+
 						rule = rule->next;
 					}
 					printk("===========================\n");
@@ -788,12 +788,12 @@ int32 rtl865x_show_allAclChains(void)
 				}
 				printk("--------------------------------\n\n");
 			}
-			
+
 		}
 	}
 #endif
 	return SUCCESS;
-	
+
 }
 
 
@@ -804,7 +804,7 @@ static int32 _rtl865x_print_allChain_allAcl(rtl865x_netif_local_t *netif)
 	rtl865x_acl_chain_t *chain;
 	rtl865x_AclRule_t *rule;
 	int32 i;
-	
+
 	for(i = RTL865X_ACL_INGRESS; i<= RTL865X_ACL_EGRESS;i++)
 	{
 		printk("netif(%s),isEgress(%d):\n",netif->name,i);
@@ -825,7 +825,7 @@ static int32 _rtl865x_print_allChain_allAcl(rtl865x_netif_local_t *netif)
 		printk("--------------------------------\n\n");
 	}
 	return SUCCESS;
-	
+
 }
 
 
@@ -884,7 +884,7 @@ static int32 _rtl865x_setAsicNetif(rtl865x_netif_local_t *entry)
 	asicEntry.valid = entry->valid;
 
 
-	
+
 	retval = rtl8651_setAsicNetInterface( entry->asicIdx, &asicEntry);
 	return retval;
 
@@ -894,7 +894,7 @@ rtl865x_netif_local_t *_rtl865x_getSWNetifByName(char *name)
 {
 	int32 i;
 	rtl865x_netif_local_t *netif = NULL;
-	
+
 	if(name == NULL)
 		return NULL;
 
@@ -903,16 +903,16 @@ rtl865x_netif_local_t *_rtl865x_getSWNetifByName(char *name)
 		//printk("%s:%d,i(%d),valid(%d),ifname(%s),strlen of name(%d), netifTbl(0x%p),netifTblName(%s)\n",__FUNCTION__,__LINE__,i,netifTbl[i].valid,name,strlen(name),&netifTbl[i],netifTbl[i].name);
 		if(netifTbl[i].valid == 1 && strlen(name) == strlen(netifTbl[i].name) && memcmp(netifTbl[i].name,name,strlen(name)) == 0)
 		{
-			netif = &netifTbl[i];			
+			netif = &netifTbl[i];
 			break;
 		}
 	}
-	
+
 	#if defined (CONFIG_RTL_LOCAL_PUBLIC)
 	if(virtualNetIf.valid == 1 && strlen(name) == strlen(virtualNetIf.name) && memcmp(virtualNetIf.name,name,strlen(name)) == 0)
 	{
 		netif = &virtualNetIf;
-		
+
 	}
 	#endif
 
@@ -923,7 +923,7 @@ rtl865x_netif_local_t *_rtl865x_getNetifByName(char *name)
 {
 	int32 i;
 	rtl865x_netif_local_t *netif = NULL;
-	
+
 	if(name == NULL)
 		return NULL;
 
@@ -945,7 +945,7 @@ rtl865x_netif_local_t *_rtl865x_getNetifByName(char *name)
 	if(virtualNetIf.valid == 1 && strlen(name) == strlen(virtualNetIf.name) && memcmp(virtualNetIf.name,name,strlen(name)) == 0)
 	{
 		netif = &virtualNetIf;
-	
+
 	}
 	#endif
 	return netif;
@@ -956,13 +956,13 @@ rtl865x_netif_local_t *_rtl865x_getDefaultWanNetif(void)
 	int32 i;
 	rtl865x_netif_local_t *firstWan, *defNetif;
 	firstWan = defNetif = NULL;
-	
+
 	for(i = 0; i < NETIF_NUMBER; i++)
 	{
 		//printk("i(%d),netifTbl(0x%p)\n",i,&netifTbl[i]);
 		if(netifTbl[i].valid == 1 && netifTbl[i].is_wan == 1 && firstWan == NULL)
 			firstWan = &netifTbl[i];
-			
+
 		if(netifTbl[i].valid == 1 && netifTbl[i].is_defaultWan == 1)
 		{
 			defNetif = &netifTbl[i];
@@ -975,9 +975,9 @@ rtl865x_netif_local_t *_rtl865x_getDefaultWanNetif(void)
 	{
 		defNetif = firstWan;
 	}
-	
+
 	return defNetif;
-	
+
 }
 
 int32 _rtl865x_setDefaultWanNetif(char *name)
@@ -988,7 +988,7 @@ int32 _rtl865x_setDefaultWanNetif(char *name)
 	//printk("set default wan interface....(%s)\n",name);
 	if(entry)
 		entry->is_defaultWan = 1;
-	
+
 	return SUCCESS;
 }
 
@@ -1000,7 +1000,7 @@ int32 _rtl865x_clearDefaultWanNetif(char *name)
 	//printk("set default wan interface....(%s)\n",name);
 	if(entry)
 		entry->is_defaultWan = 0;
-	
+
 	return SUCCESS;
 }
 
@@ -1021,7 +1021,7 @@ static int32 _rtl865x_attachMasterNetif(char *slave, char *master)
 	slave_netif ->master = master_netif;
 
 	return SUCCESS;
-	
+
 }
 
 static int32 _rtl865x_detachMasterNetif(char *slave)
@@ -1029,7 +1029,7 @@ static int32 _rtl865x_detachMasterNetif(char *slave)
 	rtl865x_netif_local_t *slave_netif;
 
 	slave_netif = _rtl865x_getSWNetifByName(slave);
-	
+
 	if(slave_netif == NULL)
 		return RTL_EENTRYNOTFOUND;
 
@@ -1043,10 +1043,12 @@ int32 _rtl865x_addNetif(rtl865x_netif_t *netif)
 	rtl865x_netif_local_t *entry;
 	int32 retval = FAILED;
 	int32 i;
-#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+#if defined (CONFIG_RTL_LOCAL_PUBLIC) || defined(CONFIG_RTL_MULTIPLE_WAN)
 	int asicIdx;
+#if defined(CONFIG_RTL_LOCAL_PUBLIC)
 	rtl865xc_tblAsic_netifTable_t asicEntry;
 #endif
+#endif
 	if(netif == NULL)
 		return RTL_EINVALIDINPUT;
 
@@ -1062,21 +1064,30 @@ int32 _rtl865x_addNetif(rtl865x_netif_t *netif)
 			break;
 	}
 
-#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+#if defined (CONFIG_RTL_LOCAL_PUBLIC) || defined(CONFIG_RTL_MULTIPLE_WAN)
+#if defined(CONFIG_RTL_LOCAL_PUBLIC)
 	for (asicIdx=0;asicIdx<RTL865XC_NETIFTBL_SIZE;asicIdx++)
-	{	
+	{
 		_rtl8651_readAsicEntry(TYPE_NETINTERFACE_TABLE, asicIdx, &asicEntry);
 		if (asicEntry.valid==0)
 		{
 			break;
 		}
-	}	
+	}
+#endif
+
 	if(netif->forMacBasedMCast==TRUE)
 	{
 		asicIdx=RTL865XC_NETIFTBL_SIZE-1;
 	}
+#if defined(CONFIG_RTL_MULTIPLE_WAN)
+	else
+	{
+		asicIdx = i;
+	}
 #endif
-	
+#endif
+
 	if(i == NETIF_NUMBER)
 		return RTL_ENOFREEBUFFER;
 
@@ -1086,7 +1097,7 @@ int32 _rtl865x_addNetif(rtl865x_netif_t *netif)
 	#if defined (CONFIG_RTL_LOCAL_PUBLIC)
 	memset(entry, 0, sizeof(rtl865x_netif_local_t));
 	#endif
-	
+
 	entry->valid = 1;
 	entry->mtu = netif->mtu;
 	entry->if_type = netif->if_type;
@@ -1098,21 +1109,21 @@ int32 _rtl865x_addNetif(rtl865x_netif_t *netif)
 	memcpy(entry->name,netif->name,MAX_IFNAMESIZE);
 
 	/*private number...*/
-#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+#if defined (CONFIG_RTL_LOCAL_PUBLIC) ||defined(CONFIG_RTL_MULTIPLE_WAN)
 	entry->asicIdx=asicIdx;
 #else
 	entry->asicIdx = i;
 #endif
-	entry->enableRoute = netif->enableRoute; 
+	entry->enableRoute = netif->enableRoute;
 	entry->macAddrNumber = 1;
 	entry->inAclEnd = entry->inAclStart = entry->outAclEnd = entry->outAclStart = RTL865X_ACLTBL_PERMIT_ALL; /*default permit...*/
 	entry->refCnt = 1;
 	entry->master = NULL;
-	
+
 #ifdef 	CONFIG_RTL_LAYERED_DRIVER_ACL
 	//ingress acl chains head
 	entry->chainListHead[RTL865X_ACL_INGRESS] = NULL;
-	
+
 	//init egress acl
 	entry->chainListHead[RTL865X_ACL_EGRESS] = NULL;
 #endif
@@ -1123,20 +1134,20 @@ int32 _rtl865x_addNetif(rtl865x_netif_t *netif)
 		retval = _rtl865x_setAsicNetif(entry);
 		if(retval == SUCCESS)
 			rtl865x_referVlan(entry->vid);
-		
+
 #ifdef CONFIG_RTL_LAYERED_DRIVER_ACL
 		/*register 2 ingress chains: system/user*/
 		retval = rtl865x_regist_aclChain(netif->name, RTL865X_ACL_SYSTEM_USED, RTL865X_ACL_INGRESS);
 #if RTL_LAYERED_DRIVER_DEBUG
 		printk("register system acl chain, return %d\n",retval);
-		_rtl865x_print_freeChainNum();	
+		_rtl865x_print_freeChainNum();
 #endif
 		retval = rtl865x_regist_aclChain(netif->name, RTL865X_ACL_USER_USED, RTL865X_ACL_INGRESS);
 		retval = rtl865x_regist_aclChain(netif->name, RTL865X_ACL_USER_USED, RTL865X_ACL_EGRESS);
 
 #if RTL_LAYERED_DRIVER_DEBUG
 		printk("register user acl chain, return %d\n",retval);
-		_rtl865x_print_freeChainNum();	
+		_rtl865x_print_freeChainNum();
 #endif
 
 #if defined(CONFIG_RTL_HW_QOS_SUPPORT)
@@ -1146,7 +1157,7 @@ int32 _rtl865x_addNetif(rtl865x_netif_t *netif)
 #endif //CONFIG_RTL_LAYERED_DRIVER_ACL
 	}
 
-	
+
 	return SUCCESS;
 }
 
@@ -1171,19 +1182,19 @@ static int32 _rtl865x_delNetif(char *name)
 #ifdef CONFIG_RTL_LAYERED_DRIVER_ACL
 		retval = _rtl865x_unRegister_all_aclChain(name);
 #endif
-		
+
 		retval = rtl865x_delNetInterfaceByVid(entry->vid);
 		if(retval == SUCCESS)
 		{
 			rtl865x_deReferVlan(entry->vid);
-			
+
 			/*flush acl*/
 			#if 0
 			do_eventAction(EV_DEL_NETIF, (void*)entry);
 			#else
 			rtl865x_raiseEvent(EVENT_DEL_NETIF, (void*)entry);
 			#endif
-		}		
+		}
 
 		/*now delete all slave interface whose master is the deleting master interface*/
 		{
@@ -1195,14 +1206,14 @@ static int32 _rtl865x_delNetif(char *name)
 					netifTbl[i].master = NULL;
 			}
 		}
-#ifdef CONFIG_RTL_LAYERED_DRIVER_ACL		
+#ifdef CONFIG_RTL_LAYERED_DRIVER_ACL
 #if RTL_LAYERED_DRIVER_DEBUG
 		printk("unregist all acl chain, return %d\n",retval);
-		_rtl865x_print_freeChainNum();	
+		_rtl865x_print_freeChainNum();
 #endif
 #endif
 	}
-	
+
 	//entry->valid = 0;
 	memset(entry,0,sizeof(rtl865x_netif_local_t));
 	retval = SUCCESS;
@@ -1235,7 +1246,7 @@ static int32 _rtl865x_deReferNetif(char *ifName)
 		return RTL_EENTRYNOTFOUND;
 
 	entry->refCnt--;
-	
+
 	return SUCCESS;
 }
 
@@ -1253,9 +1264,9 @@ static int32 _rtl865x_setNetifVid(char *name, uint16 vid)
 
 	if(entry->vid > 0 && entry->vid <= 4095)
 		rtl865x_deReferVlan(entry->vid);
-	
+
 	entry->vid = vid;
-	
+
 	/*update asic table*/
 	if (entry->is_slave)
 		return SUCCESS;
@@ -1275,7 +1286,7 @@ static int32 _rtl865x_setNetifType(char *name, uint32 ifType)
 
 	if(entry == NULL)
 		return RTL_EENTRYNOTFOUND;
-	
+
 	entry->if_type = ifType;
 
 	return SUCCESS;
@@ -1289,7 +1300,7 @@ int32 _rtl865x_setNetifMac(rtl865x_netif_t *netif)
 	if(netif == NULL)
 		return RTL_EINVALIDINPUT;
 	entry = _rtl865x_getNetifByName(netif->name);
-	
+
 	if(entry == NULL)
 		return RTL_EENTRYNOTFOUND;
 
@@ -1297,9 +1308,9 @@ int32 _rtl865x_setNetifMac(rtl865x_netif_t *netif)
 
 	/*update asic table*/
 	retval = _rtl865x_setAsicNetif(entry);
-	
+
 	return retval;
-	
+
 }
 
 int32 _rtl865x_setNetifMtu(rtl865x_netif_t *netif)
@@ -1315,9 +1326,9 @@ int32 _rtl865x_setNetifMtu(rtl865x_netif_t *netif)
 
 	/*update asic table*/
 	retval = _rtl865x_setAsicNetif(entry);
-	
+
 	return retval;
-	
+
 }
 
 int32 _rtl865x_getNetifIdxByVid(uint16 vid)
@@ -1331,7 +1342,7 @@ int32 _rtl865x_getNetifIdxByVid(uint16 vid)
 
 	if(i == NETIF_NUMBER)
 		return -1;
-	
+
 	return i;
 }
 
@@ -1346,7 +1357,7 @@ int32 _rtl865x_getNetifIdxByName(uint8 *name)
 
 	if(i == NETIF_NUMBER)
 		return -1;
-	
+
 	return i;
 }
 
@@ -1361,7 +1372,7 @@ int32 _rtl865x_getNetifIdxByNameExt(uint8 *name)
 			{
 				if(netifTbl[i].master)
 					return _rtl865x_getNetifIdxByNameExt(netifTbl[i].master->name);
-				else 
+				else
 					return -1;
 			}
 			else
@@ -1428,7 +1439,7 @@ int32 _rtl865x_getAclFromAsic(int32 index, rtl865x_AclRule_t *rule)
 		 rule->ipIdentSrcDstIp_ = entry.is.L3L4.is.IP.identSDIPM;
 		 rule->ruleType_= entry.ruleType;
 		 goto l3l4_shared;
-	   
+
 	case RTL865X_ACL_ICMP: /* ICMP  (ip is mask) rule type */
 	case RTL865X_ACL_ICMP_IPRANGE: /* ICMP (ip is  range) rule type */
 		 rule->tos_ = entry.is.L3L4.is.ICMP.IPTOSP;
@@ -1441,7 +1452,7 @@ int32 _rtl865x_getAclFromAsic(int32 index, rtl865x_AclRule_t *rule)
 		 goto l3l4_shared;
 
 	case RTL865X_ACL_IGMP: /* IGMP (ip is mask) rule type */
-	case RTL865X_ACL_IGMP_IPRANGE: /* IGMP (ip is range) rule type */	
+	case RTL865X_ACL_IGMP_IPRANGE: /* IGMP (ip is range) rule type */
 		 rule->tos_ = entry.is.L3L4.is.IGMP.IPTOSP;
 		 rule->tosMask_ = entry.is.L3L4.is.IGMP.IPTOSM;
 		 rule->igmpType_ = entry.is.L3L4.is.IGMP.IGMPTypeP;
@@ -1459,7 +1470,7 @@ int32 _rtl865x_getAclFromAsic(int32 index, rtl865x_AclRule_t *rule)
 		 rule->tcpSrcPortLB_ = entry.is.L3L4.is.TCP.TCPSPLB;
 		 rule->tcpDstPortUB_ = entry.is.L3L4.is.TCP.TCPDPUB;
 		 rule->tcpDstPortLB_ = entry.is.L3L4.is.TCP.TCPDPLB;
-	 	 rule->ruleType_ = entry.ruleType;		 
+	 	 rule->ruleType_ = entry.ruleType;
          goto l3l4_shared;
 
 	case RTL865X_ACL_UDP: /* UDP rule type */
@@ -1479,14 +1490,14 @@ l3l4_shared:
 		break;
 
  	case RTL865X_ACL_SRCFILTER: /* Source Filter */
-	case RTL865X_ACL_SRCFILTER_IPRANGE:	
+	case RTL865X_ACL_SRCFILTER_IPRANGE:
 	 	 rule->srcFilterMac_.octet[0]     = entry.is.SRC_FILTER.sMacP47_32 >> 8;
 		 rule->srcFilterMac_.octet[1]     = entry.is.SRC_FILTER.sMacP47_32 & 0xff;
 		 rule->srcFilterMac_.octet[2]     = entry.is.SRC_FILTER.sMacP31_16 >> 8;
 		 rule->srcFilterMac_.octet[3]     = entry.is.SRC_FILTER.sMacP31_16 & 0xff;
 		 rule->srcFilterMac_.octet[4]     = entry.is.SRC_FILTER.sMacP15_0 >> 8;
 		 rule->srcFilterMac_.octet[5]     = entry.is.SRC_FILTER.sMacP15_0 & 0xff;
-		 if ( entry.is.SRC_FILTER.sMacM3_0&0x8)		 
+		 if ( entry.is.SRC_FILTER.sMacM3_0&0x8)
 	 	{
 			 rule->srcFilterMacMask_.octet[0] = 0xff;
 			 rule->srcFilterMacMask_.octet[1] = 0xff;
@@ -1516,7 +1527,7 @@ l3l4_shared:
 		 rule->srcFilterPortLowerBound_ = entry.is.SRC_FILTER.SPORTLB;
 	 	 rule->ruleType_ = entry.ruleType;
 		 break;
-		 
+
 	case RTL865X_ACL_DSTFILTER: /* Destination Filter */
 	case RTL865X_ACL_DSTFILTER_IPRANGE: /* Destination Filter(IP range) */
 	 	 rule->dstFilterMac_.octet[0]     = entry.is.DST_FILTER.dMacP47_32 >> 8;
@@ -1525,7 +1536,7 @@ l3l4_shared:
 		 rule->dstFilterMac_.octet[3]     = entry.is.DST_FILTER.dMacP31_16 & 0xff;
 		 rule->dstFilterMac_.octet[4]     = entry.is.DST_FILTER.dMacP15_0 >> 8;
 		 rule->dstFilterMac_.octet[5]     = entry.is.DST_FILTER.dMacP15_0 & 0xff;
-		 if ( entry.is.DST_FILTER.dMacM3_0&0x8)		 
+		 if ( entry.is.DST_FILTER.dMacM3_0&0x8)
 	 	{
 			 rule->dstFilterMacMask_.octet[0] = 0xff;
 			 rule->dstFilterMacMask_.octet[1] = 0xff;
@@ -1544,7 +1555,7 @@ l3l4_shared:
   		 	 rule->dstFilterMacMask_.octet[5] = entry.is.DST_FILTER.dMacM3_0;
 	 	}
 
-		
+
 		 rule->dstFilterVlanIdx_ = entry.is.DST_FILTER.vidP;
 		 rule->dstFilterVlanIdxMask_ = entry.is.DST_FILTER.vidM;
 		 if(entry.is.DST_FILTER.protoType == 1) rule->dstFilterIgnoreL3L4_ = 1;
@@ -1554,7 +1565,7 @@ l3l4_shared:
 		 rule->dstFilterPortUpperBound_ = entry.is.DST_FILTER.DPORTUB;
 		 rule->dstFilterPortLowerBound_ = entry.is.DST_FILTER.DPORTLB;
  	 	 rule->ruleType_ = entry.ruleType;
-		 break;		
+		 break;
 	default: return FAILED; /* Unknown rule type */
 
 	}
@@ -1574,13 +1585,13 @@ l3l4_shared:
 	case RTL865X_ACL_MIRROR_KEEP_MATCH:
 		rule->L2Idx_ = entry.nextHop ;
 		rule->netifIdx_ =  entry.vid;
-		rule->pppoeIdx_ = entry.PPPoEIndex;		 
+		rule->pppoeIdx_ = entry.PPPoEIndex;
 		 break;
-		 
+
 	case RTL865X_ACL_DEFAULT_REDIRECT:
-		rule->nexthopIdx_ = entry.nextHop;		
+		rule->nexthopIdx_ = entry.nextHop;
 		break;
-	
+
 	case RTL865X_ACL_DROP_RATE_EXCEED_PPS:
 		rule->ratelimtIdx_ = entry.nextHop;
 		break;
@@ -1596,14 +1607,14 @@ l3l4_shared:
 	case RTL865X_ACL_PRIORITY:
 		rule->priority_ = entry.nextHop;
 		break;
-		
+
 	}
 
 	rule->actionType_ = entry.actionType;
 	rule->pktOpApp_ = entry.pktOpApp;
 
 	return SUCCESS;
-	
+
 }
 
 static int32 _rtl865x_setAclToAsic(int32 startIdx, rtl865x_AclRule_t *rule)
@@ -1648,9 +1659,9 @@ static int32 _rtl865x_setAclToAsic(int32 startIdx, rtl865x_AclRule_t *rule)
 		 entry.is.L3L4.is.IP.FOM = rule->ipFOM_;
 		 entry.is.L3L4.is.IP.HTTPP = entry.is.L3L4.is.IP.HTTPM = rule->ipHttpFilter_;
 		 entry.is.L3L4.is.IP.identSDIPP = entry.is.L3L4.is.IP.identSDIPM = rule->ipIdentSrcDstIp_;
-		 
+
 		 goto l3l4_shared;
-		 
+
 	case RTL865X_ACL_ICMP:
 	case RTL865X_ACL_ICMP_IPRANGE:
 		 entry.is.L3L4.is.ICMP.IPTOSP = rule->tos_;
@@ -1666,8 +1677,8 @@ static int32 _rtl865x_setAclToAsic(int32 startIdx, rtl865x_AclRule_t *rule)
 		 entry.is.L3L4.is.IGMP.IPTOSP = rule->tos_;
 		 entry.is.L3L4.is.IGMP.IPTOSM = rule->tosMask_;
 		 entry.is.L3L4.is.IGMP.IGMPTypeP = rule->igmpType_;
-		 entry.is.L3L4.is.IGMP.IGMPTypeM = rule->igmpTypeMask_; 
-  		
+		 entry.is.L3L4.is.IGMP.IGMPTypeM = rule->igmpTypeMask_;
+
  		 goto l3l4_shared;
 
 	case RTL865X_ACL_TCP:
@@ -1680,7 +1691,7 @@ static int32 _rtl865x_setAclToAsic(int32 startIdx, rtl865x_AclRule_t *rule)
 		 entry.is.L3L4.is.TCP.TCPSPLB = rule->tcpSrcPortLB_;
 		 entry.is.L3L4.is.TCP.TCPDPUB = rule->tcpDstPortUB_;
 		 entry.is.L3L4.is.TCP.TCPDPLB = rule->tcpDstPortLB_;
- 		 
+
          goto l3l4_shared;
 
 	case RTL865X_ACL_UDP:
@@ -1691,7 +1702,7 @@ static int32 _rtl865x_setAclToAsic(int32 startIdx, rtl865x_AclRule_t *rule)
 		 entry.is.L3L4.is.UDP.UDPSPLB = rule->udpSrcPortLB_;
 		 entry.is.L3L4.is.UDP.UDPDPUB = rule->udpDstPortUB_;
 		 entry.is.L3L4.is.UDP.UDPDPLB = rule->udpDstPortLB_;
-  		 
+
 l3l4_shared:
 		 entry.ruleType = rule->ruleType_;
 		 entry.is.L3L4.sIPP = rule->srcIpAddr_;
@@ -1708,14 +1719,14 @@ l3l4_shared:
  		 rule->srcFilterMac_.octet[3] = rule->srcFilterMac_.octet[3] & rule->srcFilterMacMask_.octet[3];
  		 rule->srcFilterMac_.octet[4] = rule->srcFilterMac_.octet[4] & rule->srcFilterMacMask_.octet[4];
  		 rule->srcFilterMac_.octet[5] = rule->srcFilterMac_.octet[5] & rule->srcFilterMacMask_.octet[5];
- 		 
+
 		 entry.is.SRC_FILTER.sMacP47_32 = rule->srcFilterMac_.octet[0]<<8 | rule->srcFilterMac_.octet[1];
 		 entry.is.SRC_FILTER.sMacP31_16 = rule->srcFilterMac_.octet[2]<<8 | rule->srcFilterMac_.octet[3];
 		 entry.is.SRC_FILTER.sMacP15_0 = rule->srcFilterMac_.octet[4]<<8 | rule->srcFilterMac_.octet[5];
 		 entry.is.SRC_FILTER.sMacM3_0 =rule->srcFilterMacMask_.octet[5] &0xf;
 
 		 rule->srcFilterVlanId_ = rule->srcFilterVlanId_ & rule->srcFilterVlanIdMask_;
-		 entry.is.SRC_FILTER.spaP = rule->srcFilterPort_;	
+		 entry.is.SRC_FILTER.spaP = rule->srcFilterPort_;
 		 entry.is.SRC_FILTER.sVidP = rule->srcFilterVlanId_;
 		 entry.is.SRC_FILTER.sVidM = rule->srcFilterVlanIdMask_;
 		 if(rule->srcFilterIgnoreL3L4_)
@@ -1724,7 +1735,7 @@ l3l4_shared:
 		 	entry.is.SRC_FILTER.protoType = 2;
 		 else
 		 	entry.is.SRC_FILTER.protoType = 0;
-		 
+
 		 entry.is.SRC_FILTER.sIPP = rule->srcFilterIpAddr_;
 		 entry.is.SRC_FILTER.sIPM = rule->srcFilterIpAddrMask_;
 		 entry.is.SRC_FILTER.SPORTUB = rule->srcFilterPortUpperBound_;
@@ -1732,7 +1743,7 @@ l3l4_shared:
 
 		 entry.ruleType = rule->ruleType_;
 		 break;
-		 
+
 	case RTL865X_ACL_DSTFILTER:
  	case RTL865X_ACL_DSTFILTER_IPRANGE:
 		 entry.is.DST_FILTER.dMacP47_32 = rule->dstFilterMac_.octet[0]<<8 | rule->dstFilterMac_.octet[1];
@@ -1751,14 +1762,14 @@ l3l4_shared:
 		 entry.is.DST_FILTER.dIPM = rule->dstFilterIpAddrMask_;
 		 entry.is.DST_FILTER.DPORTUB = rule->dstFilterPortUpperBound_;
 		 entry.is.DST_FILTER.DPORTLB = rule->dstFilterPortLowerBound_;
-		 
+
     		 entry.ruleType = rule->ruleType_;
 		 break;
- 
+
 	default: return FAILED; /* Unknown rule type */
-	
+
 	}
-	
+
 	switch(rule->actionType_)
 	{
 	case RTL865X_ACL_PERMIT:
@@ -1772,13 +1783,13 @@ l3l4_shared:
 	case RTL865X_ACL_MIRROR_KEEP_MATCH:
 		 entry.nextHop = rule->L2Idx_;
 		 entry.vid = rule->netifIdx_;
-		 entry.PPPoEIndex = rule->pppoeIdx_;		 
+		 entry.PPPoEIndex = rule->pppoeIdx_;
 		 break;
-		 
+
 	case RTL865X_ACL_DEFAULT_REDIRECT:
-		entry.nextHop = rule->nexthopIdx_;		
+		entry.nextHop = rule->nexthopIdx_;
 		break;
-	
+
 	case RTL865X_ACL_DROP_RATE_EXCEED_PPS:
 		entry.nextHop = rule->ratelimtIdx_;
 		break;
@@ -1794,13 +1805,13 @@ l3l4_shared:
 	case RTL865X_ACL_PRIORITY:
 		entry.nextHop = rule->priority_;
 		break;
-		
+
 	}
 
 	entry.actionType = rule->actionType_;
 	entry.pktOpApp = rule->pktOpApp_;
 
-	
+
 	return _rtl8651_forceAddAsicEntry(TYPE_ACL_RULE_TABLE, startIdx + rule->aclIdx -1, &entry);
 }
 
@@ -1832,9 +1843,9 @@ static int32 _rtl865x_confReservedAcl(void)
 	#ifdef CONFIG_RTL_LAYERED_ASIC_DRIVER
 	rtl865x_setDefACLForNetDecisionMiss(RTL865X_ACLTBL_PERMIT_ALL,RTL865X_ACLTBL_PERMIT_ALL,RTL865X_ACLTBL_PERMIT_ALL,RTL865X_ACLTBL_PERMIT_ALL);
 	#endif
-	
+
 	return SUCCESS;
-	
+
 }
 
 /*
@@ -1862,14 +1873,14 @@ static int32 _rtl865x_setDefACLForAllNetif(uint8 start_ingressAclIdx, uint8 end_
 		netif = &netifTbl[i];
 		if(netif->valid == 0 || netif->is_slave == 1)
 			continue;
-		
+
 		netif->inAclStart = start_ingressAclIdx;
 		netif->inAclEnd = end_ingressAclIdx;
 		netif->outAclStart = start_egressAclIdx;
 		netif->outAclEnd = end_egressAclIdx;
 		_rtl865x_setAsicNetif(netif);
 	}
-#if defined (CONFIG_RTL_LOCAL_PUBLIC)   
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
 	rtl865x_setDefACLForNetDecisionMiss(start_ingressAclIdx,end_ingressAclIdx,start_egressAclIdx,end_egressAclIdx);
 #endif
 
@@ -1892,7 +1903,7 @@ static int8 _rtl865x_sameAclRule(rtl865x_AclRule_t *rule1, rtl865x_AclRule_t *ru
 	case RTL865X_ACL_MAC:
 		 if (rule1->typeLen_ != rule2->typeLen_ || rule1->typeLenMask_ != rule2->typeLenMask_)
 		 	return FALSE;
-		 if (memcmp(&rule1->dstMac_, &rule2->dstMac_, sizeof(ether_addr_t)) || 
+		 if (memcmp(&rule1->dstMac_, &rule2->dstMac_, sizeof(ether_addr_t)) ||
 		 	 memcmp(&rule1->dstMacMask_, &rule2->dstMacMask_, sizeof(ether_addr_t)) ||
 			 memcmp(&rule1->srcMac_, &rule2->srcMac_, sizeof(ether_addr_t)) ||
 			 memcmp(&rule1->srcMacMask_, &rule2->srcMacMask_, sizeof(ether_addr_t)) )
@@ -1902,27 +1913,27 @@ static int8 _rtl865x_sameAclRule(rtl865x_AclRule_t *rule1, rtl865x_AclRule_t *ru
 	case RTL865X_ACL_IP_RANGE:
 		 if (rule1->ipProto_ != rule2->ipProto_ || rule1->ipProtoMask_ != rule2->ipProtoMask_ ||
 			rule1->ipFlag_ != rule2->ipFlag_ || rule1->ipFlagMask_ != rule2->ipFlagMask_)
-			return FALSE; 
+			return FALSE;
 		break;
-			
+
 	case RTL865X_ACL_ICMP:
 	case RTL865X_ACL_ICMP_IPRANGE:
 		 if (rule1->icmpType_ != rule2->icmpType_ || rule1->icmpTypeMask_ != rule2->icmpTypeMask_ ||
 			rule1->icmpCode_ != rule2->icmpCode_ || rule1->icmpCodeMask_ != rule2->icmpCodeMask_)
-			return FALSE; 
+			return FALSE;
 		 break;
 
 	case RTL865X_ACL_IGMP:
 	case RTL865X_ACL_IGMP_IPRANGE:
 		 if(rule1->igmpType_ != rule2->igmpType_ || rule1->igmpTypeMask_ != rule2->igmpTypeMask_)
-		 	return FALSE; 
+		 	return FALSE;
 		 break;
 	case RTL865X_ACL_TCP:
 	case RTL865X_ACL_TCP_IPRANGE:
 		 if(rule1->tcpFlag_ != rule2->tcpFlag_ || rule1->tcpFlagMask_ != rule2->tcpFlagMask_ ||
 			rule1->tcpSrcPortUB_ != rule2->tcpSrcPortUB_ || rule1->tcpSrcPortLB_ != rule2->tcpSrcPortLB_ ||
 			rule1->tcpDstPortUB_ != rule2->tcpDstPortUB_ || rule1->tcpDstPortLB_ != rule2->tcpDstPortLB_)
-		 	return FALSE; 
+		 	return FALSE;
 		 break;
 	case RTL865X_ACL_UDP:
 	case RTL865X_ACL_UDP_IPRANGE:
@@ -1957,9 +1968,9 @@ static int8 _rtl865x_sameAclRule(rtl865x_AclRule_t *rule1, rtl865x_AclRule_t *ru
 				(rule2->srcFilterIpAddrMask_ != rule2->srcFilterIpAddrMask_))
 				return FALSE;
 		}
-		
+
 		break;
-		
+
 	case RTL865X_ACL_DSTFILTER:
 	case RTL865X_ACL_DSTFILTER_IPRANGE:
 		if(	memcmp(&rule1->dstFilterMac_, &rule2->dstFilterMac_, sizeof(ether_addr_t)) != 0||
@@ -1985,17 +1996,17 @@ static int8 _rtl865x_sameAclRule(rtl865x_AclRule_t *rule1, rtl865x_AclRule_t *ru
 				(rule2->dstFilterIpAddrMask_ != rule2->dstFilterIpAddrMask_))
 				return FALSE;
 		}
-		
+
 		break;
 	default: return FALSE; /* Unknown rule type */
-	
+
 	}
 	/* Compare common part */
 	if (rule1->srcIpAddr_ != rule2->srcIpAddr_ || rule1->srcIpAddrMask_ != rule2->srcIpAddrMask_ ||
 		rule1->dstIpAddr_ != rule2->dstIpAddr_ || rule1->dstIpAddrMask_ != rule2->dstIpAddrMask_ ||
 		rule1->tos_ != rule2->tos_ || rule1->tosMask_ != rule2->tosMask_ )
 		return FALSE;
-	return TRUE;				
+	return TRUE;
 }
 
 
@@ -2003,13 +2014,13 @@ static int32 _rtl865x_addAclToChain(rtl865x_AclRule_t *rule, rtl865x_AclRule_t *
 {
 	rtl865x_AclRule_t *addAcl;
 	rtl865x_AclRule_t *tmpRule;
-	
+
 	if(head == NULL || tail == NULL)
 	{
 		return RTL_EINVALIDINPUT;
 	}
 
-	
+
 	if((*head) != NULL)
 	{
 		tmpRule = *head;
@@ -2022,7 +2033,7 @@ static int32 _rtl865x_addAclToChain(rtl865x_AclRule_t *rule, rtl865x_AclRule_t *
 			tmpRule = tmpRule->next;
 		}
 	}
-	
+
 	addAcl = freeAclList.freeHead;
 	if(addAcl == NULL)
 		return RTL_ENOFREEBUFFER;
@@ -2030,12 +2041,12 @@ static int32 _rtl865x_addAclToChain(rtl865x_AclRule_t *rule, rtl865x_AclRule_t *
 	/*remove acl buffer from freeAclList*/
 	freeAclList.freeHead = freeAclList.freeHead->next;
 	if(freeAclList.freeHead)
-		freeAclList.freeHead->pre = NULL;		
+		freeAclList.freeHead->pre = NULL;
 	freeAclList.freeCnt--;
 
 	memcpy(addAcl,rule,sizeof(rtl865x_AclRule_t));
-	
-	addAcl->pre = addAcl->next = NULL;	
+
+	addAcl->pre = addAcl->next = NULL;
 	if((*head) == NULL)
 	{
 		/*head = null, tail must null*/
@@ -2044,7 +2055,7 @@ static int32 _rtl865x_addAclToChain(rtl865x_AclRule_t *rule, rtl865x_AclRule_t *
 		*tail = addAcl;
 	}
 	else
-	{		
+	{
 		if(addAcl->aclIdx == 0 || addAcl->aclIdx > (*tail)->aclIdx)
 		{
 			/*append this rule to tail*/
@@ -2057,7 +2068,7 @@ static int32 _rtl865x_addAclToChain(rtl865x_AclRule_t *rule, rtl865x_AclRule_t *
 		else
 		{
 			/*user specified the index, it's means: this rule should be inserted before the rule->aclIdx*/
-			
+
 			tmpRule = *head;
 			while(tmpRule)
 			{
@@ -2066,15 +2077,15 @@ static int32 _rtl865x_addAclToChain(rtl865x_AclRule_t *rule, rtl865x_AclRule_t *
 					/*found the rule...*/
 					break;
 				}
-					
+
 				tmpRule = tmpRule->next;
 			}
 
 			if(tmpRule == NULL)
 			{
 				/*not found the correct position, append this rule at the tail??*/
-				
-				
+
+
 				printk("%s(%d): BUG!!!\n",__FUNCTION__,__LINE__);
 
 				addAcl->pre = NULL;
@@ -2101,7 +2112,7 @@ static int32 _rtl865x_addAclToChain(rtl865x_AclRule_t *rule, rtl865x_AclRule_t *
 				addAcl->pre = tmpRule->pre;
 				addAcl->next = tmpRule;
 				tmpRule->pre = addAcl;
-			}			
+			}
 
 			/*update aclIdx...*/
 			while(tmpRule)
@@ -2109,7 +2120,7 @@ static int32 _rtl865x_addAclToChain(rtl865x_AclRule_t *rule, rtl865x_AclRule_t *
 				tmpRule->aclIdx++;
 				tmpRule = tmpRule->next;
 			}
-			
+
 		}
 	}
 	return SUCCESS;
@@ -2119,7 +2130,7 @@ static int32 _rtl865x_delAclFromChain(rtl865x_AclRule_t *rule, rtl865x_AclRule_t
 {
 	rtl865x_AclRule_t *delRule,*nextRule;
 	int8 isSame = FALSE;
-		
+
 	if(head == NULL || tail == NULL)
 	{
 		return RTL_EINVALIDINPUT;
@@ -2143,7 +2154,7 @@ static int32 _rtl865x_delAclFromChain(rtl865x_AclRule_t *rule, rtl865x_AclRule_t
 				break;
 			}
 		}
-		
+
 		delRule = delRule->next;
 	}
 
@@ -2159,7 +2170,7 @@ static int32 _rtl865x_delAclFromChain(rtl865x_AclRule_t *rule, rtl865x_AclRule_t
 
 	if(delRule == *head)
 		*head = delRule->next;
-	
+
 	if(delRule == *tail)
 		*tail = delRule->pre;
 
@@ -2176,12 +2187,15 @@ static int32 _rtl865x_delAclFromChain(rtl865x_AclRule_t *rule, rtl865x_AclRule_t
 	{
 		nextRule->aclIdx--;
 		nextRule = nextRule->next;
-	}	
+	}
 	return SUCCESS;
 }
 
-
+#if defined(CONFIG_RTL_IPTABLES2ACL_PATCH)
+int32 _rtl865x_synAclwithAsicTbl(void)
+#else
 static int32 _rtl865x_synAclwithAsicTbl(void)
+#endif
 {
 	rtl865x_netif_local_t *netif = NULL;
 	rtl865x_acl_chain_t *chain;
@@ -2206,7 +2220,7 @@ static int32 _rtl865x_synAclwithAsicTbl(void)
 				rule = chain->head;
 				while(rule)
 				{
-					_rtl865x_setAclToAsic(startIdx, rule);					
+					_rtl865x_setAclToAsic(startIdx, rule);
 					addCnt++;
 					rule = rule->next;
 				}
@@ -2220,13 +2234,13 @@ static int32 _rtl865x_synAclwithAsicTbl(void)
 			if(totalAddCnt > 0)
 			{
 				netif->inAclEnd = netif->inAclStart + totalAddCnt -1;
-//				startIdx += addCnt; 
+//				startIdx += addCnt;
 			}
 			else
 				netif->inAclEnd = netif->inAclStart = RTL865X_ACLTBL_PERMIT_ALL; /*default permit...*/
-				
+
 			/*egress acl*/
-			chain = netif->chainListHead[RTL865X_ACL_EGRESS];			
+			chain = netif->chainListHead[RTL865X_ACL_EGRESS];
 			totalAddCnt = 0;
 			netif->outAclStart = startIdx;
 			while(chain)
@@ -2243,7 +2257,7 @@ static int32 _rtl865x_synAclwithAsicTbl(void)
 				startIdx += addCnt;
 				totalAddCnt += addCnt;
 			}
-			
+
 			if(totalAddCnt > 0)
 			{
 				netif->outAclEnd = netif->outAclStart + totalAddCnt -1;
@@ -2253,13 +2267,13 @@ static int32 _rtl865x_synAclwithAsicTbl(void)
 				netif->outAclEnd = netif->outAclStart = RTL865X_ACLTBL_PERMIT_ALL; /*default permit...*/
 
 			_rtl865x_setAsicNetif(netif);
-			
-		}		
+
+		}
 	}
 
-#if defined (CONFIG_RTL_LOCAL_PUBLIC)	
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
 	{
-		
+
 		netif = &virtualNetIf;
 		if(netif->valid)
 		{
@@ -2273,7 +2287,7 @@ static int32 _rtl865x_synAclwithAsicTbl(void)
 				rule = chain->head;
 				while(rule)
 				{
-					_rtl865x_setAclToAsic(startIdx, rule);					
+					_rtl865x_setAclToAsic(startIdx, rule);
 					addCnt++;
 					rule = rule->next;
 				}
@@ -2287,14 +2301,14 @@ static int32 _rtl865x_synAclwithAsicTbl(void)
 			if(totalAddCnt > 0)
 			{
 				netif->inAclEnd = netif->inAclStart + totalAddCnt -1;
-//				startIdx += addCnt; 
+//				startIdx += addCnt;
 			}
 			else
 				netif->inAclEnd = netif->inAclStart = RTL865X_ACLTBL_PERMIT_ALL; /*default permit...*/
 
-				
+
 			/*egress acl*/
-			chain = netif->chainListHead[RTL865X_ACL_EGRESS];			
+			chain = netif->chainListHead[RTL865X_ACL_EGRESS];
 			totalAddCnt = 0;
 			netif->outAclStart = startIdx;
 			while(chain)
@@ -2311,7 +2325,7 @@ static int32 _rtl865x_synAclwithAsicTbl(void)
 				startIdx += addCnt;
 				totalAddCnt += addCnt;
 			}
-			
+
 			if(totalAddCnt > 0)
 			{
 				netif->outAclEnd = netif->outAclStart + totalAddCnt -1;
@@ -2321,7 +2335,7 @@ static int32 _rtl865x_synAclwithAsicTbl(void)
 				netif->outAclEnd = netif->outAclStart = RTL865X_ACLTBL_PERMIT_ALL; /*default permit...*/
 			 //printk("netif->inAclStart is %d,netif->inAclEnd is %d,netif->outAclStart is %d, netif->outAclEnd is %d\n",netif->inAclStart,netif->inAclEnd,netif->outAclStart, netif->outAclEnd);
 			 rtl865x_setDefACLForNetDecisionMiss(netif->inAclStart, netif->inAclEnd, netif->outAclStart, netif->outAclEnd);
-		}		
+		}
 	}
 #endif
 	return SUCCESS;
@@ -2334,18 +2348,18 @@ static int32 _rtl865x_regist_aclChain(char *netifName, int32 priority,uint32 fla
 	rtl865x_netif_local_t *netif;
 	rtl865x_acl_chain_t *addEntry,*chainEntry;
 	uint32 aclDir = RTL865X_ACL_INGRESS;/*default :RTL865X_ACL_INGRESS*/
-	
+
 	netif = _rtl865x_getNetifByName(netifName);
 
 	if(netif == NULL)
-		return RTL_ENETIFINVALID;	
+		return RTL_ENETIFINVALID;
 
 	if(flag == RTL865X_ACL_EGRESS)
-		aclDir = RTL865X_ACL_EGRESS;	
+		aclDir = RTL865X_ACL_EGRESS;
 
 	chainEntry = netif->chainListHead[aclDir];
 
-	
+
 	while(chainEntry)
 	{
 		if(chainEntry->priority < priority)
@@ -2376,7 +2390,7 @@ static int32 _rtl865x_regist_aclChain(char *netifName, int32 priority,uint32 fla
 
 	if(chainEntry)
 	{
-		/*insert addentry before the chainEntry*/		
+		/*insert addentry before the chainEntry*/
 		addEntry->nextChain = chainEntry;
 		addEntry->preChain = chainEntry->preChain;
 
@@ -2387,8 +2401,8 @@ static int32 _rtl865x_regist_aclChain(char *netifName, int32 priority,uint32 fla
 			/*insert before head???*/
 			netif->chainListHead[aclDir] = addEntry;
 		}
-		
-		chainEntry->preChain = addEntry;		
+
+		chainEntry->preChain = addEntry;
 	}
 	else
 	{
@@ -2402,7 +2416,7 @@ static int32 _rtl865x_regist_aclChain(char *netifName, int32 priority,uint32 fla
 			{
 				if(chainEntry->nextChain == NULL)
 					break;
-				
+
 				chainEntry = chainEntry->nextChain;
 			}
 
@@ -2425,18 +2439,18 @@ static int32 _rtl865x_unRegist_aclChain(char *netifName,int32 priority, uint32 f
 	rtl865x_AclRule_t *aclRule;
 	rtl865x_acl_chain_t *chainEntry;
 	uint32 aclDir = RTL865X_ACL_INGRESS;/*default :RTL865X_ACL_INGRESS*/
-	
+
 	netif = _rtl865x_getNetifByName(netifName);
 
 	if(netif == NULL)
-		return RTL_ENETIFINVALID;	
+		return RTL_ENETIFINVALID;
 
 	if(flag == RTL865X_ACL_EGRESS)
-		aclDir = RTL865X_ACL_EGRESS;	
+		aclDir = RTL865X_ACL_EGRESS;
 
 	chainEntry = netif->chainListHead[aclDir];
 
-	
+
 	while(chainEntry)
 	{
 		if(chainEntry->priority == priority)
@@ -2457,26 +2471,26 @@ static int32 _rtl865x_unRegist_aclChain(char *netifName,int32 priority, uint32 f
 	}
 
 	chainEntry->ruleCnt = 0;
-	
+
 	if(chainEntry->nextChain)
 		chainEntry->nextChain->preChain = chainEntry->preChain;
-	
+
 	if(chainEntry->preChain)
 		chainEntry->preChain->nextChain = chainEntry->nextChain;
 	else
-		/*remove head???*/	
+		/*remove head???*/
 		netif->chainListHead[aclDir] = chainEntry->nextChain;
 
-	
+
 	memset(chainEntry,0,sizeof(rtl865x_acl_chain_t));
 
 	chainEntry->nextChain = freeChainHead;
 	if (freeChainHead)
-		freeChainHead->preChain = chainEntry;	
+		freeChainHead->preChain = chainEntry;
 	freeChainHead = chainEntry;
 
 	_rtl865x_synAclwithAsicTbl();
-	
+
 	return SUCCESS;
 }
 
@@ -2488,16 +2502,16 @@ static int32 _rtl865x_flush_allAcl_fromChain(char *netifName,int32 priority, uin
 	uint32 aclDir = RTL865X_ACL_INGRESS;/*default :RTL865X_ACL_INGRESS*/
 
 	if(flag == RTL865X_ACL_EGRESS)
-		aclDir = RTL865X_ACL_EGRESS;	
+		aclDir = RTL865X_ACL_EGRESS;
 
 	if(netifName && netifName[0] != '\0')
 	{
 		netif = _rtl865x_getNetifByName(netifName);
 
 		if(netif == NULL)
-			return RTL_ENETIFINVALID;	
+			return RTL_ENETIFINVALID;
 
-		chainEntry = netif->chainListHead[aclDir];		
+		chainEntry = netif->chainListHead[aclDir];
 		while(chainEntry)
 		{
 			if(chainEntry->priority == priority)
@@ -2526,10 +2540,10 @@ static int32 _rtl865x_flush_allAcl_fromChain(char *netifName,int32 priority, uin
 		int32 i;
 		for(i = 0 ; i < NETIF_NUMBER; i++)
 		{
-			netif = &netifTbl[i];	
+			netif = &netifTbl[i];
 			if(netif->valid)
 			{
-				chainEntry = netif->chainListHead[aclDir];	
+				chainEntry = netif->chainListHead[aclDir];
 				while(chainEntry)
 				{
 					if(chainEntry->priority == priority)
@@ -2555,7 +2569,7 @@ static int32 _rtl865x_flush_allAcl_fromChain(char *netifName,int32 priority, uin
 	}
 
 	_rtl865x_synAclwithAsicTbl();
-	
+
 	return SUCCESS;
 }
 
@@ -2568,16 +2582,16 @@ static rtl865x_AclRule_t* _rtl865x_matched_layer4_aclChain(char *netifName,int32
 	uint32 aclDir = RTL865X_ACL_INGRESS;/*default :RTL865X_ACL_INGRESS*/
 
 	if(flag == RTL865X_ACL_EGRESS)
-		aclDir = RTL865X_ACL_EGRESS;	
+		aclDir = RTL865X_ACL_EGRESS;
 
 	if(netifName && netifName[0] != '\0')
 	{
 		netif = _rtl865x_getNetifByName(netifName);
 
 		if(netif == NULL)
-			return NULL;	
+			return NULL;
 
-		chainEntry = netif->chainListHead[aclDir];		
+		chainEntry = netif->chainListHead[aclDir];
 		while(chainEntry)
 		{
 			if(chainEntry->priority == priority)
@@ -2689,16 +2703,16 @@ static rtl865x_AclRule_t* _rtl865x_matched_layer2_aclChain(char *netifName,int32
 	uint32 aclDir = RTL865X_ACL_INGRESS;/*default :RTL865X_ACL_INGRESS*/
 
 	if(flag == RTL865X_ACL_EGRESS)
-		aclDir = RTL865X_ACL_EGRESS;	
+		aclDir = RTL865X_ACL_EGRESS;
 
 	if(netifName && netifName[0] != '\0')
 	{
 		netif = _rtl865x_getNetifByName(netifName);
 
 		if(netif == NULL)
-			return NULL;	
+			return NULL;
 
-		chainEntry = netif->chainListHead[aclDir];		
+		chainEntry = netif->chainListHead[aclDir];
 		while(chainEntry)
 		{
 			if(chainEntry->priority == priority)
@@ -2747,10 +2761,10 @@ static int32 _rtl865x_unRegister_all_aclChain(char *netifName)
 	rtl865x_AclRule_t *aclRule;
 	rtl865x_acl_chain_t *chainEntry;
 	uint32 aclDir = RTL865X_ACL_INGRESS;
-		
+
 	netif = _rtl865x_getNetifByName(netifName);
 	if(netif == NULL)
-		return RTL_ENETIFINVALID;	
+		return RTL_ENETIFINVALID;
 
 	for(aclDir = RTL865X_ACL_INGRESS; aclDir <= RTL865X_ACL_EGRESS; aclDir++)
 	{
@@ -2765,16 +2779,16 @@ static int32 _rtl865x_unRegister_all_aclChain(char *netifName)
 				aclRule = chainEntry->head;
 			}
 
-			chainEntry->ruleCnt = 0;			
+			chainEntry->ruleCnt = 0;
 			netif->chainListHead[aclDir] = chainEntry->nextChain;
 
 			/*remove to freelist*/
 			chainEntry->nextChain = freeChainHead;
 			if(freeChainHead)
-				freeChainHead->preChain = chainEntry;	
+				freeChainHead->preChain = chainEntry;
 			freeChainHead = chainEntry;
 
-			chainEntry = netif->chainListHead[aclDir];			
+			chainEntry = netif->chainListHead[aclDir];
 		}
 	}
 
@@ -2813,7 +2827,7 @@ static int32 _rtl865x_add_acl(rtl865x_AclRule_t *rule, char *netifName,int32 cha
 		netif = _rtl865x_getNetifByName(netifName);
 		if(netif == NULL)
 			return RTL_EINVALIDINPUT;
-	
+
 		chain = _rtl865x_find_aclChain_byPriority(netif->chainListHead[rule->direction_],chainNo);
 		if(chain == NULL)
 			return RTL_EENTRYNOTFOUND;
@@ -2842,7 +2856,7 @@ static int32 _rtl865x_add_acl(rtl865x_AclRule_t *rule, char *netifName,int32 cha
 				if(memcmp(netif->name,netifName,strlen(netifName)) == 0)
 					continue;
 			}
-			
+
 			/*add rule to netif*/
 			{
 				chain = _rtl865x_find_aclChain_byPriority(netif->chainListHead[rule->direction_],chainNo);
@@ -2858,11 +2872,11 @@ static int32 _rtl865x_add_acl(rtl865x_AclRule_t *rule, char *netifName,int32 cha
 			}
 		}
 	}
-	
+
 	if(isSynAsic == 1)
 		_rtl865x_synAclwithAsicTbl();
-	
-	return retval;	
+
+	return retval;
 }
 
 static int32 _rtl865x_del_acl(rtl865x_AclRule_t *rule, char *netifName,int32 chainNo)
@@ -2874,7 +2888,7 @@ static int32 _rtl865x_del_acl(rtl865x_AclRule_t *rule, char *netifName,int32 cha
 
 	if(rule == NULL)
 		return RTL_EINVALIDINPUT;
-	
+
 	if(netifName)
 	{
 		netif = _rtl865x_getNetifByName(netifName);
@@ -2888,7 +2902,7 @@ static int32 _rtl865x_del_acl(rtl865x_AclRule_t *rule, char *netifName,int32 cha
 		chain = _rtl865x_find_aclChain_byPriority(netif->chainListHead[rule->direction_],chainNo);
 		if(chain == NULL)
 			return RTL_EENTRYNOTFOUND;
-		
+
 		retval = _rtl865x_delAclFromChain(rule, &(chain->head), &(chain->tail));
 		if(retval == SUCCESS)
 		{
@@ -2902,7 +2916,7 @@ static int32 _rtl865x_del_acl(rtl865x_AclRule_t *rule, char *netifName,int32 cha
 		int32 i;
 		for(i = 0 ; i < NETIF_NUMBER; i++)
 		{
-			netif = &netifTbl[i];	
+			netif = &netifTbl[i];
 			if(netif->valid)
 			{
 				chain = _rtl865x_find_aclChain_byPriority(netif->chainListHead[rule->direction_],chainNo);
@@ -2920,9 +2934,9 @@ static int32 _rtl865x_del_acl(rtl865x_AclRule_t *rule, char *netifName,int32 cha
 
 	if(isSynAsic == 1)
 		_rtl865x_synAclwithAsicTbl();
-	
-	return retval;	
-	
+
+	return retval;
+
 }
 
 /*
@@ -2949,7 +2963,7 @@ ingress acl head--->acl chain(priority0)--->acl chain(priority1)--->acl chain(pr
 					|->acl rule3			|->acl rule3			|->aclrule3
 					|->acl rule4								|->aclrule4
 					|->acl rule5								|->aclrule5
-					
+
 
 */
 int32 rtl865x_regist_aclChain(char *netifName, int32 priority, uint32 flag)
@@ -2990,6 +3004,182 @@ int32 rtl865x_flush_allAcl_fromChain(char *netifName, int32 priority, uint32 fla
 	return _rtl865x_flush_allAcl_fromChain(netifName, priority, flag);
 }
 
+#if defined(CONFIG_RTL_IPTABLES2ACL_PATCH)
+
+static int32 _rtl865x_flush_allAcl_sw_fromChain(char *netifName,int32 priority, uint32 flag)
+{
+	rtl865x_netif_local_t *netif;
+	rtl865x_AclRule_t *aclRule;
+	rtl865x_acl_chain_t *chainEntry;
+	uint32 aclDir = RTL865X_ACL_INGRESS;/*default :RTL865X_ACL_INGRESS*/
+
+	if(flag == RTL865X_ACL_EGRESS)
+		aclDir = RTL865X_ACL_EGRESS;
+
+	if(netifName && netifName[0] != '\0')
+	{
+		netif = _rtl865x_getNetifByName(netifName);
+
+		if(netif == NULL)
+			return RTL_ENETIFINVALID;
+
+		chainEntry = netif->chainListHead[aclDir];
+		while(chainEntry)
+		{
+			if(chainEntry->priority == priority)
+				break;
+			chainEntry = chainEntry->nextChain;
+		}
+
+		if(chainEntry == NULL)
+			return RTL_EENTRYNOTFOUND;
+
+		/*remove all aclrule*/
+		aclRule = chainEntry->head;
+		while(aclRule)
+		{
+			_rtl865x_delAclFromChain(aclRule, &chainEntry->head, &chainEntry->tail);
+			aclRule = chainEntry->head;
+			chainEntry->ruleCnt--;
+		}
+
+		chainEntry->ruleCnt = 0;
+
+	}
+	else
+	{
+		/*add this rule to every netif*/
+		int32 i;
+		for(i = 0 ; i < NETIF_NUMBER; i++)
+		{
+			netif = &netifTbl[i];
+			if(netif->valid)
+			{
+				chainEntry = netif->chainListHead[aclDir];
+				while(chainEntry)
+				{
+					if(chainEntry->priority == priority)
+						break;
+					chainEntry = chainEntry->nextChain;
+				}
+
+				if(chainEntry == NULL)
+					continue;
+
+				/*remove all aclrule*/
+				aclRule = chainEntry->head;
+				while(aclRule)
+				{
+					_rtl865x_delAclFromChain(aclRule, &chainEntry->head, &chainEntry->tail);
+					aclRule = chainEntry->head;
+					chainEntry->ruleCnt--;
+				}
+
+				chainEntry->ruleCnt = 0;
+			}
+		}
+	}
+
+	//_rtl865x_synAclwithAsicTbl();
+	return SUCCESS;
+}
+
+int32 rtl865x_flush_allAcl_sw_fromChain(char *netifName, int32 priority, uint32 flag)
+{
+	return _rtl865x_flush_allAcl_sw_fromChain(netifName, priority, flag);
+}
+
+static int32 _rtl865x_add_sw_acl(rtl865x_AclRule_t *rule, char *netifName,int32 chainNo)
+{
+	rtl865x_netif_local_t *netif = NULL;
+	rtl865x_acl_chain_t *chain = NULL;
+	int32 isSynAsic = 0;
+	int32 retval = FAILED;
+
+	if(rule == NULL)
+		return RTL_EINVALIDINPUT;
+
+	if(netifName && netifName[0] != '\0' && (rule->inv_flag == 0))
+	{
+		netif = _rtl865x_getNetifByName(netifName);
+		if(netif == NULL)
+			return RTL_EINVALIDINPUT;
+
+		chain = _rtl865x_find_aclChain_byPriority(netif->chainListHead[rule->direction_],chainNo);
+		if(chain == NULL)
+			return RTL_EENTRYNOTFOUND;
+
+		retval = _rtl865x_addAclToChain(rule, &(chain->head), &(chain->tail));
+		if(retval == SUCCESS)
+		{
+			isSynAsic = 1;
+			chain->ruleCnt++;
+		}
+	}
+	else
+	{
+		/*add this rule to every netif*/
+		int32 i;
+		for(i = 0 ; i < NETIF_NUMBER; i++)
+		{
+			netif = &netifTbl[i];
+			if(netif->valid == 0)
+				continue;
+
+			/*inv_flag != 0, means alc should add to the other netifs else netifName*/
+			/*now: the inv_flag only should be RTL865X_INVERT_IN_NETIF or RTL865X_INVERT_OUT_NETIF*/
+			if(netifName && netifName[0] != '\0' && rule->inv_flag != 0)
+			{
+				if(memcmp(netif->name,netifName,strlen(netifName)) == 0)
+					continue;
+			}
+
+			/*add rule to netif*/
+			{
+				chain = _rtl865x_find_aclChain_byPriority(netif->chainListHead[rule->direction_],chainNo);
+				if(chain == NULL)
+					continue;
+
+				retval = _rtl865x_addAclToChain(rule, &(chain->head), &(chain->tail));
+				if(retval == SUCCESS)
+				{
+					isSynAsic = 1;
+					chain->ruleCnt++;
+				}
+			}
+		}
+	}
+
+	//if(isSynAsic == 1)
+		//_rtl865x_synAclwithAsicTbl();
+
+	return retval;
+}
+
+
+int32 rtl865x_add_sw_acl(rtl865x_AclRule_t *rule, char *netifName,int32 priority)
+{
+	int32 retval = FAILED;
+	unsigned long flags;
+	//printk("********%s(%d)*********,netif(%s),priority(%d)\n",__FUNCTION__,__LINE__,netifName,priority);
+#if defined(CONFIG_RTK_VLAN_SUPPORT)
+	if(rtl865x_acl_enable == 0)
+		return retval;
+#endif
+	//rtl_down_interruptible(&netif_sem);
+	local_irq_save(flags);
+	retval = _rtl865x_add_sw_acl(rule,netifName,priority);
+	if(retval == RTL_ENOFREEBUFFER){	// acl entries is full.
+		_rtl865x_setDefACLForAllNetif(RTL865X_ACLTBL_PERMIT_ALL,RTL865X_ACLTBL_PERMIT_ALL,RTL865X_ACLTBL_PERMIT_ALL,RTL865X_ACLTBL_PERMIT_ALL);
+	}
+	//rtl_up(&netif_sem);
+	local_irq_restore(flags);
+	//printk("********%s(%d)*********retval(%d)\n",__FUNCTION__,__LINE__,retval);
+	return retval;
+}
+
+#endif
+
 rtl865x_AclRule_t* rtl865x_matched_layer4_aclChain(char *netifName,int32 priority, uint32 flag, rtl865x_AclRule_t *match)
 {
 	return _rtl865x_matched_layer4_aclChain(netifName, priority, flag, match);
@@ -3025,7 +3215,7 @@ int32 rtl865x_init_acl_chain(void)
 	rtl865x_acl_chain_t *entry;
 
 	freeChainHead = NULL;
-		
+
 	TBL_MEM_ALLOC(entry, rtl865x_acl_chain_t, RTL865X_ACL_CHAIN_NUMBER);
 
 	for(i = 0; i<RTL865X_ACL_CHAIN_NUMBER;i++)
@@ -3040,7 +3230,7 @@ int32 rtl865x_init_acl_chain(void)
 			freeChainHead->preChain = &entry[i];
 		freeChainHead = &entry[i];
 	}
-	
+
 	return SUCCESS;
 }
 
@@ -3056,7 +3246,7 @@ int32 rtl865x_init_acl(void)
 	rtl865x_AclRule_t *aclEntry;
 
 	freeAclList.freeHead = NULL;
-		
+
 	TBL_MEM_ALLOC(aclEntry, rtl865x_AclRule_t, RTL865X_ACL_MAX_NUMBER);
 
 	for(i = 0; i<RTL865X_ACL_MAX_NUMBER;i++)
@@ -3067,11 +3257,11 @@ int32 rtl865x_init_acl(void)
 		if(freeAclList.freeHead)
 			freeAclList.freeHead->pre = &aclEntry[i];
 		freeAclList.freeHead = &aclEntry[i];
-			
+
 		freeAclList.totalCnt++;
-		freeAclList.freeCnt++;		
+		freeAclList.freeCnt++;
 	}
-	
+
 	_rtl865x_confReservedAcl();
 	/*init acl chains*/
 	rtl865x_init_acl_chain();
@@ -3093,9 +3283,9 @@ int32 rtl865x_init_acl(void)
 	ACL rule structure: please refer in header file.
 */
 int32 rtl865x_add_acl(rtl865x_AclRule_t *rule, char *netifName,int32 priority)
-{	
+{
 	int32 retval = FAILED;
-	unsigned long flags;	
+	unsigned long flags;
 	//printk("********%s(%d)*********,netif(%s),priority(%d)\n",__FUNCTION__,__LINE__,netifName,priority);
 #if defined(CONFIG_RTK_VLAN_SUPPORT)
 	if(rtl865x_acl_enable == 0)
@@ -3103,14 +3293,14 @@ int32 rtl865x_add_acl(rtl865x_AclRule_t *rule, char *netifName,int32 priority)
 #endif
 	//rtl_down_interruptible(&netif_sem);
 	local_irq_save(flags);
-	retval = _rtl865x_add_acl(rule,netifName,priority);	
+	retval = _rtl865x_add_acl(rule,netifName,priority);
 	if(retval == RTL_ENOFREEBUFFER){	// acl entries is full.
 		_rtl865x_setDefACLForAllNetif(RTL865X_ACLTBL_PERMIT_ALL,RTL865X_ACLTBL_PERMIT_ALL,RTL865X_ACLTBL_PERMIT_ALL,RTL865X_ACLTBL_PERMIT_ALL);
 	}
 	//rtl_up(&netif_sem);
 	local_irq_restore(flags);
 	//printk("********%s(%d)*********retval(%d)\n",__FUNCTION__,__LINE__,retval);
-	return retval;	
+	return retval;
 }
 
 /*
@@ -3126,22 +3316,22 @@ int32 rtl865x_add_acl(rtl865x_AclRule_t *rule, char *netifName,int32 priority)
 	ACL rule structure: please refer in header file.
 */
 int32 rtl865x_del_acl(rtl865x_AclRule_t *rule, char *netifName,int32 priority)
-{	
+{
 	int32 retval = FAILED;
-	unsigned long flags;	
+	unsigned long flags;
 	//rtl_down_interruptible(&netif_sem);
 	local_irq_save(flags);
-	retval = _rtl865x_del_acl(rule,netifName,priority);	
+	retval = _rtl865x_del_acl(rule,netifName,priority);
 	//rtl_up(&netif_sem);
 	local_irq_restore(flags);
-	return retval;		
+	return retval;
 }
 
 #if defined(CONFIG_RTK_VLAN_SUPPORT)
 int32 rtl865x_enable_acl(uint32 enable)
 {
 	if(enable)
-	{		
+	{
 		rtl865x_acl_enable = 1;
 		_rtl865x_setDefACLForAllNetif(RTL865X_ACLTBL_PERMIT_ALL,RTL865X_ACLTBL_PERMIT_ALL,RTL865X_ACLTBL_PERMIT_ALL,RTL865X_ACLTBL_PERMIT_ALL);
 	}
@@ -3158,27 +3348,27 @@ int32 rtl865x_enable_acl(uint32 enable)
 
 int  rtl865x_add_pattern_acl_for_contentFilter(rtl865x_AclRule_t *rule,char *netifName)
 {
-	uint32 i;     
-	//### add by sen_liu 2011.5.4 to get wan prot  
+	uint32 i;
+	//### add by sen_liu 2011.5.4 to get wan prot
 	rtl865x_netif_local_t	*netif;
 	rtl865x_vlan_entry_t	*vlan;
-	union 
+	union
 	{
 		char pat[4];
 		uint32 pattern;
 	}u;
-		
+
 	if(rule == NULL)
-		return FAILED;	
-        
-        rtl865x_add_acl(rule, netifName, RTL865X_ACL_SYSTEM_USED);                
+		return FAILED;
+
+        rtl865x_add_acl(rule, netifName, RTL865X_ACL_SYSTEM_USED);
  		netif = _rtl865x_getNetifByName(netifName);
         if(netif == NULL)
         	return FAILED;
         vlan = _rtl8651_getVlanTableEntry(netif->vid);
         if(vlan == NULL)
         	return FAILED;
-        
+
         u.pat[0]='T';
         u.pat[1]='T';
         u.pat[2]='P';
@@ -3189,36 +3379,36 @@ int  rtl865x_add_pattern_acl_for_contentFilter(rtl865x_AclRule_t *rule,char *net
 				if(rtl8651_setAsicPortPatternMatch(i, u.pattern, 0xffffffff, 0x2)!=SUCCESS)
 					return FAILED;
 			}
-               
+
         }
-		
+
         return SUCCESS;
 }
 
 int  rtl865x_del_pattern_acl_for_contentFilter(rtl865x_AclRule_t *rule,char *netifName)
-{ 
-	union 
+{
+	union
 	{
 		char pat[4];
 		uint32 pattern;
-	}u;                     
+	}u;
 	int32 i;
 
 	rtl865x_netif_local_t	*netif;
 	rtl865x_vlan_entry_t	*vlan;
-	
+
 	if(rule == NULL)
-		return FAILED;	
-	
+		return FAILED;
+
 	rtl865x_del_acl(rule, netifName, RTL865X_ACL_SYSTEM_USED);
-	
+
 	netif = _rtl865x_getNetifByName(netifName);
         if(netif == NULL)
         	return FAILED;
         vlan = _rtl8651_getVlanTableEntry(netif->vid);
         if(vlan == NULL)
         	return FAILED;
-			
+
 	u.pat[0]='T';
 	u.pat[1]='T';
 	u.pat[2]='P';
@@ -3227,7 +3417,7 @@ int  rtl865x_del_pattern_acl_for_contentFilter(rtl865x_AclRule_t *rule,char *net
 	{
 		if (vlan->memberPortMask & 1<<i) {
 				rtl8651_setAsicPortPatternMatch(i, 0, 0, 0x2);
-			}	
+			}
 	}
 
 	return SUCCESS;
@@ -3265,7 +3455,7 @@ int32 rtl865x_detachMasterNetif(char *slave)
 int32 rtl865x_addNetif(rtl865x_netif_t *netif)
 {
 	int32 retval = FAILED;
-	unsigned long flags;	
+	unsigned long flags;
 	//rtl_down_interruptible(&netif_sem);
 	local_irq_save(flags);
 	retval = _rtl865x_addNetif(netif);
@@ -3281,12 +3471,12 @@ int32 rtl865x_addNetif(rtl865x_netif_t *netif)
 @rvalue RTL_EENTRYNOTFOUND | network interface is NOT found
 @rvalue RTL_EREFERENCEDBYOTHER | netif is referenced by onter table entry
 @rvalue FAILED | Failed
-@comm	
+@comm
 */
 int32 rtl865x_delNetif(char *ifName)
 {
 	int32 retval = FAILED;
-	unsigned long flags;	
+	unsigned long flags;
 	//rtl_down_interruptible(&netif_sem);
 	local_irq_save(flags);
 	retval = _rtl865x_delNetif(ifName);
@@ -3319,7 +3509,7 @@ int32 rtl865x_addVirtualNetif(rtl865x_netif_t *netif)
 	entry->inAclEnd = entry->inAclStart = entry->outAclEnd = entry->outAclStart = RTL865X_ACLTBL_PERMIT_ALL; /*default permit...*/
 	entry->refCnt = 1;
 
-	
+
 #ifdef 	CONFIG_RTL_LAYERED_DRIVER_ACL
 	entry->chainListHead[RTL865X_ACL_INGRESS] = NULL;
 	entry->chainListHead[RTL865X_ACL_EGRESS] = NULL;
@@ -3338,7 +3528,7 @@ int32 rtl865x_addVirtualNetif(rtl865x_netif_t *netif)
 int32 rtl865x_delVirtualNetif(char *ifName)
 {
 	int32 retval = FAILED;
-	unsigned long flags;	
+	unsigned long flags;
 	//rtl_down_interruptible(&netif_sem);
 	local_irq_save(flags);
 	retval = _rtl865x_delNetif(ifName);
@@ -3360,7 +3550,7 @@ when other table entry refer network interface table entry, please call this API
 int32 rtl865x_referNetif(char *ifName)
 {
 	int32 retval = FAILED;
-	unsigned long flags;	
+	unsigned long flags;
 	//rtl_down_interruptible(&netif_sem);
 	local_irq_save(flags);
 	retval = _rtl865x_referNetif(ifName);
@@ -3375,13 +3565,13 @@ int32 rtl865x_referNetif(char *ifName)
 @rvalue SUCCESS | Success.
 @rvalue RTL_EENTRYNOTFOUND | network interface is NOT found
 @rvalue FAILED | Failed
-@comm	
+@comm
 this API should be called after rtl865x_referNetif.
 */
 int32 rtl865x_deReferNetif(char *ifName)
 {
 	int32 retval = FAILED;
-	unsigned long flags;	
+	unsigned long flags;
 	//rtl_down_interruptible(&netif_sem);
 	local_irq_save(flags);
 	retval = _rtl865x_deReferNetif(ifName);
@@ -3397,12 +3587,12 @@ int32 rtl865x_deReferNetif(char *ifName)
 @rvalue SUCCESS | Success.
 @rvalue RTL_EENTRYNOTFOUND | network interface is NOT found
 @rvalue FAILED | Failed
-@comm	
+@comm
 */
 int32 rtl865x_setNetifVid(char *name, uint16 vid)
 {
 	int32 ret;
-	unsigned long flags;	
+	unsigned long flags;
 	//rtl_down_interruptible(&netif_sem);
 	local_irq_save(flags);
 	ret = _rtl865x_setNetifVid(name,vid);
@@ -3416,11 +3606,11 @@ int32 rtl865x_setPortToNetif(char *name,uint32 port)
 	int32 ret;
 	rtl865x_netif_local_t *entry;
 	entry = _rtl865x_getNetifByName(name);
-	
+
 	if(entry == NULL)
 		return FAILED;
 
-	ret = rtl8651_setPortToNetif(port, entry->asicIdx);	
+	ret = rtl8651_setPortToNetif(port, entry->asicIdx);
 	return ret;
 }
 
@@ -3431,12 +3621,12 @@ int32 rtl865x_setPortToNetif(char *name,uint32 port)
 @rvalue SUCCESS | Success.
 @rvalue RTL_EENTRYNOTFOUND | network interface is NOT found
 @rvalue FAILED | Failed
-@comm	
+@comm
 */
 int32 rtl865x_setNetifType(char *name, uint32 ifType)
 {
 	int32 ret;
-	unsigned long flags;	
+	unsigned long flags;
 	//rtl_down_interruptible(&netif_sem);
 	local_irq_save(flags);
 	ret = _rtl865x_setNetifType(name,ifType);
@@ -3451,12 +3641,12 @@ int32 rtl865x_setNetifType(char *name, uint32 ifType)
 @rvalue SUCCESS | Success.
 @rvalue RTL_EENTRYNOTFOUND | network interface is NOT found
 @rvalue FAILED | Failed
-@comm	
+@comm
 */
 int32 rtl865x_setNetifMac(rtl865x_netif_t *netif)
 {
 	int32 retval = FAILED;
-	unsigned long flags;	
+	unsigned long flags;
 	//rtl_down_interruptible(&netif_sem);
 	local_irq_save(flags);
 	retval = _rtl865x_setNetifMac(netif);
@@ -3471,16 +3661,16 @@ int32 rtl865x_setNetifMac(rtl865x_netif_t *netif)
 @rvalue SUCCESS | Success.
 @rvalue RTL_EENTRYNOTFOUND | network interface is NOT found
 @rvalue FAILED | Failed
-@comm	
+@comm
 */
 int32 rtl865x_setNetifMtu(rtl865x_netif_t *netif)
 {
 	int32 retval = FAILED;
-	unsigned long flags;	
+	unsigned long flags;
 	//rtl_down_interruptible(&netif_sem);
 	local_irq_save(flags);
 	retval = _rtl865x_setNetifMtu(netif);
-	//rtl_up(&netif_sem);	
+	//rtl_up(&netif_sem);
 	local_irq_restore(flags);
 	return retval;
 }
@@ -3493,7 +3683,7 @@ int32 rtl865x_setNetifMtu(rtl865x_netif_t *netif)
 */
 int32 rtl865x_initNetifTable(void)
 {
-	TBL_MEM_ALLOC(netifTbl, rtl865x_netif_local_t, NETIF_NUMBER);	
+	TBL_MEM_ALLOC(netifTbl, rtl865x_netif_local_t, NETIF_NUMBER);
 	memset(netifTbl,0,sizeof(rtl865x_netif_local_t)*NETIF_NUMBER);
 #ifdef CONFIG_RTL_LAYERED_DRIVER_ACL
 	/*init reserved acl in function init_acl...*/
@@ -3506,7 +3696,7 @@ int32 rtl865x_initNetifTable(void)
 #endif
 	rtl_get_drv_netifName_by_psName = NULL;
 
-	return SUCCESS;	
+	return SUCCESS;
 }
 
 int32 rtl865x_config_callback_for_get_drv_netifName(int (*fun)(const char *psName,char *netifName))
@@ -3519,14 +3709,14 @@ int32 rtl865x_get_drvNetifName_by_psName(const char *psName,char *netifName)
 {
 	if(strlen(psName) >= MAX_IFNAMESIZE)
 		return FAILED;
-	
+
 	if(rtl_get_drv_netifName_by_psName)
 		rtl_get_drv_netifName_by_psName(psName,netifName);
 	else
 	{
 		memcpy(netifName,psName,MAX_IFNAMESIZE);
 	}
-	
+
 	return SUCCESS;
 }
 
@@ -3536,12 +3726,12 @@ int32 rtl865x_get_drvNetifName_by_psName(const char *psName,char *netifName)
 @rvalue SUCCESS | Success.
 @rvalue RTL_EINVALIDINPUT | input is invalid
 @rvalue FAILED | Failed
-@comm	
+@comm
 */
 int32 rtl865x_enableNetifRouting(rtl865x_netif_local_t *netif)
 {
 	int32 retval = FAILED;
-	
+
 	if(netif == NULL)
 		return RTL_EINVALIDINPUT;
 	if(netif ->enableRoute == 1)
@@ -3558,15 +3748,15 @@ int32 rtl865x_enableNetifRouting(rtl865x_netif_local_t *netif)
 @rvalue SUCCESS | Success.
 @rvalue RTL_EINVALIDINPUT | input is invalid
 @rvalue FAILED | Failed
-@comm	
+@comm
 */
 int32 rtl865x_disableNetifRouting(rtl865x_netif_local_t *netif)
 {
 	int32 retval = FAILED;
-	
+
 	if(netif == NULL)
 		return RTL_EINVALIDINPUT;
-	
+
 	if(netif ->enableRoute == 0)
 		return SUCCESS;
 
@@ -3581,12 +3771,12 @@ int32 rtl865x_disableNetifRouting(rtl865x_netif_local_t *netif)
 @rvalue SUCCESS | Success.
 @rvalue RTL_EINVALIDINPUT | input is invalid
 @rvalue FAILED | Failed
-@comm	
+@comm
 */
 int32 rtl865x_reinitNetifTable(void)
 {
 	int32 i;
-	unsigned long flags;	
+	unsigned long flags;
 	//rtl_down_interruptible(&netif_sem);
 	local_irq_save(flags);
 	for(i = 0; i < NETIF_NUMBER; i++)
@@ -3620,7 +3810,7 @@ uint32 rtl865x_getExternalPortMask(void)
 
 	for(i = 0; i < NETIF_NUMBER; i++)
 	{
-		netif = &netifTbl[i];		
+		netif = &netifTbl[i];
 		if((netif->valid == 1) && (netif->is_wan==1))
 		{
 			externalPortMask|=rtl865x_getVlanPortMask(netif->vid);
@@ -3645,10 +3835,10 @@ int32 rtl865x_getNetifVid(char *name, uint32 *vid)
 	{
 		return FAILED;
 	}
-	
+
 	*vid=(uint32)(entry->vid);
 	return SUCCESS;
-	
+
 }
 
 int32 rtl865x_getNetifType(char *name,uint32 *type)
@@ -3664,17 +3854,17 @@ int32 rtl865x_getNetifType(char *name,uint32 *type)
 	{
 		return FAILED;
 	}
-	
+
 	entry = _rtl865x_getNetifByName(name);
 
 	if(entry == NULL)
 	{
 		return FAILED;
 	}
-	
+
 	*type=(uint32)(entry->if_type);
 	return SUCCESS;
-	
+
 }
 #endif
 
@@ -3713,7 +3903,7 @@ int32 rtl865x_acl_test(int32 testNo)
 			printk("====================================\n");
 
 			retval = _rtl865x_unRegist_aclChain(RTL_DRV_LAN_NETIF_NAME, -500, RTL865X_ACL_INGRESS);
-			
+
 			chain = netif->chainListHead[RTL865X_ACL_INGRESS];
 			cnt = 0;
 			printk("=============after unregist the chain================\n");
@@ -3742,14 +3932,14 @@ int32 rtl865x_acl_test(int32 testNo)
 			printk("now the information of netif(%s) is:\n\n",netif->name);
 			_rtl865x_print_allChain_allAcl(netif);
 			_rtl865x_print_freeChainNum();
-			
+
 
 			memset(&rule,0,sizeof(rtl865x_AclRule_t));
 			rule.pktOpApp_ = RTL865X_ACL_L2_AND_L3;
 			rule.actionType_ = RTL865X_ACL_DROP;
 
 			printk("============add 1st acl===========\n");
-			rtl865x_add_acl(&rule, RTL_DRV_LAN_NETIF_NAME, -500);			
+			rtl865x_add_acl(&rule, RTL_DRV_LAN_NETIF_NAME, -500);
 			printk("now the information of netif(%s) is:\n\n",netif->name);
 			_rtl865x_print_allChain_allAcl(netif);
 			_rtl865x_print_freeChainNum();
@@ -3802,14 +3992,14 @@ int32 rtl865x_acl_test(int32 testNo)
 			printk("now the information of netif(%s) is:\n\n",netif->name);
 			_rtl865x_print_allChain_allAcl(netif);
 			_rtl865x_print_freeChainNum();
-			
+
 
 			printk("flush all chain of br0");
 			_rtl865x_unRegister_all_aclChain(RTL_DRV_LAN_NETIF_NAME);
 			printk("now the information of netif(%s) is:\n\n",netif->name);
 			_rtl865x_print_allChain_allAcl(netif);
 			_rtl865x_print_freeChainNum();
-			
+
 		}
 		break;
 
@@ -3827,18 +4017,18 @@ int32 rtl865x_acl_test(int32 testNo)
 			printk("now the information of netif(%s) is:\n\n",netif->name);
 			_rtl865x_print_allChain_allAcl(netif);
 			_rtl865x_print_freeChainNum();
-			
+
 
 			memset(&rule,0,sizeof(rtl865x_AclRule_t));
 			rule.pktOpApp_ = RTL865X_ACL_L2_AND_L3;
 			rule.actionType_ = RTL865X_ACL_DROP;
 
 			printk("============add 1st acl===========\n");
-			rtl865x_add_acl(&rule, RTL_DRV_LAN_NETIF_NAME, -500);			
+			rtl865x_add_acl(&rule, RTL_DRV_LAN_NETIF_NAME, -500);
 			printk("now the information of netif(%s) is:\n\n",netif->name);
 			_rtl865x_print_allChain_allAcl(netif);
-			_rtl865x_print_freeChainNum();			
-			
+			_rtl865x_print_freeChainNum();
+
 		}
 		break;
 
@@ -3848,26 +4038,26 @@ int32 rtl865x_acl_test(int32 testNo)
 			rtl865x_acl_chain_t *chain = NULL;
 			rtl865x_netif_local_t *netif = NULL;
 			rtl865x_AclRule_t rule1;
-			
+
 			netif = _rtl865x_getNetifByName(RTL_DRV_LAN_NETIF_NAME);
 			chain = netif->chainListHead[RTL865X_ACL_INGRESS];
 
 			printk("now the information of netif(%s) is:\n\n",netif->name);
 			_rtl865x_print_allChain_allAcl(netif);
 			_rtl865x_print_freeChainNum();
-			
+
 
 			memset(&rule1,0,sizeof(rtl865x_AclRule_t));
 			rule1.pktOpApp_ = RTL865X_ACL_L3_AND_L4;
 			rule1.actionType_ = RTL865X_ACL_DROP;
 			rule1.ruleType_ = RTL865X_ACL_IP;
 
-			
-			rtl865x_add_acl(&rule1, RTL_DRV_LAN_NETIF_NAME, -500);			
+
+			rtl865x_add_acl(&rule1, RTL_DRV_LAN_NETIF_NAME, -500);
 			printk("now the information of netif(%s) is:\n\n",netif->name);
 			_rtl865x_print_allChain_allAcl(netif);
-			_rtl865x_print_freeChainNum();			
-			
+			_rtl865x_print_freeChainNum();
+
 		}
 		break;
 
@@ -3886,16 +4076,16 @@ int32 rtl865x_acl_test(int32 testNo)
 		case 5:
 		{
 			rtl865x_AclRule_t rule;
-			union 
+			union
 			{
 				char pat[4];
 				uint32 pattern;
-			}u;			
+			}u;
 			int32 i;
 
-			
+
 			printk("for url filter test....");
-			memset(&rule,0,sizeof(rtl865x_AclRule_t));			
+			memset(&rule,0,sizeof(rtl865x_AclRule_t));
 			rule.actionType_ = RTL865X_ACL_TOCPU;
 			rule.ruleType_ = RTL865X_ACL_IP;
 			rule.ipHttpFilter_=rule.ipHttpFilterM_=1;
@@ -3906,7 +4096,7 @@ int32 rtl865x_acl_test(int32 testNo)
 			rule.actionType_ = RTL865X_ACL_PERMIT;
 			rule.pktOpApp_ = RTL865X_ACL_ALL_LAYER;
 			rtl865x_add_acl(&rule, RTL_DRV_LAN_NETIF_NAME, -10000);
-			
+
 			u.pat[0]='T';
 			u.pat[1]='T';
 			u.pat[2]='P';
@@ -3916,7 +4106,7 @@ int32 rtl865x_acl_test(int32 testNo)
 				if(rtl8651_setAsicPortPatternMatch(i, u.pattern, 0xffffffff, 0x2 /* fwd to CPU */)!=SUCCESS)
 					return FAILED;
 			}
-			
+
 		}
 		break;
 
@@ -3926,12 +4116,12 @@ int32 rtl865x_acl_test(int32 testNo)
 			int32 i;
 			for(i = 0; i < NETIF_NUMBER; i++)
 			{
-				printk("i(%d),netifTbl(0x%p),name(%s)\n",i,&netifTbl[i],netifTbl[i].name);				
-			}			
+				printk("i(%d),netifTbl(0x%p),name(%s)\n",i,&netifTbl[i],netifTbl[i].name);
+			}
 		}
 		break;
 
-					
+
 	}
 	return retval;
 }
@@ -3944,15 +4134,15 @@ int rtl865x_show_all_netif(void)
 {
 	int32 i;
 	rtl865x_netif_local_t *netif = NULL;
-	
+
 	for(i = 0; i < NETIF_NUMBER; i++)
-	{		
+	{
 		if(netifTbl[i].valid == 1 )
 		{
 			netif = &netifTbl[i];
 			printk("idx(%d),valid(%d),name(%s),vid(%d),is_slave(%d),type(%d)\n",i,netif->valid,netif->name,netif->vid,netif->is_slave,netif->if_type);
 		}
-	}	
+	}
 
 	return SUCCESS;
 }
@@ -3963,7 +4153,7 @@ int32 rtl865x_getNetifFid(char *name,  uint16 *fid)
 {
 	rtl865x_netif_local_t *entry;
 	rtl865x_vlan_entry_t *vlan;
-	
+
 	if(name == NULL)
 	{
 		return FAILED;
@@ -3979,7 +4169,7 @@ int32 rtl865x_getNetifFid(char *name,  uint16 *fid)
 	vlan = _rtl8651_getVlanTableEntry(entry->vid);
 	*fid = vlan->fid;
 	return SUCCESS;
-	
+
 }
 #endif
 extern int rtk_vlan_support_enable;
@@ -3988,7 +4178,7 @@ int32 rtl865x_reConfigDefaultAcl(char *ifName)
 	rtl865x_AclRule_t	rule;
 	int ret=FAILED;
 
-	unsigned long flags;	
+	unsigned long flags;
 	local_irq_save(flags);
 
 #if defined (CONFIG_RTK_VLAN_SUPPORT)
@@ -4000,13 +4190,13 @@ int32 rtl865x_reConfigDefaultAcl(char *ifName)
 			rule.pktOpApp_ = RTL865X_ACL_ALL_LAYER;
 			rule.actionType_ = RTL865X_ACL_PERMIT;
 			ret=_rtl865x_del_acl(&rule, ifName, RTL865X_ACL_SYSTEM_USED);
-			
+
 			/*add new default permit acl*/
 			bzero((void*)&rule,sizeof(rtl865x_AclRule_t));
 			rule.ruleType_ = RTL865X_ACL_MAC;
 			rule.pktOpApp_ = RTL865X_ACL_ALL_LAYER;
 			rule.actionType_ = RTL865X_ACL_PERMIT;
-			ret=_rtl865x_add_acl(&rule, ifName, RTL865X_ACL_SYSTEM_USED); 
+			ret=_rtl865x_add_acl(&rule, ifName, RTL865X_ACL_SYSTEM_USED);
 		}
 		else
 		{
@@ -4016,13 +4206,13 @@ int32 rtl865x_reConfigDefaultAcl(char *ifName)
 			rule.pktOpApp_ = RTL865X_ACL_ALL_LAYER;
 			rule.actionType_ = RTL865X_ACL_TOCPU;
 			ret=_rtl865x_del_acl(&rule, ifName, RTL865X_ACL_SYSTEM_USED);
-			
+
 			/*add new default to cpu acl*/
 			bzero((void*)&rule,sizeof(rtl865x_AclRule_t));
 			rule.ruleType_ = RTL865X_ACL_MAC;
 			rule.pktOpApp_ = RTL865X_ACL_ALL_LAYER;
 			rule.actionType_ = RTL865X_ACL_TOCPU;
-			ret=_rtl865x_add_acl(&rule, ifName, RTL865X_ACL_SYSTEM_USED); 
+			ret=_rtl865x_add_acl(&rule, ifName, RTL865X_ACL_SYSTEM_USED);
 		}
 #else
 		{
@@ -4032,15 +4222,15 @@ int32 rtl865x_reConfigDefaultAcl(char *ifName)
 			rule.pktOpApp_ = RTL865X_ACL_ALL_LAYER;
 			rule.actionType_ = RTL865X_ACL_PERMIT;
 			ret=_rtl865x_del_acl(&rule, ifName, RTL865X_ACL_SYSTEM_USED);
-			
+
 			/*add new default permit acl*/
 			bzero((void*)&rule,sizeof(rtl865x_AclRule_t));
 			rule.ruleType_ = RTL865X_ACL_MAC;
 			rule.pktOpApp_ = RTL865X_ACL_ALL_LAYER;
 			rule.actionType_ = RTL865X_ACL_PERMIT;
-			ret=_rtl865x_add_acl(&rule, ifName, RTL865X_ACL_SYSTEM_USED); 
+			ret=_rtl865x_add_acl(&rule, ifName, RTL865X_ACL_SYSTEM_USED);
 		}
-#endif			
+#endif
 		local_irq_restore(flags);
 
 		return SUCCESS;
diff --git a/drivers/net/rtl819x/common/rtl865x_vlan.c b/drivers/net/rtl819x/common/rtl865x_vlan.c
index d55b592..34bca35 100644
--- a/drivers/net/rtl819x/common/rtl865x_vlan.c
+++ b/drivers/net/rtl819x/common/rtl865x_vlan.c
@@ -1,532 +1,516 @@
-/*
-* Copyright c                  Realtek Semiconductor Corporation, 2008  
-* All rights reserved.
-* 
-* Program : Vlan driver
-* Abstract : 
-* Author : hyking (hyking_liu@realsil.com.cn)  
-*/
-
-/*      @doc RTL_LAYEREDDRV_API
-
-        @module rtl865x_vlan.c - RTL865x Home gateway controller Layered driver API documentation       |
-        This document explains the API interface of the table driver module. Functions with rtl865x prefix
-        are external functions.
-        @normal Hyking Liu (Hyking_liu@realsil.com.cn) <date>
-
-        Copyright <cp>2008 Realtek<tm> Semiconductor Cooperation, All Rights Reserved.
-
-        @head3 List of Symbols |
-        Here is a list of all functions and variables in this module.
-        
-        @index | RTL_LAYEREDDRV_API
-*/
-
-#include <net/rtl/rtl_types.h>
-#include <net/rtl/rtl_glue.h>
-#include "rtl_errno.h"
-//#include "rtl_utils.h"
-//#include "rtl_glue.h"
-#include "rtl865x_vlan.h"
-#ifdef CONFIG_RTL_LAYERED_ASIC_DRIVER
-#include "AsicDriver/rtl865x_asicCom.h"
-#else
-#include "AsicDriver/rtl865xC_tblAsicDrv.h"
-#endif
-#include "rtl865x_eventMgr.h"
-
-
-static rtl865x_vlan_entry_t *vlanTbl = NULL;
-
-static RTL_DECLARE_MUTEX(vlan_sem);
-
-static int32 _rtl865x_delVlan(uint16 vid);
-
-static int32 _rtl865x_setAsicVlan(uint16 vid,rtl865x_vlan_entry_t *vlanEntry)
-{
-	int32 retval = FAILED;
-	rtl865x_tblAsicDrv_vlanParam_t asicEntry;
-	/*add this entry to asic table*/
-	asicEntry.fid = vlanEntry->fid;
-	asicEntry.memberPortMask = vlanEntry->memberPortMask;
-	asicEntry.untagPortMask = vlanEntry->untagPortMask;
-	retval = rtl8651_setAsicVlan(vid,&asicEntry);
-	return retval;
-}
-
-
-static int32 _rtl865x_referVlan(uint16 vid)
-{
-	rtl865x_vlan_entry_t *entry;
-	/* vid should be legal vlan ID */
-	if(vid < 1 || vid > VLAN_NUMBER-1)
-		return RTL_EINVALIDVLANID;
-
-	entry = &vlanTbl[vid];
-	if(entry->valid != 1)
-		return RTL_EINVALIDVLANID;
-
-	entry->refCnt++;
-	return SUCCESS;
-}
-
-static int32 _rtl865x_deReferVlan(uint16 vid)
-{
-	rtl865x_vlan_entry_t *entry;
-	/* vid should be legal vlan ID */
-	if(vid < 1 || vid > VLAN_NUMBER-1)
-		return RTL_EINVALIDVLANID;
-
-	entry = &vlanTbl[vid];
-	if(entry->valid != 1)
-		return RTL_EINVALIDVLANID;
-
-	entry->refCnt--;
-	return SUCCESS;
-}
-
-int32 _rtl865x_addVlan(uint16 vid)
-{
-	int32 retval = FAILED;
-	rtl865x_vlan_entry_t *entry;
-	entry=&vlanTbl[vid];
-	
-	if(1 == entry->valid)
-		return RTL_EVLANALREADYEXISTS;
-
-	/*add new vlan entry*/
-	memset(entry,0,sizeof(rtl865x_vlan_entry_t));
-	entry->vid = vid;
-	entry->valid = 1;
-	entry->refCnt = 1;
-
-	/*add this entry to asic table*/
-	retval = _rtl865x_setAsicVlan(vid,entry);	
-	
-	return retval;
-}
-
-
-static int32 _rtl865x_delVlan(uint16 vid)
-{
-	int32 retval = FAILED;
-	rtl865x_vlan_entry_t *vlanEntry,org;
-	vlanEntry=&vlanTbl[vid];
-	if(0 == vlanEntry->valid)
-		return RTL_EINVALIDVLANID;
-	/*
-	if(vlanEntry->refCnt > 1)
-	{
-		printk("vid(%d),reference(%d)\n",vid,vlanEntry->refCnt);
-		return RTL_EREFERENCEDBYOTHER;
-	}
-	*/
-
-	memcpy(&org,vlanEntry,sizeof(rtl865x_vlan_entry_t));
-	
-	/*delete vlan entry*/
-	vlanEntry->valid =  0;
-	/*ignor other member...*/
-
-	retval = rtl8651_delAsicVlan(vid);
-
-	if(SUCCESS == retval)
-	{
-		/*if vlan entry is deleted, this information should be noticed by uplayer module*/
-		#if 0
-		do_eventAction(EV_DEL_VLAN, (void *)&org);
-		#else
-		rtl865x_raiseEvent(EVENT_DEL_VLAN, (void *)&org);
-		#endif
-	}
-	
-	return retval;
-}
-
-static int32 _rtl865x_addVlanPortMember(uint16 vid, uint32 portMask)
-{
-	int32 retval = FAILED;
-	rtl865x_vlan_entry_t *vlanEntry;
-	
-	vlanEntry = &vlanTbl[vid];
-	if(vlanEntry->valid == 0)
-		return RTL_EINVALIDVLANID;
-
-	/*add member port*/
-	vlanEntry->memberPortMask |= portMask;
-	vlanEntry->untagPortMask |= portMask;
-
-	/*update this entry to asic table*/
-	retval = _rtl865x_setAsicVlan(vid,vlanEntry);
-
-	return retval;
-	
-	
-}
-
-
-static int32 _rtl865x_delVlanPortMember(uint16 vid, uint32 portMask)
-{
-	int32 retval = FAILED;
-	rtl865x_vlan_entry_t *vlanEntry;
-	//rtl865x_tblAsicDrv_vlanParam_t asicEntry;
-	
-	vlanEntry = &vlanTbl[vid];
-	if(vlanEntry->valid == 0)
-		return RTL_EINVALIDVLANID;
-
-	/*add member port*/
-	vlanEntry->memberPortMask &= ~portMask;
-	vlanEntry->untagPortMask &=~portMask;
-
-	if(vlanEntry->memberPortMask == 0)
-		vlanEntry->valid = 0;
-
-	/*update this entry to asic table*/
-	retval = _rtl865x_setAsicVlan(vid,vlanEntry);
-
-	return retval;
-	
-	
-}
-
-
-static int32 _rtl865x_setVlanPortTag(uint16 vid, uint32 portMask, uint8 tag)
-{
-	int32 retval = FAILED;
-	rtl865x_vlan_entry_t *vlanEntry;
-	
-	vlanEntry = &vlanTbl[vid];
-	if(vlanEntry->valid == 0)
-		return RTL_EINVALIDVLANID;
-
-	if(tag == 0)
-		vlanEntry->untagPortMask |= vlanEntry->memberPortMask & portMask;
-	else
-		vlanEntry->untagPortMask &=~(vlanEntry->memberPortMask & portMask);
-
-	/*update this entry to asic table*/
-	retval = _rtl865x_setAsicVlan(vid,vlanEntry);
-
-	return retval;
-	
-}
-
-static int32 _rtl865x_setVlanFID(uint16 vid, uint32 fid)
-{
-	int32 retval = FAILED;
-	rtl865x_vlan_entry_t *vlanEntry;
-
-	if(fid >= RTL865X_FDB_NUMBER)
-		return RTL_EINVALIDFID;
-	
-	vlanEntry = &vlanTbl[vid];
-	if(vlanEntry->valid == 0)
-		return RTL_EINVALIDVLANID;
-
-	vlanEntry->fid = fid;		
-
-	/*update this entry to asic table*/
-	retval = _rtl865x_setAsicVlan(vid,vlanEntry);
-
-	return retval;
-}
-
-
-static int32 _rtl865x_getVlanFilterDatabaseId(uint16 vid, uint32 *fid)
-{
-	int32 retval = 0;
-	
-	if(vid < 1 || vid > VLAN_NUMBER -1)
-		return RTL_EINVALIDVLANID;
-	
-	if(vlanTbl[vid].valid == 1)
-	{
-		*fid = vlanTbl[vid].fid;
-		retval = SUCCESS;
-	}
-	else
-	{
-		printk("%s(%d):the vlan is invalid!!!BUG!!!!\n",__FUNCTION__,__LINE__);
-		retval = FAILED;
-	}
-
-	return retval;
-	
-}
-rtl865x_vlan_entry_t *_rtl8651_getVlanTableEntry(uint16 vid)
-{
-	if(vlanTbl[vid].valid == 1)
-		return &vlanTbl[vid];
-	return NULL;
-}
-
-/*
-@func int32 | rtl865x_referVlan | reference a VLAN entry.
-@parm uint16 | vid | VLAN ID.
-@rvalue SUCCESS | Success.
-@rvalue RTL_EINVALIDVLANID | Invalid VLAN ID.
-@comm
-if a vlan entry is referenced, please call this API.
-*/
-int32 rtl865x_referVlan(uint16 vid)
-{
-	int32 retval = FAILED;
-	unsigned long flags;
-	//rtl_down_interruptible(&vlan_sem);
-	local_irq_save(flags);
-	retval = _rtl865x_referVlan(vid);
-	//rtl_up(&vlan_sem);
-	local_irq_restore(flags);
-	return retval;
-}
-
-/*
-@func int32 | rtl865x_deReferVlan | dereference a VLAN entry.
-@parm uint16 | vid | VLAN ID.
-@rvalue SUCCESS | Success.
-@rvalue RTL_EINVALIDVLANID | Invalid VLAN ID.
-@comm
-if a vlan entry is dereferenced, please call this API.
-NOTE: rtl865x_deReferVlan should be called after rtl865x_referVlan.
-*/
-int32 rtl865x_deReferVlan(uint16 vid)
-{
-	int32 retval = FAILED;
-	unsigned long flags;	
-	//rtl_down_interruptible(&vlan_sem);
-	local_irq_save(flags);
-	retval = _rtl865x_deReferVlan(vid);
-	//rtl_up(&vlan_sem);
-	local_irq_restore(flags);
-	return retval;
-}
-
-/*
-@func int32 | rtl865x_addVlan | Add a VLAN.
-@parm uint16 | vid | VLAN ID.
-@rvalue SUCCESS | Success.
-@rvalue RTL_EINVALIDVLANID | Invalid VLAN ID.
-@rvalue RTL_EVLANALREADYEXISTS | Vlan already exists.
-*/
-int32 rtl865x_addVlan(uint16 vid)
-{
-	int32 retval = FAILED;
-	unsigned long flags;
-	/* vid should be legal vlan ID */
-	if(vid < 1 || vid > VLAN_NUMBER-1)
-		return RTL_EINVALIDVLANID;
-
-	//rtl_down_interruptible(&vlan_sem);
-	local_irq_save(flags);
-	retval = _rtl865x_addVlan(vid);
-	//rtl_up(&vlan_sem);
-	local_irq_restore(flags);
-	return retval;
-		
-}
-
-/*
-@func int32 | rtl865x_delVlan | Delete a VLAN.
-@parm uint16 | vid | VLAN ID.
-@rvalue SUCCESS | Success.
-@rvalue RTL_EINVALIDVLANID | Invalid VLAN ID.
-@rvalue RTL_EREFERENCEDBYOTHER | the Vlan is referenced by other,please delete releated table entry first.
-*/
-int32 rtl865x_delVlan(uint16 vid)
-{
-	int32 retval = FAILED;
-	unsigned long flags;	
-	/* vid should be legal vlan ID */
-	if(vid < 1 || vid > VLAN_NUMBER -1)
-		return RTL_EINVALIDVLANID;
-	
-	//rtl_down_interruptible(&vlan_sem);
-	local_irq_save(flags);
-	retval = _rtl865x_delVlan(vid);	
-	//rtl_up(&vlan_sem);
-	local_irq_restore(flags);
-	return retval;
-}
-
-/*
-@func int32 | rtl865x_addVlanPortMember | configure vlan member port
-@parm uint16 | vid | VLAN ID.
-@parm uint32 | portMask | Port mask.
-@rvalue SUCCESS | Success.
-@rvalue RTL_EINVALIDVLANID | Invalid VLAN ID.
-@comm
-the parm portMask is the MASK of port. bit0 mapping to physical port 0,bit1 mapping to physical port 1.
-*/
-int32 rtl865x_addVlanPortMember(uint16 vid, uint32 portMask)
-{
-	int32 retval = FAILED;
-	unsigned long flags;
-	/* vid should be legal vlan ID */
-	if(vid < 1 || vid > VLAN_NUMBER -1)
-		return RTL_EINVALIDVLANID;
-
-	//rtl_down_interruptible(&vlan_sem);
-	local_irq_save(flags);
-	retval = _rtl865x_addVlanPortMember(vid,portMask);	
-	//rtl_up(&vlan_sem);
-	local_irq_restore(flags);
-	return retval;
-}
-
-/*
-@func int32 | rtl865x_delVlanPortMember | delete vlan's member port
-@parm uint16 | vid | VLAN ID.
-@parm uint32 | portMask | Port mask.
-@rvalue SUCCESS | Success.
-@rvalue RTL_EINVALIDVLANID | Invalid VLAN ID.
-@comm
-the parm portMask is the MASK of port. bit0 mapping to physical port 0,bit1 mapping to physical port 1.
-*/
-int32 rtl865x_delVlanPortMember(uint16 vid,uint32 portMask)
-{
-	int32 retval = FAILED;
-	unsigned long flags;
-	/* vid should be legal vlan ID */
-	if(vid < 1 || vid > VLAN_NUMBER -1)
-		return RTL_EINVALIDVLANID;
-	
-	//rtl_down_interruptible(&vlan_sem);
-	local_irq_save(flags);
-	retval = _rtl865x_delVlanPortMember(vid,portMask);	
-	//rtl_up(&vlan_sem);
-	local_irq_restore(flags);
-
-	return retval;
-	
-}
-
-
-/*
-@func uint32 | rtl865x_getVlanPortMask | get the member portMask of a vlan
-@parm uint16 | vid | VLAN ID.
-@comm
-if the retrun value is zero, it means vlan entry is invalid or no member port in this vlan.
-*/
-uint32 rtl865x_getVlanPortMask(uint32 vid)
-{
-	rtl865x_vlan_entry_t *vlanEntry;
-	
-	if((vid < 1) || (vid > VLAN_NUMBER -1))
-	{
-		return 0;
-	}
-	
-	vlanEntry = &vlanTbl[vid];
-
-	if(vlanEntry->valid == 0)
-	{
-		return 0;
-	}	
-	
-	return vlanEntry->memberPortMask;
-}
-
-
-/*
-@func int32 | rtl865x_setVlanPortTag | configure member port vlan tag attribute
-@parm uint16 | vid | VLAN ID.
-@parm uint32 | portMask | Port mask.
-@parm uint8 | portMask | vlantag or untag.
-@rvalue SUCCESS | Success.
-@rvalue RTL_EINVALIDVLANID | Invalid VLAN ID.
-@comm
-the parm portMask is the MASK of port. bit0 mapping to physical port 0,bit1 mapping to physical port 1.
-parm tag is used to indicated physical port is vlantag or untag. value 1 means vlan tagged, and vlan 0 means vlan untagged.
-*/
-int32 rtl865x_setVlanPortTag(uint16 vid,uint32 portMask,uint8 tag)
-{
-	int32 retval = FAILED;
-	unsigned long flags;	
-	/* vid should be legal vlan ID */
-	if(vid < 1 || vid > VLAN_NUMBER -1)
-		return RTL_EINVALIDVLANID;
-	
-	//rtl_down_interruptible(&vlan_sem);
-	local_irq_save(flags);
-	retval = _rtl865x_setVlanPortTag(vid,portMask,tag);	
-	//rtl_up(&vlan_sem);
-	local_irq_restore(flags);
-	return retval;
-}
-
-/*
-@func int32 | rtl865x_setVlanFilterDatabase | configure the filter database for a vlan.
-@parm uint16 | vid | VLAN ID.
-@parm uint32 | fid | filter data base ID.
-@rvalue SUCCESS | Success.
-@rvalue RTL_EINVALIDVLANID | Invalid VLAN ID.
-@rvalue RTL_EINVALIDFID | Invalid filter database ID.
-@comm
-in realtek 865x, 4 filter databases are support.
-if you want to configure SVL for all vlan, please set the fid of vlan is same.
-default configure is SVL.
-*/
-int32 rtl865x_setVlanFilterDatabase(uint16 vid, uint32 fid)
-{
-	int32 retval = FAILED;
-	unsigned long flags;
-	/* vid should be legal vlan ID */
-	if(vid < 1 || vid > VLAN_NUMBER -1)
-		return RTL_EINVALIDVLANID;
-	
-	//rtl_down_interruptible(&vlan_sem);//Lock resource
-	local_irq_save(flags);
-	retval = _rtl865x_setVlanFID(vid,fid);	
-	//rtl_up(&vlan_sem);
-	local_irq_restore(flags);
-
-	return retval;	
-}
-
-/*
-@func int32 | rtl865x_getVlanFilterDatabaseId | get the vlan's filter database ID.
-@parm uint16 | vid | VLAN ID.
-@parm uint32 | fid | filter data base ID.
-@rvalue SUCCESS | Success.
-@rvalue RTL_EINVALIDVLANID | Invalid VLAN ID.
-@comm
-*/
-int32 rtl865x_getVlanFilterDatabaseId(uint16 vid, uint32 *fid)
-{
-	int32 retval = FAILED;
-	retval = _rtl865x_getVlanFilterDatabaseId(vid, fid);
-
-	return retval;
-}
-
-/*
-@func int32 | rtl865x_initVlanTable | initialize vlan table.
-@rvalue SUCCESS | Success.
-@rvalue FAILED | Failed,system should be reboot.
-*/
-int32 rtl865x_initVlanTable(void)
-{	
-	TBL_MEM_ALLOC(vlanTbl, rtl865x_vlan_entry_t, VLAN_NUMBER);	
-	memset(vlanTbl,0,sizeof(rtl865x_vlan_entry_t)*VLAN_NUMBER);
-
-	return SUCCESS;	
-}
-
-/*
-@func int32 | rtl865x_reinitVlantable | initialize vlan table.
-@rvalue SUCCESS | Success.
-*/
-int32 rtl865x_reinitVlantable(void)
-{
-	uint16 i;
-	for(i = 0; i < VLAN_NUMBER; i++)
-	{
-		if(vlanTbl[i].valid)
-		{
-			_rtl865x_delVlan(i);
-		}
-	}
-	return SUCCESS;
-}
-
+/*
+* Copyright c                  Realtek Semiconductor Corporation, 2008  
+* All rights reserved.
+* 
+* Program : Vlan driver
+* Abstract : 
+* Author : hyking (hyking_liu@realsil.com.cn)  
+*/
+#include <net/rtl/rtl_types.h>
+#include <net/rtl/rtl_glue.h>
+#include "rtl_errno.h"
+//#include "rtl_utils.h"
+//#include "rtl_glue.h"
+#include "rtl865x_vlan.h"
+#ifdef CONFIG_RTL_LAYERED_ASIC_DRIVER
+#include "AsicDriver/rtl865x_asicCom.h"
+#else
+#include "AsicDriver/rtl865xC_tblAsicDrv.h"
+#endif
+#include "rtl865x_eventMgr.h"
+
+
+static rtl865x_vlan_entry_t *vlanTbl = NULL;
+
+static RTL_DECLARE_MUTEX(vlan_sem);
+
+static int32 _rtl865x_delVlan(uint16 vid);
+
+static int32 _rtl865x_setAsicVlan(uint16 vid,rtl865x_vlan_entry_t *vlanEntry)
+{
+	int32 retval = FAILED;
+	rtl865x_tblAsicDrv_vlanParam_t asicEntry;
+	/*add this entry to asic table*/
+	asicEntry.fid = vlanEntry->fid;
+	asicEntry.memberPortMask = vlanEntry->memberPortMask;
+	asicEntry.untagPortMask = vlanEntry->untagPortMask;
+	retval = rtl8651_setAsicVlan(vid,&asicEntry);
+	return retval;
+}
+
+
+static int32 _rtl865x_referVlan(uint16 vid)
+{
+	rtl865x_vlan_entry_t *entry;
+	/* vid should be legal vlan ID */
+	if(vid < 1 || vid > VLAN_NUMBER-1)
+		return RTL_EINVALIDVLANID;
+
+	entry = &vlanTbl[vid];
+	if(entry->valid != 1)
+		return RTL_EINVALIDVLANID;
+
+	entry->refCnt++;
+	return SUCCESS;
+}
+
+static int32 _rtl865x_deReferVlan(uint16 vid)
+{
+	rtl865x_vlan_entry_t *entry;
+	/* vid should be legal vlan ID */
+	if(vid < 1 || vid > VLAN_NUMBER-1)
+		return RTL_EINVALIDVLANID;
+
+	entry = &vlanTbl[vid];
+	if(entry->valid != 1)
+		return RTL_EINVALIDVLANID;
+
+	entry->refCnt--;
+	return SUCCESS;
+}
+
+int32 _rtl865x_addVlan(uint16 vid)
+{
+	int32 retval = FAILED;
+	rtl865x_vlan_entry_t *entry;
+	entry=&vlanTbl[vid];
+	
+	if(1 == entry->valid)
+		return RTL_EVLANALREADYEXISTS;
+
+	/*add new vlan entry*/
+	memset(entry,0,sizeof(rtl865x_vlan_entry_t));
+	entry->vid = vid;
+	entry->valid = 1;
+	entry->refCnt = 1;
+
+	/*add this entry to asic table*/
+	retval = _rtl865x_setAsicVlan(vid,entry);	
+	
+	return retval;
+}
+
+
+static int32 _rtl865x_delVlan(uint16 vid)
+{
+	int32 retval = FAILED;
+	rtl865x_vlan_entry_t *vlanEntry,org;
+	vlanEntry=&vlanTbl[vid];
+	if(0 == vlanEntry->valid)
+		return RTL_EINVALIDVLANID;
+	/*
+	if(vlanEntry->refCnt > 1)
+	{
+		printk("vid(%d),reference(%d)\n",vid,vlanEntry->refCnt);
+		return RTL_EREFERENCEDBYOTHER;
+	}
+	*/
+
+	memcpy(&org,vlanEntry,sizeof(rtl865x_vlan_entry_t));
+	
+	/*delete vlan entry*/
+	vlanEntry->valid =  0;
+	/*ignor other member...*/
+
+	retval = rtl8651_delAsicVlan(vid);
+
+	if(SUCCESS == retval)
+	{
+		/*if vlan entry is deleted, this information should be noticed by uplayer module*/
+		#if 0
+		do_eventAction(EV_DEL_VLAN, (void *)&org);
+		#else
+		rtl865x_raiseEvent(EVENT_DEL_VLAN, (void *)&org);
+		#endif
+	}
+	
+	return retval;
+}
+
+static int32 _rtl865x_addVlanPortMember(uint16 vid, uint32 portMask)
+{
+	int32 retval = FAILED;
+	rtl865x_vlan_entry_t *vlanEntry;
+	
+	vlanEntry = &vlanTbl[vid];
+	if(vlanEntry->valid == 0)
+		return RTL_EINVALIDVLANID;
+
+	/*add member port*/
+	vlanEntry->memberPortMask |= portMask;
+	vlanEntry->untagPortMask |= portMask;
+
+	/*update this entry to asic table*/
+	retval = _rtl865x_setAsicVlan(vid,vlanEntry);
+
+	return retval;
+	
+	
+}
+
+
+static int32 _rtl865x_delVlanPortMember(uint16 vid, uint32 portMask)
+{
+	int32 retval = FAILED;
+	rtl865x_vlan_entry_t *vlanEntry;
+	//rtl865x_tblAsicDrv_vlanParam_t asicEntry;
+	
+	vlanEntry = &vlanTbl[vid];
+	if(vlanEntry->valid == 0)
+		return RTL_EINVALIDVLANID;
+
+	/*add member port*/
+	vlanEntry->memberPortMask &= ~portMask;
+	vlanEntry->untagPortMask &=~portMask;
+
+	if(vlanEntry->memberPortMask == 0)
+		vlanEntry->valid = 0;
+
+	/*update this entry to asic table*/
+	retval = _rtl865x_setAsicVlan(vid,vlanEntry);
+
+	return retval;
+	
+	
+}
+
+
+static int32 _rtl865x_setVlanPortTag(uint16 vid, uint32 portMask, uint8 tag)
+{
+	int32 retval = FAILED;
+	rtl865x_vlan_entry_t *vlanEntry;
+	
+	vlanEntry = &vlanTbl[vid];
+	if(vlanEntry->valid == 0)
+		return RTL_EINVALIDVLANID;
+
+	if(tag == 0)
+		vlanEntry->untagPortMask |= vlanEntry->memberPortMask & portMask;
+	else
+		vlanEntry->untagPortMask &=~(vlanEntry->memberPortMask & portMask);
+
+	/*update this entry to asic table*/
+	retval = _rtl865x_setAsicVlan(vid,vlanEntry);
+
+	return retval;
+	
+}
+
+static int32 _rtl865x_setVlanFID(uint16 vid, uint32 fid)
+{
+	int32 retval = FAILED;
+	rtl865x_vlan_entry_t *vlanEntry;
+
+	if(fid >= RTL865X_FDB_NUMBER)
+		return RTL_EINVALIDFID;
+	
+	vlanEntry = &vlanTbl[vid];
+	if(vlanEntry->valid == 0)
+		return RTL_EINVALIDVLANID;
+
+	vlanEntry->fid = fid;		
+
+	/*update this entry to asic table*/
+	retval = _rtl865x_setAsicVlan(vid,vlanEntry);
+
+	return retval;
+}
+
+
+static int32 _rtl865x_getVlanFilterDatabaseId(uint16 vid, uint32 *fid)
+{
+	int32 retval = 0;
+	
+	if(vid < 1 || vid > VLAN_NUMBER -1)
+		return RTL_EINVALIDVLANID;
+	
+	if(vlanTbl[vid].valid == 1)
+	{
+		*fid = vlanTbl[vid].fid;
+		retval = SUCCESS;
+	}
+	else
+	{
+		printk("%s(%d):the vlan is invalid!!!BUG!!!!\n",__FUNCTION__,__LINE__);
+		retval = FAILED;
+	}
+
+	return retval;
+	
+}
+rtl865x_vlan_entry_t *_rtl8651_getVlanTableEntry(uint16 vid)
+{
+	if(vlanTbl[vid].valid == 1)
+		return &vlanTbl[vid];
+	return NULL;
+}
+
+/*
+@func int32 | rtl865x_referVlan | reference a VLAN entry.
+@parm uint16 | vid | VLAN ID.
+@rvalue SUCCESS | Success.
+@rvalue RTL_EINVALIDVLANID | Invalid VLAN ID.
+@comm
+if a vlan entry is referenced, please call this API.
+*/
+int32 rtl865x_referVlan(uint16 vid)
+{
+	int32 retval = FAILED;
+	unsigned long flags;
+	//rtl_down_interruptible(&vlan_sem);
+	local_irq_save(flags);
+	retval = _rtl865x_referVlan(vid);
+	//rtl_up(&vlan_sem);
+	local_irq_restore(flags);
+	return retval;
+}
+
+/*
+@func int32 | rtl865x_deReferVlan | dereference a VLAN entry.
+@parm uint16 | vid | VLAN ID.
+@rvalue SUCCESS | Success.
+@rvalue RTL_EINVALIDVLANID | Invalid VLAN ID.
+@comm
+if a vlan entry is dereferenced, please call this API.
+NOTE: rtl865x_deReferVlan should be called after rtl865x_referVlan.
+*/
+int32 rtl865x_deReferVlan(uint16 vid)
+{
+	int32 retval = FAILED;
+	unsigned long flags;	
+	//rtl_down_interruptible(&vlan_sem);
+	local_irq_save(flags);
+	retval = _rtl865x_deReferVlan(vid);
+	//rtl_up(&vlan_sem);
+	local_irq_restore(flags);
+	return retval;
+}
+
+/*
+@func int32 | rtl865x_addVlan | Add a VLAN.
+@parm uint16 | vid | VLAN ID.
+@rvalue SUCCESS | Success.
+@rvalue RTL_EINVALIDVLANID | Invalid VLAN ID.
+@rvalue RTL_EVLANALREADYEXISTS | Vlan already exists.
+*/
+int32 rtl865x_addVlan(uint16 vid)
+{
+	int32 retval = FAILED;
+	unsigned long flags;
+	/* vid should be legal vlan ID */
+	if(vid < 1 || vid > VLAN_NUMBER-1)
+		return RTL_EINVALIDVLANID;
+
+	//rtl_down_interruptible(&vlan_sem);
+	local_irq_save(flags);
+	retval = _rtl865x_addVlan(vid);
+	//rtl_up(&vlan_sem);
+	local_irq_restore(flags);
+	return retval;
+		
+}
+
+/*
+@func int32 | rtl865x_delVlan | Delete a VLAN.
+@parm uint16 | vid | VLAN ID.
+@rvalue SUCCESS | Success.
+@rvalue RTL_EINVALIDVLANID | Invalid VLAN ID.
+@rvalue RTL_EREFERENCEDBYOTHER | the Vlan is referenced by other,please delete releated table entry first.
+*/
+int32 rtl865x_delVlan(uint16 vid)
+{
+	int32 retval = FAILED;
+	unsigned long flags;	
+	/* vid should be legal vlan ID */
+	if(vid < 1 || vid > VLAN_NUMBER -1)
+		return RTL_EINVALIDVLANID;
+	
+	//rtl_down_interruptible(&vlan_sem);
+	local_irq_save(flags);
+	retval = _rtl865x_delVlan(vid);	
+	//rtl_up(&vlan_sem);
+	local_irq_restore(flags);
+	return retval;
+}
+
+/*
+@func int32 | rtl865x_addVlanPortMember | configure vlan member port
+@parm uint16 | vid | VLAN ID.
+@parm uint32 | portMask | Port mask.
+@rvalue SUCCESS | Success.
+@rvalue RTL_EINVALIDVLANID | Invalid VLAN ID.
+@comm
+the parm portMask is the MASK of port. bit0 mapping to physical port 0,bit1 mapping to physical port 1.
+*/
+int32 rtl865x_addVlanPortMember(uint16 vid, uint32 portMask)
+{
+	int32 retval = FAILED;
+	unsigned long flags;
+	/* vid should be legal vlan ID */
+	if(vid < 1 || vid > VLAN_NUMBER -1)
+		return RTL_EINVALIDVLANID;
+
+	//rtl_down_interruptible(&vlan_sem);
+	local_irq_save(flags);
+	retval = _rtl865x_addVlanPortMember(vid,portMask);	
+	//rtl_up(&vlan_sem);
+	local_irq_restore(flags);
+	return retval;
+}
+
+/*
+@func int32 | rtl865x_delVlanPortMember | delete vlan's member port
+@parm uint16 | vid | VLAN ID.
+@parm uint32 | portMask | Port mask.
+@rvalue SUCCESS | Success.
+@rvalue RTL_EINVALIDVLANID | Invalid VLAN ID.
+@comm
+the parm portMask is the MASK of port. bit0 mapping to physical port 0,bit1 mapping to physical port 1.
+*/
+int32 rtl865x_delVlanPortMember(uint16 vid,uint32 portMask)
+{
+	int32 retval = FAILED;
+	unsigned long flags;
+	/* vid should be legal vlan ID */
+	if(vid < 1 || vid > VLAN_NUMBER -1)
+		return RTL_EINVALIDVLANID;
+	
+	//rtl_down_interruptible(&vlan_sem);
+	local_irq_save(flags);
+	retval = _rtl865x_delVlanPortMember(vid,portMask);	
+	//rtl_up(&vlan_sem);
+	local_irq_restore(flags);
+
+	return retval;
+	
+}
+
+
+/*
+@func uint32 | rtl865x_getVlanPortMask | get the member portMask of a vlan
+@parm uint16 | vid | VLAN ID.
+@comm
+if the retrun value is zero, it means vlan entry is invalid or no member port in this vlan.
+*/
+uint32 rtl865x_getVlanPortMask(uint32 vid)
+{
+	rtl865x_vlan_entry_t *vlanEntry;
+	
+	if((vid < 1) || (vid > VLAN_NUMBER -1))
+	{
+		return 0;
+	}
+	
+	vlanEntry = &vlanTbl[vid];
+
+	if(vlanEntry->valid == 0)
+	{
+		return 0;
+	}	
+	
+	return vlanEntry->memberPortMask;
+}
+
+
+/*
+@func int32 | rtl865x_setVlanPortTag | configure member port vlan tag attribute
+@parm uint16 | vid | VLAN ID.
+@parm uint32 | portMask | Port mask.
+@parm uint8 | portMask | vlantag or untag.
+@rvalue SUCCESS | Success.
+@rvalue RTL_EINVALIDVLANID | Invalid VLAN ID.
+@comm
+the parm portMask is the MASK of port. bit0 mapping to physical port 0,bit1 mapping to physical port 1.
+parm tag is used to indicated physical port is vlantag or untag. value 1 means vlan tagged, and vlan 0 means vlan untagged.
+*/
+int32 rtl865x_setVlanPortTag(uint16 vid,uint32 portMask,uint8 tag)
+{
+	int32 retval = FAILED;
+	unsigned long flags;	
+	/* vid should be legal vlan ID */
+	if(vid < 1 || vid > VLAN_NUMBER -1)
+		return RTL_EINVALIDVLANID;
+	
+	//rtl_down_interruptible(&vlan_sem);
+	local_irq_save(flags);
+	retval = _rtl865x_setVlanPortTag(vid,portMask,tag);	
+	//rtl_up(&vlan_sem);
+	local_irq_restore(flags);
+	return retval;
+}
+
+/*
+@func int32 | rtl865x_setVlanFilterDatabase | configure the filter database for a vlan.
+@parm uint16 | vid | VLAN ID.
+@parm uint32 | fid | filter data base ID.
+@rvalue SUCCESS | Success.
+@rvalue RTL_EINVALIDVLANID | Invalid VLAN ID.
+@rvalue RTL_EINVALIDFID | Invalid filter database ID.
+@comm
+in realtek 865x, 4 filter databases are support.
+if you want to configure SVL for all vlan, please set the fid of vlan is same.
+default configure is SVL.
+*/
+int32 rtl865x_setVlanFilterDatabase(uint16 vid, uint32 fid)
+{
+	int32 retval = FAILED;
+	unsigned long flags;
+	/* vid should be legal vlan ID */
+	if(vid < 1 || vid > VLAN_NUMBER -1)
+		return RTL_EINVALIDVLANID;
+	
+	//rtl_down_interruptible(&vlan_sem);//Lock resource
+	local_irq_save(flags);
+	retval = _rtl865x_setVlanFID(vid,fid);	
+	//rtl_up(&vlan_sem);
+	local_irq_restore(flags);
+
+	return retval;	
+}
+
+/*
+@func int32 | rtl865x_getVlanFilterDatabaseId | get the vlan's filter database ID.
+@parm uint16 | vid | VLAN ID.
+@parm uint32 | fid | filter data base ID.
+@rvalue SUCCESS | Success.
+@rvalue RTL_EINVALIDVLANID | Invalid VLAN ID.
+@comm
+*/
+int32 rtl865x_getVlanFilterDatabaseId(uint16 vid, uint32 *fid)
+{
+	int32 retval = FAILED;
+	retval = _rtl865x_getVlanFilterDatabaseId(vid, fid);
+
+	return retval;
+}
+
+/*
+@func int32 | rtl865x_initVlanTable | initialize vlan table.
+@rvalue SUCCESS | Success.
+@rvalue FAILED | Failed,system should be reboot.
+*/
+int32 rtl865x_initVlanTable(void)
+{	
+	TBL_MEM_ALLOC(vlanTbl, rtl865x_vlan_entry_t, VLAN_NUMBER);	
+	memset(vlanTbl,0,sizeof(rtl865x_vlan_entry_t)*VLAN_NUMBER);
+
+	return SUCCESS;	
+}
+
+/*
+@func int32 | rtl865x_reinitVlantable | initialize vlan table.
+@rvalue SUCCESS | Success.
+*/
+int32 rtl865x_reinitVlantable(void)
+{
+	uint16 i;
+	for(i = 0; i < VLAN_NUMBER; i++)
+	{
+		if(vlanTbl[i].valid)
+		{
+			_rtl865x_delVlan(i);
+		}
+	}
+	return SUCCESS;
+}
+
diff --git a/drivers/net/rtl819x/common/rtl_utils.c b/drivers/net/rtl819x/common/rtl_utils.c
index 9e4610f..4ecf53e 100644
--- a/drivers/net/rtl819x/common/rtl_utils.c
+++ b/drivers/net/rtl819x/common/rtl_utils.c
@@ -130,8 +130,8 @@ void rtl8651_memcpy(void *dst,void*src,int32 len)
 	}
 #endif
 }
-
-#ifndef RTK_X86_CLE//RTK-CNSD2-NickWu-20061222: for x86 compile
+#if 1
+//#ifndef RTK_X86_CLE//RTK-CNSD2-NickWu-20061222: for x86 compile
 /*cfliu: This function is only for debugging. Should not be used in production code...*/
 void memDump (void *start, uint32 size, int8 * strHeader)
 {
@@ -170,15 +170,17 @@ void memDump (void *start, uint32 size, int8 * strHeader)
 		max = (index == row - 1) ? column : 16;
 		if ( max==0 ) break; /* If we need not dump this line, break it. */
 
-		rtlglue_printf ("\n%08x ", (memaddr) line);
+		rtlglue_printf ("\n%08x: ", (memaddr) line);
 		
 		//Hex
 		for (index2 = 0; index2 < max; index2++)
 		{
 			if (index2 == 8)
 			rtlglue_printf ("  ");
-			rtlglue_printf ("%02x ", (uint8) buf[index2]);
+			rtlglue_printf ("%02X", (uint8) buf[index2]);
 			ascii[index2] = ((uint8) buf[index2] < 32) ? empty : buf[index2];
+			if((index2+1)%4==0)
+				rtlglue_printf ("  ");
 		}
 
 		if (max != 16)
diff --git a/drivers/net/rtl819x/igmpsnooping/igmp_delete.c b/drivers/net/rtl819x/igmpsnooping/igmp_delete.c
index 2b3ec00..3e0cfdb 100644
--- a/drivers/net/rtl819x/igmpsnooping/igmp_delete.c
+++ b/drivers/net/rtl819x/igmpsnooping/igmp_delete.c
@@ -1,119 +1,127 @@
-
-#include <linux/module.h>	
-#include <linux/proc_fs.h>
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/sched.h>
-#include <linux/kernel.h>
-#include <linux/kernel_stat.h>
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/slab.h>
-#include <asm/uaccess.h>
-#include <linux/net.h>
-#include <linux/socket.h>
-
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/string.h>
-#include <net/ip.h>
-#include <net/protocol.h>
-#include <net/route.h>
-#include <net/sock.h>
-#include <net/arp.h>
-#include <net/raw.h>
-#include <net/checksum.h>
-#include <linux/netfilter.h>
-#include <linux/netfilter_ipv4.h>
-#include <linux/netlink.h>
-#include <linux/inetdevice.h>
-#include <linux/icmp.h>
-#include <net/udp.h>
-#include <net/tcp.h>
-
-#include <net/rtl/rtl_types.h>
-#ifdef CONFIG_NETFILTER
-#include <net/netfilter/nf_conntrack.h>
-#include <net/rtl/fastpath/fastpath_core.h>
-#endif
-#include <net/rtl/rtl865x_netif.h>
-#include <net/rtl/rtl_nic.h>
-
-
-struct sock *igmp_delete_sk = NULL;
-struct test_struct
-{
-	char data[30];
-};
-static int try_mac(const char *data, char array[],
-		      int array_size, char sep)
-{
-	uint32 i;
-
-	memset(array, 0, sizeof(array[0])*array_size);
-
-	/* Keep data pointing at next char. */
-	for (i = 0;  i < array_size; data++) {
-		if (*data >= '0' && *data <= '9') {
-			array[i] = array[i]*16 + *data - '0';
-		}
-		else if(*data >='a' && *data <='f') {
-			array[i] = array[i]*16 + *data - 'a'+10;
-		}
-		else if(*data >='A' && *data <='F') {
-			array[i] = array[i]*16 + *data - 'A'+10;
-		}
-		else if (*data == sep)
-			i++;
-		else {
-			/* Unexpected character; true if it's the
-			   terminator and we're finished. */
-			if (i == array_size - 1)
-				return 1;
-
-			printk("Char %u  '%c' unexpected\n",\
-				 i, *data);
-			return 0;
-		}
-	}
-	return 0;
-}
-
-extern int32 rtl_delIgmpRecordByMacAddr(uint8 *macAddr);
-void igmp_delete (struct sk_buff *__skb)
-{
-  	int pid;
-	struct test_struct send_data,recv_data;
-	uint8 mac[6];
-	char *ptr;
-	pid=rtk_nlrecvmsg(__skb,sizeof(struct test_struct),&recv_data);	
- 	//printk("igmp_delete data:%s\n", recv_data.data);
-	memset(mac, 0, 6);
-	ptr = recv_data.data;
-	if(try_mac(recv_data.data, mac, 6, ':'))
-	{
-		rtl_delIgmpRecordByMacAddr(mac);
-		//printk("filter mac: %02x:%02x:%02x:%02x:%02x:%02x\n", mac[0],mac[1],mac[2],mac[3],mac[4],mac[5]);
-    		sprintf(send_data.data,"clear igmp cache ok\n");
-	}
-	else
-	{
-		printk("clear igmp cache of bad format mac:%s\n", recv_data.data);
-    		sprintf(send_data.data,"please input like 00:23:e8:79:99:32\n");
-	}
-      	rtk_nlsendmsg(pid, igmp_delete_sk, sizeof(struct test_struct), &send_data);
-  	return;
-}
-
-int igmp_delete_init_netlink(void) 
-{
-  	igmp_delete_sk = netlink_kernel_create(&init_net, NETLINK_MULTICAST_DELETE, 0, igmp_delete, NULL, THIS_MODULE);
-
-  	if (!igmp_delete_sk) {
-    		printk(KERN_ERR "Netlink[Kernel] Cannot create netlink socket for igmp delete.\n");
-    		return -EIO;
-  	}	
-  	printk("Netlink[Kernel] create socket for igmp ok.\n");
-  	return 0;
-}
-
+/*
+ *
+ *  Copyright (c) 2011 Realtek Semiconductor Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>	
+#include <linux/proc_fs.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/kernel_stat.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <asm/uaccess.h>
+#include <linux/net.h>
+#include <linux/socket.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/string.h>
+#include <net/ip.h>
+#include <net/protocol.h>
+#include <net/route.h>
+#include <net/sock.h>
+#include <net/arp.h>
+#include <net/raw.h>
+#include <net/checksum.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter_ipv4.h>
+#include <linux/netlink.h>
+#include <linux/inetdevice.h>
+#include <linux/icmp.h>
+#include <net/udp.h>
+#include <net/tcp.h>
+
+#include <net/rtl/rtl_types.h>
+#ifdef CONFIG_NETFILTER
+#include <net/netfilter/nf_conntrack.h>
+#include <net/rtl/fastpath/fastpath_core.h>
+#endif
+#include <net/rtl/rtl865x_netif.h>
+#include <net/rtl/rtl_nic.h>
+
+
+struct sock *igmp_delete_sk = NULL;
+struct test_struct
+{
+	char data[30];
+};
+static int try_mac(const char *data, char array[],
+		      int array_size, char sep)
+{
+	uint32 i;
+
+	memset(array, 0, sizeof(array[0])*array_size);
+
+	/* Keep data pointing at next char. */
+	for (i = 0;  i < array_size; data++) {
+		if (*data >= '0' && *data <= '9') {
+			array[i] = array[i]*16 + *data - '0';
+		}
+		else if(*data >='a' && *data <='f') {
+			array[i] = array[i]*16 + *data - 'a'+10;
+		}
+		else if(*data >='A' && *data <='F') {
+			array[i] = array[i]*16 + *data - 'A'+10;
+		}
+		else if (*data == sep)
+			i++;
+		else {
+			/* Unexpected character; true if it's the
+			   terminator and we're finished. */
+			if (i == array_size - 1)
+				return 1;
+
+			printk("Char %u  '%c' unexpected\n",\
+				 i, *data);
+			return 0;
+		}
+	}
+	return 0;
+}
+
+extern int32 rtl_delIgmpRecordByMacAddr(uint8 *macAddr);
+void igmp_delete (struct sk_buff *__skb)
+{
+  	int pid;
+	struct test_struct send_data,recv_data;
+	uint8 mac[6];
+	char *ptr;
+	pid=rtk_nlrecvmsg(__skb,sizeof(struct test_struct),&recv_data);	
+ 	//printk("igmp_delete data:%s\n", recv_data.data);
+	memset(mac, 0, 6);
+	ptr = recv_data.data;
+	if(try_mac(recv_data.data, mac, 6, ':'))
+	{
+		rtl_delIgmpRecordByMacAddr(mac);
+		//printk("filter mac: %02x:%02x:%02x:%02x:%02x:%02x\n", mac[0],mac[1],mac[2],mac[3],mac[4],mac[5]);
+    		sprintf(send_data.data,"clear igmp cache ok\n");
+	}
+	else
+	{
+		printk("clear igmp cache of bad format mac:%s\n", recv_data.data);
+    		sprintf(send_data.data,"please input like 00:23:e8:79:99:32\n");
+	}
+      	rtk_nlsendmsg(pid, igmp_delete_sk, sizeof(struct test_struct), &send_data);
+  	return;
+}
+
+int igmp_delete_init_netlink(void) 
+{
+  	igmp_delete_sk = netlink_kernel_create(&init_net, NETLINK_MULTICAST_DELETE, 0, igmp_delete, NULL, THIS_MODULE);
+
+  	if (!igmp_delete_sk) {
+    		printk(KERN_ERR "Netlink[Kernel] Cannot create netlink socket for igmp delete.\n");
+    		return -EIO;
+  	}	
+  	printk("Netlink[Kernel] create socket for igmp ok.\n");
+  	return 0;
+}
+
diff --git a/drivers/net/rtl819x/igmpsnooping/rtl865x_igmpsnooping.c b/drivers/net/rtl819x/igmpsnooping/rtl865x_igmpsnooping.c
index bdc097f..4f01408 100644
--- a/drivers/net/rtl819x/igmpsnooping/rtl865x_igmpsnooping.c
+++ b/drivers/net/rtl819x/igmpsnooping/rtl865x_igmpsnooping.c
@@ -1,26 +1,16 @@
 /*
-* Copyright c                  Realsil Semiconductor Corporation, 2006
-* All rights reserved.
-* 
 * Program :  igmp snooping function
 * Abstract : 
 * Author :qinjunjie 
 * Email:qinjunjie1980@hotmail.com
 *
+*  Copyright (c) 2011 Realtek Semiconductor Corp.
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License version 2 as
+*  published by the Free Software Foundation.
 */
-/*	@doc Realtek_Igmp_Snooping_API
-
-	@module rtl865x_igmpsnooping.c - Realtek Igmp Snooping API documentation	|
-	This document explains the API interface of the igmp snooping  module.
-	@normal Jun-Jie Qin (qjj_qin@realsil.com.cn) <date>
-
-	Copyright <cp>2009 Realtek<tm> Semiconductor Cooperation, All Rights Reserved.
 
- 	@head3 List of Symbols |
- 	Here is a list of all functions and variables in this module.
-
- 	@index | Realtek_Igmp_Snooping_API
-*/
 #ifdef __linux__
 #include <linux/config.h>
 #include <linux/jiffies.h>
diff --git a/drivers/net/rtl819x/igmpsnooping/rtl865x_igmpsnooping_glue.c b/drivers/net/rtl819x/igmpsnooping/rtl865x_igmpsnooping_glue.c
index 65ac569..72be54a 100644
--- a/drivers/net/rtl819x/igmpsnooping/rtl865x_igmpsnooping_glue.c
+++ b/drivers/net/rtl819x/igmpsnooping/rtl865x_igmpsnooping_glue.c
@@ -10,26 +10,10 @@
 */
 
 
-/*	@doc RTL865X_IGMP_GlUE_API
-
-	@module rtl865x_igmpsnooping_glue.c - RTL865x Igmp Snooping Glue Function documentation	|
-	This document lists the glue functions when porting multicast snooping to different platform.
-	@normal Jun-Jie Qin (qjj_qin@realsil.com.cn) <date>
-
-	Copyright <cp>2006 Realsil<tm> Semiconductor Cooperation, All Rights Reserved.
-
- 	@head3 List of Symbols |
- 	Here is a list of all functions and variables in this module.
-
- 	@index | RTL8306_MULTICAST_GlUE_API
-*/
-
-
-
 #include <net/rtl/rtl_types.h>
 #include <net/rtl/rtl_glue.h>
 #include <net/rtl/rtl865x_igmpsnooping_glue.h>
-#include "../AsicDriver/rtl865xc_asicregs.h"
+#include "AsicDriver/rtl865xc_asicregs.h"
 
 #ifdef __linux__
 #include <linux/mm.h>
diff --git a/drivers/net/rtl819x/igmpsnooping/rtl865x_igmpsnooping_local.h b/drivers/net/rtl819x/igmpsnooping/rtl865x_igmpsnooping_local.h
index bf7557e..5854a1f 100644
--- a/drivers/net/rtl819x/igmpsnooping/rtl865x_igmpsnooping_local.h
+++ b/drivers/net/rtl819x/igmpsnooping/rtl865x_igmpsnooping_local.h
@@ -1,575 +1,577 @@
-/*
-* Copyright c                  Realsil Semiconductor Corporation, 2006
-* All rights reserved.
-* 
-* Program :  IGMP snooping function
-* Abstract : 
-* Author :qinjunjie 
-* Email:qinjunjie1980@hotmail.com
-*
-*/
-
-#ifndef RTL_MULTICASTV2_LOCAL_H
-#define RTL_MULTICASTV2_LOCAL_H
-
- /*                                               Macro declaration                                         */
-
-
-/***********************************Utilities************************************************/
-#define IS_CLASSD_ADDR(ipv4addr)				((((uint32)(ipv4addr)) & 0xf0000000) == 0xe0000000)
-#define RESERVE_MULTICAST_ADDR1 	0xEFFFFFFA
-/* ip 225.1.1.1 is not in the list of "http://www.iana.org/assignments/multicast-addresses/multicast-addresses.xml",
-	but it is used by customer's VoIP phone device.
- */
-#define RESERVE_MULTICAST_ADDR2 	0xE1010101	//225.1.1.1
-#define IN_MULTICAST_RESV1(addr)	((((uint32)(addr)) & 0xFFFFFF00) == 0xe0000000)	// 224.0.0.x
-#define IN_MULTICAST_RESV2(addr)	((((uint32)(addr)) & 0xFF000000) == 0xEF000000)	// 239.0.0.0~239.255.255.255
-
-#define IS_IPV6_MULTICAST_ADDRESS(ipv6addr)	((ipv6addr[0] & 0xFF000000)==0xff000000)
-#define IS_IPV4_MULTICAST_ADDRESS(ipv4addr)	(IS_CLASSD_ADDR(ipv4addr[0]))		
-
-#define CONFIG_STATIC_RESERVED_MULTICAST
-#if defined (CONFIG_STATIC_RESERVED_MULTICAST)
-#define STATIC_RESERVED_MULTICAST 	0x01
-#endif
-
-#define PORT0_MASK 0x01
-#define PORT1_MASK 0x02
-#define PORT2_MASK 0x04
-#define PORT3_MASK 0x08
-#define PORT4_MASK 0x10
-#define PORT5_MASK 0x20
-
-#ifdef CONFIG_NEW_IGMP_IMPLEMENTATION
-#define MAX_SUPPORT_PORT_NUMBER 16
-#else
-#define MAX_SUPPORT_PORT_NUMBER 10
-#endif
-#define DEFAULT_HASH_TABLE_SIZE 64
-#define MAX_HASH_TABLE_SIZE 1024
-#define MAX_MCAST_MODULE_NUM 8
-
-#define NON_PORT_MASK 0x00
-#define IPV4_MCAST_MAC_MASK 0x007fffff
-#define IPV6_MCAST_MAC_MASK 0x00ffffff
-
-
-
-/* IGMP snooping default  parameters */
-#define DEFAULT_MAX_GROUP_COUNT					     256	         /* default max group entry count **/
-#define DEFAULT_MAX_SOURCE_COUNT                                  300         /*default max source entry count*/
-#define DEFAULT_MAX_CLIENT_COUNT			256
-#define DEFAULT_MAX_FLOW_COUNT			256
-
-#define DEFAULT_GROUP_MEMBER_INTERVAL 260             /* IGMP group member interval, default is 260 seconds */
-#define DEFAULT_LAST_MEMBER_INTERVAL  10             /* IGMP last member query time, default is 2 seconds */
-#define DEFAULT_QUERIER_PRESENT_TIMEOUT 260             /* IGMP  querier present timeout, default is 260 seconds */
-
-#define DEFAULT_MCAST_FLOW_EXPIRE_TIME 	15
-
-#define DEFAULT_DVMRP_AGING_TIME		120           
-#define DEFAULT_PIM_AGING_TIME		120           
-#define DEFAULT_MOSPF_AGING_TIME		120
-
-#define DEFAULT_IPV4_UNKNOWN_MCAST_FLOOD_MAP	0x0
-#define DEFAULT_IPV6_UNKNOWN_MCAST_FLOOD_MAP	0xFFFFFFFF
-
-#define IP_VERSION4 4
-#define IP_VERSION6 6
-#define BOTH_IPV4_IPV6 0x46
-
-#define CPUTAGPROTOCOL 0x09
-#define VLAN_PROTOCOL_ID 0x8100
-
-#define IPV4_ETHER_TYPE 0x0800
-#define IPV6_ETHER_TYPE 0x86DD
-
-#define PPPOE_ETHER_TYPE 0x8864
-#define PPP_IPV4_PROTOCOL 0x0021
-#define PPP_IPV6_PROTOCOL 0x0057
-#define ROUTER_ALERT_OPTION 0x94040000
-
-#define  HOP_BY_HOP_OPTIONS_HEADER 0
-#define ROUTING_HEADER 43
-#define  FRAGMENT_HEADER 44
-#define DESTINATION_OPTION_HEADER 60
-#define NO_NEXT_HEADER 59
-#define ICMP_PROTOCOL 58
-
-#define DVMRP_ADDR  0xE0000004
-#define DVMRP_TYPE 0x13
-#define DVMRP_PROTOCOL 3
-
-#define PIM_PROTOCOL 103
-#define IPV4_PIM_ADDR 0xE000000D
-#define IS_IPV6_PIM_ADDR(ipv6addr) ((ipv6addr[0] == 0xFF020000)&&(ipv6addr[1] == 0x00000000)&&(ipv6addr[2] == 0x00000000)&&(ipv6addr[3] ==0x0000000D)) 
-		
-#define MOSPF_PROTOCOL 89
-#define MOSPF_HELLO_TYPE 1
-#define IPV4_MOSPF_ADDR1  0xE0000005
-#define IPV4_MOSPF_ADDR2  0xE0000006
-#define IS_IPV6_MOSPF_ADDR1(ipv6addr) ((ipv6addr[0] == 0xFF020000)&&(ipv6addr[1] == 0x00000000)&&(ipv6addr[2] == 0x00000000)&&(ipv6addr[3] ==0x00000005)) 		
-#define IS_IPV6_MOSPF_ADDR2(ipv6addr) ((ipv6addr[0] == 0xFF020000)&&(ipv6addr[1] == 0x00000000)&&(ipv6addr[2] == 0x00000000)&&(ipv6addr[3] ==0x00000006)) 
-
-
-#define IGMP_PROTOCOL 2
-#define IGMP_ALL_HOSTS_ADDR	0xE0000001	/*general query address*/
-#define IGMP_ALL_ROUTERS_ADDR	0xE0000002  /*leave report address*/
-#define IGMPV3_REPORT_ADDR 0xE0000016
-
-
-#define IS_MLD_ALL_HOSTS_ADDRESS(ipv6addr) ((ipv6addr[0] == 0xFF020000)&&(ipv6addr[1] == 0x00000000)&&(ipv6addr[2] == 0x00000000)&&(ipv6addr[3] ==0x00000001))
-
-	
-#define IS_MLD_ALL__ROUTER_ADDRESS(ipv6addr) ((ipv6addr[0] == 0xFF020000)&&(ipv6addr[1] ==0x00000000)&&(ipv6addr[2] ==0x00000000)&&(ipv6addr[3] == 0x00000002))
-
-	
-#define IS_MLDv2_REPORT_ADDRESS(ipv6addr) ((ipv6addr[0] == 0xFF020000)&&(ipv6addr[1] == 0x00000000)&&(ipv6addr[2] == 0x00000000)&&(ipv6addr[3] ==0x00000016))
-
-
-/*            IGMP type              */
-#define IGMP_QUERY 0x11
-#define IGMPV1_REPORT 0x12
-#define IGMPV2_REPORT 0x16
-#define IGMPV2_LEAVE 0x17
-#define IGMPV3_REPORT 0x22
-
-/*             MLD type          */
-#define MLD_QUERY 130
-#define MLDV1_REPORT 131
-#define MLDV1_DONE 132
-#define MLDV2_REPORT 143
-#define S_FLAG_MASK 0x08
-
-#define MODE_IS_INCLUDE			                      1
-#define MODE_IS_EXCLUDE			                      2
-#define CHANGE_TO_INCLUDE_MODE	                      3
-#define CHANGE_TO_EXCLUDE_MODE		               4
-#define ALLOW_NEW_SOURCES                                  5
-#define BLOCK_OLD_SOURCES			                      6
-
-#define	FILTER_MODE_INCLUDE		0
-#define	FILTER_MODE_EXCLUDE		1
-
-		/*             IGMP version                       */
-#define IGMP_V1					       1
-#define IGMP_V2						2
-#define IGMP_V3						3
-
-#define MLD_V1 						1
-#define MLD_V2						2
-
-
-#define IPV4_ROUTER_ALTER_OPTION 0x94040000
-#define IPV6_ROUTER_ALTER_OPTION 0x05020000
-#define IPV6_HEADER_LENGTH 40
-
-/**********************IGMPv3 exponential field decoding ******************************/ 
-#define	RTL_IGMPV3_MASK(value, nb)		((nb)>=32 ? (value) : ((1<<(nb))-1) & (value))
-#define	RTL_IGMPV3_EXP(thresh, nbmant, nbexp, value) \
-			((value) < (thresh) ? (value) : \
-			((RTL_IGMPV3_MASK(value, nbmant) | (1<<(nbmant))) << \
-			(RTL_IGMPV3_MASK((value) >> (nbmant), nbexp) + (nbexp))))		
-			
-#define	RTL_IGMPV3_QQIC(value)			RTL_IGMPV3_EXP(0x80, 4, 3, value)
-#define	RTL_IGMPV3_MRC(value)			RTL_IGMPV3_EXP(0x80, 4, 3, value)
-/********************************************************************************/
-
-
-/**************************MLDv2 exponential field decoding ****************************/
-#define   RTL_MLDV2_MASK(value, nb) 	((nb)>=32 ? (value) : ((1<<(nb))-1) & (value))
-#define   RTL_MLDV2_EXP(thresh, nbmant, nbexp, value)\
-	              ((value) < (thresh) ? (value) : \
-			((RTL_MLDV2_MASK(value, nbmant) | (1<<(nbmant))) << \
-			(RTL_MLDV2_MASK((value) >> (nbmant), nbexp) + (nbexp))))
-			
-#define   RTL_MLDV2_QQIC(value)			RTL_MLDV2_EXP(0x80, 4, 3, value)
-#define   RTL_MLDV2_MRC(value)			RTL_MLDV2_EXP(0x8000, 12, 3, value)
-/*------------------------------------------------------------------------------*/
-
-struct ipv4Pkt 
-{
-	uint8       vhl;            
-	uint8	typeOfService;			
-	uint16	length;			/* total length */
-	uint16	identification;	/* identification */
-	uint16	offset;			
-	uint8	ttl;				/* time to live */
-	uint8	protocol;			
-	uint16	checksum;			
-	uint32 sourceIp;
-	uint32 destinationIp;
-};
-
-struct igmpPkt{
-	uint8 type;				      /* type*/
-	uint8 maxRespTime;                /*maximum response time,unit:0.1 seconds*/
-	uint16 checksum;                   
-	uint32 groupAddr;
-	
-};
-
-struct igmpv1Pkt
-{
-	uint8 VersionType;	              /*4bits: version, 4bits:type*/
-	uint8 unused;
-	uint16 checkSum;                     /*IGMP packet checksum*/
-	uint32 groupAddr;                    /*multicast group address*/
-};
-
-struct igmpv2Pkt
-{
-	uint8 type;				      /* type*/
-	uint8 maxRespTime;                /*maximum response time,unit:0.1 seconds*/
-	uint16 checkSum;                   
-	uint32 groupAddr;
-	
-};
-
-struct igmpv3Query
-{
-	uint8 type;                                /*query type*/
-	uint8 maxRespCode;			/*maximum response code*/
-	uint16 checkSum;				/*IGMP checksum*/
-	uint32 groupAddr;                    /*multicast group address*/
-	uint8 rsq;					/* 4bit: reserved, 1bit: suppress router-side processing, 3bit: querier's robustness variable*/
-	uint8 qqic;					/* querier's query interval code */
-	uint16 numOfSrc;				/* number of sources */
-	uint32 srcList;				/* first entry of source list */	
-};
-
-struct groupRecord
-{
-	uint8	type;					/* Record Type */
-	uint8	auxLen;			              /* auxiliary data length, in uints of 32 bit words*/
-	uint16	numOfSrc;			       /* number of sources */
-	uint32	groupAddr;			       /* group address being reported */
-	uint32	srcList;				       /* first entry of source list */
-	
-};
-
-struct igmpv3Report
-{
-	uint8	type;					/* Report Type */
-	uint8  reserved1;             
-	uint16 checkSum;					/*IGMP checksum*/
-	uint16 reserved2;
-	uint16	numOfRecords;			       /* number of Group records */
-	struct groupRecord recordList;       /*first entry of group record list*/
-};
- 
-struct ipv6Pkt
-{
-	uint32     vtf;                 /*version(4bits),  traffic class(8bits), and flow label(20bits)*/
-	uint16	payloadLenth;			/* payload length */
-	uint8	nextHeader;			/* next header */
-	uint8	hopLimit;			/* hop limit*/
-	uint32     sourceAddr[4];	      /*source address*/
-	uint32    	destinationAddr[4];	      /* destination address */
-};
-
-
-struct mldv1Pkt
-{
-	uint8 type;                                   
-	uint8 code;						/*initialize by sender, ignored by receiver*/
-	uint16 checkSum;
-	uint16 maxResDelay;                       /*maximum response delay,unit:0.001 second*/ 
-	uint16 reserved;
-	uint32 mCastAddr[4];                      /*ipv6 multicast address*/  
-};
-
-
-struct mldv2Query
-{
-	uint8 type;
-	uint8 code;                                   /*initialize by sender, ignored by receiver*/
-	uint16 checkSum;
-	uint16 maxResCode;                      /*maximum response code,unit:0.001 second*/ 
-	uint16 reserved;
-	uint32 mCastAddr[4];
-	uint8 rsq;	                               /* 4bits: reserved, 1bit: suppress router-side processing, 3bits: querier's robustness variable*/
-	uint8 qqic;                                   /* querier's query interval code */
-	uint16 numOfSrc;				  /* number of sources */
-	uint32 srcList;
-};
-
-struct mCastAddrRecord
-{
-	uint8	type;					/* Record Type */
-	uint8	auxLen;			              /* auxiliary data length, in uints of 32 bit words*/
-	uint16	numOfSrc;			       /* number of sources */
-	uint32	mCastAddr[4];			/* group address being reported */
-	uint32	srcList;			             /* first entry of source list */
-};
-
-struct mldv2Report
-{
-	uint8 type;
-	uint8  reserved1;                                  
-	uint16 checkSum;                           
-	uint16 reserved2;                    
-	uint16 numOfRecords;				  /* number of multicast address records */
-	struct mCastAddrRecord recordList;
-};
-
-
-struct ipv4MospfHdr
-{
-	uint8 version;
-	uint8 type;
-	uint16 pktLen;
-	uint32 routerId;
-	uint32 areaId;
-	uint16 CheckSum;
-	uint16 auType;
-	uint32 authentication[2];	
-};
-
-struct ipv4MospfHello
-{
-	struct ipv4MospfHdr hdr;
-	uint32 netWorkMask;
-	uint16 helloInterVal;
-	uint8  options;          /*  X-X-DC-EA-N/P-MC-E-X */
-	uint8 routerPriority;
-	uint32 routerDeadInterval;
-	uint32 designatedRouter;
-	uint32 backupDesignatedRouter;
-	uint32 neighbor;
-};
-
-struct ipv6MospfHdr
-{
-	uint8 version; /*vesion is 3*/
-	uint8 type;
-	uint16 pktLen;
-	uint32 routerId;
-	uint32 areaId;
-	uint16 CheckSum;
-	uint8 instanceId;
-	uint8 zeroData;
-
-};
-
-struct ipv6MospfHello
-{
-	struct ipv6MospfHdr hdr;
-	uint32 interfaceId;
-	uint8 routerPriority;
-	uint8  options[3];          /*X-X-DC-R-N-MC-E-V6 */
-	uint16 helloInterval;
-	uint16 routerDeadInterval;
-	uint32 designatedRouter;
-	uint32 backupDesignatedRouter;
-	uint32 neighbor;
-};
-
-struct ipv6PseudoHeader
-{
-	uint32 sourceAddr[4];
-	uint32 destinationAddr[4];
-	uint32 upperLayerPacketLength;
-	uint8  zeroData[3];
-	uint8  nextHeader;
-};
-
-struct ipv4PseudoHeader
-{
-	uint32 sourceAddr;
-	uint32 destinationAddr;
-	uint8 zero;
-	uint8  protocol;
-	uint16  payloadLen;
-};
-
-
-union pseudoHeader 
-{
-	struct ipv6PseudoHeader ipv6_pHdr;
-	struct ipv4PseudoHeader ipv4_pHdr;
-};
-
-#ifdef CONFIG_NEW_IGMP_IMPLEMENTATION
-struct rtl_groupEntry
-{
-	struct rtl_groupEntry *previous;
-	struct rtl_groupEntry  *next;             /*Pointer of next group entry*/
-	uint32 ipVersion;
-	#ifdef CONFIG_RTL_MLD_SNOOPING
-	uint32 groupAddr[4];
-	#else
-	uint32 groupAddr[1];
-	#endif
-
-	struct	rtl_clientEntry *clientList;
-#if defined (CONFIG_STATIC_RESERVED_MULTICAST)	
-	uint32	attribute;
-	uint32 	staticFwdPortMask;
-#endif	
-};
-
-struct rtl_clientEntry
-{
-	uint16 igmpVersion;
-	uint16 portNum;
-	struct rtl_clientEntry *previous;
-	struct rtl_clientEntry  *next;             /*Pointer of next group entry*/
-	#ifdef CONFIG_RTL_MLD_SNOOPING
-	uint32 clientAddr[4];	/*client ip address*/
-	#else
-	uint32 clientAddr[1];	/*client ip address*/
-	#endif
-	struct rtl_sourceEntry *sourceList;	/*this is the server source ip list*/
-	uint32 groupFilterTimer;
-	uint8 clientMacAddr[6];
-};
-
-
-struct rtl_sourceEntry
-{
-	#ifdef CONFIG_RTL_MLD_SNOOPING
-	uint32 sourceAddr[4];                       /*D class IP multicast address*/
-	#else
-	uint32 sourceAddr[1];                       /*D class IP multicast address*/
-	#endif
-	uint32 fwdState;
-	struct rtl_sourceEntry *previous; 
-	struct rtl_sourceEntry *next;             /*Pointer of next group entry*/
-	uint32 portTimer;   
-};
-
-struct rtl_mcastFlowEntry
-{
-	struct rtl_mcastFlowEntry *previous;
-	struct rtl_mcastFlowEntry  *next;             /*Pointer of next group entry*/
-	uint32 ipVersion;
-	#ifdef CONFIG_RTL_MLD_SNOOPING
-	uint32 serverAddr[4];
-	uint32 groupAddr[4];
-	#else
-	uint32 serverAddr[1];
-	uint32 groupAddr[1];
-	#endif
-	
-	struct rtl_multicastFwdInfo multicastFwdInfo;
-	uint32 refreshTime;
-};
-#else
-struct rtl_groupEntry
-{
-	struct rtl_groupEntry *previous;
-	struct rtl_groupEntry  *next;             /*Pointer of next group entry*/
-	struct rtl_sourceEntry *sourceList;
-	uint32 ipVersion;
-	#ifdef CONFIG_RTL_MLD_SNOOPING
-	uint32 groupAddr[4];
-	#else
-	uint32 groupAddr[1];
-	#endif
-	uint32 groupFilterTimer[MAX_SUPPORT_PORT_NUMBER];
-	
-};
-
-struct rtl_sourceEntry
-{
-	#ifdef CONFIG_RTL_MLD_SNOOPING
-	uint32 sourceAddr[4];                       /*D class IP multicast address*/
-	#else
-	uint32 sourceAddr[1];                       /*D class IP multicast address*/
-	#endif
-	struct rtl_sourceEntry *previous; 
-	struct rtl_sourceEntry *next;             /*Pointer of next group entry*/
-	uint32 portTimer[MAX_SUPPORT_PORT_NUMBER];   
-};
-#endif
-
-struct rtl_mcastRouter
-{	
-	uint32 portTimer[MAX_SUPPORT_PORT_NUMBER];
-};
-
-
-struct rtl_macFrameInfo
-{
-	uint8   ipVersion;
-
-	uint32 srcIpAddr[4];
-	uint32 dstIpAddr[4];
-
-	uint8 *ipBuf;
-	uint16   ipHdrLen;
-	uint8   l3Protocol;
-	uint8 checksumFlag;
-	uint8 *l3PktBuf;
-	uint16 l3PktLen;
-	uint16 macFrameLen;
-	uint16 vlanTagFlag;
-	uint16 vlanTagID;
-	uint8 srcMacAddr[6];
-
-};
-
-
-struct rtl_multicastRouters
-{
-	 struct rtl_mcastRouter querier;
-	 struct rtl_mcastRouter dvmrpRouter;
-	 struct rtl_mcastRouter mospfRouter;
-	 struct rtl_mcastRouter pimRouter;
-	 		 
-};
-#ifdef CONFIG_NEW_IGMP_IMPLEMENTATION
-//#define CONFIG_RECORD_MCAST_FLOW
-#endif
-
-struct rtl_multicastModule
-{
-	uint8 enableSnooping;
-#ifdef CONFIG_NEW_IGMP_IMPLEMENTATION
-#else
-	uint8 enableSourceList;
-#endif
-	uint8 enableFastLeave;
-
-	uint32 ipv4UnknownMCastFloodMap;
-#ifdef CONFIG_RTL_MLD_SNOOPING		
-	uint32 ipv6UnknownMCastFloodMap;
-#endif
-	uint32 staticRouterPortMask;
-	
-	rtl_multicastDeviceInfo_t deviceInfo;
-
-	struct rtl_multicastRouters rtl_ipv4MulticastRouters;
-#ifdef CONFIG_RTL_MLD_SNOOPING	
-	struct rtl_multicastRouters rtl_ipv6MulticastRouters;
-#endif
-
-	/*gateway infomation*/
-	uint8 rtl_gatewayMac[6];
-	uint32 rtl_gatewayIpv4Addr;
-	
-#ifdef CONFIG_RTL_MLD_SNOOPING	
-	uint32 rtl_gatewayIpv6Addr[4];
-#endif
-
-
-	/*hash table definition*/
-	struct rtl_groupEntry ** rtl_ipv4HashTable;
-
-#ifdef CONFIG_RTL_MLD_SNOOPING	
-	struct rtl_groupEntry ** rtl_ipv6HashTable;
-#endif
-
-#ifdef CONFIG_RECORD_MCAST_FLOW
-	struct rtl_mcastFlowEntry **flowHashTable;
-#endif
-#ifdef CONFIG_PROC_FS
-	 unsigned int expireEventCnt;
-#endif
-
-};
-
-
-#endif 
-
+/*
+* Copyright c                  Realsil Semiconductor Corporation, 2006
+* All rights reserved.
+* 
+* Program :  IGMP snooping function
+* Abstract : 
+* Author :qinjunjie 
+* Email:qinjunjie1980@hotmail.com
+*
+*/
+
+#ifndef RTL_MULTICASTV2_LOCAL_H
+#define RTL_MULTICASTV2_LOCAL_H
+
+ /*                                               Macro declaration                                         */
+
+
+/***********************************Utilities************************************************/
+#define IS_CLASSD_ADDR(ipv4addr)				((((uint32)(ipv4addr)) & 0xf0000000) == 0xe0000000)
+#define RESERVE_MULTICAST_ADDR1 	0xEFFFFFFA
+/* ip 225.1.1.1 is not in the list of "http://www.iana.org/assignments/multicast-addresses/multicast-addresses.xml",
+	but it is used by customer's VoIP phone device.
+ */
+#define IS_RESERVE_MULTICAST_MDNS_ADDR_V4(ipv4addr) 	((((uint32)(ipv4addr)) & 0xFFFFFFFF) == 0xE00000FB)//224.0.0.251
+#define IS_RESERVE_MULTICAST_MDNS_ADDR_V6(ipv6addr) 	(((ipv6addr[0] & 0xFFFFFFFF)==0xff020000)&&((ipv6addr[1] & 0xFFFFFFFF)==0x00000000)&&((ipv6addr[2] & 0xFFFFFFFF)==0x00000000)&&((ipv6addr[3] & 0xFFFFFFFF)==0x000000FB)) 
+#define RESERVE_MULTICAST_ADDR2 	0xE1010101	//225.1.1.1
+#define IN_MULTICAST_RESV1(addr)	((((uint32)(addr)) & 0xFFFFFF00) == 0xe0000000)	// 224.0.0.x
+#define IN_MULTICAST_RESV2(addr)	((((uint32)(addr)) & 0xFF000000) == 0xEF000000)	// 239.0.0.0~239.255.255.255
+
+#define IS_IPV6_MULTICAST_ADDRESS(ipv6addr)	((ipv6addr[0] & 0xFF000000)==0xff000000)
+#define IS_IPV4_MULTICAST_ADDRESS(ipv4addr)	(IS_CLASSD_ADDR(ipv4addr[0]))		
+
+#define CONFIG_STATIC_RESERVED_MULTICAST
+#if defined (CONFIG_STATIC_RESERVED_MULTICAST)
+#define STATIC_RESERVED_MULTICAST 	0x01
+#endif
+
+#define PORT0_MASK 0x01
+#define PORT1_MASK 0x02
+#define PORT2_MASK 0x04
+#define PORT3_MASK 0x08
+#define PORT4_MASK 0x10
+#define PORT5_MASK 0x20
+
+#ifdef CONFIG_NEW_IGMP_IMPLEMENTATION
+#define MAX_SUPPORT_PORT_NUMBER 16
+#else
+#define MAX_SUPPORT_PORT_NUMBER 10
+#endif
+#define DEFAULT_HASH_TABLE_SIZE 64
+#define MAX_HASH_TABLE_SIZE 1024
+#define MAX_MCAST_MODULE_NUM 8
+
+#define NON_PORT_MASK 0x00
+#define IPV4_MCAST_MAC_MASK 0x007fffff
+#define IPV6_MCAST_MAC_MASK 0x00ffffff
+
+
+
+/* IGMP snooping default  parameters */
+#define DEFAULT_MAX_GROUP_COUNT					     256	         /* default max group entry count **/
+#define DEFAULT_MAX_SOURCE_COUNT                                  300         /*default max source entry count*/
+#define DEFAULT_MAX_CLIENT_COUNT			256
+#define DEFAULT_MAX_FLOW_COUNT			256
+
+#define DEFAULT_GROUP_MEMBER_INTERVAL 260             /* IGMP group member interval, default is 260 seconds */
+#define DEFAULT_LAST_MEMBER_INTERVAL  10             /* IGMP last member query time, default is 2 seconds */
+#define DEFAULT_QUERIER_PRESENT_TIMEOUT 260             /* IGMP  querier present timeout, default is 260 seconds */
+
+#define DEFAULT_MCAST_FLOW_EXPIRE_TIME 	15
+
+#define DEFAULT_DVMRP_AGING_TIME		120           
+#define DEFAULT_PIM_AGING_TIME		120           
+#define DEFAULT_MOSPF_AGING_TIME		120
+
+#define DEFAULT_IPV4_UNKNOWN_MCAST_FLOOD_MAP	0x0
+#define DEFAULT_IPV6_UNKNOWN_MCAST_FLOOD_MAP	0xFFFFFFFF
+
+#define IP_VERSION4 4
+#define IP_VERSION6 6
+#define BOTH_IPV4_IPV6 0x46
+
+#define CPUTAGPROTOCOL 0x09
+#define VLAN_PROTOCOL_ID 0x8100
+
+#define IPV4_ETHER_TYPE 0x0800
+#define IPV6_ETHER_TYPE 0x86DD
+
+#define PPPOE_ETHER_TYPE 0x8864
+#define PPP_IPV4_PROTOCOL 0x0021
+#define PPP_IPV6_PROTOCOL 0x0057
+#define ROUTER_ALERT_OPTION 0x94040000
+
+#define  HOP_BY_HOP_OPTIONS_HEADER 0
+#define ROUTING_HEADER 43
+#define  FRAGMENT_HEADER 44
+#define DESTINATION_OPTION_HEADER 60
+#define NO_NEXT_HEADER 59
+#define ICMP_PROTOCOL 58
+
+#define DVMRP_ADDR  0xE0000004
+#define DVMRP_TYPE 0x13
+#define DVMRP_PROTOCOL 3
+
+#define PIM_PROTOCOL 103
+#define IPV4_PIM_ADDR 0xE000000D
+#define IS_IPV6_PIM_ADDR(ipv6addr) ((ipv6addr[0] == 0xFF020000)&&(ipv6addr[1] == 0x00000000)&&(ipv6addr[2] == 0x00000000)&&(ipv6addr[3] ==0x0000000D)) 
+		
+#define MOSPF_PROTOCOL 89
+#define MOSPF_HELLO_TYPE 1
+#define IPV4_MOSPF_ADDR1  0xE0000005
+#define IPV4_MOSPF_ADDR2  0xE0000006
+#define IS_IPV6_MOSPF_ADDR1(ipv6addr) ((ipv6addr[0] == 0xFF020000)&&(ipv6addr[1] == 0x00000000)&&(ipv6addr[2] == 0x00000000)&&(ipv6addr[3] ==0x00000005)) 		
+#define IS_IPV6_MOSPF_ADDR2(ipv6addr) ((ipv6addr[0] == 0xFF020000)&&(ipv6addr[1] == 0x00000000)&&(ipv6addr[2] == 0x00000000)&&(ipv6addr[3] ==0x00000006)) 
+
+
+#define IGMP_PROTOCOL 2
+#define IGMP_ALL_HOSTS_ADDR	0xE0000001	/*general query address*/
+#define IGMP_ALL_ROUTERS_ADDR	0xE0000002  /*leave report address*/
+#define IGMPV3_REPORT_ADDR 0xE0000016
+
+
+#define IS_MLD_ALL_HOSTS_ADDRESS(ipv6addr) ((ipv6addr[0] == 0xFF020000)&&(ipv6addr[1] == 0x00000000)&&(ipv6addr[2] == 0x00000000)&&(ipv6addr[3] ==0x00000001))
+
+	
+#define IS_MLD_ALL__ROUTER_ADDRESS(ipv6addr) ((ipv6addr[0] == 0xFF020000)&&(ipv6addr[1] ==0x00000000)&&(ipv6addr[2] ==0x00000000)&&(ipv6addr[3] == 0x00000002))
+
+	
+#define IS_MLDv2_REPORT_ADDRESS(ipv6addr) ((ipv6addr[0] == 0xFF020000)&&(ipv6addr[1] == 0x00000000)&&(ipv6addr[2] == 0x00000000)&&(ipv6addr[3] ==0x00000016))
+
+
+/*            IGMP type              */
+#define IGMP_QUERY 0x11
+#define IGMPV1_REPORT 0x12
+#define IGMPV2_REPORT 0x16
+#define IGMPV2_LEAVE 0x17
+#define IGMPV3_REPORT 0x22
+
+/*             MLD type          */
+#define MLD_QUERY 130
+#define MLDV1_REPORT 131
+#define MLDV1_DONE 132
+#define MLDV2_REPORT 143
+#define S_FLAG_MASK 0x08
+
+#define MODE_IS_INCLUDE			                      1
+#define MODE_IS_EXCLUDE			                      2
+#define CHANGE_TO_INCLUDE_MODE	                      3
+#define CHANGE_TO_EXCLUDE_MODE		               4
+#define ALLOW_NEW_SOURCES                                  5
+#define BLOCK_OLD_SOURCES			                      6
+
+#define	FILTER_MODE_INCLUDE		0
+#define	FILTER_MODE_EXCLUDE		1
+
+		/*             IGMP version                       */
+#define IGMP_V1					       1
+#define IGMP_V2						2
+#define IGMP_V3						3
+
+#define MLD_V1 						1
+#define MLD_V2						2
+
+
+#define IPV4_ROUTER_ALTER_OPTION 0x94040000
+#define IPV6_ROUTER_ALTER_OPTION 0x05020000
+#define IPV6_HEADER_LENGTH 40
+
+/**********************IGMPv3 exponential field decoding ******************************/ 
+#define	RTL_IGMPV3_MASK(value, nb)		((nb)>=32 ? (value) : ((1<<(nb))-1) & (value))
+#define	RTL_IGMPV3_EXP(thresh, nbmant, nbexp, value) \
+			((value) < (thresh) ? (value) : \
+			((RTL_IGMPV3_MASK(value, nbmant) | (1<<(nbmant))) << \
+			(RTL_IGMPV3_MASK((value) >> (nbmant), nbexp) + (nbexp))))		
+			
+#define	RTL_IGMPV3_QQIC(value)			RTL_IGMPV3_EXP(0x80, 4, 3, value)
+#define	RTL_IGMPV3_MRC(value)			RTL_IGMPV3_EXP(0x80, 4, 3, value)
+/********************************************************************************/
+
+
+/**************************MLDv2 exponential field decoding ****************************/
+#define   RTL_MLDV2_MASK(value, nb) 	((nb)>=32 ? (value) : ((1<<(nb))-1) & (value))
+#define   RTL_MLDV2_EXP(thresh, nbmant, nbexp, value)\
+	              ((value) < (thresh) ? (value) : \
+			((RTL_MLDV2_MASK(value, nbmant) | (1<<(nbmant))) << \
+			(RTL_MLDV2_MASK((value) >> (nbmant), nbexp) + (nbexp))))
+			
+#define   RTL_MLDV2_QQIC(value)			RTL_MLDV2_EXP(0x80, 4, 3, value)
+#define   RTL_MLDV2_MRC(value)			RTL_MLDV2_EXP(0x8000, 12, 3, value)
+/*------------------------------------------------------------------------------*/
+
+struct ipv4Pkt 
+{
+	uint8       vhl;            
+	uint8	typeOfService;			
+	uint16	length;			/* total length */
+	uint16	identification;	/* identification */
+	uint16	offset;			
+	uint8	ttl;				/* time to live */
+	uint8	protocol;			
+	uint16	checksum;			
+	uint32 sourceIp;
+	uint32 destinationIp;
+};
+
+struct igmpPkt{
+	uint8 type;				      /* type*/
+	uint8 maxRespTime;                /*maximum response time,unit:0.1 seconds*/
+	uint16 checksum;                   
+	uint32 groupAddr;
+	
+};
+
+struct igmpv1Pkt
+{
+	uint8 VersionType;	              /*4bits: version, 4bits:type*/
+	uint8 unused;
+	uint16 checkSum;                     /*IGMP packet checksum*/
+	uint32 groupAddr;                    /*multicast group address*/
+};
+
+struct igmpv2Pkt
+{
+	uint8 type;				      /* type*/
+	uint8 maxRespTime;                /*maximum response time,unit:0.1 seconds*/
+	uint16 checkSum;                   
+	uint32 groupAddr;
+	
+};
+
+struct igmpv3Query
+{
+	uint8 type;                                /*query type*/
+	uint8 maxRespCode;			/*maximum response code*/
+	uint16 checkSum;				/*IGMP checksum*/
+	uint32 groupAddr;                    /*multicast group address*/
+	uint8 rsq;					/* 4bit: reserved, 1bit: suppress router-side processing, 3bit: querier's robustness variable*/
+	uint8 qqic;					/* querier's query interval code */
+	uint16 numOfSrc;				/* number of sources */
+	uint32 srcList;				/* first entry of source list */	
+};
+
+struct groupRecord
+{
+	uint8	type;					/* Record Type */
+	uint8	auxLen;			              /* auxiliary data length, in uints of 32 bit words*/
+	uint16	numOfSrc;			       /* number of sources */
+	uint32	groupAddr;			       /* group address being reported */
+	uint32	srcList;				       /* first entry of source list */
+	
+};
+
+struct igmpv3Report
+{
+	uint8	type;					/* Report Type */
+	uint8  reserved1;             
+	uint16 checkSum;					/*IGMP checksum*/
+	uint16 reserved2;
+	uint16	numOfRecords;			       /* number of Group records */
+	struct groupRecord recordList;       /*first entry of group record list*/
+};
+ 
+struct ipv6Pkt
+{
+	uint32     vtf;                 /*version(4bits),  traffic class(8bits), and flow label(20bits)*/
+	uint16	payloadLenth;			/* payload length */
+	uint8	nextHeader;			/* next header */
+	uint8	hopLimit;			/* hop limit*/
+	uint32     sourceAddr[4];	      /*source address*/
+	uint32    	destinationAddr[4];	      /* destination address */
+};
+
+
+struct mldv1Pkt
+{
+	uint8 type;                                   
+	uint8 code;						/*initialize by sender, ignored by receiver*/
+	uint16 checkSum;
+	uint16 maxResDelay;                       /*maximum response delay,unit:0.001 second*/ 
+	uint16 reserved;
+	uint32 mCastAddr[4];                      /*ipv6 multicast address*/  
+};
+
+
+struct mldv2Query
+{
+	uint8 type;
+	uint8 code;                                   /*initialize by sender, ignored by receiver*/
+	uint16 checkSum;
+	uint16 maxResCode;                      /*maximum response code,unit:0.001 second*/ 
+	uint16 reserved;
+	uint32 mCastAddr[4];
+	uint8 rsq;	                               /* 4bits: reserved, 1bit: suppress router-side processing, 3bits: querier's robustness variable*/
+	uint8 qqic;                                   /* querier's query interval code */
+	uint16 numOfSrc;				  /* number of sources */
+	uint32 srcList;
+};
+
+struct mCastAddrRecord
+{
+	uint8	type;					/* Record Type */
+	uint8	auxLen;			              /* auxiliary data length, in uints of 32 bit words*/
+	uint16	numOfSrc;			       /* number of sources */
+	uint32	mCastAddr[4];			/* group address being reported */
+	uint32	srcList;			             /* first entry of source list */
+};
+
+struct mldv2Report
+{
+	uint8 type;
+	uint8  reserved1;                                  
+	uint16 checkSum;                           
+	uint16 reserved2;                    
+	uint16 numOfRecords;				  /* number of multicast address records */
+	struct mCastAddrRecord recordList;
+};
+
+
+struct ipv4MospfHdr
+{
+	uint8 version;
+	uint8 type;
+	uint16 pktLen;
+	uint32 routerId;
+	uint32 areaId;
+	uint16 CheckSum;
+	uint16 auType;
+	uint32 authentication[2];	
+};
+
+struct ipv4MospfHello
+{
+	struct ipv4MospfHdr hdr;
+	uint32 netWorkMask;
+	uint16 helloInterVal;
+	uint8  options;          /*  X-X-DC-EA-N/P-MC-E-X */
+	uint8 routerPriority;
+	uint32 routerDeadInterval;
+	uint32 designatedRouter;
+	uint32 backupDesignatedRouter;
+	uint32 neighbor;
+};
+
+struct ipv6MospfHdr
+{
+	uint8 version; /*vesion is 3*/
+	uint8 type;
+	uint16 pktLen;
+	uint32 routerId;
+	uint32 areaId;
+	uint16 CheckSum;
+	uint8 instanceId;
+	uint8 zeroData;
+
+};
+
+struct ipv6MospfHello
+{
+	struct ipv6MospfHdr hdr;
+	uint32 interfaceId;
+	uint8 routerPriority;
+	uint8  options[3];          /*X-X-DC-R-N-MC-E-V6 */
+	uint16 helloInterval;
+	uint16 routerDeadInterval;
+	uint32 designatedRouter;
+	uint32 backupDesignatedRouter;
+	uint32 neighbor;
+};
+
+struct ipv6PseudoHeader
+{
+	uint32 sourceAddr[4];
+	uint32 destinationAddr[4];
+	uint32 upperLayerPacketLength;
+	uint8  zeroData[3];
+	uint8  nextHeader;
+};
+
+struct ipv4PseudoHeader
+{
+	uint32 sourceAddr;
+	uint32 destinationAddr;
+	uint8 zero;
+	uint8  protocol;
+	uint16  payloadLen;
+};
+
+
+union pseudoHeader 
+{
+	struct ipv6PseudoHeader ipv6_pHdr;
+	struct ipv4PseudoHeader ipv4_pHdr;
+};
+
+#ifdef CONFIG_NEW_IGMP_IMPLEMENTATION
+struct rtl_groupEntry
+{
+	struct rtl_groupEntry *previous;
+	struct rtl_groupEntry  *next;             /*Pointer of next group entry*/
+	uint32 ipVersion;
+	#ifdef CONFIG_RTL_MLD_SNOOPING
+	uint32 groupAddr[4];
+	#else
+	uint32 groupAddr[1];
+	#endif
+
+	struct	rtl_clientEntry *clientList;
+#if defined (CONFIG_STATIC_RESERVED_MULTICAST)	
+	uint32	attribute;
+	uint32 	staticFwdPortMask;
+#endif	
+};
+
+struct rtl_clientEntry
+{
+	uint16 igmpVersion;
+	uint16 portNum;
+	struct rtl_clientEntry *previous;
+	struct rtl_clientEntry  *next;             /*Pointer of next group entry*/
+	#ifdef CONFIG_RTL_MLD_SNOOPING
+	uint32 clientAddr[4];	/*client ip address*/
+	#else
+	uint32 clientAddr[1];	/*client ip address*/
+	#endif
+	struct rtl_sourceEntry *sourceList;	/*this is the server source ip list*/
+	uint32 groupFilterTimer;
+	uint8 clientMacAddr[6];
+};
+
+
+struct rtl_sourceEntry
+{
+	#ifdef CONFIG_RTL_MLD_SNOOPING
+	uint32 sourceAddr[4];                       /*D class IP multicast address*/
+	#else
+	uint32 sourceAddr[1];                       /*D class IP multicast address*/
+	#endif
+	uint32 fwdState;
+	struct rtl_sourceEntry *previous; 
+	struct rtl_sourceEntry *next;             /*Pointer of next group entry*/
+	uint32 portTimer;   
+};
+
+struct rtl_mcastFlowEntry
+{
+	struct rtl_mcastFlowEntry *previous;
+	struct rtl_mcastFlowEntry  *next;             /*Pointer of next group entry*/
+	uint32 ipVersion;
+	#ifdef CONFIG_RTL_MLD_SNOOPING
+	uint32 serverAddr[4];
+	uint32 groupAddr[4];
+	#else
+	uint32 serverAddr[1];
+	uint32 groupAddr[1];
+	#endif
+	
+	struct rtl_multicastFwdInfo multicastFwdInfo;
+	uint32 refreshTime;
+};
+#else
+struct rtl_groupEntry
+{
+	struct rtl_groupEntry *previous;
+	struct rtl_groupEntry  *next;             /*Pointer of next group entry*/
+	struct rtl_sourceEntry *sourceList;
+	uint32 ipVersion;
+	#ifdef CONFIG_RTL_MLD_SNOOPING
+	uint32 groupAddr[4];
+	#else
+	uint32 groupAddr[1];
+	#endif
+	uint32 groupFilterTimer[MAX_SUPPORT_PORT_NUMBER];
+	
+};
+
+struct rtl_sourceEntry
+{
+	#ifdef CONFIG_RTL_MLD_SNOOPING
+	uint32 sourceAddr[4];                       /*D class IP multicast address*/
+	#else
+	uint32 sourceAddr[1];                       /*D class IP multicast address*/
+	#endif
+	struct rtl_sourceEntry *previous; 
+	struct rtl_sourceEntry *next;             /*Pointer of next group entry*/
+	uint32 portTimer[MAX_SUPPORT_PORT_NUMBER];   
+};
+#endif
+
+struct rtl_mcastRouter
+{	
+	uint32 portTimer[MAX_SUPPORT_PORT_NUMBER];
+};
+
+
+struct rtl_macFrameInfo
+{
+	uint8   ipVersion;
+
+	uint32 srcIpAddr[4];
+	uint32 dstIpAddr[4];
+
+	uint8 *ipBuf;
+	uint16   ipHdrLen;
+	uint8   l3Protocol;
+	uint8 checksumFlag;
+	uint8 *l3PktBuf;
+	uint16 l3PktLen;
+	uint16 macFrameLen;
+	uint16 vlanTagFlag;
+	uint16 vlanTagID;
+	uint8 srcMacAddr[6];
+
+};
+
+
+struct rtl_multicastRouters
+{
+	 struct rtl_mcastRouter querier;
+	 struct rtl_mcastRouter dvmrpRouter;
+	 struct rtl_mcastRouter mospfRouter;
+	 struct rtl_mcastRouter pimRouter;
+	 		 
+};
+#ifdef CONFIG_NEW_IGMP_IMPLEMENTATION
+//#define CONFIG_RECORD_MCAST_FLOW
+#endif
+
+struct rtl_multicastModule
+{
+	uint8 enableSnooping;
+#ifdef CONFIG_NEW_IGMP_IMPLEMENTATION
+#else
+	uint8 enableSourceList;
+#endif
+	uint8 enableFastLeave;
+
+	uint32 ipv4UnknownMCastFloodMap;
+#ifdef CONFIG_RTL_MLD_SNOOPING		
+	uint32 ipv6UnknownMCastFloodMap;
+#endif
+	uint32 staticRouterPortMask;
+	
+	rtl_multicastDeviceInfo_t deviceInfo;
+
+	struct rtl_multicastRouters rtl_ipv4MulticastRouters;
+#ifdef CONFIG_RTL_MLD_SNOOPING	
+	struct rtl_multicastRouters rtl_ipv6MulticastRouters;
+#endif
+
+	/*gateway infomation*/
+	uint8 rtl_gatewayMac[6];
+	uint32 rtl_gatewayIpv4Addr;
+	
+#ifdef CONFIG_RTL_MLD_SNOOPING	
+	uint32 rtl_gatewayIpv6Addr[4];
+#endif
+
+
+	/*hash table definition*/
+	struct rtl_groupEntry ** rtl_ipv4HashTable;
+
+#ifdef CONFIG_RTL_MLD_SNOOPING	
+	struct rtl_groupEntry ** rtl_ipv6HashTable;
+#endif
+
+#ifdef CONFIG_RECORD_MCAST_FLOW
+	struct rtl_mcastFlowEntry **flowHashTable;
+#endif
+#ifdef CONFIG_PROC_FS
+	 unsigned int expireEventCnt;
+#endif
+
+};
+
+
+#endif 
+
diff --git a/drivers/net/rtl819x/igmpsnooping/rtl865x_igmpsnooping_new.c b/drivers/net/rtl819x/igmpsnooping/rtl865x_igmpsnooping_new.c
index a9d16c5..e79d6a3 100644
--- a/drivers/net/rtl819x/igmpsnooping/rtl865x_igmpsnooping_new.c
+++ b/drivers/net/rtl819x/igmpsnooping/rtl865x_igmpsnooping_new.c
@@ -1,12 +1,14 @@
 /*
-* Copyright c                  Realsil Semiconductor Corporation, 2009
-* All rights reserved.
-* 
 * Program :  igmp snooping function
 * Abstract : 
 * Author :qinjunjie 
 * Email:qinjunjie1980@hotmail.com
 *
+*  Copyright (c) 2011 Realtek Semiconductor Corp.
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License version 2 as
+*  published by the Free Software Foundation.
 */
 
 #ifdef __linux__
@@ -1106,7 +1108,6 @@ static  void rtl_freeMcastFlowEntry(struct rtl_mcastFlowEntry* mcastFlowEntry)
  *********************************************/
 
 /*       find a group address in a group list    */
-
 struct rtl_groupEntry* rtl_searchGroupEntry(uint32 moduleIndex, uint32 ipVersion,uint32 *multicastAddr)
 {
 	struct rtl_groupEntry* groupPtr = NULL;
@@ -5474,6 +5475,16 @@ int32 rtl_getMulticastDataFwdInfo(uint32 moduleIndex, struct rtl_multicastDataIn
 		return SUCCESS;
 	}
 	#endif
+
+	//added for MDNS packets
+	if ((IS_RESERVE_MULTICAST_MDNS_ADDR_V4(multicastDataInfo->groupAddr[0])&&multicastDataInfo->ipVersion==IP_VERSION4)
+		||(IS_RESERVE_MULTICAST_MDNS_ADDR_V6(multicastDataInfo->groupAddr)&&multicastDataInfo->ipVersion==IP_VERSION6))
+	{
+		multicastFwdInfo->reservedMCast=TRUE;
+		multicastFwdInfo->fwdPortMask=0xFFFFFFFF;
+				
+		return FAILED;
+	}
 	
 	groupEntry=rtl_searchGroupEntry(moduleIndex,multicastDataInfo->ipVersion, multicastDataInfo->groupAddr); 
 
@@ -6190,7 +6201,9 @@ int igmp_show(struct seq_file *s, void *v)
 	int32 flowCnt;
 	struct rtl_mcastFlowEntry *mcastFlowEntry=NULL; 
 	#endif
-
+	#if defined (CONFIG_RTL_MLD_SNOOPING)	
+	int mldVersion;
+	#endif
 	for(moduleIndex=0; moduleIndex<MAX_MCAST_MODULE_NUM ;moduleIndex++)
 	{
 		if(rtl_mCastModuleArray[moduleIndex].enableSnooping==TRUE)
@@ -6321,7 +6334,14 @@ int igmp_show(struct seq_file *s, void *v)
 					clientCnt=0;
 					while (clientEntry!=NULL)
 					{	
-						
+						if(clientEntry->igmpVersion==IGMP_V3)
+						{
+							mldVersion = MLD_V2;
+						}
+						else
+						{
+							mldVersion = MLD_V1;
+						}
 						clientCnt++;
 						seq_printf(s, "        <%d>%x%x%x%x%x%x%x%x-%x%x%x%x%x%x%x%x-%x%x%x%x%x%x%x%x-%x%x%x%x%x%x%x%x\\port %d\\MLDv%d\\",clientCnt,
 							(clientEntry->clientAddr[0])>>28,(clientEntry->clientAddr[0]<<4)>>28, (clientEntry->clientAddr[0]<<8)>>28,(clientEntry->clientAddr[0]<<12)>>28, 
@@ -6332,7 +6352,7 @@ int igmp_show(struct seq_file *s, void *v)
 							(clientEntry->clientAddr[2]<<16)>>28,(clientEntry->clientAddr[2]<<20)>>28,(clientEntry->clientAddr[2]<<24)>>28, (clientEntry->clientAddr[2]<<28)>>28, 
 							(clientEntry->clientAddr[3])>>28,(clientEntry->clientAddr[3]<<4)>>28, (clientEntry->clientAddr[3]<<8)>>28,(clientEntry->clientAddr[3]<<12)>>28, 
 							(clientEntry->clientAddr[3]<<16)>>28,(clientEntry->clientAddr[3]<<20)>>28,(clientEntry->clientAddr[3]<<24)>>28, (clientEntry->clientAddr[3]<<28)>>28, 
-							clientEntry->portNum, clientEntry->igmpVersion);
+							clientEntry->portNum, mldVersion);
 						
 						seq_printf(s, "%s",(clientEntry->groupFilterTimer>rtl_sysUpSeconds)?"EXCLUDE":"INCLUDE");
 						if(clientEntry->groupFilterTimer>rtl_sysUpSeconds)
diff --git a/drivers/net/rtl819x/l2Driver/Makefile b/drivers/net/rtl819x/l2Driver/Makefile
index a9702aa..c2ec19b 100644
--- a/drivers/net/rtl819x/l2Driver/Makefile
+++ b/drivers/net/rtl819x/l2Driver/Makefile
@@ -8,7 +8,7 @@
 # Note 2! The CFLAGS definitions are now in the main makefile...
 #Add mips16 Support
 
-DIR_RTLASIC = $(TOPDIR)/drivers/net/rtl819x/
+DIR_RTLASIC = $(DIR_LINUX)/drivers/net/rtl819x/
 
 ifdef CONFIG_RTL865X_KERNEL_MIPS16_LAYERDRIVER
 	CFLAGS_rtl865x_fdb.o		= -mips16
@@ -21,7 +21,7 @@ endif
 			obj-y += rtl865x_outputQueue.o
 		endif
 	endif
-
+	obj-y += rtl865x_hw_qos_config.o
 ifeq ($(CONFIG_RTL_STP),y)
 	obj-y += rtl865x_stp.o
 endif
diff --git a/drivers/net/rtl819x/l2Driver/rtl865x_fdb.c b/drivers/net/rtl819x/l2Driver/rtl865x_fdb.c
index 264dcc0..94187e8 100644
--- a/drivers/net/rtl819x/l2Driver/rtl865x_fdb.c
+++ b/drivers/net/rtl819x/l2Driver/rtl865x_fdb.c
@@ -1,17 +1,12 @@
-/*      @doc RTL_LAYEREDDRV_API
-
-        @module rtl865x_fdb.c - RTL865x Home gateway controller Layered driver API documentation       |
-        This document explains the API interface of the table driver module. Functions with rtl865x prefix
-        are external functions.
-        @normal Hyking Liu (Hyking_liu@realsil.com.cn) <date>
+/*
+ *
+ *  Copyright (c) 2011 Realtek Semiconductor Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
 
-        Copyright <cp>2008 Realtek<tm> Semiconductor Cooperation, All Rights Reserved.
-
-        @head3 List of Symbols |
-        Here is a list of all functions and variables in this module.
-        
-        @index | RTL_LAYEREDDRV_API
-*/
 
 #include <linux/config.h>
 #include <linux/module.h>
@@ -38,8 +33,16 @@
 #include "rtl865x_fdb.h"
 #include "common/rtl_errno.h"
 
+
+
 #if defined(CONFIG_RTL865X_LANPORT_RESTRICTION)
 lan_restrict_info	lan_restrict_tbl[LAN_RESTRICT_PORT_NUMBER];
+int lan_restrict_tble_reset_port(int port)
+{
+	lan_restrict_tbl[port].curr_num	= 	0;
+	return SUCCESS;
+}
+
 #endif
 
 struct rtl865x_L2Tables sw_FDB_Table;
@@ -255,6 +258,24 @@ int32 rtl_get_hw_fdb_age(uint32 fid,ether_addr_t *mac, uint32 flags)
         return retval;
 }
 
+int32 rtl865x_getPortNum(const unsigned char *addr){
+	ether_addr_t *macAddr;
+	int32 column;
+	rtl865x_tblAsicDrv_l2Param_t	fdbEntry;
+	int8 port_num = -1;
+	//fdb->ageing_timer = 300*HZ;
+	macAddr = (ether_addr_t *)(addr);
+			
+	if (rtl865x_Lookup_fdb_entry(RTL_LAN_FID, macAddr, FDB_DYNAMIC, &column,&fdbEntry) == SUCCESS)
+	{
+		/*find the fdb entry*/
+		port_num = rtl865x_ConvertPortMasktoPortNum(fdbEntry.memberPortMask);
+	} else {
+		/*can't find */
+	}
+	return port_num;
+}
+
 int32 rtl865x_Lookup_fdb_entry(uint32 fid, ether_addr_t *mac, uint32 flags, uint32 *col_num, rtl865x_tblAsicDrv_l2Param_t *L2buff)
 {
 	uint32 rowIdx;
@@ -387,7 +408,14 @@ int32 _rtl865x_removeFilterDatabaseEntry(uint16 fid, ether_addr_t * mac, uint32
 {
 	rtl865x_filterDbTable_t *fdb_t = &sw_FDB_Table.filterDB[fid];
 	rtl865x_filterDbTableEntry_t * l2entry_t ;
-
+	/*printk("rowIdx:%dfid:%d\n",rowIdx,fid);*/
+	/*printk("\n mac address is %x %x %x %x %x %x\n", mac->octet[0],
+													mac->octet[1],
+													mac->octet[2],
+													mac->octet[3],
+													mac->octet[4],
+													mac->octet[5]);
+													*/
 	if (SLIST_FIRST(&(fdb_t->database[rowIdx]))) 
 	{	
 		SLIST_FOREACH(l2entry_t, &(fdb_t->database[rowIdx]), nextFDB) 
@@ -707,7 +735,7 @@ int32 _rtl865x_addFilterDatabaseEntry(uint16 l2Type, uint16 fid,  ether_addr_t *
 /*	if (typeII == RTL8651_L2TBL_COLUMN && l2Type == RTL8651_L2_TYPEII) 
 		return RTL_NOFREEBUFFER;
 */	
-	rtl865x_raiseEvent(EVENT_ADD_FDB, (void *)(l2entry_t));
+	//rtl865x_raiseEvent(EVENT_ADD_FDB, (void *)(l2entry_t));
 	
 	return SUCCESS;
 }
@@ -748,7 +776,7 @@ int32 _rtl865x_delFilterDatabaseEntry(uint16 l2Type, uint16 fid, ether_addr_t *
 	rtl865x_filterDbTableEntry_t * l2entry_t = NULL;
 	rtl865x_filterDbTable_t *fdb_t = &sw_FDB_Table.filterDB[fid];
 	int32 found = FALSE;
-
+	//printk("[%s][%d].\n", __FUNCTION__, __LINE__);
 	rowIdx = rtl8651_filterDbIndex(macAddr, fid);
 
 	L2buff = &L2temp;
@@ -794,7 +822,7 @@ int32 _rtl865x_delFilterDatabaseEntry(uint16 l2Type, uint16 fid, ether_addr_t *
 					 nextFDB
 				);
 				SLIST_INSERT_HEAD(&sw_FDB_Table.freefdbList.filterDBentry, l2entry_t, nextFDB);	
-			
+				
 				rtl865x_raiseEvent(EVENT_DEL_FDB, (void *)(l2entry_t));
 			}
 			break;
@@ -812,7 +840,7 @@ int32 rtl865x_arrangeFdbEntry(const unsigned char *timeout_addr, int32 *port)
 	rtl865x_tblAsicDrv_l2Param_t	fdbEntry;
 	rtl865x_filterDbTableEntry_t		l2temp_entry;
 	int32 rowIdx;
-
+	
 	macAddr = (ether_addr_t *)(timeout_addr);
 	rowIdx = rtl8651_filterDbIndex(macAddr, RTL_LAN_FID);
 	found = rtl865x_Lookup_fdb_entry(RTL_LAN_FID, macAddr, FDB_DYNAMIC, &column, &fdbEntry);
@@ -922,14 +950,14 @@ int32 rtl865x_addFDBEntry(const unsigned char *addr)
 	
 	if (addr == NULL)
 		return RTL_EINVALIDINPUT;
-	
+	//printk("[%s][%d].\n", __FUNCTION__, __LINE__);
 	macAddr = (ether_addr_t *)(addr);
 	found = rtl865x_Lookup_fdb_entry(RTL_LAN_FID, macAddr, FDB_DYNAMIC, &column, &fdbEntry);
 	if (found == SUCCESS )
 	{
 		port_num = rtl865x_ConvertPortMasktoPortNum(fdbEntry.memberPortMask);
-
-/*		printk("\nbefore rtl865x_lookup_FilterDatabaseEntry, port is %d\n", port_num);	*/
+		//printk("[%s][%d].\n", __FUNCTION__, __LINE__);
+		//printk("\nbefore rtl865x_lookup_FilterDatabaseEntry, port is %d\n", port_num);	
 		if (rtl865x_lookup_FilterDatabaseEntry(fdbEntry.fid, macAddr, &l2temp_entry) != SUCCESS)
 		{
 			l2temp_entry.l2type = (fdbEntry.nhFlag==0)?RTL865x_L2_TYPEI: RTL865x_L2_TYPEII;
@@ -949,6 +977,7 @@ int32 rtl865x_addFDBEntry(const unsigned char *addr)
 	}
 	else
 	{
+		//printk("[%s][%d].\n", __FUNCTION__, __LINE__);
 		/*add */
 	}
 	return ret;
@@ -966,7 +995,7 @@ int32 rtl865x_delLanFDBEntry(uint16 l2Type,  const unsigned char *addr)
 	}
 	macAddr = (ether_addr_t *)(addr);
 	
-	ret =_rtl865x_delFilterDatabaseEntry(	l2Type, RTL_LAN_FID, macAddr);		
+	ret =_rtl865x_delFilterDatabaseEntry(l2Type, RTL_LAN_FID, macAddr);		
 
 	return ret;
 }
@@ -974,7 +1003,7 @@ int32 rtl865x_delLanFDBEntry(uint16 l2Type,  const unsigned char *addr)
 int32 rtl865x_ConvertPortMasktoPortNum(int32 portmask)
 {
 	int32 i = 0;
-
+	
 	for (i = PHY0; i < EXT3; i++)
 	{
 		if(((portmask >> i) & 0x01) == 1)
@@ -1045,13 +1074,11 @@ int32 lanrestrict_callbackFn_for_add_fdb(void *param)
 	}
 	
 	fdbEntry=(rtl865x_filterDbTableEntry_t *)param;
-
 	port_num = rtl865x_ConvertPortMasktoPortNum(fdbEntry->memberPortMask);	
 
 	if (lan_restrict_tbl[port_num].enable == TRUE)
 	{
-/*		printk("\nadd authed port[%d], num:%d\n", port_num, lan_restrict_tbl[port_num].curr_num);*/
-		lan_restrict_tbl[port_num].curr_num ++;
+		lan_restrict_tbl[port_num].curr_num ++;	
 	}
 	
 	return SUCCESS;
@@ -1068,16 +1095,15 @@ int32 lanrestrict_callbackFn_for_del_fdb(void *param)
 	}
 	
 	fdbEntry=(rtl865x_filterDbTableEntry_t *)param;
-
 	port_num = rtl865x_ConvertPortMasktoPortNum(fdbEntry->memberPortMask);	
 	if (lan_restrict_tbl[port_num].enable == TRUE)
 	{
-/*		printk("\ndel authed port[%d], num:%d\n", port_num, lan_restrict_tbl[port_num].curr_num);*/
 		lan_restrict_tbl[port_num].curr_num --;
 		if (lan_restrict_tbl[port_num].curr_num < 0)
 		{
 			lan_restrict_tbl[port_num].curr_num = 0;
 		}
+		/*printk("\ndel authed port[%d], num:%d\n", port_num, lan_restrict_tbl[port_num].curr_num);*/
 	}
 	return SUCCESS;
 }
@@ -1119,17 +1145,54 @@ static int32 lanrestrict_authadd_register_event(void)
 	eventParam.eventPriority=0;
 	eventParam.event_action_fn=lanrestrict_callbackFn_for_add_fdb;
 	rtl865x_registerEvent(&eventParam);
+	
+	#if 0
+	if (rtl865x_registerEvent(&eventParam)== SUCCESS)
+	{
+		printk("register Event SUCCESS:%x\n",EVENT_ADD_AUTHED_FDB);
+		return SUCCESS;
+	}
+	else if(rtl865x_registerEvent(&eventParam)== RTL_EENTRYALREADYEXIST)
+	{
+		printk("the Event already exist\n");
+		return SUCCESS;
+	}
+	else
+	{
+		printk("register Event FAILED:%d \n",rtl865x_registerEvent(&eventParam));
+		return FAILED;
+	}
+	#endif
 	return SUCCESS;
 }
 
 static int32 lanrestrict_authdel_register_event(void)
 {
+	
 	rtl865x_event_Param_t eventParam;
 	eventParam.eventLayerId=DEFAULT_LAYER2_EVENT_LIST_ID;
 	eventParam.eventId=EVENT_DEL_AUTHED_FDB;
 	eventParam.eventPriority=0;
 	eventParam.event_action_fn=lanrestrict_callbackFn_for_del_fdb;
 	rtl865x_registerEvent(&eventParam);
+	
+	#if 0
+	if (rtl865x_registerEvent(&eventParam)== SUCCESS)
+	{
+		printk("register Event SUCCESS:%x\n",EVENT_DEL_AUTHED_FDB);
+		return SUCCESS;
+	}
+	else if(rtl865x_registerEvent(&eventParam)== RTL_EENTRYALREADYEXIST)
+	{
+		printk("the Event already exist\n");
+		return SUCCESS;
+	}
+	else
+	{
+		printk("register Event FAILED:%d \n",rtl865x_registerEvent(&eventParam));
+		return FAILED;
+	}
+	#endif
 	return SUCCESS;
 }
 
@@ -1159,6 +1222,7 @@ int32 _rtl865x_addAuthFilterDatabaseEntry(uint16 l2Type, uint16 fid,  ether_addr
 	int32 retval = 0;
 	int32 overwite_blk_flag = FALSE;
 	
+	//printk("auth:%d,srcblk:%d\n",auth,SrcBlk);
 	L2buff = &l2entry_tmp;
 	memset(L2buff,0,sizeof(rtl865x_tblAsicDrv_l2Param_t));
 	rowIdx = rtl8651_filterDbIndex(macAddr, fid);
@@ -1179,6 +1243,7 @@ int32 _rtl865x_addAuthFilterDatabaseEntry(uint16 l2Type, uint16 fid,  ether_addr
 						overwite_blk_flag = TRUE;
 					}
 					found = TRUE;
+					
 					col_tmp = colIdx;
 				}
 				else
@@ -1186,6 +1251,7 @@ int32 _rtl865x_addAuthFilterDatabaseEntry(uint16 l2Type, uint16 fid,  ether_addr
 				{
 					found = FALSE;
 					flag = TRUE;
+					
 				}
 				break;
 			}
@@ -1199,11 +1265,12 @@ int32 _rtl865x_addAuthFilterDatabaseEntry(uint16 l2Type, uint16 fid,  ether_addr
 		else
 		{
 			/*there is still empty l2 asic entry*/
+			
 			flag = TRUE;
 			break;
 		}
 	}
-	
+	/*printk("found:%d,overwite_blk_flag:%d",found, overwite_blk_flag);*/
 	switch(l2Type) {	
 	case RTL865x_L2_TYPEI:
 		nexthp_flag = FALSE;isStatic = FALSE;
@@ -1232,16 +1299,16 @@ int32 _rtl865x_addAuthFilterDatabaseEntry(uint16 l2Type, uint16 fid,  ether_addr
 			break;
 	default: assert(0);
 	}
-	
+
 	if (found == FALSE)
 	{			
 		/*no empty entry, overwrite the biggest aging time asic l2 entry*/
 		if(flag == FALSE)
 		{
 			/*delete the biggest aging time software entry*/
-			rtl8651_getAsicL2Table(rowIdx, col_num, L2buff);			
+			rtl8651_getAsicL2Table(rowIdx, col_num, L2buff);	
+			
 			_rtl865x_removeFilterDatabaseEntry(fid, &(L2buff->macAddr), rowIdx);	
-
 			/*overwrite asic entry*/
 			rtl8651_setAsicL2Table_Patch(
 					rowIdx, 
@@ -1260,6 +1327,7 @@ int32 _rtl865x_addAuthFilterDatabaseEntry(uint16 l2Type, uint16 fid,  ether_addr
 		/*portmask is different , so it should overwrite the original asic entry. Or there is empty entry, set it to asic*/
 		else if(flag == TRUE)
 		{
+			
 			rtl8651_setAsicL2Table_Patch(
 					rowIdx, 
 					colIdx, 
@@ -1278,6 +1346,7 @@ int32 _rtl865x_addAuthFilterDatabaseEntry(uint16 l2Type, uint16 fid,  ether_addr
 	/*find the same asic entry, should update the aging time*/
 	else
 	{
+		
 		rtl8651_setAsicL2Table_Patch(
 				rowIdx, 
 				col_tmp, 
@@ -1317,8 +1386,10 @@ int32 _rtl865x_addAuthFilterDatabaseEntry(uint16 l2Type, uint16 fid,  ether_addr
 */
 
 	if (SLIST_FIRST(&sw_FDB_Table.freefdbList.filterDBentry) == NULL)
+	{
+		
 		return RTL_ENOFREEBUFFER;
-	
+	}
 	/*config the SW l2 entry */
 	l2entry_t = SLIST_FIRST(&sw_FDB_Table.freefdbList.filterDBentry);
 	SLIST_REMOVE_HEAD(&sw_FDB_Table.freefdbList.filterDBentry, nextFDB);
@@ -1371,18 +1442,19 @@ check_swfdb:
 					tmpL2->SrcBlk 			= SrcBlk;
 					tmpL2->memberPortMask	= portMask;
 					tmpL2->l2type 			= l2Type;
-/*					tmpL2 ->refCount = 0;*/
+					/*tmpL2 ->refCount = 0;*/
 					break;
 				}
 				else
 				{
-					goto out;
+					return SUCCESS;
+					//goto out; appear errorr:label used but not defined 
 				}
 			}		
 			/*try to check whether there is timeout sw fdb entry*/
 			else if(tmpL2->asicPos == col_tmp)
 			{
-/*				if ((tmpL2->SrcBlk == TRUE) && (tmpL2->auth == FALSE))*/
+			/*	if ((tmpL2->SrcBlk == TRUE) && (tmpL2->auth == FALSE))*/
 				{
 					_rtl865x_removeFilterDatabaseEntry(fid, &(tmpL2->macAddr), rowIdx);
 					goto check_swfdb;
@@ -1400,6 +1472,7 @@ check_swfdb:
 	else 
 	{
 /*		l2entry_t ->refCount = 0;*/
+		
 		SLIST_INSERT_HEAD(&(fdb_t->database[rowIdx]), l2entry_t, nextFDB);
 	}
 	
@@ -1407,21 +1480,19 @@ check_swfdb:
 /*	if (typeII == RTL8651_L2TBL_COLUMN && l2Type == RTL8651_L2_TYPEII) 
 		return RTL_NOFREEBUFFER;
 */
-	if (!((l2entry_t->SrcBlk == TRUE) && (l2entry_t->auth == FALSE)))
-	{
-		rtl865x_raiseEvent(EVENT_ADD_FDB, (void *)(l2entry_t));
-	}
 
 	if (overwite_blk_flag != TRUE)
 	{
+		/*Add a new entry*/
 		rtl865x_raiseEvent(EVENT_ADD_AUTHED_FDB, (void *)(l2entry_t));
 	}
 	else
 	{
-/*		printk("\nover blk entry, no raise event\n");*/
+			
+		/*printk("\nover blk entry, no raise event\n");*/
 	}
-	
-out:
+		
+//out:
 	return SUCCESS;
 }
 
@@ -1505,7 +1576,8 @@ int32 _rtl865x_addAuthSWl2Entry(uint16 l2Type, uint16 fid,  ether_addr_t * macAd
 				else
 				{
 					SLIST_INSERT_HEAD(&sw_FDB_Table.freefdbList.filterDBentry, l2entry_t, nextFDB);					
-					goto out;
+					//goto out;
+					return SUCCESS;
 				}
 			}		
 			
@@ -1529,19 +1601,17 @@ int32 _rtl865x_addAuthSWl2Entry(uint16 l2Type, uint16 fid,  ether_addr_t * macAd
 		return RTL_NOFREEBUFFER;
 */
 
-	rtl865x_raiseEvent(EVENT_ADD_FDB, (void *)(l2entry_t));
-
-
 	if (overwite_blk_flag != TRUE)
 	{
+		//printk("\nauth:,srcblk:\n",auth,SrcBlk);
 		rtl865x_raiseEvent(EVENT_ADD_AUTHED_FDB, (void *)(l2entry_t));
 	}
 	else
 	{
-/*		printk("\nover blk entry, no raise event\n");*/
+		/*printk("\nNO need to add currnum,over blk entry, no raise event\n");*/
 	}
 	
-out:
+//out:
 	return SUCCESS;
 }
 
@@ -1614,15 +1684,30 @@ int32 _rtl865x_delAuthFilterDatabaseEntry(uint16 l2Type, uint16 fid, ether_addr_
 	rtl865x_filterDbTableEntry_t * l2entry_t = NULL;
 	rtl865x_filterDbTable_t *fdb_t = &sw_FDB_Table.filterDB[fid];
 	int32 found = FALSE;
-
+	
 	rowIdx = rtl8651_filterDbIndex(macAddr, fid);
-
+	/*print message
+	printk("rowIdx%d:\n",rowIdx);
+	printk("fid%d:\n",fid);
+	printk("\n the mac address is %x %x %x %x %x %x\n", macAddr->octet[0],
+													macAddr->octet[1],
+													macAddr->octet[2],
+													macAddr->octet[3],
+													macAddr->octet[4],
+													macAddr->octet[5]);*/
 	L2buff = &L2temp;
 	memset(L2buff, 0 , sizeof (rtl865x_tblAsicDrv_l2Param_t));
 	for(colIdx=0; colIdx<RTL8651_L2TBL_COLUMN; colIdx++) 
 	{
 		if ((rtl8651_getAsicL2Table(rowIdx, colIdx, L2buff))==SUCCESS)
 		{
+			/*printk("\n mac address is %x %x %x %x %x %x\n", L2buff->macAddr.octet[0],
+															L2buff->macAddr.octet[1],
+															L2buff->macAddr.octet[2],
+															L2buff->macAddr.octet[3],
+															L2buff->macAddr.octet[4],
+															L2buff->macAddr.octet[5]);*/
+
 			/*check whether mac address has been learned  to SW or not*/
 			if (memcmp(&(L2buff->macAddr), macAddr, 6)== 0)
 			{	
@@ -1632,32 +1717,74 @@ int32 _rtl865x_delAuthFilterDatabaseEntry(uint16 l2Type, uint16 fid, ether_addr_
 			}
 		}
 	}
-
-	SLIST_FOREACH(l2entry_t, &(fdb_t->database[rowIdx]), nextFDB)			
+	
+	SLIST_FOREACH(l2entry_t, &(fdb_t->database[rowIdx]), nextFDB)
+	{
+		
 	if (!memcmp(&l2entry_t->macAddr, macAddr, sizeof(ether_addr_t))) 
 	{
-/*		l2entry_t->refCount -= 1;*/
-/*		if (l2entry_t->refCount == 0)*/
+	/*		l2entry_t->refCount -= 1;*/
+	/*		if (l2entry_t->refCount == 0)*/
+
+		SLIST_REMOVE(
+			&(fdb_t->database[rowIdx]), 
+			l2entry_t, 
+			 rtl865x_filterDbTableEntry_s,
+			 nextFDB
+		);
+		SLIST_INSERT_HEAD(&sw_FDB_Table.freefdbList.filterDBentry, l2entry_t, nextFDB);
+		if (found == TRUE)
 		{
-			SLIST_REMOVE(
-				&(fdb_t->database[rowIdx]), 
-				l2entry_t, 
-				 rtl865x_filterDbTableEntry_s,
-				 nextFDB
-			);
-			SLIST_INSERT_HEAD(&sw_FDB_Table.freefdbList.filterDBentry, l2entry_t, nextFDB);	
-			if (found == TRUE)
-			{
-				rtl8651_delAsicL2Table(rowIdx, colIdx);
-			}
-			rtl865x_raiseEvent(EVENT_DEL_FDB, (void *)(l2entry_t));	
-/*			printk("raise event EVENT_DEL_AUTHED_FDB : %x", l2entry_t->memberPortMask);*/
-			rtl865x_raiseEvent(EVENT_DEL_AUTHED_FDB, (void *)(l2entry_t));
+			rtl8651_delAsicL2Table(rowIdx, colIdx);
+		}
+		/*printk("l2entry_t->srcblk:%d,l2entry_t->auth:%d\n", l2entry_t->SrcBlk,l2entry_t->auth);*/
+		if ((l2entry_t->SrcBlk == FALSE) && (l2entry_t->auth == TRUE))
+		{	
+			uint32 memberPortMask_t;
+			memberPortMask_t=l2entry_t->memberPortMask;
 
+			/*after del an auth fdb, consider add an auth fdb*/
+
+			#if defined (CONFIG_RTL865X_LANPORT_RESTRICTION) && defined(CONFIG_RTL_LAYERED_DRIVER) && defined(CONFIG_RTL_LAYERED_DRIVER_L2)&& defined(CONFIG_RTL865X_SYNC_L2)
+			{
+				unsigned char swap_addr[ETHER_ADDR_LEN];
+				int32 port_num;
+				/*try to find blocked l2 entry, then set it to authed*/
+				port_num = rtl865x_ConvertPortMasktoPortNum(memberPortMask_t);
+				if (port_num != FAILED)
+				{	
+					/*printk("\ntime out port num is %d\n", port_num);*/
+					if ((lan_restrict_getBlockAddr(port_num, swap_addr)) == SUCCESS)
+					{
+							//struct hlist_head *head = &br->hash[br_mac_hash(swap_addr)];
+							/*									
+							printk("\n arrange block entry is %x %x %x %x %x %x\n", swap_addr[0],
+																	swap_addr[1],
+																	swap_addr[2],
+																	swap_addr[3],
+																	swap_addr[4],
+													 				swap_addr[5]);
+																										
+										*/
+						rtl865x_addAuthFDBEntry(swap_addr, TRUE, port_num, FALSE);
+					}
+					
+				}
+				else
+				{/*port_num==FAILED*/}
+			}						
+			#endif	/* #if defined (CONFIG_RTL865X_LANPORT_RESTRICTION) && defined(CONFIG_RTL_LAYERED_DRIVER) && defined(CONFIG_RTL_LAYERED_DRIVER_L2) && defined(CONFIG_RTL865X_SYNC_L2)	*/	//consider add an auth fdb entry
+				
 		}
-		break;
+
+		//SLIST_INSERT_HEAD(&sw_FDB_Table.freefdbList.filterDBentry, l2entry_t, nextFDB);
+		rtl865x_raiseEvent(EVENT_DEL_FDB, (void *)(l2entry_t));
+		//if(lanrestrict_authdel_register_event()==SUCCESS);
+		rtl865x_raiseEvent(EVENT_DEL_AUTHED_FDB, (void *)(l2entry_t));
+
+	break;
 	}
-	
+	} /*SLIST_FOREACH*/
 	return SUCCESS;	
 }
 
@@ -1668,17 +1795,19 @@ int32 rtl865x_check_authfdbentry_Byport(int32 port_num, const unsigned char  *ma
 	rtl865x_tblAsicDrv_l2Param_t *L2buff, l2temp;
 	rtl865x_filterDbTable_t *fdb_t = &sw_FDB_Table.filterDB[0];
 	rtl865x_filterDbTableEntry_t * l2entry_t ;
-
+	
 	L2buff = &l2temp;
 	memset(L2buff, 0, sizeof(rtl865x_tblAsicDrv_l2Param_t));
 	for(rowIdx=0; rowIdx<RTL8651_L2TBL_ROW; rowIdx++)
 	{
 		if (SLIST_FIRST(&(fdb_t->database[rowIdx]))) 
-		{	
+		{
+			
 			SLIST_FOREACH(l2entry_t, &(fdb_t->database[rowIdx]), nextFDB) 
 			{
-				if ((l2entry_t ->auth == FALSE) && (l2entry_t->SrcBlk == TRUE))
+				if ( (l2entry_t->memberPortMask&(1<<port_num)) && (l2entry_t ->auth == FALSE) && (l2entry_t->SrcBlk == TRUE))
 				{
+					
 					memcpy((ether_addr_t *)macAddr, &(l2entry_t->macAddr), sizeof(ether_addr_t));
 #if 0
 					printk("\nfind block entry, rowIdx is %d, address2 is %x %x %x %x %x %x\n", rowIdx, ((ether_addr_t *)macAddr)->octet[0],
@@ -1700,7 +1829,7 @@ int32 rtl865x_check_authfdbentry_Byport(int32 port_num, const unsigned char  *ma
 	return retval;
 }
 
-int32 rtl865x_addAuthFDBEntry(const unsigned char *addr, int32 auth, int32  port)
+int32 rtl865x_addAuthFDBEntry(const unsigned char *addr, int32 auth, int32  port, int32 srcblk)
 {
 	int32 found = FAILED;
 	ether_addr_t *macAddr;
@@ -1709,25 +1838,25 @@ int32 rtl865x_addAuthFDBEntry(const unsigned char *addr, int32 auth, int32  port
 	int32 column;
 	rtl865x_tblAsicDrv_l2Param_t	fdbEntry;
 	rtl865x_filterDbTableEntry_t		l2temp_entry;
-	int32 srcblk;
+	//int32 srcblk;
 	
 	if (addr == NULL)
 		return RTL_EINVALIDINPUT;
-	
 	macAddr = (ether_addr_t *)(addr);
 	found = rtl865x_Lookup_fdb_entry(RTL_LAN_FID, macAddr, FDB_DYNAMIC, &column, &fdbEntry);
-	if (auth == TRUE)
+	/*if (auth == TRUE)
 		srcblk = FALSE;
 	else
-		srcblk = TRUE;
+		srcblk = TRUE; */
 	
 	if (found == SUCCESS )
 	{
 		port_num = rtl865x_ConvertPortMasktoPortNum(fdbEntry.memberPortMask);
 
-/*		printk("\nbefore rtl865x_lookup_FilterDatabaseEntry, port is %d, auth is %d\n", port_num, auth);	*/
+		//printk("\nbefore rtl865x_lookup_FilterDatabaseEntry, port is %d, auth is %d\n", port_num, auth);	
 		if (rtl865x_lookup_FilterDatabaseEntry(fdbEntry.fid, macAddr, &l2temp_entry) != SUCCESS)
 		{
+			
 			l2temp_entry.l2type = (fdbEntry.nhFlag==0)?RTL865x_L2_TYPEI: RTL865x_L2_TYPEII;
 			l2temp_entry.process = FDB_TYPE_FWD;
 			l2temp_entry.memberPortMask = fdbEntry.memberPortMask;
@@ -1748,6 +1877,7 @@ int32 rtl865x_addAuthFDBEntry(const unsigned char *addr, int32 auth, int32  port
 		{
 			if ((l2temp_entry.auth == FALSE) && (l2temp_entry.SrcBlk == TRUE))
 			{
+				
 				l2temp_entry.l2type = (fdbEntry.nhFlag==0)?RTL865x_L2_TYPEI: RTL865x_L2_TYPEII;
 				l2temp_entry.process = FDB_TYPE_FWD;
 				l2temp_entry.memberPortMask = fdbEntry.memberPortMask;
@@ -1766,10 +1896,11 @@ int32 rtl865x_addAuthFDBEntry(const unsigned char *addr, int32 auth, int32  port
 	else
 	{
 		/*just add sw l2 table */
+		
 		l2temp_entry.l2type = RTL865x_L2_TYPEII;
 		l2temp_entry.process = FDB_TYPE_FWD;
-/*			l2temp_entry.auth = TRUE;*/
-/*			l2temp_entry.SrcBlk = FALSE;*/
+		/*			l2temp_entry.auth = TRUE;*/
+		/*			l2temp_entry.SrcBlk = FALSE;*/
 		memcpy(&(l2temp_entry.macAddr), macAddr, sizeof(ether_addr_t));	
 		ret =_rtl865x_addAuthSWl2Entry(	l2temp_entry.l2type, 
     										0,  
@@ -1783,19 +1914,45 @@ int32 rtl865x_addAuthFDBEntry(const unsigned char *addr, int32 auth, int32  port
 }
 
 
+int32 rtl865x_addAuthFDBEntry_hooks(const unsigned char *addr)
+{
+	int32	port_num;
+	int32	ret;
+	
+	if ((port_num=rtl865x_getPortNum(addr))!= -1)
+	{
+		ret = lan_restrict_CheckStatusByport(port_num);
+		
+			if (ret == RTL_LAN_RESTRICT_STAT2)
+		{
+			//function opened, and should be authed
+			rtl865x_addAuthFDBEntry(addr, TRUE, port_num, FALSE);
+		} else if(ret == RTL_LAN_RESTRICT_STAT1)
+		{
+			//function opened, and set it to block
+			rtl865x_addAuthFDBEntry(addr, FALSE, port_num, TRUE);
+		
+		}else  if(ret == RTL_LAN_RESTRICT_STAT0)
+		{
+			//function not open , no need to be authed
+			rtl865x_addFDBEntry(addr);
+		}
+	}
+	return SUCCESS;
+}
+
+
 int32 rtl865x_delAuthLanFDBEntry(uint16 l2Type,  const unsigned char *addr)
 {
 	int32 ret=FAILED;
 	ether_addr_t *macAddr;	
-
 	if (addr == NULL)
 	{
 		return RTL_EINVALIDINPUT;
 	}
+	
 	macAddr = (ether_addr_t *)(addr);
-		
 	ret =_rtl865x_delAuthFilterDatabaseEntry(	l2Type, RTL_LAN_FID, macAddr);	
-
 	return ret;
 }
 
@@ -1899,6 +2056,7 @@ int32 _rtl865x_ClearFDBEntryByPort(int32 port_num)
 	rtl865x_tblAsicDrv_l2Param_t l2entry_tmp,*L2buff;
 
 	L2buff = &l2entry_tmp;
+	
 	for (i = 0; i < RTL8651_L2TBL_ROW; i++)
 		for (j = 0; j < RTL8651_L2TBL_COLUMN; j++)
 		{
@@ -1915,6 +2073,11 @@ int32 _rtl865x_ClearFDBEntryByPort(int32 port_num)
 			_rtl865x_removeFilterDatabaseEntry(RTL_LAN_FID, &(L2buff->macAddr), i);
 		}
 
+	#if defined(CONFIG_RTL865X_LANPORT_RESTRICTION)
+	/*when link is down, set curr_num of port to 0 */
+	lan_restrict_tble_reset_port(port_num);
+	#endif
+
 	return SUCCESS;		
 
 }
@@ -1922,7 +2085,7 @@ int32 _rtl865x_ClearFDBEntryByPort(int32 port_num)
 int32 rtl865x_LinkChange_Process(void)
 {
 	uint32 i, status;
-
+	
 	/* Check each port. */
 	for ( i = 0; i < RTL8651_MAC_NUMBER; i++ )
 	{
diff --git a/drivers/net/rtl819x/l2Driver/rtl865x_fdb.h b/drivers/net/rtl819x/l2Driver/rtl865x_fdb.h
index 6c2a3e6..b414dd5 100644
--- a/drivers/net/rtl819x/l2Driver/rtl865x_fdb.h
+++ b/drivers/net/rtl819x/l2Driver/rtl865x_fdb.h
@@ -1,125 +1,123 @@
-#ifndef RTL8651_FDB_H
-#define RTL8651_FDB_H
-#define RTL8651_MAC_NUMBER						6
-#define RTL8651_PORT_NUMBER						RTL8651_MAC_NUMBER
-#define RTL8651_MII_PORTNUMBER                 			5
-#define RTL8651_MII_PORTMASK                    			0x20
-#define RTL8651_PHY_NUMBER						5
-//#define RTL8651_AGGREGATOR_NUMBER				(RTL8651_PORT_NUMBER+rtl8651_totalExtPortNum)
-//#define RTL8651_PSOFFLOAD_RESV_PORT				(RTL8651_PORT_NUMBER+rtl8651_totalExtPortNum+1)	/* port reserved for protocol stack offloading */
-#define RTL8651_ALLPORTMASK				((1<<RTL8651_AGGREGATOR_NUMBER)-1)
-#define RTL8651_PHYSICALPORTMASK			((1<<RTL8651_MAC_NUMBER)-1)
-#define RTL8651_L2TBL_ROW					256
-#define RTL8651_L2TBL_COLUMN				4
-#define RTL8651_MAX_AGGREGATION_NUM		1
-#define RTL8651_VLAN_NUMBER				8
-#define RTL865XC_NETINTERFACE_NUMBER		8
-#define RTL865XC_MAC_NETINTERFACE_NUMBER		4
-#define RTL865XC_PORT_NUMBER				9
-#define RTL865XC_VLAN_NUMBER				4096
-#define RTL865XC_LAGHASHIDX_NUMBER			8	/* There are 8 hash values in RTL865xC Link Aggregation. */
-#define RTL8651_CPU_PORTNUMBER			RTL8651_MAC_NUMBER
-
-#define RTL8651_L2_NUMBER				1024 
-
-#define	FDB_TYPE_FWD					0x00 
-#define	FDB_TYPE_SRCBLK				0x01
-#define	FDB_TYPE_DSTBLK				0x02
-#define	FDB_TYPE_TRAPCPU				0x03
-
-#define RTL865x_FDB_NUMBER				4
-#define RTL865x_L2_TYPEI			0x0001		/* Referenced by ARP/PPPoE */
-#define RTL865x_L2_TYPEII			0x0002		/* Referenced by Protocol */
-#define RTL865x_L2_TYPEIII			0x0004		/* Referenced by PCI/Extension Port */
-
-#define RTL865X_FDBENTRY_TIMEOUT		0x1001		/*fdb entry time out*/
-#define RTL865X_FDBENTRY_450SEC		0x1002		/*fdb entry 450s timing*/
-#define RTL865X_FDBENTRY_300SEC		0x1004		/*fdb entry 300s timing*/
-#define RTL865X_FDBENTRY_150SEC		0x1008		/*fdb entry 150s timing*/
-#define RTL865X_FDBENTRY_SWAP			0x1010		/*fdb entry swap */
-#define CONFIG_RTL865X_SYNC_L2		1
-
-//#define CONFIG_RTL865X_LANPORT_RESTRICTION
-/*
-Note:
-1. Entry property toCpu, srcBlocking destination blocking (memberPortMask) and normal forwarding (Neither toCpu nor srcBlocking) are 
-    mutually exclusive. Therefore, only 2-bit to represent this situation. 
-2. All entries are static configuration
-3. Unable to process conflict macAddress entry process, return fail when following operation are conflict with current one.
-*/
-typedef struct rtl865x_filterDbTableEntry_s {
-	ether_addr_t	macAddr;
-	uint16  l2type;			// see bleow definition
-	uint16	process:2,		//0: Normal forwarding, 1: destination blocking 2: source blocking 3: toCpu
-			//Management flag
-			refCount:8,		//Referenced by other table, such as 
-			configToAsic:1,	//This entry is configured to ASIC
-			asicPos:2,		//The entry position of the ASIC. Since rtl8651 only provides 4-entry. Only 2-bit is required
-			SrcBlk:1,
-			auth:1,
-			nhFlag:1;
-	uint16 	vid;				//0: don't care. 1~4094: vid of this entry
-	uint32	linkId;			//For WLAN WDS.
-		//cfliu: What is link Id? link Id is a virtual port number which represents a WDS link for wireless application.
-		//since 8650 uses MII loopback port and 8650B has only 3 ext ports, it is always insufficient to map 8650B ext ports
-		//to typical 8 WDS links.
-
-	uint32	memberPortMask; 
-	SLIST_ENTRY(rtl865x_filterDbTableEntry_s) nextFDB;
-} rtl865x_filterDbTableEntry_t;
-
-
-typedef struct rtl865x_filterDbTable_s {
-	uint16 sid;// Spanning tree ID, 0: CIST id, 1-4096 MST ID
-	uint32 valid:1;	//Whether this filter database is valid
-	SLIST_HEAD(, rtl865x_filterDbTableEntry_s) database[RTL8651_L2TBL_ROW];
-} rtl865x_filterDbTable_t;
-
-struct rtl865x_L2Tables{
-	rtl865x_filterDbTable_t *filterDB;
-	struct freefdbEntryList_s {
-		SLIST_HEAD( _FreeFDBEntry, rtl865x_filterDbTableEntry_s) filterDBentry;
-	} freefdbList;
-};
-int32 rtl865x_layer2_init(void);
-int32 _rtl865x_addFilterDatabaseEntry(uint16 l2Type, uint16 fid, ether_addr_t * macAddr, uint32 type, uint32 portMask, uint8 auth, uint8 SrcBlk);
-int32 _rtl865x_addAuthFilterDatabaseEntry(uint16 l2Type, uint16 fid, ether_addr_t * macAddr, uint32 type, uint32 portMask, uint8 auth, uint8 SrcBlk);
-int32 _rtl865x_delAuthFilterDatabaseEntry(uint16 l2Type, uint16 fid, ether_addr_t * macAddr);
-int32 rtl865x_addAuthFilterDatabaseEntryExtension( uint16 fid, rtl865x_filterDbTableEntry_t * L2entry);
-int32 rtl865x_delAuthFilterDatabaseEntry(uint16 l2Type, uint16 fid, ether_addr_t * macAddr);
-int32 _rtl865x_delFilterDatabaseEntry(uint16 l2Type, uint16 fid, ether_addr_t * macAddr); 
-uint32 rtl865x_getHWL2Index(ether_addr_t * macAddr, uint16 fid);
-int32 rtl865x_setHWL2Table(uint32 row, uint32 column, rtl865x_tblAsicDrv_l2Param_t *l2p);
-int32 rtl865x_getHWL2Table(uint32 row, uint32 column, rtl865x_tblAsicDrv_l2Param_t *l2p);
-int32 rtl865x_refleshHWL2Table(ether_addr_t * macAddr, uint32 flags,uint16 fid);
-extern int32 rtl865x_Lookup_fdb_entry(uint32 fid, ether_addr_t *mac, uint32 flags, uint32 *col_num, rtl865x_tblAsicDrv_l2Param_t *L2buff);
-//int32 rtl865x_addFilterDatabaseEntry( uint32 fid, ether_addr_t * mac, uint32 portmask, uint32 type , uint32 isStatic);
-int32 rtl865x_addFilterDatabaseEntry( uint32 fid, ether_addr_t * mac, uint32 portmask, uint32 type );
-int32 rtl865x_addFilterDatabaseEntryExtension( uint16 fid, rtl865x_filterDbTableEntry_t * L2entry);
-int32 rtl865x_getReserveMacAddr(ether_addr_t *macAddr);
-int32 rtl865x_delFilterDatabaseEntry(uint16 l2Type, uint16 fid, ether_addr_t * macAddr); 
-int32 rtl865x_ConvertPortMasktoPortNum(int32 portmask);
-int32 rtl865x_delLanFDBEntry(uint16 l2Type,  const unsigned char *addr);
-int32 rtl865x_delAuthLanFDBEntry(uint16 l2Type,  const unsigned char *addr);
-int32 rtl865x_addFDBEntry(const unsigned char *addr);
-int32 rtl865x_arrangeFdbEntry(const unsigned char *timeout_addr, int32 *port);
-int32 rtl865x_lookup_FilterDatabaseEntry(uint16 fid, ether_addr_t * mac, rtl865x_filterDbTableEntry_t *l2_entry);
-
-#ifdef CONFIG_RTL_LINKCHG_PROCESS
-int32 rtl865x_LinkChange_Process(void);
-#endif
-
-#define CONFIG_RTL_CUSTOM_PASSTHRU
-//#define CONFIG_RTL_CUSTOM_PASSTHRU_PPPOE
-#ifdef CONFIG_RTL_CUSTOM_PASSTHRU
-#define PASSTHRU_VLAN_ID 100
-
-#define IP6_PASSTHRU_RULEID 5
-#define PPPOE_PASSTHRU_RULEID1 3
-#define PPPOE_PASSTHRU_RULEID2 4
-#define IP6_PASSTHRU_MASK 0x1
-#define PPPOE_PASSTHRU_MASK 0x1<<1
-#endif
-
-#endif
-
+#ifndef RTL8651_FDB_H
+#define RTL8651_FDB_H
+#define RTL8651_MAC_NUMBER						6
+#define RTL8651_PORT_NUMBER						RTL8651_MAC_NUMBER
+#define RTL8651_MII_PORTNUMBER                 			5
+#define RTL8651_MII_PORTMASK                    			0x20
+#define RTL8651_PHY_NUMBER						5
+//#define RTL8651_AGGREGATOR_NUMBER				(RTL8651_PORT_NUMBER+rtl8651_totalExtPortNum)
+//#define RTL8651_PSOFFLOAD_RESV_PORT				(RTL8651_PORT_NUMBER+rtl8651_totalExtPortNum+1)	/* port reserved for protocol stack offloading */
+#define RTL8651_ALLPORTMASK				((1<<RTL8651_AGGREGATOR_NUMBER)-1)
+#define RTL8651_PHYSICALPORTMASK			((1<<RTL8651_MAC_NUMBER)-1)
+#define RTL8651_L2TBL_ROW					256
+#define RTL8651_L2TBL_COLUMN				4
+#define RTL8651_MAX_AGGREGATION_NUM		1
+#define RTL8651_VLAN_NUMBER				8
+#define RTL865XC_NETINTERFACE_NUMBER		8
+#define RTL865XC_MAC_NETINTERFACE_NUMBER		4
+#define RTL865XC_PORT_NUMBER				9
+#define RTL865XC_VLAN_NUMBER				4096
+#define RTL865XC_LAGHASHIDX_NUMBER			8	/* There are 8 hash values in RTL865xC Link Aggregation. */
+#define RTL8651_CPU_PORTNUMBER			RTL8651_MAC_NUMBER
+
+#define RTL8651_L2_NUMBER				1024 
+
+#define	FDB_TYPE_FWD					0x00 
+#define	FDB_TYPE_SRCBLK				0x01
+#define	FDB_TYPE_DSTBLK				0x02
+#define	FDB_TYPE_TRAPCPU				0x03
+
+#define RTL865X_FDBENTRY_TIMEOUT		0x1001		/*fdb entry time out*/
+#define RTL865X_FDBENTRY_450SEC		0x1002		/*fdb entry 450s timing*/
+#define RTL865X_FDBENTRY_300SEC		0x1004		/*fdb entry 300s timing*/
+#define RTL865X_FDBENTRY_150SEC		0x1008		/*fdb entry 150s timing*/
+#define RTL865X_FDBENTRY_SWAP			0x1010		/*fdb entry swap */
+#define CONFIG_RTL865X_SYNC_L2		1
+
+//#define CONFIG_RTL865X_LANPORT_RESTRICTION
+/*
+Note:
+1. Entry property toCpu, srcBlocking destination blocking (memberPortMask) and normal forwarding (Neither toCpu nor srcBlocking) are 
+    mutually exclusive. Therefore, only 2-bit to represent this situation. 
+2. All entries are static configuration
+3. Unable to process conflict macAddress entry process, return fail when following operation are conflict with current one.
+*/
+typedef struct rtl865x_filterDbTableEntry_s {
+	ether_addr_t	macAddr;
+	uint16  l2type;			// see bleow definition
+	uint16	process:2,		//0: Normal forwarding, 1: destination blocking 2: source blocking 3: toCpu
+			//Management flag
+			refCount:8,		//Referenced by other table, such as 
+			configToAsic:1,	//This entry is configured to ASIC
+			asicPos:2,		//The entry position of the ASIC. Since rtl8651 only provides 4-entry. Only 2-bit is required
+			SrcBlk:1,
+			auth:1,
+			nhFlag:1;
+	uint16 	vid;				//0: don't care. 1~4094: vid of this entry
+	uint32	linkId;			//For WLAN WDS.
+		//cfliu: What is link Id? link Id is a virtual port number which represents a WDS link for wireless application.
+		//since 8650 uses MII loopback port and 8650B has only 3 ext ports, it is always insufficient to map 8650B ext ports
+		//to typical 8 WDS links.
+
+	uint32	memberPortMask; 
+	SLIST_ENTRY(rtl865x_filterDbTableEntry_s) nextFDB;
+} rtl865x_filterDbTableEntry_t;
+
+
+typedef struct rtl865x_filterDbTable_s {
+	uint16 sid;// Spanning tree ID, 0: CIST id, 1-4096 MST ID
+	uint32 valid:1;	//Whether this filter database is valid
+	SLIST_HEAD(, rtl865x_filterDbTableEntry_s) database[RTL8651_L2TBL_ROW];
+} rtl865x_filterDbTable_t;
+
+struct rtl865x_L2Tables{
+	rtl865x_filterDbTable_t *filterDB;
+	struct freefdbEntryList_s {
+		SLIST_HEAD( _FreeFDBEntry, rtl865x_filterDbTableEntry_s) filterDBentry;
+	} freefdbList;
+};
+
+// int32 rtl865x_arp_register_event(void);
+
+int32 rtl865x_layer2_init(void);
+int32 _rtl865x_addFilterDatabaseEntry(uint16 l2Type, uint16 fid, ether_addr_t * macAddr, uint32 type, uint32 portMask, uint8 auth, uint8 SrcBlk);
+int32 _rtl865x_addAuthFilterDatabaseEntry(uint16 l2Type, uint16 fid, ether_addr_t * macAddr, uint32 type, uint32 portMask, uint8 auth, uint8 SrcBlk);
+int32 _rtl865x_delAuthFilterDatabaseEntry(uint16 l2Type, uint16 fid, ether_addr_t * macAddr);
+int32 rtl865x_addAuthFilterDatabaseEntryExtension( uint16 fid, rtl865x_filterDbTableEntry_t * L2entry);
+int32 rtl865x_delAuthFilterDatabaseEntry(uint16 l2Type, uint16 fid, ether_addr_t * macAddr);
+int32 _rtl865x_delFilterDatabaseEntry(uint16 l2Type, uint16 fid, ether_addr_t * macAddr); 
+uint32 rtl865x_getHWL2Index(ether_addr_t * macAddr, uint16 fid);
+int32 rtl865x_setHWL2Table(uint32 row, uint32 column, rtl865x_tblAsicDrv_l2Param_t *l2p);
+int32 rtl865x_getHWL2Table(uint32 row, uint32 column, rtl865x_tblAsicDrv_l2Param_t *l2p);
+int32 rtl865x_refleshHWL2Table(ether_addr_t * macAddr, uint32 flags,uint16 fid);
+extern int32 rtl865x_Lookup_fdb_entry(uint32 fid, ether_addr_t *mac, uint32 flags, uint32 *col_num, rtl865x_tblAsicDrv_l2Param_t *L2buff);
+//int32 rtl865x_addFilterDatabaseEntry( uint32 fid, ether_addr_t * mac, uint32 portmask, uint32 type , uint32 isStatic);
+int32 rtl865x_addFilterDatabaseEntry( uint32 fid, ether_addr_t * mac, uint32 portmask, uint32 type );
+int32 rtl865x_addFilterDatabaseEntryExtension( uint16 fid, rtl865x_filterDbTableEntry_t * L2entry);
+int32 rtl865x_getReserveMacAddr(ether_addr_t *macAddr);
+int32 rtl865x_delFilterDatabaseEntry(uint16 l2Type, uint16 fid, ether_addr_t * macAddr); 
+int32 rtl865x_ConvertPortMasktoPortNum(int32 portmask);
+int32 rtl865x_delLanFDBEntry(uint16 l2Type,  const unsigned char *addr);
+int32 rtl865x_delAuthLanFDBEntry(uint16 l2Type,  const unsigned char *addr);
+int32 rtl865x_addFDBEntry(const unsigned char *addr);
+int32 rtl865x_arrangeFdbEntry(const unsigned char *timeout_addr, int32 *port);
+int32 rtl865x_lookup_FilterDatabaseEntry(uint16 fid, ether_addr_t * mac, rtl865x_filterDbTableEntry_t *l2_entry);
+
+#ifdef CONFIG_RTL_LINKCHG_PROCESS
+int32 rtl865x_LinkChange_Process(void);
+#endif
+
+#define CONFIG_RTL_CUSTOM_PASSTHRU
+//#define CONFIG_RTL_CUSTOM_PASSTHRU_PPPOE
+#ifdef CONFIG_RTL_CUSTOM_PASSTHRU
+#define PASSTHRU_VLAN_ID 100
+
+#define IP6_PASSTHRU_RULEID 5
+#define PPPOE_PASSTHRU_RULEID1 3
+#define PPPOE_PASSTHRU_RULEID2 4
+#define IP6_PASSTHRU_MASK 0x1
+#define PPPOE_PASSTHRU_MASK 0x1<<1
+#endif
+
+#endif
+
diff --git a/drivers/net/rtl819x/l2Driver/rtl865x_outputQueue.c b/drivers/net/rtl819x/l2Driver/rtl865x_outputQueue.c
index ce1afe9..f73099b 100644
--- a/drivers/net/rtl819x/l2Driver/rtl865x_outputQueue.c
+++ b/drivers/net/rtl819x/l2Driver/rtl865x_outputQueue.c
@@ -1,18 +1,12 @@
+/*
+ *
+ *  Copyright (c) 2011 Realtek Semiconductor Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
 
-/*      @doc RTL_LAYEREDDRV_API
-
-        @module rtl865x_outputQueue.c - RTL865x Home gateway controller Layered driver API documentation       |
-        This document explains the API interface of the table driver module. Functions with rtl865x prefix
-        are external functions.
-        @normal Hyking Liu (Hyking_liu@realsil.com.cn) <date>
-
-        Copyright <cp>2008 Realtek<tm> Semiconductor Cooperation, All Rights Reserved.
-
-        @head3 List of Symbols |
-        Here is a list of all functions and variables in this module.
-        
-        @index | RTL_LAYEREDDRV_API
-*/
 #include <linux/config.h>
 #include <net/rtl/rtl_types.h>
 #include <net/rtl/rtl_glue.h>
@@ -77,6 +71,7 @@ static uint32	priority2HandleMapping[NETIF_NUMBER][TOTAL_VLAN_PRIORITY_NUM] = {{
 static rtl_qos_mark_info_t	mark2Priority[NETIF_NUMBER][MAX_MARK_NUM_PER_DEV] = {{{0}}};
 
 rtl865x_qos_rule_t		*rtl865x_qosRuleHead = NULL;
+extern int hw_qos_init_netlink(void);
 static int32 _rtl865x_qosArrangeRuleByNetif(uint8 *netIfName);
 	
 int32 rtl865x_qosSetBandwidth(uint8 *netIfName, uint32 bps)
@@ -1116,6 +1111,8 @@ int __init rtl865x_initOutputQueue(uint8 **netIfName)
 	rtl8651_flushAsicDot1qAbsolutelyPriority();
 #endif
 
+	hw_qos_init_netlink();
+
 	for(i =0; i < RTL8651_OUTPUTQUEUE_SIZE; i++)
 	{
 		for(j=PHY0;j<=CPU;j++)
diff --git a/drivers/net/rtl819x/l2Driver/rtl865x_stp.c b/drivers/net/rtl819x/l2Driver/rtl865x_stp.c
index 2b84d82..c96580f 100644
--- a/drivers/net/rtl819x/l2Driver/rtl865x_stp.c
+++ b/drivers/net/rtl819x/l2Driver/rtl865x_stp.c
@@ -1,44 +1,38 @@
-/*add by lu yang*/
-/*      @doc RTL_LAYEREDDRV_API
-
-        @module rtl865x_stp.c - RTL865x Home gateway controller Layered driver API documentation       |
-        This document explains the API interface of the table driver module. Functions with rtl865x prefix
-        are external functions.
-        @normal Hyking Liu (Hyking_liu@realsil.com.cn) <date>
-
-        Copyright <cp>2008 Realtek<tm> Semiconductor Cooperation, All Rights Reserved.
-
-        @head3 List of Symbols |
-        Here is a list of all functions and variables in this module.
-        
-        @index | RTL_LAYEREDDRV_API
-*/
-
-//#include "rtl_utils.h"
-#include <net/rtl/rtl_types.h>
-#include <net/rtl/rtl_glue.h>
-#include "AsicDriver/asicRegs.h"
-#ifdef CONFIG_RTL_LAYERED_ASIC_DRIVER
-#include "AsicDriver/rtl865x_asicCom.h"
-#include "AsicDriver/rtl865x_asicL2.h"
-#else
-#include <common/rtl8651_aclLocal.h>
-#include <AsicDriver/rtl865xC_tblAsicDrv.h>
-#endif
-
-#include <net/rtl/rtk_stp.h>
-
-int32 rtl865x_setSpanningEnable(int8 spanningTreeEnabled)
-{
-	return rtl8651_setAsicSpanningEnable(spanningTreeEnabled);
-}
-
-int32 rtl865x_setSpanningTreePortState(uint32 port, uint32 portState)
-{
-	return rtl865xC_setAsicSpanningTreePortState(port,  portState);
-}
-
-int32 rtl865x_setMulticastSpanningTreePortState(uint32 port, uint32 portState)
-{
-	return rtl8651_setAsicMulticastSpanningTreePortState(port, portState);
-}
+/*
+ *
+ *  Copyright (c) 2011 Realtek Semiconductor Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+
+//#include "rtl_utils.h"
+#include <net/rtl/rtl_types.h>
+#include <net/rtl/rtl_glue.h>
+#include "AsicDriver/asicRegs.h"
+#ifdef CONFIG_RTL_LAYERED_ASIC_DRIVER
+#include "AsicDriver/rtl865x_asicCom.h"
+#include "AsicDriver/rtl865x_asicL2.h"
+#else
+#include <common/rtl8651_aclLocal.h>
+#include <AsicDriver/rtl865xC_tblAsicDrv.h>
+#endif
+
+#include <net/rtl/rtk_stp.h>
+
+int32 rtl865x_setSpanningEnable(int8 spanningTreeEnabled)
+{
+	return rtl8651_setAsicSpanningEnable(spanningTreeEnabled);
+}
+
+int32 rtl865x_setSpanningTreePortState(uint32 port, uint32 portState)
+{
+	return rtl865xC_setAsicSpanningTreePortState(port,  portState);
+}
+
+int32 rtl865x_setMulticastSpanningTreePortState(uint32 port, uint32 portState)
+{
+	return rtl8651_setAsicMulticastSpanningTreePortState(port, portState);
+}
diff --git a/drivers/net/rtl819x/l3Driver/Makefile b/drivers/net/rtl819x/l3Driver/Makefile
index ad10ae6..6db70ac 100644
--- a/drivers/net/rtl819x/l3Driver/Makefile
+++ b/drivers/net/rtl819x/l3Driver/Makefile
@@ -8,7 +8,7 @@
 # Note 2! The CFLAGS definitions are now in the main makefile...
 #Add mips16 Support
 
-DIR_RTLASIC = $(TOPDIR)/drivers/net/rtl819x/
+DIR_RTLASIC = $(DIR_LINUX)/drivers/net/rtl819x/
 ifdef CONFIG_RTL865X_KERNEL_MIPS16_LAYERDRIVER
 	CFLAGS_rtl865x_arp.o 		= -mips16
 	CFLAGS_rtl865x_ip.o		= -mips16
diff --git a/drivers/net/rtl819x/l3Driver/rtl865x_multicast.c b/drivers/net/rtl819x/l3Driver/rtl865x_multicast.c
index 8720738..83a9e8c 100644
--- a/drivers/net/rtl819x/l3Driver/rtl865x_multicast.c
+++ b/drivers/net/rtl819x/l3Driver/rtl865x_multicast.c
@@ -1,1795 +1,1791 @@
-
-
-/*      @doc RTL_LAYEREDDRV_API
-
-        @module rtl865x_multicast.c - RTL865x Home gateway controller Layered driver API documentation       |
-        This document explains the API interface of the table driver module. Functions with rtl865x prefix
-        are external functions.
-        @normal Hyking Liu (Hyking_liu@realsil.com.cn) <date>
-
-        Copyright <cp>2008 Realtek<tm> Semiconductor Cooperation, All Rights Reserved.
-
-        @head3 List of Symbols |
-        Here is a list of all functions and variables in this module.
-        
-        @index | RTL_LAYEREDDRV_API
-*/
-
+/*
+ *
+ *  Copyright (c) 2011 Realtek Semiconductor Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
 #ifdef __linux__
-#include <linux/config.h>
-#include <linux/jiffies.h>
-#include <linux/timer.h>
-#include <linux/proc_fs.h>
-#endif
-
-
-
+#include <linux/config.h>
+#include <linux/jiffies.h>
+#include <linux/timer.h>
+#include <linux/proc_fs.h>
+#endif
+
+
+
 #include <net/rtl/rtl_types.h>
 #include <net/rtl/rtl_glue.h>
-//#include "common/rtl_utils.h"
-//#include "common/assert.h"
-
-#ifdef CONFIG_RTL_LAYERED_ASIC_DRIVER
-#include "AsicDriver/rtl865x_asicCom.h"
-#include "AsicDriver/rtl865x_asicL3.h"
-#else
-#include "AsicDriver/rtl865xC_tblAsicDrv.h" 
-#include "common/rtl865x_tblDrvPatch.h"
-#endif
-
-#include "AsicDriver/asicRegs.h"
-#include "AsicDriver/asicTabs.h"
-
-#include "common/rtl8651_tblDrvProto.h"
-
-#include "common/rtl865x_eventMgr.h"
-#include "common/rtl865x_vlan.h"
+//#include "common/rtl_utils.h"
+//#include "common/assert.h"
+
+#ifdef CONFIG_RTL_LAYERED_ASIC_DRIVER
+#include "AsicDriver/rtl865x_asicCom.h"
+#include "AsicDriver/rtl865x_asicL3.h"
+#else
+#include "AsicDriver/rtl865xC_tblAsicDrv.h" 
+#include "common/rtl865x_tblDrvPatch.h"
+#endif
+
+#include "AsicDriver/asicRegs.h"
+#include "AsicDriver/asicTabs.h"
+
+#include "common/rtl8651_tblDrvProto.h"
+
+#include "common/rtl865x_eventMgr.h"
+#include "common/rtl865x_vlan.h"
 #include <net/rtl/rtl865x_netif.h>
-
-#include "l3Driver/rtl865x_ip.h"
-
-#ifdef RTL865X_TEST
-#include <string.h>
-#endif
-
+
+#include "l3Driver/rtl865x_ip.h"
+
+#ifdef RTL865X_TEST
+#include <string.h>
+#endif
+
 #include <net/rtl/rtl865x_multicast.h>
 #include <net/rtl/rtl865x_igmpsnooping.h>
-/********************************************************/
-/*			Multicast Related Global Variable			*/
-/********************************************************/
-
-static rtl865x_mcast_fwd_descriptor_t *rtl865x_mcastFwdDescPool=NULL;
-static mcast_fwd_descriptor_head_t  free_mcast_fwd_descriptor_head;
-static struct rtl865x_multicastTable mCastTbl;
-static uint32 rtl865x_externalMulticastPortMask = 0;
-#if defined(__linux__) && defined(__KERNEL__)
-static struct timer_list rtl865x_mCastSysTimer;	/*igmp timer*/
-#endif
-
-static int32 _rtl865x_initMCastFwdDescPool(void)
-{
-	int32 i;
-
-
-	MC_LIST_INIT(&free_mcast_fwd_descriptor_head);
-
-	TBL_MEM_ALLOC(rtl865x_mcastFwdDescPool, rtl865x_mcast_fwd_descriptor_t,MAX_MCAST_FWD_DESCRIPTOR_CNT);
-	
-	if(rtl865x_mcastFwdDescPool!=NULL)
-	{
-		memset( rtl865x_mcastFwdDescPool, 0, MAX_MCAST_FWD_DESCRIPTOR_CNT * sizeof(rtl865x_mcast_fwd_descriptor_t));	
-	}
-	else
-	{
-		return FAILED;
-	}
-	
-	for(i = 0; i<MAX_MCAST_FWD_DESCRIPTOR_CNT;i++)
-	{
-		MC_LIST_INSERT_HEAD(&free_mcast_fwd_descriptor_head, &rtl865x_mcastFwdDescPool[i], next);
-	}
-	
-	return SUCCESS;
-}
-
-static rtl865x_mcast_fwd_descriptor_t *_rtl865x_allocMCastFwdDesc(void)
-{
-	rtl865x_mcast_fwd_descriptor_t *retDesc=NULL;
-	retDesc = MC_LIST_FIRST(&free_mcast_fwd_descriptor_head);
-	if(retDesc!=NULL)
-	{
-		MC_LIST_REMOVE(retDesc, next);
-		memset(retDesc,0,sizeof(rtl865x_mcast_fwd_descriptor_t));
-	}
-	return retDesc;
-}
-
-static int32 _rtl865x_freeMCastFwdDesc(rtl865x_mcast_fwd_descriptor_t *descPtr)
-{
-	if(descPtr==NULL)
-	{
-		return SUCCESS;
-	}
-	memset(descPtr,0,sizeof(rtl865x_mcast_fwd_descriptor_t));
-	MC_LIST_INSERT_HEAD(&free_mcast_fwd_descriptor_head, descPtr, next);
-	
-	return SUCCESS;
-}
-
-static int32 _rtl865x_flushMCastFwdDescChain(mcast_fwd_descriptor_head_t * descChainHead)
-{
-	rtl865x_mcast_fwd_descriptor_t * curDesc,*nextDesc;
-	
-	if(descChainHead==NULL)
-	{
-		return SUCCESS;
-	}
-	
-	curDesc=MC_LIST_FIRST(descChainHead);
-	while(curDesc)
-	{
-		nextDesc=MC_LIST_NEXT(curDesc, next );
-		/*remove from the old descriptor chain*/
-		MC_LIST_REMOVE(curDesc, next);
-		/*return to the free descriptor chain*/
-		_rtl865x_freeMCastFwdDesc(curDesc);
-		curDesc = nextDesc;
-	}
-
-	return SUCCESS;
-}
-
-
-
-static int32 _rtl865x_mCastFwdDescEnqueue(mcast_fwd_descriptor_head_t * queueHead,
-												rtl865x_mcast_fwd_descriptor_t * enqueueDesc)
-{
-
-	rtl865x_mcast_fwd_descriptor_t *newDesc;
-	rtl865x_mcast_fwd_descriptor_t *curDesc,*nextDesc;
-	if(queueHead==NULL)
-	{
-		return FAILED;
-	}
-	
-	if(enqueueDesc==NULL)
-	{
-		return SUCCESS;
-	}
-	
-	/*multicast forward descriptor is internal maintained,always alloc new one*/
-	newDesc=_rtl865x_allocMCastFwdDesc();
-	
-	if(newDesc!=NULL)
-	{
-		memcpy(newDesc, enqueueDesc,sizeof(rtl865x_mcast_fwd_descriptor_t ));
-		//memset(&(newDesc->next), 0, sizeof(MC_LIST_ENTRY(rtl865x_mcast_fwd_descriptor_s)));
-		newDesc->next.le_next=NULL;
-		newDesc->next.le_prev=NULL;
-	}
-	else
-	{
-		/*no enough memory*/
-		return FAILED;
-	}
-	
-
-	for(curDesc=MC_LIST_FIRST(queueHead);curDesc!=NULL;curDesc=nextDesc)
-	{
-
-		nextDesc=MC_LIST_NEXT(curDesc, next);
-		
-		/*merge two descriptor*/
-	//	if((strcmp(curDesc->netifName,newDesc->netifName)==0) && (curDesc->vid==newDesc->vid))
-		if(strcmp(curDesc->netifName,newDesc->netifName)==0)
-		{	
-			
-			if(newDesc->descPortMask==0)
-			{
-				newDesc->descPortMask=curDesc->descPortMask;
-			}
-			MC_LIST_REMOVE(curDesc, next);
-			_rtl865x_freeMCastFwdDesc(curDesc);
-			
-		}
-	}
-
-	/*not matched descriptor is found*/
-	MC_LIST_INSERT_HEAD(queueHead, newDesc, next);
-
-	return SUCCESS;
-	
-}
-
-
-static int32 _rtl865x_mergeMCastFwdDescChain(mcast_fwd_descriptor_head_t * targetChainHead ,
-													rtl865x_mcast_fwd_descriptor_t *srcChain)
-{
-	rtl865x_mcast_fwd_descriptor_t *curDesc;
-
-	if(targetChainHead==NULL)
-	{
-		return FAILED;
-	}
-	
-	for(curDesc=srcChain; curDesc!=NULL; curDesc=MC_LIST_NEXT(curDesc,next))
-	{
-		
-		_rtl865x_mCastFwdDescEnqueue(targetChainHead, curDesc);
-		
-	}
-	
-	return SUCCESS;
-}
-
-
-
-
-static int32 _rtl865x_initMCastEntryPool(void)
-{
-	int32 index;
-	rtl865x_tblDrv_mCast_t *multiCast_t;
-	
-	TBL_MEM_ALLOC(multiCast_t, rtl865x_tblDrv_mCast_t ,MAX_MCAST_TABLE_ENTRY_CNT);
-	TAILQ_INIT(&mCastTbl.freeList.freeMultiCast);
-	for(index=0; index<MAX_MCAST_TABLE_ENTRY_CNT; index++)
-	{
-		memset( &multiCast_t[index], 0, sizeof(rtl865x_tblDrv_mCast_t));
-		TAILQ_INSERT_HEAD(&mCastTbl.freeList.freeMultiCast, &multiCast_t[index], nextMCast);
-	}
-
-	TBL_MEM_ALLOC(multiCast_t, rtl865x_tblDrv_mCast_t, RTL8651_MULTICASTTBL_SIZE);
-	memset(multiCast_t, 0,RTL8651_MULTICASTTBL_SIZE* sizeof(rtl865x_tblDrv_mCast_t));
-	mCastTbl.inuseList.mCastTbl = (void *)multiCast_t;
-
-	for(index=0; index<RTL8651_MULTICASTTBL_SIZE; index++)
-	{
-		TAILQ_INIT(&mCastTbl.inuseList.mCastTbl[index]);
-	}
-
-	return SUCCESS;
-}
-
-static rtl865x_tblDrv_mCast_t * _rtl865x_allocMCastEntry(uint32 hashIndex)
-{
-	rtl865x_tblDrv_mCast_t *newEntry;
-	newEntry=TAILQ_FIRST(&mCastTbl.freeList.freeMultiCast);
-	if (newEntry == NULL)
-	{
-		return NULL;
-	}		
-	
-	TAILQ_REMOVE(&mCastTbl.freeList.freeMultiCast, newEntry, nextMCast);
-
-	
-	/*initialize it*/
-	if(MC_LIST_FIRST(&newEntry->fwdDescChain)!=NULL)
-	{
-		_rtl865x_flushMCastFwdDescChain(&newEntry->fwdDescChain);
-	}
-	MC_LIST_INIT(&newEntry->fwdDescChain);
-	
-	memset(newEntry, 0, sizeof(rtl865x_tblDrv_mCast_t));
-
-	TAILQ_INSERT_TAIL(&mCastTbl.inuseList.mCastTbl[hashIndex], newEntry, nextMCast);
-	
-	return newEntry;
-}
-
-static int32 _rtl865x_flushMCastEntry(rtl865x_tblDrv_mCast_t *mCastEntry)
-{
-	if(mCastEntry==NULL)
-	{
-		return SUCCESS;
-	}
-	
-	_rtl865x_flushMCastFwdDescChain(&mCastEntry->fwdDescChain);
-	
-	memset(mCastEntry, 0, sizeof(rtl865x_tblDrv_mCast_t));
-	return SUCCESS;
-}
-
-static int32 _rtl865x_freeMCastEntry(rtl865x_tblDrv_mCast_t * mCastEntry, uint32 hashIndex)
-{
-	if(mCastEntry==NULL)
-	{
-		return SUCCESS;
-	}
-	
-	TAILQ_REMOVE(&mCastTbl.inuseList.mCastTbl[hashIndex], mCastEntry, nextMCast);
-	_rtl865x_flushMCastEntry(mCastEntry);
-	TAILQ_INSERT_HEAD(&mCastTbl.freeList.freeMultiCast, mCastEntry, nextMCast);
-	return SUCCESS;
-}
-
-
-static uint32 _rtl865x_doMCastEntrySrcVlanPortFilter(rtl865x_tblDrv_mCast_t *mCastEntry)
-{
-	rtl865x_mcast_fwd_descriptor_t * curDesc,*nextDesc;
-	if(mCastEntry==NULL)
-	{
-		return SUCCESS;
-	}
-	
-	for(curDesc=MC_LIST_FIRST(&mCastEntry->fwdDescChain);curDesc!=NULL;curDesc=nextDesc)
-	{
-		nextDesc=MC_LIST_NEXT(curDesc, next);
-		{
-			curDesc->fwdPortMask=curDesc->fwdPortMask & (~(1<<mCastEntry->port));
-			if(curDesc->fwdPortMask==0)
-			{
-				/*remove from the old chain*/
-				MC_LIST_REMOVE(curDesc, next);
-				/*return to the free descriptor chain*/
-				_rtl865x_freeMCastFwdDesc(curDesc);
-
-			}
-		}
-		
-	}
-
-	return SUCCESS;
-}
-
- 
-static uint32 rtl865x_genMCastEntryAsicFwdMask(rtl865x_tblDrv_mCast_t *mCastEntry)
-{
-	uint32 asicFwdPortMask=0;
-	rtl865x_mcast_fwd_descriptor_t * curDesc;
-	if(mCastEntry==NULL)
-	{
-		return 0;
-	}
-	
-	MC_LIST_FOREACH(curDesc, &(mCastEntry->fwdDescChain), next)
-	{
-		if(curDesc->toCpu==0)
-		{
-			asicFwdPortMask|=(curDesc->fwdPortMask & ((1<<RTL8651_MAC_NUMBER)-1));
-		}
-		else
-		{
-			asicFwdPortMask|=( 0x01<<RTL8651_MAC_NUMBER);
-		}
-	}
-	asicFwdPortMask = asicFwdPortMask & (~(1<<mCastEntry->port)); 
-	return asicFwdPortMask;
-}
-
-static uint16 rtl865x_genMCastEntryCpuFlag(rtl865x_tblDrv_mCast_t *mCastEntry)
-{
-	uint16 cpuFlag=FALSE;
-	rtl865x_mcast_fwd_descriptor_t * curDesc;
-	if(mCastEntry==NULL)
-	{
-		return 0;
-	}
-
-	if(mCastEntry->cpuHold==TRUE)
-	{
-		cpuFlag=TRUE;
-	}
-	
-	MC_LIST_FOREACH(curDesc, &(mCastEntry->fwdDescChain), next)
-	{
-		if(	(curDesc->toCpu==TRUE)	||
-			(memcmp(curDesc->netifName, RTL_WLAN_NAME,4)==0)	)
-		{
-			cpuFlag=TRUE;
-		}
-	}
-	
-	return cpuFlag;
-}
-
-/*for linux bridge level igmp snooping usage*/
-static uint32 rtl865x_getMCastEntryDescPortMask(rtl865x_tblDrv_mCast_t *mCastEntry)
-{
-	uint32 descPortMask=0;
-	rtl865x_mcast_fwd_descriptor_t * curDesc;
-	if(mCastEntry==NULL)
-	{
-		return 0;
-	}
-	
-	MC_LIST_FOREACH(curDesc, &(mCastEntry->fwdDescChain), next)
-	{
-		descPortMask=descPortMask | curDesc->descPortMask;
-	}
-	
-	return descPortMask;
-}
-
-
-/*=======================================
-  * Multicast Table APIs
-  *=======================================*/
-#define RTL865X_MULTICASE_TABLE_APIs
-
-static void  _rtl865x_setASICMulticastPortStatus(void) {
-	uint32 index;
-
-	for (index=0; index<RTL8651_PORT_NUMBER+rtl8651_totalExtPortNum; index++) {
-		rtl8651_setAsicMulticastPortInternal(index, (rtl865x_externalMulticastPortMask&(1<<index))?FALSE:TRUE);
-	}
-}
-
-void rtl865x_arrangeMulticastPortStatus(void) {
-
-	rtl865x_externalMulticastPortMask=rtl865x_getExternalPortMask();
-	_rtl865x_setASICMulticastPortStatus();
-}
-
+/********************************************************/
+/*			Multicast Related Global Variable			*/
+/********************************************************/
+
+static rtl865x_mcast_fwd_descriptor_t *rtl865x_mcastFwdDescPool=NULL;
+static mcast_fwd_descriptor_head_t  free_mcast_fwd_descriptor_head;
+static struct rtl865x_multicastTable mCastTbl;
+static uint32 rtl865x_externalMulticastPortMask = 0;
+#if defined(__linux__) && defined(__KERNEL__)
+static struct timer_list rtl865x_mCastSysTimer;	/*igmp timer*/
+#endif
+
+static int32 _rtl865x_initMCastFwdDescPool(void)
+{
+	int32 i;
+
+
+	MC_LIST_INIT(&free_mcast_fwd_descriptor_head);
+
+	TBL_MEM_ALLOC(rtl865x_mcastFwdDescPool, rtl865x_mcast_fwd_descriptor_t,MAX_MCAST_FWD_DESCRIPTOR_CNT);
+	
+	if(rtl865x_mcastFwdDescPool!=NULL)
+	{
+		memset( rtl865x_mcastFwdDescPool, 0, MAX_MCAST_FWD_DESCRIPTOR_CNT * sizeof(rtl865x_mcast_fwd_descriptor_t));	
+	}
+	else
+	{
+		return FAILED;
+	}
+	
+	for(i = 0; i<MAX_MCAST_FWD_DESCRIPTOR_CNT;i++)
+	{
+		MC_LIST_INSERT_HEAD(&free_mcast_fwd_descriptor_head, &rtl865x_mcastFwdDescPool[i], next);
+	}
+	
+	return SUCCESS;
+}
+
+static rtl865x_mcast_fwd_descriptor_t *_rtl865x_allocMCastFwdDesc(void)
+{
+	rtl865x_mcast_fwd_descriptor_t *retDesc=NULL;
+	retDesc = MC_LIST_FIRST(&free_mcast_fwd_descriptor_head);
+	if(retDesc!=NULL)
+	{
+		MC_LIST_REMOVE(retDesc, next);
+		memset(retDesc,0,sizeof(rtl865x_mcast_fwd_descriptor_t));
+	}
+	return retDesc;
+}
+
+static int32 _rtl865x_freeMCastFwdDesc(rtl865x_mcast_fwd_descriptor_t *descPtr)
+{
+	if(descPtr==NULL)
+	{
+		return SUCCESS;
+	}
+	memset(descPtr,0,sizeof(rtl865x_mcast_fwd_descriptor_t));
+	MC_LIST_INSERT_HEAD(&free_mcast_fwd_descriptor_head, descPtr, next);
+	
+	return SUCCESS;
+}
+
+static int32 _rtl865x_flushMCastFwdDescChain(mcast_fwd_descriptor_head_t * descChainHead)
+{
+	rtl865x_mcast_fwd_descriptor_t * curDesc,*nextDesc;
+	
+	if(descChainHead==NULL)
+	{
+		return SUCCESS;
+	}
+	
+	curDesc=MC_LIST_FIRST(descChainHead);
+	while(curDesc)
+	{
+		nextDesc=MC_LIST_NEXT(curDesc, next );
+		/*remove from the old descriptor chain*/
+		MC_LIST_REMOVE(curDesc, next);
+		/*return to the free descriptor chain*/
+		_rtl865x_freeMCastFwdDesc(curDesc);
+		curDesc = nextDesc;
+	}
+
+	return SUCCESS;
+}
+
+
+
+static int32 _rtl865x_mCastFwdDescEnqueue(mcast_fwd_descriptor_head_t * queueHead,
+												rtl865x_mcast_fwd_descriptor_t * enqueueDesc)
+{
+
+	rtl865x_mcast_fwd_descriptor_t *newDesc;
+	rtl865x_mcast_fwd_descriptor_t *curDesc,*nextDesc;
+	if(queueHead==NULL)
+	{
+		return FAILED;
+	}
+	
+	if(enqueueDesc==NULL)
+	{
+		return SUCCESS;
+	}
+	
+	/*multicast forward descriptor is internal maintained,always alloc new one*/
+	newDesc=_rtl865x_allocMCastFwdDesc();
+	
+	if(newDesc!=NULL)
+	{
+		memcpy(newDesc, enqueueDesc,sizeof(rtl865x_mcast_fwd_descriptor_t ));
+		//memset(&(newDesc->next), 0, sizeof(MC_LIST_ENTRY(rtl865x_mcast_fwd_descriptor_s)));
+		newDesc->next.le_next=NULL;
+		newDesc->next.le_prev=NULL;
+	}
+	else
+	{
+		/*no enough memory*/
+		return FAILED;
+	}
+	
+
+	for(curDesc=MC_LIST_FIRST(queueHead);curDesc!=NULL;curDesc=nextDesc)
+	{
+
+		nextDesc=MC_LIST_NEXT(curDesc, next);
+		
+		/*merge two descriptor*/
+	//	if((strcmp(curDesc->netifName,newDesc->netifName)==0) && (curDesc->vid==newDesc->vid))
+		if(strcmp(curDesc->netifName,newDesc->netifName)==0)
+		{	
+			
+			if(newDesc->descPortMask==0)
+			{
+				newDesc->descPortMask=curDesc->descPortMask;
+			}
+			MC_LIST_REMOVE(curDesc, next);
+			_rtl865x_freeMCastFwdDesc(curDesc);
+			
+		}
+	}
+
+	/*not matched descriptor is found*/
+	MC_LIST_INSERT_HEAD(queueHead, newDesc, next);
+
+	return SUCCESS;
+	
+}
+
+
+static int32 _rtl865x_mergeMCastFwdDescChain(mcast_fwd_descriptor_head_t * targetChainHead ,
+													rtl865x_mcast_fwd_descriptor_t *srcChain)
+{
+	rtl865x_mcast_fwd_descriptor_t *curDesc;
+
+	if(targetChainHead==NULL)
+	{
+		return FAILED;
+	}
+	
+	for(curDesc=srcChain; curDesc!=NULL; curDesc=MC_LIST_NEXT(curDesc,next))
+	{
+		
+		_rtl865x_mCastFwdDescEnqueue(targetChainHead, curDesc);
+		
+	}
+	
+	return SUCCESS;
+}
+
+
+
+
+static int32 _rtl865x_initMCastEntryPool(void)
+{
+	int32 index;
+	rtl865x_tblDrv_mCast_t *multiCast_t;
+	
+	TBL_MEM_ALLOC(multiCast_t, rtl865x_tblDrv_mCast_t ,MAX_MCAST_TABLE_ENTRY_CNT);
+	TAILQ_INIT(&mCastTbl.freeList.freeMultiCast);
+	for(index=0; index<MAX_MCAST_TABLE_ENTRY_CNT; index++)
+	{
+		memset( &multiCast_t[index], 0, sizeof(rtl865x_tblDrv_mCast_t));
+		TAILQ_INSERT_HEAD(&mCastTbl.freeList.freeMultiCast, &multiCast_t[index], nextMCast);
+	}
+
+	TBL_MEM_ALLOC(multiCast_t, rtl865x_tblDrv_mCast_t, RTL8651_MULTICASTTBL_SIZE);
+	memset(multiCast_t, 0,RTL8651_MULTICASTTBL_SIZE* sizeof(rtl865x_tblDrv_mCast_t));
+	mCastTbl.inuseList.mCastTbl = (void *)multiCast_t;
+
+	for(index=0; index<RTL8651_MULTICASTTBL_SIZE; index++)
+	{
+		TAILQ_INIT(&mCastTbl.inuseList.mCastTbl[index]);
+	}
+
+	return SUCCESS;
+}
+
+static rtl865x_tblDrv_mCast_t * _rtl865x_allocMCastEntry(uint32 hashIndex)
+{
+	rtl865x_tblDrv_mCast_t *newEntry;
+	newEntry=TAILQ_FIRST(&mCastTbl.freeList.freeMultiCast);
+	if (newEntry == NULL)
+	{
+		return NULL;
+	}		
+	
+	TAILQ_REMOVE(&mCastTbl.freeList.freeMultiCast, newEntry, nextMCast);
+
+	
+	/*initialize it*/
+	if(MC_LIST_FIRST(&newEntry->fwdDescChain)!=NULL)
+	{
+		_rtl865x_flushMCastFwdDescChain(&newEntry->fwdDescChain);
+	}
+	MC_LIST_INIT(&newEntry->fwdDescChain);
+	
+	memset(newEntry, 0, sizeof(rtl865x_tblDrv_mCast_t));
+
+	TAILQ_INSERT_TAIL(&mCastTbl.inuseList.mCastTbl[hashIndex], newEntry, nextMCast);
+	
+	return newEntry;
+}
+
+static int32 _rtl865x_flushMCastEntry(rtl865x_tblDrv_mCast_t *mCastEntry)
+{
+	if(mCastEntry==NULL)
+	{
+		return SUCCESS;
+	}
+	
+	_rtl865x_flushMCastFwdDescChain(&mCastEntry->fwdDescChain);
+	
+	memset(mCastEntry, 0, sizeof(rtl865x_tblDrv_mCast_t));
+	return SUCCESS;
+}
+
+static int32 _rtl865x_freeMCastEntry(rtl865x_tblDrv_mCast_t * mCastEntry, uint32 hashIndex)
+{
+	if(mCastEntry==NULL)
+	{
+		return SUCCESS;
+	}
+	
+	TAILQ_REMOVE(&mCastTbl.inuseList.mCastTbl[hashIndex], mCastEntry, nextMCast);
+	_rtl865x_flushMCastEntry(mCastEntry);
+	TAILQ_INSERT_HEAD(&mCastTbl.freeList.freeMultiCast, mCastEntry, nextMCast);
+	return SUCCESS;
+}
+
+
+static uint32 _rtl865x_doMCastEntrySrcVlanPortFilter(rtl865x_tblDrv_mCast_t *mCastEntry)
+{
+	rtl865x_mcast_fwd_descriptor_t * curDesc,*nextDesc;
+	if(mCastEntry==NULL)
+	{
+		return SUCCESS;
+	}
+	
+	for(curDesc=MC_LIST_FIRST(&mCastEntry->fwdDescChain);curDesc!=NULL;curDesc=nextDesc)
+	{
+		nextDesc=MC_LIST_NEXT(curDesc, next);
+		{
+			curDesc->fwdPortMask=curDesc->fwdPortMask & (~(1<<mCastEntry->port));
+			if(curDesc->fwdPortMask==0)
+			{
+				/*remove from the old chain*/
+				MC_LIST_REMOVE(curDesc, next);
+				/*return to the free descriptor chain*/
+				_rtl865x_freeMCastFwdDesc(curDesc);
+
+			}
+		}
+		
+	}
+
+	return SUCCESS;
+}
+
+ 
+static uint32 rtl865x_genMCastEntryAsicFwdMask(rtl865x_tblDrv_mCast_t *mCastEntry)
+{
+	uint32 asicFwdPortMask=0;
+	rtl865x_mcast_fwd_descriptor_t * curDesc;
+	if(mCastEntry==NULL)
+	{
+		return 0;
+	}
+	
+	MC_LIST_FOREACH(curDesc, &(mCastEntry->fwdDescChain), next)
+	{
+		if(curDesc->toCpu==0)
+		{
+			asicFwdPortMask|=(curDesc->fwdPortMask & ((1<<RTL8651_MAC_NUMBER)-1));
+		}
+		else
+		{
+			asicFwdPortMask|=( 0x01<<RTL8651_MAC_NUMBER);
+		}
+	}
+	asicFwdPortMask = asicFwdPortMask & (~(1<<mCastEntry->port)); 
+	return asicFwdPortMask;
+}
+
+static uint16 rtl865x_genMCastEntryCpuFlag(rtl865x_tblDrv_mCast_t *mCastEntry)
+{
+	uint16 cpuFlag=FALSE;
+	rtl865x_mcast_fwd_descriptor_t * curDesc;
+	if(mCastEntry==NULL)
+	{
+		return 0;
+	}
+
+	if(mCastEntry->cpuHold==TRUE)
+	{
+		cpuFlag=TRUE;
+	}
+	
+	MC_LIST_FOREACH(curDesc, &(mCastEntry->fwdDescChain), next)
+	{
+		if(	(curDesc->toCpu==TRUE)	||
+			(memcmp(curDesc->netifName, RTL_WLAN_NAME,4)==0)	)
+		{
+			cpuFlag=TRUE;
+		}
+	}
+	
+	return cpuFlag;
+}
+
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+/*for linux bridge level igmp snooping usage*/
+static uint32 rtl865x_getMCastEntryDescPortMask(rtl865x_tblDrv_mCast_t *mCastEntry)
+{
+	uint32 descPortMask=0;
+	rtl865x_mcast_fwd_descriptor_t * curDesc;
+	if(mCastEntry==NULL)
+	{
+		return 0;
+	}
+	
+	MC_LIST_FOREACH(curDesc, &(mCastEntry->fwdDescChain), next)
+	{
+		descPortMask=descPortMask | curDesc->descPortMask;
+	}
+	
+	return descPortMask;
+}
+
+#endif
+/*=======================================
+  * Multicast Table APIs
+  *=======================================*/
+#define RTL865X_MULTICASE_TABLE_APIs
+
+static void  _rtl865x_setASICMulticastPortStatus(void) {
+	uint32 index;
+
+	for (index=0; index<RTL8651_PORT_NUMBER+rtl8651_totalExtPortNum; index++) {
+		rtl8651_setAsicMulticastPortInternal(index, (rtl865x_externalMulticastPortMask&(1<<index))?FALSE:TRUE);
+	}
+}
+
+void rtl865x_arrangeMulticastPortStatus(void) {
+
+	rtl865x_externalMulticastPortMask=rtl865x_getExternalPortMask();
+	_rtl865x_setASICMulticastPortStatus();
+}
+
 /*
-@func int32	| rtl865x_addMulticastExternalPort	| API to add a hardware multicast external port.
-@parm  uint32 | extPort	| External port number to be added. 
-@rvalue SUCCESS	|Add hardware multicast external port successfully.
-@rvalue FAILED	|Add hardware multicast external port failed.
-*/
-int32 rtl865x_addMulticastExternalPort(uint32 extPort)
-{
-	rtl865x_externalMulticastPortMask |= (1<<extPort);
-	_rtl865x_setASICMulticastPortStatus();
-	return SUCCESS;
-}
-
+@func int32	| rtl865x_addMulticastExternalPort	| API to add a hardware multicast external port.
+@parm  uint32 | extPort	| External port number to be added. 
+@rvalue SUCCESS	|Add hardware multicast external port successfully.
+@rvalue FAILED	|Add hardware multicast external port failed.
+*/
+int32 rtl865x_addMulticastExternalPort(uint32 extPort)
+{
+	rtl865x_externalMulticastPortMask |= (1<<extPort);
+	_rtl865x_setASICMulticastPortStatus();
+	return SUCCESS;
+}
+
 /*
-@func int32	| rtl865x_delMulticastExternalPort	| API to delete a hardware multicast external port.
-@parm  uint32 | extPort	| External port number to be deleted.
-@rvalue SUCCESS	|Delete external port successfully.
-@rvalue FAILED	|Delete external port failed.
-*/
-int32 rtl865x_delMulticastExternalPort(uint32 extPort)
-{
-	rtl865x_externalMulticastPortMask &= ~(1<<extPort);
-	_rtl865x_setASICMulticastPortStatus();
-	return SUCCESS;
-}
-
+@func int32	| rtl865x_delMulticastExternalPort	| API to delete a hardware multicast external port.
+@parm  uint32 | extPort	| External port number to be deleted.
+@rvalue SUCCESS	|Delete external port successfully.
+@rvalue FAILED	|Delete external port failed.
+*/
+int32 rtl865x_delMulticastExternalPort(uint32 extPort)
+{
+	rtl865x_externalMulticastPortMask &= ~(1<<extPort);
+	_rtl865x_setASICMulticastPortStatus();
+	return SUCCESS;
+}
+
 /*
-@func int32	| rtl865x_setMulticastExternalPortMask	| API to set hardware multicast external port mask.
-@parm  uint32 | extPortMask	| External port mask to be set.
-@rvalue SUCCESS	|Set external port mask successfully.
-@rvalue FAILED	|Set external port mask failed.
-*/
-int32 rtl865x_setMulticastExternalPortMask(uint32 extPortMask)
-{
-	rtl865x_externalMulticastPortMask =extPortMask;
-	_rtl865x_setASICMulticastPortStatus();
-	return SUCCESS;
-}
-
+@func int32	| rtl865x_setMulticastExternalPortMask	| API to set hardware multicast external port mask.
+@parm  uint32 | extPortMask	| External port mask to be set.
+@rvalue SUCCESS	|Set external port mask successfully.
+@rvalue FAILED	|Set external port mask failed.
+*/
+int32 rtl865x_setMulticastExternalPortMask(uint32 extPortMask)
+{
+	rtl865x_externalMulticastPortMask =extPortMask;
+	_rtl865x_setASICMulticastPortStatus();
+	return SUCCESS;
+}
+
 /*
-@func int32	| rtl865x_addMulticastExternalPortMask	| API to add hardware multicast external port mask.
-@parm  uint32 | extPortMask	| External port mask to be added.
-@rvalue SUCCESS	|Add external port mask successfully.
-@rvalue FAILED	|Add external port mask failed.
-*/
-int32 rtl865x_addMulticastExternalPortMask(uint32 extPortMask)
-{
-	rtl865x_externalMulticastPortMask|= extPortMask;
-	_rtl865x_setASICMulticastPortStatus();
-	return SUCCESS;
-}
-
+@func int32	| rtl865x_addMulticastExternalPortMask	| API to add hardware multicast external port mask.
+@parm  uint32 | extPortMask	| External port mask to be added.
+@rvalue SUCCESS	|Add external port mask successfully.
+@rvalue FAILED	|Add external port mask failed.
+*/
+int32 rtl865x_addMulticastExternalPortMask(uint32 extPortMask)
+{
+	rtl865x_externalMulticastPortMask|= extPortMask;
+	_rtl865x_setASICMulticastPortStatus();
+	return SUCCESS;
+}
+
 /*
-@func int32	| rtl865x_delMulticastExternalPortMask	|  API to delete hardware multicast external port mask.
-@parm  uint32 | extPortMask	| External port mask to be deleted.
-@rvalue SUCCESS	|Delete external port mask successfully.
-@rvalue FAILED	|Delete external port mask failed.
-*/
-int32 rtl865x_delMulticastExternalPortMask(uint32 extPortMask)
-{
-	rtl865x_externalMulticastPortMask &= ~extPortMask;
-	_rtl865x_setASICMulticastPortStatus();
-	return SUCCESS;
-}
-
-int32 rtl865x_getMulticastExternalPortMask(void)
-{
-	return rtl865x_externalMulticastPortMask ;
-}
-
-static inline void _rtl865x_patchPppoeWeak(rtl865x_tblDrv_mCast_t *mCast_t)
-{
-	rtl865x_mcast_fwd_descriptor_t * curDesc;
-	uint32 netifType;
-	/* patch: keep cache in software if one vlan's interface is pppoe */
-	MC_LIST_FOREACH(curDesc, &(mCast_t->fwdDescChain), next)
-	{
-		if(rtl865x_getNetifType(curDesc->netifName, &netifType)==SUCCESS)
-		{
-			/*how about pptp,l2tp?*/
-			if(netifType==IF_PPPOE)
-			{
-				mCast_t->flag |= RTL865X_MULTICAST_PPPOEPATCH_CPUBIT;
-				return;
-			}
-		}
-		
-	}
-
-	mCast_t->flag &= ~RTL865X_MULTICAST_PPPOEPATCH_CPUBIT;
-}
-#if 0
-static int _rtl865x_checkMulticastEntryEqual(rtl865x_tblDrv_mCast_t * mCastEntry1, rtl865x_tblDrv_mCast_t * mCastEntry2)
-{
-	if((mCastEntry1==NULL) && (mCastEntry2==NULL))
-	{
-		return TRUE;
-	}
-	
-	if((mCastEntry1==NULL) && (mCastEntry2!=NULL))
-	{
-		return FALSE;
-	}
-
-	if((mCastEntry1!=NULL) && (mCastEntry2==NULL))
-	{
-		return FALSE;
-	}
-	
-	if(mCastEntry1->sip!=mCastEntry2->sip)
-	{
-		return FALSE;
-	}
-
-	if(mCastEntry1->dip!=mCastEntry2->dip)
-	{
-		return FALSE;
-	}
-
-	if(mCastEntry1->svid!=mCastEntry2->svid)
-	{
-		return FALSE;
-	}
-	
-	if(mCastEntry1->port!=mCastEntry2->port)
-	{
-		return FALSE;
-	}
-
-	if(mCastEntry1->mbr!=mCastEntry2->mbr)
-	{
-		return FALSE;
-	}
-	
-	if(mCastEntry1->cpu!=mCastEntry2->cpu)
-	{
-		return FALSE;
-	}
-	
-	if(mCastEntry1->extIp!=mCastEntry2->extIp)
-	{
-		return FALSE;
-	}
-
-	if(mCastEntry1->flag!=mCastEntry2->flag)
-	{
-		return FALSE;
-	}
-
-	
-	if(mCastEntry1->inAsic!=mCastEntry2->inAsic)
-	{
-		return FALSE;
-	}			
-
-	return TRUE;
-}
-#endif
-#ifdef CONFIG_PROC_FS
-static unsigned int mcastAddOpCnt=0;
-unsigned int _rtl865x_getAddMcastOpCnt(void)
-{
-	return mcastAddOpCnt;
-}
-
-static unsigned int mcastDelOpCnt=0;
-unsigned int _rtl865x_getDelMcastOpCnt(void)
-{
-	return mcastDelOpCnt;
-}
-#endif
-/* re-select Multicast entry to ASIC for the index ""entryIndex */
-static void _rtl865x_arrangeMulticast(uint32 entryIndex)
-{
-	rtl865x_tblAsicDrv_multiCastParam_t asic_mcast;
-	rtl865x_tblDrv_mCast_t *mCast_t=NULL;
-	rtl865x_tblDrv_mCast_t *select_t=NULL;
-	rtl865x_tblDrv_mCast_t *swapOutEntry=NULL;
-	int32 retval;
-	
-	TAILQ_FOREACH(mCast_t, &mCastTbl.inuseList.mCastTbl[entryIndex], nextMCast) 
-	{
-		if ((mCast_t->cpu == 0) && !(mCast_t->flag & RTL865X_MULTICAST_PPPOEPATCH_CPUBIT)) 
-		{ /* Ignore cpu=1 */
-
-			if(mCast_t->inAsic==TRUE)
-			{
-				if(swapOutEntry==NULL)
-				{
-					swapOutEntry=mCast_t;
-				}
-				else
-				{
-					/*impossible, two flow in one asic entry*/
-					swapOutEntry->inAsic=FALSE;
-					mCast_t->inAsic = FALSE;
-				}
-			}
-			
-			if (select_t) 
-			{
-#if 1
-				if ((mCast_t->unKnownMCast==TRUE) && (select_t->unKnownMCast==TRUE))
-				{
-					/*unknown multicast, select the heavy load*/
-					if (mCast_t->maxPPS > select_t->maxPPS)
-					{
-						select_t = mCast_t;
-					}
-				}
-				else if ((mCast_t->unKnownMCast==FALSE) && (select_t->unKnownMCast==TRUE))
-				{
-					/*replace unknown multicast*/
-					select_t = mCast_t;
-				}
-				else if((mCast_t->unKnownMCast==FALSE) && (select_t->unKnownMCast==FALSE))
-				{
-					/*select the heavy load*/
-					if (mCast_t->maxPPS > select_t->maxPPS)
-					{
-						select_t = mCast_t;
-					}
-				}
-				else if((mCast_t->unKnownMCast==TRUE) && (select_t->unKnownMCast==FALSE))
-				{
-					/*this  stream is unknown multicast,needn't change candidate*/
-				}
-#else
-				if ((mCast_t->mbr==0) && (select_t->mbr==0))
-				{
-					/*unknown multicast, select the heavy load*/
-					if (mCast_t->maxPPS > select_t->maxPPS)
-					{
-						select_t = mCast_t;
-					}
-				}
-				else if ((mCast_t->mbr!=0) && (select_t->mbr==0))
-				{
-					/*replace unknown multicast*/
-					select_t = mCast_t;
-				}
-				else if((mCast_t->mbr!=0) && (select_t->mbr!=0))
-				{
-					/*select the heavy load*/
-					if (mCast_t->maxPPS > select_t->maxPPS)
-					{
-						select_t = mCast_t;
-					}
-				}
-				else if((mCast_t->mbr==0) && (select_t->mbr!=0))
-				{
-					/*this  stream is unknown multicast,needn't change candidate*/
-				}
-#endif				
-				
-				
-			}
-			else 
-			{
-				select_t = mCast_t;
-			}
-
-			//printk("mCast_t->dip is 0x%x,mCast_t->inAsic is %d,mCast_t->maxPPS is %d\n\n\n",mCast_t->dip,mCast_t->inAsic,mCast_t->maxPPS);
-		}
-		else
-		{
-			mCast_t->inAsic = FALSE;	/* reset "inAsic" bit */
-		} 
-
-
-	}
-	/*
-	if(swapOutEntry)
-	{
-		printk("%s:%d,swapOutEntry->dip is 0x%x,swapOutEntry->mbr is 0x%x\n",__FUNCTION__,__LINE__,swapOutEntry->dip,swapOutEntry->mbr);
-
-	}
-	
-	if (select_t) 
-	{
-		printk("%s:%d,select_t->dip is 0x%x,select_t->mbr is 0x%x\n",__FUNCTION__,__LINE__,select_t->dip,select_t->mbr);
-	}
-	*/
-	if (select_t) 
-	{
-		if((swapOutEntry==NULL) ||(select_t==swapOutEntry))
-		{
-			select_t->age = RTL865X_MULTICAST_TABLE_ASIC_AGE;
-			bzero(&asic_mcast, sizeof(rtl865x_tblAsicDrv_multiCastParam_t));
-			memcpy(&asic_mcast, select_t, (uint32)&(((rtl865x_tblDrv_mCast_t *)0)->extIp));
-			if (select_t->extIp)
-			{
-			
-#ifdef CONFIG_RTL_LAYERED_DRIVER_L3
-				int32 ipIdx;
-				if(rtl865x_getIpIdxByExtIp(select_t->extIp, &ipIdx)==SUCCESS)
-				{
-					asic_mcast.extIdx=(uint16)ipIdx;
-				}
-#else
-				asic_mcast.extIdx=0;
-#endif
-		
-			}
-			retval = rtl8651_setAsicIpMulticastTable(&asic_mcast);
-			
-#ifdef CONFIG_PROC_FS
-			mcastAddOpCnt++;
-#endif
-			assert(retval == SUCCESS);
-			if(retval==SUCCESS)
-			{
-				select_t->inAsic = TRUE;
-			}
-			else
-			{
-				select_t->inAsic = FALSE;
-				rtl8651_delAsicIpMulticastTable(entryIndex);
-#ifdef CONFIG_PROC_FS
-				mcastDelOpCnt++;
-#endif
-			}
-				
-			assert(retval == SUCCESS);
-			TAILQ_REMOVE(&mCastTbl.inuseList.mCastTbl[entryIndex], select_t, nextMCast);
-			TAILQ_INSERT_HEAD(&mCastTbl.inuseList.mCastTbl[entryIndex], select_t, nextMCast);
-		}
-		else/*(swapOutEntry!=NULL) && (select_t!=swapOutEntry)*/
-		{
-			/*disable swap and only explicit joined mulicast flow can replace unknown multicast flow*/
-			if((swapOutEntry->unKnownMCast==TRUE) &&(select_t->unKnownMCast==FALSE))
-			{
-				/*don't forget to set swapOutEntry's inAsic flag*/
-				swapOutEntry->inAsic=FALSE;
-				
-				select_t->age = RTL865X_MULTICAST_TABLE_ASIC_AGE;
-				bzero(&asic_mcast, sizeof(rtl865x_tblAsicDrv_multiCastParam_t));
-				memcpy(&asic_mcast, select_t, (uint32)&(((rtl865x_tblDrv_mCast_t *)0)->extIp));
-
-				if (select_t->extIp)
-				{
-#ifdef CONFIG_RTL_LAYERED_DRIVER_L3		
-					int32 ipIdx;
-					if(rtl865x_getIpIdxByExtIp(select_t->extIp, &ipIdx)==SUCCESS)
-					{
-						asic_mcast.extIdx=(uint16)ipIdx;
-					}
-#else
-					asic_mcast.extIdx=0;
-#endif
-				}
-
-				retval = rtl8651_setAsicIpMulticastTable(&asic_mcast);
-#ifdef CONFIG_PROC_FS
-				mcastAddOpCnt++;
-#endif
-				assert(retval == SUCCESS);
-				if(retval==SUCCESS)
-				{
-					select_t->inAsic = TRUE;
-				}
-				else
-				{
-					select_t->inAsic = FALSE;
-					rtl8651_delAsicIpMulticastTable(entryIndex);
-#ifdef CONFIG_PROC_FS
-					mcastDelOpCnt++;
-#endif
-				}
-				
-				TAILQ_REMOVE(&mCastTbl.inuseList.mCastTbl[entryIndex], select_t, nextMCast);
-				TAILQ_INSERT_HEAD(&mCastTbl.inuseList.mCastTbl[entryIndex], select_t, nextMCast);
-
-			}
-			else
-			{			
-				if(swapOutEntry->inAsic == FALSE)
-				{
-					/*maybe something is wrong, we remove the asic entry*/
-					rtl8651_delAsicIpMulticastTable(entryIndex);
-#ifdef CONFIG_PROC_FS
-					mcastDelOpCnt++;
-#endif
-				}
-				
-			}		
-			
-		}
-		
-	}
-	else 	
-	{
-		if(swapOutEntry!=NULL)
-		{
-			swapOutEntry->inAsic=FALSE;
-		}
-		rtl8651_delAsicIpMulticastTable(entryIndex);
-#ifdef CONFIG_PROC_FS
-		mcastDelOpCnt++;
-#endif
-	}
-}
-
-
-static void _rtl865x_mCastEntryReclaim(void)
-{
-	uint32 index;
-	uint32 freeCnt=0;
-	uint32 asicFwdPortMask=0;
-	uint32 needReArrange=FALSE;
-	rtl865x_tblDrv_mCast_t *curMCastEntry, *nextMCastEntry;
-
-	/*free unused software forward entry*/
-	for(index=0; index<RTL8651_MULTICASTTBL_SIZE; index++) 
-	{
-		curMCastEntry = TAILQ_FIRST(&mCastTbl.inuseList.mCastTbl[index]);
-		while (curMCastEntry)
-		{
-			nextMCastEntry = TAILQ_NEXT(curMCastEntry, nextMCast);
-			if((curMCastEntry->inAsic==FALSE)  && (curMCastEntry->count==0))
-			{
-				_rtl865x_freeMCastEntry(curMCastEntry, index);
-				freeCnt++;
-			}
-			curMCastEntry = nextMCastEntry;
-		}
-		
-	}
-
-	if(freeCnt>0)
-	{
-		return;
-	}
-	
-	for(index=0; index<RTL8651_MULTICASTTBL_SIZE; index++) 
-	{
-		curMCastEntry = TAILQ_FIRST(&mCastTbl.inuseList.mCastTbl[index]);
-		needReArrange=FALSE;
-		while (curMCastEntry)
-		{
-			nextMCastEntry = TAILQ_NEXT(curMCastEntry, nextMCast);
-			if(curMCastEntry->inAsic)
-			{
-				asicFwdPortMask=rtl865x_genMCastEntryAsicFwdMask(curMCastEntry);
-				if(asicFwdPortMask==0) 
-				{
-					_rtl865x_freeMCastEntry(curMCastEntry, index);
-					needReArrange=TRUE;
-				}
-			}
-			curMCastEntry = nextMCastEntry;
-		}
-		
-		if(needReArrange==TRUE)
-		{
-			_rtl865x_arrangeMulticast(index);
-		}
-	}
-
-	return;
-}
+@func int32	| rtl865x_delMulticastExternalPortMask	|  API to delete hardware multicast external port mask.
+@parm  uint32 | extPortMask	| External port mask to be deleted.
+@rvalue SUCCESS	|Delete external port mask successfully.
+@rvalue FAILED	|Delete external port mask failed.
+*/
+int32 rtl865x_delMulticastExternalPortMask(uint32 extPortMask)
+{
+	rtl865x_externalMulticastPortMask &= ~extPortMask;
+	_rtl865x_setASICMulticastPortStatus();
+	return SUCCESS;
+}
+
+int32 rtl865x_getMulticastExternalPortMask(void)
+{
+	return rtl865x_externalMulticastPortMask ;
+}
+
+static inline void _rtl865x_patchPppoeWeak(rtl865x_tblDrv_mCast_t *mCast_t)
+{
+	rtl865x_mcast_fwd_descriptor_t * curDesc;
+	uint32 netifType;
+	/* patch: keep cache in software if one vlan's interface is pppoe */
+	MC_LIST_FOREACH(curDesc, &(mCast_t->fwdDescChain), next)
+	{
+		if(rtl865x_getNetifType(curDesc->netifName, &netifType)==SUCCESS)
+		{
+			/*how about pptp,l2tp?*/
+			if(netifType==IF_PPPOE)
+			{
+				mCast_t->flag |= RTL865X_MULTICAST_PPPOEPATCH_CPUBIT;
+				return;
+			}
+		}
+		
+	}
+
+	mCast_t->flag &= ~RTL865X_MULTICAST_PPPOEPATCH_CPUBIT;
+}
+#if 0
+static int _rtl865x_checkMulticastEntryEqual(rtl865x_tblDrv_mCast_t * mCastEntry1, rtl865x_tblDrv_mCast_t * mCastEntry2)
+{
+	if((mCastEntry1==NULL) && (mCastEntry2==NULL))
+	{
+		return TRUE;
+	}
+	
+	if((mCastEntry1==NULL) && (mCastEntry2!=NULL))
+	{
+		return FALSE;
+	}
+
+	if((mCastEntry1!=NULL) && (mCastEntry2==NULL))
+	{
+		return FALSE;
+	}
+	
+	if(mCastEntry1->sip!=mCastEntry2->sip)
+	{
+		return FALSE;
+	}
+
+	if(mCastEntry1->dip!=mCastEntry2->dip)
+	{
+		return FALSE;
+	}
+
+	if(mCastEntry1->svid!=mCastEntry2->svid)
+	{
+		return FALSE;
+	}
+	
+	if(mCastEntry1->port!=mCastEntry2->port)
+	{
+		return FALSE;
+	}
+
+	if(mCastEntry1->mbr!=mCastEntry2->mbr)
+	{
+		return FALSE;
+	}
+	
+	if(mCastEntry1->cpu!=mCastEntry2->cpu)
+	{
+		return FALSE;
+	}
+	
+	if(mCastEntry1->extIp!=mCastEntry2->extIp)
+	{
+		return FALSE;
+	}
+
+	if(mCastEntry1->flag!=mCastEntry2->flag)
+	{
+		return FALSE;
+	}
+
+	
+	if(mCastEntry1->inAsic!=mCastEntry2->inAsic)
+	{
+		return FALSE;
+	}			
+
+	return TRUE;
+}
+#endif
+#ifdef CONFIG_PROC_FS
+static unsigned int mcastAddOpCnt=0;
+unsigned int _rtl865x_getAddMcastOpCnt(void)
+{
+	return mcastAddOpCnt;
+}
+
+static unsigned int mcastDelOpCnt=0;
+unsigned int _rtl865x_getDelMcastOpCnt(void)
+{
+	return mcastDelOpCnt;
+}
+#endif
+/* re-select Multicast entry to ASIC for the index ""entryIndex */
+static void _rtl865x_arrangeMulticast(uint32 entryIndex)
+{
+	rtl865x_tblAsicDrv_multiCastParam_t asic_mcast;
+	rtl865x_tblDrv_mCast_t *mCast_t=NULL;
+	rtl865x_tblDrv_mCast_t *select_t=NULL;
+	rtl865x_tblDrv_mCast_t *swapOutEntry=NULL;
+	int32 retval;
+	
+	TAILQ_FOREACH(mCast_t, &mCastTbl.inuseList.mCastTbl[entryIndex], nextMCast) 
+	{
+		if ((mCast_t->cpu == 0) && !(mCast_t->flag & RTL865X_MULTICAST_PPPOEPATCH_CPUBIT)) 
+		{ /* Ignore cpu=1 */
+
+			if(mCast_t->inAsic==TRUE)
+			{
+				if(swapOutEntry==NULL)
+				{
+					swapOutEntry=mCast_t;
+				}
+				else
+				{
+					/*impossible, two flow in one asic entry*/
+					swapOutEntry->inAsic=FALSE;
+					mCast_t->inAsic = FALSE;
+				}
+			}
+			
+			if (select_t) 
+			{
+#if 1
+				if ((mCast_t->unKnownMCast==TRUE) && (select_t->unKnownMCast==TRUE))
+				{
+					/*unknown multicast, select the heavy load*/
+					if (mCast_t->maxPPS > select_t->maxPPS)
+					{
+						select_t = mCast_t;
+					}
+				}
+				else if ((mCast_t->unKnownMCast==FALSE) && (select_t->unKnownMCast==TRUE))
+				{
+					/*replace unknown multicast*/
+					select_t = mCast_t;
+				}
+				else if((mCast_t->unKnownMCast==FALSE) && (select_t->unKnownMCast==FALSE))
+				{
+					/*select the heavy load*/
+					if (mCast_t->maxPPS > select_t->maxPPS)
+					{
+						select_t = mCast_t;
+					}
+				}
+				else if((mCast_t->unKnownMCast==TRUE) && (select_t->unKnownMCast==FALSE))
+				{
+					/*this  stream is unknown multicast,needn't change candidate*/
+				}
+#else
+				if ((mCast_t->mbr==0) && (select_t->mbr==0))
+				{
+					/*unknown multicast, select the heavy load*/
+					if (mCast_t->maxPPS > select_t->maxPPS)
+					{
+						select_t = mCast_t;
+					}
+				}
+				else if ((mCast_t->mbr!=0) && (select_t->mbr==0))
+				{
+					/*replace unknown multicast*/
+					select_t = mCast_t;
+				}
+				else if((mCast_t->mbr!=0) && (select_t->mbr!=0))
+				{
+					/*select the heavy load*/
+					if (mCast_t->maxPPS > select_t->maxPPS)
+					{
+						select_t = mCast_t;
+					}
+				}
+				else if((mCast_t->mbr==0) && (select_t->mbr!=0))
+				{
+					/*this  stream is unknown multicast,needn't change candidate*/
+				}
+#endif				
+				
+				
+			}
+			else 
+			{
+				select_t = mCast_t;
+			}
+
+			//printk("mCast_t->dip is 0x%x,mCast_t->inAsic is %d,mCast_t->maxPPS is %d\n\n\n",mCast_t->dip,mCast_t->inAsic,mCast_t->maxPPS);
+		}
+		else
+		{
+			mCast_t->inAsic = FALSE;	/* reset "inAsic" bit */
+		} 
+
+
+	}
+	/*
+	if(swapOutEntry)
+	{
+		printk("%s:%d,swapOutEntry->dip is 0x%x,swapOutEntry->mbr is 0x%x\n",__FUNCTION__,__LINE__,swapOutEntry->dip,swapOutEntry->mbr);
+
+	}
+	
+	if (select_t) 
+	{
+		printk("%s:%d,select_t->dip is 0x%x,select_t->mbr is 0x%x\n",__FUNCTION__,__LINE__,select_t->dip,select_t->mbr);
+	}
+	*/
+	if (select_t) 
+	{
+		if((swapOutEntry==NULL) ||(select_t==swapOutEntry))
+		{
+			select_t->age = RTL865X_MULTICAST_TABLE_ASIC_AGE;
+			bzero(&asic_mcast, sizeof(rtl865x_tblAsicDrv_multiCastParam_t));
+			memcpy(&asic_mcast, select_t, (uint32)&(((rtl865x_tblDrv_mCast_t *)0)->extIp));
+			if (select_t->extIp)
+			{
+			
+#ifdef CONFIG_RTL_LAYERED_DRIVER_L3
+				int32 ipIdx;
+				if(rtl865x_getIpIdxByExtIp(select_t->extIp, &ipIdx)==SUCCESS)
+				{
+					asic_mcast.extIdx=(uint16)ipIdx;
+				}
+#else
+				asic_mcast.extIdx=0;
+#endif
+		
+			}
+			retval = rtl8651_setAsicIpMulticastTable(&asic_mcast);
+			
+#ifdef CONFIG_PROC_FS
+			mcastAddOpCnt++;
+#endif
+			assert(retval == SUCCESS);
+			if(retval==SUCCESS)
+			{
+				select_t->inAsic = TRUE;
+			}
+			else
+			{
+				select_t->inAsic = FALSE;
+				rtl8651_delAsicIpMulticastTable(entryIndex);
+#ifdef CONFIG_PROC_FS
+				mcastDelOpCnt++;
+#endif
+			}
+				
+			assert(retval == SUCCESS);
+			TAILQ_REMOVE(&mCastTbl.inuseList.mCastTbl[entryIndex], select_t, nextMCast);
+			TAILQ_INSERT_HEAD(&mCastTbl.inuseList.mCastTbl[entryIndex], select_t, nextMCast);
+		}
+		else/*(swapOutEntry!=NULL) && (select_t!=swapOutEntry)*/
+		{
+			/*disable swap and only explicit joined mulicast flow can replace unknown multicast flow*/
+			if((swapOutEntry->unKnownMCast==TRUE) &&(select_t->unKnownMCast==FALSE))
+			{
+				/*don't forget to set swapOutEntry's inAsic flag*/
+				swapOutEntry->inAsic=FALSE;
+				
+				select_t->age = RTL865X_MULTICAST_TABLE_ASIC_AGE;
+				bzero(&asic_mcast, sizeof(rtl865x_tblAsicDrv_multiCastParam_t));
+				memcpy(&asic_mcast, select_t, (uint32)&(((rtl865x_tblDrv_mCast_t *)0)->extIp));
+
+				if (select_t->extIp)
+				{
+#ifdef CONFIG_RTL_LAYERED_DRIVER_L3		
+					int32 ipIdx;
+					if(rtl865x_getIpIdxByExtIp(select_t->extIp, &ipIdx)==SUCCESS)
+					{
+						asic_mcast.extIdx=(uint16)ipIdx;
+					}
+#else
+					asic_mcast.extIdx=0;
+#endif
+				}
+
+				retval = rtl8651_setAsicIpMulticastTable(&asic_mcast);
+#ifdef CONFIG_PROC_FS
+				mcastAddOpCnt++;
+#endif
+				assert(retval == SUCCESS);
+				if(retval==SUCCESS)
+				{
+					select_t->inAsic = TRUE;
+				}
+				else
+				{
+					select_t->inAsic = FALSE;
+					rtl8651_delAsicIpMulticastTable(entryIndex);
+#ifdef CONFIG_PROC_FS
+					mcastDelOpCnt++;
+#endif
+				}
+				
+				TAILQ_REMOVE(&mCastTbl.inuseList.mCastTbl[entryIndex], select_t, nextMCast);
+				TAILQ_INSERT_HEAD(&mCastTbl.inuseList.mCastTbl[entryIndex], select_t, nextMCast);
+
+			}
+			else
+			{			
+				if(swapOutEntry->inAsic == FALSE)
+				{
+					/*maybe something is wrong, we remove the asic entry*/
+					rtl8651_delAsicIpMulticastTable(entryIndex);
+#ifdef CONFIG_PROC_FS
+					mcastDelOpCnt++;
+#endif
+				}
+				
+			}		
+			
+		}
+		
+	}
+	else 	
+	{
+		if(swapOutEntry!=NULL)
+		{
+			swapOutEntry->inAsic=FALSE;
+		}
+		rtl8651_delAsicIpMulticastTable(entryIndex);
+#ifdef CONFIG_PROC_FS
+		mcastDelOpCnt++;
+#endif
+	}
+}
+
+
+static void _rtl865x_mCastEntryReclaim(void)
+{
+	uint32 index;
+	uint32 freeCnt=0;
+	uint32 asicFwdPortMask=0;
+	uint32 needReArrange=FALSE;
+	rtl865x_tblDrv_mCast_t *curMCastEntry, *nextMCastEntry;
+
+	/*free unused software forward entry*/
+	for(index=0; index<RTL8651_MULTICASTTBL_SIZE; index++) 
+	{
+		curMCastEntry = TAILQ_FIRST(&mCastTbl.inuseList.mCastTbl[index]);
+		while (curMCastEntry)
+		{
+			nextMCastEntry = TAILQ_NEXT(curMCastEntry, nextMCast);
+			if((curMCastEntry->inAsic==FALSE)  && (curMCastEntry->count==0))
+			{
+				_rtl865x_freeMCastEntry(curMCastEntry, index);
+				freeCnt++;
+			}
+			curMCastEntry = nextMCastEntry;
+		}
+		
+	}
+
+	if(freeCnt>0)
+	{
+		return;
+	}
+	
+	for(index=0; index<RTL8651_MULTICASTTBL_SIZE; index++) 
+	{
+		curMCastEntry = TAILQ_FIRST(&mCastTbl.inuseList.mCastTbl[index]);
+		needReArrange=FALSE;
+		while (curMCastEntry)
+		{
+			nextMCastEntry = TAILQ_NEXT(curMCastEntry, nextMCast);
+			if(curMCastEntry->inAsic)
+			{
+				asicFwdPortMask=rtl865x_genMCastEntryAsicFwdMask(curMCastEntry);
+				if(asicFwdPortMask==0) 
+				{
+					_rtl865x_freeMCastEntry(curMCastEntry, index);
+					needReArrange=TRUE;
+				}
+			}
+			curMCastEntry = nextMCastEntry;
+		}
+		
+		if(needReArrange==TRUE)
+		{
+			_rtl865x_arrangeMulticast(index);
+		}
+	}
+
+	return;
+}
 /*
-@func rtl865x_tblDrv_mCast_t *	| rtl865x_findMCastEntry	|  API to find a hardware multicast entry.
-@parm  ipaddr_t 	| mAddr	| Multicast stream destination group address. 
-@parm  ipaddr_t	|  sip	| Multicast stream source ip address.
-@parm  uint16		| svid	| Multicast stream input vlan index.
-@parm  uint16 	| sport	| Multicast stream input port number.
-*/
-rtl865x_tblDrv_mCast_t *rtl865x_findMCastEntry(ipaddr_t mAddr, ipaddr_t sip, uint16 svid, uint16 sport)
-{
-	rtl865x_tblDrv_mCast_t *mCast_t;
-	uint32 entry = rtl8651_ipMulticastTableIndex(sip, mAddr);
-	TAILQ_FOREACH(mCast_t, &mCastTbl.inuseList.mCastTbl[entry], nextMCast) {
-		if (mCast_t->dip==mAddr && mCast_t->sip==sip && mCast_t->svid==svid && mCast_t->port==sport)
-		{
-			if (mCast_t->inAsic == FALSE) 
-			{
-				mCast_t->age = RTL865X_MULTICAST_TABLE_AGE;
-				mCast_t->count ++;
-			}
-
-			return mCast_t;
-		}
-		
-		mCast_t->count ++;
-		if(mCast_t->maxPPS<mCast_t->count)
-		{
-			/*update maxPPS*/
-			mCast_t->maxPPS=mCast_t->count ;
-		}
-			
-	}
-	return (rtl865x_tblDrv_mCast_t *)NULL;	
-}
-
+@func rtl865x_tblDrv_mCast_t *	| rtl865x_findMCastEntry	|  API to find a hardware multicast entry.
+@parm  ipaddr_t 	| mAddr	| Multicast stream destination group address. 
+@parm  ipaddr_t	|  sip	| Multicast stream source ip address.
+@parm  uint16		| svid	| Multicast stream input vlan index.
+@parm  uint16 	| sport	| Multicast stream input port number.
+*/
+rtl865x_tblDrv_mCast_t *rtl865x_findMCastEntry(ipaddr_t mAddr, ipaddr_t sip, uint16 svid, uint16 sport)
+{
+	rtl865x_tblDrv_mCast_t *mCast_t;
+	uint32 entry = rtl8651_ipMulticastTableIndex(sip, mAddr);
+	TAILQ_FOREACH(mCast_t, &mCastTbl.inuseList.mCastTbl[entry], nextMCast) {
+		if (mCast_t->dip==mAddr && mCast_t->sip==sip && mCast_t->svid==svid && mCast_t->port==sport)
+		{
+			if (mCast_t->inAsic == FALSE) 
+			{
+				mCast_t->age = RTL865X_MULTICAST_TABLE_AGE;
+				mCast_t->count ++;
+			}
+
+			return mCast_t;
+		}
+		
+		mCast_t->count ++;
+		if(mCast_t->maxPPS<mCast_t->count)
+		{
+			/*update maxPPS*/
+			mCast_t->maxPPS=mCast_t->count ;
+		}
+			
+	}
+	return (rtl865x_tblDrv_mCast_t *)NULL;	
+}
+
 /*
-@func int32	| rtl865x_addMulticastEntry	|  API to add a hardwawre multicast forwarding entry.
-@parm  ipaddr_t 	| mAddr	| Multicast flow Destination group address. 
-@parm  ipaddr_t 	| sip	| Multicast flow source ip address. 
-@parm  uint16 	| svid	| Multicast flow input vlan index. 
-@parm  uint16		| sport	| Multicast flow input port number. 
-@parm  rtl865x_mcast_fwd_descriptor_t *	| newFwdDescChain	| Multicast flow forwarding descriptor chain to be added. 
-@parm  int32 	| flushOldChain	| Flag to indicate to flush old mulicast forwarding descriptor chain or not. 1 is to flush old chain, and 0 is not to. 
-@parm  ipaddr_t 	| extIp	| External source ip address used when forward multicast data from lan to wan. 
-@parm  int8	| toCpu	| Cpu forwarding flag, 1 is to forward multicast data by cpu,and  0 is not.
-@parm  int8	| flag	| For future usage, set to 0 at present.
-@rvalue SUCCESS	|Add hardware multicast forwarding entry successfully. 
-@rvalue FAILED	|Add hardware multicast forwarding entry failed.
-*/
-int32 rtl865x_addMulticastEntry(ipaddr_t mAddr, ipaddr_t sip, uint16 svid, uint16 sport, 
-									rtl865x_mcast_fwd_descriptor_t * newFwdDescChain, 
-									int32 flushOldChain, ipaddr_t extIp, char cpuHold, uint8 flag)
-{
-
-	rtl865x_tblDrv_mCast_t *mCast_t;
-	uint32 hashIndex = rtl8651_ipMulticastTableIndex(sip, mAddr);
-	struct rtl_groupInfo groupInfo;
-	/*windows xp upnp:239.255.255.0*/
-	if(mAddr==0xEFFFFFFA)
-	{
-		return FAILED;
-	}
-#if 0
-	/*reserved multicast address 224.0.0.x*/
-	if((mAddr & 0xFFFFFF00) == 0xE0000000)
-	{
-		return FAILED;
-	}
-#endif	
-	/*try to match hash line*/
-	TAILQ_FOREACH(mCast_t, &mCastTbl.inuseList.mCastTbl[hashIndex], nextMCast) 
-	{
-		if (mCast_t->sip==sip && mCast_t->dip==mAddr && mCast_t->svid==svid && mCast_t->port==sport)
-			break;
-	}
-	
-	if (mCast_t == NULL) 
-	{
-		mCast_t=_rtl865x_allocMCastEntry(hashIndex);
-		if (mCast_t == NULL)
-		{
-			_rtl865x_mCastEntryReclaim();
-			mCast_t=_rtl865x_allocMCastEntry(hashIndex);
-			if(mCast_t == NULL)
-			{
-				return FAILED;
-			}
-		}
-		mCast_t->sip			= sip;
-		mCast_t->dip			= mAddr;
-		mCast_t->svid		= svid;
-		mCast_t->port		= sport;
-		mCast_t->mbr		= 0;
-		mCast_t->count		= 0;
-		mCast_t->maxPPS		= 0;
-		mCast_t->inAsic		= FALSE;
-	}
-	
-	if(flushOldChain)
-	{
-		_rtl865x_flushMCastFwdDescChain(&mCast_t->fwdDescChain);
-		
-	}
-	
-	_rtl865x_mergeMCastFwdDescChain(&mCast_t->fwdDescChain,newFwdDescChain);
-	_rtl865x_doMCastEntrySrcVlanPortFilter(mCast_t);
-	
-	mCast_t->mbr			= rtl865x_genMCastEntryAsicFwdMask(mCast_t);
-	mCast_t->extIp			= extIp;
-
-	mCast_t->age			= RTL865X_MULTICAST_TABLE_AGE;
-#if 0
-	mCast_t->cpu			= (toCpu==TRUE? 1: 0);
-#else
-	mCast_t->cpuHold			= cpuHold;
-	mCast_t->cpu 			= rtl865x_genMCastEntryCpuFlag(mCast_t);
-#endif	
-	mCast_t->flag			= flag;
-	
-	if (extIp)
-		mCast_t->flag |= RTL865X_MULTICAST_EXTIP_SET;
-	else
-		mCast_t->flag &= ~RTL865X_MULTICAST_EXTIP_SET;
-
-	rtl_getGroupInfo(mAddr, &groupInfo);
-	if(groupInfo.ownerMask==0)
-	{
-		mCast_t->unKnownMCast=TRUE;
-	}
-	else
-	{
-		mCast_t->unKnownMCast=FALSE;
-	}
-	
-	_rtl865x_patchPppoeWeak(mCast_t);
-	_rtl865x_arrangeMulticast(hashIndex);
-	return SUCCESS;	
-}
-
-
+@func int32	| rtl865x_addMulticastEntry	|  API to add a hardwawre multicast forwarding entry.
+@parm  ipaddr_t 	| mAddr	| Multicast flow Destination group address. 
+@parm  ipaddr_t 	| sip	| Multicast flow source ip address. 
+@parm  uint16 	| svid	| Multicast flow input vlan index. 
+@parm  uint16		| sport	| Multicast flow input port number. 
+@parm  rtl865x_mcast_fwd_descriptor_t *	| newFwdDescChain	| Multicast flow forwarding descriptor chain to be added. 
+@parm  int32 	| flushOldChain	| Flag to indicate to flush old mulicast forwarding descriptor chain or not. 1 is to flush old chain, and 0 is not to. 
+@parm  ipaddr_t 	| extIp	| External source ip address used when forward multicast data from lan to wan. 
+@parm  int8	| toCpu	| Cpu forwarding flag, 1 is to forward multicast data by cpu,and  0 is not.
+@parm  int8	| flag	| For future usage, set to 0 at present.
+@rvalue SUCCESS	|Add hardware multicast forwarding entry successfully. 
+@rvalue FAILED	|Add hardware multicast forwarding entry failed.
+*/
+int32 rtl865x_addMulticastEntry(ipaddr_t mAddr, ipaddr_t sip, uint16 svid, uint16 sport, 
+									rtl865x_mcast_fwd_descriptor_t * newFwdDescChain, 
+									int32 flushOldChain, ipaddr_t extIp, char cpuHold, uint8 flag)
+{
+
+	rtl865x_tblDrv_mCast_t *mCast_t;
+	uint32 hashIndex = rtl8651_ipMulticastTableIndex(sip, mAddr);
+	#if defined (CONFIG_RTL_IGMP_SNOOPING)
+	struct rtl_groupInfo groupInfo;
+	#endif
+	/*windows xp upnp:239.255.255.0*/
+	if(mAddr==0xEFFFFFFA)
+	{
+		return FAILED;
+	}
+#if 0
+	/*reserved multicast address 224.0.0.x*/
+	if((mAddr & 0xFFFFFF00) == 0xE0000000)
+	{
+		return FAILED;
+	}
+#endif	
+	/*try to match hash line*/
+	TAILQ_FOREACH(mCast_t, &mCastTbl.inuseList.mCastTbl[hashIndex], nextMCast) 
+	{
+		if (mCast_t->sip==sip && mCast_t->dip==mAddr && mCast_t->svid==svid && mCast_t->port==sport)
+			break;
+	}
+	
+	if (mCast_t == NULL) 
+	{
+		mCast_t=_rtl865x_allocMCastEntry(hashIndex);
+		if (mCast_t == NULL)
+		{
+			_rtl865x_mCastEntryReclaim();
+			mCast_t=_rtl865x_allocMCastEntry(hashIndex);
+			if(mCast_t == NULL)
+			{
+				return FAILED;
+			}
+		}
+		mCast_t->sip			= sip;
+		mCast_t->dip			= mAddr;
+		mCast_t->svid		= svid;
+		mCast_t->port		= sport;
+		mCast_t->mbr		= 0;
+		mCast_t->count		= 0;
+		mCast_t->maxPPS		= 0;
+		mCast_t->inAsic		= FALSE;
+	}
+	
+	if(flushOldChain)
+	{
+		_rtl865x_flushMCastFwdDescChain(&mCast_t->fwdDescChain);
+		
+	}
+	
+	_rtl865x_mergeMCastFwdDescChain(&mCast_t->fwdDescChain,newFwdDescChain);
+	_rtl865x_doMCastEntrySrcVlanPortFilter(mCast_t);
+	
+	mCast_t->mbr			= rtl865x_genMCastEntryAsicFwdMask(mCast_t);
+	mCast_t->extIp			= extIp;
+
+	mCast_t->age			= RTL865X_MULTICAST_TABLE_AGE;
+#if 0
+	mCast_t->cpu			= (toCpu==TRUE? 1: 0);
+#else
+	mCast_t->cpuHold			= cpuHold;
+	mCast_t->cpu 			= rtl865x_genMCastEntryCpuFlag(mCast_t);
+#endif	
+	mCast_t->flag			= flag;
+	
+	if (extIp)
+		mCast_t->flag |= RTL865X_MULTICAST_EXTIP_SET;
+	else
+		mCast_t->flag &= ~RTL865X_MULTICAST_EXTIP_SET;
+	#if defined (CONFIG_RTL_IGMP_SNOOPING)
+	rtl_getGroupInfo(mAddr, &groupInfo);
+	if(groupInfo.ownerMask==0)
+	{
+		mCast_t->unKnownMCast=TRUE;
+	}
+	else
+	{
+		mCast_t->unKnownMCast=FALSE;
+	}
+	#endif
+	_rtl865x_patchPppoeWeak(mCast_t);
+	_rtl865x_arrangeMulticast(hashIndex);
+	return SUCCESS;	
+}
+
+
 /*
-@func int32	| rtl865x_delMulticastEntry	|  API to delete multicast forwarding entry related with a certain group address.
-@parm  ipaddr_t 	| mcast_addr	| Group address to be mached in deleting hardware multicast forwarding entry. 
-@rvalue SUCCESS	|Delete hardware multicast forwarding entry successfully. 
-@rvalue FAILED	|Delete hardware multicast forwarding entry failed.
-*/
-int32 rtl865x_delMulticastEntry(ipaddr_t mcast_addr)
-{
-
-	rtl865x_tblDrv_mCast_t *mCastEntry, *nextMCastEntry;
-	uint32 entry;
-	uint32 deleteFlag=FALSE;
-
-	for(entry=0; entry<RTL8651_MULTICASTTBL_SIZE; entry++) 
-	{
-		deleteFlag=FALSE;
-		mCastEntry = TAILQ_FIRST(&mCastTbl.inuseList.mCastTbl[entry]);
-		while (mCastEntry)
-		{
-			nextMCastEntry = TAILQ_NEXT(mCastEntry, nextMCast);
-			if (!mcast_addr || mCastEntry->dip == mcast_addr) 
-			{
-				deleteFlag=TRUE;
-				_rtl865x_freeMCastEntry(mCastEntry, entry);
-			}
-			
-			mCastEntry = nextMCastEntry;
-		}
-		
-		if(deleteFlag==TRUE)
-		{
-			_rtl865x_arrangeMulticast(entry);
-		}
-	}
-
-	return SUCCESS;
-}
-
-#if 0
-/*the following function maybe used in future*/
-
-int32 rtl865x_addMulticastFwdDesc(ipaddr_t mcast_addr, rtl865x_mcast_fwd_descriptor_t * newFwdDesc)
-{
-
-	rtl865x_tblDrv_mCast_t *mCast_t;
-	uint32 entry, matchedIdx = 0;
-	uint32 oldFwdPortMask,newFwdPortMask;
-	if(newFwdDesc==NULL)
-	{
-		return SUCCESS;
-	}
-
-	for (entry=0; entry< RTL8651_MULTICASTTBL_SIZE; entry++)
-	{
-		TAILQ_FOREACH(mCast_t, &mCastTbl.inuseList.mCastTbl[entry], nextMCast)
-		{
-			if (mCast_t->dip != mcast_addr)
-				continue;
-
-			oldFwdPortMask=mCast_t->mbr;
-
-			_rtl865x_mergeMCastFwdDescChain(&mCast_t->fwdDescChain,newFwdDesc);
-			_rtl865x_doMCastEntrySrcVlanPortFilter(mCast_t);
-			
-			mCast_t->mbr 		= rtl865x_genMCastEntryFwdMask(mCast_t);
-			newFwdPortMask		= mCast_t->mbr ;
-#ifndef RTL8651_MCAST_ALWAYS2UPSTREAM
-			if (mCast_t->flag & RTL865X_MULTICAST_UPLOADONLY)
-			{	/* remove upload term*/
-				if(oldFwdPortMask!=newFwdPortMask)
-				{
-					mCast_t->flag &= ~RTL865X_MULTICAST_UPLOADONLY;
-					/* we assume multicast member will NEVER in External interface, so we remove
-					     external ip now */
-					mCast_t->flag &= ~RTL865X_MULTICAST_EXTIP_SET;
-					mCast_t->extIp= 0;
-				}
-			}
-#endif /* RTL8651_MCAST_ALWAYS2UPSTREAM */
-
-			_rtl865x_patchPppoeWeak(mCast_t);
-			_rtl865x_arrangeMulticast(entry);
-			matchedIdx = entry;
-		}
-	}
-
-	if (matchedIdx) 
-	{
-		return SUCCESS;
-	}
-	return FAILED;
-}
-
-int32 rtl865x_delMulticastFwdDesc(ipaddr_t mcast_addr,  rtl865x_mcast_fwd_descriptor_t * deadFwdDesc)
-{
-
-	uint32 index;
-	rtl865x_tblDrv_mCast_t  *mCastEntry, *nextMCastEntry;
-	uint32 oldFwdPortMask,newFwdPortMask;
-	
-	for(index=0; index<RTL8651_MULTICASTTBL_SIZE; index++) 
-	{
-
-		for (mCastEntry = TAILQ_FIRST(&mCastTbl.inuseList.mCastTbl[index]); mCastEntry; mCastEntry = nextMCastEntry)
-		{
-			nextMCastEntry=TAILQ_NEXT(mCastEntry, nextMCast);
-			
-			if ((mcast_addr) && (mCastEntry->dip != mcast_addr))
-			{
-				continue;
-			}
-			
-			oldFwdPortMask=mCastEntry->mbr;
-		
-			_rtl865x_subMCastFwdDescChain(&mCastEntry->fwdDescChain, deadFwdDesc);
-			
-			mCastEntry->mbr=rtl865x_genMCastEntryFwdMask(mCastEntry);
-			newFwdPortMask=mCastEntry->mbr; 	
-			if (mCastEntry->mbr == 0)
-			{
-				/*to-do:unknown multicast hardware blocking*/
-				_rtl865x_freeMCastEntry(mCastEntry, index);
-				mCastEntry=NULL;
-				_rtl865x_arrangeMulticast(index);
-			}
-			else
-			{
-			
-				_rtl865x_patchPppoeWeak(mCastEntry);
-			}
-			
-		}
-			
-		_rtl865x_arrangeMulticast(index);
-	}
-
-	return SUCCESS;
-}
-
-int32 rtl865x_delMulticastUpStream(ipaddr_t mcast_addr, ipaddr_t sip, uint16 svid, uint16 sport)
-{
-	uint32 index;
-	rtl865x_tblDrv_mCast_t *mCast_t;
-	
-	for(index=0; index<RTL8651_MULTICASTTBL_SIZE; index++) 
-	{
-		TAILQ_FOREACH(mCast_t, &mCastTbl.inuseList.mCastTbl[index], nextMCast) 
-		{
-			if ((!mcast_addr || mCast_t->dip == mcast_addr) && 
-				(!sip || mCast_t->sip==sip) && 
-				(!svid || mCast_t->svid==svid) && 
-				mCast_t->port==sport)
-			{
-				_rtl865x_freeMCastEntry(mCast_t, index);
-				_rtl865x_arrangeMulticast(index);
-				return SUCCESS;
-			}
-		}
-	}
-	return FAILED;
-}
-
-int32 rtl865x_delMulticastByVid(uint32 vid)
-{
-	uint16 sport;
-	uint32 sportMask;
-	rtl865x_mcast_fwd_descriptor_t vlanFwdDesc;
-	memset(&vlanFwdDesc,0,sizeof(rtl865x_mcast_fwd_descriptor_t));
-	
-	/* delete all upstream related to vid */
-	sport = 0;
-	sportMask=rtl865x_getVlanPortMask(vid);
-	while (sportMask) 
-	{
-		if (sportMask & 1)
-		{
-			rtl865x_delMulticastUpStream(0, 0, vid, sport);
-		}
-		
-		sportMask = sportMask >> 1;
-		sport ++;
-	}
-	
-	/* delete all downstream related to vid*/
-	vlanFwdDesc.vid=vid;
-	vlanFwdDesc.fwdPortMask=rtl865x_getVlanPortMask(vid);
-	rtl865x_delMulticastFwdDesc(0, &vlanFwdDesc);
-
-	return FAILED;
-}
-
-int32 rtl865x_delMulticastByPort(uint32 port)
-{
-
-	rtl865x_mcast_fwd_descriptor_t portFwdDesc;
-	memset(&portFwdDesc,0,sizeof(rtl865x_mcast_fwd_descriptor_t));
-	
-	/* delete all upstream related to this port */
-	rtl865x_delMulticastUpStream(0, 0, 0, port);
-
-	/* delete all downstream related to this port*/
-	portFwdDesc.vid=0;
-	portFwdDesc.fwdPortMask=1<<port;
-	rtl865x_delMulticastFwdDesc(0, &portFwdDesc);
-
-	return SUCCESS;
-}
-
-int32 rtl865x_setMGroupAttribute(ipaddr_t groupIp, int8 toCpu)
-{
-	uint32 index;
-	rtl865x_tblDrv_mCast_t *mCast_t;
-
-	for(index=0; index<RTL8651_MULTICASTTBL_SIZE; index++) 
-	{
-		TAILQ_FOREACH(mCast_t, &mCastTbl.inuseList.mCastTbl[index], nextMCast) 
-		{
-			if (mCast_t->dip == groupIp)
-			{
-				mCast_t->cpu = (toCpu==TRUE? 1: 0);
-			}
-		}
-		_rtl865x_arrangeMulticast(index);
-	}
-	return SUCCESS;
-}
-
-
-static int32 _rtl865x_subMCastFwdDescChain(mcast_fwd_descriptor_head_t * targetChainHead,rtl865x_mcast_fwd_descriptor_t *srcChain)
-{
-	rtl865x_mcast_fwd_descriptor_t *curDesc;
-	if(targetChainHead==NULL)
-	{
-		return FAILED;
-	}
-	
-	for(curDesc=srcChain; curDesc!=NULL; curDesc=MC_LIST_NEXT(curDesc,next))
-	{
-		_rtl865x_mCastFwdDescDequeue(targetChainHead, curDesc);
-	}
-
-	return SUCCESS;
-}
-
-static int32 _rtl865x_mCastFwdDescDequeue(mcast_fwd_descriptor_head_t * queueHead,rtl865x_mcast_fwd_descriptor_t * dequeueDesc)
-{
-	rtl865x_mcast_fwd_descriptor_t *curDesc,*nextDesc;
-	
-	if(queueHead==NULL)
-	{
-		return FAILED;
-	}
-	
-	if(dequeueDesc==NULL)
-	{
-		return FAILED;
-	}
-
-	for(curDesc=MC_LIST_FIRST(queueHead);curDesc!=NULL;curDesc=nextDesc)
-	{
-		nextDesc=MC_LIST_NEXT(curDesc, next );
-		if((strcmp(curDesc->netifName,dequeueDesc->netifName)==0) ||
-			((dequeueDesc->vid==0 ) ||(curDesc->vid==dequeueDesc->vid)))
-		{
-			curDesc->fwdPortMask &= (~dequeueDesc->fwdPortMask);
-			if(curDesc->fwdPortMask==0)
-			{
-				/*remove from the old descriptor chain*/
-				MC_LIST_REMOVE(curDesc, next);
-				/*return to the free descriptor chain*/
-				_rtl865x_freeMCastFwdDesc(curDesc);
-
-			}
-
-			return SUCCESS;
-		}
-	}
-
-	/*never reach here*/
-	return SUCCESS;
-}
-
-#endif
-
-static int32 rtl865x_multicastCallbackFn(void *param)
-{
-	uint32 index;
-	uint32 oldDescPortMask,newDescPortMask;/*for device decriptor forwarding usage*/
-	
-	uint32 oldAsicFwdPortMask,newAsicFwdPortMask;/*for physical port forwarding usage*/
-	uint32 oldCpuFlag,newCpuFlag;
-	
-	rtl_multicastEventContext_t mcastEventContext;
-
-	rtl865x_mcast_fwd_descriptor_t newFwdDesc;
-	struct rtl_multicastDataInfo multicastDataInfo;
-	struct rtl_multicastFwdInfo multicastFwdInfo;
-	rtl865x_tblDrv_mCast_t  *mCastEntry,*nextMCastEntry;
-	struct rtl_multicastDeviceInfo_s bridgeMCastDev;
-
-	struct rtl_groupInfo groupInfo;
-	int32 retVal=FAILED;
-
-	if(param==NULL)
-	{
-		return EVENT_CONTINUE_EXECUTE;
-	}
-	memcpy(&mcastEventContext,param,sizeof(rtl_multicastEventContext_t));
-	/*check device name's validity*/
-	if(strlen(mcastEventContext.devName)==0)
-	{
-		return EVENT_CONTINUE_EXECUTE;
-	}
-	#ifdef CONFIG_RTL865X_MUTLICAST_DEBUG
-	printk("%s:%d,mcastEventContext.devName is %s, mcastEventContext.groupAddr is 0x%x,mcastEventContext.sourceAdd is 0x%x,mcastEventContext.portMask is 0x%x\n",__FUNCTION__,__LINE__,mcastEventContext.devName, mcastEventContext.groupAddr[0], mcastEventContext.sourceAddr[0], mcastEventContext.portMask);
-	#endif
-	/*case 1:this is multicast event from bridge(br0) */
-	/*sync wlan and ethernet*/
-	//hyking:[Fix me] the RTL_BR_NAME...
-	if(memcmp(mcastEventContext.devName,RTL_BR_NAME,3)==0)
-	{
-
-		for (index=0; index< RTL8651_MULTICASTTBL_SIZE; index++)
-		{
-			for (mCastEntry = TAILQ_FIRST(&mCastTbl.inuseList.mCastTbl[index]); mCastEntry; mCastEntry = nextMCastEntry)
-			{
-				nextMCastEntry=TAILQ_NEXT(mCastEntry, nextMCast);
-				
-				if ((mcastEventContext.groupAddr!=0) && (mCastEntry->dip != mcastEventContext.groupAddr[0]))
-				{
-					continue;
-				}
-
-				rtl_getGroupInfo(mCastEntry->dip, &groupInfo);
-				if(groupInfo.ownerMask==0)
-				{
-					mCastEntry->unKnownMCast=TRUE;
-				}
-				else
-				{
-					mCastEntry->unKnownMCast=FALSE;
-				}
-
-				oldDescPortMask=rtl865x_getMCastEntryDescPortMask( mCastEntry);			
-				
-				/*sync with control plane*/
-				memset(&newFwdDesc, 0 ,sizeof(rtl865x_mcast_fwd_descriptor_t));
-				strcpy(newFwdDesc.netifName,mcastEventContext.devName);
-				multicastDataInfo.ipVersion=4;
-				multicastDataInfo.sourceIp[0]=  mCastEntry->sip;
-				multicastDataInfo.groupAddr[0]= mCastEntry->dip;
-				retVal= rtl_getMulticastDataFwdInfo(mcastEventContext.moduleIndex, &multicastDataInfo, &multicastFwdInfo);
-				
-
-				if(retVal!=SUCCESS)
-				{
-					continue;
-				}
-				
-				retVal= rtl_getIgmpSnoopingModuleDevInfo(mcastEventContext.moduleIndex, &bridgeMCastDev);
-				if(retVal!=SUCCESS)
-				{
-					continue;
-				}
-				newDescPortMask=multicastFwdInfo.fwdPortMask;
-				if(	(oldDescPortMask != newDescPortMask) &&
-					(	((newDescPortMask & bridgeMCastDev.swPortMask)!=0) ||
-						(((oldDescPortMask & bridgeMCastDev.swPortMask) !=0) && ((newDescPortMask & bridgeMCastDev.swPortMask)==0)))	)
-				{
-					/*this multicast entry should be re-generated at linux protocol stack bridge level*/
-					_rtl865x_freeMCastEntry(mCastEntry, index);
-					_rtl865x_arrangeMulticast(index);
-				}
-				
-			}
-		}
-		
-		return EVENT_CONTINUE_EXECUTE;
-	}
-			
-	/*case 2:this is multicast event from ethernet (eth0)*/
-	/*update ethernet forwarding port mask*/
-	if(memcmp(mcastEventContext.devName,"eth*",4)==0)
-	{
-		#ifdef CONFIG_RTL865X_MUTLICAST_DEBUG
-		printk("%s:%d,multicast event from ethernet (%s),mcastEventContext.groupAddr[0] is 0x%x\n",__FUNCTION__,__LINE__,mcastEventContext.devName,mcastEventContext.groupAddr[0]);
-		#endif
-		
-		for (index=0; index< RTL8651_MULTICASTTBL_SIZE; index++)
-		{
-			for (mCastEntry = TAILQ_FIRST(&mCastTbl.inuseList.mCastTbl[index]); mCastEntry; mCastEntry = nextMCastEntry)
-			{
-				nextMCastEntry=TAILQ_NEXT(mCastEntry, nextMCast);
-				
-				if ((mcastEventContext.groupAddr!=0) && (mCastEntry->dip != mcastEventContext.groupAddr[0]))
-				{
-					continue;
-				}
-				
-				memset(&newFwdDesc, 0 ,sizeof(rtl865x_mcast_fwd_descriptor_t));
-				strcpy(newFwdDesc.netifName,mcastEventContext.devName);
-
-				/*save old multicast entry forward port mask*/
-				oldAsicFwdPortMask=mCastEntry->mbr;
-				oldCpuFlag=mCastEntry->cpu;
-
-				/*sync with control plane*/
-				multicastDataInfo.ipVersion=4;
-				multicastDataInfo.sourceIp[0]=  mCastEntry->sip;
-				multicastDataInfo.groupAddr[0]= mCastEntry->dip;
-				retVal= rtl_getMulticastDataFwdInfo(mcastEventContext.moduleIndex, &multicastDataInfo, &multicastFwdInfo);
-
-				newFwdDesc.fwdPortMask=multicastFwdInfo.fwdPortMask & (~(1<<mCastEntry->port));
-				newFwdDesc.toCpu=multicastFwdInfo.cpuFlag;
-			
-				/*update/replace old forward descriptor*/
-				
-				_rtl865x_mergeMCastFwdDescChain(&mCastEntry->fwdDescChain,&newFwdDesc);
-				mCastEntry->mbr 		= rtl865x_genMCastEntryAsicFwdMask(mCastEntry);
-				mCastEntry->cpu		= rtl865x_genMCastEntryCpuFlag(mCastEntry);
-				
-				newAsicFwdPortMask	= mCastEntry->mbr ;
-				newCpuFlag			=mCastEntry->cpu;
-				
-				#ifdef CONFIG_RTL865X_MUTLICAST_DEBUG
-				printk("%s:%d,oldAsicFwdPortMask is %d,newAsicFwdPortMask is %d\n",__FUNCTION__,__LINE__,oldAsicFwdPortMask,newAsicFwdPortMask);
-				#endif
-				
-#ifndef RTL8651_MCAST_ALWAYS2UPSTREAM
-				if (mCastEntry->flag & RTL865X_MULTICAST_UPLOADONLY)
-				{	/* remove upload term*/
-					if((newAsicFwdPortMask!=0) && (newAsicFwdPortMask!=oldAsicFwdPortMask))
-					{
-						mCastEntry->flag &= ~RTL865X_MULTICAST_UPLOADONLY;
-						/* we assume multicast member will NEVER in External interface, so we remove
-						     external ip now */
-						mCastEntry->flag &= ~RTL865X_MULTICAST_EXTIP_SET;
-						mCastEntry->extIp= 0;
-					}
-				}
-#endif /* RTL8651_MCAST_ALWAYS2UPSTREAM */
-
-				rtl_getGroupInfo(mCastEntry->dip, &groupInfo);
-				if(groupInfo.ownerMask==0)
-				{
-					mCastEntry->unKnownMCast=TRUE;
-				}
-				else
-				{
-					mCastEntry->unKnownMCast=FALSE;
-				}
-	
-				
-				if((oldCpuFlag != newCpuFlag)||(newAsicFwdPortMask!=oldAsicFwdPortMask)) 
-				{
-					_rtl865x_patchPppoeWeak(mCastEntry);
-					
-					/*reset inAsic flag to re-select or re-write this hardware asic entry*/
-					if(newAsicFwdPortMask==0)
-					{
-						_rtl865x_freeMCastEntry(mCastEntry, index);
-					}
-
-					_rtl865x_arrangeMulticast(index);
-				}
-			}
-
-				
-			
-		}
-	}
-
-	return EVENT_CONTINUE_EXECUTE;
-}
-
-static int32 _rtl865x_multicastUnRegisterEvent(void)
-{
-	rtl865x_event_Param_t eventParam;
-
-	eventParam.eventLayerId=DEFAULT_LAYER3_EVENT_LIST_ID;
-	eventParam.eventId=EVENT_UPDATE_MCAST;
-	eventParam.eventPriority=0;
-	eventParam.event_action_fn=rtl865x_multicastCallbackFn;
-	rtl865x_unRegisterEvent(&eventParam);
-
-	return SUCCESS;
-}
-
-static int32 _rtl865x_multicastRegisterEvent(void)
-{
-	rtl865x_event_Param_t eventParam;
-
-	eventParam.eventLayerId=DEFAULT_LAYER3_EVENT_LIST_ID;
-	eventParam.eventId=EVENT_UPDATE_MCAST;
-	eventParam.eventPriority=0;
-	eventParam.event_action_fn=rtl865x_multicastCallbackFn;
-	rtl865x_registerEvent(&eventParam);
-
-	return SUCCESS;
-}
-
-
-void _rtl865x_timeUpdateMulticast(uint32 secPassed)
-{
-
-	rtl865x_tblDrv_mCast_t *mCast_t, *nextMCast_t;
-	uint32 entry;
-	uint32 needReArrange=FALSE;
-	/* check to Aging and HW swapping */
-	for (entry=0; entry< RTL8651_MULTICASTTBL_SIZE; entry++) {
-		needReArrange=FALSE;
-		mCast_t = TAILQ_FIRST(&mCastTbl.inuseList.mCastTbl[entry]);
-		while (mCast_t) {
-			/*save the next entry first*/
-			nextMCast_t=TAILQ_NEXT(mCast_t, nextMCast);
-			
-			if (mCast_t->inAsic == TRUE)
-			{
-				/* Entry is in the ASIC */
-				if (mCast_t->age <= secPassed) 
-				{
-					if(mCast_t->mbr==0)
-					{
-						_rtl865x_freeMCastEntry(mCast_t, entry);
-						needReArrange=TRUE;
-					}
-					else
-					{
-						mCast_t->age = RTL865X_MULTICAST_TABLE_AGE;
-					}
-				}
-				else
-				{
-					mCast_t->age -= secPassed;
-				}
-			}
-			else 
-			{
-				/* Entry is not in the ASIC */
-				if(mCast_t->maxPPS<mCast_t->count)
-				{
-					mCast_t->maxPPS=mCast_t->count ;
-				}
-				
-				if(mCast_t->maxPPS>0)
-				{
-					mCast_t->maxPPS--;
-				}
-				
-				if (mCast_t->age <= secPassed)
-				{ /* aging out */
-					_rtl865x_freeMCastEntry(mCast_t, entry);
-				}
-				else 
-				{
-					mCast_t->age -= secPassed;
-				}
-			}
-			
-			mCast_t->count = 0;
-			mCast_t = nextMCast_t;
-		}
-
-		if(needReArrange==TRUE)
-		{
-			_rtl865x_arrangeMulticast(entry);
-		}
-	
-	}
-}
-
-#if defined(__linux__) && defined(__KERNEL__)
-static void _rtl865x_mCastSysTimerExpired(uint32 expireDada)
+@func int32	| rtl865x_delMulticastEntry	|  API to delete multicast forwarding entry related with a certain group address.
+@parm  ipaddr_t 	| mcast_addr	| Group address to be mached in deleting hardware multicast forwarding entry. 
+@rvalue SUCCESS	|Delete hardware multicast forwarding entry successfully. 
+@rvalue FAILED	|Delete hardware multicast forwarding entry failed.
+*/
+int32 rtl865x_delMulticastEntry(ipaddr_t mcast_addr)
+{
+
+	rtl865x_tblDrv_mCast_t *mCastEntry, *nextMCastEntry;
+	uint32 entry;
+	uint32 deleteFlag=FALSE;
+
+	for(entry=0; entry<RTL8651_MULTICASTTBL_SIZE; entry++) 
+	{
+		deleteFlag=FALSE;
+		mCastEntry = TAILQ_FIRST(&mCastTbl.inuseList.mCastTbl[entry]);
+		while (mCastEntry)
+		{
+			nextMCastEntry = TAILQ_NEXT(mCastEntry, nextMCast);
+			if (!mcast_addr || mCastEntry->dip == mcast_addr) 
+			{
+				deleteFlag=TRUE;
+				_rtl865x_freeMCastEntry(mCastEntry, entry);
+			}
+			
+			mCastEntry = nextMCastEntry;
+		}
+		
+		if(deleteFlag==TRUE)
+		{
+			_rtl865x_arrangeMulticast(entry);
+		}
+	}
+
+	return SUCCESS;
+}
+
+#if 0
+/*the following function maybe used in future*/
+
+int32 rtl865x_addMulticastFwdDesc(ipaddr_t mcast_addr, rtl865x_mcast_fwd_descriptor_t * newFwdDesc)
+{
+
+	rtl865x_tblDrv_mCast_t *mCast_t;
+	uint32 entry, matchedIdx = 0;
+	uint32 oldFwdPortMask,newFwdPortMask;
+	if(newFwdDesc==NULL)
+	{
+		return SUCCESS;
+	}
+
+	for (entry=0; entry< RTL8651_MULTICASTTBL_SIZE; entry++)
+	{
+		TAILQ_FOREACH(mCast_t, &mCastTbl.inuseList.mCastTbl[entry], nextMCast)
+		{
+			if (mCast_t->dip != mcast_addr)
+				continue;
+
+			oldFwdPortMask=mCast_t->mbr;
+
+			_rtl865x_mergeMCastFwdDescChain(&mCast_t->fwdDescChain,newFwdDesc);
+			_rtl865x_doMCastEntrySrcVlanPortFilter(mCast_t);
+			
+			mCast_t->mbr 		= rtl865x_genMCastEntryFwdMask(mCast_t);
+			newFwdPortMask		= mCast_t->mbr ;
+#ifndef RTL8651_MCAST_ALWAYS2UPSTREAM
+			if (mCast_t->flag & RTL865X_MULTICAST_UPLOADONLY)
+			{	/* remove upload term*/
+				if(oldFwdPortMask!=newFwdPortMask)
+				{
+					mCast_t->flag &= ~RTL865X_MULTICAST_UPLOADONLY;
+					/* we assume multicast member will NEVER in External interface, so we remove
+					     external ip now */
+					mCast_t->flag &= ~RTL865X_MULTICAST_EXTIP_SET;
+					mCast_t->extIp= 0;
+				}
+			}
+#endif /* RTL8651_MCAST_ALWAYS2UPSTREAM */
+
+			_rtl865x_patchPppoeWeak(mCast_t);
+			_rtl865x_arrangeMulticast(entry);
+			matchedIdx = entry;
+		}
+	}
+
+	if (matchedIdx) 
+	{
+		return SUCCESS;
+	}
+	return FAILED;
+}
+
+int32 rtl865x_delMulticastFwdDesc(ipaddr_t mcast_addr,  rtl865x_mcast_fwd_descriptor_t * deadFwdDesc)
+{
+
+	uint32 index;
+	rtl865x_tblDrv_mCast_t  *mCastEntry, *nextMCastEntry;
+	uint32 oldFwdPortMask,newFwdPortMask;
+	
+	for(index=0; index<RTL8651_MULTICASTTBL_SIZE; index++) 
+	{
+
+		for (mCastEntry = TAILQ_FIRST(&mCastTbl.inuseList.mCastTbl[index]); mCastEntry; mCastEntry = nextMCastEntry)
+		{
+			nextMCastEntry=TAILQ_NEXT(mCastEntry, nextMCast);
+			
+			if ((mcast_addr) && (mCastEntry->dip != mcast_addr))
+			{
+				continue;
+			}
+			
+			oldFwdPortMask=mCastEntry->mbr;
+		
+			_rtl865x_subMCastFwdDescChain(&mCastEntry->fwdDescChain, deadFwdDesc);
+			
+			mCastEntry->mbr=rtl865x_genMCastEntryFwdMask(mCastEntry);
+			newFwdPortMask=mCastEntry->mbr; 	
+			if (mCastEntry->mbr == 0)
+			{
+				/*to-do:unknown multicast hardware blocking*/
+				_rtl865x_freeMCastEntry(mCastEntry, index);
+				mCastEntry=NULL;
+				_rtl865x_arrangeMulticast(index);
+			}
+			else
+			{
+			
+				_rtl865x_patchPppoeWeak(mCastEntry);
+			}
+			
+		}
+			
+		_rtl865x_arrangeMulticast(index);
+	}
+
+	return SUCCESS;
+}
+
+int32 rtl865x_delMulticastUpStream(ipaddr_t mcast_addr, ipaddr_t sip, uint16 svid, uint16 sport)
+{
+	uint32 index;
+	rtl865x_tblDrv_mCast_t *mCast_t;
+	
+	for(index=0; index<RTL8651_MULTICASTTBL_SIZE; index++) 
+	{
+		TAILQ_FOREACH(mCast_t, &mCastTbl.inuseList.mCastTbl[index], nextMCast) 
+		{
+			if ((!mcast_addr || mCast_t->dip == mcast_addr) && 
+				(!sip || mCast_t->sip==sip) && 
+				(!svid || mCast_t->svid==svid) && 
+				mCast_t->port==sport)
+			{
+				_rtl865x_freeMCastEntry(mCast_t, index);
+				_rtl865x_arrangeMulticast(index);
+				return SUCCESS;
+			}
+		}
+	}
+	return FAILED;
+}
+
+int32 rtl865x_delMulticastByVid(uint32 vid)
+{
+	uint16 sport;
+	uint32 sportMask;
+	rtl865x_mcast_fwd_descriptor_t vlanFwdDesc;
+	memset(&vlanFwdDesc,0,sizeof(rtl865x_mcast_fwd_descriptor_t));
+	
+	/* delete all upstream related to vid */
+	sport = 0;
+	sportMask=rtl865x_getVlanPortMask(vid);
+	while (sportMask) 
+	{
+		if (sportMask & 1)
+		{
+			rtl865x_delMulticastUpStream(0, 0, vid, sport);
+		}
+		
+		sportMask = sportMask >> 1;
+		sport ++;
+	}
+	
+	/* delete all downstream related to vid*/
+	vlanFwdDesc.vid=vid;
+	vlanFwdDesc.fwdPortMask=rtl865x_getVlanPortMask(vid);
+	rtl865x_delMulticastFwdDesc(0, &vlanFwdDesc);
+
+	return FAILED;
+}
+
+int32 rtl865x_delMulticastByPort(uint32 port)
+{
+
+	rtl865x_mcast_fwd_descriptor_t portFwdDesc;
+	memset(&portFwdDesc,0,sizeof(rtl865x_mcast_fwd_descriptor_t));
+	
+	/* delete all upstream related to this port */
+	rtl865x_delMulticastUpStream(0, 0, 0, port);
+
+	/* delete all downstream related to this port*/
+	portFwdDesc.vid=0;
+	portFwdDesc.fwdPortMask=1<<port;
+	rtl865x_delMulticastFwdDesc(0, &portFwdDesc);
+
+	return SUCCESS;
+}
+
+int32 rtl865x_setMGroupAttribute(ipaddr_t groupIp, int8 toCpu)
+{
+	uint32 index;
+	rtl865x_tblDrv_mCast_t *mCast_t;
+
+	for(index=0; index<RTL8651_MULTICASTTBL_SIZE; index++) 
+	{
+		TAILQ_FOREACH(mCast_t, &mCastTbl.inuseList.mCastTbl[index], nextMCast) 
+		{
+			if (mCast_t->dip == groupIp)
+			{
+				mCast_t->cpu = (toCpu==TRUE? 1: 0);
+			}
+		}
+		_rtl865x_arrangeMulticast(index);
+	}
+	return SUCCESS;
+}
+
+
+static int32 _rtl865x_subMCastFwdDescChain(mcast_fwd_descriptor_head_t * targetChainHead,rtl865x_mcast_fwd_descriptor_t *srcChain)
+{
+	rtl865x_mcast_fwd_descriptor_t *curDesc;
+	if(targetChainHead==NULL)
+	{
+		return FAILED;
+	}
+	
+	for(curDesc=srcChain; curDesc!=NULL; curDesc=MC_LIST_NEXT(curDesc,next))
+	{
+		_rtl865x_mCastFwdDescDequeue(targetChainHead, curDesc);
+	}
+
+	return SUCCESS;
+}
+
+static int32 _rtl865x_mCastFwdDescDequeue(mcast_fwd_descriptor_head_t * queueHead,rtl865x_mcast_fwd_descriptor_t * dequeueDesc)
+{
+	rtl865x_mcast_fwd_descriptor_t *curDesc,*nextDesc;
+	
+	if(queueHead==NULL)
+	{
+		return FAILED;
+	}
+	
+	if(dequeueDesc==NULL)
+	{
+		return FAILED;
+	}
+
+	for(curDesc=MC_LIST_FIRST(queueHead);curDesc!=NULL;curDesc=nextDesc)
+	{
+		nextDesc=MC_LIST_NEXT(curDesc, next );
+		if((strcmp(curDesc->netifName,dequeueDesc->netifName)==0) ||
+			((dequeueDesc->vid==0 ) ||(curDesc->vid==dequeueDesc->vid)))
+		{
+			curDesc->fwdPortMask &= (~dequeueDesc->fwdPortMask);
+			if(curDesc->fwdPortMask==0)
+			{
+				/*remove from the old descriptor chain*/
+				MC_LIST_REMOVE(curDesc, next);
+				/*return to the free descriptor chain*/
+				_rtl865x_freeMCastFwdDesc(curDesc);
+
+			}
+
+			return SUCCESS;
+		}
+	}
+
+	/*never reach here*/
+	return SUCCESS;
+}
+
+#endif
+
+static int32 rtl865x_multicastCallbackFn(void *param)
+{
+	#if defined (CONFIG_RTL_IGMP_SNOOPING)
+	uint32 index;
+	uint32 oldDescPortMask,newDescPortMask;/*for device decriptor forwarding usage*/
+	
+	uint32 oldAsicFwdPortMask,newAsicFwdPortMask;/*for physical port forwarding usage*/
+	uint32 oldCpuFlag,newCpuFlag;
+	
+	rtl_multicastEventContext_t mcastEventContext;
+
+	rtl865x_mcast_fwd_descriptor_t newFwdDesc;
+	struct rtl_multicastDataInfo multicastDataInfo;
+	struct rtl_multicastFwdInfo multicastFwdInfo;
+	rtl865x_tblDrv_mCast_t  *mCastEntry,*nextMCastEntry;
+	struct rtl_multicastDeviceInfo_s bridgeMCastDev;
+
+	struct rtl_groupInfo groupInfo;
+	int32 retVal=FAILED;
+
+	if(param==NULL)
+	{
+		return EVENT_CONTINUE_EXECUTE;
+	}
+	memcpy(&mcastEventContext,param,sizeof(rtl_multicastEventContext_t));
+	/*check device name's validity*/
+	if(strlen(mcastEventContext.devName)==0)
+	{
+		return EVENT_CONTINUE_EXECUTE;
+	}
+	#ifdef CONFIG_RTL865X_MUTLICAST_DEBUG
+	printk("%s:%d,mcastEventContext.devName is %s, mcastEventContext.groupAddr is 0x%x,mcastEventContext.sourceAdd is 0x%x,mcastEventContext.portMask is 0x%x\n",__FUNCTION__,__LINE__,mcastEventContext.devName, mcastEventContext.groupAddr[0], mcastEventContext.sourceAddr[0], mcastEventContext.portMask);
+	#endif
+	/*case 1:this is multicast event from bridge(br0) */
+	/*sync wlan and ethernet*/
+	//hyking:[Fix me] the RTL_BR_NAME...
+	if(memcmp(mcastEventContext.devName,RTL_BR_NAME,3)==0)
+	{
+
+		for (index=0; index< RTL8651_MULTICASTTBL_SIZE; index++)
+		{
+			for (mCastEntry = TAILQ_FIRST(&mCastTbl.inuseList.mCastTbl[index]); mCastEntry; mCastEntry = nextMCastEntry)
+			{
+				nextMCastEntry=TAILQ_NEXT(mCastEntry, nextMCast);
+				
+				if ((mcastEventContext.groupAddr!=0) && (mCastEntry->dip != mcastEventContext.groupAddr[0]))
+				{
+					continue;
+				}
+
+				rtl_getGroupInfo(mCastEntry->dip, &groupInfo);
+				if(groupInfo.ownerMask==0)
+				{
+					mCastEntry->unKnownMCast=TRUE;
+				}
+				else
+				{
+					mCastEntry->unKnownMCast=FALSE;
+				}
+
+				oldDescPortMask=rtl865x_getMCastEntryDescPortMask( mCastEntry);			
+				
+				/*sync with control plane*/
+				memset(&newFwdDesc, 0 ,sizeof(rtl865x_mcast_fwd_descriptor_t));
+				strcpy(newFwdDesc.netifName,mcastEventContext.devName);
+				multicastDataInfo.ipVersion=4;
+				multicastDataInfo.sourceIp[0]=  mCastEntry->sip;
+				multicastDataInfo.groupAddr[0]= mCastEntry->dip;
+				retVal= rtl_getMulticastDataFwdInfo(mcastEventContext.moduleIndex, &multicastDataInfo, &multicastFwdInfo);
+				
+
+				if(retVal!=SUCCESS)
+				{
+					continue;
+				}
+				
+				retVal= rtl_getIgmpSnoopingModuleDevInfo(mcastEventContext.moduleIndex, &bridgeMCastDev);
+				if(retVal!=SUCCESS)
+				{
+					continue;
+				}
+				newDescPortMask=multicastFwdInfo.fwdPortMask;
+				if(	(oldDescPortMask != newDescPortMask) &&
+					(	((newDescPortMask & bridgeMCastDev.swPortMask)!=0) ||
+						(((oldDescPortMask & bridgeMCastDev.swPortMask) !=0) && ((newDescPortMask & bridgeMCastDev.swPortMask)==0)))	)
+				{
+					/*this multicast entry should be re-generated at linux protocol stack bridge level*/
+					_rtl865x_freeMCastEntry(mCastEntry, index);
+					_rtl865x_arrangeMulticast(index);
+				}
+				
+			}
+		}
+		
+		return EVENT_CONTINUE_EXECUTE;
+	}
+			
+	/*case 2:this is multicast event from ethernet (eth0)*/
+	/*update ethernet forwarding port mask*/
+	if(memcmp(mcastEventContext.devName,"eth*",4)==0)
+	{
+		#ifdef CONFIG_RTL865X_MUTLICAST_DEBUG
+		printk("%s:%d,multicast event from ethernet (%s),mcastEventContext.groupAddr[0] is 0x%x\n",__FUNCTION__,__LINE__,mcastEventContext.devName,mcastEventContext.groupAddr[0]);
+		#endif
+		
+		for (index=0; index< RTL8651_MULTICASTTBL_SIZE; index++)
+		{
+			for (mCastEntry = TAILQ_FIRST(&mCastTbl.inuseList.mCastTbl[index]); mCastEntry; mCastEntry = nextMCastEntry)
+			{
+				nextMCastEntry=TAILQ_NEXT(mCastEntry, nextMCast);
+				
+				if ((mcastEventContext.groupAddr!=0) && (mCastEntry->dip != mcastEventContext.groupAddr[0]))
+				{
+					continue;
+				}
+				
+				memset(&newFwdDesc, 0 ,sizeof(rtl865x_mcast_fwd_descriptor_t));
+				strcpy(newFwdDesc.netifName,mcastEventContext.devName);
+
+				/*save old multicast entry forward port mask*/
+				oldAsicFwdPortMask=mCastEntry->mbr;
+				oldCpuFlag=mCastEntry->cpu;
+
+				/*sync with control plane*/
+				multicastDataInfo.ipVersion=4;
+				multicastDataInfo.sourceIp[0]=  mCastEntry->sip;
+				multicastDataInfo.groupAddr[0]= mCastEntry->dip;
+				retVal= rtl_getMulticastDataFwdInfo(mcastEventContext.moduleIndex, &multicastDataInfo, &multicastFwdInfo);
+
+				newFwdDesc.fwdPortMask=multicastFwdInfo.fwdPortMask & (~(1<<mCastEntry->port));
+				newFwdDesc.toCpu=multicastFwdInfo.cpuFlag;
+			
+				/*update/replace old forward descriptor*/
+				
+				_rtl865x_mergeMCastFwdDescChain(&mCastEntry->fwdDescChain,&newFwdDesc);
+				mCastEntry->mbr 		= rtl865x_genMCastEntryAsicFwdMask(mCastEntry);
+				mCastEntry->cpu		= rtl865x_genMCastEntryCpuFlag(mCastEntry);
+				
+				newAsicFwdPortMask	= mCastEntry->mbr ;
+				newCpuFlag			=mCastEntry->cpu;
+				
+				#ifdef CONFIG_RTL865X_MUTLICAST_DEBUG
+				printk("%s:%d,oldAsicFwdPortMask is %d,newAsicFwdPortMask is %d\n",__FUNCTION__,__LINE__,oldAsicFwdPortMask,newAsicFwdPortMask);
+				#endif
+				
+#ifndef RTL8651_MCAST_ALWAYS2UPSTREAM
+				if (mCastEntry->flag & RTL865X_MULTICAST_UPLOADONLY)
+				{	/* remove upload term*/
+					if((newAsicFwdPortMask!=0) && (newAsicFwdPortMask!=oldAsicFwdPortMask))
+					{
+						mCastEntry->flag &= ~RTL865X_MULTICAST_UPLOADONLY;
+						/* we assume multicast member will NEVER in External interface, so we remove
+						     external ip now */
+						mCastEntry->flag &= ~RTL865X_MULTICAST_EXTIP_SET;
+						mCastEntry->extIp= 0;
+					}
+				}
+#endif /* RTL8651_MCAST_ALWAYS2UPSTREAM */
+
+				rtl_getGroupInfo(mCastEntry->dip, &groupInfo);
+				if(groupInfo.ownerMask==0)
+				{
+					mCastEntry->unKnownMCast=TRUE;
+				}
+				else
+				{
+					mCastEntry->unKnownMCast=FALSE;
+				}
+	
+				
+				if((oldCpuFlag != newCpuFlag)||(newAsicFwdPortMask!=oldAsicFwdPortMask)) 
+				{
+					_rtl865x_patchPppoeWeak(mCastEntry);
+					
+					/*reset inAsic flag to re-select or re-write this hardware asic entry*/
+					if(newAsicFwdPortMask==0)
+					{
+						_rtl865x_freeMCastEntry(mCastEntry, index);
+					}
+
+					_rtl865x_arrangeMulticast(index);
+				}
+			}
+
+				
+			
+		}
+	}
+	#endif
+	return EVENT_CONTINUE_EXECUTE;
+}
+
+static int32 _rtl865x_multicastUnRegisterEvent(void)
+{
+	rtl865x_event_Param_t eventParam;
+
+	eventParam.eventLayerId=DEFAULT_LAYER3_EVENT_LIST_ID;
+	eventParam.eventId=EVENT_UPDATE_MCAST;
+	eventParam.eventPriority=0;
+	eventParam.event_action_fn=rtl865x_multicastCallbackFn;
+	rtl865x_unRegisterEvent(&eventParam);
+
+	return SUCCESS;
+}
+
+static int32 _rtl865x_multicastRegisterEvent(void)
+{
+	rtl865x_event_Param_t eventParam;
+
+	eventParam.eventLayerId=DEFAULT_LAYER3_EVENT_LIST_ID;
+	eventParam.eventId=EVENT_UPDATE_MCAST;
+	eventParam.eventPriority=0;
+	eventParam.event_action_fn=rtl865x_multicastCallbackFn;
+	rtl865x_registerEvent(&eventParam);
+
+	return SUCCESS;
+}
+
+
+void _rtl865x_timeUpdateMulticast(uint32 secPassed)
+{
+
+	rtl865x_tblDrv_mCast_t *mCast_t, *nextMCast_t;
+	uint32 entry;
+	uint32 needReArrange=FALSE;
+	/* check to Aging and HW swapping */
+	for (entry=0; entry< RTL8651_MULTICASTTBL_SIZE; entry++) {
+		needReArrange=FALSE;
+		mCast_t = TAILQ_FIRST(&mCastTbl.inuseList.mCastTbl[entry]);
+		while (mCast_t) {
+			/*save the next entry first*/
+			nextMCast_t=TAILQ_NEXT(mCast_t, nextMCast);
+			
+			if (mCast_t->inAsic == TRUE)
+			{
+				/* Entry is in the ASIC */
+				if (mCast_t->age <= secPassed) 
+				{
+					if(mCast_t->mbr==0)
+					{
+						_rtl865x_freeMCastEntry(mCast_t, entry);
+						needReArrange=TRUE;
+					}
+					else
+					{
+						mCast_t->age = RTL865X_MULTICAST_TABLE_AGE;
+					}
+				}
+				else
+				{
+					mCast_t->age -= secPassed;
+				}
+			}
+			else 
+			{
+				/* Entry is not in the ASIC */
+				if(mCast_t->maxPPS<mCast_t->count)
+				{
+					mCast_t->maxPPS=mCast_t->count ;
+				}
+				
+				if(mCast_t->maxPPS>0)
+				{
+					mCast_t->maxPPS--;
+				}
+				
+				if (mCast_t->age <= secPassed)
+				{ /* aging out */
+					_rtl865x_freeMCastEntry(mCast_t, entry);
+				}
+				else 
+				{
+					mCast_t->age -= secPassed;
+				}
+			}
+			
+			mCast_t->count = 0;
+			mCast_t = nextMCast_t;
+		}
+
+		if(needReArrange==TRUE)
+		{
+			_rtl865x_arrangeMulticast(entry);
+		}
+	
+	}
+}
+
+#if defined(__linux__) && defined(__KERNEL__)
+static void _rtl865x_mCastSysTimerExpired(uint32 expireDada)
 {
-
-	_rtl865x_timeUpdateMulticast(1);
-	mod_timer(&rtl865x_mCastSysTimer, jiffies+HZ);
+
+	_rtl865x_timeUpdateMulticast(1);
+	mod_timer(&rtl865x_mCastSysTimer, jiffies+HZ);
 	
 }
 
-static void _rtl865x_initMCastSysTimer(void)
+static void _rtl865x_initMCastSysTimer(void)
 {
-
-	init_timer(&rtl865x_mCastSysTimer);
-	rtl865x_mCastSysTimer.data=rtl865x_mCastSysTimer.expires;
-	rtl865x_mCastSysTimer.expires=jiffies+HZ;
-	rtl865x_mCastSysTimer.function=(void*)_rtl865x_mCastSysTimerExpired;
-	add_timer(&rtl865x_mCastSysTimer);
+
+	init_timer(&rtl865x_mCastSysTimer);
+	rtl865x_mCastSysTimer.data=rtl865x_mCastSysTimer.expires;
+	rtl865x_mCastSysTimer.expires=jiffies+HZ;
+	rtl865x_mCastSysTimer.function=(void*)_rtl865x_mCastSysTimerExpired;
+	add_timer(&rtl865x_mCastSysTimer);
 }
 
-static void _rtl865x_destroyMCastSysTimer(void)
+static void _rtl865x_destroyMCastSysTimer(void)
 {
-	del_timer(&rtl865x_mCastSysTimer);
+	del_timer(&rtl865x_mCastSysTimer);
 }
 
 #endif
-
+
 /*
-@func int32	| rtl865x_initMulticast	|  Init hardware ip multicast module.
-@parm  rtl865x_mCastConfig_t *	| mCastConfigPtr	| Pointer of hardware multicast configuration. 
-@rvalue SUCCESS	|Initialize successfully.
-@rvalue FAILED	|Initialize failed.
-*/
-int32 rtl865x_initMulticast(rtl865x_mCastConfig_t * mCastConfigPtr)
-{
-	_rtl865x_multicastUnRegisterEvent();
-	_rtl865x_initMCastEntryPool();
-	_rtl865x_initMCastFwdDescPool();
-	rtl865x_setMulticastExternalPortMask(0);
-	if(mCastConfigPtr!=NULL)
-	{
-		rtl865x_setMulticastExternalPortMask(mCastConfigPtr->externalPortMask);
-	}
-	#if defined(__linux__) && defined(__KERNEL__)
-	_rtl865x_initMCastSysTimer();
-	#endif
-	rtl8651_setAsicMulticastMTU(1522); 
-	rtl8651_setAsicMulticastEnable(TRUE);
-	rtl865x_setAsicMulticastAging(TRUE);
-	_rtl865x_multicastRegisterEvent();
-	return SUCCESS;
-}
-
+@func int32	| rtl865x_initMulticast	|  Init hardware ip multicast module.
+@parm  rtl865x_mCastConfig_t *	| mCastConfigPtr	| Pointer of hardware multicast configuration. 
+@rvalue SUCCESS	|Initialize successfully.
+@rvalue FAILED	|Initialize failed.
+*/
+int32 rtl865x_initMulticast(rtl865x_mCastConfig_t * mCastConfigPtr)
+{
+	_rtl865x_multicastUnRegisterEvent();
+	_rtl865x_initMCastEntryPool();
+	_rtl865x_initMCastFwdDescPool();
+	rtl865x_setMulticastExternalPortMask(0);
+	if(mCastConfigPtr!=NULL)
+	{
+		rtl865x_setMulticastExternalPortMask(mCastConfigPtr->externalPortMask);
+	}
+	#if defined(__linux__) && defined(__KERNEL__)
+	_rtl865x_initMCastSysTimer();
+	#endif
+	rtl8651_setAsicMulticastMTU(1522); 
+	rtl8651_setAsicMulticastEnable(TRUE);
+	rtl865x_setAsicMulticastAging(TRUE);
+	_rtl865x_multicastRegisterEvent();
+	return SUCCESS;
+}
+
 /*
-@func int32	| rtl865x_reinitMulticast	|  Re-init hardware ip multicast module.
-@rvalue SUCCESS	|Re-initialize successfully.
-@rvalue FAILED	|Re-initialize failed.
-*/
-int32 rtl865x_reinitMulticast(void)
-{
-	_rtl865x_multicastUnRegisterEvent();
-	/*delete all multicast entry*/
-	rtl8651_setAsicMulticastEnable(FALSE);
-	rtl865x_delMulticastEntry(0);
-	
-	#if defined(__linux__) && defined(__KERNEL__)
-	_rtl865x_destroyMCastSysTimer();
-	_rtl865x_initMCastSysTimer();
-	#endif
-	
-	/*regfster twice won't cause any side-effect, 
-	because event management module will handle duplicate event issue*/
-	rtl8651_setAsicMulticastMTU(1522); 
-	rtl8651_setAsicMulticastEnable(TRUE);
-	rtl865x_setAsicMulticastAging(TRUE);
-	_rtl865x_multicastRegisterEvent();
-	return SUCCESS;
-}	
-
-
-
-#ifdef CONFIG_PROC_FS
-extern int32 rtl8651_getAsicMulticastSpanningTreePortState(uint32 port, uint32 *portState);
-int32 rtl_dumpSwMulticastInfo(void)
-{
-	uint32 mCastMtu=0;
-	uint32 mCastEnable=FALSE;
-	uint32 index;
-	int8 isInternal;
-	uint32 portStatus;
-	uint32 internalPortMask=0;
-	uint32 externalPortMask=0;
-	int32 ret=FAILED;
-	
-	rtl865x_tblDrv_mCast_t *mCast_t, *nextMCast_t;
-	rtl865x_mcast_fwd_descriptor_t *curDesc,*nextDesc;
-	uint32 entry;
-	uint32 cnt;
-	printk("----------------------------------------------------\n");
-	printk("Asic Operation Layer :%d\n", rtl8651_getAsicOperationLayer());
-	
-	ret=rtl8651_getAsicMulticastEnable(&mCastEnable);
-	if(ret==SUCCESS)
-	{
-		printk("Asic Multicast Table:%s\n", (mCastEnable==TRUE)?"Enable":"Disable");
-	}
-	else
-	{
-		printk("Read Asic Multicast Table Enable Bit Error\n");
-	}
-	
-	ret=rtl8651_getAsicMulticastMTU(&mCastMtu); 
-	if(ret==SUCCESS)
-	{
-		printk("Asic Multicast MTU:%d\n", mCastMtu);
-	}
-	else
-	{
-		printk("Read Asic Multicast MTU Error\n");
-	}
-	
-	for (index=0; index<RTL8651_PORT_NUMBER+rtl8651_totalExtPortNum; index++)
-	{
-		ret=rtl8651_getAsicMulticastPortInternal(index, &isInternal);
-		if(ret==SUCCESS)
-		{
-			if(isInternal==TRUE)
-			{
-				internalPortMask |= 1<<index;
-			}
-			else
-			{
-				externalPortMask |= 1<<index;
-			}
-		}
-	
-	}
-
-	printk("Internal Port Mask:0x%x\nExternal Port Mask:0x%x\n", internalPortMask,externalPortMask);
-	printk("----------------------------------------------------\n");
-	printk("Multicast STP State:\n");
-	for (index=0; index<RTL8651_PORT_NUMBER+rtl8651_totalExtPortNum; index++)
-	{
-		ret= rtl8651_getAsicMulticastSpanningTreePortState(index, &portStatus);
-		if(ret==SUCCESS)
-		{
-			printk("port[%d]:",index);
-			if(portStatus==RTL8651_PORTSTA_DISABLED)
-			{
-				printk("disabled\n");
-			}
-			else if(portStatus==RTL8651_PORTSTA_BLOCKING)
-			{
-				printk("blocking\n");
-			}
-			else if(portStatus==RTL8651_PORTSTA_LEARNING)
-			{
-				printk("learning\n");
-			}
-			else if(portStatus==RTL8651_PORTSTA_FORWARDING)
-			{
-				printk("forwarding\n");
-			}
-		}
-		
-	}
-	printk("----------------------------------------------------\n");
-	printk("Software Multicast Table:\n");
-	/* check to Aging and HW swapping */
-	for (entry=0; entry< RTL8651_MULTICASTTBL_SIZE; entry++) {
-		mCast_t = TAILQ_FIRST(&mCastTbl.inuseList.mCastTbl[entry]);
-		while (mCast_t) {
-			/*save the next entry first*/
-			nextMCast_t=TAILQ_NEXT(mCast_t, nextMCast);
-			printk("\t[%2d]  dip:%d.%d.%d.%d, sip:%d.%d.%d.%d, mbr:0x%x, svid:%d, spa:%d, \n", entry,
-				mCast_t->dip>>24, (mCast_t->dip&0x00ff0000)>>16, (mCast_t->dip&0x0000ff00)>>8, (mCast_t->dip&0xff), 
-				mCast_t->sip>>24, (mCast_t->sip&0x00ff0000)>>16, (mCast_t->sip&0x0000ff00)>>8, (mCast_t->sip&0xff),
-				mCast_t->mbr,mCast_t->svid, mCast_t->port);
-			printk("\t      extIP:0x%x,age:%d, cpu:%d, maxPPS:%d, inAsic:%d, (%s)\n", 
-				mCast_t->extIp,mCast_t->age, mCast_t->cpu,mCast_t->maxPPS,mCast_t->inAsic,mCast_t->unKnownMCast?"UnknownMCast":"KnownMCast");
-			
-			cnt=0;
-			curDesc=MC_LIST_FIRST(&mCast_t->fwdDescChain);
-			while(curDesc)
-			{
-				nextDesc=MC_LIST_NEXT(curDesc, next );
-				printk("\t      netif(%s),descPortMask(0x%x),toCpu(%d),fwdPortMask(0x%x)\n",curDesc->netifName,curDesc->descPortMask,curDesc->toCpu,curDesc->fwdPortMask);
-				curDesc = nextDesc;
-			}
-			
-			printk("\n");
-			mCast_t = nextMCast_t;
-		}
-		
-	}
-
-	return SUCCESS;
-}
+@func int32	| rtl865x_reinitMulticast	|  Re-init hardware ip multicast module.
+@rvalue SUCCESS	|Re-initialize successfully.
+@rvalue FAILED	|Re-initialize failed.
+*/
+int32 rtl865x_reinitMulticast(void)
+{
+	_rtl865x_multicastUnRegisterEvent();
+	/*delete all multicast entry*/
+	rtl8651_setAsicMulticastEnable(FALSE);
+	rtl865x_delMulticastEntry(0);
+	
+	#if defined(__linux__) && defined(__KERNEL__)
+	_rtl865x_destroyMCastSysTimer();
+	_rtl865x_initMCastSysTimer();
+	#endif
+	
+	/*regfster twice won't cause any side-effect, 
+	because event management module will handle duplicate event issue*/
+	rtl8651_setAsicMulticastMTU(1522); 
+	rtl8651_setAsicMulticastEnable(TRUE);
+	rtl865x_setAsicMulticastAging(TRUE);
+	_rtl865x_multicastRegisterEvent();
+	return SUCCESS;
+}	
+
+
+
+#ifdef CONFIG_PROC_FS
+extern int32 rtl8651_getAsicMulticastSpanningTreePortState(uint32 port, uint32 *portState);
+int32 rtl_dumpSwMulticastInfo(void)
+{
+	uint32 mCastMtu=0;
+	uint32 mCastEnable=FALSE;
+	uint32 index;
+	int8 isInternal;
+	uint32 portStatus;
+	uint32 internalPortMask=0;
+	uint32 externalPortMask=0;
+	int32 ret=FAILED;
+	
+	rtl865x_tblDrv_mCast_t *mCast_t, *nextMCast_t;
+	rtl865x_mcast_fwd_descriptor_t *curDesc,*nextDesc;
+	uint32 entry;
+	uint32 cnt;
+	printk("----------------------------------------------------\n");
+	printk("Asic Operation Layer :%d\n", rtl8651_getAsicOperationLayer());
+	
+	ret=rtl8651_getAsicMulticastEnable(&mCastEnable);
+	if(ret==SUCCESS)
+	{
+		printk("Asic Multicast Table:%s\n", (mCastEnable==TRUE)?"Enable":"Disable");
+	}
+	else
+	{
+		printk("Read Asic Multicast Table Enable Bit Error\n");
+	}
+	
+	ret=rtl8651_getAsicMulticastMTU(&mCastMtu); 
+	if(ret==SUCCESS)
+	{
+		printk("Asic Multicast MTU:%d\n", mCastMtu);
+	}
+	else
+	{
+		printk("Read Asic Multicast MTU Error\n");
+	}
+	
+	for (index=0; index<RTL8651_PORT_NUMBER+rtl8651_totalExtPortNum; index++)
+	{
+		ret=rtl8651_getAsicMulticastPortInternal(index, &isInternal);
+		if(ret==SUCCESS)
+		{
+			if(isInternal==TRUE)
+			{
+				internalPortMask |= 1<<index;
+			}
+			else
+			{
+				externalPortMask |= 1<<index;
+			}
+		}
+	
+	}
+
+	printk("Internal Port Mask:0x%x\nExternal Port Mask:0x%x\n", internalPortMask,externalPortMask);
+	printk("----------------------------------------------------\n");
+	printk("Multicast STP State:\n");
+	for (index=0; index<RTL8651_PORT_NUMBER+rtl8651_totalExtPortNum; index++)
+	{
+		ret= rtl8651_getAsicMulticastSpanningTreePortState(index, &portStatus);
+		if(ret==SUCCESS)
+		{
+			printk("port[%d]:",index);
+			if(portStatus==RTL8651_PORTSTA_DISABLED)
+			{
+				printk("disabled\n");
+			}
+			else if(portStatus==RTL8651_PORTSTA_BLOCKING)
+			{
+				printk("blocking\n");
+			}
+			else if(portStatus==RTL8651_PORTSTA_LEARNING)
+			{
+				printk("learning\n");
+			}
+			else if(portStatus==RTL8651_PORTSTA_FORWARDING)
+			{
+				printk("forwarding\n");
+			}
+		}
+		
+	}
+	printk("----------------------------------------------------\n");
+	printk("Software Multicast Table:\n");
+	/* check to Aging and HW swapping */
+	for (entry=0; entry< RTL8651_MULTICASTTBL_SIZE; entry++) {
+		mCast_t = TAILQ_FIRST(&mCastTbl.inuseList.mCastTbl[entry]);
+		while (mCast_t) {
+			/*save the next entry first*/
+			nextMCast_t=TAILQ_NEXT(mCast_t, nextMCast);
+			printk("\t[%2d]  dip:%d.%d.%d.%d, sip:%d.%d.%d.%d, mbr:0x%x, svid:%d, spa:%d, \n", entry,
+				mCast_t->dip>>24, (mCast_t->dip&0x00ff0000)>>16, (mCast_t->dip&0x0000ff00)>>8, (mCast_t->dip&0xff), 
+				mCast_t->sip>>24, (mCast_t->sip&0x00ff0000)>>16, (mCast_t->sip&0x0000ff00)>>8, (mCast_t->sip&0xff),
+				mCast_t->mbr,mCast_t->svid, mCast_t->port);
+			printk("\t      extIP:0x%x,age:%d, cpu:%d, maxPPS:%d, inAsic:%d, (%s)\n", 
+				mCast_t->extIp,mCast_t->age, mCast_t->cpu,mCast_t->maxPPS,mCast_t->inAsic,mCast_t->unKnownMCast?"UnknownMCast":"KnownMCast");
+			
+			cnt=0;
+			curDesc=MC_LIST_FIRST(&mCast_t->fwdDescChain);
+			while(curDesc)
+			{
+				nextDesc=MC_LIST_NEXT(curDesc, next );
+				printk("\t      netif(%s),descPortMask(0x%x),toCpu(%d),fwdPortMask(0x%x)\n",curDesc->netifName,curDesc->descPortMask,curDesc->toCpu,curDesc->fwdPortMask);
+				curDesc = nextDesc;
+			}
+			
+			printk("\n");
+			mCast_t = nextMCast_t;
+		}
+		
+	}
+
+	return SUCCESS;
+}
 #endif
-
+
 int rtl865x_genVirtualMCastFwdDescriptor(unsigned int forceToCpu, uint32 fwdPortMask, rtl865x_mcast_fwd_descriptor_t *fwdDescriptor)
 {
 	
@@ -1803,22 +1799,22 @@ int rtl865x_genVirtualMCastFwdDescriptor(unsigned int forceToCpu, uint32 fwdPort
 	fwdDescriptor->fwdPortMask=fwdPortMask;
 	return SUCCESS;
 
-}
-
-int rtl865x_blockMulticastFlow(unsigned int srcVlanId, unsigned int srcPort,unsigned int srcIpAddr, unsigned int destIpAddr)
-{
-	rtl865x_mcast_fwd_descriptor_t fwdDescriptor;
-	rtl865x_tblDrv_mCast_t * existMCastEntry=NULL;
-	existMCastEntry=rtl865x_findMCastEntry(destIpAddr, srcIpAddr, (uint16)srcVlanId, (uint16)srcPort);
-	if(existMCastEntry!=NULL)
-	{
-		if(existMCastEntry->mbr==0)
-		{
-			return SUCCESS;
-		}
-	}
-	memset(&fwdDescriptor, 0, sizeof(rtl865x_mcast_fwd_descriptor_t ));
-	rtl865x_addMulticastEntry(destIpAddr, srcIpAddr, (unsigned short)srcVlanId, (unsigned short)srcPort, &fwdDescriptor, TRUE, 0, 0, 0);
-	return SUCCESS;
-}
-
+}
+
+int rtl865x_blockMulticastFlow(unsigned int srcVlanId, unsigned int srcPort,unsigned int srcIpAddr, unsigned int destIpAddr)
+{
+	rtl865x_mcast_fwd_descriptor_t fwdDescriptor;
+	rtl865x_tblDrv_mCast_t * existMCastEntry=NULL;
+	existMCastEntry=rtl865x_findMCastEntry(destIpAddr, srcIpAddr, (uint16)srcVlanId, (uint16)srcPort);
+	if(existMCastEntry!=NULL)
+	{
+		if(existMCastEntry->mbr==0)
+		{
+			return SUCCESS;
+		}
+	}
+	memset(&fwdDescriptor, 0, sizeof(rtl865x_mcast_fwd_descriptor_t ));
+	rtl865x_addMulticastEntry(destIpAddr, srcIpAddr, (unsigned short)srcVlanId, (unsigned short)srcPort, &fwdDescriptor, TRUE, 0, 0, 0);
+	return SUCCESS;
+}
+
diff --git a/drivers/net/rtl819x/l4Driver/Makefile b/drivers/net/rtl819x/l4Driver/Makefile
index 0478306..1f49b93 100644
--- a/drivers/net/rtl819x/l4Driver/Makefile
+++ b/drivers/net/rtl819x/l4Driver/Makefile
@@ -8,7 +8,7 @@
 # Note 2! The CFLAGS definitions are now in the main makefile...
 #Add mips16 Support
 
-DIR_RTLASIC = $(TOPDIR)/drivers/net/rtl819x/
+DIR_RTLASIC = $(DIR_LINUX)/drivers/net/rtl819x/
 ifdef CONFIG_RTL865X_KERNEL_MIPS16_LAYERDRIVER
 	CFLAGS_rtl865x_nat.o	= -mips16
 endif
diff --git a/drivers/net/rtl819x/l4Driver/rtl865x_nat.c b/drivers/net/rtl819x/l4Driver/rtl865x_nat.c
index 9ca1c26..06025a2 100644
--- a/drivers/net/rtl819x/l4Driver/rtl865x_nat.c
+++ b/drivers/net/rtl819x/l4Driver/rtl865x_nat.c
@@ -1,25 +1,13 @@
 /*
-* Copyright c                  Realtek Semiconductor Corporation, 2008  
-* All rights reserved.
-* 
 * Program : napt table driver
 * Abstract : 
 * Author : hyking (hyking_liu@realsil.com.cn)  
-*/
-
-/*      @doc RTL_LAYEREDDRV_API
-
-        @module rtl865x_nat.c - RTL865x Home gateway controller Layered driver API documentation       |
-        This document explains the API interface of the table driver module. Functions with rtl865x prefix
-        are external functions.
-        @normal Hyking Liu (Hyking_liu@realsil.com.cn) <date>
-
-        Copyright <cp>2008 Realtek<tm> Semiconductor Cooperation, All Rights Reserved.
-
-        @head3 List of Symbols |
-        Here is a list of all functions and variables in this module.
-        
-        @index | RTL_LAYEREDDRV_API
+*
+*  Copyright (c) 2011 Realtek Semiconductor Corp.
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License version 2 as
+*  published by the Free Software Foundation.
 */
 
 #include <net/rtl/rtl_types.h>
@@ -67,7 +55,7 @@
 
 static struct nat_table nat_tbl;
 static int32 rtl865x_enableNaptFourWay=FALSE;
-//static int32 _rtl865x_naptIdleCheck(int32 index);
+static int32 _rtl865x_naptIdleCheck(int32 index);
 #if 0
 static int32 rtl865x_nat_callbackFn_for_del_ip(void *param);
 
@@ -655,7 +643,7 @@ static int32 _rtl865x_addNaptConnection(rtl865x_napt_entry *naptEntry, rtl865x_p
 	#endif
 	int32		priority[2];
 #endif
-	//int32		elasped, del_conn_flags;
+	int32		elasped, del_conn_flags;
 	
 	uint32 outCollision=FALSE;
 	uint32 inCollision=FALSE;
@@ -738,7 +726,7 @@ static int32 _rtl865x_addNaptConnection(rtl865x_napt_entry *naptEntry, rtl865x_p
 	
 	nat_out = &nat_tbl.nat_bucket[out];
 	nat_in = &nat_tbl.nat_bucket[in];
-	#if 0
+
 	del_conn_flags = 0;
 	if (NAT_INUSE(nat_out))
 	{
@@ -767,7 +755,7 @@ static int32 _rtl865x_addNaptConnection(rtl865x_napt_entry *naptEntry, rtl865x_p
 	if (del_conn_flags==2) {
 		nat_tbl.connNum--;
 	}
-	#endif
+
 	if ( NAT_INUSE(nat_out) && NAT_INUSE(nat_in))
 	{
 		/*both outbound and inbound has been occupied*/
@@ -1187,7 +1175,7 @@ static int32 _rtl865x_delNaptConnection(rtl865x_napt_entry *naptEntry)
 	
 	return SUCCESS;
 }
-#if 0
+
 static int32 _rtl865x_naptIdleCheck(int32 index)
 {
 	rtl865x_tblAsicDrv_naptTcpUdpParam_t	entry;
@@ -1203,7 +1191,7 @@ static int32 _rtl865x_naptIdleCheck(int32 index)
 		return (nat_tbl.udp_timeout>hw_now?nat_tbl.udp_timeout-hw_now:0);
 	}
 }
-#endif
+
 static int32 _rtl865x_naptSync(rtl865x_napt_entry *naptEntry, uint32 refresh)
 {
 	rtl865x_tblAsicDrv_naptTcpUdpParam_t asic_nat_out;
@@ -1211,6 +1199,7 @@ static int32 _rtl865x_naptSync(rtl865x_napt_entry *naptEntry, uint32 refresh)
 	struct nat_entry *nat_out,*nat_in;
 	struct nat_tuple nat_tuple;
 	int32 rc;
+	int32 hw_now;
 
 	memset(&nat_tuple, 0, sizeof(struct nat_tuple));
 	nat_tuple.int_host.ip			= naptEntry->intIp;
@@ -1226,8 +1215,7 @@ static int32 _rtl865x_naptSync(rtl865x_napt_entry *naptEntry, uint32 refresh)
 
 	if( (!nat_out) && (!nat_in))
 	{
-		return 0;
-
+		return -1;
 	}
 
 	memset(&asic_nat_out ,0 ,sizeof(rtl865x_tblAsicDrv_naptTcpUdpParam_t));
@@ -1240,29 +1228,37 @@ static int32 _rtl865x_naptSync(rtl865x_napt_entry *naptEntry, uint32 refresh)
 		
 		rc = rtl8651_getAsicNaptTcpUdpTable(nat_in->in, &asic_nat_in);
 		assert(rc==SUCCESS);
-		return (asic_nat_out.ageSec>asic_nat_in.ageSec)? asic_nat_out.ageSec: asic_nat_in.ageSec;
+		hw_now = (asic_nat_out.ageSec>asic_nat_in.ageSec)? asic_nat_out.ageSec: asic_nat_in.ageSec;
 	}
 	else if((nat_out!=NULL) && (nat_in==NULL))
 	{
 		rc = rtl8651_getAsicNaptTcpUdpTable(nat_out->out, &asic_nat_out);
 		assert(rc==SUCCESS);
-		return asic_nat_out.ageSec;
+		hw_now = asic_nat_out.ageSec;
 	}
 	else if((nat_out==NULL) && (nat_in!=NULL))
 	{
 		rc = rtl8651_getAsicNaptTcpUdpTable(nat_in->in, &asic_nat_in);
 		assert(rc==SUCCESS);
-		return asic_nat_in.ageSec;
+		hw_now = asic_nat_in.ageSec;
 		
 	}
 	else
 	{
-		return 0;
+		hw_now = 0;
 	}
 
-	return 0;
-	
-	
+	if (hw_now==0) {
+		return -1;
+	} else {
+		if (naptEntry->protocol==RTL865X_PROTOCOL_UDP) {
+			return (nat_tbl.udp_timeout>hw_now?nat_tbl.udp_timeout-hw_now:0);
+		} else if (naptEntry->protocol==RTL865X_PROTOCOL_TCP) {
+			return (nat_tbl.tcp_timeout>hw_now?nat_tbl.tcp_timeout-hw_now:0);
+		}
+	}
+
+	return -1;	
 }
 
 
diff --git a/drivers/net/rtl819x/romeperf.c b/drivers/net/rtl819x/romeperf.c
index f8353c6..0c7ae8d 100644
--- a/drivers/net/rtl819x/romeperf.c
+++ b/drivers/net/rtl819x/romeperf.c
@@ -1,16 +1,16 @@
 /*
-* Copyright c                  Realtek Semiconductor Corporation, 2002  
+* Copyright c                  Realtek Semiconductor Corporation, 2002
 * All rights reserved.
-* 
+*
 * Program : Performance Profiling for ROME Driver
-* Abstract : 
-* Author : Yung-Chieh Lo (yjlou@realtek.com.tw)               
+* Abstract :
+* Author : Yung-Chieh Lo (yjlou@realtek.com.tw)
 * $Id: romeperf.c,v 1.1 2007-12-21 10:28:22 davidhsu Exp $
 */
 
 #include "romeperf.h"
 #include <net/rtl/rtl_glue.h>
-#define KERNEL_SYSeALLS 
+#define KERNEL_SYSeALLS
 #include <asm/unistd.h>
 #include <asm/processor.h>
 #include <asm/uaccess.h>
@@ -47,12 +47,12 @@ static uint32 tempVariable32;
 static uint64 currCnt[4];
 
 /* Global variables */
-uint64 cnt1, cnt2;
+//uint64 cnt1, cnt2;
 rtl8651_romeperf_stat_t romePerfStat[ROMEPERF_INDEX_MAX];
 uint32 rtl8651_romeperf_inited = 0;
 uint32 rtl8651_romeperf_enable = TRUE;
 
-__IRAM void CP3_COUNTER0_INIT( void )
+__IRAM static void CP3_COUNTER0_INIT( void )
 {
 __asm__ __volatile__ \
 ("  ;\
@@ -63,7 +63,8 @@ __asm__ __volatile__ \
 ");
 }
 
-__IRAM uint32 CP3_COUNTER0_IS_INITED( void )
+#if 0
+__IRAM static uint32 CP3_COUNTER0_IS_INITED( void )
 {
 __asm__ __volatile__ \
 ("  ;\
@@ -73,8 +74,8 @@ __asm__ __volatile__ \
 ");
 	return tempVariable32;
 }
-
-__IRAM void CP3_COUNTER0_START( void )
+#endif
+__IRAM static void CP3_COUNTER0_START( void )
 {
 #if 1 /* Inst */
 	tempVariable32 = /* Counter0 */((0x10|CP3CNT_CYCLES)<< 0) |
@@ -103,7 +104,7 @@ __asm__ __volatile__ \
 ");
 }
 
-__IRAM void CP3_COUNTER0_STOP( void )
+__IRAM static void CP3_COUNTER0_STOP( void )
 {
 __asm__ __volatile__ \
 ("	;\
@@ -111,7 +112,7 @@ __asm__ __volatile__ \
 ");
 }
 
-__IRAM uint64 CP3_COUNTER0_GET( void )
+__IRAM static uint64 CP3_COUNTER0_GET( void )
 {
 __asm__ __volatile__ \
 ("	;\
@@ -124,7 +125,7 @@ __asm__ __volatile__ \
 	return tempVariable64;
 }
 
-__IRAM void CP3_COUNTER0_GET_ALL( void )
+__IRAM static void CP3_COUNTER0_GET_ALL( void )
 {
 __asm__ __volatile__ \
 ("	;\
@@ -231,7 +232,7 @@ int32 rtl8651_romeperfInit()
 	 romePerfStat[ROMEPERF_INDEX_PCIE_IRQ].desc = "PCIE_IRQ";
 	romePerfStat[ROMEPERF_INDEX_RX_DSR].desc = "RX DSR";
 	romePerfStat[ROMEPERF_INDEX_RX_ISR].desc = "RX ISR";
-	romePerfStat[ROMEPERF_INDEX_validate_mpdu].desc = "validate mpdu";  
+	romePerfStat[ROMEPERF_INDEX_validate_mpdu].desc = "validate mpdu";
 	romePerfStat[ROMEPERF_INDEX_swNic_receive].desc = "swNic_receive";
 	romePerfStat[ROMEPERF_INDEX_rtl_processReceivedInfo].desc = "rtl_processReceivedInfo";
 	romePerfStat[ROMEPERF_INDEX_rtl_decideRxDevice].desc = "rtl_decideRxDevice";
@@ -252,15 +253,15 @@ int32 rtl8651_romeperfInit()
 	romePerfStat[ROMEPERF_INDEX_fastpath_1].desc = "fastpath_1";
 	romePerfStat[ROMEPERF_INDEX_fastpath_2].desc = "fastpath_2";
 	romePerfStat[ROMEPERF_INDEX_fastpath_3].desc = "fastpath_3";
- 
- 
+
+
         return SUCCESS;
 }
 
 int32 rtl8651_romeperfReset()
 {
 	rtl8651_romeperfInit();
-	
+
 	return SUCCESS;
 }
 
@@ -268,7 +269,7 @@ int32 rtl8651_romeperfReset()
 int32 rtl8651_romeperfStart()
 {
 	if ( rtl8651_romeperf_inited == FALSE ) rtl8651_romeperfInit();
-	
+
 	START_AND_GET_CP3_COUNTER0( cnt1 );
 
 	return SUCCESS;
@@ -277,7 +278,7 @@ int32 rtl8651_romeperfStart()
 int32 rtl8651_romeperfStop( uint64 *pDiff )
 {
 	if ( rtl8651_romeperf_inited == FALSE ) rtl8651_romeperfInit();
-	
+
 	STOP_AND_GET_CP3_COUNTER0( cnt2 );
 
 	*pDiff = cnt2 - cnt1;
@@ -295,7 +296,7 @@ int32 rtl8651_romeperfGet( uint64 *pGet )
 	CP3_COUNTER0_STOP();
 	*pGet = CP3_COUNTER0_GET();
 	CP3_COUNTER0_START();
-	
+
 	return SUCCESS;
 }
 
@@ -304,12 +305,12 @@ int32 rtl8651_romeperfPause( void )
 	if ( rtl8651_romeperf_inited == FALSE ) return FAILED;
 
 	rtl8651_romeperf_enable = FALSE;
-	
+
 	/* Louis patch: someone will disable CP3 in somewhere. */
 	CP3_COUNTER0_INIT();
 
 	CP3_COUNTER0_STOP();
-	
+
 	return SUCCESS;
 }
 
@@ -318,12 +319,12 @@ int32 rtl8651_romeperfResume( void )
 	if ( rtl8651_romeperf_inited == FALSE ) return FAILED;
 
 	rtl8651_romeperf_enable = TRUE;
-	
+
 	/* Louis patch: someone will disable CP3 in somewhere. */
 	CP3_COUNTER0_INIT();
- 	
+
 	CP3_COUNTER0_START();
-	
+
 	return SUCCESS;
 }
 
@@ -345,7 +346,7 @@ __IRAM int rtl8651_romeperfEnterPoint( int index )
 	romePerfStat[index].tempCycle[3] = currCnt[3];
 	romePerfStat[index].hasTempCycle = TRUE;
 	CP3_COUNTER0_START();
-	
+
 	return SUCCESS;
 }
 
@@ -360,7 +361,7 @@ __IRAM int rtl8651_romeperfExitPoint(int index )
 
 	/* Louis patch: someone will disable CP3 in somewhere. */
 	CP3_COUNTER0_INIT();
-	
+
 	CP3_COUNTER0_STOP();
 	CP3_COUNTER0_GET_ALL();
 	romePerfStat[index].accCycle[0] += currCnt[0]-romePerfStat[index].tempCycle[0];
@@ -370,7 +371,7 @@ __IRAM int rtl8651_romeperfExitPoint(int index )
 	romePerfStat[index].hasTempCycle = FALSE;
 	romePerfStat[index].executedNum++;
 	CP3_COUNTER0_START();
-	
+
 	return SUCCESS;
 }
 
@@ -389,7 +390,7 @@ int32 rtl8651_romeperfDump( int start, int end )
 		else
 		{
 			int j;
-			rtlglue_printf( "[%3d] %30s ", 
+			rtlglue_printf( "[%3d] %30s ",
 			                i, romePerfStat[i].desc );
 			for( j =0; j < sizeof(romePerfStat[i].accCycle)/sizeof(romePerfStat[i].accCycle[0]);
 			     j++ )
@@ -400,7 +401,7 @@ int32 rtl8651_romeperfDump( int start, int end )
 
 				rtlglue_printf( "%12llu %8u %10u\n",
 				                romePerfStat[i].accCycle[j],
-				                romePerfStat[i].executedNum, 
+				                romePerfStat[i].executedNum,
 				                avrgCycle
 				                );
 				rtlglue_printf( " %3s  %30s ", "", "" );
@@ -408,7 +409,7 @@ int32 rtl8651_romeperfDump( int start, int end )
 			rtlglue_printf( "\r" );
 		}
 	}
-	
+
 	return SUCCESS;
 #else
 	int i;
@@ -450,8 +451,8 @@ int32 rtl8651_romeperfDump( int start, int end )
 				uint32 avrgCycle = /* Hi-word */ (pAccCycle[0]*(0xffffffff/statSnapShot[i].executedNum)) +
 				                   /* Low-word */(pAccCycle[1]/statSnapShot[i].executedNum);
 				rtlglue_printf( "%12llu %8u %10u\n",
-				statSnapShot[i].accCycle[j], 
-				statSnapShot[i].executedNum, 
+				statSnapShot[i].accCycle[j],
+				statSnapShot[i].executedNum,
 				avrgCycle );
 				rtlglue_printf( " %3s  %30s ", "", "" );
 			}
@@ -460,7 +461,7 @@ int32 rtl8651_romeperfDump( int start, int end )
 	}
 
 	rtlglue_free(statSnapShot);
-	
+
 	return SUCCESS;
 #endif
 }
@@ -479,11 +480,31 @@ int rtl865x_perf_proc_read( char *page, char **start, off_t off, int count, int
 int rtl865x_perf_proc_write(struct file *file, const char *buffer,
               unsigned long count, void *data)
 {
+	char  tmpbuf[32];
+	int start, end, num;
 	unsigned long x;
 	spin_lock_irq(x);
+	if (buffer && !copy_from_user(tmpbuf, buffer, count))
+	{
+		tmpbuf[count] = '\0';
+		if(!memcmp(tmpbuf, "flush", 5)){
+			rtl8651_romeperfReset();
+		}else{
+			num = sscanf(tmpbuf, "%d %d", &start, &end);
+			if (num !=  2) {
+				printk("invalid romeperf parameter!\n");
+				goto OUT;
+			}
 
-	rtl8651_romeperfReset();
+			if((start<0) ||(start>99)||(end<0) ||(end>99) ||(start>end)){
+				printk("Bad index!\n");
+				goto OUT;
+			}
 
-	spin_unlock_irq(x);
+			rtl8651_romeperfDump(start, end);
+		}
+	}
+OUT:
+    spin_unlock_irq(x);
     return count;
 }
diff --git a/drivers/net/rtl819x/rtl865x_proc_debug.c b/drivers/net/rtl819x/rtl865x_proc_debug.c
index 15d2531..3c5cf65 100644
--- a/drivers/net/rtl819x/rtl865x_proc_debug.c
+++ b/drivers/net/rtl819x/rtl865x_proc_debug.c
@@ -1,10 +1,10 @@
 /*
-* Copyright c                  Realtek Semiconductor Corporation, 2008  
-* All rights reserved.                                                    
-* 
+* Copyright c                  Realtek Semiconductor Corporation, 2008
+* All rights reserved.
+*
 * Program : just for driver debug
-* Abstract :                                                           
-* Author : Hyking Liu (Hyking_liu@realsil.com.tw)               
+* Abstract :
+* Author : Hyking Liu (Hyking_liu@realsil.com.tw)
 * -------------------------------------------------------
 */
 #include <net/rtl/rtl_types.h>
@@ -31,7 +31,7 @@
 
 #include "AsicDriver/rtl865x_asicBasic.h"
 #include "AsicDriver/rtl865x_asicCom.h"
-#include "AsicDriver/rtl865x_asicL2.h"	
+#include "AsicDriver/rtl865x_asicL2.h"
 #ifdef CONFIG_RTL_LAYERED_ASIC_DRIVER_L3
 #include "AsicDriver/rtl865x_asicL3.h"
 #endif
@@ -57,7 +57,14 @@
 #include <net/rtl/rtl_nic.h>
 #endif
 
+#if defined(CONFIG_RTL_PROC_DEBUG)
+extern unsigned int rx_noBuffer_cnt;
+extern unsigned int tx_ringFull_cnt;
+#endif
+
+
 static struct proc_dir_entry *rtl865x_proc_dir;
+#ifdef CONFIG_RTL_PROC_DEBUG	//proc debug flag
 static struct proc_dir_entry *vlan_entry,*netif_entry,*l2_entry, *arp_entry,
 		*nexthop_entry,*l3_entry,*ip_entry,*pppoe_entry,*napt_entry,
 		*acl_entry,*storm_control,
@@ -65,32 +72,118 @@ static struct proc_dir_entry *vlan_entry,*netif_entry,*l2_entry, *arp_entry,
 		*advRt_entry,
 #endif
 #if defined(RTL_DEBUG_NIC_SKB_BUFFER)
-		*nic_skb_buff, 
+		*nic_skb_buff,
 #endif
 #ifdef CONFIG_RTL_LAYERED_DRIVER
-		*acl_chains_entry, 
+		*acl_chains_entry,
 #endif
 #if defined(CONFIG_RTL_HW_QOS_SUPPORT)
-		*qos_rule_entry, 
+		*qos_rule_entry,
 #endif
-		*rxRing_entry, *txRing_entry, *mbuf_entry, 
-		*hs_entry, *pvid_entry, *mirrorPort_entry, 
-		*mem_entry, *diagnostic_entry, 
+		*rxRing_entry, *txRing_entry, *mbuf_entry,
+		*hs_entry, *pvid_entry, *mirrorPort_entry,
+		
 #if defined(CONFIG_RTL_LAYERED_DRIVER_L4) && defined(CONFIG_RTL_8198)
-		*sw_napt_entry, 
+		*sw_napt_entry,
 #endif
-		*port_bandwidth_entry, *queue_bandwidth_entry, 
-		*port_status_entry, *priority_decision_entry,*hwMCast_entry,
-#if defined (CONFIG_RTL_HARDWARE_MULTICAST)		
+		*port_bandwidth_entry, *queue_bandwidth_entry,
+		*priority_decision_entry,
+#if defined (CONFIG_RTL_HARDWARE_MULTICAST)
 		*swMCast_entry,
-#endif		
+#endif
 #if defined (CONFIG_RTL_ENABLE_RATELIMIT_TABLE)
 		*rateLimit_entry,
 #endif
-		*asicCnt_entry,*phyReg_entry;
+*hwMCast_entry,*stats_debug_entry;
+#endif
+
+#if defined(CONFIG_RTL_PROC_DEBUG)||defined(CONFIG_RTL_DEBUG_TOOL)
+
+static struct proc_dir_entry *mmd_entry,	*mem_entry, *diagnostic_entry,	
+		*asicCnt_entry,*phyReg_entry,*port_status_entry,*mac_entry,*fc_threshold_entry;
+#define	PROC_READ_RETURN_VALUE		0
+extern int32 mmd_read(uint32 phyId, uint32 devId, uint32 regId, uint32 *rData);
+extern int32 mmd_write(uint32 phyId, uint32 devId, uint32 regId, uint32 wData);
+
+#endif
+
+#if defined CONFIG_RTL_DEBUG_TOOL	//debug tool flag
+#ifndef CONFIG_RTL_PROC_DEBUG
+ //#ifndef RTK_X86_CLE//RTK-CNSD2-NickWu-20061222: for x86 compile
+ /*cfliu: This function is only for debugging. Should not be used in production code...*/
+
+ void memDump (void *start, uint32 size, int8 * strHeader)
+ {
+	 int32 row, column, index, index2, max;
+	 uint32 buffer[5];
+	 uint8 *buf, *line, ascii[17];
+	 int8 empty = ' ';
+ 
+	 if(!start ||(size==0))
+		 return;
+	 line = (uint8*)start;
+ 
+	 /*
+	 16 bytes per line
+	 */
+	 if (strHeader)
+		 rtlglue_printf ("%s", strHeader);
+	 column = size % 16;
+	 row = (size / 16) + 1;
+	 for (index = 0; index < row; index++, line += 16) 
+	 {
+#ifdef RTL865X_TEST
+		 buf = (uint8*)line;
+#else
+		 /* for un-alignment access */
+		 buffer[0] = ntohl( READ_MEM32( (((uint32)line)&~3)+ 0 ) );
+		 buffer[1] = ntohl( READ_MEM32( (((uint32)line)&~3)+ 4 ) );
+		 buffer[2] = ntohl( READ_MEM32( (((uint32)line)&~3)+ 8 ) );
+		 buffer[3] = ntohl( READ_MEM32( (((uint32)line)&~3)+12 ) );
+		 buffer[4] = ntohl( READ_MEM32( (((uint32)line)&~3)+16 ) );
+		 buf = ((uint8*)buffer) + (((uint32)line)&3);
+#endif
+ 
+		 memset (ascii, 0, 17);
+ 
+		 max = (index == row - 1) ? column : 16;
+		 if ( max==0 ) break; /* If we need not dump this line, break it. */
+ 
+		 rtlglue_printf ("\n%08x:  ", (memaddr) line);
+		 
+		 //Hex
+		 for (index2 = 0; index2 < max; index2++)
+		 {
+			 if (index2 == 8)
+			 rtlglue_printf ("  ");
+			 rtlglue_printf ("%02X", (uint8) buf[index2]);
+			 ascii[index2] = ((uint8) buf[index2] < 32) ? empty : buf[index2];
+			 if ((index2+1)%4==0)
+			 	rtlglue_printf ("  ");
+		 }
+ 	
+		 if (max != 16)
+		 {
+			 if (max < 8)
+				 rtlglue_printf ("	");
+			 for (index2 = 16 - max; index2 > 0; index2--)
+				 rtlglue_printf ("	 ");
+		 }
+		
+ 		 //ASCII
+		 rtlglue_printf ("	%s", ascii);
+	 }
+	 rtlglue_printf ("\n");
+	 return;
+ }
+#endif
+#endif
+
+#ifdef CONFIG_RTL_PROC_DEBUG
 
 static uint32 queue_bandwidth_record_portmask = 0;
 
+
 #if defined (CONFIG_RTL_HARDWARE_MULTICAST)
 int32 rtl_dumpSwMulticastInfo(void);
 #endif
@@ -98,20 +191,16 @@ int32 rtl_dumpSwMulticastInfo(void);
 static struct proc_dir_entry *eventMgr_entry;
 #endif
 
-#if defined (CONFIG_RTL_IGMP_SNOOPING) 
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
 static struct proc_dir_entry *igmp_entry;
 #endif
 /*#if defined(CONFIG_RTL_ETH_PRIV_SKB_DEBUG)*/
 static struct proc_dir_entry *prive_skb_debug_entry;
 /*#endif*/
 
-
-#define	PROC_READ_RETURN_VALUE		0
-
 extern int32 rtl865x_sw_napt_proc_read( char *page, char **start, off_t off, int count, int *eof, void *data );
 extern int32  rtl865x_sw_napt_proc_write( struct file *filp, const char *buff,unsigned long len, void *data );
 
-
 #ifdef CONFIG_RTL_LAYERED_DRIVER
 #ifdef CONFIG_RTL_LAYERED_DRIVER_L2
 static struct proc_dir_entry *sw_l2_entry;
@@ -130,14 +219,14 @@ extern int32 rtl865x_perf_proc_write(struct file *file, const char *buffer, unsi
 int vlan_show(void)
 {
 		int i, j;
-		
+
 		for ( i = 0; i < RTL865XC_VLAN_NUMBER; i++ )
 		{
 			rtl865x_tblAsicDrv_vlanParam_t vlan;
 
 			if ( rtl8651_getAsicVlan( i, &vlan ) == FAILED )
 				continue;
-			
+
 			printk("  VID[%d] ", i);
 			printk("\n\tmember ports:");
 
@@ -147,7 +236,7 @@ int vlan_show(void)
 					printk( "%d ", j);
 			}
 
-			printk("\n\tUntag member ports:"); 			
+			printk("\n\tUntag member ports:");
 
 			for( j = 0; j < RTL8651_PORT_NUMBER + rtl8651_totalExtPortNum; j++ )
 			{
@@ -171,15 +260,19 @@ static int32 vlan_single_show(struct seq_file *s, void *v)
 
 	{
 		int i, j;
-		
-		for ( i = 0; i < RTL865XC_VLAN_NUMBER; i++ )
+
+		for ( i = 0; i < RTL865XC_VLANTBL_SIZE; i++ )
 		{
 			rtl865x_tblAsicDrv_vlanParam_t vlan;
 
 			if ( rtl8651_getAsicVlan( i, &vlan ) == FAILED )
 				continue;
-			
+
+#if defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+			seq_printf(s, "  idx [%d]  VID[%d] ", i, vlan.vid);
+#else
 			seq_printf(s, "  VID[%d] ", i);
+#endif
 			seq_printf(s, "\n\tmember ports:");
 
 			for( j = 0; j < RTL8651_PORT_NUMBER + rtl8651_totalExtPortNum; j++ )
@@ -188,7 +281,7 @@ static int32 vlan_single_show(struct seq_file *s, void *v)
 					seq_printf(s,"%d ", j);
 			}
 
-			seq_printf(s,"\n\tUntag member ports:");				
+			seq_printf(s,"\n\tUntag member ports:");
 
 			for( j = 0; j < RTL8651_PORT_NUMBER + rtl8651_totalExtPortNum; j++ )
 			{
@@ -199,7 +292,7 @@ static int32 vlan_single_show(struct seq_file *s, void *v)
 			seq_printf(s,"\n\tFID:\t%d\n",vlan.fid);
 		}
 
-	}	
+	}
 
 	return 0;
 }
@@ -209,36 +302,40 @@ extern int switch_iram(uint32 addr);
 #endif
 static int32 vlan_write( struct file *filp, const char *buff,unsigned long len, void *data )
 {
-	char 		tmpbuf[32];	
+	char 		tmpbuf[256];
+	if(len>32)
+	{
+		goto errout;
+	}
 	if (buff && !copy_from_user(tmpbuf, buff, len))
 	{
-		tmpbuf[len -1] = '\0';		
+		tmpbuf[len -1] = '\0';
 		if(tmpbuf[0] == '1')
 		{
 		#ifdef CONFIG_RTL_LAYERED_DRIVER_ACL
-		        rtl865x_AclRule_t rule;      
-		                        
-		        memset(&rule,0,sizeof(rtl865x_AclRule_t));                      
+		        rtl865x_AclRule_t rule;
+
+		        memset(&rule,0,sizeof(rtl865x_AclRule_t));
 		        rule.actionType_ = RTL865X_ACL_PRIORITY;
 		        rule.ruleType_ = RTL865X_ACL_IP;
 		        rule.dstIpAddrLB_ = 0xc0a801fe;
 			 rule.dstIpAddrUB_ = 0xc0a801fe;
 			 rule.priority_ = 6;
 		        rule.pktOpApp_ = RTL865X_ACL_ALL_LAYER;
-		        
-		        rtl865x_add_acl(&rule, RTL_DRV_LAN_NETIF_NAME, RTL865X_ACL_SYSTEM_USED);			
+
+		        rtl865x_add_acl(&rule, RTL_DRV_LAN_NETIF_NAME, RTL865X_ACL_SYSTEM_USED);
 		#endif
 
 		}
 #if defined(CONFIG_RTL_DYNAMIC_IRAM_MAPPING_FOR_WAPI)
 		else if(tmpbuf[0] =='2')
-		{					
+		{
 			switch_iram(0);
-			
+
 		}
 		else if(tmpbuf[0] == '3')
-		{			
-			switch_iram(1);		
+		{
+			switch_iram(1);
 		}
 #endif
 		else
@@ -253,7 +350,7 @@ static int32 vlan_write( struct file *filp, const char *buff,unsigned long len,
 			{
 				goto errout;
 			}
-			printk("cmd %s\n", cmd_addr);
+			rtlglue_printf("cmd %s\n", cmd_addr);
 			if (!memcmp(cmd_addr, "dump", 4))
 			{
 				tokptr = strsep(&strptr," ");
@@ -263,39 +360,94 @@ static int32 vlan_write( struct file *filp, const char *buff,unsigned long len,
 				}
 
 				vid = simple_strtol(tokptr, NULL, 0);
-				printk("Vlan info:\n");				
+				rtlglue_printf("Vlan info:\n");
 				{
 					rtl865x_tblAsicDrv_vlanParam_t vlan;
 					int j;
 
 					if ( rtl8651_getAsicVlan( vid, &vlan ) == FAILED )
 						return len;
-					
-					printk("  VID[%d] ", vid);
-					printk("\n\tmember ports:");
+
+					rtlglue_printf("  VID[%d] ", vid);
+					rtlglue_printf("\n\tmember ports:");
 
 					for( j = 0; j < RTL8651_PORT_NUMBER + rtl8651_totalExtPortNum; j++ )
 					{
 						if ( vlan.memberPortMask & ( 1 << j ) )
-							printk("%d ", j);
+							rtlglue_printf("%d ", j);
 					}
 
-					printk("\n\tUntag member ports:");				
+					rtlglue_printf("\n\tUntag member ports:");
 
 					for( j = 0; j < RTL8651_PORT_NUMBER + rtl8651_totalExtPortNum; j++ )
 					{
 						if( vlan.untagPortMask & ( 1 << j ) )
-							printk("%d ", j);
+							rtlglue_printf("%d ", j);
 					}
 
-					printk("\n\tFID:\t%d\n",vlan.fid);
+					rtlglue_printf("\n\tFID:\t%d\n",vlan.fid);
+				}
+			}
+			else if (	(!memcmp(cmd_addr, "add", 3)) || 
+				(!memcmp(cmd_addr, "Add", 3)) ||
+				(!memcmp(cmd_addr, "ADD", 3))	)
+			{
+				
+				uint32 vid=0;
+				uint32 portMask=0;
+				uint32 taggedPortMask=0;
+				tokptr = strsep(&strptr," ");
+				if (tokptr==NULL)
+				{
+					goto errout;
+				}
+				
+				vid=simple_strtol(tokptr, NULL, 0);
+
+				tokptr = strsep(&strptr," ");
+				if (tokptr==NULL)
+				{
+					goto errout;
+				}
+
+				portMask=simple_strtol(tokptr, NULL, 0);
+				
+				tokptr = strsep(&strptr," ");
+				if (tokptr==NULL)
+				{
+					goto errout;
+				}
+				
+				taggedPortMask= simple_strtol(tokptr, NULL, 0);
+				
+				rtl865x_addVlan(vid);
+				rtl865x_addVlanPortMember(vid & 4095,portMask & 0x1F);
+				rtl865x_setVlanPortTag(vid,taggedPortMask,1);
+				rtl865x_setVlanFilterDatabase(vid,0);
+
+				
+			}
+			else if (	(!memcmp(cmd_addr, "del", 3)) || 
+				(!memcmp(cmd_addr, "Del", 3)) ||
+				(!memcmp(cmd_addr, "DEL", 3))	)
+			{
+				uint32 vid=0;
+				tokptr = strsep(&strptr," ");
+				if (tokptr==NULL)
+				{
+					goto errout;
 				}
+				
+				vid=simple_strtol(tokptr, NULL, 0);
+				
+				rtl865x_delVlan(vid);
+
 			}
 
 			return len;
 errout:
-			printk("vlan operation only support \"dump\" as the first parameter\n");
-			printk("dump format:	\"dump vid\"\n");
+			rtlglue_printf("vlan operation only support \"dump\" as the first parameter\n");
+			rtlglue_printf("dump format:	\"dump vid\"\n");
 		}
 	}
 	return len;
@@ -315,7 +467,7 @@ static ssize_t vlan_single_write(struct file * file, const char __user * userbuf
 
 struct file_operations vlan_single_seq_file_operations = {
         .open           = vlan_single_open,
-	 .write		=vlan_single_write, 
+	 .write		=vlan_single_write,
         .read           = seq_read,
         .llseek         = seq_lseek,
         .release        = single_release,
@@ -346,7 +498,7 @@ static int32 netif_read( char *page, char **start, off_t off, int count, int *eo
 		if ( intf.valid )
 		{
 			mac = (uint8 *)&intf.macAddr.octet[0];
-			len += sprintf(page+len,"[%d]  VID[%d] %x:%x:%x:%x:%x:%x", 
+			len += sprintf(page+len,"[%d]  VID[%d] %x:%x:%x:%x:%x:%x",
 				i, intf.vid, mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
 			len += sprintf(page+len,"  Routing %s \n",
 				intf.enableRoute==TRUE? "enabled": "disabled" );
@@ -397,7 +549,7 @@ static int32 netif_read( char *page, char **start, off_t off, int count, int *eo
 				if ( vlan.memberPortMask & ( 1 << j ) )
 					len += sprintf(page+len, "%d ", j);
 			}
-			
+
 			len += sprintf(page+len, "\n      Port state(");
 
 			for ( j = 0; j < RTL8651_PORT_NUMBER + rtl8651_totalExtPortNum; j++ )
@@ -435,8 +587,8 @@ static int32 netif_write( struct file *filp, const char *buff,unsigned long len,
 static int32 acl_read( char *page, char **start, off_t off, int count, int *eof, void *data )
 {
 	int len;
-	int8 *actionT[] = { "permit", "redirect to ether", "drop", "to cpu", "legacy drop", 
-					"drop for log", "mirror", "redirect to pppoe", "default redirect", "mirror keep match", 
+	int8 *actionT[] = { "permit", "redirect to ether", "drop", "to cpu", "legacy drop",
+					"drop for log", "mirror", "redirect to pppoe", "default redirect", "mirror keep match",
 					"drop rate exceed pps", "log rate exceed pps", "drop rate exceed bps", "log rate exceed bps","priority "
 					};
 #ifdef CONFIG_RTL_LAYERED_DRIVER
@@ -451,9 +603,9 @@ static int32 acl_read( char *page, char **start, off_t off, int count, int *eof,
 	int8 outRule;
 
 
-	
+
 	len = sprintf(page, "%s\n", "ASIC ACL Table:");
-	for(vid=0; vid<8; vid++ ) 
+	for(vid=0; vid<8; vid++ )
 	{
 		/* Read VLAN Table */
 		if (rtl8651_getAsicNetInterface(vid, &asic_intf) == FAILED)
@@ -476,7 +628,7 @@ static int32 acl_read( char *page, char **start, off_t off, int count, int *eof,
 		{
 			if ( _rtl865x_getAclFromAsic(acl_start, &asic_acl) == FAILED)
 				rtlglue_printf("=============%s(%d): get asic acl rule error!\n",__FUNCTION__, __LINE__);
-		
+
 			switch(asic_acl.ruleType_)
 			{
 			case RTL865X_ACL_MAC:
@@ -488,7 +640,7 @@ static int32 acl_read( char *page, char **start, off_t off, int count, int *eof,
 						asic_acl.dstMacMask_.octet[0], asic_acl.dstMacMask_.octet[1], asic_acl.dstMacMask_.octet[2],
 						asic_acl.dstMacMask_.octet[3], asic_acl.dstMacMask_.octet[4], asic_acl.dstMacMask_.octet[5]
 						);
-				
+
 				len += sprintf(page+len, "\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n",
 						asic_acl.srcMac_.octet[0], asic_acl.srcMac_.octet[1], asic_acl.srcMac_.octet[2],
 						asic_acl.srcMac_.octet[3], asic_acl.srcMac_.octet[4], asic_acl.srcMac_.octet[5],
@@ -512,14 +664,14 @@ static int32 acl_read( char *page, char **start, off_t off, int count, int *eof,
 				len += sprintf(page+len, "\tTos: %x   TosM: %x   ipProto: %x   ipProtoM: %x   ipFlag: %x   ipFlagM: %x\n",
 						asic_acl.tos_, asic_acl.tosMask_, asic_acl.ipProto_, asic_acl.ipProtoMask_, asic_acl.ipFlag_, asic_acl.ipFlagMask_
 					);
-				
+
 				len += sprintf(page+len, "\t<FOP:%x> <FOM:%x> <http:%x> <httpM:%x> <IdentSdip:%x> <IdentSdipM:%x> \n",
 						asic_acl.ipFOP_, asic_acl.ipFOM_, asic_acl.ipHttpFilter_, asic_acl.ipHttpFilterM_, asic_acl.ipIdentSrcDstIp_,
 						asic_acl.ipIdentSrcDstIpM_
 						);
-				len += sprintf(page+len, "\t<DF:%x> <MF:%x>\n", asic_acl.ipDF_, asic_acl.ipMF_); 
+				len += sprintf(page+len, "\t<DF:%x> <MF:%x>\n", asic_acl.ipDF_, asic_acl.ipMF_);
 					break;
-					
+
 			case RTL865X_ACL_IP_RANGE:
 				len += sprintf(page+len, " [%d] rule type: %s   rule action: %s\n", acl_start, "IP Range", actionT[asic_acl.actionType_]);
 				len += sprintf(page+len, "\tdipU: %d.%d.%d.%d dipL: %d.%d.%d.%d\n", (asic_acl.dstIpAddr_>>24),
@@ -539,8 +691,8 @@ static int32 acl_read( char *page, char **start, off_t off, int count, int *eof,
 						asic_acl.ipFOP_, asic_acl.ipFOM_, asic_acl.ipHttpFilter_, asic_acl.ipHttpFilterM_, asic_acl.ipIdentSrcDstIp_,
 						asic_acl.ipIdentSrcDstIpM_
 						);
-					len += sprintf(page+len, "\t<DF:%x> <MF:%x>\n", asic_acl.ipDF_, asic_acl.ipMF_); 
-					break;			
+					len += sprintf(page+len, "\t<DF:%x> <MF:%x>\n", asic_acl.ipDF_, asic_acl.ipMF_);
+					break;
 			case RTL865X_ACL_ICMP:
 				len += sprintf(page+len, " [%d] rule type: %s   rule action: %s\n", acl_start, "ICMP", actionT[asic_acl.actionType_]);
 				len += sprintf(page+len, "\tdip: %d.%d.%d.%d dipM: %d.%d.%d.%d\n", (asic_acl.dstIpAddr_>>24),
@@ -554,7 +706,7 @@ static int32 acl_read( char *page, char **start, off_t off, int count, int *eof,
 						((asic_acl.srcIpAddrMask_&0x0000ff00)>>8), (asic_acl.srcIpAddrMask_&0xff)
 						);
 				len += sprintf(page+len, "\tTos: %x   TosM: %x   type: %x   typeM: %x   code: %x   codeM: %x\n",
-						asic_acl.tos_, asic_acl.tosMask_, asic_acl.icmpType_, asic_acl.icmpTypeMask_, 
+						asic_acl.tos_, asic_acl.tosMask_, asic_acl.icmpType_, asic_acl.icmpTypeMask_,
 						asic_acl.icmpCode_, asic_acl.icmpCodeMask_);
 				break;
 			case RTL865X_ACL_ICMP_IPRANGE:
@@ -570,7 +722,7 @@ static int32 acl_read( char *page, char **start, off_t off, int count, int *eof,
 						((asic_acl.srcIpAddrMask_&0x0000ff00)>>8), (asic_acl.srcIpAddrMask_&0xff)
 						);
 				len += sprintf(page+len, "\tTos: %x   TosM: %x   type: %x   typeM: %x   code: %x   codeM: %x\n",
-						asic_acl.tos_, asic_acl.tosMask_, asic_acl.icmpType_, asic_acl.icmpTypeMask_, 
+						asic_acl.tos_, asic_acl.tosMask_, asic_acl.icmpType_, asic_acl.icmpTypeMask_,
 						asic_acl.icmpCode_, asic_acl.icmpCodeMask_);
 				break;
 			case RTL865X_ACL_IGMP:
@@ -667,7 +819,7 @@ static int32 acl_read( char *page, char **start, off_t off, int count, int *eof,
 						asic_acl.tos_, asic_acl.tosMask_, asic_acl.udpSrcPortLB_, asic_acl.udpSrcPortUB_,
 						asic_acl.udpDstPortLB_, asic_acl.udpDstPortUB_
 						);
-				break;				
+				break;
 			case RTL865X_ACL_UDP_IPRANGE:
 				len += sprintf(page+len, " [%d] rule type: %s   rule action: %s\n", acl_start, "UDP IP RANGE", actionT[asic_acl.actionType_]);
 				len += sprintf(page+len, "\tdipU: %d.%d.%d.%d dipL: %d.%d.%d.%d\n", (asic_acl.dstIpAddr_>>24),
@@ -684,13 +836,13 @@ static int32 acl_read( char *page, char **start, off_t off, int count, int *eof,
 						asic_acl.tos_, asic_acl.tosMask_, asic_acl.udpSrcPortLB_, asic_acl.udpSrcPortUB_,
 						asic_acl.udpDstPortLB_, asic_acl.udpDstPortUB_
 					);
-				break;				
+				break;
+
 
-			
 			case RTL865X_ACL_SRCFILTER:
 				len += sprintf(page+len, " [%d] rule type: %s   rule action: %s\n", acl_start, "Source Filter", actionT[asic_acl.actionType_]);
-				len += sprintf(page+len, "\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n", 
-						asic_acl.srcFilterMac_.octet[0], asic_acl.srcFilterMac_.octet[1], asic_acl.srcFilterMac_.octet[2], 
+				len += sprintf(page+len, "\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n",
+						asic_acl.srcFilterMac_.octet[0], asic_acl.srcFilterMac_.octet[1], asic_acl.srcFilterMac_.octet[2],
 						asic_acl.srcFilterMac_.octet[3], asic_acl.srcFilterMac_.octet[4], asic_acl.srcFilterMac_.octet[5],
 						asic_acl.srcFilterMacMask_.octet[0], asic_acl.srcFilterMacMask_.octet[1], asic_acl.srcFilterMacMask_.octet[2],
 						asic_acl.srcFilterMacMask_.octet[3], asic_acl.srcFilterMacMask_.octet[4], asic_acl.srcFilterMacMask_.octet[5]
@@ -710,8 +862,8 @@ static int32 acl_read( char *page, char **start, off_t off, int count, int *eof,
 
 			case RTL865X_ACL_SRCFILTER_IPRANGE:
 				len += sprintf(page+len, " [%d] rule type: %s   rule action: %s\n", acl_start, "Source Filter(IP RANGE)", actionT[asic_acl.actionType_]);
-				len += sprintf(page+len, "\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n", 
-						asic_acl.srcFilterMac_.octet[0], asic_acl.srcFilterMac_.octet[1], asic_acl.srcFilterMac_.octet[2], 
+				len += sprintf(page+len, "\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n",
+						asic_acl.srcFilterMac_.octet[0], asic_acl.srcFilterMac_.octet[1], asic_acl.srcFilterMac_.octet[2],
 						asic_acl.srcFilterMac_.octet[3], asic_acl.srcFilterMac_.octet[4], asic_acl.srcFilterMac_.octet[5],
 						asic_acl.srcFilterMacMask_.octet[0], asic_acl.srcFilterMacMask_.octet[1], asic_acl.srcFilterMacMask_.octet[2],
 						asic_acl.srcFilterMacMask_.octet[3], asic_acl.srcFilterMacMask_.octet[4], asic_acl.srcFilterMacMask_.octet[5]
@@ -731,15 +883,15 @@ static int32 acl_read( char *page, char **start, off_t off, int count, int *eof,
 
 			case RTL865X_ACL_DSTFILTER:
 				len += sprintf(page+len, " [%d] rule type: %s   rule action: %s\n", acl_start, "Deatination Filter", actionT[asic_acl.actionType_]);
-				len += sprintf(page+len, "\tDMAC: %x:%x:%x:%x:%x:%x  DMACM: %x:%x:%x:%x:%x:%x\n", 
-						asic_acl.dstFilterMac_.octet[0], asic_acl.dstFilterMac_.octet[1], asic_acl.dstFilterMac_.octet[2], 
+				len += sprintf(page+len, "\tDMAC: %x:%x:%x:%x:%x:%x  DMACM: %x:%x:%x:%x:%x:%x\n",
+						asic_acl.dstFilterMac_.octet[0], asic_acl.dstFilterMac_.octet[1], asic_acl.dstFilterMac_.octet[2],
 						asic_acl.dstFilterMac_.octet[3], asic_acl.dstFilterMac_.octet[4], asic_acl.dstFilterMac_.octet[5],
 						asic_acl.dstFilterMacMask_.octet[0], asic_acl.dstFilterMacMask_.octet[1], asic_acl.dstFilterMacMask_.octet[2],
 						asic_acl.dstFilterMacMask_.octet[3], asic_acl.dstFilterMacMask_.octet[4], asic_acl.dstFilterMacMask_.octet[5]
 						);
 				len += sprintf(page+len, "\tdvidx: %d   dvidxM: %x  ProtoType: %x   dportL: %d   dportU: %d\n",
-						asic_acl.dstFilterVlanIdx_, asic_acl.dstFilterVlanIdxMask_, 
-						(asic_acl.dstFilterIgnoreL3L4_==TRUE? 2: (asic_acl.dstFilterIgnoreL4_ == 1? 1: 0)), 
+						asic_acl.dstFilterVlanIdx_, asic_acl.dstFilterVlanIdxMask_,
+						(asic_acl.dstFilterIgnoreL3L4_==TRUE? 2: (asic_acl.dstFilterIgnoreL4_ == 1? 1: 0)),
 						asic_acl.dstFilterPortLowerBound_, asic_acl.dstFilterPortUpperBound_
 						);
 				len += sprintf(page+len, "\tdip: %d.%d.%d.%d   dipM: %d.%d.%d.%d\n", (asic_acl.dstFilterIpAddr_>>24),
@@ -751,15 +903,15 @@ static int32 acl_read( char *page, char **start, off_t off, int count, int *eof,
 				break;
 			case RTL865X_ACL_DSTFILTER_IPRANGE:
 				len += sprintf(page+len, " [%d] rule type: %s   rule action: %s\n", acl_start, "Deatination Filter(IP Range)", actionT[asic_acl.actionType_]);
-				len += sprintf(page+len, "\tDMAC: %x:%x:%x:%x:%x:%x  DMACM: %x:%x:%x:%x:%x:%x\n", 
-						asic_acl.dstFilterMac_.octet[0], asic_acl.dstFilterMac_.octet[1], asic_acl.dstFilterMac_.octet[2], 
+				len += sprintf(page+len, "\tDMAC: %x:%x:%x:%x:%x:%x  DMACM: %x:%x:%x:%x:%x:%x\n",
+						asic_acl.dstFilterMac_.octet[0], asic_acl.dstFilterMac_.octet[1], asic_acl.dstFilterMac_.octet[2],
 						asic_acl.dstFilterMac_.octet[3], asic_acl.dstFilterMac_.octet[4], asic_acl.dstFilterMac_.octet[5],
 						asic_acl.dstFilterMacMask_.octet[0], asic_acl.dstFilterMacMask_.octet[1], asic_acl.dstFilterMacMask_.octet[2],
 						asic_acl.dstFilterMacMask_.octet[3], asic_acl.dstFilterMacMask_.octet[4], asic_acl.dstFilterMacMask_.octet[5]
 						);
 				len += sprintf(page+len, "\tdvidx: %d   dvidxM: %x  ProtoType: %x   dportL: %d   dportU: %d\n",
-						asic_acl.dstFilterVlanIdx_, asic_acl.dstFilterVlanIdxMask_, 
-						(asic_acl.dstFilterIgnoreL3L4_==TRUE? 2: (asic_acl.dstFilterIgnoreL4_ == 1? 1: 0)), 
+						asic_acl.dstFilterVlanIdx_, asic_acl.dstFilterVlanIdxMask_,
+						(asic_acl.dstFilterIgnoreL3L4_==TRUE? 2: (asic_acl.dstFilterIgnoreL4_ == 1? 1: 0)),
 						asic_acl.dstFilterPortLowerBound_, asic_acl.dstFilterPortUpperBound_
 						);
 				len += sprintf(page+len, "\tdipU: %d.%d.%d.%d   dipL: %d.%d.%d.%d\n", (asic_acl.dstFilterIpAddr_>>24),
@@ -777,7 +929,7 @@ static int32 acl_read( char *page, char **start, off_t off, int count, int *eof,
 
 
 				/* Action type */
-		switch (asic_acl.actionType_) 
+		switch (asic_acl.actionType_)
 		{
 
 			case RTL865X_ACL_PERMIT:
@@ -792,10 +944,10 @@ static int32 acl_read( char *page, char **start, off_t off, int count, int *eof,
 				len += sprintf(page+len, "\tnetifIdx: %d   pppoeIdx: %d   l2Idx:%d  ", asic_acl.netifIdx_, asic_acl.pppoeIdx_, asic_acl.L2Idx_);
 				break;
 
-			case RTL865X_ACL_PRIORITY: 
+			case RTL865X_ACL_PRIORITY:
 				len += sprintf(page+len, "\tprioirty: %d   ", asic_acl.priority_) ;
 				break;
-				
+
 			case RTL865X_ACL_DEFAULT_REDIRECT:
 				len += sprintf(page+len,"\tnextHop:%d  ", asic_acl.nexthopIdx_);
 				break;
@@ -806,19 +958,19 @@ static int32 acl_read( char *page, char **start, off_t off, int count, int *eof,
 			case RTL865X_ACL_LOG_RATE_EXCEED_BPS:
 				len += sprintf(page+len, "\tratelimitIdx: %d  ", asic_acl.ratelimtIdx_);
 				break;
-			default: 
+			default:
 				;
-			
+
 			}
 			len += sprintf(page+len, "pktOpApp: %d\n", asic_acl.pktOpApp_);
-			
+
 		}
 #else
-		for( ; acl_start<=acl_end; acl_start++) 
+		for( ; acl_start<=acl_end; acl_start++)
 		{
 			if (rtl8651_getAsicAclRule(acl_start, &asic_acl) == FAILED)
 				rtlglue_printf("=============%s(%d): get asic acl rule error!\n",__FUNCTION__, __LINE__);
-		
+
 			switch(asic_acl.ruleType_)
 			{
 			case RTL8651_ACL_MAC:
@@ -830,7 +982,7 @@ static int32 acl_read( char *page, char **start, off_t off, int count, int *eof,
 						asic_acl.dstMacMask_.octet[0], asic_acl.dstMacMask_.octet[1], asic_acl.dstMacMask_.octet[2],
 						asic_acl.dstMacMask_.octet[3], asic_acl.dstMacMask_.octet[4], asic_acl.dstMacMask_.octet[5]
 						);
-				
+
 				len += sprintf(page+len, "\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n",
 						asic_acl.srcMac_.octet[0], asic_acl.srcMac_.octet[1], asic_acl.srcMac_.octet[2],
 						asic_acl.srcMac_.octet[3], asic_acl.srcMac_.octet[4], asic_acl.srcMac_.octet[5],
@@ -854,14 +1006,14 @@ static int32 acl_read( char *page, char **start, off_t off, int count, int *eof,
 				len += sprintf(page+len, "\tTos: %x   TosM: %x   ipProto: %x   ipProtoM: %x   ipFlag: %x   ipFlagM: %x\n",
 						asic_acl.tos_, asic_acl.tosMask_, asic_acl.ipProto_, asic_acl.ipProtoMask_, asic_acl.ipFlag_, asic_acl.ipFlagMask_
 					);
-				
+
 				len += sprintf(page+len, "\t<FOP:%x> <FOM:%x> <http:%x> <httpM:%x> <IdentSdip:%x> <IdentSdipM:%x> \n",
 						asic_acl.ipFOP_, asic_acl.ipFOM_, asic_acl.ipHttpFilter_, asic_acl.ipHttpFilterM_, asic_acl.ipIdentSrcDstIp_,
 						asic_acl.ipIdentSrcDstIpM_
 						);
-				len += sprintf(page+len, "\t<DF:%x> <MF:%x>\n", asic_acl.ipDF_, asic_acl.ipMF_); 
+				len += sprintf(page+len, "\t<DF:%x> <MF:%x>\n", asic_acl.ipDF_, asic_acl.ipMF_);
 					break;
-					
+
 			case RTL8652_ACL_IP_RANGE:
 				len += sprintf(page+len, " [%d] rule type: %s   rule action: %s\n", acl_start, "IP Range", actionT[asic_acl.actionType_]);
 				len += sprintf(page+len, "\tdipU: %d.%d.%d.%d dipL: %d.%d.%d.%d\n", (asic_acl.dstIpAddr_>>24),
@@ -881,8 +1033,8 @@ static int32 acl_read( char *page, char **start, off_t off, int count, int *eof,
 						asic_acl.ipFOP_, asic_acl.ipFOM_, asic_acl.ipHttpFilter_, asic_acl.ipHttpFilterM_, asic_acl.ipIdentSrcDstIp_,
 						asic_acl.ipIdentSrcDstIpM_
 						);
-					len += sprintf(page+len, "\t<DF:%x> <MF:%x>\n", asic_acl.ipDF_, asic_acl.ipMF_); 
-					break;			
+					len += sprintf(page+len, "\t<DF:%x> <MF:%x>\n", asic_acl.ipDF_, asic_acl.ipMF_);
+					break;
 			case RTL8651_ACL_ICMP:
 				len += sprintf(page+len, " [%d] rule type: %s   rule action: %s\n", acl_start, "ICMP", actionT[asic_acl.actionType_]);
 				len += sprintf(page+len, "\tdip: %d.%d.%d.%d dipM: %d.%d.%d.%d\n", (asic_acl.dstIpAddr_>>24),
@@ -896,7 +1048,7 @@ static int32 acl_read( char *page, char **start, off_t off, int count, int *eof,
 						((asic_acl.srcIpAddrMask_&0x0000ff00)>>8), (asic_acl.srcIpAddrMask_&0xff)
 						);
 				len += sprintf(page+len, "\tTos: %x   TosM: %x   type: %x   typeM: %x   code: %x   codeM: %x\n",
-						asic_acl.tos_, asic_acl.tosMask_, asic_acl.icmpType_, asic_acl.icmpTypeMask_, 
+						asic_acl.tos_, asic_acl.tosMask_, asic_acl.icmpType_, asic_acl.icmpTypeMask_,
 						asic_acl.icmpCode_, asic_acl.icmpCodeMask_);
 				break;
 			case RTL8652_ACL_ICMP_IPRANGE:
@@ -912,7 +1064,7 @@ static int32 acl_read( char *page, char **start, off_t off, int count, int *eof,
 						((asic_acl.srcIpAddrMask_&0x0000ff00)>>8), (asic_acl.srcIpAddrMask_&0xff)
 						);
 				len += sprintf(page+len, "\tTos: %x   TosM: %x   type: %x   typeM: %x   code: %x   codeM: %x\n",
-						asic_acl.tos_, asic_acl.tosMask_, asic_acl.icmpType_, asic_acl.icmpTypeMask_, 
+						asic_acl.tos_, asic_acl.tosMask_, asic_acl.icmpType_, asic_acl.icmpTypeMask_,
 						asic_acl.icmpCode_, asic_acl.icmpCodeMask_);
 				break;
 			case RTL8651_ACL_IGMP:
@@ -1009,7 +1161,7 @@ static int32 acl_read( char *page, char **start, off_t off, int count, int *eof,
 						asic_acl.tos_, asic_acl.tosMask_, asic_acl.udpSrcPortLB_, asic_acl.udpSrcPortUB_,
 						asic_acl.udpDstPortLB_, asic_acl.udpDstPortUB_
 						);
-				break;				
+				break;
 			case RTL8652_ACL_UDP_IPRANGE:
 				len += sprintf(page+len, " [%d] rule type: %s   rule action: %s\n", acl_start, "UDP IP RANGE", actionT[asic_acl.actionType_]);
 				len += sprintf(page+len, "\tdipU: %d.%d.%d.%d dipL: %d.%d.%d.%d\n", (asic_acl.dstIpAddr_>>24),
@@ -1026,7 +1178,7 @@ static int32 acl_read( char *page, char **start, off_t off, int count, int *eof,
 						asic_acl.tos_, asic_acl.tosMask_, asic_acl.udpSrcPortLB_, asic_acl.udpSrcPortUB_,
 						asic_acl.udpDstPortLB_, asic_acl.udpDstPortUB_
 					);
-				break;				
+				break;
 
 			case RTL8651_ACL_IFSEL:
 				len += sprintf(page+len, " [%d] rule type: %s   rule action: %s\n", acl_start, "UDP", actionT[asic_acl.actionType_]);
@@ -1034,8 +1186,8 @@ static int32 acl_read( char *page, char **start, off_t off, int count, int *eof,
 				break;
 			case RTL8651_ACL_SRCFILTER:
 				len += sprintf(page+len, " [%d] rule type: %s   rule action: %s\n", acl_start, "Source Filter", actionT[asic_acl.actionType_]);
-				len += sprintf(page+len, "\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n", 
-						asic_acl.srcFilterMac_.octet[0], asic_acl.srcFilterMac_.octet[1], asic_acl.srcFilterMac_.octet[2], 
+				len += sprintf(page+len, "\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n",
+						asic_acl.srcFilterMac_.octet[0], asic_acl.srcFilterMac_.octet[1], asic_acl.srcFilterMac_.octet[2],
 						asic_acl.srcFilterMac_.octet[3], asic_acl.srcFilterMac_.octet[4], asic_acl.srcFilterMac_.octet[5],
 						asic_acl.srcFilterMacMask_.octet[0], asic_acl.srcFilterMacMask_.octet[1], asic_acl.srcFilterMacMask_.octet[2],
 						asic_acl.srcFilterMacMask_.octet[3], asic_acl.srcFilterMacMask_.octet[4], asic_acl.srcFilterMacMask_.octet[5]
@@ -1055,8 +1207,8 @@ static int32 acl_read( char *page, char **start, off_t off, int count, int *eof,
 
 			case RTL8652_ACL_SRCFILTER_IPRANGE:
 				len += sprintf(page+len, " [%d] rule type: %s   rule action: %s\n", acl_start, "Source Filter(IP RANGE)", actionT[asic_acl.actionType_]);
-				len += sprintf(page+len, "\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n", 
-						asic_acl.srcFilterMac_.octet[0], asic_acl.srcFilterMac_.octet[1], asic_acl.srcFilterMac_.octet[2], 
+				len += sprintf(page+len, "\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n",
+						asic_acl.srcFilterMac_.octet[0], asic_acl.srcFilterMac_.octet[1], asic_acl.srcFilterMac_.octet[2],
 						asic_acl.srcFilterMac_.octet[3], asic_acl.srcFilterMac_.octet[4], asic_acl.srcFilterMac_.octet[5],
 						asic_acl.srcFilterMacMask_.octet[0], asic_acl.srcFilterMacMask_.octet[1], asic_acl.srcFilterMacMask_.octet[2],
 						asic_acl.srcFilterMacMask_.octet[3], asic_acl.srcFilterMacMask_.octet[4], asic_acl.srcFilterMacMask_.octet[5]
@@ -1076,15 +1228,15 @@ static int32 acl_read( char *page, char **start, off_t off, int count, int *eof,
 
 			case RTL8651_ACL_DSTFILTER:
 				len += sprintf(page+len, " [%d] rule type: %s   rule action: %s\n", acl_start, "Deatination Filter", actionT[asic_acl.actionType_]);
-				len += sprintf(page+len, "\tDMAC: %x:%x:%x:%x:%x:%x  DMACM: %x:%x:%x:%x:%x:%x\n", 
-						asic_acl.dstFilterMac_.octet[0], asic_acl.dstFilterMac_.octet[1], asic_acl.dstFilterMac_.octet[2], 
+				len += sprintf(page+len, "\tDMAC: %x:%x:%x:%x:%x:%x  DMACM: %x:%x:%x:%x:%x:%x\n",
+						asic_acl.dstFilterMac_.octet[0], asic_acl.dstFilterMac_.octet[1], asic_acl.dstFilterMac_.octet[2],
 						asic_acl.dstFilterMac_.octet[3], asic_acl.dstFilterMac_.octet[4], asic_acl.dstFilterMac_.octet[5],
 						asic_acl.dstFilterMacMask_.octet[0], asic_acl.dstFilterMacMask_.octet[1], asic_acl.dstFilterMacMask_.octet[2],
 						asic_acl.dstFilterMacMask_.octet[3], asic_acl.dstFilterMacMask_.octet[4], asic_acl.dstFilterMacMask_.octet[5]
 						);
 				len += sprintf(page+len, "\tdvidx: %d   dvidxM: %x  ProtoType: %x   dportL: %d   dportU: %d\n",
-						asic_acl.dstFilterVlanIdx_, asic_acl.dstFilterVlanIdxMask_, 
-						(asic_acl.dstFilterIgnoreL3L4_==TRUE? 2: (asic_acl.dstFilterIgnoreL4_ == 1? 1: 0)), 
+						asic_acl.dstFilterVlanIdx_, asic_acl.dstFilterVlanIdxMask_,
+						(asic_acl.dstFilterIgnoreL3L4_==TRUE? 2: (asic_acl.dstFilterIgnoreL4_ == 1? 1: 0)),
 						asic_acl.dstFilterPortLowerBound_, asic_acl.dstFilterPortUpperBound_
 						);
 				len += sprintf(page+len, "\tdip: %d.%d.%d.%d   dipM: %d.%d.%d.%d\n", (asic_acl.dstFilterIpAddr_>>24),
@@ -1096,15 +1248,15 @@ static int32 acl_read( char *page, char **start, off_t off, int count, int *eof,
 				break;
 			case RTL8652_ACL_DSTFILTER_IPRANGE:
 				len += sprintf(page+len, " [%d] rule type: %s   rule action: %s\n", acl_start, "Deatination Filter(IP Range)", actionT[asic_acl.actionType_]);
-				len += sprintf(page+len, "\tDMAC: %x:%x:%x:%x:%x:%x  DMACM: %x:%x:%x:%x:%x:%x\n", 
-						asic_acl.dstFilterMac_.octet[0], asic_acl.dstFilterMac_.octet[1], asic_acl.dstFilterMac_.octet[2], 
+				len += sprintf(page+len, "\tDMAC: %x:%x:%x:%x:%x:%x  DMACM: %x:%x:%x:%x:%x:%x\n",
+						asic_acl.dstFilterMac_.octet[0], asic_acl.dstFilterMac_.octet[1], asic_acl.dstFilterMac_.octet[2],
 						asic_acl.dstFilterMac_.octet[3], asic_acl.dstFilterMac_.octet[4], asic_acl.dstFilterMac_.octet[5],
 						asic_acl.dstFilterMacMask_.octet[0], asic_acl.dstFilterMacMask_.octet[1], asic_acl.dstFilterMacMask_.octet[2],
 						asic_acl.dstFilterMacMask_.octet[3], asic_acl.dstFilterMacMask_.octet[4], asic_acl.dstFilterMacMask_.octet[5]
 						);
 				len += sprintf(page+len, "\tdvidx: %d   dvidxM: %x  ProtoType: %x   dportL: %d   dportU: %d\n",
-						asic_acl.dstFilterVlanIdx_, asic_acl.dstFilterVlanIdxMask_, 
-						(asic_acl.dstFilterIgnoreL3L4_==TRUE? 2: (asic_acl.dstFilterIgnoreL4_ == 1? 1: 0)), 
+						asic_acl.dstFilterVlanIdx_, asic_acl.dstFilterVlanIdxMask_,
+						(asic_acl.dstFilterIgnoreL3L4_==TRUE? 2: (asic_acl.dstFilterIgnoreL4_ == 1? 1: 0)),
 						asic_acl.dstFilterPortLowerBound_, asic_acl.dstFilterPortUpperBound_
 						);
 				len += sprintf(page+len, "\tdipU: %d.%d.%d.%d   dipL: %d.%d.%d.%d\n", (asic_acl.dstFilterIpAddr_>>24),
@@ -1122,7 +1274,7 @@ static int32 acl_read( char *page, char **start, off_t off, int count, int *eof,
 
 
 				/* Action type */
-		switch (asic_acl.actionType_) 
+		switch (asic_acl.actionType_)
 		{
 
 			case RTL8651_ACL_PERMIT: /* 0x00 */
@@ -1151,17 +1303,17 @@ static int32 acl_read( char *page, char **start, off_t off, int count, int *eof,
 			case RTL8651_ACL_LOG_RATE_EXCEED_BPS: /* 0x0d */
 				len += sprintf(page+len, "\trlIdx: %d  ", asic_acl.rlIndex);
 				break;
-			default: 
+			default:
 				;
-			
+
 			}
 			len += sprintf(page+len, "pktOpApp: %d\n", asic_acl.pktOpApp);
-			
+
 		}
 
 #endif
 
-		if (outRule == FALSE) 
+		if (outRule == FALSE)
 		{
 			acl_start = asic_intf.outAclStart; acl_end = asic_intf.outAclEnd;
 			outRule = TRUE;
@@ -1186,11 +1338,11 @@ static int32 acl_write( struct file *filp, const char *buff,unsigned long len, v
 #if RTL_LAYERED_DRIVER_DEBUG
 	char 	tmpbuf[32];
 	int32 testNo;
-	
-	if (buff && !copy_from_user(tmpbuf, buff, len)) 
+
+	if (buff && !copy_from_user(tmpbuf, buff, len))
 	{
 		tmpbuf[len] = '\0';
-		testNo = tmpbuf[0]-'0';		
+		testNo = tmpbuf[0]-'0';
 		rtl865x_acl_test(testNo);
 	}
 #endif
@@ -1207,14 +1359,18 @@ static int32 advRt_read( char *page, char **start, off_t off, int count, int *eo
 	return len;
 }
 
-static int32 advRt_write( struct file *filp, const char *buff,unsigned long len, void *data )	
+static int32 advRt_write( struct file *filp, const char *buff,unsigned long len, void *data )
 {
 	char 		tmpbuf[32];
 	rtl_advRoute_entry_t rule;
 	int retval;
+	if(len>32)
+	{
+		goto errout;
+	}
 	if (buff && !copy_from_user(tmpbuf, buff, len))
 	{
-		tmpbuf[len -1] = '\0';		
+		tmpbuf[len -1] = '\0';
 		if(tmpbuf[0] == '1')
 		{
 			//add rule
@@ -1232,7 +1388,7 @@ static int32 advRt_write( struct file *filp, const char *buff,unsigned long len,
 			rule.advrt_dstIpAddrEnd_ = 0xffffffff;
 
 			retval = rtl_add_advRt_entry(&rule);
-			printk("===%s(%d),retval(%d)\n",__FUNCTION__,__LINE__,retval);
+			rtlglue_printf("===%s(%d),retval(%d)\n",__FUNCTION__,__LINE__,retval);
 
 			//add rule
 			memset(&rule,0,sizeof(rtl_advRoute_entry_t));
@@ -1249,7 +1405,7 @@ static int32 advRt_write( struct file *filp, const char *buff,unsigned long len,
 			rule.advrt_dstIpAddrEnd_ = 0xffffffff;
 			retval = rtl_add_advRt_entry(&rule);
 
-			printk("===%s(%d),retval(%d)\n",__FUNCTION__,__LINE__,retval);
+			rtlglue_printf("===%s(%d),retval(%d)\n",__FUNCTION__,__LINE__,retval);
 		}
 		else if(tmpbuf[0] == '2')
 		{
@@ -1267,7 +1423,7 @@ static int32 advRt_write( struct file *filp, const char *buff,unsigned long len,
 			rule.advrt_dstIpAddrEnd_ = 0xffffffff;
 
 			retval = rtl_del_advRt_entry(&rule);
-			printk("===%s(%d),retval(%d)\n",__FUNCTION__,__LINE__,retval);		
+			rtlglue_printf("===%s(%d),retval(%d)\n",__FUNCTION__,__LINE__,retval);
 		}
 		else
 		{
@@ -1285,17 +1441,22 @@ static int32 advRt_write( struct file *filp, const char *buff,unsigned long len,
 			rule.advrt_dstIpAddrEnd_ = 0xffffffff;
 			retval = rtl_del_advRt_entry(&rule);
 
-			printk("===%s(%d),retval(%d)\n",__FUNCTION__,__LINE__,retval);
+			rtlglue_printf("===%s(%d),retval(%d)\n",__FUNCTION__,__LINE__,retval);
 		}
 	}
+	else
+	{
+errout:
+	rtlglue_printf("error input\n");
+	}
 	return len;
 }
 #endif
 
 int acl_show(struct seq_file *s, void *v)
 {
-	int8 *actionT[] = { "permit", "redirect to ether", "drop", "to cpu", "legacy drop", 
-					"drop for log", "mirror", "redirect to pppoe", "default redirect", "mirror keep match", 
+	int8 *actionT[] = { "permit", "redirect to ether", "drop", "to cpu", "legacy drop",
+					"drop for log", "mirror", "redirect to pppoe", "default redirect", "mirror keep match",
 					"drop rate exceed pps", "log rate exceed pps", "drop rate exceed bps", "log rate exceed bps","priority "
 					};
 #ifdef CONFIG_RTL_LAYERED_DRIVER
@@ -1308,13 +1469,13 @@ int acl_show(struct seq_file *s, void *v)
 
 	uint16 vid;
 	int8 outRule;
-#if defined (CONFIG_RTL_LOCAL_PUBLIC) || defined(CONFIG_RTL_MULTIPLE_WAN)
+#if defined (CONFIG_RTL_LOCAL_PUBLIC) || defined(CONFIG_RTL_MULTIPLE_WAN) || defined(CONFIG_RTL_HW_VLAN_SUPPORT)
 	unsigned char defInAclStart, defInAclEnd,defOutAclStart,defOutAclEnd;
 #endif
 
-	
+
 	seq_printf(s, "%s\n", "ASIC ACL Table:");
-	for(vid=0; vid<8; vid++ ) 
+	for(vid=0; vid<8; vid++ )
 	{
 		/* Read VLAN Table */
 		if (rtl8651_getAsicNetInterface(vid, &asic_intf) == FAILED)
@@ -1337,7 +1498,7 @@ int acl_show(struct seq_file *s, void *v)
 		{
 			if ( _rtl865x_getAclFromAsic(acl_start, &asic_acl) == FAILED)
 				rtlglue_printf("=============%s(%d): get asic acl rule error!\n",__FUNCTION__, __LINE__);
-		
+
 			switch(asic_acl.ruleType_)
 			{
 			case RTL865X_ACL_MAC:
@@ -1349,7 +1510,7 @@ int acl_show(struct seq_file *s, void *v)
 						asic_acl.dstMacMask_.octet[0], asic_acl.dstMacMask_.octet[1], asic_acl.dstMacMask_.octet[2],
 						asic_acl.dstMacMask_.octet[3], asic_acl.dstMacMask_.octet[4], asic_acl.dstMacMask_.octet[5]
 						);
-				
+
 				seq_printf(s, "\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n",
 						asic_acl.srcMac_.octet[0], asic_acl.srcMac_.octet[1], asic_acl.srcMac_.octet[2],
 						asic_acl.srcMac_.octet[3], asic_acl.srcMac_.octet[4], asic_acl.srcMac_.octet[5],
@@ -1373,14 +1534,14 @@ int acl_show(struct seq_file *s, void *v)
 				seq_printf(s, "\tTos: %x   TosM: %x   ipProto: %x   ipProtoM: %x   ipFlag: %x   ipFlagM: %x\n",
 						asic_acl.tos_, asic_acl.tosMask_, asic_acl.ipProto_, asic_acl.ipProtoMask_, asic_acl.ipFlag_, asic_acl.ipFlagMask_
 					);
-				
+
 				seq_printf(s, "\t<FOP:%x> <FOM:%x> <http:%x> <httpM:%x> <IdentSdip:%x> <IdentSdipM:%x> \n",
 						asic_acl.ipFOP_, asic_acl.ipFOM_, asic_acl.ipHttpFilter_, asic_acl.ipHttpFilterM_, asic_acl.ipIdentSrcDstIp_,
 						asic_acl.ipIdentSrcDstIpM_
 						);
-				seq_printf(s, "\t<DF:%x> <MF:%x>\n", asic_acl.ipDF_, asic_acl.ipMF_); 
+				seq_printf(s, "\t<DF:%x> <MF:%x>\n", asic_acl.ipDF_, asic_acl.ipMF_);
 					break;
-					
+
 			case RTL865X_ACL_IP_RANGE:
 				seq_printf(s, " [%d] rule type: %s   rule action: %s\n", acl_start, "IP Range", actionT[asic_acl.actionType_]);
 				seq_printf(s, "\tdipU: %d.%d.%d.%d dipL: %d.%d.%d.%d\n", (asic_acl.dstIpAddr_>>24),
@@ -1400,8 +1561,8 @@ int acl_show(struct seq_file *s, void *v)
 						asic_acl.ipFOP_, asic_acl.ipFOM_, asic_acl.ipHttpFilter_, asic_acl.ipHttpFilterM_, asic_acl.ipIdentSrcDstIp_,
 						asic_acl.ipIdentSrcDstIpM_
 						);
-					seq_printf(s, "\t<DF:%x> <MF:%x>\n", asic_acl.ipDF_, asic_acl.ipMF_); 
-					break;			
+					seq_printf(s, "\t<DF:%x> <MF:%x>\n", asic_acl.ipDF_, asic_acl.ipMF_);
+					break;
 			case RTL865X_ACL_ICMP:
 				seq_printf(s, " [%d] rule type: %s   rule action: %s\n", acl_start, "ICMP", actionT[asic_acl.actionType_]);
 				seq_printf(s, "\tdip: %d.%d.%d.%d dipM: %d.%d.%d.%d\n", (asic_acl.dstIpAddr_>>24),
@@ -1415,7 +1576,7 @@ int acl_show(struct seq_file *s, void *v)
 						((asic_acl.srcIpAddrMask_&0x0000ff00)>>8), (asic_acl.srcIpAddrMask_&0xff)
 						);
 				seq_printf(s, "\tTos: %x   TosM: %x   type: %x   typeM: %x   code: %x   codeM: %x\n",
-						asic_acl.tos_, asic_acl.tosMask_, asic_acl.icmpType_, asic_acl.icmpTypeMask_, 
+						asic_acl.tos_, asic_acl.tosMask_, asic_acl.icmpType_, asic_acl.icmpTypeMask_,
 						asic_acl.icmpCode_, asic_acl.icmpCodeMask_);
 				break;
 			case RTL865X_ACL_ICMP_IPRANGE:
@@ -1431,7 +1592,7 @@ int acl_show(struct seq_file *s, void *v)
 						((asic_acl.srcIpAddrMask_&0x0000ff00)>>8), (asic_acl.srcIpAddrMask_&0xff)
 						);
 				seq_printf(s, "\tTos: %x   TosM: %x   type: %x   typeM: %x   code: %x   codeM: %x\n",
-						asic_acl.tos_, asic_acl.tosMask_, asic_acl.icmpType_, asic_acl.icmpTypeMask_, 
+						asic_acl.tos_, asic_acl.tosMask_, asic_acl.icmpType_, asic_acl.icmpTypeMask_,
 						asic_acl.icmpCode_, asic_acl.icmpCodeMask_);
 				break;
 			case RTL865X_ACL_IGMP:
@@ -1528,7 +1689,7 @@ int acl_show(struct seq_file *s, void *v)
 						asic_acl.tos_, asic_acl.tosMask_, asic_acl.udpSrcPortLB_, asic_acl.udpSrcPortUB_,
 						asic_acl.udpDstPortLB_, asic_acl.udpDstPortUB_
 						);
-				break;				
+				break;
 			case RTL865X_ACL_UDP_IPRANGE:
 				seq_printf(s, " [%d] rule type: %s   rule action: %s\n", acl_start, "UDP IP RANGE", actionT[asic_acl.actionType_]);
 				seq_printf(s, "\tdipU: %d.%d.%d.%d dipL: %d.%d.%d.%d\n", (asic_acl.dstIpAddr_>>24),
@@ -1545,13 +1706,13 @@ int acl_show(struct seq_file *s, void *v)
 						asic_acl.tos_, asic_acl.tosMask_, asic_acl.udpSrcPortLB_, asic_acl.udpSrcPortUB_,
 						asic_acl.udpDstPortLB_, asic_acl.udpDstPortUB_
 					);
-				break;				
+				break;
+
 
-			
 			case RTL865X_ACL_SRCFILTER:
 				seq_printf(s, " [%d] rule type: %s   rule action: %s\n", acl_start, "Source Filter", actionT[asic_acl.actionType_]);
-				seq_printf(s, "\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n", 
-						asic_acl.srcFilterMac_.octet[0], asic_acl.srcFilterMac_.octet[1], asic_acl.srcFilterMac_.octet[2], 
+				seq_printf(s, "\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n",
+						asic_acl.srcFilterMac_.octet[0], asic_acl.srcFilterMac_.octet[1], asic_acl.srcFilterMac_.octet[2],
 						asic_acl.srcFilterMac_.octet[3], asic_acl.srcFilterMac_.octet[4], asic_acl.srcFilterMac_.octet[5],
 						asic_acl.srcFilterMacMask_.octet[0], asic_acl.srcFilterMacMask_.octet[1], asic_acl.srcFilterMacMask_.octet[2],
 						asic_acl.srcFilterMacMask_.octet[3], asic_acl.srcFilterMacMask_.octet[4], asic_acl.srcFilterMacMask_.octet[5]
@@ -1571,8 +1732,8 @@ int acl_show(struct seq_file *s, void *v)
 
 			case RTL865X_ACL_SRCFILTER_IPRANGE:
 				seq_printf(s, " [%d] rule type: %s   rule action: %s\n", acl_start, "Source Filter(IP RANGE)", actionT[asic_acl.actionType_]);
-				seq_printf(s, "\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n", 
-						asic_acl.srcFilterMac_.octet[0], asic_acl.srcFilterMac_.octet[1], asic_acl.srcFilterMac_.octet[2], 
+				seq_printf(s, "\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n",
+						asic_acl.srcFilterMac_.octet[0], asic_acl.srcFilterMac_.octet[1], asic_acl.srcFilterMac_.octet[2],
 						asic_acl.srcFilterMac_.octet[3], asic_acl.srcFilterMac_.octet[4], asic_acl.srcFilterMac_.octet[5],
 						asic_acl.srcFilterMacMask_.octet[0], asic_acl.srcFilterMacMask_.octet[1], asic_acl.srcFilterMacMask_.octet[2],
 						asic_acl.srcFilterMacMask_.octet[3], asic_acl.srcFilterMacMask_.octet[4], asic_acl.srcFilterMacMask_.octet[5]
@@ -1592,15 +1753,15 @@ int acl_show(struct seq_file *s, void *v)
 
 			case RTL865X_ACL_DSTFILTER:
 				seq_printf(s, " [%d] rule type: %s   rule action: %s\n", acl_start, "Deatination Filter", actionT[asic_acl.actionType_]);
-				seq_printf(s, "\tDMAC: %x:%x:%x:%x:%x:%x  DMACM: %x:%x:%x:%x:%x:%x\n", 
-						asic_acl.dstFilterMac_.octet[0], asic_acl.dstFilterMac_.octet[1], asic_acl.dstFilterMac_.octet[2], 
+				seq_printf(s, "\tDMAC: %x:%x:%x:%x:%x:%x  DMACM: %x:%x:%x:%x:%x:%x\n",
+						asic_acl.dstFilterMac_.octet[0], asic_acl.dstFilterMac_.octet[1], asic_acl.dstFilterMac_.octet[2],
 						asic_acl.dstFilterMac_.octet[3], asic_acl.dstFilterMac_.octet[4], asic_acl.dstFilterMac_.octet[5],
 						asic_acl.dstFilterMacMask_.octet[0], asic_acl.dstFilterMacMask_.octet[1], asic_acl.dstFilterMacMask_.octet[2],
 						asic_acl.dstFilterMacMask_.octet[3], asic_acl.dstFilterMacMask_.octet[4], asic_acl.dstFilterMacMask_.octet[5]
 						);
 				seq_printf(s, "\tdvidx: %d   dvidxM: %x  ProtoType: %x   dportL: %d   dportU: %d\n",
-						asic_acl.dstFilterVlanIdx_, asic_acl.dstFilterVlanIdxMask_, 
-						(asic_acl.dstFilterIgnoreL3L4_==TRUE? 2: (asic_acl.dstFilterIgnoreL4_ == 1? 1: 0)), 
+						asic_acl.dstFilterVlanIdx_, asic_acl.dstFilterVlanIdxMask_,
+						(asic_acl.dstFilterIgnoreL3L4_==TRUE? 2: (asic_acl.dstFilterIgnoreL4_ == 1? 1: 0)),
 						asic_acl.dstFilterPortLowerBound_, asic_acl.dstFilterPortUpperBound_
 						);
 				seq_printf(s, "\tdip: %d.%d.%d.%d   dipM: %d.%d.%d.%d\n", (asic_acl.dstFilterIpAddr_>>24),
@@ -1612,15 +1773,15 @@ int acl_show(struct seq_file *s, void *v)
 				break;
 			case RTL865X_ACL_DSTFILTER_IPRANGE:
 				seq_printf(s, " [%d] rule type: %s   rule action: %s\n", acl_start, "Deatination Filter(IP Range)", actionT[asic_acl.actionType_]);
-				seq_printf(s, "\tDMAC: %x:%x:%x:%x:%x:%x  DMACM: %x:%x:%x:%x:%x:%x\n", 
-						asic_acl.dstFilterMac_.octet[0], asic_acl.dstFilterMac_.octet[1], asic_acl.dstFilterMac_.octet[2], 
+				seq_printf(s, "\tDMAC: %x:%x:%x:%x:%x:%x  DMACM: %x:%x:%x:%x:%x:%x\n",
+						asic_acl.dstFilterMac_.octet[0], asic_acl.dstFilterMac_.octet[1], asic_acl.dstFilterMac_.octet[2],
 						asic_acl.dstFilterMac_.octet[3], asic_acl.dstFilterMac_.octet[4], asic_acl.dstFilterMac_.octet[5],
 						asic_acl.dstFilterMacMask_.octet[0], asic_acl.dstFilterMacMask_.octet[1], asic_acl.dstFilterMacMask_.octet[2],
 						asic_acl.dstFilterMacMask_.octet[3], asic_acl.dstFilterMacMask_.octet[4], asic_acl.dstFilterMacMask_.octet[5]
 						);
 				seq_printf(s, "\tdvidx: %d   dvidxM: %x  ProtoType: %x   dportL: %d   dportU: %d\n",
-						asic_acl.dstFilterVlanIdx_, asic_acl.dstFilterVlanIdxMask_, 
-						(asic_acl.dstFilterIgnoreL3L4_==TRUE? 2: (asic_acl.dstFilterIgnoreL4_ == 1? 1: 0)), 
+						asic_acl.dstFilterVlanIdx_, asic_acl.dstFilterVlanIdxMask_,
+						(asic_acl.dstFilterIgnoreL3L4_==TRUE? 2: (asic_acl.dstFilterIgnoreL4_ == 1? 1: 0)),
 						asic_acl.dstFilterPortLowerBound_, asic_acl.dstFilterPortUpperBound_
 						);
 				seq_printf(s, "\tdipU: %d.%d.%d.%d   dipL: %d.%d.%d.%d\n", (asic_acl.dstFilterIpAddr_>>24),
@@ -1638,7 +1799,7 @@ int acl_show(struct seq_file *s, void *v)
 
 
 				/* Action type */
-		switch (asic_acl.actionType_) 
+		switch (asic_acl.actionType_)
 		{
 
 			case RTL865X_ACL_PERMIT:
@@ -1653,10 +1814,10 @@ int acl_show(struct seq_file *s, void *v)
 				seq_printf(s, "\tnetifIdx: %d   pppoeIdx: %d   l2Idx:%d  ", asic_acl.netifIdx_, asic_acl.pppoeIdx_, asic_acl.L2Idx_);
 				break;
 
-			case RTL865X_ACL_PRIORITY: 
+			case RTL865X_ACL_PRIORITY:
 				seq_printf(s, "\tprioirty: %d   ", asic_acl.priority_) ;
 				break;
-				
+
 			case RTL865X_ACL_DEFAULT_REDIRECT:
 				seq_printf(s,"\tnextHop:%d  ", asic_acl.nexthopIdx_);
 				break;
@@ -1667,19 +1828,19 @@ int acl_show(struct seq_file *s, void *v)
 			case RTL865X_ACL_LOG_RATE_EXCEED_BPS:
 				seq_printf(s, "\tratelimitIdx: %d  ", asic_acl.ratelimtIdx_);
 				break;
-			default: 
+			default:
 				;
-			
+
 			}
 			seq_printf(s, "pktOpApp: %d\n", asic_acl.pktOpApp_);
-			
+
 		}
 #else
-		for( ; acl_start<=acl_end; acl_start++) 
+		for( ; acl_start<=acl_end; acl_start++)
 		{
 			if (rtl8651_getAsicAclRule(acl_start, &asic_acl) == FAILED)
 				rtlglue_printf("=============%s(%d): get asic acl rule error!\n",__FUNCTION__, __LINE__);
-		
+
 			switch(asic_acl.ruleType_)
 			{
 			case RTL8651_ACL_MAC:
@@ -1691,7 +1852,7 @@ int acl_show(struct seq_file *s, void *v)
 						asic_acl.dstMacMask_.octet[0], asic_acl.dstMacMask_.octet[1], asic_acl.dstMacMask_.octet[2],
 						asic_acl.dstMacMask_.octet[3], asic_acl.dstMacMask_.octet[4], asic_acl.dstMacMask_.octet[5]
 						);
-				
+
 				seq_printf(s, "\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n",
 						asic_acl.srcMac_.octet[0], asic_acl.srcMac_.octet[1], asic_acl.srcMac_.octet[2],
 						asic_acl.srcMac_.octet[3], asic_acl.srcMac_.octet[4], asic_acl.srcMac_.octet[5],
@@ -1715,14 +1876,14 @@ int acl_show(struct seq_file *s, void *v)
 				seq_printf(s, "\tTos: %x   TosM: %x   ipProto: %x   ipProtoM: %x   ipFlag: %x   ipFlagM: %x\n",
 						asic_acl.tos_, asic_acl.tosMask_, asic_acl.ipProto_, asic_acl.ipProtoMask_, asic_acl.ipFlag_, asic_acl.ipFlagMask_
 					);
-				
+
 				seq_printf(s, "\t<FOP:%x> <FOM:%x> <http:%x> <httpM:%x> <IdentSdip:%x> <IdentSdipM:%x> \n",
 						asic_acl.ipFOP_, asic_acl.ipFOM_, asic_acl.ipHttpFilter_, asic_acl.ipHttpFilterM_, asic_acl.ipIdentSrcDstIp_,
 						asic_acl.ipIdentSrcDstIpM_
 						);
-				seq_printf(s, "\t<DF:%x> <MF:%x>\n", asic_acl.ipDF_, asic_acl.ipMF_); 
+				seq_printf(s, "\t<DF:%x> <MF:%x>\n", asic_acl.ipDF_, asic_acl.ipMF_);
 					break;
-					
+
 			case RTL8652_ACL_IP_RANGE:
 				seq_printf(s, " [%d] rule type: %s   rule action: %s\n", acl_start, "IP Range", actionT[asic_acl.actionType_]);
 				seq_printf(s, "\tdipU: %d.%d.%d.%d dipL: %d.%d.%d.%d\n", (asic_acl.dstIpAddr_>>24),
@@ -1742,8 +1903,8 @@ int acl_show(struct seq_file *s, void *v)
 						asic_acl.ipFOP_, asic_acl.ipFOM_, asic_acl.ipHttpFilter_, asic_acl.ipHttpFilterM_, asic_acl.ipIdentSrcDstIp_,
 						asic_acl.ipIdentSrcDstIpM_
 						);
-					seq_printf(s, "\t<DF:%x> <MF:%x>\n", asic_acl.ipDF_, asic_acl.ipMF_); 
-					break;			
+					seq_printf(s, "\t<DF:%x> <MF:%x>\n", asic_acl.ipDF_, asic_acl.ipMF_);
+					break;
 			case RTL8651_ACL_ICMP:
 				seq_printf(s, " [%d] rule type: %s   rule action: %s\n", acl_start, "ICMP", actionT[asic_acl.actionType_]);
 				seq_printf(s, "\tdip: %d.%d.%d.%d dipM: %d.%d.%d.%d\n", (asic_acl.dstIpAddr_>>24),
@@ -1757,7 +1918,7 @@ int acl_show(struct seq_file *s, void *v)
 						((asic_acl.srcIpAddrMask_&0x0000ff00)>>8), (asic_acl.srcIpAddrMask_&0xff)
 						);
 				seq_printf(s, "\tTos: %x   TosM: %x   type: %x   typeM: %x   code: %x   codeM: %x\n",
-						asic_acl.tos_, asic_acl.tosMask_, asic_acl.icmpType_, asic_acl.icmpTypeMask_, 
+						asic_acl.tos_, asic_acl.tosMask_, asic_acl.icmpType_, asic_acl.icmpTypeMask_,
 						asic_acl.icmpCode_, asic_acl.icmpCodeMask_);
 				break;
 			case RTL8652_ACL_ICMP_IPRANGE:
@@ -1773,7 +1934,7 @@ int acl_show(struct seq_file *s, void *v)
 						((asic_acl.srcIpAddrMask_&0x0000ff00)>>8), (asic_acl.srcIpAddrMask_&0xff)
 						);
 				seq_printf(s, "\tTos: %x   TosM: %x   type: %x   typeM: %x   code: %x   codeM: %x\n",
-						asic_acl.tos_, asic_acl.tosMask_, asic_acl.icmpType_, asic_acl.icmpTypeMask_, 
+						asic_acl.tos_, asic_acl.tosMask_, asic_acl.icmpType_, asic_acl.icmpTypeMask_,
 						asic_acl.icmpCode_, asic_acl.icmpCodeMask_);
 				break;
 			case RTL8651_ACL_IGMP:
@@ -1870,7 +2031,7 @@ int acl_show(struct seq_file *s, void *v)
 						asic_acl.tos_, asic_acl.tosMask_, asic_acl.udpSrcPortLB_, asic_acl.udpSrcPortUB_,
 						asic_acl.udpDstPortLB_, asic_acl.udpDstPortUB_
 						);
-				break;				
+				break;
 			case RTL8652_ACL_UDP_IPRANGE:
 				seq_printf(s, " [%d] rule type: %s   rule action: %s\n", acl_start, "UDP IP RANGE", actionT[asic_acl.actionType_]);
 				seq_printf(s, "\tdipU: %d.%d.%d.%d dipL: %d.%d.%d.%d\n", (asic_acl.dstIpAddr_>>24),
@@ -1887,7 +2048,7 @@ int acl_show(struct seq_file *s, void *v)
 						asic_acl.tos_, asic_acl.tosMask_, asic_acl.udpSrcPortLB_, asic_acl.udpSrcPortUB_,
 						asic_acl.udpDstPortLB_, asic_acl.udpDstPortUB_
 					);
-				break;				
+				break;
 
 			case RTL8651_ACL_IFSEL:
 				seq_printf(s, " [%d] rule type: %s   rule action: %s\n", acl_start, "UDP", actionT[asic_acl.actionType_]);
@@ -1895,8 +2056,8 @@ int acl_show(struct seq_file *s, void *v)
 				break;
 			case RTL8651_ACL_SRCFILTER:
 				seq_printf(s, " [%d] rule type: %s   rule action: %s\n", acl_start, "Source Filter", actionT[asic_acl.actionType_]);
-				seq_printf(s, "\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n", 
-						asic_acl.srcFilterMac_.octet[0], asic_acl.srcFilterMac_.octet[1], asic_acl.srcFilterMac_.octet[2], 
+				seq_printf(s, "\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n",
+						asic_acl.srcFilterMac_.octet[0], asic_acl.srcFilterMac_.octet[1], asic_acl.srcFilterMac_.octet[2],
 						asic_acl.srcFilterMac_.octet[3], asic_acl.srcFilterMac_.octet[4], asic_acl.srcFilterMac_.octet[5],
 						asic_acl.srcFilterMacMask_.octet[0], asic_acl.srcFilterMacMask_.octet[1], asic_acl.srcFilterMacMask_.octet[2],
 						asic_acl.srcFilterMacMask_.octet[3], asic_acl.srcFilterMacMask_.octet[4], asic_acl.srcFilterMacMask_.octet[5]
@@ -1916,8 +2077,8 @@ int acl_show(struct seq_file *s, void *v)
 
 			case RTL8652_ACL_SRCFILTER_IPRANGE:
 				seq_printf(s, " [%d] rule type: %s   rule action: %s\n", acl_start, "Source Filter(IP RANGE)", actionT[asic_acl.actionType_]);
-				seq_printf(s, "\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n", 
-						asic_acl.srcFilterMac_.octet[0], asic_acl.srcFilterMac_.octet[1], asic_acl.srcFilterMac_.octet[2], 
+				seq_printf(s, "\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n",
+						asic_acl.srcFilterMac_.octet[0], asic_acl.srcFilterMac_.octet[1], asic_acl.srcFilterMac_.octet[2],
 						asic_acl.srcFilterMac_.octet[3], asic_acl.srcFilterMac_.octet[4], asic_acl.srcFilterMac_.octet[5],
 						asic_acl.srcFilterMacMask_.octet[0], asic_acl.srcFilterMacMask_.octet[1], asic_acl.srcFilterMacMask_.octet[2],
 						asic_acl.srcFilterMacMask_.octet[3], asic_acl.srcFilterMacMask_.octet[4], asic_acl.srcFilterMacMask_.octet[5]
@@ -1937,15 +2098,15 @@ int acl_show(struct seq_file *s, void *v)
 
 			case RTL8651_ACL_DSTFILTER:
 				seq_printf(s, " [%d] rule type: %s   rule action: %s\n", acl_start, "Deatination Filter", actionT[asic_acl.actionType_]);
-				seq_printf(s, "\tDMAC: %x:%x:%x:%x:%x:%x  DMACM: %x:%x:%x:%x:%x:%x\n", 
-						asic_acl.dstFilterMac_.octet[0], asic_acl.dstFilterMac_.octet[1], asic_acl.dstFilterMac_.octet[2], 
+				seq_printf(s, "\tDMAC: %x:%x:%x:%x:%x:%x  DMACM: %x:%x:%x:%x:%x:%x\n",
+						asic_acl.dstFilterMac_.octet[0], asic_acl.dstFilterMac_.octet[1], asic_acl.dstFilterMac_.octet[2],
 						asic_acl.dstFilterMac_.octet[3], asic_acl.dstFilterMac_.octet[4], asic_acl.dstFilterMac_.octet[5],
 						asic_acl.dstFilterMacMask_.octet[0], asic_acl.dstFilterMacMask_.octet[1], asic_acl.dstFilterMacMask_.octet[2],
 						asic_acl.dstFilterMacMask_.octet[3], asic_acl.dstFilterMacMask_.octet[4], asic_acl.dstFilterMacMask_.octet[5]
 						);
 				seq_printf(s, "\tdvidx: %d   dvidxM: %x  ProtoType: %x   dportL: %d   dportU: %d\n",
-						asic_acl.dstFilterVlanIdx_, asic_acl.dstFilterVlanIdxMask_, 
-						(asic_acl.dstFilterIgnoreL3L4_==TRUE? 2: (asic_acl.dstFilterIgnoreL4_ == 1? 1: 0)), 
+						asic_acl.dstFilterVlanIdx_, asic_acl.dstFilterVlanIdxMask_,
+						(asic_acl.dstFilterIgnoreL3L4_==TRUE? 2: (asic_acl.dstFilterIgnoreL4_ == 1? 1: 0)),
 						asic_acl.dstFilterPortLowerBound_, asic_acl.dstFilterPortUpperBound_
 						);
 				seq_printf(s, "\tdip: %d.%d.%d.%d   dipM: %d.%d.%d.%d\n", (asic_acl.dstFilterIpAddr_>>24),
@@ -1957,15 +2118,15 @@ int acl_show(struct seq_file *s, void *v)
 				break;
 			case RTL8652_ACL_DSTFILTER_IPRANGE:
 				seq_printf(s, " [%d] rule type: %s   rule action: %s\n", acl_start, "Deatination Filter(IP Range)", actionT[asic_acl.actionType_]);
-				seq_printf(s, "\tDMAC: %x:%x:%x:%x:%x:%x  DMACM: %x:%x:%x:%x:%x:%x\n", 
-						asic_acl.dstFilterMac_.octet[0], asic_acl.dstFilterMac_.octet[1], asic_acl.dstFilterMac_.octet[2], 
+				seq_printf(s, "\tDMAC: %x:%x:%x:%x:%x:%x  DMACM: %x:%x:%x:%x:%x:%x\n",
+						asic_acl.dstFilterMac_.octet[0], asic_acl.dstFilterMac_.octet[1], asic_acl.dstFilterMac_.octet[2],
 						asic_acl.dstFilterMac_.octet[3], asic_acl.dstFilterMac_.octet[4], asic_acl.dstFilterMac_.octet[5],
 						asic_acl.dstFilterMacMask_.octet[0], asic_acl.dstFilterMacMask_.octet[1], asic_acl.dstFilterMacMask_.octet[2],
 						asic_acl.dstFilterMacMask_.octet[3], asic_acl.dstFilterMacMask_.octet[4], asic_acl.dstFilterMacMask_.octet[5]
 						);
 				seq_printf(s, "\tdvidx: %d   dvidxM: %x  ProtoType: %x   dportL: %d   dportU: %d\n",
-						asic_acl.dstFilterVlanIdx_, asic_acl.dstFilterVlanIdxMask_, 
-						(asic_acl.dstFilterIgnoreL3L4_==TRUE? 2: (asic_acl.dstFilterIgnoreL4_ == 1? 1: 0)), 
+						asic_acl.dstFilterVlanIdx_, asic_acl.dstFilterVlanIdxMask_,
+						(asic_acl.dstFilterIgnoreL3L4_==TRUE? 2: (asic_acl.dstFilterIgnoreL4_ == 1? 1: 0)),
 						asic_acl.dstFilterPortLowerBound_, asic_acl.dstFilterPortUpperBound_
 						);
 				seq_printf(s, "\tdipU: %d.%d.%d.%d   dipL: %d.%d.%d.%d\n", (asic_acl.dstFilterIpAddr_>>24),
@@ -1983,7 +2144,7 @@ int acl_show(struct seq_file *s, void *v)
 
 
 				/* Action type */
-		switch (asic_acl.actionType_) 
+		switch (asic_acl.actionType_)
 		{
 
 			case RTL8651_ACL_PERMIT: /* 0x00 */
@@ -2012,17 +2173,17 @@ int acl_show(struct seq_file *s, void *v)
 			case RTL8651_ACL_LOG_RATE_EXCEED_BPS: /* 0x0d */
 				seq_printf(s, "\trlIdx: %d  ", asic_acl.rlIndex);
 				break;
-			default: 
+			default:
 				;
-			
+
 			}
 			seq_printf(s, "pktOpApp: %d\n", asic_acl.pktOpApp);
-			
+
 		}
 
 #endif
 
-		if (outRule == FALSE) 
+		if (outRule == FALSE)
 		{
 			acl_start = asic_intf.outAclStart; acl_end = asic_intf.outAclEnd;
 			outRule = TRUE;
@@ -2030,11 +2191,11 @@ int acl_show(struct seq_file *s, void *v)
 		}
 	}
 
-#if defined (CONFIG_RTL_LOCAL_PUBLIC) ||defined(CONFIG_RTL_MULTIPLE_WAN)
+#if defined (CONFIG_RTL_LOCAL_PUBLIC) ||defined(CONFIG_RTL_MULTIPLE_WAN) || defined(CONFIG_RTL_HW_VLAN_SUPPORT)
 {
 
 		outRule = FALSE;
-		 rtl865x_getDefACLForNetDecisionMiss(&defInAclStart, &defInAclEnd,&defOutAclStart,&defOutAclEnd);	
+		 rtl865x_getDefACLForNetDecisionMiss(&defInAclStart, &defInAclEnd,&defOutAclStart,&defOutAclEnd);
 		acl_start = defInAclStart; acl_end = defInAclEnd;
 		seq_printf(s, "\nacl_start(%d), acl_end(%d)", acl_start, acl_end);
 again_forOutAcl:
@@ -2047,7 +2208,7 @@ again_forOutAcl:
 		{
 			if ( _rtl865x_getAclFromAsic(acl_start, &asic_acl) == FAILED)
 				rtlglue_printf("=============%s(%d): get asic acl rule error!\n",__FUNCTION__, __LINE__);
-		
+
 			switch(asic_acl.ruleType_)
 			{
 			case RTL865X_ACL_MAC:
@@ -2059,7 +2220,7 @@ again_forOutAcl:
 						asic_acl.dstMacMask_.octet[0], asic_acl.dstMacMask_.octet[1], asic_acl.dstMacMask_.octet[2],
 						asic_acl.dstMacMask_.octet[3], asic_acl.dstMacMask_.octet[4], asic_acl.dstMacMask_.octet[5]
 						);
-				
+
 				seq_printf(s, "\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n",
 						asic_acl.srcMac_.octet[0], asic_acl.srcMac_.octet[1], asic_acl.srcMac_.octet[2],
 						asic_acl.srcMac_.octet[3], asic_acl.srcMac_.octet[4], asic_acl.srcMac_.octet[5],
@@ -2083,14 +2244,14 @@ again_forOutAcl:
 				seq_printf(s, "\tTos: %x   TosM: %x   ipProto: %x   ipProtoM: %x   ipFlag: %x   ipFlagM: %x\n",
 						asic_acl.tos_, asic_acl.tosMask_, asic_acl.ipProto_, asic_acl.ipProtoMask_, asic_acl.ipFlag_, asic_acl.ipFlagMask_
 					);
-				
+
 				seq_printf(s, "\t<FOP:%x> <FOM:%x> <http:%x> <httpM:%x> <IdentSdip:%x> <IdentSdipM:%x> \n",
 						asic_acl.ipFOP_, asic_acl.ipFOM_, asic_acl.ipHttpFilter_, asic_acl.ipHttpFilterM_, asic_acl.ipIdentSrcDstIp_,
 						asic_acl.ipIdentSrcDstIpM_
 						);
-				seq_printf(s, "\t<DF:%x> <MF:%x>\n", asic_acl.ipDF_, asic_acl.ipMF_); 
+				seq_printf(s, "\t<DF:%x> <MF:%x>\n", asic_acl.ipDF_, asic_acl.ipMF_);
 					break;
-					
+
 			case RTL865X_ACL_IP_RANGE:
 				seq_printf(s, " [%d] rule type: %s   rule action: %s\n", acl_start, "IP Range", actionT[asic_acl.actionType_]);
 				seq_printf(s, "\tdipU: %d.%d.%d.%d dipL: %d.%d.%d.%d\n", (asic_acl.dstIpAddr_>>24),
@@ -2110,8 +2271,8 @@ again_forOutAcl:
 						asic_acl.ipFOP_, asic_acl.ipFOM_, asic_acl.ipHttpFilter_, asic_acl.ipHttpFilterM_, asic_acl.ipIdentSrcDstIp_,
 						asic_acl.ipIdentSrcDstIpM_
 						);
-					seq_printf(s, "\t<DF:%x> <MF:%x>\n", asic_acl.ipDF_, asic_acl.ipMF_); 
-					break;			
+					seq_printf(s, "\t<DF:%x> <MF:%x>\n", asic_acl.ipDF_, asic_acl.ipMF_);
+					break;
 			case RTL865X_ACL_ICMP:
 				seq_printf(s, " [%d] rule type: %s   rule action: %s\n", acl_start, "ICMP", actionT[asic_acl.actionType_]);
 				seq_printf(s, "\tdip: %d.%d.%d.%d dipM: %d.%d.%d.%d\n", (asic_acl.dstIpAddr_>>24),
@@ -2125,7 +2286,7 @@ again_forOutAcl:
 						((asic_acl.srcIpAddrMask_&0x0000ff00)>>8), (asic_acl.srcIpAddrMask_&0xff)
 						);
 				seq_printf(s, "\tTos: %x   TosM: %x   type: %x   typeM: %x   code: %x   codeM: %x\n",
-						asic_acl.tos_, asic_acl.tosMask_, asic_acl.icmpType_, asic_acl.icmpTypeMask_, 
+						asic_acl.tos_, asic_acl.tosMask_, asic_acl.icmpType_, asic_acl.icmpTypeMask_,
 						asic_acl.icmpCode_, asic_acl.icmpCodeMask_);
 				break;
 			case RTL865X_ACL_ICMP_IPRANGE:
@@ -2141,7 +2302,7 @@ again_forOutAcl:
 						((asic_acl.srcIpAddrMask_&0x0000ff00)>>8), (asic_acl.srcIpAddrMask_&0xff)
 						);
 				seq_printf(s, "\tTos: %x   TosM: %x   type: %x   typeM: %x   code: %x   codeM: %x\n",
-						asic_acl.tos_, asic_acl.tosMask_, asic_acl.icmpType_, asic_acl.icmpTypeMask_, 
+						asic_acl.tos_, asic_acl.tosMask_, asic_acl.icmpType_, asic_acl.icmpTypeMask_,
 						asic_acl.icmpCode_, asic_acl.icmpCodeMask_);
 				break;
 			case RTL865X_ACL_IGMP:
@@ -2238,7 +2399,7 @@ again_forOutAcl:
 						asic_acl.tos_, asic_acl.tosMask_, asic_acl.udpSrcPortLB_, asic_acl.udpSrcPortUB_,
 						asic_acl.udpDstPortLB_, asic_acl.udpDstPortUB_
 						);
-				break;				
+				break;
 			case RTL865X_ACL_UDP_IPRANGE:
 				seq_printf(s, " [%d] rule type: %s   rule action: %s\n", acl_start, "UDP IP RANGE", actionT[asic_acl.actionType_]);
 				seq_printf(s, "\tdipU: %d.%d.%d.%d dipL: %d.%d.%d.%d\n", (asic_acl.dstIpAddr_>>24),
@@ -2255,13 +2416,13 @@ again_forOutAcl:
 						asic_acl.tos_, asic_acl.tosMask_, asic_acl.udpSrcPortLB_, asic_acl.udpSrcPortUB_,
 						asic_acl.udpDstPortLB_, asic_acl.udpDstPortUB_
 					);
-				break;				
+				break;
+
 
-			
 			case RTL865X_ACL_SRCFILTER:
 				seq_printf(s, " [%d] rule type: %s   rule action: %s\n", acl_start, "Source Filter", actionT[asic_acl.actionType_]);
-				seq_printf(s, "\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n", 
-						asic_acl.srcFilterMac_.octet[0], asic_acl.srcFilterMac_.octet[1], asic_acl.srcFilterMac_.octet[2], 
+				seq_printf(s, "\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n",
+						asic_acl.srcFilterMac_.octet[0], asic_acl.srcFilterMac_.octet[1], asic_acl.srcFilterMac_.octet[2],
 						asic_acl.srcFilterMac_.octet[3], asic_acl.srcFilterMac_.octet[4], asic_acl.srcFilterMac_.octet[5],
 						asic_acl.srcFilterMacMask_.octet[0], asic_acl.srcFilterMacMask_.octet[1], asic_acl.srcFilterMacMask_.octet[2],
 						asic_acl.srcFilterMacMask_.octet[3], asic_acl.srcFilterMacMask_.octet[4], asic_acl.srcFilterMacMask_.octet[5]
@@ -2281,8 +2442,8 @@ again_forOutAcl:
 
 			case RTL865X_ACL_SRCFILTER_IPRANGE:
 				seq_printf(s, " [%d] rule type: %s   rule action: %s\n", acl_start, "Source Filter(IP RANGE)", actionT[asic_acl.actionType_]);
-				seq_printf(s, "\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n", 
-						asic_acl.srcFilterMac_.octet[0], asic_acl.srcFilterMac_.octet[1], asic_acl.srcFilterMac_.octet[2], 
+				seq_printf(s, "\tSMAC: %x:%x:%x:%x:%x:%x  SMACM: %x:%x:%x:%x:%x:%x\n",
+						asic_acl.srcFilterMac_.octet[0], asic_acl.srcFilterMac_.octet[1], asic_acl.srcFilterMac_.octet[2],
 						asic_acl.srcFilterMac_.octet[3], asic_acl.srcFilterMac_.octet[4], asic_acl.srcFilterMac_.octet[5],
 						asic_acl.srcFilterMacMask_.octet[0], asic_acl.srcFilterMacMask_.octet[1], asic_acl.srcFilterMacMask_.octet[2],
 						asic_acl.srcFilterMacMask_.octet[3], asic_acl.srcFilterMacMask_.octet[4], asic_acl.srcFilterMacMask_.octet[5]
@@ -2302,15 +2463,15 @@ again_forOutAcl:
 
 			case RTL865X_ACL_DSTFILTER:
 				seq_printf(s, " [%d] rule type: %s   rule action: %s\n", acl_start, "Deatination Filter", actionT[asic_acl.actionType_]);
-				seq_printf(s, "\tDMAC: %x:%x:%x:%x:%x:%x  DMACM: %x:%x:%x:%x:%x:%x\n", 
-						asic_acl.dstFilterMac_.octet[0], asic_acl.dstFilterMac_.octet[1], asic_acl.dstFilterMac_.octet[2], 
+				seq_printf(s, "\tDMAC: %x:%x:%x:%x:%x:%x  DMACM: %x:%x:%x:%x:%x:%x\n",
+						asic_acl.dstFilterMac_.octet[0], asic_acl.dstFilterMac_.octet[1], asic_acl.dstFilterMac_.octet[2],
 						asic_acl.dstFilterMac_.octet[3], asic_acl.dstFilterMac_.octet[4], asic_acl.dstFilterMac_.octet[5],
 						asic_acl.dstFilterMacMask_.octet[0], asic_acl.dstFilterMacMask_.octet[1], asic_acl.dstFilterMacMask_.octet[2],
 						asic_acl.dstFilterMacMask_.octet[3], asic_acl.dstFilterMacMask_.octet[4], asic_acl.dstFilterMacMask_.octet[5]
 						);
 				seq_printf(s, "\tdvidx: %d   dvidxM: %x  ProtoType: %x   dportL: %d   dportU: %d\n",
-						asic_acl.dstFilterVlanIdx_, asic_acl.dstFilterVlanIdxMask_, 
-						(asic_acl.dstFilterIgnoreL3L4_==TRUE? 2: (asic_acl.dstFilterIgnoreL4_ == 1? 1: 0)), 
+						asic_acl.dstFilterVlanIdx_, asic_acl.dstFilterVlanIdxMask_,
+						(asic_acl.dstFilterIgnoreL3L4_==TRUE? 2: (asic_acl.dstFilterIgnoreL4_ == 1? 1: 0)),
 						asic_acl.dstFilterPortLowerBound_, asic_acl.dstFilterPortUpperBound_
 						);
 				seq_printf(s, "\tdip: %d.%d.%d.%d   dipM: %d.%d.%d.%d\n", (asic_acl.dstFilterIpAddr_>>24),
@@ -2322,15 +2483,15 @@ again_forOutAcl:
 				break;
 			case RTL865X_ACL_DSTFILTER_IPRANGE:
 				seq_printf(s, " [%d] rule type: %s   rule action: %s\n", acl_start, "Deatination Filter(IP Range)", actionT[asic_acl.actionType_]);
-				seq_printf(s, "\tDMAC: %x:%x:%x:%x:%x:%x  DMACM: %x:%x:%x:%x:%x:%x\n", 
-						asic_acl.dstFilterMac_.octet[0], asic_acl.dstFilterMac_.octet[1], asic_acl.dstFilterMac_.octet[2], 
+				seq_printf(s, "\tDMAC: %x:%x:%x:%x:%x:%x  DMACM: %x:%x:%x:%x:%x:%x\n",
+						asic_acl.dstFilterMac_.octet[0], asic_acl.dstFilterMac_.octet[1], asic_acl.dstFilterMac_.octet[2],
 						asic_acl.dstFilterMac_.octet[3], asic_acl.dstFilterMac_.octet[4], asic_acl.dstFilterMac_.octet[5],
 						asic_acl.dstFilterMacMask_.octet[0], asic_acl.dstFilterMacMask_.octet[1], asic_acl.dstFilterMacMask_.octet[2],
 						asic_acl.dstFilterMacMask_.octet[3], asic_acl.dstFilterMacMask_.octet[4], asic_acl.dstFilterMacMask_.octet[5]
 						);
 				seq_printf(s, "\tdvidx: %d   dvidxM: %x  ProtoType: %x   dportL: %d   dportU: %d\n",
-						asic_acl.dstFilterVlanIdx_, asic_acl.dstFilterVlanIdxMask_, 
-						(asic_acl.dstFilterIgnoreL3L4_==TRUE? 2: (asic_acl.dstFilterIgnoreL4_ == 1? 1: 0)), 
+						asic_acl.dstFilterVlanIdx_, asic_acl.dstFilterVlanIdxMask_,
+						(asic_acl.dstFilterIgnoreL3L4_==TRUE? 2: (asic_acl.dstFilterIgnoreL4_ == 1? 1: 0)),
 						asic_acl.dstFilterPortLowerBound_, asic_acl.dstFilterPortUpperBound_
 						);
 				seq_printf(s, "\tdipU: %d.%d.%d.%d   dipL: %d.%d.%d.%d\n", (asic_acl.dstFilterIpAddr_>>24),
@@ -2348,7 +2509,7 @@ again_forOutAcl:
 
 
 				/* Action type */
-		switch (asic_acl.actionType_) 
+		switch (asic_acl.actionType_)
 		{
 
 			case RTL865X_ACL_PERMIT:
@@ -2363,10 +2524,10 @@ again_forOutAcl:
 				seq_printf(s, "\tnetifIdx: %d   pppoeIdx: %d   l2Idx:%d  ", asic_acl.netifIdx_, asic_acl.pppoeIdx_, asic_acl.L2Idx_);
 				break;
 
-			case RTL865X_ACL_PRIORITY: 
+			case RTL865X_ACL_PRIORITY:
 				seq_printf(s, "\tprioirty: %d   ", asic_acl.priority_) ;
 				break;
-				
+
 			case RTL865X_ACL_DEFAULT_REDIRECT:
 				seq_printf(s,"\tnextHop:%d  ", asic_acl.nexthopIdx_);
 				break;
@@ -2377,15 +2538,15 @@ again_forOutAcl:
 			case RTL865X_ACL_LOG_RATE_EXCEED_BPS:
 				seq_printf(s, "\tratelimitIdx: %d  ", asic_acl.ratelimtIdx_);
 				break;
-			default: 
+			default:
 				;
-			
+
 			}
 			seq_printf(s, "pktOpApp: %d\n", asic_acl.pktOpApp_);
-			
+
 		}
 
-		if (outRule == FALSE) 
+		if (outRule == FALSE)
 		{
 			acl_start = defOutAclStart; acl_end = defOutAclEnd;
 			outRule = TRUE;
@@ -2468,7 +2629,7 @@ struct file_operations qosRule_single_seq_file_operations = {
 
 static int32 hs_read( char *page, char **start, off_t off, int count, int *eof, void *data )
 {
-	int	len;	
+	int	len;
 	hsb_param_t *hsb_r, dummy_hsb_r;
 	hsa_param_t *hsa_r, dummy_hsa_r;
 	ipaddr_t addr;
@@ -2479,48 +2640,48 @@ static int32 hs_read( char *page, char **start, off_t off, int count, int *eof,
 	hsa_r = &dummy_hsa_r;
 	memset((void*)hsb_r,0,sizeof(hsb_r));
 	memset((void*)hsa_r,0,sizeof(hsa_r));
-	
+
 	virtualMacGetHsb( hsb_r );
 	{
 		len += sprintf(page+len,"HSB(");
 		len += sprintf(page+len,"\ttype:%d",hsb_r->type);
-		
+
 		len += sprintf(page+len,"\tspa:%d",hsb_r->spa);
 		len += sprintf(page+len,"\tlen:%d",hsb_r->len);
 		len += sprintf(page+len,"\tvid :%d\n",hsb_r->vid);
 		len += sprintf(page+len,"\tpppoe:%d",hsb_r->pppoeif);
-		
+
 		/* Protocol contents */
 		len += sprintf(page+len,"\ttagif:%d\tpppoeId:%d",hsb_r->tagif,hsb_r->pppoeid);
 		len += sprintf(page+len,"\tethrtype:0x%04x\n",hsb_r->ethtype);
 		len += sprintf(page+len,"\tllc_other:%d\tsnap:%d\n",hsb_r->llcothr,hsb_r->snap);
 		len += sprintf(page+len,"\tda:%02x-%02x-%02x-%02x-%02x-%02x",hsb_r->da[0],hsb_r->da[1],hsb_r->da[2],hsb_r->da[3],hsb_r->da[4],hsb_r->da[5]);
 		len += sprintf(page+len,"\tsa:%02x-%02x-%02x-%02x-%02x-%02x\n",hsb_r->sa[0],hsb_r->sa[1],hsb_r->sa[2],hsb_r->sa[3],hsb_r->sa[4],hsb_r->sa[5]);
-		
+
 		addr = ntohl( hsb_r->sip);
 		inet_ntoa_r(addr, addr_s);
 		len += sprintf(page+len,"\tsip:%s(hex:%08x)   ",addr_s,hsb_r->sip);
 		len += sprintf(page+len,"\tsprt:%d (hex:%x)\n ",(int)hsb_r->sprt,hsb_r->sprt);
 		addr  = ntohl(hsb_r->dip);
 		inet_ntoa_r(addr, addr_s);
-		len += sprintf(page+len,"\tdip:%s(hex:%08x) ",addr_s,hsb_r->dip);;		
+		len += sprintf(page+len,"\tdip:%s(hex:%08x) ",addr_s,hsb_r->dip);;
 		len += sprintf(page+len,"\tdprt:%d(hex:%08x)\n",hsb_r->dprt,hsb_r->dprt);
-		
+
 		len += sprintf(page+len,"\tipptl:%d,",(int)hsb_r->ipptl);
 		len += sprintf(page+len,"\tipflg:%d,",hsb_r->ipfg);
 		len += sprintf(page+len,"\tiptos:%d,",hsb_r->iptos);
 		len += sprintf(page+len,"\ttcpflg:%d\n",hsb_r->tcpfg);
-		
+
 		len += sprintf(page+len,"\tdirtx:%d,",hsb_r->dirtx);
 		len += sprintf(page+len,"\tprtnmat:%d",hsb_r->patmatch);
-	       
+
 		len += sprintf(page+len,"\tudp_nocs:%d",hsb_r->udpnocs);
 		len += sprintf(page+len,"\tttlst:0x%x\n",hsb_r->ttlst);
 
-		
+
 		len += sprintf(page+len,"\thp:%d",hsb_r->hiprior);
 		len += sprintf(page+len,"\tl3csok:%d\tl4csok:%d\tipfragif:%d\n",hsb_r->l3csok,hsb_r->l4csok,hsb_r->ipfo0_n);
-		
+
 	 	len += sprintf(page+len,"\textspa:%d",hsb_r->extspa);
 		len += sprintf(page+len,"\turlmch:%d\n)\n",hsb_r->urlmch);
 	}
@@ -2532,7 +2693,7 @@ static int32 hs_read( char *page, char **start, off_t off, int count, int *eof,
 
 		addr =ntohl( hsa_r->trip);
 		inet_ntoa_r(addr, addr_s);
-		len += sprintf(page+len,"\ttrip:%s(hex:%08x)",addr_s,hsa_r->trip);	
+		len += sprintf(page+len,"\ttrip:%s(hex:%08x)",addr_s,hsa_r->trip);
 		len += sprintf(page+len,"\tprt:%d\tipmcast:%d\n",hsa_r->port,hsa_r->ipmcastr);
 		len += sprintf(page+len,"\tl3cs:%d",hsa_r->l3csdt);
 		len += sprintf(page+len,"\tl4cs:%d",hsa_r->l4csdt);
@@ -2566,7 +2727,7 @@ static int32 hs_read( char *page, char **start, off_t off, int count, int *eof,
 		len += sprintf(page+len,"\tdpext:0x%x\thwfwrd:%d\n",hsa_r->dpext,hsa_r->hwfwrd);
 		len += sprintf(page+len,"\tspcp:%d",hsa_r->spcp);
 		len += sprintf(page+len,"\tpriority:%d",hsa_r->priority);
-		
+
 		len += sprintf(page+len,"\tdp:0x%x\n",hsa_r->dp);
 		len += sprintf(page+len,")\n");
 	}
@@ -2694,102 +2855,87 @@ static int32 pvid_read( char *page, char **start, off_t off, int count, int *eof
 
 static int32 pvid_write( struct file *filp, const char *buff,unsigned long len, void *data )
 {
-	return SUCCESS;
-}
+	char		tmpbuf[256];	
+	char		*strptr;
+	char		*tokptr;
+	uint32		port=0;
+	uint32		pvid=0;
+	if (buff && !copy_from_user(tmpbuf, buff, len))
+	{
+		strptr = tmpbuf;
 
-static int32 mirrorPort_read( char *page, char **start, off_t off, int count, int *eof, void *data )
-{
-	uint32 mirrorRx, mirrorTx, mirrorPort;
-	int	len;
+		tokptr = strsep(&strptr," ");
+		if (tokptr==NULL)
+		{
+			goto errout;
+		}
 
-	len = 0;
-	rtl8651_getAsicPortMirror(&mirrorRx, &mirrorTx, &mirrorPort);
-	len += sprintf(page+len,">>Mirror Control Register:\n\n");
-	len += sprintf(page+len,"  Mirror Rx: 0x%x\n", mirrorRx);
-	len += sprintf(page+len,"  Mirror Tx: 0x%x\n", mirrorTx);
-	len += sprintf(page+len,"  Mirror Port: 0x%x\n", mirrorPort);
+		port=simple_strtol(tokptr, NULL, 0);
 
-	if (len <= off+count) *eof = 1;
-	*start = page + off;
-	len -= off;
-	if (len>count)
-		len = count;
-	if (len<0)
-	  	len = 0;
+		if(port>(RTL8651_PORT_NUMBER+rtl8651_totalExtPortNum))
+		{
+			goto errout;
+		}
 
-	return len;
-}
-
-static int32 mirrorPort_write( struct file *filp, const char *buff,unsigned long len, void *data )
-{
-	char		tmpbuf[64];
-	//uint32	*mem_addr, mem_data, mem_len;
-	uint32	rx_mask,tx_mask,port_mask;
-	char		*strptr, *cmd_addr;
-	char		*tokptr;
-
-	if (buff && !copy_from_user(tmpbuf, buff, len)) {
-		tmpbuf[len] = '\0';
-		strptr=tmpbuf;
-		cmd_addr = strsep(&strptr," ");
-		if (cmd_addr==NULL)
-		{
-			goto errout;
-		}
-		printk("cmd %s\n", cmd_addr);
 		tokptr = strsep(&strptr," ");
 		if (tokptr==NULL)
 		{
 			goto errout;
 		}
 
-		if (!memcmp(cmd_addr, "mirror", 6))
-		{
-			rx_mask=simple_strtol(tokptr, NULL, 0);
+		pvid=simple_strtol(tokptr, NULL, 0);
 
-			tokptr = strsep(&strptr," ");
-			if (tokptr==NULL)
-			{
-				goto errout;
-			}
-			tx_mask = simple_strtol(tokptr,NULL,0);
-			
-			tokptr = strsep(&strptr," ");
-			if (tokptr==NULL)
-			{
-				goto errout;
-			}
-			port_mask = simple_strtol(tokptr, NULL, 0);
-			printk("mirror rx port mask(0x%x) tx port mask(0x%x), mirror port mask(0x%x)\n",rx_mask,tx_mask,port_mask);
-			rtl8651_setAsicPortMirror(rx_mask,tx_mask,port_mask);
-		}		
-		else
+		if(pvid>4096)
 		{
 			goto errout;
 		}
-	}
-	else
-	{
-errout:
-		printk("Mirror port configuration only support \"mirror\"as the first parameter\n");		
-		printk("mirror: \"mirror rx_portmask tx_portmask mirror_portmask\"\n");
+
+		rtl8651_setAsicPvid( port,	pvid);
+
+		return len;
+		errout:
+		rtlglue_printf("wrong format\n");
+
 	}
 
 	return len;
 }
 
 
-static int32 proc_mem_read( char *page, char **start, off_t off, int count, int *eof, void *data )
+static int32 mirrorPort_read( char *page, char **start, off_t off, int count, int *eof, void *data )
 {
-	return PROC_READ_RETURN_VALUE;
+	uint32 mirrorRx, mirrorTx, mirrorPort;
+	int	len;
+
+	len = 0;
+	rtl8651_getAsicPortMirror(&mirrorRx, &mirrorTx, &mirrorPort);
+	len += sprintf(page+len,">>Mirror Control Register:\n\n");
+	len += sprintf(page+len,"  Mirror Rx: 0x%x\n", mirrorRx);
+	len += sprintf(page+len,"  Mirror Tx: 0x%x\n", mirrorTx);
+	len += sprintf(page+len,"  Mirror Port: 0x%x\n", mirrorPort);
+
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count)
+		len = count;
+	if (len<0)
+	  	len = 0;
+
+	return len;
 }
 
-static int32 proc_mem_write( struct file *filp, const char *buff,unsigned long len, void *data )
+static int32 mirrorPort_write( struct file *filp, const char *buff,unsigned long len, void *data )
 {
-	char 		tmpbuf[64];
-	uint32	*mem_addr, mem_data, mem_len;
+	char		tmpbuf[64];
+	//uint32	*mem_addr, mem_data, mem_len;
+	uint32	rx_mask,tx_mask,port_mask;
 	char		*strptr, *cmd_addr;
 	char		*tokptr;
+	if(len>64)
+	{
+		goto errout;
+	}
 
 	if (buff && !copy_from_user(tmpbuf, buff, len)) {
 		tmpbuf[len] = '\0';
@@ -2799,35 +2945,32 @@ static int32 proc_mem_write( struct file *filp, const char *buff,unsigned long l
 		{
 			goto errout;
 		}
-		printk("cmd %s\n", cmd_addr);
+		rtlglue_printf("cmd %s\n", cmd_addr);
 		tokptr = strsep(&strptr," ");
 		if (tokptr==NULL)
 		{
 			goto errout;
 		}
 
-		if (!memcmp(cmd_addr, "read", 4))
+		if (!memcmp(cmd_addr, "mirror", 6))
 		{
-			mem_addr=(uint32*)simple_strtol(tokptr, NULL, 0);
+			rx_mask=simple_strtol(tokptr, NULL, 0);
+
 			tokptr = strsep(&strptr," ");
 			if (tokptr==NULL)
 			{
 				goto errout;
 			}
-			mem_len=simple_strtol(tokptr, NULL, 0);
-			memDump(mem_addr, mem_len, "");
-		}
-		else if (!memcmp(cmd_addr, "write", 5))
-		{
-			mem_addr=(uint32*)simple_strtol(tokptr, NULL, 0);
+			tx_mask = simple_strtol(tokptr,NULL,0);
+
 			tokptr = strsep(&strptr," ");
 			if (tokptr==NULL)
 			{
 				goto errout;
 			}
-			mem_data=simple_strtol(tokptr, NULL, 0);
-			WRITE_MEM32(mem_addr, mem_data);
-			printk("Write memory 0x%p dat 0x%x: 0x%x\n", mem_addr, mem_data, READ_MEM32(mem_addr));
+			port_mask = simple_strtol(tokptr, NULL, 0);
+			rtlglue_printf("mirror rx port mask(0x%x) tx port mask(0x%x), mirror port mask(0x%x)\n",rx_mask,tx_mask,port_mask);
+			rtl8651_setAsicPortMirror(rx_mask,tx_mask,port_mask);
 		}
 		else
 		{
@@ -2837,9 +2980,8 @@ static int32 proc_mem_write( struct file *filp, const char *buff,unsigned long l
 	else
 	{
 errout:
-		printk("Memory operation only support \"read\" and \"write\" as the first parameter\n");
-		printk("Read format:	\"read mem_addr length\"\n");
-		printk("Write format:	\"write mem_addr mem_data\"\n");
+		rtlglue_printf("Mirror port configuration only support \"mirror\"as the first parameter\n");
+		rtlglue_printf("mirror: \"mirror rx_portmask tx_portmask mirror_portmask\"\n");
 	}
 
 	return len;
@@ -2851,7 +2993,7 @@ static int32 l2_read( char *page, char **start, off_t off, int count, int *eof,
 	int len;
 	rtl865x_tblAsicDrv_l2Param_t asic_l2;
  	uint32 row, col, port, m=0;
-	
+
 	len = sprintf(page, "%s\n", "ASIC L2 Table:");
 	for(row=0x0; row<RTL8651_L2TBL_ROW; row++)
 	{
@@ -2862,14 +3004,14 @@ static int32 l2_read( char *page, char **start, off_t off, int count, int *eof,
 			{
 				continue;
 			}
-			
+
 			if (asic_l2.isStatic && asic_l2.ageSec==0 && asic_l2.cpu && asic_l2.memberPortMask == 0 &&asic_l2.auth==0)
 			{
 				continue;
 			}
 
-			len += sprintf(page + len, "%4d.[%3d,%d] %02x:%02x:%02x:%02x:%02x:%02x FID:%x mbr(",m, row, col, 
-					asic_l2.macAddr.octet[0], asic_l2.macAddr.octet[1], asic_l2.macAddr.octet[2], 
+			len += sprintf(page + len, "%4d.[%3d,%d] %02x:%02x:%02x:%02x:%02x:%02x FID:%x mbr(",m, row, col,
+					asic_l2.macAddr.octet[0], asic_l2.macAddr.octet[1], asic_l2.macAddr.octet[2],
 					asic_l2.macAddr.octet[3], asic_l2.macAddr.octet[4], asic_l2.macAddr.octet[5],asic_l2.fid
 			);
 
@@ -2894,7 +3036,7 @@ static int32 l2_read( char *page, char **start, off_t off, int count, int *eof,
 			{
 				len += sprintf(page + len,"AUTH:0");
 			}
-			
+
 			len += sprintf(page + len,"\n");
 		}
 	}
@@ -2916,62 +3058,62 @@ static int32 rtl865x_proc_hw_mcast_read( char *page, char **start, off_t off, in
 	int len=0;
 	rtl865x_tblAsicDrv_multiCastParam_t asic;
 	uint32 entry;
-	
+
 	#if 1
-	printk("%s\n", "ASIC Multicast Table:");
-	for(entry=0; entry<RTL8651_MULTICASTTBL_SIZE; entry++) 
+	rtlglue_printf("%s\n", "ASIC Multicast Table:");
+	for(entry=0; entry<RTL8651_MULTICASTTBL_SIZE; entry++)
 	{
 			if (rtl8651_getAsicIpMulticastTable(entry, &asic) != SUCCESS) {
-				printk("\t[%d]  (INVALID)dip(%d.%d.%d.%d) sip(%d.%d.%d.%d) mbr(0x%x)\n", entry,
-					asic.dip>>24, (asic.dip&0x00ff0000)>>16, (asic.dip&0x0000ff00)>>8, (asic.dip&0xff), 
+				rtlglue_printf("\t[%d]  (INVALID)dip(%d.%d.%d.%d) sip(%d.%d.%d.%d) mbr(0x%x)\n", entry,
+					asic.dip>>24, (asic.dip&0x00ff0000)>>16, (asic.dip&0x0000ff00)>>8, (asic.dip&0xff),
 					asic.sip>>24, (asic.sip&0x00ff0000)>>16, (asic.sip&0x0000ff00)>>8, (asic.sip&0xff),
 					asic.mbr);
-				printk("\t       svid:%d, spa:%d, extIP:%d, age:%d, cpu:%d\n", asic.svid, asic.port, asic.extIdx,
+				rtlglue_printf("\t       svid:%d, spa:%d, extIP:%d, age:%d, cpu:%d\n", asic.svid, asic.port, asic.extIdx,
 					asic.age, asic.cpu);
 				continue;
 			}
 			else
 			{
-				printk("\t[%d]  (OK)dip(%d.%d.%d.%d) sip(%d.%d.%d.%d) mbr(0x%x)\n", entry,
-				asic.dip>>24, (asic.dip&0x00ff0000)>>16, (asic.dip&0x0000ff00)>>8, (asic.dip&0xff), 
+				rtlglue_printf("\t[%d]  (OK)dip(%d.%d.%d.%d) sip(%d.%d.%d.%d) mbr(0x%x)\n", entry,
+				asic.dip>>24, (asic.dip&0x00ff0000)>>16, (asic.dip&0x0000ff00)>>8, (asic.dip&0xff),
 				asic.sip>>24, (asic.sip&0x00ff0000)>>16, (asic.sip&0x0000ff00)>>8, (asic.sip&0xff),
 				asic.mbr);
-				printk("\t       svid:%d, spa:%d, extIP:%d, age:%d, cpu:%d\n", asic.svid, asic.port, asic.extIdx,
+				rtlglue_printf("\t       svid:%d, spa:%d, extIP:%d, age:%d, cpu:%d\n", asic.svid, asic.port, asic.extIdx,
 				asic.age, asic.cpu);
 			}
 	}
-	printk("\n\t TotalOpCnt:AddMcastOpCnt:%d\tDelMcastOpCnt:%d\tForceAddMcastOpCnt:%d\t \n", _rtl865x_getAddMcastOpCnt(),_rtl865x_getDelMcastOpCnt(),_rtl865x_getForceAddMcastOpCnt());
+	rtlglue_printf("\n\t TotalOpCnt:AddMcastOpCnt:%d\tDelMcastOpCnt:%d\tForceAddMcastOpCnt:%d\t \n", _rtl865x_getAddMcastOpCnt(),_rtl865x_getDelMcastOpCnt(),_rtl865x_getForceAddMcastOpCnt());
 	#else
 	len = sprintf(page, "%s\n", "ASIC Multicast Table:");
 
-	for(entry=0; entry<RTL8651_MULTICASTTBL_SIZE; entry++) 
+	for(entry=0; entry<RTL8651_MULTICASTTBL_SIZE; entry++)
 	{
 			if (rtl8651_getAsicIpMulticastTable(entry, &asic) != SUCCESS) {
 				len +=sprintf(page+len,"\t[%d]  (Invalid Entry)\n", entry);
 				continue;
 			}
 			len += sprintf(page+len, "\t[%d]  dip(%d.%d.%d.%d) sip(%d.%d.%d.%d) mbr(%x)\n", entry,
-				asic.dip>>24, (asic.dip&0x00ff0000)>>16, (asic.dip&0x0000ff00)>>8, (asic.dip&0xff), 
+				asic.dip>>24, (asic.dip&0x00ff0000)>>16, (asic.dip&0x0000ff00)>>8, (asic.dip&0xff),
 				asic.sip>>24, (asic.sip&0x00ff0000)>>16, (asic.sip&0x0000ff00)>>8, (asic.sip&0xff),
 				asic.mbr);
 			len +=sprintf(page+len,"\t       svid:%d, spa:%d, extIP:%d, age:%d, cpu:%d\n", asic.svid, asic.port, asic.extIdx,
 				asic.age, asic.cpu);
 	}
 	#endif
-	
-	if (len <= off+count) 
+
+	if (len <= off+count)
 	{
 		*eof = 1;
 	}
-	
+
 	*start = page + off;
 	len -= off;
-	
+
 	if (len>count)
 	{
 		len = count;
 	}
-	
+
 	if (len<0)
 	{
 	  	len = 0;
@@ -2986,19 +3128,23 @@ static int32 rtl865x_proc_hw_mcast_write( struct file *filp, const char *buff,un
 	char		*strptr;
 	char		*tokptr;
 	char		*dotPtr;
-	rtl865xc_tblAsic_ipMulticastTable_t entry;		
+	rtl865xc_tblAsic_ipMulticastTable_t entry;
 	int16 age;
 	uint32 idx;
 	uint32 sip,dip;
 	uint32 srcPort,svid,mbr;
 	int32	i;
 
-	
+	if(len>512)
+	{
+		goto errout;
+	}
+
 	if (buff && !copy_from_user(tmpbuf, buff, len))
 	{
 		bzero(&entry, sizeof(entry));
 		tmpbuf[len] = '\0';
-		
+
 		strptr=tmpbuf;
 
 		/*valid*/
@@ -3008,7 +3154,7 @@ static int32 rtl865x_proc_hw_mcast_write( struct file *filp, const char *buff,un
 			goto errout;
 		}
 		entry.valid = simple_strtol(tokptr, NULL, 0);
-		
+
 		/*destination ip*/
 		tokptr = strsep(&strptr," ");
 		if (tokptr==NULL)
@@ -3026,17 +3172,17 @@ static int32 rtl865x_proc_hw_mcast_write( struct file *filp, const char *buff,un
 			}
 			dip=(dip<<8)|simple_strtol(dotPtr, NULL, 0);
 		}
-		
+
 		entry.destIPAddrLsbs= dip & 0xfffffff;
-		
-		
+
+
 		/*source ip*/
 		tokptr = strsep(&strptr," ");
 		if (tokptr==NULL)
 		{
 			goto errout;
 		}
-		
+
 		sip=0;
 		for(i=0;i<4;i++)
 		{
@@ -3047,10 +3193,10 @@ static int32 rtl865x_proc_hw_mcast_write( struct file *filp, const char *buff,un
 			}
 			sip=(sip<<8)|simple_strtol(dotPtr, NULL, 0);
 		}
-		
+
 		entry.srcIPAddr=sip;
-		
-		
+
+
 		/*mbr*/
 		tokptr = strsep(&strptr," ");
 		if (tokptr==NULL)
@@ -3059,7 +3205,7 @@ static int32 rtl865x_proc_hw_mcast_write( struct file *filp, const char *buff,un
 		}
 		mbr= simple_strtol(tokptr, NULL, 0);
 		entry.portList 			= mbr & (RTL8651_PHYSICALPORTMASK);
-#if defined (CONFIG_RTL8196C_REVISION_B) || defined (CONFIG_RTL8198_REVISION_B) 
+#if defined (CONFIG_RTL8196C_REVISION_B) || defined (CONFIG_RTL8198_REVISION_B) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 #else
 		entry.extPortList 		= mbr >> RTL8651_PORT_NUMBER;
 #endif
@@ -3071,7 +3217,7 @@ static int32 rtl865x_proc_hw_mcast_write( struct file *filp, const char *buff,un
 			goto errout;
 		}
 		svid= simple_strtol(tokptr, NULL, 0);
-#if defined (CONFIG_RTL8196C_REVISION_B) || defined (CONFIG_RTL8198_REVISION_B) 
+#if defined (CONFIG_RTL8196C_REVISION_B) || defined (CONFIG_RTL8198_REVISION_B) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 #else
 		entry.srcVidH 			= ((svid)>>4) &0xff;
 		entry.srcVidL 			= (svid)&0xf;
@@ -3082,19 +3228,19 @@ static int32 rtl865x_proc_hw_mcast_write( struct file *filp, const char *buff,un
 		if (tokptr==NULL)
 		{
 			goto errout;
-		}		
+		}
 		srcPort= simple_strtol(tokptr, NULL, 0);
-#if defined (CONFIG_RTL8196C_REVISION_B) || defined (CONFIG_RTL8198_REVISION_B) 
+#if defined (CONFIG_RTL8196C_REVISION_B) || defined (CONFIG_RTL8198_REVISION_B) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 #else
 
-		if (srcPort>= RTL8651_PORT_NUMBER) 
+		if (srcPort>= RTL8651_PORT_NUMBER)
 		{
 
 			/* extension port */
 			entry.srcPortExt = 1;
 			entry.srcPort 			= (srcPort-RTL8651_PORT_NUMBER);
 		}
-		else 
+		else
 		{
 			entry.srcPortExt = 0;
 			entry.srcPort 			= srcPort;
@@ -3107,7 +3253,7 @@ static int32 rtl865x_proc_hw_mcast_write( struct file *filp, const char *buff,un
 			goto errout;
 		}
 		entry.extIPIndex = simple_strtol(tokptr, NULL, 0);
-		
+
 		/*age*/
 		tokptr = strsep(&strptr," ");
 		if (tokptr==NULL)
@@ -3115,8 +3261,8 @@ static int32 rtl865x_proc_hw_mcast_write( struct file *filp, const char *buff,un
 			goto errout;
 		}
 		age=simple_strtol(tokptr, NULL, 0);
-	
-		
+
+
 		entry.ageTime			= 0;
 		while ( age > 0 )
 		{
@@ -3135,13 +3281,13 @@ static int32 rtl865x_proc_hw_mcast_write( struct file *filp, const char *buff,un
 
 		idx = rtl8651_ipMulticastTableIndex(sip,dip);
 		_rtl8651_forceAddAsicEntry(TYPE_MULTICAST_TABLE, idx, &entry);
-			
-			
+
+
 	}
 	else
 	{
 errout:
-		printk("error input\n");
+		rtlglue_printf("error input\n");
 	}
 
 	return len;
@@ -3150,15 +3296,15 @@ errout:
 static int32 rtl865x_proc_sw_mcast_read( char *page, char **start, off_t off, int count, int *eof, void *data )
 {
 	int len=0;
-		
+
 	rtl_dumpSwMulticastInfo();
-	
+
 	return len;
 }
 
 static int32 rtl865x_proc_sw_mcast_write( struct file *filp, const char *buff,unsigned long len, void *data )
 {
-	
+
 	return len;
 }
 #endif
@@ -3170,18 +3316,18 @@ static int32 arp_read( char *page, char **start, off_t off, int count, int *eof,
 	rtl865x_tblAsicDrv_routingParam_t asic_l3;
 	rtl865x_tblAsicDrv_arpParam_t asic_arp;
 	rtl865x_tblAsicDrv_l2Param_t asic_l2;
-	
+
 	uint32	i, j, port;
 	ipaddr_t ipAddr;
 	int8 ipBuf[sizeof"255.255.255.255"];
 
-		
+
 	len = sprintf(page, "%s\n", "ASIC Arp Table:\n");
-	for(i=0; i<RTL8651_ARPTBL_SIZE; i++) 
+	for(i=0; i<RTL8651_ARPTBL_SIZE; i++)
 	{
 		if (rtl8651_getAsicArp(i,  &asic_arp) == FAILED)
 			continue;
-		for(j=0; j<RTL8651_ROUTINGTBL_SIZE; j++) 
+		for(j=0; j<RTL8651_ROUTINGTBL_SIZE; j++)
 		{
 			if (rtl8651_getAsicRouting(j, &asic_l3) == FAILED || asic_l3.process!= 0x02 /*RT_ARP*/)
 				continue;
@@ -3193,7 +3339,7 @@ static int32 arp_read( char *page, char **start, off_t off, int count, int *eof,
 					inet_ntoa_r(ipAddr, ipBuf);
 					len += sprintf(page + len,"%-16s [%3d,%d] ", ipBuf, asic_arp.nextHopRow, asic_arp.nextHopColumn);
 				}
-				else 
+				else
 				{
 					inet_ntoa_r(ipAddr, ipBuf);
 					len += sprintf(page + len,"%-16s %02x-%02x-%02x-%02x-%02x-%02x (", ipBuf, asic_l2.macAddr.octet[0], asic_l2.macAddr.octet[1], asic_l2.macAddr.octet[2], asic_l2.macAddr.octet[3], asic_l2.macAddr.octet[4], asic_l2.macAddr.octet[5]);
@@ -3202,7 +3348,7 @@ static int32 arp_read( char *page, char **start, off_t off, int count, int *eof,
 							len += sprintf(page + len,"%d ", port);
 						else
 							len += sprintf(page + len,"  ");
-					}							
+					}
 					len += sprintf(page + len,") %us", asic_l2.ageSec);
 				}
 				continue;
@@ -3213,7 +3359,7 @@ static int32 arp_read( char *page, char **start, off_t off, int count, int *eof,
 
 	}
 
-	return len;		
+	return len;
 }
 
 static int32 arp_write( struct file *filp, const char *buff,unsigned long len, void *data )
@@ -3223,7 +3369,7 @@ static int32 arp_write( struct file *filp, const char *buff,unsigned long len, v
 
 static int32 nexthop_read( char *page, char **start, off_t off, int count, int *eof, void *data )
 {
-	int len;	
+	int len;
 	rtl865x_tblAsicDrv_nextHopParam_t asic_nxthop;
 
 	uint32 idx, refcnt, rt_flag;
@@ -3234,7 +3380,7 @@ static int32 nexthop_read( char *page, char **start, off_t off, int count, int *
 		if (rtl8651_getAsicNextHopTable(idx, &asic_nxthop) == FAILED)
 			continue;
 		len += sprintf(page + len,"  [%d]  type(%s) IPIdx(%d) dstVid(%d) pppoeIdx(%d) nextHop(%d) rf(%d) rt(%d)\n", idx,
-			(asic_nxthop.isPppoe==TRUE? "pppoe": "ethernet"), asic_nxthop.extIntIpIdx, 
+			(asic_nxthop.isPppoe==TRUE? "pppoe": "ethernet"), asic_nxthop.extIntIpIdx,
 			asic_nxthop.dvid, asic_nxthop.pppoeIdx, (asic_nxthop.nextHopRow<<2)+asic_nxthop.nextHopColumn, refcnt, rt_flag);
 	}
 
@@ -3248,7 +3394,7 @@ static int32 nexthop_write( struct file *filp, const char *buff,unsigned long le
 
 static int32 l3_read( char *page, char **start, off_t off, int count, int *eof, void *data )
 {
-	int len;	
+	int len;
 	rtl865x_tblAsicDrv_routingParam_t asic_l3;
 	int8 *str[] = { "PPPoE", "L2", "ARP", " ", "CPU", "NxtHop", "DROP", " " };
 	int8 *strNetType[] = { "WAN", "DMZ", "LAN",  "RLAN"};
@@ -3269,15 +3415,15 @@ static int32 l3_read( char *page, char **start, off_t off, int count, int *eof,
 				mask--;
 		netIdx = asic_l3.internal<<1|asic_l3.DMZFlag;
 		len += sprintf(page + len,"\t[%d]  %d.%d.%d.%d/%d process(%s) %s \n", idx, (asic_l3.ipAddr>>24),
-			((asic_l3.ipAddr&0x00ff0000)>>16), ((asic_l3.ipAddr&0x0000ff00)>>8), (asic_l3.ipAddr&0xff), 
+			((asic_l3.ipAddr&0x00ff0000)>>16), ((asic_l3.ipAddr&0x0000ff00)>>8), (asic_l3.ipAddr&0xff),
 			mask, str[asic_l3.process],strNetType[netIdx]);
-		
-		switch(asic_l3.process) 
+
+		switch(asic_l3.process)
 		{
 		case 0x00:	/* PPPoE */
 			len += sprintf(page + len,"\t           dvidx(%d)  pppidx(%d) nxthop(%d)\n", asic_l3.vidx, asic_l3.pppoeIdx, (asic_l3.nextHopRow<<2)+asic_l3.nextHopColumn);
 			break;
-			
+
 		case 0x01:	/* L2 */
 			len += sprintf(page + len,"              dvidx(%d) nexthop(%d)\n", asic_l3.vidx, (asic_l3.nextHopRow<<2)+asic_l3.nextHopColumn);
 			break;
@@ -3304,7 +3450,7 @@ static int32 l3_read( char *page, char **start, off_t off, int count, int *eof,
 
 		case 0x07:	/* Reserved */
 			/* pass through */
-		default: 
+		default:
 		;
 		}
 	}
@@ -3336,7 +3482,7 @@ static int32 ip_read( char *page, char **start, off_t off, int count, int *eof,
 			continue;
 		}
 		inet_ntoa_r(asic_ip.intIpAddr, intIpBuf);
-		inet_ntoa_r(asic_ip.extIpAddr,extIpBuf);			
+		inet_ntoa_r(asic_ip.extIpAddr,extIpBuf);
 		len += sprintf(page + len,"  [%d] intip(%-14s) extip(%-14s) type(%s) nhIdx(%d)\n",
 					i, intIpBuf,extIpBuf,
 					(asic_ip.localPublic==TRUE? "LP" : (asic_ip.nat==TRUE ? "NAT" : "NAPT")), asic_ip.nhIndex);
@@ -3352,12 +3498,12 @@ static int32 ip_write( struct file *filp, const char *buff,unsigned long len, vo
 
 static int32 pppoe_read( char *page, char **start, off_t off, int count, int *eof, void *data )
 {
-	int len;	
+	int len;
 	rtl865x_tblAsicDrv_pppoeParam_t asic_pppoe;
 	int32	i;
 
 	len = sprintf(page, "%s\n", "ASIC PPPOE Table:\n");
-	for(i=0; i<RTL8651_PPPOETBL_SIZE; i++) 
+	for(i=0; i<RTL8651_PPPOETBL_SIZE; i++)
 	{
 		if (rtl8651_getAsicPppoe(i,  &asic_pppoe) == FAILED)
 			continue;
@@ -3376,7 +3522,7 @@ static int32 pppoe_write( struct file *filp, const char *buff,unsigned long len,
 #if defined(CONFIG_RTL_LAYERED_DRIVER_L4) && defined(CONFIG_RTL_8198)
 int32 napt_show(struct seq_file *s, void *v)
 {
-	int len;	
+	int len;
 	rtl865x_tblAsicDrv_naptTcpUdpParam_t asic_tcpudp;
 	uint32 idx, entry=0;
 
@@ -3391,18 +3537,18 @@ int32 napt_show(struct seq_file *s, void *v)
 			       idx,
 			       asic_tcpudp.insideLocalIpAddr>>24, (asic_tcpudp.insideLocalIpAddr&0x00ff0000) >> 16,
 			       (asic_tcpudp.insideLocalIpAddr&0x0000ff00)>>8, asic_tcpudp.insideLocalIpAddr&0x000000ff,
-			       asic_tcpudp.insideLocalPort, 
+			       asic_tcpudp.insideLocalPort,
 			       asic_tcpudp.isValid, asic_tcpudp.isDedicated,
 			       asic_tcpudp.isCollision, asic_tcpudp.isCollision2, asic_tcpudp.isStatic, asic_tcpudp.isTcp );
 
 			len += seq_printf(s, "   age(%d) offset(%d) tcpflag(%d) SelEIdx(%d) SelIPIdx(%d) priValid:%d pri(%d)\n",
-			        asic_tcpudp.ageSec, asic_tcpudp.offset<<10, asic_tcpudp.tcpFlag, 
+			        asic_tcpudp.ageSec, asic_tcpudp.offset<<10, asic_tcpudp.tcpFlag,
 			        asic_tcpudp.selEIdx, asic_tcpudp.selExtIPIdx,asic_tcpudp.priValid,asic_tcpudp.priority );
 			entry++;
 		}
 	}
-	len += seq_printf(s, "Total entry: %d\n", entry);	
-	
+	len += seq_printf(s, "Total entry: %d\n", entry);
+
 	return 0;
 }
 
@@ -3443,89 +3589,13 @@ struct file_operations sw_napt_single_seq_file_operations = {
 };
 #endif
 
-
-static int32 diagnostic_read( char *page, char **start, off_t off, int count, int *eof, void *data )
-{
-	int		len;
-	uint32	regData, regData1;
-	int		port, regIdx;
-	uint32	mask, offset;
-
-	len = sprintf(page, "Diagnostic Register Info:\n");
-
-	regData = READ_MEM32(GDSR0);
-	len += sprintf(page + len, "MaxUsedDescriptor: %d CurUsed Descriptor: %d\n", 
-		(regData&MaxUsedDsc_MASK)>>MaxUsedDsc_OFFSET, 
-		(regData&USEDDSC_MASK)>>USEDDSC_OFFSET);
-	len += sprintf(page+len, "DescRunOut: %s TotalDescFC: %s ShareBufFC: %s\n", 
-		(regData&DSCRUNOUT)?"YES":"NO", (regData&TotalDscFctrl_Flag)?"YES":"NO", (regData&SharedBufFCON_Flag)?"YES":"NO");
-
-	for(regIdx = 0; regIdx<2; regIdx++)
-	{
-		regData = READ_MEM32(PCSR0+(regIdx<<2));
-
-		for(port=0; port<4; port++)
-		{
-			switch(port)
-			{
-				case 0:
-					mask = P0OQCgst_MASK;
-					offset = P0OQCgst_OFFSET;
-					break;
-				case 1:
-					mask = P1OQCgst_MASK;
-					offset = P1OQCgst_OFFSET;
-					break;
-				case 2:
-					mask = P2OQCgst_MASK;
-					offset = P2OQCgst_OFFSET;
-					break;
-				default:
-					mask = P3OQCgst_MASK;
-					offset = P3OQCgst_OFFSET;
-					break;
-			}
-			regData1 = (regData&mask)>>offset;
-			if (regData1==0)
-				len += sprintf(page+len, "Port%d not congestion\n", port+(regIdx<<2));
-			else
-			{
-				len += sprintf(page+len, "Port%d queue congestion mask 0x%x\n", port+(regIdx<<2), regData1);
-			}
-		}
-	}
-	
-	for(port=0;port<=CPU;port++)
-	{
-		len += sprintf(page+len, "Port%d each queue used descriptor: Queue[0~5]: [ ", port);
-		for(regIdx=0; regIdx<3; regIdx++)
-		{
-			regData = READ_MEM32(P0_DCR0+(port<<4)+(regIdx<<2));
-			len += sprintf(page+len, "%d %d ", 
-				((regData&Pn_EQDSCR_MASK)>>Pn_EVEN_OQDSCR_OFFSET), 
-				((regData&Pn_OQDSCR_MASK)>>Pn_ODD_OQDSCR_OFFSET));
-		}
-
-		regData = READ_MEM32(P0_DCR3+(port<<4));
-		len += sprintf(page+len, "]  Input queue [%d]\n", 
-				((regData&Pn_EQDSCR_MASK)>>Pn_EVEN_OQDSCR_OFFSET));
-	}
-	
-	return len;
-}
-
-static int32 diagnostic_write( struct file *filp, const char *buff,unsigned long len, void *data )
-{
-	return len;
-}
-
 static int32 port_bandwidth_read( char *page, char **start, off_t off, int count, int *eof, void *data )
 {
 	int		len;
 	uint32	regData;
 	uint32	data0, data1;
 	int		port;
-	
+
 	len = sprintf(page, "Dump Port Bandwidth Info:\n");
 
 	for(port=0;port<=CPU;port++)
@@ -3539,12 +3609,12 @@ static int32 port_bandwidth_read( char *page, char **start, off_t off, int count
 		{
 			data0 = (regData&IBWC_EVENPORT_MASK)>>IBWC_EVENPORT_OFFSET;
 		}
-		
+
 		regData = READ_MEM32(WFQRCRP0+((port*3)<<2));
 		data1 = (regData&APR_MASK)>>APR_OFFSET;
 
 		data0++;
-		
+
 		if (data0)
 		{
 			if (data0<64)
@@ -3560,7 +3630,7 @@ static int32 port_bandwidth_read( char *page, char **start, off_t off, int count
 		if(data1!=(APR_MASK>>APR_OFFSET))
 		{
 			data1++;
-			
+
 			if (data1<16)
 				len += sprintf(page+len, "Engress:[%dKbps]\n", (data1<<16)/1000);
 			else
@@ -3570,7 +3640,7 @@ static int32 port_bandwidth_read( char *page, char **start, off_t off, int count
 		else
 			len += sprintf(page+len, "Egress:FullSpeed\n");
 	}
-	
+
 	return len;
 }
 
@@ -3597,7 +3667,7 @@ static int32 queue_bandwidth_read( char *page, char **start, off_t off, int coun
 	{
 		if ((queue_bandwidth_record_portmask&(1<<port))==0)
 			continue;
-		
+
 		regData = READ_MEM32(QNUMCR);
 		data0 = (regData>>(port*3))&7;
 		len += sprintf(page+len, "Port%d Queue number:	%d\n", port, data0);
@@ -3615,7 +3685,7 @@ static int32 queue_bandwidth_read( char *page, char **start, off_t off, int coun
 			{
 				len += sprintf(page+len, "Type: WFQ [weight:%d]\n", data1+1);
 			}
-			
+
 			regData = READ_MEM32(P0Q0RGCR+(queue<<2)+((port*6)<<2));
 			data1 = (regData&L1_MASK)>>L1_OFFSET;
 
@@ -3641,10 +3711,10 @@ static int32 queue_bandwidth_read( char *page, char **start, off_t off, int coun
 			}
 			else
 				len += sprintf(page+len, "Egress: avgRate & peakRateFullSpeed\n");
-			
-		}		
+
+		}
 	}
-	
+
 	return len;
 }
 
@@ -3652,49 +3722,501 @@ static int32 queue_bandwidth_write( struct file *filp, const char *buff,unsigned
 {
 	char tmpbuf[16], *tokptr, *strptr;
 	int	port;
+	if(len>16)
+	{
+		goto errout;
+	}
 
 	memset(tmpbuf, 0, 16);
-	
+
 	if (buff && !copy_from_user(tmpbuf, buff, len)) {
 		tmpbuf[len] = '\0';
 		strptr = tmpbuf;
 		tokptr = strsep(&strptr," ");
 		if (tokptr==NULL)
 		{
-			return len;
+			return len;
+		}
+		queue_bandwidth_record_portmask=(uint32)simple_strtol(tokptr, NULL, 0);
+
+		rtlglue_printf("Dump info of: ");
+		for(port=PHY0;port<=CPU;port++)
+		{
+			if ((1<<port)&queue_bandwidth_record_portmask)
+				rtlglue_printf("port%d ", port);
+		}
+		rtlglue_printf("\n");
+	}
+	else
+	{
+errout:
+		rtlglue_printf("error input\n");
+	}
+
+	return len;
+}
+
+
+
+static int32 priority_decision_read( char *page, char **start, off_t off, int count, int *eof, void *data )
+{
+	int		len;
+	uint32	regData;
+	int		queue;
+
+	len = sprintf(page, "Dump Priority Infor:\n");
+
+	regData = READ_MEM32(QIDDPCR);
+
+	len += sprintf(page+len, "NAPT[%d] ACL[%d] DSCP[%d] 8021Q[%d] PortBase[%d]\n",
+		(regData & NAPT_PRI_MASK) >> NAPT_PRI_OFFSET,
+		(regData & ACL_PRI_MASK) >> ACL_PRI_OFFSET,
+		(regData & DSCP_PRI_MASK) >> DSCP_PRI_OFFSET,
+		(regData & BP8021Q_PRI_MASK) >> BP8021Q_PRI_OFFSET,
+		(regData & PBP_PRI_MASK) >> PBP_PRI_OFFSET);
+
+	for(queue=0;queue<RTL8651_OUTPUTQUEUE_SIZE;queue++)
+	{
+		regData = READ_MEM32(UPTCMCR0+(queue<<2));
+		len += sprintf(page+len, "Queue number %d:\n", (queue+1));
+		len += sprintf(page+len, "Piority[0~7] Mapping to Queue[ %d %d %d %d %d %d %d %d ]\n",
+			regData&0x7, (regData>>3)&0x7, (regData>>6)&0x7, (regData>>9)&0x7,
+			(regData>>12)&0x7, (regData>>15)&0x7, (regData>>18)&0x7, (regData>>21)&0x7);
+	}
+
+	return len;
+}
+
+static int32 priority_decision_write( struct file *filp, const char *buff,unsigned long len, void *data )
+{
+	return len;
+}
+
+#if defined (CONFIG_RTL_ENABLE_RATELIMIT_TABLE)
+static int32 rate_limit_read( char *page, char **start, off_t off, int count, int *eof, void *data )
+{
+	int		len;
+	rtl865x_tblAsicDrv_rateLimitParam_t asic_rl;
+	uint32 entry;
+
+	len = sprintf(page, "Dump rate limit table:\n");
+	for(entry=0; entry<RTL8651_RATELIMITTBL_SIZE; entry++) {
+		if (rtl8651_getAsicRateLimitTable(entry, &asic_rl) == SUCCESS) {
+			len += sprintf(page+len, " [%d]  Token(%u)  MaxToken(%u)  remainTime Unit(%u)  \n\trefillTimeUnit(%u)  refillToken(%u)\n",
+				entry, asic_rl.token, asic_rl.maxToken, asic_rl.t_remainUnit, asic_rl.t_intervalUnit, asic_rl.refill_number);
+		}
+		else len += sprintf(page+len, " [%d]  Invalid entry\n", entry);
+	}
+	len += sprintf(page+len, "\n");
+
+	return len;
+}
+
+static int32 rate_limit_write( struct file *filp, const char *buff,unsigned long len, void *data )
+{
+	return len;
+}
+#endif
+
+#if defined(CONFIG_RTL_ETH_PRIV_SKB_DEBUG)
+static int32 rtl819x_proc_priveSkbDebug_read( char *page, char **start, off_t off, int count, int *eof, void *data )
+{
+	return PROC_READ_RETURN_VALUE;
+}
+
+static int32 rtl819x_proc_priveSkbDebug_write( struct file *filp, const char *buff,unsigned long len, void *data )
+{
+	char  tmpbuf[32];
+	
+	if(len>32)
+	{
+		goto errout;
+	}
+	if (buff && !copy_from_user(tmpbuf, buff, len))
+	{
+		tmpbuf[len -1] = '\0';
+		if(tmpbuf[0] == '1')
+		{
+			unsigned long flags;
+			int cpu_queue_cnt,rxRing_cnt,txRing_cnt,wlan_txRing_cnt,wlan_txRing_cnt1, mbuf_pending_cnt;
+			int rx_queue_cnt,poll_cnt;
+
+			rtlglue_printf("nic buf cnt(%d)\n",MAX_ETH_SKB_NUM);
+
+			local_irq_save(flags);
+			mbuf_pending_cnt = get_mbuf_pending_times();
+			cpu_queue_cnt = get_cpu_completion_queue_num();
+			rxRing_cnt = get_nic_rxRing_buf();
+			txRing_cnt = get_nic_txRing_buf();
+			wlan_txRing_cnt = get_nic_buf_in_wireless_tx("wlan0");
+			wlan_txRing_cnt1 = get_nic_buf_in_wireless_tx("wlan1");
+			rx_queue_cnt = get_buf_in_rx_skb_queue();
+			poll_cnt = get_buf_in_poll();
+			local_irq_restore(flags);
+
+			rtlglue_printf("cpu completion cnt(%d)\nnic rxring cnt(%d)\nnic txring cnt(%d)\nwlan0 txring(%d)\nwlan1 txring(%d)\nrx_queue_cnt(%d)\npoll_cnt(%d)\ntotal(%d)\nmbuf_pending_cnt(%d)\n",cpu_queue_cnt,
+			rxRing_cnt,txRing_cnt,wlan_txRing_cnt,wlan_txRing_cnt1, rx_queue_cnt,poll_cnt,
+			cpu_queue_cnt+rxRing_cnt+txRing_cnt+wlan_txRing_cnt+wlan_txRing_cnt1+rx_queue_cnt+poll_cnt, mbuf_pending_cnt);
+		}
+		else if (tmpbuf[0] == '2')
+		{
+			dump_wlan_dz_queue_num("wlan0");
+			dump_wlan_dz_queue_num("wlan1");
+		}
+		else
+		{
+
+		}
+	}
+	else
+	{
+errout:
+		rtlglue_printf("error input\n");
+	}
+	return len;
+}
+#else
+static int32 rtl819x_proc_priveSkbDebug_read( char *page, char **start, off_t off, int count, int *eof, void *data )
+{
+	return PROC_READ_RETURN_VALUE;
+}
+
+static int32 rtl819x_proc_priveSkbDebug_write( struct file *filp, const char *buff,unsigned long len, void *data )
+{
+	char  tmpbuf[32];
+	if(len>32)
+	{
+		goto errout;
+	}
+	if (buff && !copy_from_user(tmpbuf, buff, len)) {
+		tmpbuf[len -1] = '\0';
+		if(tmpbuf[0] == '1') {
+			rtl_dumpIndexs();
+		}
+	}
+	else
+	{
+errout:
+		rtlglue_printf("error input\n");
+	}
+
+	return len;
+}
+#endif
+
+static int32 storm_read( char *page, char **start, off_t off, int count, int *eof, void *data )
+{
+	int		len;
+	uint32	regData;
+	uint32 port;
+	uint32 totalExtPortNum=3;
+	len = sprintf(page, "Dump storm control info:\n");
+
+	regData = READ_MEM32(BSCR);
+	len += sprintf(page+len, "rate(%d)\n",regData*100/30360);
+
+	for ( port = 0; port < RTL8651_PORT_NUMBER + totalExtPortNum; port++ )
+	{
+		regData = READ_MEM32(PCRP0+port*4);
+		len+= sprintf(page+len,"port%d, %s BCSC, %s BC, %s MC\n", port,regData&ENBCSC?"enable":"disable",regData&BCSC_ENBROADCAST?"enable":"disable",
+					regData&BCSC_ENMULTICAST?"enable":"disable");
+	}
+
+	if (len <= off+count)
+		*eof = 1;
+
+	*start = page + off;
+	len -= off;
+
+	if (len>count)
+		len = count;
+
+	if (len<0) len = 0;
+
+	return len;
+}
+
+static int32 storm_write(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+	uint32 tmpBuf[32];
+	uint32 stormCtrlType=0x3;//mc & bc
+	uint32 enableStormCtrl=FALSE;
+	uint32 percentage=0;
+	uint32 uintVal;
+	if(count>32)
+	{
+		goto errout;
+	}
+
+	if (buffer && !copy_from_user(tmpBuf, buffer, count))
+	{
+		tmpBuf[count-1]=0;
+		uintVal=simple_strtoul((char *)tmpBuf, NULL, 0);
+		rtlglue_printf("%s(%d) uintval(%u) \n",__FUNCTION__,__LINE__,uintVal);//Added for test
+		if(uintVal>100)
+		{
+			enableStormCtrl=FALSE;
+			percentage=0;
+		}
+		else
+		{
+			enableStormCtrl=TRUE;
+			percentage=uintVal;
+		}
+		//printk("%s(%d),enableStormCtrl=%d,percentage=%d\n",__FUNCTION__,__LINE__,
+		//	enableStormCtrl,percentage);//Added for test
+		rtl865x_setStormControl(stormCtrlType,enableStormCtrl,percentage);
+		return count;
+	}
+	else
+	{
+errout:
+		rtlglue_printf("error input\n");
+	}
+	return -EFAULT;
+}
+
+static int32 stats_debug_entry_read( char *page, char **start, off_t off, int count, int *eof, void *data )
+	{
+		int 	len;
+		
+		len = sprintf(page, "  Debug Statistics Info:\n");
+		len += sprintf(page+len,"    rx_noBuffer_cnt:	%d\n",rx_noBuffer_cnt);
+		len += sprintf(page+len,"    tx_ringFull_cnt:	%d\n",tx_ringFull_cnt);
+		return len;
+			
+	}
+/*echo clear > /proc/rtl865x/stats to clear the count of tx&rx no buffer count*/
+static int32 stats_debug_entry_write(struct file *file, const char *buffer,
+		      unsigned long len, void *data)
+
+{
+	char tmpBuf[32];
+	char		*strptr;
+	char 		*cmd_addr;
+	if(len>32)
+	{
+		goto errout;
+	}
+	if (buffer && !copy_from_user(tmpBuf, buffer, len)) {
+		tmpBuf[len-1] = '\0';
+		strptr=tmpBuf;
+		cmd_addr = strsep(&strptr," ");
+		if (cmd_addr==NULL)
+		{
+			goto errout;
+		}
+
+		if(strncmp(cmd_addr, "clear",5) == 0)
+		{
+			rx_noBuffer_cnt=0;
+			tx_ringFull_cnt=0;
+		}
+
+	}
+	else
+	{
+errout:
+			rtlglue_printf("error input\n");
+	}
+	return len;
+}
+
+#endif
+
+#if defined(CONFIG_RTL_PROC_DEBUG)||defined(CONFIG_RTL_DEBUG_TOOL)
+//the following proc default established
+static int32 diagnostic_read( char *page, char **start, off_t off, int count, int *eof, void *data )
+{
+	int		len;
+	uint32	regData, regData1;
+	int		port, regIdx;
+	uint32	mask, offset;
+
+	len = sprintf(page, "Diagnostic Register Info:\n");
+
+	regData = READ_MEM32(GDSR0);
+	len += sprintf(page + len, "MaxUsedDescriptor: %d CurUsed Descriptor: %d\n",
+		(regData&MaxUsedDsc_MASK)>>MaxUsedDsc_OFFSET,
+		(regData&USEDDSC_MASK)>>USEDDSC_OFFSET);
+	len += sprintf(page+len, "DescRunOut: %s TotalDescFC: %s ShareBufFC: %s\n",
+		(regData&DSCRUNOUT)?"YES":"NO", (regData&TotalDscFctrl_Flag)?"YES":"NO", (regData&SharedBufFCON_Flag)?"YES":"NO");
+
+	for(regIdx = 0; regIdx<2; regIdx++)
+	{
+		regData = READ_MEM32(PCSR0+(regIdx<<2));
+
+		for(port=0; port<4; port++)
+		{
+			switch(port)
+			{
+				case 0:
+					mask = P0OQCgst_MASK;
+					offset = P0OQCgst_OFFSET;
+					break;
+				case 1:
+					mask = P1OQCgst_MASK;
+					offset = P1OQCgst_OFFSET;
+					break;
+				case 2:
+					mask = P2OQCgst_MASK;
+					offset = P2OQCgst_OFFSET;
+					break;
+				default:
+					mask = P3OQCgst_MASK;
+					offset = P3OQCgst_OFFSET;
+					break;
+			}
+			regData1 = (regData&mask)>>offset;
+			if (regData1==0)
+				len += sprintf(page+len, "Port%d not congestion\n", port+(regIdx<<2));
+			else
+			{
+				len += sprintf(page+len, "Port%d queue congestion mask 0x%x\n", port+(regIdx<<2), regData1);
+			}
+		}
+	}
+
+	for(port=0;port<=CPU;port++)
+	{
+		len += sprintf(page+len, "Port%d each queue used descriptor: Queue[0~5]: [ ", port);
+		for(regIdx=0; regIdx<3; regIdx++)
+		{
+			regData = READ_MEM32(P0_DCR0+(port<<4)+(regIdx<<2));
+			len += sprintf(page+len, "%d %d ",
+				((regData&Pn_EQDSCR_MASK)>>Pn_EVEN_OQDSCR_OFFSET),
+				((regData&Pn_OQDSCR_MASK)>>Pn_ODD_OQDSCR_OFFSET));
+		}
+
+		regData = READ_MEM32(P0_DCR3+(port<<4));
+		len += sprintf(page+len, "]  Input queue [%d]\n",
+				((regData&Pn_EQDSCR_MASK)>>Pn_EVEN_OQDSCR_OFFSET));
+	}
+
+	return len;
+}
+
+static int32 diagnostic_write( struct file *filp, const char *buff,unsigned long len, void *data )
+{
+	return len;
+}
+
+
+static int32 proc_mem_read( char *page, char **start, off_t off, int count, int *eof, void *data )
+{
+	return PROC_READ_RETURN_VALUE;
+}
+
+static int32 proc_mem_write( struct file *filp, const char *buff,unsigned long len, void *data )
+{
+	char 		tmpbuf[64];
+	uint32	*mem_addr, mem_data, mem_len;
+	char		*strptr, *cmd_addr;
+	char		*tokptr;
+
+	if(len>64)
+	{
+		goto errout;
+	}
+	if (buff && !copy_from_user(tmpbuf, buff, len)) {
+		tmpbuf[len] = '\0';
+		strptr=tmpbuf;
+		cmd_addr = strsep(&strptr," ");
+		if (cmd_addr==NULL)
+		{
+			goto errout;
+		}
+		rtlglue_printf("cmd %s\n", cmd_addr);
+		tokptr = strsep(&strptr," ");
+		if (tokptr==NULL)
+		{
+			goto errout;
+		}
+
+		if (!memcmp(cmd_addr, "read", 4))
+		{
+			mem_addr=(uint32*)simple_strtol(tokptr, NULL, 0);
+			tokptr = strsep(&strptr," ");
+			if (tokptr==NULL)
+			{
+				goto errout;
+			}
+			mem_len=simple_strtol(tokptr, NULL, 0);
+			memDump(mem_addr, mem_len, "");
+		}
+		else if (!memcmp(cmd_addr, "write", 5))
+		{
+			mem_addr=(uint32*)simple_strtol(tokptr, NULL, 0);
+			tokptr = strsep(&strptr," ");
+			if (tokptr==NULL)
+			{
+				goto errout;
+			}
+			mem_data=simple_strtol(tokptr, NULL, 0);
+			WRITE_MEM32(mem_addr, mem_data);
+			rtlglue_printf("Write memory 0x%p dat 0x%x: 0x%x\n", mem_addr, mem_data, READ_MEM32(mem_addr));
 		}
-		queue_bandwidth_record_portmask=(uint32)simple_strtol(tokptr, NULL, 0);
-
-		printk("Dump info of: ");
-		for(port=PHY0;port<=CPU;port++)
+		else
 		{
-			if ((1<<port)&queue_bandwidth_record_portmask)
-				printk("port%d ", port);
+			goto errout;
 		}
-		printk("\n");
+	}
+	else
+	{
+errout:
+		rtlglue_printf("Memory operation only support \"read\" and \"write\" as the first parameter\n");
+		rtlglue_printf("Read format:	\"read mem_addr length\"\n");
+		rtlglue_printf("Write format:	\"write mem_addr mem_data\"\n");
 	}
 
 	return len;
 }
 
+
+
 static int32 port_status_read( char *page, char **start, off_t off, int count, int *eof, void *data )
 {
 	int		len;
 	uint32	regData;
 	uint32	data0;
 	int		port;
+	uint32  regData_PCR;
 	
 	len = sprintf(page, "Dump Port Status:\n");
 
 	for(port=PHY0;port<=CPU;port++)
 	{
 		regData = READ_MEM32(PSRP0+((port)<<2));
+		regData_PCR = READ_MEM32(PCRP0+((port)<<2));
+		
 		if (port==CPU)
 			len += sprintf(page+len, "CPUPort ");
 		else
 			len += sprintf(page+len, "Port%d ", port);
-		data0 = regData & PortStatusLinkUp;
 		
+		data0 = regData_PCR & EnForceMode;
+		if(data0)
+		{
+			len += sprintf(page+len, "Enforce Mode ");
+			data0 = regData_PCR & PollLinkStatus;
+			if (data0)
+				len += sprintf(page+len, " | polling LinkUp");
+			else
+			{
+				len += sprintf(page+len, " | disable Auto-Negotiation\n\n");
+			}
+		}
+		else
+		{
+			len += sprintf(page+len, "Force Mode disable\n");
+		}
+		data0 = (regData & (PortEEEStatus_MASK))>>PortEEEStatus_OFFSET;
+		len += sprintf(page+len,"EEE Status %0x\n",data0);
+		
+		regData = READ_MEM32(PSRP0+((port)<<2));
+		data0 = regData & PortStatusLinkUp;
+
 		if (data0)
 			len += sprintf(page+len, "LinkUp | ");
 		else
@@ -3715,7 +4237,7 @@ static int32 port_status_read( char *page, char **start, off_t off, int count, i
 			(data0==PortStatusLinkSpeed1000M?"1G":
 				(data0==PortStatusLinkSpeed10M?"10M":"Unkown")));
 	}
-	
+
 	return len;
 }
 
@@ -3737,6 +4259,10 @@ static int32 port_status_write( struct file *filp, const char *buff,unsigned lon
 #define SPEED100M 	1
 #define SPEED1000M 	2
 
+	if(len>64)
+	{
+		goto errout;
+	}
 	if (buff && !copy_from_user(tmpbuf, buff, len)) {
 		tmpbuf[len-1] = '\0';
 		strptr=tmpbuf;
@@ -3759,7 +4285,7 @@ static int32 port_status_write( struct file *filp, const char *buff,unsigned lon
 			{
 				goto errout;
 			}
-			
+
 			if(strcmp(tokptr,"10_half") == 0)
 				type = HALF_DUPLEX_10M;
 			else if(strcmp(tokptr,"100_half") == 0)
@@ -3821,7 +4347,7 @@ static int32 port_status_write( struct file *filp, const char *buff,unsigned lon
 					forceDuplex=TRUE;
 					advCapability=(1<<DUPLEX_100M);
 					break;
-				}	
+				}
 				case DUPLEX_1000M:
 				{
 					forceMode=TRUE;
@@ -3831,32 +4357,32 @@ static int32 port_status_write( struct file *filp, const char *buff,unsigned lon
 					advCapability=(1<<DUPLEX_1000M);
 					break;
 				}	
-				default:	
+				default:
 				{
 					forceMode=FALSE;
 					forceLink=TRUE;
 					/*all capality*/
-					advCapability=(1<<PORT_AUTO);		
+					advCapability=(1<<PORT_AUTO);
 				}
 			}
-				
-			
+
+
 			for(port = 0; port < CPU; port++)
 			{
 				if((1<<port) & port_mask)
 				{
 					rtl865xC_setAsicEthernetForceModeRegs(port, forceMode, forceLink, forceLinkSpeed, forceDuplex);
-							
+
 					/*Set PHY Register*/
 					rtl8651_setAsicEthernetPHYSpeed(port,forceLinkSpeed);
 					rtl8651_setAsicEthernetPHYDuplex(port,forceDuplex);
 					rtl8651_setAsicEthernetPHYAutoNeg(port,forceMode?FALSE:TRUE);
 					rtl8651_setAsicEthernetPHYAdvCapality(port,advCapability);
-					rtl8651_restartAsicEthernetPHYNway(port);					
+					rtl8651_restartAsicEthernetPHYNway(port);
 				}
 			}
-			
-		}		
+
+		}
 		else
 		{
 			goto errout;
@@ -3865,138 +4391,20 @@ static int32 port_status_write( struct file *filp, const char *buff,unsigned lon
 	else
 	{
 errout:
-		printk("port status only support \"port\" as the first parameter\n");
-		printk("format: \"port port_mask 10_half/100_half/10_full/100_full/1000_full/auto\"\n");
-	}
-	return len;
-}
-
-
-static int32 priority_decision_read( char *page, char **start, off_t off, int count, int *eof, void *data )
-{
-	int		len;
-	uint32	regData;
-	int		queue;
-	
-	len = sprintf(page, "Dump Priority Infor:\n");
-
-	regData = READ_MEM32(QIDDPCR);
-
-	len += sprintf(page+len, "NAPT[%d] ACL[%d] DSCP[%d] 8021Q[%d] PortBase[%d]\n",
-		(regData & NAPT_PRI_MASK) >> NAPT_PRI_OFFSET, 
-		(regData & ACL_PRI_MASK) >> ACL_PRI_OFFSET, 
-		(regData & DSCP_PRI_MASK) >> DSCP_PRI_OFFSET, 
-		(regData & BP8021Q_PRI_MASK) >> BP8021Q_PRI_OFFSET, 
-		(regData & PBP_PRI_MASK) >> PBP_PRI_OFFSET);
-	
-	for(queue=0;queue<RTL8651_OUTPUTQUEUE_SIZE;queue++)
-	{
-		regData = READ_MEM32(UPTCMCR0+(queue<<2));
-		len += sprintf(page+len, "Queue number %d:\n", (queue+1));
-		len += sprintf(page+len, "Piority[0~7] Mapping to Queue[ %d %d %d %d %d %d %d %d ]\n",
-			regData&0x7, (regData>>3)&0x7, (regData>>6)&0x7, (regData>>9)&0x7, 
-			(regData>>12)&0x7, (regData>>15)&0x7, (regData>>18)&0x7, (regData>>21)&0x7);
-	}
-
-	return len;
-}
-
-static int32 priority_decision_write( struct file *filp, const char *buff,unsigned long len, void *data )
-{
-	return len;
-}
-
-#if defined (CONFIG_RTL_ENABLE_RATELIMIT_TABLE)
-static int32 rate_limit_read( char *page, char **start, off_t off, int count, int *eof, void *data )
-{
-	int		len;
-	rtl865x_tblAsicDrv_rateLimitParam_t asic_rl;
-	uint32 entry;
-
-	len = sprintf(page, "Dump rate limit table:\n");
-	for(entry=0; entry<RTL8651_RATELIMITTBL_SIZE; entry++) {
-		if (rtl8651_getAsicRateLimitTable(entry, &asic_rl) == SUCCESS) {
-			len += sprintf(page+len, " [%d]  Token(%u)  MaxToken(%u)  remainTime Unit(%u)  \n\trefillTimeUnit(%u)  refillToken(%u)\n",
-				entry, asic_rl.token, asic_rl.maxToken, asic_rl.t_remainUnit, asic_rl.t_intervalUnit, asic_rl.refill_number);
-		}
-		else len += sprintf(page+len, " [%d]  Invalid entry\n", entry);
+		rtlglue_printf("port status only support \"port\" as the first parameter\n");
+		rtlglue_printf("format: \"port port_mask 10_half/100_half/10_full/100_full/1000_full/auto\"\n");
 	}
-	len += sprintf(page+len, "\n");
-
 	return len;
 }
 
-static int32 rate_limit_write( struct file *filp, const char *buff,unsigned long len, void *data )
-{
-	return len;
-}
-#endif
 
-#if defined(CONFIG_RTL_ETH_PRIV_SKB_DEBUG)
-static int32 rtl819x_proc_priveSkbDebug_read( char *page, char **start, off_t off, int count, int *eof, void *data )
-{
-	return PROC_READ_RETURN_VALUE;
-}
-		
-static int32 rtl819x_proc_priveSkbDebug_write( struct file *filp, const char *buff,unsigned long len, void *data )
-{
-	char  tmpbuf[32];	
-	if (buff && !copy_from_user(tmpbuf, buff, len))
-	{
-		tmpbuf[len -1] = '\0';		
-		if(tmpbuf[0] == '1')
-		{
-			unsigned long flags;
-			int cpu_queue_cnt,rxRing_cnt,txRing_cnt,wlan_txRing_cnt,wlan_txRing_cnt1, mbuf_pending_cnt;
-			int rx_queue_cnt,poll_cnt;
-				
-			printk("=======nic buf cnt(%d)\n",MAX_ETH_SKB_NUM);
-				
-			local_irq_save(flags);
-			mbuf_pending_cnt = get_mbuf_pending_times();
-			cpu_queue_cnt = get_cpu_completion_queue_num();
-			rxRing_cnt = get_nic_rxRing_buf();
-			txRing_cnt = get_nic_txRing_buf();
-			wlan_txRing_cnt = get_nic_buf_in_wireless_tx("wlan0");
-			wlan_txRing_cnt1 = get_nic_buf_in_wireless_tx("wlan1");
-			rx_queue_cnt = get_buf_in_rx_skb_queue();
-			poll_cnt = get_buf_in_poll();
-			local_irq_restore(flags);
-				
-			printk("cpu completion cnt(%d)\nnic rxring cnt(%d)\nnic txring cnt(%d)\nwlan0 txring(%d)\nwlan1 txring(%d)\nrx_queue_cnt(%d)\npoll_cnt(%d)\ntotal(%d)\nmbuf_pending_cnt(%d)\n",cpu_queue_cnt,
-			rxRing_cnt,txRing_cnt,wlan_txRing_cnt,wlan_txRing_cnt1, rx_queue_cnt,poll_cnt,
-			cpu_queue_cnt+rxRing_cnt+txRing_cnt+wlan_txRing_cnt+wlan_txRing_cnt1+rx_queue_cnt+poll_cnt, mbuf_pending_cnt);		
-		}	
-	}
-		
-	return len;
-}
-#else
-static int32 rtl819x_proc_priveSkbDebug_read( char *page, char **start, off_t off, int count, int *eof, void *data )
-{
-	return PROC_READ_RETURN_VALUE;
-}
-		
-static int32 rtl819x_proc_priveSkbDebug_write( struct file *filp, const char *buff,unsigned long len, void *data )
-{
-	char  tmpbuf[32];	
-	if (buff && !copy_from_user(tmpbuf, buff, len)) {
-		tmpbuf[len -1] = '\0';		
-		if(tmpbuf[0] == '1') {
-			rtl_dumpIndexs();
-		}	
-	}
-		
-	return len;
-}
-#endif
 
 static int32 rtl865x_proc_mibCounter_read( char *page, char **start, off_t off, int count, int *eof, void *data )
 {
 	int len=0;
-	
+
 	rtl865xC_dumpAsicDiagCounter();
-	
+
 	return len;
 }
 
@@ -4007,127 +4415,253 @@ static int32 rtl865x_proc_mibCounter_write( struct file *filp, const char *buff,
 	char		*strptr;
 	char		*cmdptr;
 	uint32	portNum=0xFFFFFFFF;
+
+	if(len>512)
+	{
+		goto errout;
+	}
 	if (buff && !copy_from_user(tmpbuf, buff, len))
 	{
 		tmpbuf[len] = '\0';
-		
+
 		strptr=tmpbuf;
 
 		if(strlen(strptr)==0)
 		{
 			goto errout;
 		}
-		
+
 		cmdptr = strsep(&strptr," ");
 		if (cmdptr==NULL)
 		{
 			goto errout;
 		}
-		
+
 		/*parse command*/
-		if(strncmp(cmdptr, "clear",5) == 0)
+		if(!strncmp(cmdptr, "clear",5))
 		{
 			rtl8651_clearAsicCounter();
 		}
-		else if(strncmp(cmdptr, "dump",4) == 0)
+		else if(!strncmp(cmdptr, "dump",4))
+		{
+			cmdptr = strsep(&strptr," ");
+			if (cmdptr==NULL)
+			{
+				goto errout;
+			}
+
+			if(strncmp(cmdptr, "port",4) != 0)
+			{
+				goto errout;
+			}
+
+			cmdptr = strsep(&strptr," ");
+			if (cmdptr==NULL)
+			{
+				goto errout;
+			}
+			portNum = simple_strtol(cmdptr, NULL, 0);
+
+
+			if((portNum>=0) && (portNum<=RTL8651_PORT_NUMBER))
+			{
+				extern int32 rtl8651_returnAsicCounter(uint32 offset);
+				extern uint64 rtl865xC_returnAsicCounter64(uint32 offset);
+				uint32 addrOffset_fromP0 = portNum * MIB_ADDROFFSETBYPORT;
+
+				if ( portNum == RTL8651_PORT_NUMBER )
+					rtlglue_printf("<CPU port (extension port included)>\n");
+				else
+					rtlglue_printf("<Port: %d>\n", portNum);
+
+				rtlglue_printf("Rx counters\n");
+				rtlglue_printf("   Rcv %llu bytes, Drop %u pkts, CRCAlignErr %u, FragErr %u, JabberErr %u\n",
+					rtl865xC_returnAsicCounter64( OFFSET_IFINOCTETS_P0 + addrOffset_fromP0 ),
+					rtl8651_returnAsicCounter( OFFSET_DOT1DTPPORTINDISCARDS_P0 + addrOffset_fromP0 ),
+					rtl8651_returnAsicCounter( OFFSET_DOT3STATSFCSERRORS_P0 + addrOffset_fromP0 ),
+					rtl8651_returnAsicCounter( OFFSET_ETHERSTATSFRAGMEMTS_P0 + addrOffset_fromP0 ),
+					rtl8651_returnAsicCounter( OFFSET_ETHERSTATSJABBERS_P0 + addrOffset_fromP0 ));
+				rtlglue_printf("   Unicast %u pkts, Multicast %u pkts, Broadcast %u pkts\n",
+					rtl8651_returnAsicCounter( OFFSET_IFINUCASTPKTS_P0 + addrOffset_fromP0 ),
+					rtl8651_returnAsicCounter( OFFSET_ETHERSTATSMULTICASTPKTS_P0 + addrOffset_fromP0 ),
+					rtl8651_returnAsicCounter( OFFSET_ETHERSTATSBROADCASTPKTS_P0 + addrOffset_fromP0 ));
+				rtlglue_printf("   < 64: %u pkts, 64: %u pkts, 65 -127: %u pkts, 128 -255: %u pkts\n",
+					rtl8651_returnAsicCounter( OFFSET_ETHERSTATSUNDERSIZEPKTS_P0 + addrOffset_fromP0 ),
+					rtl8651_returnAsicCounter( OFFSET_ETHERSTATSPKTS64OCTETS_P0 + addrOffset_fromP0 ),
+					rtl8651_returnAsicCounter( OFFSET_ETHERSTATSPKTS65TO127OCTETS_P0 + addrOffset_fromP0 ),
+					rtl8651_returnAsicCounter( OFFSET_ETHERSTATSPKTS128TO255OCTETS_P0 + addrOffset_fromP0 ));
+				rtlglue_printf("   256 - 511: %u pkts, 512 - 1023: %u pkts, 1024 - 1518: %u pkts\n",
+					rtl8651_returnAsicCounter( OFFSET_ETHERSTATSPKTS256TO511OCTETS_P0 + addrOffset_fromP0 ),
+					rtl8651_returnAsicCounter( OFFSET_ETHERSTATSPKTS512TO1023OCTETS_P0 + addrOffset_fromP0),
+					rtl8651_returnAsicCounter( OFFSET_ETHERSTATSPKTS1024TO1518OCTETS_P0 + addrOffset_fromP0 ) );
+				rtlglue_printf("   oversize: %u pkts, Control unknown %u pkts, Pause %u pkts\n",
+					rtl8651_returnAsicCounter( OFFSET_ETHERSTATSOVERSIZEPKTS_P0 + addrOffset_fromP0 ),
+					rtl8651_returnAsicCounter( OFFSET_DOT3CONTROLINUNKNOWNOPCODES_P0 + addrOffset_fromP0 ),
+					rtl8651_returnAsicCounter( OFFSET_DOT3INPAUSEFRAMES_P0 + addrOffset_fromP0 ));
+
+				rtlglue_printf("Output counters\n");
+				rtlglue_printf("   Snd %llu bytes, Unicast %u pkts, Multicast %u pkts\n",
+					rtl865xC_returnAsicCounter64( OFFSET_IFOUTOCTETS_P0 + addrOffset_fromP0 ),
+					rtl8651_returnAsicCounter( OFFSET_IFOUTUCASTPKTS_P0 + addrOffset_fromP0 ),
+					rtl8651_returnAsicCounter( OFFSET_IFOUTMULTICASTPKTS_P0 + addrOffset_fromP0 ));
+				rtlglue_printf("   Broadcast %u pkts, Late collision %u, Deferred transmission %u \n",
+					rtl8651_returnAsicCounter( OFFSET_IFOUTBROADCASTPKTS_P0 + addrOffset_fromP0 ),
+					rtl8651_returnAsicCounter( OFFSET_DOT3STATSLATECOLLISIONS_P0 + addrOffset_fromP0 ),
+					rtl8651_returnAsicCounter( OFFSET_DOT3STATSDEFERREDTRANSMISSIONS_P0 + addrOffset_fromP0 ));
+				rtlglue_printf("   Collisions %u Single collision %u Multiple collision %u pause %u\n",
+					rtl8651_returnAsicCounter( OFFSET_ETHERSTATSCOLLISIONS_P0 + addrOffset_fromP0 ),
+					rtl8651_returnAsicCounter( OFFSET_DOT3STATSSINGLECOLLISIONFRAMES_P0 + addrOffset_fromP0 ),
+					rtl8651_returnAsicCounter( OFFSET_DOT3STATSMULTIPLECOLLISIONFRAMES_P0 + addrOffset_fromP0 ),
+					rtl8651_returnAsicCounter( OFFSET_DOT3OUTPAUSEFRAMES_P0 + addrOffset_fromP0 ));
+
+			}
+			else
+			{
+				goto errout;
+			}
+		}
+		else
+		{
+			goto errout;
+		}
+
+	}
+	else
+	{
+errout:
+		rtlglue_printf("error input\n");
+	}
+
+	return len;
+}
+
+
+static int32 proc_phyReg_read( char *page, char **start, off_t off, int count, int *eof, void *data )
+{
+	return PROC_READ_RETURN_VALUE;
+}
+
+static int32 proc_mmd_read( char *page, char **start, off_t off, int count, int *eof, void *data )
+{
+	return PROC_READ_RETURN_VALUE;
+}
+
+/*
+	echo read phy_id device_id reg_addr  > /proc/rtl865x/mmd
+	echo write phy_id device_id reg_addr data_for_write > /proc/rtl865x/mmd
+ */
+static int32 proc_mmd_write( struct file *filp, const char *buff,unsigned long len, void *data )
+{
+	char 	tmpbuf[64];
+	uint32	phyId, regId, regData, devId, dataReadBack;
+	char		*strptr, *cmd_addr;
+	char		*tokptr;
+	int32 	ret;
+
+	if(len>64)
+	{
+		goto errout;
+	}
+	if (buff && !copy_from_user(tmpbuf, buff, len)) {
+		tmpbuf[len] = '\0';
+		strptr=tmpbuf;
+		cmd_addr = strsep(&strptr," ");
+		if (cmd_addr==NULL)
+		{
+			goto errout;
+		}
+	
+		if (!memcmp(cmd_addr, "read", 4))
 		{
-			cmdptr = strsep(&strptr," ");
-			if (cmdptr==NULL)
+			tokptr = strsep(&strptr," ");
+			if (tokptr==NULL)
 			{
 				goto errout;
 			}
-			
-			if(strncmp(cmdptr, "port",4) != 0)
+			phyId=simple_strtol(tokptr, NULL, 0);
+
+			tokptr = strsep(&strptr," ");
+			if (tokptr==NULL)
 			{
 				goto errout;
 			}
+			devId=simple_strtol(tokptr, NULL, 0);
 			
-			cmdptr = strsep(&strptr," ");
-			if (cmdptr==NULL)
+			tokptr = strsep(&strptr," ");
+			if (tokptr==NULL)
 			{
 				goto errout;
 			}
-			portNum = simple_strtol(cmdptr, NULL, 0);
-		
-				
-			if((portNum>=0) && (portNum<=RTL8651_PORT_NUMBER))
+			regId=simple_strtol(tokptr, NULL, 0);
+
+			ret = mmd_read(phyId, devId, regId, &regData);
+			
+			if(ret==SUCCESS)
 			{
-				extern int32 rtl8651_returnAsicCounter(uint32 offset); 
-				extern uint64 rtl865xC_returnAsicCounter64(uint32 offset);
-				uint32 addrOffset_fromP0 = portNum * MIB_ADDROFFSETBYPORT;
-				
-				if ( portNum == RTL8651_PORT_NUMBER )
-					printk("<CPU port (extension port included)>\n");
-				else
-					printk("<Port: %d>\n", portNum);
-
-				printk("Rx counters\n");
-				printk("   Rcv %llu bytes, Drop %u pkts, CRCAlignErr %u, FragErr %u, JabberErr %u\n", 
-					rtl865xC_returnAsicCounter64( OFFSET_IFINOCTETS_P0 + addrOffset_fromP0 ), 
-					rtl8651_returnAsicCounter( OFFSET_DOT1DTPPORTINDISCARDS_P0 + addrOffset_fromP0 ), 
-					rtl8651_returnAsicCounter( OFFSET_DOT3STATSFCSERRORS_P0 + addrOffset_fromP0 ), 
-					rtl8651_returnAsicCounter( OFFSET_ETHERSTATSFRAGMEMTS_P0 + addrOffset_fromP0 ), 
-					rtl8651_returnAsicCounter( OFFSET_ETHERSTATSJABBERS_P0 + addrOffset_fromP0 ));
-				printk("   Unicast %u pkts, Multicast %u pkts, Broadcast %u pkts\n", 
-					rtl8651_returnAsicCounter( OFFSET_IFINUCASTPKTS_P0 + addrOffset_fromP0 ), 
-					rtl8651_returnAsicCounter( OFFSET_ETHERSTATSMULTICASTPKTS_P0 + addrOffset_fromP0 ), 
-					rtl8651_returnAsicCounter( OFFSET_ETHERSTATSBROADCASTPKTS_P0 + addrOffset_fromP0 ));
-				printk("   < 64: %u pkts, 64: %u pkts, 65 -127: %u pkts, 128 -255: %u pkts\n", 
-					rtl8651_returnAsicCounter( OFFSET_ETHERSTATSUNDERSIZEPKTS_P0 + addrOffset_fromP0 ), 
-					rtl8651_returnAsicCounter( OFFSET_ETHERSTATSPKTS64OCTETS_P0 + addrOffset_fromP0 ), 
-					rtl8651_returnAsicCounter( OFFSET_ETHERSTATSPKTS65TO127OCTETS_P0 + addrOffset_fromP0 ), 
-					rtl8651_returnAsicCounter( OFFSET_ETHERSTATSPKTS128TO255OCTETS_P0 + addrOffset_fromP0 ));
-				printk("   256 - 511: %u pkts, 512 - 1023: %u pkts, 1024 - 1518: %u pkts\n", 
-					rtl8651_returnAsicCounter( OFFSET_ETHERSTATSPKTS256TO511OCTETS_P0 + addrOffset_fromP0 ), 
-					rtl8651_returnAsicCounter( OFFSET_ETHERSTATSPKTS512TO1023OCTETS_P0 + addrOffset_fromP0), 
-					rtl8651_returnAsicCounter( OFFSET_ETHERSTATSPKTS1024TO1518OCTETS_P0 + addrOffset_fromP0 ) );
-				printk("   oversize: %u pkts, Control unknown %u pkts, Pause %u pkts\n", 
-					rtl8651_returnAsicCounter( OFFSET_ETHERSTATSOVERSIZEPKTS_P0 + addrOffset_fromP0 ),
-					rtl8651_returnAsicCounter( OFFSET_DOT3CONTROLINUNKNOWNOPCODES_P0 + addrOffset_fromP0 ), 
-					rtl8651_returnAsicCounter( OFFSET_DOT3INPAUSEFRAMES_P0 + addrOffset_fromP0 ));
-				
-				printk("Output counters\n");
-				printk("   Snd %llu bytes, Unicast %u pkts, Multicast %u pkts\n",
-					rtl865xC_returnAsicCounter64( OFFSET_IFOUTOCTETS_P0 + addrOffset_fromP0 ), 
-					rtl8651_returnAsicCounter( OFFSET_IFOUTUCASTPKTS_P0 + addrOffset_fromP0 ),
-					rtl8651_returnAsicCounter( OFFSET_IFOUTMULTICASTPKTS_P0 + addrOffset_fromP0 ));
-				printk("   Broadcast %u pkts, Late collision %u, Deferred transmission %u \n",
-					rtl8651_returnAsicCounter( OFFSET_IFOUTBROADCASTPKTS_P0 + addrOffset_fromP0 ),
-					rtl8651_returnAsicCounter( OFFSET_DOT3STATSLATECOLLISIONS_P0 + addrOffset_fromP0 ), 
-					rtl8651_returnAsicCounter( OFFSET_DOT3STATSDEFERREDTRANSMISSIONS_P0 + addrOffset_fromP0 ));
-				printk("   Collisions %u Single collision %u Multiple collision %u pause %u\n",
-					rtl8651_returnAsicCounter( OFFSET_ETHERSTATSCOLLISIONS_P0 + addrOffset_fromP0 ), 
-					rtl8651_returnAsicCounter( OFFSET_DOT3STATSSINGLECOLLISIONFRAMES_P0 + addrOffset_fromP0 ), 
-					rtl8651_returnAsicCounter( OFFSET_DOT3STATSMULTIPLECOLLISIONFRAMES_P0 + addrOffset_fromP0 ), 
-					rtl8651_returnAsicCounter( OFFSET_DOT3OUTPAUSEFRAMES_P0 + addrOffset_fromP0 ));
-				
+				rtlglue_printf("read phyId(%d), devId(%d), regId(%d), regData:0x%x\n", phyId,devId, regId, regData);
 			}
 			else
 			{
-				goto errout;
+				rtlglue_printf("error input!\n");
 			}
 		}
-		else
+		else if (!memcmp(cmd_addr, "write", 5))
 		{
-			goto errout;
+			tokptr = strsep(&strptr," ");
+			if (tokptr==NULL)
+			{
+				goto errout;
+			}
+			phyId=simple_strtol(tokptr, NULL, 0);
+
+			tokptr = strsep(&strptr," ");
+			if (tokptr==NULL)
+			{
+				goto errout;
+			}
+			devId=simple_strtol(tokptr, NULL, 0);
+			
+			tokptr = strsep(&strptr," ");
+			if (tokptr==NULL)
+			{
+				goto errout;
+			}
+			regId=simple_strtol(tokptr, NULL, 0);
+
+			tokptr = strsep(&strptr," ");
+			if (tokptr==NULL)
+			{
+				goto errout;
+			}
+			regData=simple_strtol(tokptr, NULL, 0);
+
+			mmd_write(phyId, devId, regId, regData);
+
+			/* confirm result */
+			rtl8651_setAsicEthernetPHYReg( phyId, 13, (devId | 0x4000));
+			ret=rtl8651_getAsicEthernetPHYReg(phyId, 14, &dataReadBack);
+
+			if(ret==SUCCESS)
+			{
+				rtlglue_printf("extWrite phyId(%d), devId(%d), regId(%d), regData:0x%x, regData(read back):0x%x\n", 
+					phyId, devId, regId, regData, dataReadBack);
+			}
+			else
+			{
+				rtlglue_printf("error input!\n");
+			}
 		}
-		
 	}
 	else
 	{
 errout:
-		printk("error input\n");
+		rtlglue_printf("error input!\n");
 	}
 
 	return len;
 }
 
-static int32 proc_phyReg_read( char *page, char **start, off_t off, int count, int *eof, void *data )
-{
-	return PROC_READ_RETURN_VALUE;
-}
-
-#ifdef CONFIG_RTL_8198
+#if defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 void getPhyByPortPage(int port, int page)
 {
 	uint32	regData;
@@ -4136,7 +4670,7 @@ void getPhyByPortPage(int port, int page)
 	//change page num
 	//rtl8651_setAsicEthernetPHYReg(port, 31, page);
 	if (page>=31)
-	{	
+	{
 		rtl8651_setAsicEthernetPHYReg( port, 31, 7  );
 		rtl8651_setAsicEthernetPHYReg( port, 30, page  );
 	}
@@ -4144,15 +4678,15 @@ void getPhyByPortPage(int port, int page)
 	{
 		rtl8651_setAsicEthernetPHYReg( port, 31, page  );
 	}
-					
+
 	for(reg=0;reg<32;reg++)
 	{
-		rtl8651_getAsicEthernetPHYReg( port, reg, &regData);	
-		printk("port:%d,page:%d,regId:%d,regData:0x%x\n",port,page,reg,regData);
+		rtl8651_getAsicEthernetPHYReg( port, reg, &regData);
+		rtlglue_printf("port:%d,page:%d,regId:%d,regData:0x%x\n",port,page,reg,regData);
 	}
 	//if(page!=3)
 	//{
-		printk("------------------------------------------\n");
+		rtlglue_printf("------------------------------------------\n");
 	//}
 
 	//change back to page 0
@@ -4160,8 +4694,8 @@ void getPhyByPortPage(int port, int page)
 
 }
 
-static const int _8198_phy_page[] = {	0, 1, 2, 3,     		4, 5, 6, 32, 
-								  	33, 34, 35, 36,	40, 44, 45, 46, 
+static const int _8198_phy_page[] = {	0, 1, 2, 3,     		4, 5, 6, 32,
+								  	33, 34, 35, 36,	40, 44, 45, 46,
 								  	64, 65, 66, 69,	70, 80, 81, 161 };
 #endif
 
@@ -4175,6 +4709,10 @@ static int32 proc_phyReg_write( struct file *filp, const char *buff,unsigned lon
 	int32 	ret;
 	int 		i, j;
 
+	if(len>64)
+	{
+		goto errout;
+	}
 	if (buff && !copy_from_user(tmpbuf, buff, len)) {
 		tmpbuf[len] = '\0';
 		strptr=tmpbuf;
@@ -4183,7 +4721,7 @@ static int32 proc_phyReg_write( struct file *filp, const char *buff,unsigned lon
 		{
 			goto errout;
 		}
-	
+
 		if (!memcmp(cmd_addr, "read", 4))
 		{
 			tokptr = strsep(&strptr," ");
@@ -4192,22 +4730,22 @@ static int32 proc_phyReg_write( struct file *filp, const char *buff,unsigned lon
 				goto errout;
 			}
 			phyId=simple_strtol(tokptr, NULL, 0);
-			
+
 			tokptr = strsep(&strptr," ");
 			if (tokptr==NULL)
 			{
 				goto errout;
 			}
 			regId=simple_strtol(tokptr, NULL, 0);
-			
-			ret=rtl8651_getAsicEthernetPHYReg(phyId, regId, &regData); 
+
+			ret=rtl8651_getAsicEthernetPHYReg(phyId, regId, &regData);
 			if(ret==SUCCESS)
 			{
-				printk("read phyId(%d), regId(%d),regData:0x%x\n", phyId, regId, regData);
+				rtlglue_printf("read phyId(%d), regId(%d),regData:0x%x\n", phyId, regId, regData);
 			}
 			else
 			{
-				printk("error input!\n");
+				rtlglue_printf("error input!\n");
 			}
 		}
 		else if (!memcmp(cmd_addr, "write", 5))
@@ -4218,7 +4756,7 @@ static int32 proc_phyReg_write( struct file *filp, const char *buff,unsigned lon
 				goto errout;
 			}
 			phyId=simple_strtol(tokptr, NULL, 0);
-			
+
 			tokptr = strsep(&strptr," ");
 			if (tokptr==NULL)
 			{
@@ -4232,15 +4770,15 @@ static int32 proc_phyReg_write( struct file *filp, const char *buff,unsigned lon
 				goto errout;
 			}
 			regData=simple_strtol(tokptr, NULL, 0);
-		
+
 			ret=rtl8651_setAsicEthernetPHYReg(phyId, regId, regData);
 			if(ret==SUCCESS)
 			{
-				printk("Write phyId(%d), regId(%d), regData:0x%x\n", phyId, regId, regData);
+				rtlglue_printf("Write phyId(%d), regId(%d), regData:0x%x\n", phyId, regId, regData);
 			}
 			else
 			{
-				printk("error input!\n");
+				rtlglue_printf("error input!\n");
 			}
 		}
 #ifdef CONFIG_8198_PORT5_RGMII
@@ -4252,15 +4790,15 @@ static int32 proc_phyReg_write( struct file *filp, const char *buff,unsigned lon
 				goto errout;
 			}
 			regId=simple_strtol(tokptr, NULL, 16);
-			ret = rtl8370_getAsicReg(regId, &regData); 
-			
+			ret = rtl8370_getAsicReg(regId, &regData);
+
 			if(ret==0)
 			{
-				printk("rtl8370_getAsicReg: reg= %x, data= %x\n", regId, regData);
+				rtlglue_printf("rtl8370_getAsicReg: reg= %x, data= %x\n", regId, regData);
 			}
 			else
 			{
-				printk("get fail %d\n", ret);
+				rtlglue_printf("get fail %d\n", ret);
 			}
 		}
 		else if (!memcmp(cmd_addr, "8370write", 9))
@@ -4271,23 +4809,23 @@ static int32 proc_phyReg_write( struct file *filp, const char *buff,unsigned lon
 				goto errout;
 			}
 			regId=simple_strtol(tokptr, NULL, 16);
-			
+
 			tokptr = strsep(&strptr," ");
 			if (tokptr==NULL)
 			{
 				goto errout;
 			}
 			regData=simple_strtol(tokptr, NULL, 16);
-		
+
 			ret = rtl8370_setAsicReg(regId, regData);
 
 			if(ret==0)
 			{
-				printk("rtl8370_setAsicReg: reg= %x, data= %x\n", regId, regData);
+				rtlglue_printf("rtl8370_setAsicReg: reg= %x, data= %x\n", regId, regData);
 			}
 			else
 			{
-				printk("set fail %d\n", ret);
+				rtlglue_printf("set fail %d\n", ret);
 			}
 		}
 #endif
@@ -4306,7 +4844,7 @@ static int32 proc_phyReg_write( struct file *filp, const char *buff,unsigned lon
 				goto errout;
 			}
 			pageId=simple_strtol(tokptr, NULL, 0);
-			
+
 			tokptr = strsep(&strptr," ");
 			if (tokptr==NULL)
 			{
@@ -4316,7 +4854,7 @@ static int32 proc_phyReg_write( struct file *filp, const char *buff,unsigned lon
 
 			//switch page
 			if (pageId>=31)
-			{	
+			{
 				rtl8651_setAsicEthernetPHYReg( phyId, 31, 7  );
 				rtl8651_setAsicEthernetPHYReg( phyId, 30, pageId  );
 			}
@@ -4324,21 +4862,21 @@ static int32 proc_phyReg_write( struct file *filp, const char *buff,unsigned lon
 			{
 				rtl8651_setAsicEthernetPHYReg( phyId, 31, pageId  );
 			}
-	
+
 			ret=rtl8651_getAsicEthernetPHYReg(phyId, regId, &regData);
-			
+
 			if(ret==SUCCESS)
 			{
-				printk("extRead phyId(%d), pageId(%d), regId(%d), regData:0x%x\n", phyId,pageId, regId, regData);
+				rtlglue_printf("extRead phyId(%d), pageId(%d), regId(%d), regData:0x%x\n", phyId,pageId, regId, regData);
 			}
 			else
 			{
-				printk("error input!\n");
+				rtlglue_printf("error input!\n");
 			}
 
 			//change back to page 0
 			rtl8651_setAsicEthernetPHYReg(phyId, 31, 0);
-			
+
 		}
 		else if (!memcmp(cmd_addr, "extWrite", 8))
 		{
@@ -4355,7 +4893,7 @@ static int32 proc_phyReg_write( struct file *filp, const char *buff,unsigned lon
 				goto errout;
 			}
 			pageId=simple_strtol(tokptr, NULL, 0);
-			
+
 			tokptr = strsep(&strptr," ");
 			if (tokptr==NULL)
 			{
@@ -4372,7 +4910,7 @@ static int32 proc_phyReg_write( struct file *filp, const char *buff,unsigned lon
 
 			//switch page
 			if (pageId>=31)
-			{	
+			{
 				rtl8651_setAsicEthernetPHYReg( phyId, 31, 7  );
 				rtl8651_setAsicEthernetPHYReg( phyId, 30, pageId  );
 			}
@@ -4380,29 +4918,29 @@ static int32 proc_phyReg_write( struct file *filp, const char *buff,unsigned lon
 			{
 				rtl8651_setAsicEthernetPHYReg( phyId, 31, pageId  );
 			}
-	
+
 			ret=rtl8651_setAsicEthernetPHYReg(phyId, regId, regData);
-			
+
 			if(ret==SUCCESS)
 			{
-				printk("extWrite phyId(%d), pageId(%d), regId(%d), regData:0x%x\n", phyId, pageId, regId, regData);
+				rtlglue_printf("extWrite phyId(%d), pageId(%d), regId(%d), regData:0x%x\n", phyId, pageId, regId, regData);
 			}
 			else
 			{
-				printk("error input!\n");
+				rtlglue_printf("error input!\n");
 			}
-			
+
 			//change back to page 0
 			rtl8651_setAsicEthernetPHYReg(phyId, 31, 0);
 		}
 		else if (!memcmp(cmd_addr, "snr", 3))
 		{
 			uint32 	sum;
-			for (i=0;i<5;i++) 
+			for (i=0;i<5;i++)
 			{
-				if (REG32(PSRP0 + (i * 4)) & PortStatusLinkUp) 
+				if (REG32(PSRP0 + (i * 4)) & PortStatusLinkUp)
 				{
-					for (j=0, sum=0;j<10;j++) 
+					for (j=0, sum=0;j<10;j++)
 					{
 						rtl8651_getAsicEthernetPHYReg(i, 29, &regData);
 						sum += regData;
@@ -4411,11 +4949,11 @@ static int32 proc_phyReg_write( struct file *filp, const char *buff,unsigned lon
 					sum /= 10;
 					//db = -(10 * log(sum/262144));
 					//printk("  port %d SNR = %d dB\n", i, db);
-					printk("  port %d SUM = %d\n", i, sum);
+					rtlglue_printf("  port %d SUM = %d\n", i, sum);
 				}
-				else 
+				else
 				{
-					printk("  port %d is link down\n", i);
+					rtlglue_printf("  port %d is link down\n", i);
 				}
 			}
 		}
@@ -4427,8 +4965,8 @@ static int32 proc_phyReg_write( struct file *filp, const char *buff,unsigned lon
 #endif
 			for (port=0; port<5; port++)
 			{
-				printk("==========================================\n");
-				
+				rtlglue_printf("==========================================\n");
+
 #ifdef CONFIG_RTL_8196C
 				for(page=0;page<4;page++)
 				{
@@ -4436,114 +4974,281 @@ static int32 proc_phyReg_write( struct file *filp, const char *buff,unsigned lon
 					rtl8651_setAsicEthernetPHYReg(port, 31, page);
 					for(reg=0;reg<32;reg++)
 					{
-						rtl8651_getAsicEthernetPHYReg( port, reg, &regData);	
-						printk("port:%d,page:%d,regId:%d,regData:0x%x\n",port,page,reg,regData);
+						rtl8651_getAsicEthernetPHYReg( port, reg, &regData);
+						rtlglue_printf("port:%d,page:%d,regId:%d,regData:0x%x\n",port,page,reg,regData);
 					}
 					if(page!=3)
 					{
-						printk("------------------------------------------\n");
+						rtlglue_printf("------------------------------------------\n");
 					}
 					//change back to page 0
 					rtl8651_setAsicEthernetPHYReg(port, 31, 0 );
 				}
-#elif defined(CONFIG_RTL_8198)
-				//set pageNum {0 1 2 3 4 5 6 32 33 34 35 36 40 44 45 46 64 65 66 69 70 80 81 161}       
+#elif defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+				//set pageNum {0 1 2 3 4 5 6 32 33 34 35 36 40 44 45 46 64 65 66 69 70 80 81 161}
 				for (i=0; i<24; i++)
 					getPhyByPortPage(port,  _8198_phy_page[i]);
-#endif				
+#endif
 			}
 		}
 	}
 	else
 	{
 errout:
-		printk("error input!\n");
+		rtlglue_printf("error input!\n");
 	}
 
 	return len;
 }
 
-
-static int32 storm_read( char *page, char **start, off_t off, int count, int *eof, void *data )
+//MACCR porc--------------------------------------------------------------------------------------------
+static int32 mac_config_read( char *page, char **start, off_t off, int count, int *eof, void *data )
 {
 	int		len;
 	uint32	regData;
-	uint32 port;
-	uint32 totalExtPortNum=3;	
-	len = sprintf(page, "Dump storm control info:\n");
-
-	regData = READ_MEM32(BSCR);
-	len += sprintf(page+len, "rate(%d)\n",regData*100/30360);
+	uint32	data0;
+	
+	len = sprintf(page, "MAC Configuration Register Info:\n");
+	regData = READ_MEM32(MACCR);
+	
+	data0 = regData & IPG_SEL;
+	len += sprintf(page+len, "IfgSel:  ");
+	if (data0)
+		len += sprintf(page+len, "internal counter =352\n");
+	else
+		len += sprintf(page+len, "internal counter =480\n");
+	
+	data0 = regData & INFINITE_PAUSE_FRAMES  ;
+	len += sprintf(page+len, "INFINITE_PAUSE_FRAMES:  ");
+	if (data0)
+		len += sprintf(page+len, "Infinite pause frame count\n");
+	else
+		len += sprintf(page+len, "Maximum of 128 consecutive pause frames\n");
 
-	for ( port = 0; port < RTL8651_PORT_NUMBER + totalExtPortNum; port++ )
-	{
-		regData = READ_MEM32(PCRP0+port*4);
-		len+= sprintf(page+len,"port%d, %s BCSC, %s BC, %s MC\n", port,regData&ENBCSC?"enable":"disable",regData&BCSC_ENBROADCAST?"enable":"disable",
-					regData&BCSC_ENMULTICAST?"enable":"disable");
-	}
+	data0= regData & LONG_TXE;
+	len += sprintf(page+len, "LONG_TXE:  ");
+	if (data0)
+		len += sprintf(page+len, "Carrier-based backpressure\n");
+	else
+		len += sprintf(page+len, "Collision-based backpressure\n");
 
-	if (len <= off+count) 
-		*eof = 1;
+	data0= regData & EN_48_DROP;
+	len += sprintf(page+len, "EN_48_DROP:  ");
+	if (data0)
+		len += sprintf(page+len, "Enabled\n");
+	else
+		len += sprintf(page+len, "Disabled\n");
+	
+	data0= (regData & SELIPG_MASK)>>SELIPG_OFFSET;
+	len += sprintf(page+len, "SELIPG:  ");
+	if(data0==0x00)
+		len += sprintf(page+len, "7 byte-time\n");
+	else if(data0==0x01)
+		len += sprintf(page+len, "8 byte-time\n");
+	else if(data0==0x10)
+		len += sprintf(page+len, "10 byte-time\n");
+	else
+		len += sprintf(page+len, "12 byte-time\n");
+	
+	data0= (regData & CF_SYSCLK_SEL_MASK)>>CF_SYSCLK_SEL_OFFSET;
+	len += sprintf(page+len, "CF_SYSCLK_SEL:  ");
+	if(data0==0x00)
+		len += sprintf(page+len, "50MHz\n");
+	else if(data0==0x01)
+		len += sprintf(page+len, "100MHz\n");
+	else
+		len += sprintf(page+len, "reserved status\n");
 
-	*start = page + off;
-	len -= off;
+	data0= (regData & CF_FCDSC_MASK)>>CF_FCDSC_OFFSET;
+	len += sprintf(page+len, "CF_FCDSC:  %d pages\n",data0);
 
-	if (len>count) 
-		len = count;
+	data0= (regData & CF_RXIPG_MASK);
+	len += sprintf(page+len, "CF_RXIPG:  %d pkts\n",data0);
+	
+	return len;
 
-	if (len<0) len = 0;
+}
 
-	return len;
+static int32 mac_config_write(struct file *filp, const char *buff,unsigned long len, void *data )
+{
+		return len;
 }
 
-static int32 storm_write(struct file *file, const char *buffer,
-		      unsigned long count, void *data)
+//FC threshold--------------------------------------------------------------------------
+static int32 fc_threshold_read( char *page, char **start, off_t off, int count, int *eof, void *data )
 {
-	uint32 tmpBuf[32];
-	uint32 stormCtrlType=0x3;//mc & bc
-	uint32 enableStormCtrl=FALSE;
-	uint32 percentage=0;
-	uint32 uintVal;
 
-	if (buffer && !copy_from_user(tmpBuf, buffer, count))
+	int 	len;
+	uint32	regData;
+	uint32	data0;
+	int port;	
+	int group=3;
+	len = sprintf(page, "Dump FC threshold Information:\n");
+
+	//SBFCR0
+	regData = READ_MEM32(SBFCR0);
+	data0 = regData & S_DSC_RUNOUT_MASK;
+	len += sprintf(page+len, "S_DSC_RUNOUT:%d\n",data0);
+	//SBFCR1
+	regData = READ_MEM32(SBFCR1);
+	data0 = (regData & SDC_FCOFF_MASK)>>SDC_FCOFF_OFFSET;
+	len += sprintf(page+len, "SDC_FCOFF:%d, ",data0);
+	data0 = (regData & SDC_FCON_MASK)>>SDC_FCON_OFFSET;
+	len += sprintf(page+len, "SDC_FCON:%d\n",data0);
+	//SBFCR2
+	regData = READ_MEM32(SBFCR2);
+	data0 = (regData & S_Max_SBuf_FCOFF_MASK)>>S_Max_SBuf_FCOFF_OFFSET;
+	len += sprintf(page+len, "S_MaxSBuf_FCON:%d, ",data0);
+	data0 = (regData & S_Max_SBuf_FCON_MASK)>>S_Max_SBuf_FCON_OFFSET;
+	len += sprintf(page+len, "S_MaxSBuf_FCOFF:%d\n",data0);
+	//FCCR0,FCCR1
+	regData = READ_MEM32(FCCR0);
+	data0 =(regData & Q_P0_EN_FC_MASK)>>(Q_P0_EN_FC_OFFSET);	
+	len += sprintf(page+len, "Q_P0_EN_FC:%0x, ",data0);	
+	data0 =(regData & Q_P1_EN_FC_MASK)>>(Q_P1_EN_FC_OFFSET);	
+	len += sprintf(page+len, "Q_P1_EN_FC:%0x, ",data0);	
+	data0 =(regData & Q_P2_EN_FC_MASK)>>(Q_P2_EN_FC_OFFSET);	
+	len += sprintf(page+len, "Q_P2_EN_FC:%0x\n",data0);
+	data0 =(regData & Q_P3_EN_FC_MASK)>>(Q_P3_EN_FC_OFFSET);	
+	len += sprintf(page+len, "Q_P3_EN_FC:%0x, ",data0);
+	regData = READ_MEM32(FCCR1);
+	data0 =(regData & Q_P4_EN_FC_MASK)>>(Q_P4_EN_FC_OFFSET);	
+	len += sprintf(page+len, "Q_P4_EN_FC:%0x, ",data0);	
+	regData = READ_MEM32(FCCR0);
+	data0 =(regData & Q_P5_EN_FC_MASK)>>(Q_P5_EN_FC_OFFSET);	
+	len += sprintf(page+len, "Q_P5_EN_FC:%0x\n",data0);	
+	//PQPLGR
+	regData = READ_MEM32(PQPLGR);
+	data0 =regData & QLEN_GAP_MASK;
+	len += sprintf(page+len, "QLEN_GAP:%d\n",data0);
+	//QRR
+	regData = READ_MEM32(QRR);
+	data0 =regData & QRST;
+	len += sprintf(page+len, "QRST:%d\n",data0);
+	//IQFCTCR
+	regData = READ_MEM32(IQFCTCR);
+	data0 =(regData & IQ_DSC_FCON_MASK)>>IQ_DSC_FCON_OFFSET;
+	len += sprintf(page+len, "IQ_DSC_FCON:%d, ",data0);
+	data0 =(regData & IQ_DSC_FCOFF_MASK)>>IQ_DSC_FCOFF_OFFSET;
+	len += sprintf(page+len, "IQ_DSC_FCOFF:%d\n",data0);
+	//QNUMCR
+	regData = READ_MEM32(QNUMCR);
+	len += sprintf(page+len,"The number of output queue for port(0~6) :\n");
+	data0=(regData & P0QNum_MASK )>>(P0QNum_OFFSET);
+	len += sprintf(page+len, "P0QNum%d, ",data0);
+	data0=(regData & P1QNum_MASK )>>(P1QNum_OFFSET);
+	len += sprintf(page+len, "P1QNum%d, ",data0);
+	data0=(regData & P2QNum_MASK )>>(P2QNum_OFFSET);
+	len += sprintf(page+len, "P2QNum%d, ",data0);
+	data0=(regData & P3QNum_MASK )>>(P3QNum_OFFSET);
+	len += sprintf(page+len, "P3QNum%d, ",data0);
+	data0=(regData & P4QNum_MASK )>>(P4QNum_OFFSET);
+	len += sprintf(page+len, "P4QNum%d, ",data0);
+	data0=(regData & P5QNum_MASK )>>(P5QNum_OFFSET);
+	len += sprintf(page+len, "P5QNum%d, ",data0);
+	data0=(regData & P6QNum_MASK )>>(P6QNum_OFFSET);
+	len += sprintf(page+len, "P6QNum%d\n",data0);
+	//per port   
+	for(port=PHY0;port<=CPU;port++)
 	{
-		tmpBuf[count-1]=0;
-		uintVal=simple_strtoul((char *)tmpBuf, NULL, 0);
-		printk("%s(%d) uintval(%u) \n",__FUNCTION__,__LINE__,uintVal);//Added for test
-		if(uintVal>100)
-		{
-			enableStormCtrl=FALSE;
-			percentage=0;
-		}
+		if (port==CPU)
+		len += sprintf(page+len, "\nCPUPort\n");
 		else
-		{
-			enableStormCtrl=TRUE;
-			percentage=uintVal;
+		len += sprintf(page+len, "\nPort%d\n", port);
+		
+		regData = READ_MEM32(PBFCR0+((port)<<2));
+		data0 = (regData & P_MaxDSC_FCOFF_MASK)>>P_MaxDSC_FCOFF_OFFSET;
+		len += sprintf(page+len, "   P_MaxDSC_FCOFF:%d, ",data0);
+		data0 = (regData & P_MaxDSC_FCON_MASK)>>P_MaxDSC_FCON_OFFSET;
+		len += sprintf(page+len, "P_MaxDSC_FCON:%d\n",data0);
+		//if(port<CPU)
+		{
+			for (group=GR0;group<=GR2;group++)
+			{
+				len += sprintf(page+len, "   Port%dGroup%d\n",port,group);
+				/* QDBFCRP0G0,QDBFCRP0G1,QDBFCRP0G2
+				 * QDBFCRP1G0,QDBFCRP1G1,QDBFCRP1G2
+				 * QDBFCRP2G0,QDBFCRP2G1,QDBFCRP2G2
+				 * QDBFCRP3G0,QDBFCRP3G1,QDBFCRP3G2
+				 * QDBFCRP4G0,QDBFCRP4G1,QDBFCRP4G2
+				 * QDBFCRP5G0,QDBFCRP5G1,QDBFCRP5G2
+				 * - Queue-Descriptor=Based Flow Control Threshold for Port 0 Group 0 */
+				regData =READ_MEM32(QDBFCRP0G0+((port)<<2)+((group)<<2));
+				//len+=sprintf(page+len,"address:%0x",(QDBFCRP0G0+((port)<<2)+((group)<<2)));
+				data0 = (regData & QG_DSC_FCOFF_MASK)>>QG_DSC_FCOFF_OFFSET;
+				len += sprintf(page+len, "   QG_DSC_FCOFF:%d, ",data0);
+				data0 = (regData & QG_DSC_FCON_MASK)>>QG_DSC_FCON_OFFSET;
+				len += sprintf(page+len, "QG_DSC_FCON:%d, ",data0);
+
+				/* QPKTFCRP0G0,QPKTFCRP0G1,QPKTFCRP0G2
+				 * QPKTFCRP1G0,QPKTFCRP1G1,QPKTFCRP1G2
+				 * QPKTFCRP2G0,QPKTFCRP2G1,QPKTFCRP2G2
+				 * QPKTFCRP3G0,QPKTFCRP3G1,QPKTFCRP3G2
+				 * QPKTFCRP4G0,QPKTFCRP4G1,QPKTFCRP4G2
+				 * QPKTFCRP5G0,QPKTFCRP5G1,QPKTFCRP5G2
+				   - Queue-Packet-Based Flow Control Register for Port 0 Group 0 */
+				regData =READ_MEM32(QPKTFCRP0G0+((port)<<2)+((group)<<2));
+				//len+=sprintf(page+len,"address:%0x",(QPKTFCRP0G0+((port)<<2)+((group)<<2)));
+				data0 = (regData & QG_QLEN_FCOFF_MASK)>>QG_QLEN_FCOFF_OFFSET;
+				len += sprintf(page+len, "QG_QLEN_FCOFF:%d, ",data0);
+				data0 = (regData & QG_QLEN_FCON_MASK)>>QG_QLEN_FCON_OFFSET;
+				len += sprintf(page+len, "QG_QLEN_FCON:%d\n",data0);
+				
+			}	
 		}
-		//printk("%s(%d),enableStormCtrl=%d,percentage=%d\n",__FUNCTION__,__LINE__,
-		//	enableStormCtrl,percentage);//Added for test
-		rtl865x_setStormControl(stormCtrlType,enableStormCtrl,percentage);
-		return count;
 	}
-	return -EFAULT;
+
+	return len;
+}
+
+static int32 fc_threshold_write(struct file *filp, const char *buff,unsigned long len, void *data )
+{
+	return len;
 }
 
+#endif
+
+
 int32 rtl865x_proc_debug_init(void)
 {
 	int32 retval;
+
+#if defined(CONFIG_RTL_LOG_DEBUG)
+	extern void log_print_proc_init(void);
+	log_print_proc_init();
+#endif
 	rtl865x_proc_dir = proc_mkdir(RTL865X_PROC_DIR_NAME,NULL);
 	if(rtl865x_proc_dir)
 	{
+		#ifdef CONFIG_RTL_PROC_DEBUG
+		/*stats*/
+		{
+			stats_debug_entry = create_proc_entry("stats",0,rtl865x_proc_dir);
+			if(stats_debug_entry != NULL)
+			{
+				stats_debug_entry->read_proc = stats_debug_entry_read;
+				stats_debug_entry->write_proc= stats_debug_entry_write;
+				
+				retval = SUCCESS;
+			}
+			else
+			{
+				rtlglue_printf("can't create proc entry for stats");
+				retval = FAILED;
+				goto out;
+			}
+		}
+
 		/*vlan*/
 		{
 			vlan_entry = create_proc_entry("vlan",0,rtl865x_proc_dir);
 			if(vlan_entry != NULL)
 			{
 				//vlan_entry->read_proc = vlan_read;
-				//vlan_entry->write_proc= vlan_write;				
+				//vlan_entry->write_proc= vlan_write;
 				vlan_entry->proc_fops = &vlan_single_seq_file_operations;
 
-				retval = SUCCESS;				
+				retval = SUCCESS;
 			}
 			else
 			{
@@ -4561,7 +5266,7 @@ int32 rtl865x_proc_debug_init(void)
 				netif_entry->read_proc = netif_read;
 				netif_entry->write_proc= netif_write;
 
-				retval = SUCCESS;				
+				retval = SUCCESS;
 			}
 			else
 			{
@@ -4582,7 +5287,7 @@ int32 rtl865x_proc_debug_init(void)
 				*/
 				acl_entry->proc_fops = &acl_single_seq_file_operations;
 
-				retval = SUCCESS;				
+				retval = SUCCESS;
 			}
 			else
 			{
@@ -4599,7 +5304,7 @@ int32 rtl865x_proc_debug_init(void)
 				advRt_entry->read_proc = advRt_read;
 				advRt_entry->write_proc= advRt_write;
 				//advRt_entry->owner = THIS_MODULE;
-				retval = SUCCESS;				
+				retval = SUCCESS;
 			}
 			else
 			{
@@ -4631,10 +5336,10 @@ int32 rtl865x_proc_debug_init(void)
 		{
 			acl_chains_entry = create_proc_entry("soft_aclChains",0,rtl865x_proc_dir);
 			if(acl_chains_entry != NULL)
-			{				
+			{
 				acl_chains_entry->proc_fops = &aclChains_single_seq_file_operations;
 
-				retval = SUCCESS;				
+				retval = SUCCESS;
 			}
 			else
 			{
@@ -4657,7 +5362,7 @@ int32 rtl865x_proc_debug_init(void)
 				*/
 				qos_rule_entry->proc_fops = &qosRule_single_seq_file_operations;
 
-				retval = SUCCESS;				
+				retval = SUCCESS;
 			}
 			else
 			{
@@ -4675,7 +5380,7 @@ int32 rtl865x_proc_debug_init(void)
 				hs_entry->read_proc = hs_read;
 				hs_entry->write_proc= hs_write;
 
-				retval = SUCCESS;				
+				retval = SUCCESS;
 			}
 			else
 			{
@@ -4695,7 +5400,7 @@ int32 rtl865x_proc_debug_init(void)
 			}
 			else
 			{
-				printk("can't create nic_mbuf entry for hs");
+				rtlglue_printf("can't create nic_mbuf entry for hs");
 				retval = FAILED;
 				goto out;
 			}
@@ -4708,7 +5413,7 @@ int32 rtl865x_proc_debug_init(void)
 			{
 				rxRing_entry->proc_fops = &rxRing_single_seq_file_operations;
 
-				retval = SUCCESS;				
+				retval = SUCCESS;
 			}
 			else
 			{
@@ -4725,7 +5430,7 @@ int32 rtl865x_proc_debug_init(void)
 			{
 				txRing_entry->proc_fops = &txRing_single_seq_file_operations;
 
-				retval = SUCCESS;				
+				retval = SUCCESS;
 			}
 			else
 			{
@@ -4742,16 +5447,16 @@ int32 rtl865x_proc_debug_init(void)
 			{
 				mbuf_entry->proc_fops = &mbuf_single_seq_file_operations;
 
-				retval = SUCCESS;				
+				retval = SUCCESS;
 			}
 			else
 			{
-				rtlglue_printf("can't create mbuf entry for hs");
+				rtlglue_printf("can't create mbuf entry for mbufRing");
 				retval = FAILED;
 				goto out;
 			}
 		}
-		
+
 		/*pvid*/
 		{
 			pvid_entry = create_proc_entry("pvid",0,rtl865x_proc_dir);
@@ -4760,7 +5465,7 @@ int32 rtl865x_proc_debug_init(void)
 				pvid_entry->read_proc = pvid_read;
 				pvid_entry->write_proc= pvid_write;
 
-				retval = SUCCESS;				
+				retval = SUCCESS;
 			}
 			else
 			{
@@ -4778,7 +5483,7 @@ int32 rtl865x_proc_debug_init(void)
 				mirrorPort_entry->read_proc = mirrorPort_read;
 				mirrorPort_entry->write_proc= mirrorPort_write;
 
-				retval = SUCCESS;				
+				retval = SUCCESS;
 			}
 			else
 			{
@@ -4788,24 +5493,6 @@ int32 rtl865x_proc_debug_init(void)
 			}
 		}
 
-		/*memory*/
-		{
-			mem_entry = create_proc_entry("memory",0,rtl865x_proc_dir);
-			if(mem_entry != NULL)
-			{
-				mem_entry->read_proc = proc_mem_read;
-				mem_entry->write_proc= proc_mem_write;
-
-				retval = SUCCESS;				
-			}
-			else
-			{
-				rtlglue_printf("can't create proc entry for memory");
-				retval = FAILED;
-				goto out;
-			}
-		}
-			
 		/*l2*/
 		{
 			l2_entry = create_proc_entry("l2", 0, rtl865x_proc_dir);
@@ -4823,8 +5510,8 @@ int32 rtl865x_proc_debug_init(void)
 				goto out;
 			}
 		}
-		
-#if defined (CONFIG_RTL_HARDWARE_MULTICAST)		
+
+#if defined (CONFIG_RTL_HARDWARE_MULTICAST)
 		hwMCast_entry=create_proc_entry("hwMCast", 0, rtl865x_proc_dir);
 		if(hwMCast_entry != NULL)
 		{
@@ -4832,7 +5519,7 @@ int32 rtl865x_proc_debug_init(void)
 			hwMCast_entry->write_proc = rtl865x_proc_hw_mcast_write;
 			retval = SUCCESS;
 		}
-		
+
 		swMCast_entry=create_proc_entry("swMCast", 0, rtl865x_proc_dir);
 		if(swMCast_entry != NULL)
 		{
@@ -4840,7 +5527,7 @@ int32 rtl865x_proc_debug_init(void)
 			swMCast_entry->write_proc = rtl865x_proc_sw_mcast_write;
 			retval = SUCCESS;
 		}
-#endif	
+#endif
 
 
 #ifdef CONFIG_RTL_LAYERED_DRIVER_L3
@@ -4861,7 +5548,7 @@ int32 rtl865x_proc_debug_init(void)
 				goto out;
 			}
 		}
-		
+
 		/*nextHop*/
 		{
 			nexthop_entry= create_proc_entry("nexthop", 0, rtl865x_proc_dir);
@@ -4957,7 +5644,7 @@ int32 rtl865x_proc_debug_init(void)
 				goto out;
 			}
 		}
-		
+
 		/*software napt*/
 #if defined(CONFIG_RTL_LAYERED_DRIVER_L4) && defined(CONFIG_RTL_8198)
 		{
@@ -5021,24 +5708,6 @@ int32 rtl865x_proc_debug_init(void)
 			}
 		}
 #endif
-		/*diagnostic*/
-		{
-			diagnostic_entry= create_proc_entry("diagnostic", 0, rtl865x_proc_dir);
-			if(diagnostic_entry != NULL)
-			{
-				diagnostic_entry->read_proc = diagnostic_read;
-				diagnostic_entry->write_proc = diagnostic_write;
-
-				retval = SUCCESS;
-			}
-			else
-			{
-				rtlglue_printf("can't create proc entry for diagnostic");
-				retval = FAILED;
-				goto out;
-			}
-		}
-
 		/*port_bandwidth*/
 		{
 			port_bandwidth_entry= create_proc_entry("port_bandwidth", 0, rtl865x_proc_dir);
@@ -5074,44 +5743,7 @@ int32 rtl865x_proc_debug_init(void)
 				goto out;
 			}
 		}
-		
-		/*port_status*/
-		{
-			port_status_entry= create_proc_entry("port_status", 0, rtl865x_proc_dir);
-			if(port_status_entry != NULL)
-			{
-				port_status_entry->read_proc = port_status_read;
-				port_status_entry->write_proc = port_status_write;
-
-				retval = SUCCESS;
-			}
-			else
-			{
-				rtlglue_printf("can't create proc entry for port_status");
-				retval = FAILED;
-				goto out;
-			}
-		}
-
-		/*phy*/
-		{
-			phyReg_entry= create_proc_entry("phyReg", 0, rtl865x_proc_dir);
-			if(phyReg_entry != NULL)
-			{
-				phyReg_entry->read_proc = proc_phyReg_read;
-				phyReg_entry->write_proc = proc_phyReg_write;
-
-				retval = SUCCESS;
-			}
-			else
-			{
-				rtlglue_printf("can't create proc entry for phyTeg");
-				retval = FAILED;
-				goto out;
-			}
-		}
-
-			/*priority_decision*/
+		/*priority_decision*/
 		{
 			priority_decision_entry= create_proc_entry("priority_decision", 0, rtl865x_proc_dir);
 			if(priority_decision_entry != NULL)
@@ -5156,15 +5788,6 @@ int32 rtl865x_proc_debug_init(void)
 			retval = SUCCESS;
 		}
 		#endif
-			
-
-		asicCnt_entry=create_proc_entry("asicCounter", 0, rtl865x_proc_dir);
-		if(asicCnt_entry != NULL)
-		{
-			asicCnt_entry->read_proc = rtl865x_proc_mibCounter_read;
-			asicCnt_entry->write_proc = rtl865x_proc_mibCounter_write;
-			retval = SUCCESS;
-		}
 
 #if defined CONFIG_RTL_IGMP_SNOOPING
 		igmp_entry=create_proc_entry("igmp", 0, rtl865x_proc_dir);
@@ -5188,7 +5811,143 @@ int32 rtl865x_proc_debug_init(void)
 			prive_skb_debug_entry->write_proc = rtl819x_proc_priveSkbDebug_write;
 			retval = SUCCESS;
 		}
-		/*	#endif	*/
+		#endif
+
+#if defined(CONFIG_RTL_PROC_DEBUG)||defined(CONFIG_RTL_DEBUG_TOOL)
+		/*memory*/
+		{
+			mem_entry = create_proc_entry("memory",0,rtl865x_proc_dir);
+			if(mem_entry != NULL)
+			{
+				mem_entry->read_proc = proc_mem_read;
+				mem_entry->write_proc= proc_mem_write;
+
+				retval = SUCCESS;
+			}
+			else
+			{
+				rtlglue_printf("can't create proc entry for memory");
+				retval = FAILED;
+				goto out;
+			}
+		}
+		/*diagnostic*/
+		{
+			diagnostic_entry= create_proc_entry("diagnostic", 0, rtl865x_proc_dir);
+			if(diagnostic_entry != NULL)
+			{
+				diagnostic_entry->read_proc = diagnostic_read;
+				diagnostic_entry->write_proc = diagnostic_write;
+
+				retval = SUCCESS;
+			}
+			else
+			{
+				rtlglue_printf("can't create proc entry for diagnostic");
+				retval = FAILED;
+				goto out;
+			}
+		}
+		/*port_status*/
+		{
+			port_status_entry= create_proc_entry("port_status", 0, rtl865x_proc_dir);
+			if(port_status_entry != NULL)
+			{
+				port_status_entry->read_proc = port_status_read;
+				port_status_entry->write_proc = port_status_write;
+
+				retval = SUCCESS;
+			}
+			else
+			{
+				rtlglue_printf("can't create proc entry for port_status");
+				retval = FAILED;
+				goto out;
+			}
+		}
+
+		/*phy*/
+		{
+			phyReg_entry= create_proc_entry("phyReg", 0, rtl865x_proc_dir);
+			if(phyReg_entry != NULL)
+			{
+				phyReg_entry->read_proc = proc_phyReg_read;
+				phyReg_entry->write_proc = proc_phyReg_write;
+
+				retval = SUCCESS;
+			}
+			else
+			{
+				rtlglue_printf("can't create proc entry for phyTeg");
+				retval = FAILED;
+				goto out;
+			}
+		}
+		/*asicCnt*/
+		{
+				asicCnt_entry=create_proc_entry("asicCounter", 0, rtl865x_proc_dir);
+			if(asicCnt_entry != NULL)
+			{
+				asicCnt_entry->read_proc = rtl865x_proc_mibCounter_read;
+				asicCnt_entry->write_proc = rtl865x_proc_mibCounter_write;
+				retval = SUCCESS;
+			}
+		}
+
+		/* indirect access for special phy register */
+		{
+			mmd_entry= create_proc_entry("mmd", 0, rtl865x_proc_dir);
+			if(mmd_entry != NULL)
+			{
+				mmd_entry->read_proc = proc_mmd_read;
+				mmd_entry->write_proc = proc_mmd_write;
+
+				retval = SUCCESS;
+			}
+			else
+			{
+				rtlglue_printf("can't create proc entry for mmd");
+				retval = FAILED;
+				goto out;
+			}
+		}
+
+		/*maccr*/
+		{
+			mac_entry=create_proc_entry("mac", 0, rtl865x_proc_dir);
+			if(mac_entry != NULL)
+			{
+				mac_entry->read_proc = mac_config_read;
+				mac_entry->write_proc = mac_config_write;
+				retval = SUCCESS;
+			}
+			else
+			{
+				rtlglue_printf("can't create proc entry for mac");
+				retval = FAILED;
+				goto out;
+			}
+
+		}
+		/*FC threshold*/
+		{
+			fc_threshold_entry=create_proc_entry("fc_threshold", 0, rtl865x_proc_dir);
+			if(fc_threshold_entry != NULL)
+			{
+				fc_threshold_entry->read_proc = fc_threshold_read;
+				fc_threshold_entry->write_proc = fc_threshold_write;
+				retval = SUCCESS;
+			}
+			else
+			{
+				rtlglue_printf("can't create proc entry for fc_threshold");
+				retval = FAILED;
+				goto out;
+			}
+
+		}
+#endif	
+			
 	}
 	else
 	{
@@ -5197,15 +5956,22 @@ int32 rtl865x_proc_debug_init(void)
 out:
 	if(retval == FAILED)
 		rtl865x_proc_debug_cleanup();
-	
-	return retval;	
-	
+
+	return retval;
+
 }
 
 int32 rtl865x_proc_debug_cleanup(void)
 {
 	if(rtl865x_proc_dir)
 	{
+#ifdef CONFIG_RTL_PROC_DEBUG
+		
+		if(stats_debug_entry)
+		{
+			remove_proc_entry("stats",rtl865x_proc_dir);
+			stats_debug_entry = NULL;
+		}	
 		if(vlan_entry)
 		{
 			remove_proc_entry("vlan",rtl865x_proc_dir);
@@ -5281,12 +6047,7 @@ int32 rtl865x_proc_debug_cleanup(void)
 			l2_entry = NULL;
 		}
 
-		if(mem_entry)
-		{
-			remove_proc_entry("memory", mem_entry);
-			mem_entry = NULL;
-		}
-
+		
 		if(arp_entry)
 		{
 			remove_proc_entry("arp", rtl865x_proc_dir);
@@ -5321,12 +6082,6 @@ int32 rtl865x_proc_debug_cleanup(void)
 		{
 			remove_proc_entry("napt", rtl865x_proc_dir);
 		}
-
-		if (diagnostic_entry)
-		{
-			remove_proc_entry("diagnostic", rtl865x_proc_dir);
-		}
-
 		if (port_bandwidth_entry)
 		{
 			remove_proc_entry("port_bandwidth", rtl865x_proc_dir);
@@ -5336,16 +6091,6 @@ int32 rtl865x_proc_debug_cleanup(void)
 		{
 			remove_proc_entry("queue_bandwidth", rtl865x_proc_dir);
 		}
-
-		if (port_status_entry)
-		{
-			remove_proc_entry("port_status", rtl865x_proc_dir);
-		}
-
-		if (phyReg_entry)
-		{
-			remove_proc_entry("phyReg", rtl865x_proc_dir);
-		}
 		if (priority_decision_entry)
 		{
 			remove_proc_entry("priority_decision", rtl865x_proc_dir);
@@ -5382,18 +6127,14 @@ int32 rtl865x_proc_debug_cleanup(void)
 		{
 			remove_proc_entry("hwMCast", rtl865x_proc_dir);
 		}
-		
+
 #if defined (CONFIG_RTL_HARDWARE_MULTICAST)
 		if(swMCast_entry != NULL)
 		{
 			remove_proc_entry("swMCast", rtl865x_proc_dir);
 		}
 #endif
-		if(asicCnt_entry != NULL)
-		{
-			remove_proc_entry("asicCounter", rtl865x_proc_dir);
-		}
-
+		
 #if defined (CONFIG_RTL_IGMP_SNOOPING)
 		if(igmp_entry!=NULL)
 		{
@@ -5414,13 +6155,55 @@ int32 rtl865x_proc_debug_cleanup(void)
 			remove_proc_entry("priveSkbDebug", rtl865x_proc_dir);
 		}
 		/*#endif*/
+#endif
+
+#if defined(CONFIG_RTL_PROC_DEBUG)||defined(CONFIG_RTL_DEBUG_TOOL)
+		if(mem_entry)
+		{
+			remove_proc_entry("memory", mem_entry);
+			mem_entry = NULL;
+		}
+		if (diagnostic_entry)
+		{
+			remove_proc_entry("diagnostic", rtl865x_proc_dir);
+		}
+		if (port_status_entry)
+		{
+			remove_proc_entry("port_status", rtl865x_proc_dir);
+		}
+		if (phyReg_entry)
+		{
+			remove_proc_entry("phyReg", rtl865x_proc_dir);
+		}
+		
+		if (mmd_entry)
+		{
+			remove_proc_entry("mmd", rtl865x_proc_dir);
+		}
+		if(asicCnt_entry != NULL)
+		{
+			remove_proc_entry("asicCounter", rtl865x_proc_dir);
+		}
+		if(mac_entry != NULL)
+		{
+			remove_proc_entry("mac",rtl865x_proc_dir);
+		}
+	
+		if(fc_threshold_entry != NULL)
+		{
+			remove_proc_entry("fc_threshold", rtl865x_proc_dir);
+		}
+
+#endif
+		
+		
 
 		remove_proc_entry(RTL865X_PROC_DIR_NAME, NULL);
 		rtl865x_proc_dir = NULL;
-				
+
 	}
 
-	return SUCCESS;	
+	return SUCCESS;
 }
 
 
diff --git a/drivers/net/rtl819x/rtl865xc_swNic.c b/drivers/net/rtl819x/rtl865xc_swNic.c
index 1c983f9..5bcd7b7 100644
--- a/drivers/net/rtl819x/rtl865xc_swNic.c
+++ b/drivers/net/rtl819x/rtl865xc_swNic.c
@@ -1,48 +1,18 @@
 /*
 * ----------------------------------------------------------------
-* Copyright c                  Realtek Semiconductor Corporation, 2002  
-* All rights reserved.
-* 
 * $Header: /home/cvsroot/linux-2.6.19/linux-2.6.x/drivers/net/re865x/rtl865xc_swNic.c,v 1.11 2008/04/11 10:49:14 bo_zhao Exp $
 *
 * Abstract: Switch core polling mode NIC driver source code.
 *
 * $Author: bo_zhao $
 *
-* $Log: rtl865xc_swNic.c,v $
-* Revision 1.11  2008/04/11 10:49:14  bo_zhao
-* * restore the original cache flush
-*
-* Revision 1.10  2008/04/11 10:12:38  bo_zhao
-* *: swap nic drive to 8186 style
-*
-* Revision 1.6  2008/02/22 05:31:52  joeylin
-* set one VLAN group for Bridge/WISP mode, and fix the issue:
-* WAN port PC can not ping br0 (192.168.1.254) in Bridge/WISP mode
-*
-* Revision 1.5  2008/02/15 09:52:46  forrest
-* 1. Add hardware accelerated PPTP processing. 2. Fine tune some hardware NAT to be compatible to hardware accelerated PPTP.
-*
-* Revision 1.4  2007/12/08 08:24:26  davidhsu
-* Adjust tx desc size. Hide error message
-*
-* Revision 1.3  2007/12/04 12:00:18  joeylin
-* add hardware NAT feature
-*
-* Revision 1.2  2007/11/11 02:51:24  davidhsu
-* Fix the bug that do not fre rx skb in rx descriptor when driver is shutdown
-*
-* Revision 1.1.1.1  2007/08/06 10:04:52  root
-* Initial import source to CVS
-*
-* Revision 1.11  2007/03/27 12:51:07  michaelhuang
-* +: add function swNic_send_portmbr for FT2
-*
-*
+*  Copyright (c) 2011 Realtek Semiconductor Corp.
 *
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License version 2 as
+*  published by the Free Software Foundation.
 * ---------------------------------------------------------------
 */
-
 #include <linux/skbuff.h>
 #include <net/rtl/rtl_types.h>
 #include <net/rtl/rtl_glue.h>
@@ -56,14 +26,20 @@
 #ifdef	CONFIG_RTL865X_ROMEPERF
 #include "romeperf.h"
 #endif
+#if defined(CONFIG_RTL_HW_VLAN_SUPPORT)
+#include <linux/if_ether.h>
+#endif
 
+#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+#include <linux/if_ether.h>
+#endif
 
 extern void (*_dma_cache_wback_inv)(unsigned long start, unsigned long size);
 
 /* RX Ring */
 static uint32*  rxPkthdrRing[RTL865X_SWNIC_RXRING_HW_PKTDESC];                 /* Point to the starting address of RX pkt Hdr Ring */
 __DRAM_FWD static uint32   rxPkthdrRingCnt[RTL865X_SWNIC_RXRING_HW_PKTDESC];              /* Total pkt count for each Rx descriptor Ring */
-#if	defined(DELAY_REFILL_ETH_RX_BUF)	
+#if	defined(DELAY_REFILL_ETH_RX_BUF)
 __DRAM_FWD static uint32   rxPkthdrRefillThreshold[RTL865X_SWNIC_RXRING_HW_PKTDESC];              /* Ether refill threshold for each Rx descriptor Ring */
 #endif
 
@@ -106,17 +82,40 @@ __DRAM_FWD static uint8 extPortMaskToPortNum[_RTL865XB_EXTPORTMASKS+1] =
 	5, 6, 7, 5, 8, 5, 5, 5
 };
 
+#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+int set_portmask_tag;
+int32 swNic_setVlanPortTag(int portmask){
+        set_portmask_tag = portmask &0x3f;
+        return 0;
+}
+#endif
+
+#if defined(CONFIG_RTL_PROC_DEBUG)
+unsigned int rx_noBuffer_cnt=0;
+unsigned int tx_ringFull_cnt=0;
+#endif
+
+#if defined(CONFIG_RTL_HW_VLAN_SUPPORT)
+int32 auto_set_tag_portmask;
+int32 swNic_setVlanPortTag(int portmask)
+{
+        auto_set_tag_portmask = portmask &0x3f;
+        return 0;
+}
+#endif
+
+
 /*************************************************************************
-*   FUNCTION                                                              
-*       swNic_intHandler                                         
-*                                                                         
-*   DESCRIPTION                                                           
+*   FUNCTION
+*       swNic_intHandler
+*
+*   DESCRIPTION
 *       This function is the handler of NIC interrupts
-*                                                                         
-*   INPUTS                                                                
+*
+*   INPUTS
 *       intPending      Pending interrupt sources.
-*                                                                         
-*   OUTPUTS                                                               
+*
+*   OUTPUTS
 *       None
 *************************************************************************/
 void swNic_intHandler(uint32 intPending) {return;}
@@ -130,7 +129,7 @@ inline int32 rtl8651_rxPktPreprocess(void *pkt, unsigned int *vid)
 
 	#if 0
 	if (srcPortNum >= RTL8651_CPU_PORT)
-	{        
+	{
 		if (m_pkthdr->ph_extPortList == 0)
 		{
 			/* No any destination ( extension port or CPU) : ASIC's BUG */
@@ -159,7 +158,7 @@ inline int32 rtl8651_rxPktPreprocess(void *pkt, unsigned int *vid)
 			#else
 			*vid = m_pkthdr->ph_vlanId;
 			#endif
-		}        
+		}
 	}
        else
 	#else
@@ -203,9 +202,9 @@ inline int return_to_rxing_check(int ringIdx)
 	//local_irq_save(flags);
 	ret = ((rxDescReadyForHwIndex[ringIdx]!=currRxPkthdrDescIndex[ringIdx]) && (rxPkthdrRingCnt[ringIdx]!=0))? 1:0;
 	//local_irq_restore(flags);
-	return ret;	
+	return ret;
 }
-static inline int buffer_reuse(int ringIdx) 
+static inline int buffer_reuse(int ringIdx)
 {
 	int index1,index2,gap;
 	unsigned long flags;
@@ -213,7 +212,7 @@ static inline int buffer_reuse(int ringIdx)
 	index1 = rxDescReadyForHwIndex[ringIdx];
 	index2 = currRxPkthdrDescIndex[ringIdx]+1;
 	gap = (index2 > index1) ? (index2 - index1) : (index2 + rxPkthdrRingCnt[ringIdx] - index1);
-	
+
 	if ((rxPkthdrRingCnt[ringIdx] - gap) < (rxPkthdrRefillThreshold[ringIdx]))
 	{
 		local_irq_restore(flags);
@@ -229,7 +228,7 @@ static inline int buffer_reuse(int ringIdx)
 static inline void set_RxPkthdrRing_OwnBit(uint32 rxRingIdx)
 {
 	rxPkthdrRing[rxRingIdx][rxDescReadyForHwIndex[rxRingIdx]] |= DESC_SWCORE_OWNED;
-	
+
 	if ( ++rxDescReadyForHwIndex[rxRingIdx] == rxPkthdrRingCnt[rxRingIdx] ) {
 		rxDescReadyForHwIndex[rxRingIdx] = 0;
 		#if	defined(DELAY_REFILL_ETH_RX_BUF)
@@ -248,11 +247,11 @@ static void release_pkthdr(struct sk_buff  *skb, int idx)
 
 	_dma_cache_wback_inv((unsigned long)skb->head, skb->truesize);
 	//local_irq_save(flags);
-	pReadyForHw = (struct rtl_pktHdr *)(rxPkthdrRing[idx][rxDescReadyForHwIndex[idx]] & 
+	pReadyForHw = (struct rtl_pktHdr *)(rxPkthdrRing[idx][rxDescReadyForHwIndex[idx]] &
 						~(DESC_OWNED_BIT | DESC_WRAP));
 	mbufIndex = ((uint32)(pReadyForHw->ph_mbuf) - (rxMbufRing[0] & ~(DESC_OWNED_BIT | DESC_WRAP))) /
 					(sizeof(struct rtl_mBuf));
-	
+
 	pReadyForHw->ph_mbuf->m_data = skb->data;
 	pReadyForHw->ph_mbuf->m_extbuf = skb->data;
 	pReadyForHw->ph_mbuf->skb = skb;
@@ -301,11 +300,11 @@ int check_and_return_to_rx_pkthdr_ring(void *skb, int idx)
 /*
 	return value: 1 ==> success, returned to rx pkt hdr desc
 	return value: 0 ==> failed, no return ==> release to priv skb buf pool
- */	
+ */
 extern struct sk_buff *dev_alloc_8190_skb(unsigned char *data, int size);
 
 __IRAM_FWD
-int return_to_rx_pkthdr_ring(unsigned char *head) 
+int return_to_rx_pkthdr_ring(unsigned char *head)
 {
 	struct sk_buff *skb;
 	int ret, i;
@@ -346,10 +345,10 @@ static void increase_rx_idx_release_pkthdr(struct sk_buff  *skb, int idx)
 	local_irq_save(flags);
 
 #if	defined(DELAY_REFILL_ETH_RX_BUF)
-	pReadyForHw = (struct rtl_pktHdr *)(rxPkthdrRing[idx][rxDescReadyForHwIndex[idx]] & 
+	pReadyForHw = (struct rtl_pktHdr *)(rxPkthdrRing[idx][rxDescReadyForHwIndex[idx]] &
 						~(DESC_OWNED_BIT | DESC_WRAP));
 #else
-	pReadyForHw = (struct rtl_pktHdr *)(rxPkthdrRing[idx][currRxPkthdrDescIndex[idx]] & 
+	pReadyForHw = (struct rtl_pktHdr *)(rxPkthdrRing[idx][currRxPkthdrDescIndex[idx]] &
 						~(DESC_OWNED_BIT | DESC_WRAP));
 
 	rxPkthdrRing[idx][currRxPkthdrDescIndex[idx]] |= DESC_SWCORE_OWNED;
@@ -364,17 +363,17 @@ static void increase_rx_idx_release_pkthdr(struct sk_buff  *skb, int idx)
 
 	mbufIndex = ((uint32)(pReadyForHw->ph_mbuf) - (rxMbufRing[0] & ~(DESC_OWNED_BIT | DESC_WRAP))) /
 					(sizeof(struct rtl_mBuf));
-	
+
 	pReadyForHw->ph_mbuf->m_data = skb->data;
 	pReadyForHw->ph_mbuf->m_extbuf = skb->data;
 	pReadyForHw->ph_mbuf->skb = skb;
 
 	rxMbufRing[mbufIndex] |= DESC_SWCORE_OWNED;
-	
+
 #if	defined(DELAY_REFILL_ETH_RX_BUF)
 	set_RxPkthdrRing_OwnBit(idx);
 #endif
-	
+
 	local_irq_restore(flags);
 }
 
@@ -382,14 +381,14 @@ __IRAM_FWD
 static int __swNic_geRxRingIdx(uint32 rxRingIdx, uint32 *currRxPktDescIdx)
 {
 	unsigned long flags;
-	
+
 	if(rxPkthdrRingCnt[rxRingIdx] == 0) {
 		return FAILED;
 	}
 
 	local_irq_save(flags);
 	#if	defined(DELAY_REFILL_ETH_RX_BUF)
-	if ( (rxDescCrossBoundFlag[rxRingIdx]==0&&(currRxPkthdrDescIndex[rxRingIdx]>=rxDescReadyForHwIndex[rxRingIdx])) 
+	if ( (rxDescCrossBoundFlag[rxRingIdx]==0&&(currRxPkthdrDescIndex[rxRingIdx]>=rxDescReadyForHwIndex[rxRingIdx]))
 		|| (rxDescCrossBoundFlag[rxRingIdx]==1&&(currRxPkthdrDescIndex[rxRingIdx]<rxDescReadyForHwIndex[rxRingIdx])) )
 	#endif
 	{
@@ -406,7 +405,7 @@ static int __swNic_geRxRingIdx(uint32 rxRingIdx, uint32 *currRxPktDescIdx)
 }
 
 #if defined(RTL_MULTIPLE_RX_TX_RING)
-/*	It's the caller's responsibility to make sure "rxRingIdx" and 
+/*	It's the caller's responsibility to make sure "rxRingIdx" and
 *	"currRxPktDescIdx" NOT NULL, since the callee never check
 *	sanity of the parameters, in order to speed up.
 */
@@ -419,10 +418,10 @@ static inline int32 swNic_getRxringIdx(uint32 *rxRingIdx, uint32 *currRxPktDescI
 {
 	int32	i;
 	int32	priority;
-	
+
 
 	priority = policy;
-	
+
 	for(i = RTL865X_SWNIC_RXRING_MAX_PKTDESC -1; i >= priority; i--)
 	{
 		if (__swNic_geRxRingIdx(i, currRxPktDescIdx)==SUCCESS) {
@@ -470,7 +469,7 @@ int get_nic_txRing_buf(void)
 
 		for(j = 0; j <txPkthdrRingCnt[i]; j++)
 		{
-			
+
 			pPkthdr = (struct rtl_pktHdr *) ((int32) txPkthdrRing[i][j]& ~(DESC_OWNED_BIT | DESC_WRAP));
 
 			if(pPkthdr->ph_mbuf->skb)
@@ -478,9 +477,9 @@ int get_nic_txRing_buf(void)
 				if(is_rtl865x_eth_priv_buf(((struct sk_buff *)pPkthdr->ph_mbuf->skb)->head))
 					txCnt++;
 			}
-		}		
+		}
 	}
-	
+
 	return txCnt;
 }
 
@@ -526,7 +525,7 @@ int32 swNic_flushRxRingByPriority(int priority)
 	{
 		if(rxPkthdrRingCnt[i] == 0)
 			continue;
-		
+
 		while((rxPkthdrRing[i][currRxPkthdrDescIndex[i]] & DESC_OWNED_BIT) == DESC_RISC_OWNED)
 		{
 			pPkthdr = (struct rtl_pktHdr *) (rxPkthdrRing[i][currRxPkthdrDescIndex[i]] & ~(DESC_OWNED_BIT | DESC_WRAP));
@@ -541,19 +540,19 @@ int32 swNic_flushRxRingByPriority(int priority)
 
 
 /*************************************************************************
-*   FUNCTION                                                              
-*       swNic_receive                                         
-*                                                                         
-*   DESCRIPTION                                                           
-*       This function reads one packet from rx descriptors, and return the 
-*       previous read one to the switch core. This mechanism is based on 
-*       the assumption that packets are read only when the handling 
+*   FUNCTION
+*       swNic_receive
+*
+*   DESCRIPTION
+*       This function reads one packet from rx descriptors, and return the
+*       previous read one to the switch core. This mechanism is based on
+*       the assumption that packets are read only when the handling
 *       previous read one is done.
-*                                                                         
-*   INPUTS                                                                
+*
+*   INPUTS
 *       None
-*                                                                         
-*   OUTPUTS                                                               
+*
+*   OUTPUTS
 *       None
 *************************************************************************/
 #define	RTL_NIC_RX_RETRY_MAX		(256)
@@ -580,8 +579,8 @@ int32 swNic_receive(rtl_nicRx_info *info, int retryCount)
 	#if defined(CONFIG_RTL_HARDWARE_NAT)
 	uint32	vid;
 	#endif
-		
-get_next:	
+
+get_next:
 	 /* Check OWN bit of descriptors */
 	#if defined(RTL_MULTIPLE_RX_TX_RING)
 	if (swNic_getRxringIdx(&rxRingIdx,&currRxPktDescIdx,info->priority) == SUCCESS )
@@ -591,7 +590,7 @@ get_next:
 	#endif
 	{
 		/* Fetch pkthdr */
-		pPkthdr = (struct rtl_pktHdr *) (rxPkthdrRing[rxRingIdx][currRxPktDescIdx] & ~(DESC_OWNED_BIT | DESC_WRAP));    
+		pPkthdr = (struct rtl_pktHdr *) (rxPkthdrRing[rxRingIdx][currRxPktDescIdx] & ~(DESC_OWNED_BIT | DESC_WRAP));
 
 		/* Increment counter */
 		//rxPktCounter++;
@@ -602,7 +601,7 @@ get_next:
 			RTL_ETH_NIC_DROP_RX_PKT_RESTART;
 			goto get_next;
 		}
-		
+
 #if defined(CONFIG_RTL_HARDWARE_NAT)
 		if (rtl8651_rxPktPreprocess(pPkthdr, &vid) != 0) {
 			RTL_ETH_NIC_DROP_RX_PKT_RESTART;
@@ -613,17 +612,17 @@ get_next:
 		info->vid = vid;
 #else
 		/*
-		 * vid is assigned in rtl8651_rxPktPreprocess() 
+		 * vid is assigned in rtl8651_rxPktPreprocess()
 		 * do not update it when CONFIG_RTL_HARDWARE_NAT is defined
 		 */
 		info->vid=pPkthdr->ph_vlanId;
 		buf = alloc_rx_buf(&skb, size_of_cluster);
 #endif
 		info->pid=pPkthdr->ph_portlist;
-		if (buf) 
+		if (buf)
 		{
 			info->input = pPkthdr->ph_mbuf->skb;
-			info->len = pPkthdr->ph_len - 4;	
+			info->len = pPkthdr->ph_len - 4;
 //			#if	defined(DELAY_REFILL_ETH_RX_BUF)
 			/* Increment index */
 			increase_rx_idx_release_pkthdr(skb, rxRingIdx);
@@ -636,7 +635,7 @@ get_next:
 #if	defined(DELAY_REFILL_ETH_RX_BUF)
 		else if (!buffer_reuse(rxRingIdx)) {
 			info->input = pPkthdr->ph_mbuf->skb;
-			info->len = pPkthdr->ph_len - 4;	
+			info->len = pPkthdr->ph_len - 4;
 			//printk("====CPU is pending====\n");
 			#if defined(CONFIG_RTL_ETH_PRIV_SKB_DEBUG)
 			mbuf_pending_times ++;
@@ -645,12 +644,19 @@ get_next:
 			/* Increment index */
 			swNic_increaseRxIdx(rxRingIdx);
 		} else {
+			#if defined(CONFIG_RTL_PROC_DEBUG)
+				rx_noBuffer_cnt++;
+			#endif
+			#if 0
 			if (retryCount>RTL_NIC_RX_RETRY_MAX) {
 				/* drop pkt */
 				increase_rx_idx_release_pkthdr((void*)pPkthdr->ph_mbuf->skb, rxRingIdx);
 			}
 			return RTL_NICRX_REPEAT;
-		}		
+			#else
+			return RTL_NICRX_NULL;
+			#endif
+		}
 #endif
 
 		#if defined(RTL_MULTIPLE_RX_TX_RING)
@@ -665,17 +671,17 @@ get_next:
 #undef	RTL_ETH_NIC_DROP_RX_PKT_RESTART
 
 /*************************************************************************
-*   FUNCTION                                                              
-*       swNic_send                                         
-*                                                                         
-*   DESCRIPTION                                                           
-*       This function writes one packet to tx descriptors, and waits until 
+*   FUNCTION
+*       swNic_send
+*
+*   DESCRIPTION
+*       This function writes one packet to tx descriptors, and waits until
 *       the packet is successfully sent.
-*                                                                         
-*   INPUTS                                                                
+*
+*   INPUTS
 *       None
-*                                                                         
-*   OUTPUTS                                                               
+*
+*   OUTPUTS
 *       None
 *************************************************************************/
 __MIPS16
@@ -688,14 +694,14 @@ __IRAM_FWD  inline int32 _swNic_send(void *skb, void * output, uint32 len,rtl_ni
 		next_index = 0;
 	else
 		next_index = currTxPkthdrDescIndex[nicTx->txIdx]+1;
-	
+
 	if (next_index == txPktDoneDescIndex[nicTx->txIdx])	{
 		/*	TX ring full	*/
 			return -1;
 	}
-	
+
 	/* Fetch packet header from Tx ring */
-	pPkthdr = (struct rtl_pktHdr *) ((int32) txPkthdrRing[nicTx->txIdx][currTxPkthdrDescIndex[nicTx->txIdx]] 
+	pPkthdr = (struct rtl_pktHdr *) ((int32) txPkthdrRing[nicTx->txIdx][currTxPkthdrDescIndex[nicTx->txIdx]]
                                                 & ~(DESC_OWNED_BIT | DESC_WRAP));
 
 	/* Pad small packets and add CRC */
@@ -703,28 +709,46 @@ __IRAM_FWD  inline int32 _swNic_send(void *skb, void * output, uint32 len,rtl_ni
 		len = 64;
 	else
 		len += 4;
-		
+
 	pPkthdr->ph_mbuf->m_len  = len;
 	pPkthdr->ph_mbuf->m_extsize = len;
 	pPkthdr->ph_mbuf->skb = skb;
 	pPkthdr->ph_len = len;
-	
+
 	pPkthdr->ph_vlanId = nicTx->vid;
-	#if defined(CONFIG_8198_PORT5_GMII) || defined(CONFIG_8198_PORT5_RGMII)	
+	#if defined(CONFIG_8198_PORT5_GMII) || defined(CONFIG_8198_PORT5_RGMII)
 	pPkthdr->ph_portlist = nicTx->portlist&0x3f;
 	#else
 	pPkthdr->ph_portlist = nicTx->portlist&0x1f;
 	#endif
 	pPkthdr->ph_srcExtPortNum = nicTx->srcExtPort;
 	pPkthdr->ph_flags = nicTx->flags;
-#if	defined(CONFIG_RTL_HW_QOS_SUPPORT)
+#if	defined(CONFIG_RTL_HW_QOS_SUPPORT) || defined(CONFIG_RTK_VOIP_QOS)
 	pPkthdr->ph_txPriority = nicTx->priority;
 #endif
+#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+if (*((unsigned short *)((unsigned char*)output+ETH_ALEN*2)) != __constant_htons(ETH_P_8021Q))
+	pPkthdr->ph_txCVlanTagAutoAdd = set_portmask_tag;
+else
+	pPkthdr->ph_txCVlanTagAutoAdd = 0;
+#endif
+
+#if defined(CONFIG_RTL_HW_VLAN_SUPPORT)
+	if (*((unsigned short *)((unsigned char*)output+ETH_ALEN*2)) != __constant_htons(ETH_P_8021Q))
+			pPkthdr->ph_txCVlanTagAutoAdd = auto_set_tag_portmask;
+	else
+			pPkthdr->ph_txCVlanTagAutoAdd = 0;
+#endif
+
 
 	/* Set cluster pointer to buffer */
 	pPkthdr->ph_mbuf->m_data    = (output);
 	pPkthdr->ph_mbuf->m_extbuf = (output);
-	
+
+#if defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+	pPkthdr->ph_ptpPkt = 0;
+#endif
+
 	ret = currTxPkthdrDescIndex[nicTx->txIdx];
 	currTxPkthdrDescIndex[nicTx->txIdx] = next_index;
 	/* Give descriptor to switch core */
@@ -733,8 +757,8 @@ __IRAM_FWD  inline int32 _swNic_send(void *skb, void * output, uint32 len,rtl_ni
 #if 0
 	memDump((void*)output, 64, "TX");
 	printk("index %d address 0x%p, 0x%x 0x%p.\n", ret, &txPkthdrRing[nicTx->txIdx][ret], (*(volatile uint32 *)&txPkthdrRing[nicTx->txIdx][ret]), pPkthdr);
-	printk("Flags 0x%x proto 0x%x portlist 0x%x vid %d extPort %d srcExtPort %d len %d.\n", 
-		pPkthdr->ph_flags, pPkthdr->ph_proto, pPkthdr->ph_portlist, pPkthdr->ph_vlanId, 
+	printk("Flags 0x%x proto 0x%x portlist 0x%x vid %d extPort %d srcExtPort %d len %d.\n",
+		pPkthdr->ph_flags, pPkthdr->ph_proto, pPkthdr->ph_portlist, pPkthdr->ph_vlanId,
 		pPkthdr->ph_extPortList, pPkthdr->ph_srcExtPortNum, pPkthdr->ph_len);
 #endif
 
@@ -752,7 +776,7 @@ int32 swNic_send(void *skb, void * output, uint32 len,rtl_nicTx_info *nicTx)
 
 	local_irq_save(flags);
 	ret = _swNic_send(skb, output, len, nicTx);
-	local_irq_restore(flags);	
+	local_irq_restore(flags);
 	return ret;
 }
 
@@ -766,8 +790,8 @@ int32 swNic_txDone(int idx)
 	local_irq_save(flags);
 	//free_num = 0;
 	{
-		while (txPktDoneDescIndex[idx] != currTxPkthdrDescIndex[idx]) {		
-		if ( (*(volatile uint32 *)&txPkthdrRing[idx][txPktDoneDescIndex[idx]] 
+		while (txPktDoneDescIndex[idx] != currTxPkthdrDescIndex[idx]) {
+		if ( (*(volatile uint32 *)&txPkthdrRing[idx][txPktDoneDescIndex[idx]]
 			& DESC_OWNED_BIT) == DESC_RISC_OWNED )
 		{
 			#ifdef CONFIG_RTL8196C_REVISION_B
@@ -775,7 +799,7 @@ int32 swNic_txDone(int idx)
 				txPkthdrRing[idx][txPktDoneDescIndex[idx]] =txPkthdrRing_backup[idx][txPktDoneDescIndex[idx]] ;
 			#endif
 
-			pPkthdr = (struct rtl_pktHdr *) ((int32) txPkthdrRing[idx][txPktDoneDescIndex[idx]] 
+			pPkthdr = (struct rtl_pktHdr *) ((int32) txPkthdrRing[idx][txPktDoneDescIndex[idx]]
 				& ~(DESC_OWNED_BIT | DESC_WRAP));
 
 			if (pPkthdr->ph_mbuf->skb)
@@ -790,7 +814,7 @@ int32 swNic_txDone(int idx)
 				pPkthdr->ph_mbuf->skb = NULL;
 			}
 
-			
+
 			if (++txPktDoneDescIndex[idx] == txPkthdrRingCnt[idx])
 				txPktDoneDescIndex[idx] = 0;
 
@@ -802,7 +826,7 @@ int32 swNic_txDone(int idx)
 	}
 
 	local_irq_restore(flags);
-	return 0; //free_num;	
+	return 0; //free_num;
 }
 
 #ifdef  CONFIG_RTL865X_MODEL_TEST_FT2
@@ -818,7 +842,7 @@ int32 swNic_send_portmbr(void * output, uint32 len, uint32 portmbr)
     ASSERT_CSP( ((int32) txPkthdrRing[0][currTxPkthdrDescIndex] & DESC_OWNED_BIT) == DESC_RISC_OWNED );
 
     /* Fetch packet header from Tx ring */
-    pPkthdr = (struct rtl_pktHdr *) ((int32) txPkthdrRing[0][currTxPkthdrDescIndex] 
+    pPkthdr = (struct rtl_pktHdr *) ((int32) txPkthdrRing[0][currTxPkthdrDescIndex]
                                                 & ~(DESC_OWNED_BIT | DESC_WRAP));
 
     /* Pad small packets and add CRC */
@@ -842,14 +866,14 @@ int32 swNic_send_portmbr(void * output, uint32 len, uint32 portmbr)
 
     /* Set TXFD bit to start send */
     REG32(CPUICR) |= TXFD;
-    
+
     /* Wait until packet is successfully sent */
-#if 1    
-    while ( (*(volatile uint32 *)&txPkthdrRing[0][currTxPkthdrDescIndex] 
+#if 1
+    while ( (*(volatile uint32 *)&txPkthdrRing[0][currTxPkthdrDescIndex]
                     & DESC_OWNED_BIT) == DESC_SWCORE_OWNED );
-#endif    
+#endif
     //txPktCounter++;
-    
+
     if ( ++currTxPkthdrDescIndex == txPkthdrRingCnt[0] )
         currTxPkthdrDescIndex = 0;
 
@@ -880,12 +904,12 @@ void swNic_freeRxBuf(void)
 		rxDescReadyForHwIndex[i] = 0;
 		rxDescCrossBoundFlag[i] = 0;
 		#endif
-		
+
 		for (idx=0; idx<rxPkthdrRingCnt[i]; idx++)
 		{
 			if (!((rxPkthdrRing[i][idx] & DESC_OWNED_BIT) == DESC_RISC_OWNED)) {
-				pPkthdr = (struct rtl_pktHdr *) (rxPkthdrRing[i][idx] & 
-					~(DESC_OWNED_BIT | DESC_WRAP));    
+				pPkthdr = (struct rtl_pktHdr *) (rxPkthdrRing[i][idx] &
+					~(DESC_OWNED_BIT | DESC_WRAP));
 
 				/*if(pPkthdr == NULL || pPkthdr->ph_mbuf == NULL)
 				*	continue;
@@ -920,16 +944,16 @@ int swNic_refillRxRing(void)
 			skb=NULL;
 			buf = alloc_rx_buf(&skb, size_of_cluster);
 
-			if ((buf == NULL) ||(skb==NULL) ) { 
+			if ((buf == NULL) ||(skb==NULL) ) {
 				local_irq_restore(flags);
 				return -1;
 			}
-		
+
 			release_pkthdr(skb, i);
 		}
 		REG32(CPUIISR) = (MBUF_DESC_RUNOUT_IP_ALL|PKTHDR_DESC_RUNOUT_IP_ALL);
 	}
-	
+
 	local_irq_restore(flags);
 	return 0;
 }
@@ -947,14 +971,14 @@ void swNic_freeTxRing(void)
 	/* Initialize index of Tx pkthdr descriptor */
 	for (idx=0;idx<RTL865X_SWNIC_TXRING_HW_PKTDESC;idx++)
 	{
-			while (txPktDoneDescIndex[idx] != currTxPkthdrDescIndex[idx]) {		
-		
+			while (txPktDoneDescIndex[idx] != currTxPkthdrDescIndex[idx]) {
+
 			#ifdef CONFIG_RTL8196C_REVISION_B
 			if (rtl_chip_version == RTL8196C_REVISION_A)
 				txPkthdrRing[idx][txPktDoneDescIndex[idx]] =txPkthdrRing_backup[idx][txPktDoneDescIndex[idx]] ;
 			#endif
 
-			pPkthdr = (struct rtl_pktHdr *) ((int32) txPkthdrRing[idx][txPktDoneDescIndex[idx]] 
+			pPkthdr = (struct rtl_pktHdr *) ((int32) txPkthdrRing[idx][txPktDoneDescIndex[idx]]
 				& ~(DESC_OWNED_BIT | DESC_WRAP));
 
 			if (pPkthdr->ph_mbuf->skb)
@@ -965,23 +989,23 @@ void swNic_freeTxRing(void)
 				#else
 				dev_kfree_skb_any((struct sk_buff *)pPkthdr->ph_mbuf->skb);
 				#endif
-				
+
 				pPkthdr->ph_mbuf->skb = NULL;
 			}
-			
+
 			txPkthdrRing[idx][txPktDoneDescIndex[idx]] &= ~DESC_SWCORE_OWNED;
-			
+
 			if (++txPktDoneDescIndex[idx] == txPkthdrRingCnt[idx])
 				txPktDoneDescIndex[idx] = 0;
-		
+
 		}
 
-	
+
 	}
 
-	
+
 	local_irq_restore(flags);
-	return ; //free_num;	
+	return ; //free_num;
 }
 
 int32 swNic_reConfigRxTxRing(void)
@@ -989,7 +1013,7 @@ int32 swNic_reConfigRxTxRing(void)
 	uint32 i,j,k;
 	//struct rtl_pktHdr	*pPkthdr;
 	unsigned long flags;
-	
+
 	local_irq_save(flags);
 
 	k = 0;
@@ -1022,7 +1046,7 @@ int32 swNic_reConfigRxTxRing(void)
 
 	rxMbufRing[rxMbufRingCnt - 1] |= DESC_WRAP;
 
-	
+
 	for (i=0;i<RTL865X_SWNIC_TXRING_HW_PKTDESC;i++)
 	{
 		currTxPkthdrDescIndex[i] = 0;
@@ -1033,7 +1057,7 @@ int32 swNic_reConfigRxTxRing(void)
 	REG32(CPUTPDCR0) = (uint32) txPkthdrRing[0];
 	REG32(CPUTPDCR1) = (uint32) txPkthdrRing[1];
 
-	
+
 	/* Fill Rx packet header FDP */
 	REG32(CPURPDCR0) = (uint32) rxPkthdrRing[0];
 	REG32(CPURPDCR1) = (uint32) rxPkthdrRing[1];
@@ -1043,9 +1067,9 @@ int32 swNic_reConfigRxTxRing(void)
 	REG32(CPURPDCR5) = (uint32) rxPkthdrRing[5];
 
 	REG32(CPURMDCR0) = (uint32) rxMbufRing;
-	
+
 	local_irq_restore(flags);
-	
+
 	return 0;
 }
 int32 swNic_reInit(void)
@@ -1061,13 +1085,13 @@ int32 swNic_reInit(void)
 #endif
 //#pragma ghs section text=default
 /*************************************************************************
-*   FUNCTION                                                              
-*       swNic_init                                         
-*                                                                         
-*   DESCRIPTION                                                           
+*   FUNCTION
+*       swNic_init
+*
+*   DESCRIPTION
 *       This function initializes descriptors and data structures.
-*                                                                         
-*   INPUTS                                                                
+*
+*   INPUTS
 *       userNeedRxPkthdrRingCnt[RTL865X_SWNIC_RXRING_HW_PKTDESC] :
 *          Number of Rx pkthdr descriptors of each ring.
 *       userNeedRxMbufRingCnt :
@@ -1076,8 +1100,8 @@ int32 swNic_reInit(void)
 *          Number of Tx pkthdr descriptors of each ring.
 *       clusterSize :
 *          Size of cluster.
-*                                                                         
-*   OUTPUTS                                                               
+*
+*   OUTPUTS
 *       Status.
 *************************************************************************/
 
@@ -1089,7 +1113,7 @@ int32 swNic_init(uint32 userNeedRxPkthdrRingCnt[RTL865X_SWNIC_RXRING_HW_PKTDESC]
 	uint32 i, j, k;
 	static uint32 totalRxPkthdrRingCnt = 0, totalTxPkthdrRingCnt = 0;
 	static struct rtl_pktHdr *pPkthdrList_start;
-	static struct rtl_mBuf *pMbufList_start;		
+	static struct rtl_mBuf *pMbufList_start;
 	struct rtl_pktHdr *pPkthdrList;
 	struct rtl_mBuf *pMbufList;
 	struct rtl_pktHdr * pPkthdr;
@@ -1106,8 +1130,8 @@ int32 swNic_init(uint32 userNeedRxPkthdrRingCnt[RTL865X_SWNIC_RXRING_HW_PKTDESC]
 	extPortMaskToPortNum[5] = 5;
 	extPortMaskToPortNum[6] = 5;
 	extPortMaskToPortNum[7] = 5;
-	
-#if	defined(DELAY_REFILL_ETH_RX_BUF)	
+
+#if	defined(DELAY_REFILL_ETH_RX_BUF)
 	rxPkthdrRefillThreshold[0] = ETH_REFILL_THRESHOLD;
 	rxPkthdrRefillThreshold[1] = ETH_REFILL_THRESHOLD1;
 	rxPkthdrRefillThreshold[2] = ETH_REFILL_THRESHOLD2;
@@ -1123,11 +1147,11 @@ int32 swNic_init(uint32 userNeedRxPkthdrRingCnt[RTL865X_SWNIC_RXRING_HW_PKTDESC]
 	ret = SUCCESS;
 	local_irq_save(flags);
 	if (rxMbufRing == NULL)
-	{ 
+	{
 		size_of_cluster = clusterSize;
 
 		/* Allocate Rx descriptors of rings */
-		for (i = 0; i < RTL865X_SWNIC_RXRING_HW_PKTDESC; i++) {   
+		for (i = 0; i < RTL865X_SWNIC_RXRING_HW_PKTDESC; i++) {
 			rxPkthdrRingCnt[i] = userNeedRxPkthdrRingCnt[i];
 			if (rxPkthdrRingCnt[i] == 0)
 			{
@@ -1147,7 +1171,7 @@ int32 swNic_init(uint32 userNeedRxPkthdrRingCnt[RTL865X_SWNIC_RXRING_HW_PKTDESC]
 		}
 
 		/* Allocate Tx descriptors of rings */
-		for (i = 0; i < RTL865X_SWNIC_TXRING_HW_PKTDESC; i++) {    
+		for (i = 0; i < RTL865X_SWNIC_TXRING_HW_PKTDESC; i++) {
 			txPkthdrRingCnt[i] = userNeedTxPkthdrRingCnt[i];
 
 			if (txPkthdrRingCnt[i] == 0)
@@ -1256,6 +1280,11 @@ int32 swNic_init(uint32 userNeedRxPkthdrRingCnt[RTL865X_SWNIC_RXRING_HW_PKTDESC]
 	REG32(CPUTPDCR0) = (uint32) txPkthdrRing[0];
 	REG32(CPUTPDCR1) = (uint32) txPkthdrRing[1];
 
+#if defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+	REG32(CPUTPDCR2) = (uint32) txPkthdrRing[2];
+	REG32(CPUTPDCR3) = (uint32) txPkthdrRing[3];
+#endif
+
 	/* Initialize Rx packet header descriptors */
 	k = 0;
 
@@ -1281,7 +1310,7 @@ int32 swNic_init(uint32 userNeedRxPkthdrRingCnt[RTL865X_SWNIC_RXRING_HW_PKTDESC]
 			pMbuf->m_len = 0;
 			pMbuf->m_flags = MBUF_USED | MBUF_EXT | MBUF_PKTHDR | MBUF_EOR;
 			pMbuf->m_extsize = size_of_cluster;
-			pMbuf->m_data = pMbuf->m_extbuf = alloc_rx_buf(&pPkthdr->ph_mbuf->skb, size_of_cluster);			
+			pMbuf->m_data = pMbuf->m_extbuf = alloc_rx_buf(&pPkthdr->ph_mbuf->skb, size_of_cluster);
 
 			/* Setup descriptors */
 			rxPkthdrRing[i][j] = (int32) pPkthdr | DESC_SWCORE_OWNED;
@@ -1324,16 +1353,16 @@ out:
 
 #ifdef FAT_CODE
 /*************************************************************************
-*   FUNCTION                                                              
-*       swNic_resetDescriptors                                         
-*                                                                         
-*   DESCRIPTION                                                           
+*   FUNCTION
+*       swNic_resetDescriptors
+*
+*   DESCRIPTION
 *       This function resets descriptors.
-*                                                                         
-*   INPUTS                                                                
+*
+*   INPUTS
 *       None.
-*                                                                         
-*   OUTPUTS                                                               
+*
+*   OUTPUTS
 *       None.
 *************************************************************************/
 void swNic_resetDescriptors(void)
@@ -1368,16 +1397,16 @@ int32	rtl_dumpRxRing(void)
 		for(cnt=0;cnt<rxPkthdrRingCnt[idx];cnt++)
 		{
 			pPkthdr = (struct rtl_pktHdr *) (rxPkthdrRing[idx][cnt] & ~(DESC_OWNED_BIT | DESC_WRAP));
-			
+
 #if	defined(DELAY_REFILL_ETH_RX_BUF)
 			printk("  idx[%03d]: 0x%p-->mbuf[0x%p],skb[0x%p]%s%s%s%s\n",  cnt, pPkthdr, pPkthdr->ph_mbuf, pPkthdr->ph_mbuf->skb,
-				(rxPkthdrRing[idx][cnt]&DESC_OWNED_BIT)==DESC_RISC_OWNED?" :CPU":" :SWCORE", 
+				(rxPkthdrRing[idx][cnt]&DESC_OWNED_BIT)==DESC_RISC_OWNED?" :CPU":" :SWCORE",
 				(rxPkthdrRing[idx][cnt]&DESC_WRAP)!=0?" :WRAP":"",
 				cnt==currRxPkthdrDescIndex[idx]?"  <===currIdx":"",
 				cnt ==rxDescReadyForHwIndex[idx]?" <===readyForHw":"");
 #else
 			printk("  idx[%03d]: 0x%p-->mbuf[0x%p],skb[0x%p]%s%s%s\n",  cnt, pPkthdr, pPkthdr->ph_mbuf, pPkthdr->ph_mbuf->skb,
-				(rxPkthdrRing[idx][cnt]&DESC_OWNED_BIT)==DESC_RISC_OWNED?" :CPU":" :SWCORE", 
+				(rxPkthdrRing[idx][cnt]&DESC_OWNED_BIT)==DESC_RISC_OWNED?" :CPU":" :SWCORE",
 				(rxPkthdrRing[idx][cnt]&DESC_WRAP)!=0?" :WRAP":"",
 				cnt==currRxPkthdrDescIndex[idx]?"  <===currIdx":"");
 #endif
@@ -1411,10 +1440,10 @@ int32	rtl_dumpTxRing(void)
 #endif
 			pPkthdr = (struct rtl_pktHdr *) (txPkthdrRing[idx][cnt] & ~(DESC_OWNED_BIT | DESC_WRAP));
 
-			printk("  idx[%03d]: 0x%p-->mbuf[0x%p],skb[0x%p]%s%s%s%s\n",  cnt, pPkthdr, pPkthdr->ph_mbuf, pPkthdr->ph_mbuf->skb, 
-				(txPkthdrRing[idx][cnt]&DESC_OWNED_BIT)==DESC_RISC_OWNED?" :CPU":" :SWCORE", 
+			printk("  idx[%03d]: 0x%p-->mbuf[0x%p],skb[0x%p]%s%s%s%s\n",  cnt, pPkthdr, pPkthdr->ph_mbuf, pPkthdr->ph_mbuf->skb,
+				(txPkthdrRing[idx][cnt]&DESC_OWNED_BIT)==DESC_RISC_OWNED?" :CPU":" :SWCORE",
 				(txPkthdrRing[idx][cnt]&DESC_WRAP)!=0?" :WRAP":"",
-				cnt==currTxPkthdrDescIndex[idx]?"  <===currIdx":"", 
+				cnt==currTxPkthdrDescIndex[idx]?"  <===currIdx":"",
 				cnt==txPktDoneDescIndex[idx]?"  <===txDoneIdx":"");
 		}
 	}
@@ -1432,9 +1461,9 @@ int32	rtl_dumpMbufRing(void)
 	while(1)
 	{
 		mbuf = (struct rtl_mBuf *)(rxMbufRing[idx] & ~(DESC_OWNED_BIT | DESC_WRAP));
-		printk("mbuf[%03d]: 0x%p: ==> pkthdr[0x%p] ==> skb[0x%p]%s%s%s\n", idx, mbuf, mbuf->m_pkthdr, 
-				mbuf->skb, 
-				(rxMbufRing[idx]&DESC_OWNED_BIT)==DESC_RISC_OWNED?" :CPU":" :SWCORE", 
+		printk("mbuf[%03d]: 0x%p: ==> pkthdr[0x%p] ==> skb[0x%p]%s%s%s\n", idx, mbuf, mbuf->m_pkthdr,
+				mbuf->skb,
+				(rxMbufRing[idx]&DESC_OWNED_BIT)==DESC_RISC_OWNED?" :CPU":" :SWCORE",
 				(rxMbufRing[idx]&DESC_WRAP)==DESC_ENG_OWNED?" :WRAP":"",
 				idx==currRxMbufDescIndex?"  <===currIdx":"");
 			if ((rxMbufRing[idx]&DESC_WRAP)!=0)
@@ -1452,19 +1481,19 @@ int32 rtl_dumpIndexs(void)
 	printk("Dump RX infos:\n");
 #if	defined(DELAY_REFILL_ETH_RX_BUF)
 	for(i=0;i<RTL865X_SWNIC_RXRING_HW_PKTDESC;i++) {
-		printk("	TotalCnt: %d, currPkthdrIdx: %d currMbufIdx: %d readyForHwIdx: %d crossBoundFlag: %d.\n", 
+		printk("	TotalCnt: %d, currPkthdrIdx: %d currMbufIdx: %d readyForHwIdx: %d crossBoundFlag: %d.\n",
 			rxPkthdrRingCnt[i], currRxPkthdrDescIndex[i], currRxMbufDescIndex, rxDescReadyForHwIndex[i], rxDescCrossBoundFlag[i]);
 	}
 #else
 	for(i=0;i<RTL865X_SWNIC_RXRING_HW_PKTDESC;i++) {
-		printk("	TotalCnt: %d, currPkthdrIdx: %d currMbufIdx: %d\n", 
+		printk("	TotalCnt: %d, currPkthdrIdx: %d currMbufIdx: %d\n",
 			rxPkthdrRingCnt[i], currRxPkthdrDescIndex[i], currRxMbufDescIndex);
 	}
 #endif
 
 	printk("\nDump TX infos:\n");
 	for(i=0;i<RTL865X_SWNIC_TXRING_HW_PKTDESC;i++) {
-		printk("	TotalCnt: %d, currPkthdrIdx: %d pktDoneIdx: %d.\n", 
+		printk("	TotalCnt: %d, currPkthdrIdx: %d pktDoneIdx: %d.\n",
 			txPkthdrRingCnt[i], currTxPkthdrDescIndex[i], txPktDoneDescIndex[i]);
 	}
 
diff --git a/drivers/net/rtl819x/rtl865xc_swNic.h b/drivers/net/rtl819x/rtl865xc_swNic.h
index e2bad93..f89cd07 100644
--- a/drivers/net/rtl819x/rtl865xc_swNic.h
+++ b/drivers/net/rtl819x/rtl865xc_swNic.h
@@ -1,8 +1,8 @@
 /*
 * ----------------------------------------------------------------
-* Copyright c                  Realtek Semiconductor Corporation, 2002  
+* Copyright c                  Realtek Semiconductor Corporation, 2002
 * All rights reserved.
-* 
+*
 * $Header: /home/cvsroot/linux-2.6.19/linux-2.6.x/drivers/net/re865x/rtl865xc_swNic.h,v 1.3 2008/04/11 10:12:38 bo_zhao Exp $
 *
 * Abstract: Switch core polling mode NIC header file.
@@ -35,7 +35,7 @@
 * *** empty log message ***
 *
 * Revision 1.1.1.1  2003/09/25 08:16:56  tony
-*  initial loader tree 
+*  initial loader tree
 *
 * Revision 1.1.1.1  2003/05/07 08:16:07  danwu
 * no message
@@ -52,9 +52,14 @@
 #endif
 
 #define RTL865X_SWNIC_RXRING_HW_PKTDESC	6
+
+#if defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+#define RTL865X_SWNIC_TXRING_HW_PKTDESC	4
+#else
 #define RTL865X_SWNIC_TXRING_HW_PKTDESC	2
+#endif
 
-#if defined(CONFIG_RTL_8198) && !defined(CONFIG_RTL_8198_AP_ROOT)
+#if (defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_8196E)) && !defined(CONFIG_RTL_8198_AP_ROOT)
 	#define MAX_PRE_ALLOC_RX_SKB		512
 	#define NUM_RX_PKTHDR_DESC			512
 	#define NUM_TX_PKTHDR_DESC			1024
@@ -126,6 +131,11 @@
 #define	QUEUEID5_RXRING_MAPPING		0
 #endif
 
+#if defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+#define	NUM_TX_PKTHDR_DESC2		2
+#define	NUM_TX_PKTHDR_DESC3		2
+#endif
+
 /* refer to rtl865xc_swNic.c & rtl865xc_swNic.h
  */
 #define	UNCACHE_MASK   0x20000000
@@ -154,7 +164,7 @@ typedef struct {
 	uint16		srcExtPort;
 	uint16		flags;
 	uint32		txIdx:1;
-#if defined(CONFIG_RTL_HW_QOS_SUPPORT)
+#if defined(CONFIG_RTL_HW_QOS_SUPPORT) || defined(CONFIG_RTL_QOS_PATCH)|| defined(CONFIG_RTK_VOIP_QOS)
 	uint32		priority:3;
 	uint32		queueId:3;
 #endif
@@ -180,14 +190,14 @@ typedef struct {
  * ROUTINE NAME - swNic_init
  * --------------------------------------------------------------------
  * FUNCTION: This service initializes the switch NIC.
- * INPUT   : 
+ * INPUT   :
         userNeedRxPkthdrRingCnt[RTL865X_SWNIC_RXRING_MAX_PKTDESC]: Number of Rx pkthdr descriptors. of each ring
         userNeedRxMbufRingCnt: Number of Rx mbuf descriptors.
         userNeedTxPkthdrRingCnt[RTL865X_SWNIC_TXRING_MAX_PKTDESC]: Number of Tx pkthdr descriptors. of each ring
         clusterSize: Size of a mbuf cluster.
  * OUTPUT  : None.
- * RETURN  : Upon successful completion, the function returns ENOERR. 
-        Otherwise, 
+ * RETURN  : Upon successful completion, the function returns ENOERR.
+        Otherwise,
 		EINVAL: Invalid argument.
  * NOTE    : None.
  * -------------------------------------------------------------------*/
@@ -212,7 +222,7 @@ void swNic_intHandler(uint32 intPending);
 int32 swNic_flushRxRingByPriority(int priority);
 __MIPS16 __IRAM_FWD int32 swNic_receive(rtl_nicRx_info *info, int retryCount);
 int32 swNic_send(void *skb, void * output, uint32 len, rtl_nicTx_info *nicTx);
-//__MIPS16 
+//__MIPS16
 int32 swNic_txDone(int idx);
 void swNic_freeRxBuf(void);
 int32	swNic_txRunout(void);
@@ -230,6 +240,10 @@ extern void tx_done_callback(void *skb);
 extern void eth_save_and_cli(unsigned long *flags);
 extern void eth_restore_flags(unsigned long flags);
 
+#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+int32 swNic_setVlanPortTag(int portmask);
+#endif
+
 #define	RTL8651_IOCTL_GETWANLINKSTATUS			2000
 #define	RTL8651_IOCTL_GETLANLINKSTATUS			2001
 #define	RTL8651_IOCTL_GETWANTHROUGHPUT			2002
@@ -258,7 +272,7 @@ int32	rtl_dumpIndexs(void);
 
 struct ring_que {
 	int qlen;
-	int qmax;	
+	int qmax;
 	int head;
 	int tail;
 	struct sk_buff **ring;
@@ -266,7 +280,7 @@ struct ring_que {
 
 static inline void *UNCACHED_MALLOC(int size)
 {
-	return ((void *)(((uint32)kmalloc(size, GFP_ATOMIC)) | UNCACHE_MASK));	
+	return ((void *)(((uint32)kmalloc(size, GFP_ATOMIC)) | UNCACHE_MASK));
 }
 
 #endif /* _SWNIC_H */
diff --git a/drivers/net/rtl819x/rtl_glue.c b/drivers/net/rtl819x/rtl_glue.c
index 00c631a..a2efeea 100644
--- a/drivers/net/rtl819x/rtl_glue.c
+++ b/drivers/net/rtl819x/rtl_glue.c
@@ -1,11 +1,14 @@
 /*
-* Copyright c                  Realtek Semiconductor Corporation, 2002  
-* All rights reserved.
-* 
 * Program : Implementation of Glue Functions of Model Code
 * Abstract : 
 * Author : Louis Yung-Chieh Lo (yjlou@realtek.com.tw)               
 * $Id: rtl_glue.c,v 1.5 2008/04/11 10:12:38 bo_zhao Exp $
+
+*  Copyright (c) 2011 Realtek Semiconductor Corp.
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License version 2 as
+*  published by the Free Software Foundation.
 */
 
 #include <net/rtl/rtl_types.h>
diff --git a/drivers/net/rtl819x/rtl_nic.c b/drivers/net/rtl819x/rtl_nic.c
index 2bb6951..44b9af1 100644
--- a/drivers/net/rtl819x/rtl_nic.c
+++ b/drivers/net/rtl819x/rtl_nic.c
@@ -45,6 +45,9 @@
 #undef	CONFIG_RTL_IGMP_SNOOPING
 #endif
 
+//if you need to use the fake eth driver, please also disable the "CONFIG_RTL_ETH_PRIV_SK" in kernel
+//#define CONFIG_RTK_FAKE_ETH 1
+
 #include "version.h"
 #include <net/rtl/rtl_types.h>
 #include <net/rtl/rtl_glue.h>
@@ -88,6 +91,9 @@
 #include "romeperf.h"
 #endif
 #include <net/rtl/rtl_nic.h>
+#if defined(CONFIG_RTL_FASTBRIDGE)
+#include <net/rtl/features/fast_bridge.h>
+#endif
 #if defined(CONFIG_RTL_HW_QOS_SUPPORT) && defined(CONFIG_NET_SCHED) && defined(CONFIG_RTL_LAYERED_DRIVER)
 #include <net/rtl/rtl865x_outputQueue.h>
 #endif
@@ -100,6 +106,10 @@
 #include <net/rtl/rtk_stp.h>
 #endif
 
+#if defined(CONFIG_RTL_8196C_ESD) || defined(CONFIG_RTL_8198_ESD)
+#include <linux/reboot.h>
+#endif
+
 #if defined (CONFIG_RTL_IGMP_SNOOPING)
 #include <net/rtl/rtl865x_igmpsnooping.h>
 #include <linux/if_ether.h>
@@ -117,6 +127,11 @@ extern uint32 br0SwFwdPortMask;
 #endif
 #endif
 
+#if defined(CONFIG_RTK_VLAN_WAN_TAG_SUPPORT)
+uint32 nicIgmpModuleIndex_2=0xFFFFFFFF;
+extern uint32 brIgmpModuleIndex_2;
+#endif
+
 #if defined (CONFIG_RTL_8198_INBAND_AP) || defined (CONFIG_RTL_8198_NFBI_BOARD)
 #define CONFIG_819X_PHY_RW 1
 #endif
@@ -124,6 +139,10 @@ extern uint32 br0SwFwdPortMask;
 static unsigned int curLinkPortMask=0;
 static unsigned int newLinkPortMask=0;
 
+#ifdef CONFIG_RTL_8197D_DYN_THR
+static int _8197d_link_check = 0;
+#endif
+
 #define SET_MODULE_OWNER(dev) do { } while (0)
 
 #if defined (CONFIG_RTL_HARDWARE_MULTICAST)
@@ -135,6 +154,23 @@ static unsigned int newLinkPortMask=0;
 #include "RTL8366RB_DRIVER/rtl8366rb_apiBasic.h"
 #endif
 
+#ifdef CONFIG_RTK_VOIP_PORT_LINK
+#include <net/netlink.h>
+#include <linux/rtnetlink.h>
+static int rtnl_fill_ifinfo_voip(struct sk_buff *skb, struct net_device *dev,
+			int type, u32 pid, u32 seq, u32 change, unsigned int flags);
+static void rtmsg_ifinfo_voip(int type, struct net_device *dev, unsigned change);
+#endif
+
+#ifdef CONFIG_RTK_VOIP_ETHERNET_DSP
+void voip_dsp_L2_pkt_rx(unsigned char* eth_pkt);
+#endif
+
+#ifdef CONFIG_RTK_VOIP_ETHERNET_DSP
+//merged from r8627 may conflict later
+void ( *voip_dsp_L2_pkt_rx_trap )(unsigned char* eth_pkt, unsigned long size) = NULL;	// pkshih: eth_pkt content may be modified!!
+#endif
+
 #if (defined(CONFIG_RTL_CUSTOM_PASSTHRU) && !defined(CONFIG_RTL8196_RTL8366))
 __DRAM_FWD static int oldStatus;
 static struct proc_dir_entry *res=NULL;
@@ -144,7 +180,7 @@ static int32 rtl8651_initStormCtrl(void);
 static inline int32 rtl_isPassthruFrame(uint8 *data);
 #endif
 
-#if (defined(CONFIG_RTL_8198))
+#if defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 static struct proc_dir_entry *phyTest_entry=NULL;
 #endif
 
@@ -181,6 +217,13 @@ EXPORT_SYMBOL(wirelessnet_hook);
 #endif
 #endif
 
+#if defined(BR_SHORTCUT_C2)
+__DRAM_FWD  unsigned char cached_eth_addr2[ETHER_ADDR_LEN];
+EXPORT_SYMBOL(cached_eth_addr2);
+__DRAM_FWD  struct net_device *cached_dev2;
+EXPORT_SYMBOL(cached_dev2);
+int last_used = 1;
+#endif
 
 #if defined(CONFIG_RTL_REINIT_SWITCH_CORE)
 #define STATE_NO_ERROR 0
@@ -213,6 +256,23 @@ static void linkup_time_handle(unsigned long arg);
 static int32 initPortStateCtrl(void);
 static void  exitPortStateCtrl(void);
 #endif
+
+#ifdef CONFIG_RTL_HW_VLAN_SUPPORT
+#define PORT_NUMBER 6
+struct hw_vlan_port_setting{
+	  int32 vlan_port_enabled;
+	  int32 vlan_port_bridge;
+	  int32 vlan_port_tag;
+	  int32 vlan_port_vid;
+};
+int rtl_hw_vlan_ignore_tagged_mc = 1;
+
+struct hw_vlan_port_setting hw_vlan_info[PORT_NUMBER];
+
+int32     rtl_hw_vlan_enable = 0;
+#endif
+
+
 #if defined(CONFIG_RTL_ETH_PRIV_SKB)
 __MIPS16 __IRAM_FWD static struct sk_buff *dev_alloc_skb_priv_eth(unsigned int size);
 static void init_priv_eth_skb_buf(void);
@@ -221,14 +281,25 @@ static void init_priv_eth_skb_buf(void);
 #if defined(CONFIG_RTK_QOS_FOR_CABLE_MODEM)
 static void rtl_initVlanTableForCableMode(void);
 #endif
+
+static int32 rtl819x_eee_proc_init(void);
+
 __DRAM_FWD static struct ring_que	rx_skb_queue;
 int skb_num=0;
 
 #if defined(CONFIG_RTL_MULTIPLE_WAN)
+#define MULTICAST_NETIF_VLAN_ID		678
+static char multiCastNetIf[20]={"multiCastNetIf"};
+static char multiCastNetIfMac[6]={ 0x00, 0x11, 0x12, 0x13, 0x14, 0x15 };
 static struct net_device *rtl_multiWan_net_dev;
 static int rtl_regist_multipleWan_dev(void);
 static int rtl_config_multipleWan_netif(int32 cmd);
 static int rtl_port_used_by_device(uint32 portMask);
+static int rtl865x_addMultiCastNetif(void);
+#if 0
+static int rtl865x_delMultiCastNetif(void);
+int rtl865x_setMultiCastSrcMac(unsigned char *srcMac);
+#endif
 #endif
 
 int32 rtl865x_init(void);
@@ -276,6 +347,14 @@ __IRAM_GEN static inline void rtl_link_change_interrupt_process(unsigned int sta
 static int rtl_rxTxDoneCnt = 0;
 static atomic_t rtl_devOpened;
 
+#if defined(CONFIG_RTL_PROC_DEBUG)
+extern unsigned int tx_ringFull_cnt;
+#endif
+
+#if defined(CONFIG_RTL_819XD)
+static int rtl_port0Refined = 0;
+#endif
+
 __MIPS16 __IRAM_GEN void rtl_rxSetTxDone(int enable)
 {
 	if (unlikely(rtl_devOpened.counter==0))
@@ -309,14 +388,43 @@ static unsigned int rxRingSize[RTL865X_SWNIC_RXRING_HW_PKTDESC] =
 	NUM_RX_PKTHDR_DESC3,
 	NUM_RX_PKTHDR_DESC4,
 	NUM_RX_PKTHDR_DESC5};
+
+#if defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+static unsigned int txRingSize[RTL865X_SWNIC_TXRING_HW_PKTDESC] =
+	{NUM_TX_PKTHDR_DESC,
+	NUM_TX_PKTHDR_DESC1,
+	NUM_TX_PKTHDR_DESC2,
+	NUM_TX_PKTHDR_DESC3
+	};
+#else
 static unsigned int txRingSize[RTL865X_SWNIC_TXRING_HW_PKTDESC] =
 	{NUM_TX_PKTHDR_DESC,
 	NUM_TX_PKTHDR_DESC1};
+#endif
 
 #if defined (CONFIG_RTL_MULTI_LAN_DEV)||defined(CONFIG_RTK_VLAN_SUPPORT)
 static  struct rtl865x_vlanConfig packedVlanConfig[NETIF_NUMBER];
 #endif
 
+#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+
+	int  vlan_enable;
+	int  vlan_tag;
+	int  vlan_bridge_enable;
+	int  vlan_bridge_tag;
+	int  vlan_bridge_port;
+	int  vlan_bridge_multicast_enable;
+    int  vlan_bridge_multicast_tag;
+
+	int vlan_host_enable;
+	int vlan_host_tag;
+	int vlan_host_pri;
+	int vlan_wifi_enable[5];
+	int vlan_wifi_tag[5];
+	int vlan_wifi_pri[5];
+
+#endif
+
 /*
 linux protocol stack netif VS rtl819x driver network interface
 the name of ps netif maybe different with driver.
@@ -352,6 +460,9 @@ static struct rtl865x_vlanConfig vlanconfig[] = {
 #ifdef CONFIG_8198_PORT5_GMII
 	{	RTL_DRV_LAN_P5_NETIF_NAME, 	0,	 IF_ETHER,	RTL_LANVLANID,	RTL_LAN_FID,		RTL_LANPORT_MASK_5, 	RTL_LANPORT_MASK_5, 	1500,	{ { 0x00, 0x12, 0x34, 0x56, 0x78, 0x95 } }, 0	},
 #endif //CONFIG_8198_PORT5_GMII
+#ifdef CONFIG_RTK_VLAN_NEW_FEATURE
+	{	RTL_DRV_LAN_P7_NETIF_NAME,	0,	 IF_ETHER,	RTL_LANVLANID,	RTL_LAN_FID,	0, 	0, 	1500,	{ { 0x00, 0x12, 0x34, 0x56, 0x78, 0x97 } }, 0	},
+#endif
 #endif
 #endif
 #else	/*CONFIG_BRIDGE*/
@@ -368,6 +479,9 @@ static struct rtl865x_vlanConfig vlanconfig[] = {
 	{	RTL_DRV_LAN_P1_NETIF_NAME,	0,   IF_ETHER, 	RTL_LANVLANID,	RTL_LAN_FID,		RTL_LANPORT_MASK_3, 	RTL_LANPORT_MASK_3,		1500, 	{ { 0x00, 0x12, 0x34, 0x56, 0x78, 0x92 } }, 0	},
 	{	RTL_DRV_LAN_P2_NETIF_NAME, 	0,   IF_ETHER, 	RTL_LANVLANID,	RTL_LAN_FID,		RTL_LANPORT_MASK_2, 	RTL_LANPORT_MASK_2,		1500, 	{ { 0x00, 0x12, 0x34, 0x56, 0x78, 0x93 } }, 0	},
 	{	RTL_DRV_LAN_P3_NETIF_NAME, 	0,   IF_ETHER, 	RTL_LANVLANID, 	RTL_LAN_FID,		RTL_LANPORT_MASK_1, 	RTL_LANPORT_MASK_1,		1500, 	{ { 0x00, 0x12, 0x34, 0x56, 0x78, 0x94 } }, 0	},
+#ifdef CONFIG_RTK_VLAN_NEW_FEATURE
+	{	RTL_DRV_LAN_P7_NETIF_NAME,	0,	 IF_ETHER,	RTL_LANVLANID,	RTL_LAN_FID,	0,	0,	1500,	{ { 0x00, 0x12, 0x34, 0x56, 0x78, 0x97 } }, 0	},
+#endif
 #endif
 #endif
 #endif
@@ -401,6 +515,10 @@ EXPORT_SYMBOL(eth_skb_free_num);
 extern struct sk_buff *dev_alloc_8190_skb(unsigned char *data, int size);
 #endif
 
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+	struct vlan_info management_vlan;
+#endif
+
 #ifdef CONFIG_POCKET_AP_SUPPORT
 int rtl865x_curOpMode=BRIDGE_MODE;
 #else
@@ -438,8 +556,24 @@ static int read_proc_vlan(char *page, char **start, off_t off,int count, int *eo
 static int write_proc_vlan(struct file *file, const char *buffer,unsigned long count, void *data);
 static int32 rtk_vlan_support_read( char *page, char **start, off_t off, int count, int *eof, void *data );
 static int32 rtk_vlan_support_write( struct file *filp, const char *buff,unsigned long len, void *data );
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+static int rtk_vlan_management_read(char *page, char **start, off_t off, int count, int *eof, void *data);
+static int rtk_vlan_management_write(struct file *file, const char *buffer, unsigned long len, void *data);
+#endif
+
 //__DRAM_FWD int rtk_vlan_support_enable;
 int rtk_vlan_support_enable;
+
+
+#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+static int32 rtk_vlan_wan_tag_getportmask(int bridge_port);
+static int32 rtk_vlan_wan_tag_support_read( char *page, char **start, off_t off, int count, int *eof, void *data );
+static int32 rtk_vlan_wan_tag_support_write( struct file *filp, const char *buff,unsigned long len, void *data );
+static int32 rtk_vlan_wan_tag_cpu_support_read( char *page, char **start, off_t off, int count, int *eof, void *data );
+static int32 rtk_vlan_wan_tag_cpu_support_write( struct file *filp, const char *buff,unsigned long len, void *data );
+#endif
+
+
 #if defined(CONFIG_819X_PHY_RW) //#if defined(CONFIG_RTK_VLAN_FOR_CABLE_MODEM)
 static int32 rtl_phy_status_read( char *page, char **start, off_t off, int count, int *eof, void *data );
 static int32 rtl_phy_status_write( struct file *filp, const char *buff,unsigned long len, void *data );
@@ -509,6 +643,15 @@ struct port_mibStatistics  {
 #endif	//#if defined(CONFIG_819X_PHY_RW)
 #endif
 
+#if defined(CONFIG_RTL_HW_VLAN_SUPPORT)
+static int32 rtl_hw_vlan_support_read( char *page, char **start, off_t off, int count, int *eof, void *data );
+static int32 rtl_hw_vlan_support_write( struct file *filp, const char *buff,unsigned long len, void *data );
+static int32 rtl_hw_vlan_tagged_bridge_multicast_read( char *page, char **start, off_t off, int count, int *eof, void *data );
+static int32 rtl_hw_vlan_tagged_bridge_multicast_write( struct file *filp, const char *buff,unsigned long len, void *data );
+int rtl_process_hw_vlan_tx(rtl_nicTx_info *txInfo);
+#endif
+
+
 #if defined(RTL8196C_EEE_MAC)
 extern int eee_enabled;
 extern void eee_phy_enable(void);
@@ -734,6 +877,90 @@ void disable_led_ctrl(int port)
 }
 #endif // PATCH_GPIO_FOR_LED
 
+#if defined(CONFIG_RTL_819XD)&&defined(CONFIG_RTL_8211DS_SUPPORT)&&defined(CONFIG_RTL_8197D)
+int lanPortMask = 0x10f;
+int wanPortMask = 0x10;
+#if defined(CONFIG_RTK_VLAN_SUPPORT) || defined (CONFIG_RTL_MULTI_LAN_DEV)
+int  lanPortMask1 = 0x8;
+int  lanPortMask2 = 0x4;
+int  lanPortMask3 = 0x2;
+int  lanPortMask4 = 0x1;
+#endif
+
+#undef	RTL_WANPORT_MASK
+#undef	RTL_LANPORT_MASK
+#if defined(CONFIG_RTK_VLAN_SUPPORT) || defined (CONFIG_RTL_MULTI_LAN_DEV)
+#undef 	RTL_LANPORT_MASK_1
+#undef	RTL_LANPORT_MASK_2
+#undef 	RTL_LANPORT_MASK_3
+#undef 	RTL_LANPORT_MASK_4
+#endif
+
+#define	RTL_WANPORT_MASK		wanPortMask
+#define	RTL_LANPORT_MASK		lanPortMask
+#if defined(CONFIG_RTK_VLAN_SUPPORT) || defined (CONFIG_RTL_MULTI_LAN_DEV)
+#define 	RTL_LANPORT_MASK_1	lanPortMask1
+#define	RTL_LANPORT_MASK_2	lanPortMask2
+#define 	RTL_LANPORT_MASK_3	lanPortMask3
+#define 	RTL_LANPORT_MASK_4	lanPortMask4
+#endif
+
+void rtl_setPppMask(void)
+{
+	int i;
+	int totalVlans;
+	totalVlans=((sizeof(vlanconfig))/(sizeof(struct rtl865x_vlanConfig)))-1;
+	for(i=0;i<totalVlans;i++)
+	{
+		if(vlanconfig[i].if_type==IF_PPPOE){
+			vlanconfig[i].memPort = 0x1;
+			vlanconfig[i].untagSet = 0x1;
+		}
+	}
+}
+
+void rtl_resetRegisterNotFound8211ds(void)
+{
+	REG32(0xbb804104) =0x00FF2039;
+	REG32(0xbb80414c) =0;
+	REG32(0xbb804100) =0;
+}
+
+void rtl_setPortMask(uint32 reg_data)
+{
+	if((reg_data != 0)&&(reg_data != 0xFFFF))
+	{
+		/*8211ds is found*/
+		lanPortMask   = 0x11e;
+		wanPortMask = 0x1;
+		#if defined(CONFIG_RTK_VLAN_SUPPORT) || defined (CONFIG_RTL_MULTI_LAN_DEV)
+		lanPortMask1 = 0x10;
+		lanPortMask2 = 0x8;
+		lanPortMask3 = 0x4;
+		lanPortMask4 = 0x2;
+		#endif
+		rtl_setPppMask();
+
+		// Flow control DSC tolerance: change to 32 pages to fix "port 0 (8211D) has Rx CRC" issue.
+		REG32(MACCR) = (REG32(MACCR) & ~CF_FCDSC_MASK) | (0x20 << CF_FCDSC_OFFSET);
+	}
+	else
+	{
+		/*8211ds is not found*/
+		lanPortMask   = 0x10f;
+		wanPortMask = 0x10;
+		#if defined(CONFIG_RTK_VLAN_SUPPORT) || defined (CONFIG_RTL_MULTI_LAN_DEV)
+		lanPortMask1 = 0x8;
+		lanPortMask2 = 0x4;
+		lanPortMask3 = 0x2;
+		lanPortMask4 = 0x1;
+		#endif
+		rtl_resetRegisterNotFound8211ds();
+	}
+}
+#endif
+
+
 /*
 device mapping mainten
 */
@@ -1081,7 +1308,23 @@ static void rtl865x_disableDevPortForward(struct net_device *dev, struct dev_pri
 	_96c_esd_counter = 0;		// stop counting
 #endif
 }
-#if defined(CONFIG_819X_PHY_RW)//#if defined(CONFIG_RTK_VLAN_FOR_CABLE_MODEM)
+
+#if !defined(CONFIG_RTL_8196C)
+static void rtl865x_restartDevPHYNway(struct net_device *dev, struct dev_priv *cp)
+{
+	int port;
+	for(port=0;port<RTL8651_AGGREGATOR_NUMBER;port++)
+	{
+		if((1<<port) & cp->portmask)
+		{
+			rtl8651_restartAsicEthernetPHYNway(port);
+		}
+	}
+	return;
+}
+#endif
+
+#if defined(CONFIG_819X_PHY_RW) || defined(CONFIG_RTL_HW_VLAN_SUPPORT)
 static void rtl865x_setPortForward(int port_num, int forward)
 {
 	if(port_num < 0 || port_num >= RTL8651_AGGREGATOR_NUMBER)
@@ -1209,9 +1452,9 @@ static void refill_rx_skb(void)
 	idx = RTL865X_SWNIC_RXRING_MAX_PKTDESC -1;
 
 #ifdef DELAY_REFILL_ETH_RX_BUF
-	while (rx_skb_queue.qlen < rtl865x_maxPreAllocRxSkb || ((idx>=0)&&(SUCCESS==check_rx_pkthdr_ring(idx, &idx)))) 
+	while (rx_skb_queue.qlen < rtl865x_maxPreAllocRxSkb || ((idx>=0)&&(SUCCESS==check_rx_pkthdr_ring(idx, &idx))))
 #else
-	while (rx_skb_queue.qlen < rtl865x_maxPreAllocRxSkb) 
+	while (rx_skb_queue.qlen < rtl865x_maxPreAllocRxSkb)
 #endif
 	{
 		#if defined(CONFIG_RTL_ETH_PRIV_SKB)
@@ -1363,7 +1606,7 @@ void tx_done_callback(void *skb)
 				((struct sk_buff *)skb)->srcVlanPriority=0;
 #endif
 
-#if defined(CONFIG_NETFILTER_XT_MATCH_PHYPORT)|| defined(CONFIG_RTL_FAST_FILTER) || defined(CONFIG_RTL_QOS_PATCH)
+#if defined(CONFIG_NETFILTER_XT_MATCH_PHYPORT)|| defined(CONFIG_RTL_FAST_FILTER) || defined(CONFIG_RTL_QOS_PATCH) || defined(CONFIG_RTK_VOIP_QOS) || defined(CONFIG_RTK_VLAN_WAN_TAG_SUPPORT)
 				((struct sk_buff *)skb)->srcPhyPort=0xFF;
 				((struct sk_buff *)skb)->dstPhyPort=0xFF;
 #endif
@@ -1620,6 +1863,11 @@ static inline void re865x_relayTrappedMCast(struct sk_buff *skb, unsigned int vi
 	rtl_nicTx_info	nicTx;
  	struct sk_buff *skb2=NULL;
 
+    #ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+	struct sk_buff *skb_wan=NULL;
+	rtl_nicTx_info	nicTx_wan;
+	#endif
+
 	if(mcastFwdPortMask==0)
 	{
 		return;
@@ -1637,12 +1885,40 @@ static inline void re865x_relayTrappedMCast(struct sk_buff *skb, unsigned int vi
        if(skb2!=NULL)
        {
        	nicTx.txIdx=0;
-#if defined(CONFIG_RTL_QOS_PATCH)
+#if defined(CONFIG_RTL_QOS_PATCH)|| defined(CONFIG_RTK_VOIP_QOS)
 	if(((struct sk_buff *)skb)->srcPhyPort == QOS_PATCH_RX_FROM_LOCAL){
 		nicTx.priority = QOS_PATCH_HIGH_QUEUE_PRIO;
 		nicTx.txIdx=RTL865X_SWNIC_TXRING_MAX_PKTDESC-1;	//use the highest tx ring index, note: not RTL865X_SWNIC_TXRING_HW_PKTDESC-1
 	}
 #endif
+
+#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+	//fix tim; upnp
+    if( vlan_enable && vlan_bridge_enable && vlan_bridge_multicast_enable)
+	{
+		if((vid == vlan_bridge_tag)&& (mcastFwdPortMask & RTL_WANPORT_MASK))
+		{
+			mcastFwdPortMask &= (~RTL_WANPORT_MASK);
+			skb_wan = skb_copy(skb, GFP_ATOMIC);
+			 if(skb_wan!=NULL)
+		     {
+		       	nicTx_wan.txIdx=0;
+                nicTx_wan.vid = vlan_bridge_multicast_tag;
+				nicTx_wan.portlist = RTL_WANPORT_MASK;
+				nicTx_wan.srcExtPort = 0;
+				nicTx_wan.flags = (PKTHDR_USED|PKT_OUTGOING);
+				// flush cache 0515 by tim
+				_dma_cache_wback_inv((unsigned long) skb_wan->data, skb_wan->len);
+				if (swNic_send((void *)skb_wan, skb_wan->data, skb_wan->len, &nicTx_wan) < 0)
+				{
+					dev_kfree_skb_any(skb_wan);
+				}
+
+			}
+		}
+	}
+#endif
+
 		nicTx.vid = vid;
 		nicTx.portlist = mcastFwdPortMask;
 		nicTx.srcExtPort = 0;
@@ -1716,7 +1992,16 @@ static bool rtl_MulticastRxFilterOff(struct sk_buff *skb, int ipversion)
 		skb->data = skb->data+ETH_HLEN;
 
 	if(ipversion ==4)
+	{
+		struct net_device	*origDev=skb->dev;
+		if((skb->dev->br_port!=NULL))
+		{
+			skb->dev=__dev_get_by_name(dev_net(skb->dev),RTL_PS_BR0_DEV_NAME);
+			
+		}
 		ret = ((IgmpRxFilter_Hook(skb, NF_INET_PRE_ROUTING,  skb->dev, NULL,dev_net(skb->dev)->ipv4.iptable_filter)) !=NF_ACCEPT);
+		skb->dev=origDev;
+	}
 	else if(ipversion ==6)
 		ret = false;//ipv6 hava no iptables rule now
 
@@ -1786,13 +2071,41 @@ int  rtl_MulticastRxCheck(struct sk_buff *skb,rtl_nicRx_info *info)
 
 				/*relay packets which are trapped by hardware multicast table*/
 				#if defined (CONFIG_RTL_HARDWARE_MULTICAST)
+                #ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT//fim tim
+				if(vlan_enable && vlan_bridge_enable && !strcmp(cp_this->dev->name,RTL_PS_ETH_NAME_ETH2))
+				{
+					if(igmpsnoopenabled && (nicIgmpModuleIndex_2!=0xFFFFFFFF))
+					{
+						multicastDataInfo.ipVersion=4;
+						multicastDataInfo.sourceIp[0]=  (uint32)(iph->saddr);
+						multicastDataInfo.groupAddr[0]=  (uint32)(iph->daddr);
+						ret=rtl_getMulticastDataFwdInfo(nicIgmpModuleIndex_2, &multicastDataInfo, &nicMCastFwdInfo);
+						vlanRelayPortMask=rtl865x_getVlanPortMask(vid)& (~(1<<pid)) & nicMCastFwdInfo.fwdPortMask & ((1<<RTL8651_MAC_NUMBER)-1);
+						if(ret==SUCCESS)
+						{
+
+						}
+						else
+						{
+							ret=rtl_getMulticastDataFwdInfo(brIgmpModuleIndex_2, &multicastDataInfo, &br0MCastFwdInfo);
+							if(ret==SUCCESS)
+							{
+								/*there is wireless client,can not flooding in vlan */
+								vlanRelayPortMask=0;
+							}
+						}
+
+					}
+				}
+				else
+				#endif
 				if(igmpsnoopenabled && (nicIgmpModuleIndex!=0xFFFFFFFF))
 				{
 					multicastDataInfo.ipVersion=4;
 					multicastDataInfo.sourceIp[0]=  (uint32)(iph->saddr);
 					multicastDataInfo.groupAddr[0]=  (uint32)(iph->daddr);
 					ret=rtl_getMulticastDataFwdInfo(nicIgmpModuleIndex, &multicastDataInfo, &nicMCastFwdInfo);
-					vlanRelayPortMask=rtl865x_getVlanPortMask(vid)& (~(1<<pid)) & nicMCastFwdInfo.fwdPortMask & ((1<<RTL8651_MAC_NUMBER)-1);
+					vlanRelayPortMask=rtl865x_getVlanPortMask(vid)& (~(1<<pid)) & nicMCastFwdInfo.fwdPortMask &cp_this->portmask& ((1<<RTL8651_MAC_NUMBER)-1);
 
 					if(ret==SUCCESS)
 					{
@@ -1814,6 +2127,18 @@ int  rtl_MulticastRxCheck(struct sk_buff *skb,rtl_nicRx_info *info)
 			}
 			else if(l4Protocol==IPPROTO_IGMP)
 			{
+                #ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+				if(vlan_enable && vlan_bridge_enable && !strcmp(cp_this->dev->name,RTL_PS_ETH_NAME_ETH2))
+				{
+					if(igmpsnoopenabled && (nicIgmpModuleIndex_2!=0xFFFFFFFF))
+					{
+						rtl_igmpMldProcess(nicIgmpModuleIndex_2, skb->data, pid, &vlanRelayPortMask);
+						//just flooding
+						vlanRelayPortMask=rtl865x_getVlanPortMask(vid) & (~(1<<pid)) & ((1<<RTL8651_MAC_NUMBER)-1);
+					}
+				}
+				else
+				#endif
 				if(igmpsnoopenabled && (nicIgmpModuleIndex!=0xFFFFFFFF))
 				{
 					/*igmp packet*/
@@ -1886,7 +2211,7 @@ int  rtl_MulticastRxCheck(struct sk_buff *skb,rtl_nicRx_info *info)
 
 					ret=rtl_getMulticastDataFwdInfo(nicIgmpModuleIndex, &multicastDataInfo, &nicMCastFwdInfo);
 
-					vlanRelayPortMask=rtl865x_getVlanPortMask(vid)& (~(1<<pid)) & nicMCastFwdInfo.fwdPortMask & ((1<<RTL8651_MAC_NUMBER)-1);
+					vlanRelayPortMask=rtl865x_getVlanPortMask(vid)& (~(1<<pid)) & nicMCastFwdInfo.fwdPortMask &cp_this->portmask& ((1<<RTL8651_MAC_NUMBER)-1);
 					if(ret==SUCCESS)
 					{
 
@@ -2144,18 +2469,21 @@ static inline int32 rtl_decideRxDevice(rtl_nicRx_info *info)
 	#if defined(CONFIG_RTL_STP)
 	int32 			dev_no;
 	#endif
-	#if defined(CONFIG_RTL_CUSTOM_PASSTHRU)
+	#if defined(CONFIG_RTL_CUSTOM_PASSTHRU_PPPOE)
 	unsigned char dest_mac[MAX_ADDR_LEN];
 	#endif
 
+#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+	int32 vid=0;
+	vid = info->vid;
+#endif
 	pid = info->pid;
 	skb = info->input;
 	data = skb->data;
-	#if defined(CONFIG_RTL_CUSTOM_PASSTHRU)
+	#if defined(CONFIG_RTL_CUSTOM_PASSTHRU_PPPOE)
 	memcpy(dest_mac, data, 6);
 	#endif
 
-
 	info->isPdev=FALSE;
 	ret = SUCCESS;
 
@@ -2206,11 +2534,53 @@ static inline int32 rtl_decideRxDevice(rtl_nicRx_info *info)
 		{
 			cp = ((struct dev_priv *)_rtl86xx_dev.dev[i]->priv);
 			//printk("=========%s(%d),cp(%s),i(%d)\n",__FUNCTION__,__LINE__,cp->dev->name,i);
+ #ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+			if(vlan_enable && (*((unsigned short *)(skb->data+(ETH_ALEN<<1)))== __constant_htons(ETH_P_8021Q)))
+        	{
+        		vid = *((unsigned short *)(skb->data+(ETH_ALEN<<1)+2))&0x0fff;
+                if( vlan_enable && vlan_bridge_enable && vlan_bridge_multicast_enable &&(vid == vlan_bridge_multicast_tag))
+       			{
+					vid = vlan_bridge_tag;
+				}
+            	else if(vlan_host_enable && vid == vlan_host_tag)
+                {
+					vid = vlan_tag;
+                }
+                else if(
+                	(vlan_wifi_enable[0] && vid == vlan_wifi_tag[0]) ||
+                	(vlan_wifi_enable[1] && vid == vlan_wifi_tag[1])||
+                	(vlan_wifi_enable[2] && vid == vlan_wifi_tag[2])||
+                	(vlan_wifi_enable[3] && vid == vlan_wifi_tag[3])||
+                	(vlan_wifi_enable[4] && vid == vlan_wifi_tag[4])
+                	)
+                {
+					vid = vlan_tag;
+                }
+
+				if(cp && cp->opened && (vid==cp->id))
+				{
+					info->priv = cp;
+					ret = SUCCESS;
+					break;
+				}
+			}
+			else
+			{
+				if(cp && cp->opened && (cp->portmask & (1<<pid)))
+				{
+						info->priv = cp;
+						ret = SUCCESS;
+						break;
+
+					}
+				}
+		#else
 			if(cp && cp->opened && (cp->portmask & (1<<pid)))
 			{
 				info->priv = cp;
 				break;
 			}
+		#endif
 		}
 
 		//printk("====%s(%d),dev(%s),i(%d)\n",__FUNCTION__,__LINE__,cp->dev->name,i);
@@ -2218,11 +2588,14 @@ static inline int32 rtl_decideRxDevice(rtl_nicRx_info *info)
 		{
 			info->priv = NULL;
 			dev_kfree_skb_any(skb);
-			ret = FAILED;;
+			ret = FAILED;
 		}
 		#if defined(CONFIG_RTL_CUSTOM_PASSTHRU)
 		else if (SUCCESS==rtl_isPassthruFrame(data)&&(rtl_isWanDev(cp)==TRUE)
-			&& (compare_ether_addr((char* )cp->dev->dev_addr, (char*)dest_mac)))
+			#if defined(CONFIG_RTL_CUSTOM_PASSTHRU_PPPOE)
+			&& (compare_ether_addr((char* )cp->dev->dev_addr, (char*)dest_mac))
+			#endif
+			)
 		{
 			info->priv = _rtl86xx_dev.pdev->priv;
 			info->isPdev=TRUE;
@@ -2241,6 +2614,11 @@ __IRAM_FWD
 static inline int32 rtl_processBridgeShortCut(struct sk_buff *skb, struct dev_priv *cp_this, rtl_nicRx_info *info)
 {
 	struct net_device *dev;
+	/*2011-09-13 fix wlan sta can not access internet when wan mac clone sta mac*/
+	if(rtl_isWanDev(cp_this))
+	{
+		return FAILED;
+	}
 
 	if (
 		#if 0
@@ -2254,14 +2632,56 @@ static inline int32 rtl_processBridgeShortCut(struct sk_buff *skb, struct dev_pr
 	#else
 		((dev = get_shortcut_dev(skb->data)) != NULL)
 	#endif
+    #ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+		&& rtl865x_same_root(skb->dev,dev)
+	#endif
 	)
 	{
 		#if defined(CONFIG_RTL_HARDWARE_NAT)
 		if (memcmp(&skb->data[ETH_ALEN], cp_this->dev->dev_addr, ETH_ALEN))
 		#endif
 		{
+			#ifdef BR_SHORTCUT_C2
+			/*
+			if (cached_dev == NULL) {
+				memcpy(cached_eth_addr, &skb->data[ETH_ALEN], ETH_ALEN);
+				cached_dev = cp_this->dev;
+				last_used = 0;
+			}
+
+			else if (cached_dev2 == NULL) {
+				memcpy(cached_eth_addr2, &skb->data[ETH_ALEN], ETH_ALEN);
+				cached_dev2 = cp_this->dev;
+				last_used = 1;
+			}
+
+			else */
+			if (memcmp(cached_eth_addr, &skb->data[ETH_ALEN], ETH_ALEN) == 0) {
+				//memcpy(cached_eth_addr, &skb->data[ETH_ALEN], ETH_ALEN);
+				cached_dev = cp_this->dev;
+				last_used = 0;
+			}
+			else if (memcmp(cached_eth_addr2, &skb->data[ETH_ALEN], ETH_ALEN) == 0) {
+				//memcpy(cached_eth_addr2, &skb->data[ETH_ALEN], ETH_ALEN);
+				cached_dev2 = cp_this->dev;
+				last_used = 1;
+			}
+			else if (last_used == 1) {
+				memcpy(cached_eth_addr, &skb->data[ETH_ALEN], ETH_ALEN);
+				cached_dev = cp_this->dev;
+				last_used = 0;
+			}
+			else if (last_used == 0) {
+				memcpy(cached_eth_addr2, &skb->data[ETH_ALEN], ETH_ALEN);
+				cached_dev2 = cp_this->dev;
+				last_used = 1;
+			}
+
+
+			#else
 			memcpy(cached_eth_addr, &skb->data[ETH_ALEN], ETH_ALEN);
 			cached_dev = cp_this->dev;
+			#endif
 		}
 
 		#if defined(CONFIG_RTL_HW_QOS_SUPPORT) && defined(CONFIG_RTL_HARDWARE_NAT)
@@ -2382,8 +2802,12 @@ static inline void rtl_processRxFrame(rtl_nicRx_info *info)
 	if  ((memcmp(&data[ETH_ALEN], cp_this->dev->dev_addr, ETH_ALEN)==0)||PKTHDR_EXTPORT_MAGIC2==vid||PKTHDR_EXTPORT_MAGIC==vid)// check source mac
 	{
 		#if	defined(CONFIG_RTL_HARDWARE_NAT)&&(defined(CONFIG_RTL8192SE)||defined(CONFIG_RTL8192CD))
+                #ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+		if ((PKTHDR_EXTPORT_MAGIC!=vid)||(info->pid!=PKTHDR_EXTPORT_P3 &&info->pid!=PKTHDR_EXTPORT_P2))
+                 #else
 		if ((PKTHDR_EXTPORT_MAGIC!=vid)||(info->pid!=PKTHDR_EXTPORT_P3))
 		#endif
+		#endif
 		{
 			cp_this->net_stats.rx_dropped++;
 			dev_kfree_skb_any(skb);
@@ -2405,7 +2829,76 @@ static inline void rtl_processRxFrame(rtl_nicRx_info *info)
 	skb->dev=info->isPdev?_rtl86xx_dev.pdev:info->priv->dev;
 	//skb->dev=cp_this->dev;
 
-#if defined(CONFIG_NETFILTER_XT_MATCH_PHYPORT) || defined(CONFIG_RTL_FAST_FILTER) || defined(CONFIG_RTL_QOS_PATCH)
+#ifdef CONFIG_RTK_VOIP_ETHERNET_DSP
+	//merged from r8627 may conflict later
+	//printk("type: %x, skb->mac=%p, skb->data=%p\n", skb->mac.ethernet->h_proto, skb->mac.ethernet, skb->data);
+	//extern void voip_dsp_L2_pkt_rx(unsigned char* eth_pkt);
+	if (*(uint16*)(&(skb->data[12])) == htons(0x8899) && voip_dsp_L2_pkt_rx_trap )
+	{
+		//dsp_id = *(uint16*)(&(skb->data[14]);
+		voip_dsp_L2_pkt_rx_trap(skb->data, skb->len);
+		dev_kfree_skb_any(skb);
+		//printk("0x%x ", *(uint16*)(&(skb->data[12])));
+		return;
+	}
+#endif
+
+#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+        if (*((unsigned short *)(skb->data+(ETH_ALEN<<1))) == __constant_htons(ETH_P_8021Q))
+        {
+        		vid = *((unsigned short *)(data+(ETH_ALEN<<1)+2))&0x0fff;
+                if(vlan_enable)
+                {
+               		//for later arp reply to WAN port
+                	memcpy(&(skb->tag), skb->data+ETH_ALEN*2, VLAN_HLEN);
+
+	                if(vid == vlan_tag)
+                	{
+						goto remove_vlan_tag;
+                	}
+	                else if(vlan_bridge_enable && vid == vlan_bridge_tag)
+	                {
+	                		if(vlan_bridge_multicast_enable)
+	                		{
+	                			if((skb->data[0]==0x01) && (skb->data[1]==0x00) && (skb->data[2]==0x5e))
+        				 		{
+        				 				goto drop;
+        				 		}
+	                		}
+	                		goto remove_vlan_tag;
+                	}
+                    else if(vlan_bridge_enable && vlan_bridge_multicast_enable && (vid == vlan_bridge_multicast_tag))
+					{
+					 	 if((skb->data[0]==0x01) && (skb->data[1]==0x00) && (skb->data[2]==0x5e))
+        				 {
+	                        info->vid = vlan_bridge_tag;//for later check
+	                        goto remove_vlan_tag;
+	                     }
+	                     //goto drop;
+	                }
+	               else if((vlan_host_enable && vid == vlan_host_tag) ||
+                	(vlan_wifi_enable[0] && vid == vlan_wifi_tag[0]) ||
+                	(vlan_wifi_enable[1] && vid == vlan_wifi_tag[1])||
+                	(vlan_wifi_enable[2] && vid == vlan_wifi_tag[2])||
+                	(vlan_wifi_enable[3] && vid == vlan_wifi_tag[3])||
+                	(vlan_wifi_enable[4] && vid == vlan_wifi_tag[4]))
+                	{
+                		goto remove_vlan_tag;
+					}
+                }
+		drop:
+			cp_this->net_stats.rx_dropped++;
+			dev_kfree_skb_any(skb);
+			return;
+		remove_vlan_tag:
+			memmove(skb->data + VLAN_HLEN, skb->data, VLAN_ETH_ALEN<<1);
+			skb->len -= 4;
+			skb->data += 4;
+        }
+
+#endif
+
+#if defined(CONFIG_NETFILTER_XT_MATCH_PHYPORT) || defined(CONFIG_RTL_FAST_FILTER) || defined(CONFIG_RTL_QOS_PATCH) || defined(CONFIG_RTK_VOIP_QOS) || defined(CONFIG_RTK_VLAN_WAN_TAG_SUPPORT)
 	skb->srcPhyPort=(uint8)pid;
 #endif
 	//printk("=======%s(%d),cp_this(%s)\n",__FUNCTION__,__LINE__,cp_this->dev->name);
@@ -2413,12 +2906,27 @@ static inline void rtl_processRxFrame(rtl_nicRx_info *info)
 	#if defined(CONFIG_RTK_VLAN_SUPPORT)
 	if (rtk_vlan_support_enable && cp_this->vlan_setting.global_vlan)
 	{
+	#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+		struct sk_buff *new_skb = NULL;
+		int vlan_check;
+		vlan_check = rx_vlan_process(cp_this->dev, &cp_this->vlan_setting, skb, &new_skb);
+		if((vlan_check==0) && new_skb){
+			rtl_processRxToProtcolStack(new_skb, cp_this);
+		}else if(vlan_check == 1){
+			cp_this->net_stats.rx_dropped++;
+			dev_kfree_skb_any(skb);
+			return;
+		}else if((vlan_check == 2) && new_skb){
+			dev_kfree_skb_any(new_skb);
+		}
+	#else
 		if (rx_vlan_process(cp_this->dev, &cp_this->vlan_setting, skb))
 		{
 			cp_this->net_stats.rx_dropped++;
 			dev_kfree_skb_any(skb);
 			return;
 		}
+	#endif
 
 		#if defined(CONFIG_RTK_VLAN_FOR_CABLE_MODEM)
 		if(rtk_vlan_support_enable == 2)
@@ -2447,6 +2955,12 @@ static inline void rtl_processRxFrame(rtl_nicRx_info *info)
 	#endif	/*	defined(CONFIG_RTK_VLAN_SUPPORT)	*/
 
 	if (*((uint16*)(skb->data+(ETH_ALEN<<1))) == __constant_htons(ETH_P_8021Q)) {
+		#if defined(CONFIG_RTL_HW_VLAN_SUPPORT)
+		if((skb->data[0]&1)||((skb->data[0]==0x33)&&(skb->data[1]==0x33)&&(skb->data[2]!=0xFF)))
+		{
+			memcpy(&skb->tag, skb->data+ETH_ALEN*2, sizeof(struct vlan_tag));
+		}
+		#endif
 		vid = *((unsigned short *)(data+(ETH_ALEN<<1)+2));
 		#if	defined(CONFIG_RTL_QOS_8021P_SUPPORT)
 		skb->srcVlanPriority = (vid>>13)&0x7;
@@ -2479,6 +2993,10 @@ static inline void rtl_processRxFrame(rtl_nicRx_info *info)
 		}
 		#endif
 
+		#if defined(CONFIG_RTL_FASTBRIDGE)
+		if (RTL_FB_RETURN_SUCCESS==rtl_fb_process_in_nic(skb, cp_this->dev))
+			return;
+		#endif
 		/*	shortcut process end	*/
 
 		/*	unknow unicast control	*/
@@ -2681,9 +3199,9 @@ static int re865x_setPhyGrayCode(void)
 
 				/*=========== ###02 ===========*/
 				/*
-				  1.      reg17 = 0x1f10Aread reg29, for SNR
-				  2.      reg17 =  0x1f11Aread reg29, for AGC
-				  3.      reg17 = 0x1f18Aread reg29, for cb0
+				  1.      reg17 = 0x1f10read reg29, for SNR
+				  2.      reg17 =  0x1f11read reg29, for AGC
+				  3.      reg17 = 0x1f18read reg29, for cb0
 				 */
 				// 1. for SNR
 				snr = 0;
@@ -2783,7 +3301,7 @@ static int re865x_checkPhySnr(void)
 		if((1<<port) & (newLinkPortMask & (~curLinkPortMask)) )
 		{
 			snr=re865x_getPhySnr(port);
-		
+
 			// 3. for cb0
                         rtl8651_getAsicEthernetPHYReg( port, 17, &val );
                         val = (val & 0xfff0) | 0x8;
@@ -2797,7 +3315,7 @@ static int re865x_checkPhySnr(void)
 			//printk("snr is %d\n",snr);
 			//printk("cb0 is 0x%x,agc is 0x%x\n",cb0,agc);
 			//if( ((cb0 & 0x80) != 0)|| (snr>4155))
-		  	if ( ( ( ((agc & 0x70) >> 4) < 4    ) && ((cb0 & 0x80) != 0) ) || (snr > 4155) ) 
+		  	if ( ( ( ((agc & 0x70) >> 4) < 4    ) && ((cb0 & 0x80) != 0) ) || (snr > 4155) )
 			{
 				//printk("restart nway\n");
 				rtl8651_restartAsicEthernetPHYNway(port);
@@ -2889,7 +3407,7 @@ unsigned int rtl865x_getPhysicalPortLinkStatus(void)
 }
 
 #if defined(CONFIG_RTL_REPORT_LINK_STATUS)
-unsigned int rtl865x_setLinkStatusFlag(unsigned int newportmask)
+unsigned int rtl865x_setLinkStatusFlag(unsigned int curLinkPortMask, unsigned int newportmask)
 {
 	int i;
 	struct dev_priv * cp=NULL;
@@ -2898,7 +3416,7 @@ unsigned int rtl865x_setLinkStatusFlag(unsigned int newportmask)
 		for(i = 0; i < ETH_INTF_NUM; i++)
 		{
 			cp = ((struct dev_priv *)_rtl86xx_dev.dev[i]->priv);
-			if(cp &&  cp->opened && rtl_isWanDev(cp) && (cp->portmask & newportmask))
+			if(cp &&  cp->opened && rtl_isWanDev(cp) && ((cp->portmask & curLinkPortMask)==0) && (cp->portmask & newportmask))
 			{
 				wan_linkStatus[0] = 1;
 				return SUCCESS;
@@ -2909,11 +3427,22 @@ unsigned int rtl865x_setLinkStatusFlag(unsigned int newportmask)
 }
 #endif
 
+
+#ifdef CONFIG_RTL_819X_SWCORE
+int cnt_swcore = 0;
+int cnt_swcore_tx = 0;
+int cnt_swcore_rx = 0;
+int cnt_swcore_link = 0;
+int cnt_swcore_err = 0;
+#endif
+
+
 #ifdef CONFIG_RTL_8198_ESD
 static uint32 phy_reg30[RTL8651_PHY_NUMBER] = { 0, 0, 0, 0, 0};
 static int one_second_counter = 0;
 static int first_time_read_reg6 = 1;
 static int need_to_check_esd2 = 1;
+static int esd3_skip_one = 1;
 
 inline static int diff_more_than_1(uint32 a, uint32 b)
 {
@@ -2951,6 +3480,70 @@ static int esd_recovery(void)
 }
 #endif
 
+#if defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+/*
+krammer add this according to " Jim Hsieh/5458 "'s algorithm
+Description:
+when phy0's link partner link in force mode, we will force to half duplex mode,
+in this condition, if there is some traffic in port0's rx, sometimes port0 will die.
+so we add this patch, only work when phy0's link state change, if link partner
+is link in force mode, we will change our port0 into full duplex.
+*/
+void rtl819x_port0_force_refined(void){
+	unsigned int regData;
+
+	if((curLinkPortMask & 0x01) == (newLinkPortMask & 0x01)){
+		//no change -> return
+		return;
+	}
+
+	//default disable phy i/f(0xbb804104 b0=0)
+	REG32(PCRP0) &= ~(EnablePHYIf);
+
+	//if port#0=link up
+	if(newLinkPortMask & 0x01){
+		//if AN =0(reg6[0])
+		rtl8651_getAsicEthernetPHYReg(rtl8651_tblAsicDrvPara.externalPHYId[0], 6, &regData);
+		if((regData & 0x01) == 0){
+			rtl8651_getAsicEthernetPHYReg(rtl8651_tblAsicDrvPara.externalPHYId[0], 5, &regData);
+			if(regData & 0x080){//if spd = 100M(reg5[7])
+				//force MAC 100M Full duplex
+				//(set 0xbb804104 b25=1 b24=1 b23=0 b20-19=1 b18=1 b17-16=0x3)
+				regData = REG32(PCRP0);
+				regData |= (EnForceMode | PollLinkStatus | ForceDuplex | PauseFlowControlEtxErx);
+				regData &= ~(ForceLink | ForceSpeedMask);
+				regData |= (ForceSpeed100M);
+				//panic_printk("phy0 link partner is force 100M, we force to 100M Full duplex!regData = 0x%x\n", regData);
+				REG32(PCRP0) = regData;
+			}
+			else if(regData & 0x20){//else spd = 10M(reg5[5])
+				//force MAC 10M Full duplex
+				//(set 0xbb804104 b25=1 b24=1 b23=0 b20-19=0 b18=1 b17-16=0x3)
+				regData = REG32(PCRP0);
+				regData |= (EnForceMode | PollLinkStatus | ForceDuplex | PauseFlowControlEtxErx);
+				regData &= ~(ForceLink | ForceSpeedMask);
+				regData |= (ForceSpeed10M);
+				//panic_printk("phy0 link partner is force 10M, we force to 10M Full duplex!regData = 0x%x\n", regData);
+				REG32(PCRP0) = regData;
+			}
+		}
+		//enable phy i/f
+		//set 0xbb804104 b0=1
+		REG32(PCRP0) |= EnablePHYIf;
+		//panic_printk("phy0 link up, PCRP0 = 0x%x\n", REG32(PCRP0));
+	}
+	else{//if port#0=link down
+		//recovery MAC AN setting and disable phy i/f
+		//(set 0xbb804104 b25=0 b20-18 0x7 b0=0)
+		regData = REG32(PCRP0);
+		regData &= ~(EnForceMode | EnablePHYIf);
+		regData |= (ForceSpeed1000M | ForceDuplex);
+		//panic_printk("phy0 link down, we reset phy0!regData = 0x%x\n", regData);
+		REG32(PCRP0) = regData;
+	}
+}
+#endif
+
 static void interrupt_dsr_link(unsigned long task_priv)
 {
 #ifdef CONFIG_RTL_8198_ESD
@@ -2964,8 +3557,13 @@ static void interrupt_dsr_link(unsigned long task_priv)
 
 	newLinkPortMask=rtl865x_getPhysicalPortLinkStatus();
 
+#ifdef CONFIG_RTL_8197D_DYN_THR
+	rtl819x_setQosThreshold(curLinkPortMask, newLinkPortMask);
+#endif
+
 #if defined(CONFIG_RTL_REPORT_LINK_STATUS)
-		rtl865x_setLinkStatusFlag(newLinkPortMask);
+//		rtl865x_setLinkStatusFlag(newLinkPortMask);
+		rtl865x_setLinkStatusFlag(curLinkPortMask, newLinkPortMask);
 #endif
 #if defined(CONFIG_RTL_IGMP_SNOOPING)
 		rtl865x_igmpSyncLinkStatus();
@@ -2978,6 +3576,14 @@ static void interrupt_dsr_link(unsigned long task_priv)
 #if defined(CONFIG_RTL_8196C) && defined(CONFIG_RTL_PHY_PATCH)
 		re865x_checkPhySnr();
 #endif
+
+#if defined(CONFIG_RTL_819XD)
+	if (rtl_port0Refined == 1)
+	{
+		rtl819x_port0_force_refined();
+	}
+#endif
+
 	curLinkPortMask=newLinkPortMask;
 
 #ifdef LINK_TASKLET
@@ -3044,6 +3650,10 @@ __IRAM_GEN static inline void rtl_link_change_interrupt_process(unsigned int sta
 	  	#else
 			interrupt_dsr_link((unsigned long)cp);
   		#endif
+  		#ifdef CONFIG_RTK_VOIP_PORT_LINK
+		if(cp->opened)
+			rtmsg_ifinfo_voip(RTM_LINKCHANGE, cp->dev, ~0U);
+		#endif
 	}
 }
 #endif
@@ -3060,6 +3670,18 @@ irqreturn_t interrupt_isr(int irq, void *dev_instance)
 	REG32(CPUIISR) = status;
 	status &= REG32(CPUIIMR);
 
+#ifdef CONFIG_RTL_819X_SWCORE
+    cnt_swcore++;
+	if (status & (RX_DONE_IP_ALL))
+ 		cnt_swcore_rx++;
+	if (status & TX_ALL_DONE_IP_ALL)
+		cnt_swcore_tx++;
+	if (status&LINK_CHANGE_IP)
+		cnt_swcore_link++;
+    if (status&(RX_DONE_IP_ALL|TX_ALL_DONE_IP_ALL|LINK_CHANGE_IP))
+        cnt_swcore_err++;
+#endif
+
 	rtl_rx_interrupt_process(status, cp);
 
 	rtl_tx_interrupt_process(status, cp);
@@ -3123,7 +3745,7 @@ int total_time_for_5_port = 15*HZ;
 int port_pwr_save_low = 0;
 #endif
 
-#if defined(DYNAMIC_ADJUST_TASKLET) || defined(CONFIG_RTL8186_TR) || defined(CONFIG_RTL8196C_REVISION_B) || defined(CONFIG_RTL_8198) || defined(RTL8196C_EEE_MAC) || defined(RTL_CPU_QOS_ENABLED)
+#if defined(DYNAMIC_ADJUST_TASKLET) || defined(CONFIG_RTL8186_TR) || defined(CONFIG_RTL8196C_REVISION_B) || defined(CONFIG_RTL_8198) || defined(RTL8196C_EEE_MAC) || defined(RTL_CPU_QOS_ENABLED) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 static void one_sec_timer(unsigned long task_priv)
 {
 	unsigned long		flags;
@@ -3181,6 +3803,17 @@ static void one_sec_timer(unsigned long task_priv)
     cp->rx_byte_cnt = 0;
 #endif
 
+#ifdef CONFIG_RTL_8197D_DYN_THR
+	if (_8197d_link_check == 0) {
+		newLinkPortMask=rtl865x_getPhysicalPortLinkStatus();
+
+		rtl819x_setQosThreshold(curLinkPortMask, newLinkPortMask);
+
+		curLinkPortMask=newLinkPortMask;
+		_8197d_link_check = 1;
+	}
+#endif
+
 #ifdef CONFIG_RTL8196C_REVISION_B
 	if ((REG32(REVR) == RTL8196C_REVISION_A) && (eee_enabled)) {
 			int i, curr_sts;
@@ -3266,7 +3899,8 @@ static void one_sec_timer(unsigned long task_priv)
 				if ((val & 0xffff) != 0xAE04)
 				{
 					panic_printk("  ESD-1\n");
-					do {} while(1); // reboot
+					//do {} while(1); // reboot
+					machine_restart(NULL);
 				}
 
 				if (need_to_check_esd2) {
@@ -3279,7 +3913,8 @@ static void one_sec_timer(unsigned long task_priv)
 					if ((val & 0xff) != 0xFC)
 					{
 						panic_printk("  ESD-2\n");
-						do {} while(1); // reboot
+						//do {} while(1); // reboot
+						machine_restart(NULL);
 					}
 				}
 
@@ -3287,20 +3922,27 @@ static void one_sec_timer(unsigned long task_priv)
 				rtl8651_setAsicEthernetPHYReg( phy, 22, ((val & (0xff00)) | 0x17) );
 				rtl8651_getAsicEthernetPHYReg( phy, 30, &val );
 
+				if (esd3_skip_one == 1) {
+					phy_reg30[phy] = BIT(31) | (val & 0xfff);
+				}
+				else
 				if ((phy_reg30[phy] & 0xfff) != (val & 0xfff)) {
 					if (diff_more_than_1((phy_reg30[phy] & 0xf), (val & 0xf)) ||
 						diff_more_than_1(((phy_reg30[phy] >> 4) & 0xf), ((val >> 4) & 0xf)) ||
 						diff_more_than_1(((phy_reg30[phy] >> 8) & 0xf), ((val >> 8) & 0xf))
 						) {
 						panic_printk("  ESD-3: old= 0x%x, new= 0x%x\n", phy_reg30[phy] & 0xfff, val & 0xfff);
-						do {} while(1); // reboot
+						//do {} while(1); // reboot
+						machine_restart(NULL);
 					}
 					phy_reg30[phy] = BIT(31) | (val & 0xfff);
 				}
 			}
 
 		}
-
+		if (esd3_skip_one == 1) {
+			esd3_skip_one = 0;
+		}
 		one_second_counter = 0;
 	}
 	}
@@ -3312,7 +3954,7 @@ static void one_sec_timer(unsigned long task_priv)
 #endif
 	if (_96c_esd_counter) {
 
-		extern int is_fault;
+		//extern int is_fault;
 #if 0
 		if (++_96c_esd_counter >= 20) {
 
@@ -3328,7 +3970,8 @@ static void one_sec_timer(unsigned long task_priv)
 		{
 			if (++_96c_esd_reboot_counter >= 20) {
 				panic_printk("  ESD reboot...\n");
-				is_fault = 1;
+				//is_fault = 1;
+				machine_restart(NULL);
 			}
 		}
 		else {
@@ -3345,13 +3988,20 @@ static void one_sec_timer(unsigned long task_priv)
 	{
 		struct dev_priv *tmp_cp;
 
-		int portnum;
+		int portnum, startport=0;
 		tmp_cp = ((struct dev_priv *)_rtl86xx_dev.dev[i]->priv);
 		if(tmp_cp && tmp_cp->portmask && tmp_cp->opened) {
-			for(portnum=0;portnum<5;portnum++)
+
+#if defined(CONFIG_RTL_819XD)
+			if (rtl_port0Refined == 1)
 			{
-				if(tmp_cp->portmask & (1<<portnum))
-					break;
+				startport = 1;
+			}
+#endif
+			for(portnum=startport;portnum<5;portnum++)
+			{
+				if(tmp_cp->portmask & (1<<portnum))
+					break;
 			}
 			if(5 == portnum)
 				continue;
@@ -3500,7 +4150,7 @@ static int re865x_open (struct net_device *dev)
 
 	netif_start_queue(dev);
 
-#if defined(DYNAMIC_ADJUST_TASKLET) || defined(CONFIG_RTL8186_TR) || defined(CONFIG_RTL8196C_REVISION_B)|| defined(CONFIG_RTL_8198) || defined(RTL8196C_EEE_MAC)
+#if defined(DYNAMIC_ADJUST_TASKLET) || defined(CONFIG_RTL8186_TR) || defined(CONFIG_RTL8196C_REVISION_B)|| defined(CONFIG_RTL_8198) || defined(RTL8196C_EEE_MAC) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 	#if !defined(CONFIG_RTL8186_TR)
 	if (dev->name[3] == '0')
 	#endif
@@ -3623,10 +4273,14 @@ static int re865x_close (struct net_device *dev)
 	#endif
 	{
 		rtl865x_disableDevPortForward(dev, cp);
+#if !defined(CONFIG_RTL_8196C)
+		/*for lan dhcp client to renew ip address*/
+		rtl865x_restartDevPHYNway(dev, cp);
+#endif
 		rtl8186_stop_hw(dev, cp);
 	}
 
-#if defined(DYNAMIC_ADJUST_TASKLET) || defined(CONFIG_RTL8186_TR) || defined(BR_SHORTCUT) || defined(CONFIG_RTL8196C_REVISION_B) || defined(CONFIG_RTL_8198)
+#if defined(DYNAMIC_ADJUST_TASKLET) || defined(CONFIG_RTL8186_TR) || defined(BR_SHORTCUT) || defined(CONFIG_RTL8196C_REVISION_B) || defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
     if (timer_pending(&cp->expire_timer))
         del_timer_sync(&cp->expire_timer);
 #endif
@@ -3651,6 +4305,11 @@ static int re865x_close (struct net_device *dev)
 		cached_dev=NULL;
 #endif
 
+#ifdef BR_SHORTCUT_C2
+	if (dev == cached_dev2)
+		cached_dev2=NULL;
+#endif
+
 #ifdef CONFIG_RTL_HARDWARE_NAT
 	reset_hw_mib_counter(dev);
 #endif
@@ -3692,6 +4351,10 @@ static int re865x_pseudo_close (struct net_device *dev)
 	if (dev == cached_dev)
 		cached_dev=NULL;
 #endif
+#ifdef BR_SHORTCUT_C2
+	if (dev == cached_dev2)
+		cached_dev2=NULL;
+#endif
 	return SUCCESS;
 }
 #endif
@@ -3841,6 +4504,11 @@ int re865x_setMCastTxInfo(struct sk_buff *skb,struct net_device *dev, rtl_nicTx_
 	struct rtl_multicastDataInfo multicastDataInfo;
 	struct rtl_multicastFwdInfo multicastFwdInfo;
 
+#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+	struct sk_buff *skb_wan=NULL;
+	rtl_nicTx_info	nicTx_wan;
+#endif
+
 	if((skb==NULL) || (dev==NULL) ||(nicTx==NULL))
 	{
 		return -1;
@@ -3883,6 +4551,32 @@ int re865x_setMCastTxInfo(struct sk_buff *skb,struct net_device *dev, rtl_nicTx_
 
 
 			}
+            #ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+			//fix tim; upnp
+                if( vlan_enable && vlan_bridge_enable && vlan_bridge_multicast_enable)
+				{
+					if((cp->id == vlan_bridge_tag) && (nicTx->portlist & RTL_WANPORT_MASK))
+					{
+						nicTx->portlist &= (~RTL_WANPORT_MASK);
+						skb_wan = skb_copy(skb, GFP_ATOMIC);
+						 if(skb_wan!=NULL)
+					     {
+					       	nicTx_wan.txIdx=0;
+                            nicTx_wan.vid = vlan_bridge_multicast_tag;
+							nicTx_wan.portlist = RTL_WANPORT_MASK;
+							nicTx_wan.srcExtPort = 0;
+							nicTx_wan.flags = (PKTHDR_USED|PKT_OUTGOING);
+							_dma_cache_wback_inv((unsigned long) skb_wan->data, skb_wan->len);
+							if (swNic_send((void *)skb_wan, skb_wan->data, skb_wan->len, &nicTx_wan) < 0)
+							{
+								dev_kfree_skb_any(skb_wan);
+							}
+						}
+			}
+
+					}//hw-vlan
+			#endif
+
 		}
 	}
 #if defined (CONFIG_RTL_MLD_SNOOPING)
@@ -3980,6 +4674,85 @@ static inline int rtl_process_stp_tx(rtl_nicTx_info *txInfo)
 }
 #endif
 
+#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+static inline void rtl_process_vlan_tag_cpu(rtl_nicTx_info *txInfo)
+{
+//	extern int rtp_tos;
+//	extern int sip_tos;
+
+	struct sk_buff *skb = NULL;
+	struct sk_buff *newskb;
+	struct net_device *dev;
+	struct dev_priv *cp;
+	int vlan_tag;
+	int vlan_pri;
+	int i;
+
+	skb = txInfo->out_skb;
+	dev = skb->dev;
+	cp = dev->priv;
+	if(vlan_enable && cp->id == vlanconfig[1].vid)//WAN
+	{
+		vlan_tag = 0;
+		vlan_pri = 0;
+
+		if(vlan_host_enable && (skb->srcPhyPort == RX_FROM_LOCAL))
+		{
+			vlan_tag = 	vlan_host_tag;
+			vlan_pri = 	vlan_host_pri;
+		}
+		for(i = 0 ; i< 5; i++)
+		{
+			if(vlan_wifi_enable[i] && (skb->srcPhyPort == RX_FROM_WIRELESS+i))
+			{
+				vlan_tag = 	vlan_wifi_tag[i];
+				vlan_pri =  vlan_wifi_pri[i];
+				break;
+			}
+		}
+		//for arp request form WAN port,add the same vid , priority to be zero
+		if(*((uint16 *)(&(skb->data[12]))) == __constant_htons(ETH_P_ARP))//ARP
+        {
+        	if((1<<skb->srcPhyPort) == RTL_WANPORT_MASK)
+        	{
+        		vlan_tag = (skb->tag.f.pci)&0xfff;
+        		vlan_pri =  0;
+        	}
+        }
+		if(vlan_tag){
+
+			newskb = NULL;
+			if (skb_cloned(skb))
+			{
+				newskb = skb_copy(skb, GFP_ATOMIC);
+				if (newskb == NULL)
+				{
+					cp->net_stats.tx_dropped++;
+					dev_kfree_skb_any(skb);
+				}
+				dev_kfree_skb_any(skb);
+				skb = newskb;
+				txInfo->out_skb = skb;
+			}
+			if (*((unsigned short *)(skb->data+ETH_ALEN*2)) != __constant_htons(ETH_P_8021Q))
+			{
+				if (skb_headroom(skb) < VLAN_HLEN && skb_cow(skb, VLAN_HLEN) !=0 )
+				{
+				    printk("%s-%d: error! (skb_headroom(skb) == %d < %d). Enlarge it!\n",
+				    __FUNCTION__, __LINE__, skb_headroom(skb), VLAN_HLEN);
+				    while (1) ;
+				}
+				skb_push(skb, VLAN_HLEN);
+				memmove(skb->data, skb->data + VLAN_HLEN, VLAN_ETH_ALEN<<1);
+				*(uint16*)(&(skb->data[12])) = __constant_htons(ETH_P_8021Q);
+				*(uint16*)(&(skb->data[14])) = htons(vlan_tag)&0x0fff;// VID
+                *(uint8*)(&(skb->data[14])) |= (((uint8)vlan_pri)&0x7) << 5;
+            }
+		}
+	}
+}
+#endif
+
 //__MIPS16
 #if defined(CONFIG_RTL_CUSTOM_PASSTHRU)
 static inline int rtl_process_passthru_tx(rtl_nicTx_info *txInfo)
@@ -4076,12 +4849,19 @@ static inline int rtl_preProcess_xmit(rtl_nicTx_info *txInfo)
 	if(FAILED == retval)
 		return retval;
 	#endif
+	#if defined(CONFIG_RTL_HW_VLAN_SUPPORT)
+	retval = rtl_process_hw_vlan_tx(txInfo);
+	if(FAILED == retval)
+		return retval;
+	#endif
 	#if defined(CONFIG_RTK_VLAN_SUPPORT)
 	retval = rtl_process_rtk_vlan_tx(txInfo);
 	if(FAILED == retval)
 		return retval;
 	#endif
-
+        #ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+		rtl_process_vlan_tag_cpu(txInfo);
+	#endif
 	#if defined(CONFIG_RTL_REINIT_SWITCH_CORE)
 	if(rtl865x_duringReInitSwtichCore==1) {
 		dev_kfree_skb_any(txInfo->out_skb);
@@ -4106,6 +4886,14 @@ static inline void rtl_hwLookup_txInfo(rtl_nicTx_info *txInfo)
 	txInfo->flags = (PKTHDR_USED|PKTHDR_HWLOOKUP|PKTHDR_BRIDGING|PKT_OUTGOING);
 }
 
+#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+static inline void rtl_hwLookup_txInfo2(rtl_nicTx_info *txInfo)
+{
+	txInfo->portlist = RTL8651_CPU_PORT;		/* must be set 0x7 */
+	txInfo->srcExtPort = PKTHDR_EXTPORT_LIST_P2;//2->7
+	txInfo->flags = (PKTHDR_USED|PKTHDR_HWLOOKUP|PKTHDR_BRIDGING|PKT_OUTGOING);
+}
+#endif
 static inline int rtl_ip_option_check(struct sk_buff *skb)
 {
 	int flag = FALSE;
@@ -4135,6 +4923,12 @@ static inline int rtl_isHwlookup(struct sk_buff *skb, struct dev_priv *cp, uint3
 		flag = FALSE;
 	}
 
+#if defined(CONFIG_RTL_HW_VLAN_SUPPORT)
+	if((rtk_vlan_support_enable == 0) && ((!memcmp(cp->dev->name, "eth2", 5)) ||
+	  (!memcmp(cp->dev->name, "eth3", 5)) ||(!memcmp(cp->dev->name, "eth4", 5))))
+		flag = FALSE;
+#endif
+
 #if defined (CONFIG_RTL_LOCAL_PUBLIC)
 	//hyking:
 	//when hw local public and sw localpublic exist at same time,
@@ -4148,7 +4942,7 @@ static inline int rtl_isHwlookup(struct sk_buff *skb, struct dev_priv *cp, uint3
 	} else
 #endif
 	if (flag==FALSE) {
-#if defined(CONFIG_RTL_MULTI_LAN_DEV) || defined(CONFIG_POCKET_ROUTER_SUPPORT) || defined(CONFIG_RTK_VLAN_SUPPORT)
+#if defined(CONFIG_RTL_MULTI_LAN_DEV) ||defined (CONFIG_POCKET_ROUTER_SUPPORT)||defined(CONFIG_RTK_VLAN_SUPPORT)
 assign_portmask:
 #endif
 		*portlist = cp->portmask;
@@ -4164,6 +4958,9 @@ static inline int rtl_fill_txInfo(rtl_nicTx_info *txInfo)
 	cp = skb->dev->priv;
 	txInfo->vid = cp->id;
 
+	#if defined(CONFIG_RTK_VOIP_QOS)
+	txInfo->priority  = 0 ;
+	#endif
 	#if	defined(CONFIG_RTL_HW_QOS_SUPPORT)
 	txInfo->priority= rtl_qosGetPriorityByVid(cp->id, skb->mark);
 	#endif
@@ -4173,8 +4970,16 @@ static inline int rtl_fill_txInfo(rtl_nicTx_info *txInfo)
 
 	if((skb->data[0]&0x01)==0)
 	{
+
 		if(rtl_isHwlookup(skb, cp, &portlist) == TRUE)
 		{
+        #ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+			if ( vlan_enable && vlan_bridge_enable && cp->id == vlan_bridge_tag)
+			{
+				rtl_hwLookup_txInfo2(txInfo);
+			}
+			else
+		#endif
 			rtl_hwLookup_txInfo(txInfo);
 		}
 		else
@@ -4205,6 +5010,26 @@ static inline int rtl_fill_txInfo(rtl_nicTx_info *txInfo)
 	return SUCCESS;
 }
 
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+static int rtl_bridge_wan_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct net_device *wan_dev = NULL;
+	if(!memcmp(lan_macaddr,skb->data+6, 6)) {
+		dev_kfree_skb_any(skb);
+		return 0;
+	}
+	//printk("[%s][%d]-skb->dev[%s],proto(0x%x)\n", __FUNCTION__, __LINE__, skb->dev->name,skb->protocol);
+	wan_dev = rtl_get_wan_from_vlan_info();
+
+	if(wan_dev){
+		skb->dev = wan_dev;
+		wan_dev->netdev_ops->ndo_start_xmit(skb, wan_dev);
+		}
+	return 0;
+}
+#endif
+
+
 #define	RTL_NIC_TX_RETRY_MAX		(128)
 __MIPS16
 __IRAM_FWD
@@ -4215,29 +5040,27 @@ static int re865x_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	struct sk_buff *tx_skb;
 	rtl_nicTx_info	nicTx;
 
+
 	nicTx.out_skb = skb;
 	retval = rtl_preProcess_xmit(&nicTx);
 
 	if(FAILED == retval)
-	{
 		return 0;
-	}
+
 	tx_skb = nicTx.out_skb;
 	cp = tx_skb->dev->priv;
 
 	if((cp->id==0) || (cp->portmask ==0)) {
-		dev_kfree_skb_any(tx_skb);		
+		dev_kfree_skb_any(tx_skb);
 		return 0;
 	}
 
-#if defined (CONFIG_RTL_IGMP_SNOOPING)
+
 	retval = rtl_fill_txInfo(&nicTx);
 	if(FAILED == retval)
-	{
 		return 0;
-	}
 
-#if defined(CONFIG_RTL_QOS_PATCH)
+#if defined(CONFIG_RTL_QOS_PATCH) || defined(CONFIG_RTK_VOIP_QOS)
 	if(((struct sk_buff *)tx_skb)->srcPhyPort == QOS_PATCH_RX_FROM_LOCAL){
 		nicTx.priority = QOS_PATCH_HIGH_QUEUE_PRIO;
 		nicTx.txIdx=RTL865X_SWNIC_TXRING_MAX_PKTDESC-1;	//use the highest tx ring index, note: not RTL865X_SWNIC_TXRING_HW_PKTDESC-1
@@ -4247,7 +5070,10 @@ static int re865x_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	_dma_cache_wback_inv((unsigned long) tx_skb->data, tx_skb->len);
 	tx_retry_cnt = 0;
 	while(swNic_send((void *)tx_skb, tx_skb->data, tx_skb->len, &nicTx) < 0)
-	{		
+	{
+		#if defined(CONFIG_RTL_PROC_DEBUG)
+		tx_ringFull_cnt++;
+		#endif
 		swNic_txDone(nicTx.txIdx);
 		if ((tx_retry_cnt++)>RTL_NIC_TX_RETRY_MAX) {
 			dev_kfree_skb_any(tx_skb);
@@ -4255,9 +5081,7 @@ static int re865x_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		}
 	}
 
-#else //CONFIG_RTL_IGMP_SNOOPING
-	#error "By default should define CONFIG_RTL_IGMP_SNOOPING"
-#endif
+
 
 	rtl_pstProcess_xmit(cp,tx_skb->len);
 	//cp->net_stats.tx_packets++;
@@ -4358,10 +5182,12 @@ int re865x_priv_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 	{
 	     case RTL819X_IOCTL_READ_PORT_STATUS:
 		 	rc = rtl819x_get_port_status(portnum,&port_status); //portnumber
-		 	if(rc != 0)
+		 	if(rc != 0) {
 				return -EFAULT;
-		 	if (copy_to_user((void *)rq->ifr_data, (void *)&port_status, sizeof(struct lan_port_status)))
+			}
+		 	if (copy_to_user((void *)rq->ifr_data, (void *)&port_status, sizeof(struct lan_port_status))) {
 				return -EFAULT;
+			}
 		 	break;
 	     case RTL819X_IOCTL_READ_PORT_STATS:
 		 	rc = rtl819x_get_port_stats(portnum,&port_stats); //portnumber
@@ -4451,7 +5277,6 @@ int re865x_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)
 					if(vlanconfig[i].isWan==TRUE)
 						wanPortMask = vlanconfig[i].memPort;
 				}
-
 				if (wanPortMask==0)
 				{
 					/* no wan port exist */
@@ -5043,6 +5868,26 @@ static const struct net_device_ops rtl819x_netdev_ops = {
 	.ndo_change_mtu		= rtl865x_set_mtu,
 
 };
+
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+static const struct net_device_ops rtl819x_netdev_ops_bridge = {
+	.ndo_open		= re865x_open,
+	.ndo_stop		= re865x_close,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_set_mac_address 	= rtl865x_set_hwaddr,
+	.ndo_set_multicast_list	= re865x_set_rx_mode,
+	.ndo_get_stats		= re865x_get_stats,
+	.ndo_do_ioctl		= re865x_ioctl,
+	.ndo_start_xmit		= rtl_bridge_wan_start_xmit,
+	.ndo_tx_timeout		= re865x_tx_timeout,
+#if defined(CP_VLAN_TAG_USED)
+	.ndo_vlan_rx_register	= cp_vlan_rx_register,
+#endif
+	.ndo_change_mtu		= rtl865x_set_mtu,
+
+};
+#endif
+
 #endif
 
 
@@ -5231,6 +6076,9 @@ int  __init re865x_probe (void)
 #if defined(CONFIG_RTL_REPORT_LINK_STATUS)  ||  defined(CONFIG_RTK_VLAN_SUPPORT)
 	struct proc_dir_entry *res_stats_root;
 #endif
+#if defined(CONFIG_RTL_819XD)&&defined(CONFIG_RTL_8211DS_SUPPORT)&&defined(CONFIG_RTL_8197D)
+	uint32 reg_tmp=0;
+#endif
 
 #if defined(CONFIG_RTL_REPORT_LINK_STATUS)
 	struct proc_dir_entry *rtk_link_status_entry;
@@ -5239,6 +6087,9 @@ int  __init re865x_probe (void)
 #if defined(CONFIG_RTK_VLAN_SUPPORT)
 	struct proc_dir_entry *res_stats;
 	struct proc_dir_entry *rtk_vlan_support_entry;
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+	struct proc_dir_entry *rtk_vlan_management_entry;
+#endif
 #if defined(CONFIG_819X_PHY_RW)//#if defined(CONFIG_RTK_VLAN_FOR_CABLE_MODEM)
 	uint32 portnum;
 	char port_mibEntry_name[10];
@@ -5248,6 +6099,12 @@ int  __init re865x_probe (void)
 #endif	//#if defined(CONFIG_819X_PHY_RW)
 #endif
 
+#if defined(CONFIG_RTL_HW_VLAN_SUPPORT)
+	struct proc_dir_entry *rtl_hw_vlan_support_entry;
+	struct proc_dir_entry *rtl_hw_vlan_tagged_bridge_multicast_entry;
+	memset(hw_vlan_info, 0, PORT_NUMBER*sizeof(struct hw_vlan_port_setting));
+#endif
+
 #if defined (CONFIG_RTL_LOCAL_PUBLIC)
 	struct rtl865x_interface_info ifInfo;
 #endif
@@ -5255,6 +6112,12 @@ int  __init re865x_probe (void)
 #if defined(PATCH_GPIO_FOR_LED)
 	int port;
 #endif
+
+#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+	struct proc_dir_entry *rtk_vlan_wan_tag_support_entry;
+	struct proc_dir_entry *rtk_vlan_wan_tag_cpu_support_entry;
+#endif
+
 	//WRITE_MEM32(PIN_MUX_SEL_2, 0x7<<21);
 
 	rtlglue_printf("\n\n\nProbing RTL8186 10/100 NIC-kenel stack size order[%d]...\n", THREAD_SIZE_ORDER);
@@ -5262,19 +6125,15 @@ int  __init re865x_probe (void)
     	REG32(CPUICR) &= ~(TXCMD | RXCMD);
 	rxMbufRing=NULL;
 
-	/*Initial ASIC table*/
-#ifdef CONFIG_RTL8198_REVISION_B
- 	if (REG32(BSP_REVR) >= BSP_RTL8198_REVISION_B)
+#if defined(CONFIG_RTL_819XD)
+	if ((REG32(REVR) == 0x8197C000) || (REG32(REVR) == 0x8197C001))
 	{
-	  	REG32(SYS_CLK_MAG)&=(~(SYS_SW_RESET));
-		mdelay(300);
-		REG32(SYS_CLK_MAG)|=(SYS_SW_RESET);
-		mdelay(50);
+		rtl_port0Refined = 1;
 	}
-	else
 #endif
-		FullAndSemiReset();
 
+	/*Initial ASIC table*/
+	FullAndSemiReset();
 	{
 		rtl8651_tblAsic_InitPara_t para;
 
@@ -5370,7 +6229,11 @@ int  __init re865x_probe (void)
 #ifdef BR_SHORTCUT
 	cached_dev=NULL;
 #endif
+#ifdef BR_SHORTCUT_C2
+	cached_dev2=NULL;
+#endif
 	/*init PHY LED style*/
+#if !defined(CONFIG_RTL_819XD) && !defined(CONFIG_RTL_8196E)
 #if defined(CONFIG_RTL865X_BICOLOR_LED)
 	#ifdef BICOLOR_LED_VENDOR_BXXX
 	REG32(LEDCR) |= (1 << 19); // 5 ledmode set to 1 for bi-color LED
@@ -5387,11 +6250,18 @@ int  __init re865x_probe (void)
 #else /* CONFIG_RTL865X_BICOLOR_LED */
 
 	/* config LED mode */
+#if defined(CONFIG_RTK_VOIP_BOARD)
+		WRITE_MEM32(LEDCR, 0x00055500 ); // 15 LED
+		//avoiv bad voip quality
+		WRITE_MEM32(0xb8000048, REG32(0xb8000048)&0xfffffff3);
+#else
 	WRITE_MEM32(LEDCR, 0x00000000 ); // 15 LED
+#endif
 	WRITE_MEM32(SWTAA, PORT5_PHY_CONTROL);
 	WRITE_MEM32(TCR0, 0x000002C7); //8651 demo board default: 15 LED boards
 	WRITE_MEM32(SWTACR, CMD_FORCE | ACTION_START); // force add
 #endif /* CONFIG_RTL865X_BICOLOR_LED */
+#endif
 
 /*2007-12-19*/
 #if defined(CONFIG_RTK_VLAN_SUPPORT)
@@ -5401,6 +6271,10 @@ int  __init re865x_probe (void)
 
 #endif
 
+#if defined(CONFIG_RTL_819XD)&&defined(CONFIG_RTL_8211DS_SUPPORT)&&defined(CONFIG_RTL_8197D)
+	rtl8651_getAsicEthernetPHYReg(0x6, 0, &reg_tmp);
+	rtl_setPortMask(reg_tmp);
+#endif
 
 	INIT_CHECK(rtl865x_init());
 
@@ -5481,7 +6355,14 @@ int  __init re865x_probe (void)
 #endif
 
 #else
-		dev->netdev_ops = &rtl819x_netdev_ops;
+		#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+			if(memcmp((vlanconfig[i].ifname), RTL_DRV_LAN_P7_NETIF_NAME, 4) == 0){
+				memcpy((char*)dev->name, (char*)(&(vlanconfig[i].ifname)), 5);
+				dev->netdev_ops = &rtl819x_netdev_ops_bridge;
+			}
+			else
+		#endif
+			dev->netdev_ops = &rtl819x_netdev_ops;
 #endif
 		dev->watchdog_timeo = TX_TIMEOUT;
 #if 0
@@ -5493,6 +6374,7 @@ int  __init re865x_probe (void)
 
 		dev->irq = BSP_SWCORE_IRQ;
 		rc = register_netdev(dev);
+
 		if(!rc){
 			_rtl86xx_dev.dev[i]=dev;
 			rtl_add_ps_drv_netif_mapping(dev,vlanconfig[i].ifname);
@@ -5535,6 +6417,7 @@ int  __init re865x_probe (void)
 
 #if defined(CONFIG_RTL_MULTIPLE_WAN)
 	retVal = rtl_config_multipleWan_netif(RTL_MULTIWAN_ADD);
+	rtl865x_addMultiCastNetif();
 	rtl_regist_multipleWan_dev();
 #endif
 
@@ -5557,7 +6440,7 @@ int  __init re865x_probe (void)
 		rtl_setIgmpSnoopingModuleDevInfo(nicIgmpModuleIndex, &devInfo);
 	}
 	#endif
-	rtl_setIpv4UnknownMCastFloodMap(nicIgmpModuleIndex, 0x0);
+	rtl_setIpv4UnknownMCastFloodMap(nicIgmpModuleIndex, 0xFFFFFFFF);
 	rtl_setIpv6UnknownMCastFloodMap(nicIgmpModuleIndex, 0xFFFFFFFF);
 
 	curLinkPortMask=rtl865x_getPhysicalPortLinkStatus();
@@ -5645,7 +6528,9 @@ int  __init re865x_probe (void)
 #endif
 	rtl8651_initStormCtrl();
 
-#if (defined(CONFIG_RTL_8198))
+	rtl819x_eee_proc_init();
+
+#if defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 	// initial proc for phyRegTest
 	phyRegTest_init();
 #endif
@@ -5667,8 +6552,49 @@ int  __init re865x_probe (void)
 	    rtk_vlan_support_entry->read_proc=rtk_vlan_support_read;
 	    rtk_vlan_support_entry->write_proc=rtk_vlan_support_write;
 	}
+
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+	memset(&management_vlan, 0, sizeof(struct vlan_info*));
+	rtk_vlan_management_entry = create_proc_entry("rtk_vlan_management_entry", 0, NULL);
+	if(rtk_vlan_management_entry)
+	{
+		rtk_vlan_management_entry->read_proc=rtk_vlan_management_read;
+		rtk_vlan_management_entry->write_proc=rtk_vlan_management_write;
+	}
+#endif
+#endif
+
+#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+	rtk_vlan_wan_tag_support_entry = create_proc_entry("rtk_vlan_wan_tag",0,NULL);
+	if (rtk_vlan_wan_tag_support_entry)
+	{
+	    rtk_vlan_wan_tag_support_entry->read_proc=rtk_vlan_wan_tag_support_read;
+	    rtk_vlan_wan_tag_support_entry->write_proc=rtk_vlan_wan_tag_support_write;
+	}
+	rtk_vlan_wan_tag_cpu_support_entry = create_proc_entry("rtk_vlan_wan_tag_cpu",0,NULL);
+	if (rtk_vlan_wan_tag_cpu_support_entry)
+	{
+	    rtk_vlan_wan_tag_cpu_support_entry->read_proc=rtk_vlan_wan_tag_cpu_support_read;
+	    rtk_vlan_wan_tag_cpu_support_entry->write_proc=rtk_vlan_wan_tag_cpu_support_write;
+	}
+#endif
+
+#if defined(CONFIG_RTL_HW_VLAN_SUPPORT)
+	rtl_hw_vlan_support_entry = create_proc_entry("rtl_hw_vlan_support", 0, NULL);
+	if (rtl_hw_vlan_support_entry)
+	{
+	    rtl_hw_vlan_support_entry->read_proc=rtl_hw_vlan_support_read;
+	    rtl_hw_vlan_support_entry->write_proc=rtl_hw_vlan_support_write;
+	}
+	rtl_hw_vlan_tagged_bridge_multicast_entry = create_proc_entry("rtl_hw_vlan_tagged_mc", 0, NULL);
+	if (rtl_hw_vlan_tagged_bridge_multicast_entry)
+	{
+	    rtl_hw_vlan_tagged_bridge_multicast_entry->read_proc=rtl_hw_vlan_tagged_bridge_multicast_read;
+	    rtl_hw_vlan_tagged_bridge_multicast_entry->write_proc=rtl_hw_vlan_tagged_bridge_multicast_write;
+	}
 #endif
 
+
 #if defined(CONFIG_819X_PHY_RW)
 //#if defined(CONFIG_RTK_VLAN_FOR_CABLE_MODEM)
 	rtl_phy = create_proc_entry("rtl_phy_status",0,NULL);
@@ -5766,6 +6692,16 @@ int  __init re865x_probe (void)
 	#if defined(TX_TASKLET)
 	rtl_tx_tasklet_running=0;
 	#endif
+#if defined (CONFIG_RTL_SOCK_DEBUG)
+	rtl865x_creatSockDebugProc();
+#endif
+
+#if 0//def CONFIG_RTL_ULINKER //led
+	REG32(PIN_MUX_SEL_2) = REG32(PIN_MUX_SEL_2) | 0x00003000;
+	REG32(PABCD_CNR)     = REG32(PABCD_CNR) & ~(0x00004000);
+	REG32(PABCD_DIR)     = REG32(PABCD_DIR) | 0x00004000;
+	REG32(PABCD_DAT)     = REG32(PABCD_DAT) & ~(0x00004000);
+#endif
 
 	return 0;
 }
@@ -5925,10 +6861,12 @@ EXPORT_SYMBOL(priv_skb_copy);
 static void __exit re865x_exit (void)
 {
 
-#ifdef RTL865X_DRIVER_DEBUG_FLAG
+#if defined(CONFIG_RTL_PROC_DEBUG)||defined(CONFIG_RTL_DEBUG_TOOL)
+
 	rtl865x_proc_debug_cleanup();
 #endif
 
+
 #if defined(CONFIG_PROC_FS) && defined(CONFIG_NET_SCHED) && defined(CONFIG_RTL_LAYERED_DRIVER)
 #if defined(CONFIG_RTL_HW_QOS_SUPPORT)
 	rtl865x_exitOutputQueue();
@@ -5945,87 +6883,315 @@ static void __exit re865x_exit (void)
 	return;
 }
 
-module_init(re865x_probe);
-module_exit(re865x_exit);
+#ifdef CONFIG_RTK_FAKE_ETH
 
-/*
-@func enum RTL_RESULT | rtl865x_init | Initialize light rome driver and RTL865x ASIC.
-@rvalue RTL_SUCCESS | Initial success.
-@comm
-	Its important to call this API before using the driver. Note taht you can not call this API twice !
-*/
-int32 rtl865x_init(void)
+int32 rtl8651_EthernetPowerDown(void)
 {
-	int32 retval = 0;
+ uint32 statCtrlReg0;
+ int i;
 
+ //## from rtl8651_setAllAsicEthernetPHYPowerDown
+ for (i=0; i<5; i++) {
 
-	__865X_Config = 0;
+  /* read current PHY reg 0 value */
+  rtl8651_getAsicEthernetPHYReg( i, 0, &statCtrlReg0 );
 
-#ifdef CONFIG_RTL8196_RTL8366
-	/*	configure 8366 */
-	{
-		int ret;
-		int i;
-		rtl8366rb_phyAbility_t phy;
+  REG32(PCRP0+(i*4)) |= EnForceMode;
+  statCtrlReg0 |= POWER_DOWN;
 
-		REG32(PEFGHCNR_REG) = REG32(PEFGHCNR_REG)& (~(1<<11) ); //set byte F GPIO3 = gpio
-		REG32(PEFGHDIR_REG) = REG32(PEFGHDIR_REG) | (1<<11);  //0 input, 1 output, set F bit 3 output
-		REG32(PEFGHDAT_REG) = REG32(PEFGHDAT_REG) |( (1<<11) ); //F3 GPIO
-		mdelay(150);
+  /* write PHY reg 0 */
+  rtl8651_setAsicEthernetPHYReg( i, 0, statCtrlReg0 );
+ }
+ //#######################################
 
-		ret = smi_init(GPIO_PORT_F, 2, 1);
-		ret = rtl8366rb_initChip();
-		ret = rtl8366rb_initVlan();
-		ret = smi_write(0x0f09, 0x0020);
-		ret = smi_write(0x0012, 0xe0ff);
+ //then set bit 9 of 0xb800-0010 to 0. deactive switch core
 
-		memset(&phy, 0, sizeof(rtl8366rb_phyAbility_t));
-		phy.Full_1000 = 1;
-		phy.Full_100 = 1;
-		phy.Full_10 = 1;
-		phy.Half_100 = 1;
-		phy.Half_10 = 1;
-		phy.FC = 1;
-		phy.AsyFC = 1;
-		phy.AutoNegotiation = 1;
-		for(i=0;i<5;i++)
-		{
-			ret = rtl8366rb_setEthernetPHY(i,&phy);
-		}
-	}
+ REG32(SYS_CLK_MAG)&=(~(SYS_SW_CLK_ENABLE));
 
- 	 REG32(0xb8010000)=REG32(0xb8010000)&(0x20000000);
-        REG32(0xbb80414c)=0x00037d16;
-        REG32(0xbb804100)=1;
-        REG32(0xbb804104)=0x00E80367;
-#endif
+ return SUCCESS;
+}
 
-/*common*/
-	retval = rtl865x_initNetifTable();
-	retval = rtl865x_initVlanTable();
-#ifdef CONFIG_RTL_LAYERED_DRIVER_ACL
-	retval = rtl865x_init_acl();
-#endif
-	retval = rtl865x_initEventMgr(NULL);
+int re865x_ioctl_fake (struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	int32 rc = 0;
+	unsigned long *data;
+	int32 args[4];
+	int32  * pRet;
 
-/*l2*/
- #ifdef CONFIG_RTL_LAYERED_DRIVER_L2
-	retval = rtl865x_layer2_init();
- #endif
+	data = (unsigned long *)rq->ifr_data;
 
+	if (copy_from_user(args, data, 4*sizeof(unsigned long)))
+	{
+		return -EFAULT;
+	}
 
-/*layer3*/
-#ifdef CONFIG_RTL_LAYERED_DRIVER_L3
-	retval = rtl865x_initIpTable();
-	retval = rtl865x_initPppTable();
-	retval = rtl865x_initRouteTable();
-	retval = rtl865x_initNxtHopTable();
-	retval = rtl865x_arp_init();
-#endif
+	switch (args[0])
+	{
+		case RTL8651_IOCTL_GETWANLINKSTATUS:
+			{
+				pRet = (int32 *)args[3];
+				*pRet = FAILED;
+				rc = SUCCESS;
 
-/*layer4*/
-#if defined(CONFIG_RTL_LAYERED_DRIVER_L4) && defined(CONFIG_RTL_8198)
-	rtl865x_nat_init();
+				break;
+			}
+
+		case RTL8651_IOCTL_GETWANLINKSPEED:
+			{
+				int wanPortMask;
+
+				pRet = (int32 *)args[3];
+				*pRet = FAILED;
+				rc = SUCCESS;
+
+				wanPortMask = 0;
+
+				/* no wan port exist */
+				break;
+			}
+		default:
+			rc = SUCCESS;
+			break;
+	}
+
+	return rc;
+
+}
+
+
+static int rtl865x_set_mtu_fake(struct net_device *dev, int new_mtu)
+{
+	unsigned long flags;
+
+ 	local_irq_save(flags);
+	dev->mtu = new_mtu;
+
+	local_irq_restore(flags);
+
+	return SUCCESS;
+}
+
+static int rtl865x_set_hwaddr_fake(struct net_device *dev, void *addr)
+{
+	unsigned long flags;
+	int i;
+	unsigned char *p;
+
+	p = ((struct sockaddr *)addr)->sa_data;
+ 	local_irq_save(flags);
+
+	for (i = 0; i<ETHER_ADDR_LEN; ++i) {
+		dev->dev_addr[i] = p[i];
+	}
+
+	local_irq_restore(flags);
+	return SUCCESS;
+}
+
+static int re865x_start_xmit_fake(struct sk_buff *skb, struct net_device *dev)
+{
+
+	dev_kfree_skb_any(skb);
+	return 0;
+
+}
+
+static int re865x_open_fake (struct net_device *dev)
+{
+	struct dev_priv *cp;
+
+	cp = dev->priv;
+	//cp = netdev_priv(dev);
+	if (cp->opened)
+		return SUCCESS;
+
+	cp->opened = 1;
+	netif_start_queue(dev);
+	return SUCCESS;
+}
+
+
+static int re865x_close_fake (struct net_device *dev)
+{
+	struct dev_priv *cp;
+
+	cp = dev->priv;
+//	cp = netdev_priv(dev);
+
+	if (!cp->opened)
+		return SUCCESS;
+	netif_stop_queue(dev);
+
+//	memset(&cp->net_stats, '\0', sizeof(struct net_device_stats));
+	cp->opened = 0;
+
+#ifdef BR_SHORTCUT
+	if (dev == cached_dev)
+		cached_dev=NULL;
+#endif
+	return SUCCESS;
+}
+
+#if defined(CONFIG_COMPAT_NET_DEV_OPS)
+#else
+static const struct net_device_ops rtl819x_netdev_ops_fake = {
+	.ndo_open		= re865x_open_fake,
+	.ndo_stop		= re865x_close_fake,
+//	.ndo_validate_addr	= eth_validate_addr_fake,
+	.ndo_set_mac_address 	= rtl865x_set_hwaddr_fake,
+//	.ndo_set_multicast_list	= re865x_set_rx_mode_fake,
+//	.ndo_get_stats		= re865x_get_stats_fake,
+	.ndo_do_ioctl		= re865x_ioctl_fake,
+	.ndo_start_xmit		= re865x_start_xmit_fake,
+//	.ndo_tx_timeout		= re865x_tx_timeout_fake,
+//#if defined(CP_VLAN_TAG_USED)
+//	.ndo_vlan_rx_register	= cp_vlan_rx_register,
+//endif
+	.ndo_change_mtu		= rtl865x_set_mtu_fake,
+
+};
+#endif
+
+
+int  __init re865x_probe_fake (void)
+{
+	struct net_device *dev;
+    struct dev_priv	  *dp;
+	int rc;
+
+	dev = alloc_etherdev(sizeof(struct dev_priv));
+	if (!dev) {
+		printk("failed to allocate dev %d", 0);
+		return -1;
+	}
+
+    dp = dev->priv;
+	memset(dp,0,sizeof(*dp));
+	dp->dev = dev;
+
+	memcpy((char*)dev->dev_addr,(char*)(&(vlanconfig[0].mac)),ETHER_ADDR_LEN); //mark_FIXME.
+
+#if defined(CONFIG_COMPAT_NET_DEV_OPS)
+		dev->open = re865x_open_fake;
+		dev->stop = re865x_close_fake;
+		//dev->set_multicast_list = re865x_set_rx_mode;
+		dev->hard_start_xmit = re865x_start_xmit_fake;
+		//dev->get_stats = re865x_get_stats;
+		dev->do_ioctl = re865x_ioctl_fake;
+		//dev->tx_timeout = re865x_tx_timeout;
+		dev->set_mac_address = rtl865x_set_hwaddr_fake;
+		dev->change_mtu = rtl865x_set_mtu_fake;
+#else
+		dev->netdev_ops = &rtl819x_netdev_ops_fake;
+#endif
+
+	dev->watchdog_timeo = TX_TIMEOUT;
+
+	rc = register_netdev(dev);
+
+#ifdef BR_SHORTCUT
+	cached_dev=NULL;
+#endif
+
+	if(rc)
+		rtlglue_printf("Failed to allocate eth%d\n", 0);
+
+	rc = rtl8651_EthernetPowerDown();
+
+	return 0;
+}
+static void __exit re865x_exit_fake (void)
+{
+	return ;
+}
+#endif
+
+#ifdef CONFIG_RTK_FAKE_ETH
+module_init(re865x_probe_fake);
+module_exit(re865x_exit_fake);
+#else
+module_init(re865x_probe);
+module_exit(re865x_exit);
+#endif
+
+/*
+@func enum RTL_RESULT | rtl865x_init | Initialize light rome driver and RTL865x ASIC.
+@rvalue RTL_SUCCESS | Initial success.
+@comm
+	Its important to call this API before using the driver. Note taht you can not call this API twice !
+*/
+int32 rtl865x_init(void)
+{
+	int32 retval = 0;
+
+
+	__865X_Config = 0;
+
+#ifdef CONFIG_RTL8196_RTL8366
+	/*	configure 8366 */
+	{
+		int ret;
+		int i;
+		rtl8366rb_phyAbility_t phy;
+
+		REG32(PEFGHCNR_REG) = REG32(PEFGHCNR_REG)& (~(1<<11) ); //set byte F GPIO3 = gpio
+		REG32(PEFGHDIR_REG) = REG32(PEFGHDIR_REG) | (1<<11);  //0 input, 1 output, set F bit 3 output
+		REG32(PEFGHDAT_REG) = REG32(PEFGHDAT_REG) |( (1<<11) ); //F3 GPIO
+		mdelay(150);
+
+		ret = smi_init(GPIO_PORT_F, 2, 1);
+		ret = rtl8366rb_initChip();
+		ret = rtl8366rb_initVlan();
+		ret = smi_write(0x0f09, 0x0020);
+		ret = smi_write(0x0012, 0xe0ff);
+
+		memset(&phy, 0, sizeof(rtl8366rb_phyAbility_t));
+		phy.Full_1000 = 1;
+		phy.Full_100 = 1;
+		phy.Full_10 = 1;
+		phy.Half_100 = 1;
+		phy.Half_10 = 1;
+		phy.FC = 1;
+		phy.AsyFC = 1;
+		phy.AutoNegotiation = 1;
+		for(i=0;i<5;i++)
+		{
+			ret = rtl8366rb_setEthernetPHY(i,&phy);
+		}
+	}
+
+ 	 REG32(0xb8010000)=REG32(0xb8010000)&(0x20000000);
+        REG32(0xbb80414c)=0x00037d16;
+        REG32(0xbb804100)=1;
+        REG32(0xbb804104)=0x00E80367;
+#endif
+
+/*common*/
+	retval = rtl865x_initNetifTable();
+	retval = rtl865x_initVlanTable();
+#ifdef CONFIG_RTL_LAYERED_DRIVER_ACL
+	retval = rtl865x_init_acl();
+#endif
+	retval = rtl865x_initEventMgr(NULL);
+
+/*l2*/
+ #ifdef CONFIG_RTL_LAYERED_DRIVER_L2
+	retval = rtl865x_layer2_init();
+ #endif
+
+
+/*layer3*/
+#ifdef CONFIG_RTL_LAYERED_DRIVER_L3
+	retval = rtl865x_initIpTable();
+	retval = rtl865x_initPppTable();
+	retval = rtl865x_initRouteTable();
+	retval = rtl865x_initNxtHopTable();
+	retval = rtl865x_arp_init();
+#endif
+
+/*layer4*/
+#if defined(CONFIG_RTL_LAYERED_DRIVER_L4) && (defined(CONFIG_RTL_8198) ||defined(CONFIG_RTL_8196CT))
+	rtl865x_nat_init();
 #endif
 
  	/*queue id & rx ring descriptor mapping*/
@@ -6036,7 +7202,8 @@ int32 rtl865x_init(void)
 
 	rtl8651_setAsicOutputQueueNumber(CPU, RTL_CPU_RX_RING_NUM);
 
-#ifdef RTL865X_DRIVER_DEBUG_FLAG
+/*CONFIG_RTL_PROC_DEBUG:marco forproc debug. CONFIG_RTL_DEBUG_TOOL: marco for debug tool*/
+#if defined(CONFIG_RTL_PROC_DEBUG)||defined(CONFIG_RTL_DEBUG_TOOL)
 	rtl865x_proc_debug_init();
 #endif
 
@@ -6177,6 +7344,18 @@ int32 rtl865x_config(struct rtl865x_vlanConfig vlanconfig[])
 	rtl865x_initOutputQueue((uint8 **)netIfName);
 	#endif
 
+	#ifdef CONFIG_RTK_VOIP_QOS
+	rtl8651_setAsicOutputQueueNumber(0,QNUM3);
+	rtl8651_setAsicOutputQueueNumber(1,QNUM3);
+	rtl8651_setAsicOutputQueueNumber(2,QNUM3);
+	rtl8651_setAsicOutputQueueNumber(3,QNUM3);
+	rtl8651_setAsicOutputQueueNumber(4,QNUM3);
+	rtl8651_setAsicOutputQueueNumber(6,QNUM3);
+	REG32(CPUQIDMCR0)=0x55221000;
+	rtl8651_setAsicPriorityDecision(2, 1, 2, 1, 1);
+	#endif
+
+
 	#if defined (CONFIG_RTL_UNKOWN_UNICAST_CONTROL)
 	{
 		rtl865x_tblAsicDrv_rateLimitParam_t	asic_rl;
@@ -6315,7 +7494,7 @@ static int re865x_reInitIgmpSetting(int mode)
 		}
 
 		//rtl_setIgmpSnoopingModuleUnknownMCastFloodMap(nicIgmpModuleIndex, 0x0);
-		rtl_setIpv4UnknownMCastFloodMap(nicIgmpModuleIndex, 0x0);
+		rtl_setIpv4UnknownMCastFloodMap(nicIgmpModuleIndex, 0xFFFFFFFF);
 		rtl_setIpv6UnknownMCastFloodMap(nicIgmpModuleIndex, 0xFFFFFFFF);
 
 	}
@@ -6515,6 +7694,7 @@ static int rtl_config_lanwan_dev_vlanconfig(int mode)
 		vlanconfig[1].untagSet = RTL_WANPORT_MASK;
 		((struct dev_priv *)_rtl86xx_dev.dev[1]->priv)->portmask = RTL_WANPORT_MASK; //eth1
 		((struct dev_priv *)_rtl86xx_dev.dev[1]->priv)->id = RTL_WANVLANID; //eth1
+
 	#endif //endif CONFIG_POCKET_ROUTER_SUPPORT
 
 #else
@@ -6612,6 +7792,9 @@ static int rtl_config_vlanconfig(int mode)
 
 int32 rtl865x_changeOpMode(int mode)
 {
+#ifdef CONFIG_RTK_FAKE_ETH
+	return SUCCESS;
+#endif
 #if defined (CONFIG_RTL_LOCAL_PUBLIC)
 	struct rtl865x_interface_info ifInfo;
 #endif
@@ -6764,11 +7947,13 @@ int32 rtl865x_changeOpMode(int mode)
 	//setAsicOperationLayer
 	rtl_config_operation_layer(mode);
 
+#ifdef CONFIG_RTL_LAYERED_DRIVER_L3
 	//always init the default route...
 	if(rtl8651_getAsicOperationLayer() >2)
 	{
 		rtl865x_addRoute(0,0,0,RTL_DRV_WAN0_NETIF_NAME,0);
 	}
+#endif
 
 	//checksum control register
 	switch(mode)
@@ -6879,6 +8064,7 @@ static int32 reinit_vlan_configure(struct rtl865x_vlanConfig new_vlanconfig[])
 
 	#if defined(CONFIG_RTL_MULTIPLE_WAN)
 	rtl_config_multipleWan_netif(RTL_MULTIWAN_ADD);
+	rtl865x_addMultiCastNetif();
 	#endif
 
 #if defined(CONFIG_RTK_VLAN_SUPPORT)
@@ -6907,6 +8093,65 @@ static int32 reinit_vlan_configure(struct rtl865x_vlanConfig new_vlanconfig[])
 			rtl865x_setPortToNetif(pvlanconfig[j].ifname, i);
 		}
 	}
+
+#if defined(CONFIG_RTL_HW_VLAN_SUPPORT)
+        if(rtl_hw_vlan_enable)
+        {
+        	if((hw_vlan_info[1].vlan_port_enabled)&&hw_vlan_info[1].vlan_port_tag){
+            		 rtl865x_setVlanPortTag(vlanconfig[1].vid,RTL_WANPORT_MASK,1); //eth1 vlan port 1 tag
+        	}
+	         swNic_setVlanPortTag(RTL_WANPORT_MASK);//packet from CPU, HW add tag
+
+                if((hw_vlan_info[0].vlan_port_enabled)&&(hw_vlan_info[0].vlan_port_bridge == 1)){
+                        rtl865x_addVlan(hw_vlan_info[0].vlan_port_vid);
+                        rtl865x_addVlanPortMember(hw_vlan_info[0].vlan_port_vid, RTL_LANPORT_MASK_4|RTL_WANPORT_MASK);
+                        rtl865x_setVlanPortTag(hw_vlan_info[0].vlan_port_vid, RTL_WANPORT_MASK,1); //wan port tag
+			  if(hw_vlan_info[0].vlan_port_tag){
+					rtl865x_setVlanPortTag(hw_vlan_info[0].vlan_port_vid, RTL_LANPORT_MASK_4,1); //wan port tag
+			  }
+			  rtl865x_setVlanFilterDatabase(hw_vlan_info[0].vlan_port_vid,0);
+                        rtl8651_setAsicPvid(0, hw_vlan_info[0].vlan_port_vid); //port vid
+			  rtl865x_setPortForward(RTL_LANPORT_MASK_4, TRUE);
+                }
+                if((hw_vlan_info[2].vlan_port_enabled)&&(hw_vlan_info[2].vlan_port_bridge == 1)){
+                        rtl865x_addVlan(hw_vlan_info[2].vlan_port_vid);
+                        rtl865x_addVlanPortMember(hw_vlan_info[2].vlan_port_vid, RTL_LANPORT_MASK_3|RTL_WANPORT_MASK);
+                        rtl865x_setVlanPortTag(hw_vlan_info[2].vlan_port_vid, RTL_WANPORT_MASK,1); //wan port tag
+			  if(hw_vlan_info[2].vlan_port_tag){
+					 rtl865x_setVlanPortTag(hw_vlan_info[2].vlan_port_vid, RTL_LANPORT_MASK_3,1); //wan port tag
+			  }
+			  rtl865x_setVlanFilterDatabase(hw_vlan_info[2].vlan_port_vid,0);
+                        rtl8651_setAsicPvid(1, hw_vlan_info[2].vlan_port_vid); //port vid
+                        rtl865x_setPortForward(RTL_LANPORT_MASK_3, TRUE);
+                }
+                if((hw_vlan_info[3].vlan_port_enabled)&&(hw_vlan_info[3].vlan_port_bridge == 1)){
+                        rtl865x_addVlan(hw_vlan_info[3].vlan_port_vid);
+                        rtl865x_addVlanPortMember(hw_vlan_info[3].vlan_port_vid, RTL_LANPORT_MASK_2|RTL_WANPORT_MASK);
+                        rtl865x_setVlanPortTag(hw_vlan_info[3].vlan_port_vid, RTL_WANPORT_MASK,1); //wan port tag
+			  if(hw_vlan_info[3].vlan_port_tag){
+				 	rtl865x_setVlanPortTag(hw_vlan_info[3].vlan_port_vid, RTL_LANPORT_MASK_2,1); //wan port tag
+			  }
+			  rtl865x_setVlanFilterDatabase(hw_vlan_info[3].vlan_port_vid,0);
+                        rtl8651_setAsicPvid(2, hw_vlan_info[3].vlan_port_vid); //port vid
+                        rtl865x_setPortForward(RTL_LANPORT_MASK_2, TRUE);
+                }
+		 if((hw_vlan_info[4].vlan_port_enabled)&&(hw_vlan_info[4].vlan_port_bridge == 1)){
+                        rtl865x_addVlan(hw_vlan_info[4].vlan_port_vid);
+                        rtl865x_addVlanPortMember(hw_vlan_info[4].vlan_port_vid, RTL_LANPORT_MASK_1|RTL_WANPORT_MASK);
+                        rtl865x_setVlanPortTag(hw_vlan_info[4].vlan_port_vid, RTL_WANPORT_MASK,1); //wan port tag
+			  if(hw_vlan_info[4].vlan_port_tag){
+				 	rtl865x_setVlanPortTag(hw_vlan_info[4].vlan_port_vid, RTL_LANPORT_MASK_1,1); //wan port tag
+			  }
+			  rtl865x_setVlanFilterDatabase(hw_vlan_info[4].vlan_port_vid,0);
+                        rtl8651_setAsicPvid(3, hw_vlan_info[4].vlan_port_vid); //port vid
+                        rtl865x_setPortForward(RTL_LANPORT_MASK_1, TRUE);
+                }
+        }
+        else{
+                swNic_setVlanPortTag(0);
+        }
+#endif
+
 #ifdef CONFIG_RTL_STP
 	re865x_stp_mapping_reinit();
 #endif
@@ -6960,38 +8205,286 @@ static int32 rtk_vlan_support_read( char *page, char **start, off_t off, int cou
 	return len;
 }
 
-static int32 rtk_vlan_support_write( struct file *filp, const char *buff,unsigned long len, void *data )
+#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+
+static int32 rtk_vlan_wan_tag_cpu_support_write( struct file *filp, const char *buff,unsigned long len, void *data )
 {
-	char 		tmpbuf[32];
-	int i=0;
-	int j=0;
-	struct net_device *dev;
-	struct dev_priv	  *dp;
+	  char tmpbuf[100];
+	  int num ;
+	  if (buff && !copy_from_user(tmpbuf, buff, len))
+      {
 
-	if (buff && !copy_from_user(tmpbuf, buff, len))
-	{
-		tmpbuf[len] = '\0';
-		#if defined (CONFIG_RTL_IGMP_SNOOPING) && defined (CONFIG_RTL_MLD_SNOOPING)
-		if(mldSnoopEnabled)
-		{
-			rtl865x_removeAclForMldSnooping(vlanconfig);
-		}
-		#endif
-		if(tmpbuf[0] == '0')
-		{
-			rtk_vlan_support_enable = 0;
+            num = sscanf(tmpbuf, "%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d",
+            &vlan_host_enable, &vlan_host_tag, &vlan_host_pri,
+            &vlan_wifi_enable[0], &vlan_wifi_tag[0], &vlan_wifi_pri[0],
+            &vlan_wifi_enable[1], &vlan_wifi_tag[1], &vlan_wifi_pri[1],
+            &vlan_wifi_enable[2], &vlan_wifi_tag[2], &vlan_wifi_pri[2],
+            &vlan_wifi_enable[3], &vlan_wifi_tag[3], &vlan_wifi_pri[3],
+            &vlan_wifi_enable[4], &vlan_wifi_tag[4], &vlan_wifi_pri[4]);
 
-			rtl_config_rtkVlan_vlanconfig(rtl865x_curOpMode);
-			re865x_packVlanConfig(vlanconfig, packedVlanConfig);
-			rtl_reinit_hw_table();
-			reinit_vlan_configure(packedVlanConfig);
 
-			//unknow vlan drop
-			REG32(SWTCR0) &= ~(1 << 15);
+			if (num !=  18) {
+                    printk("invalid rtk_vlan_wan_tag_cpu_support_write parameter!\n");
+                    return len;
+            }
 
-#if defined(CONFIG_RTL_LAYERED_DRIVER_ACL)
-			rtl865x_enable_acl(1); //enable acl feature
-#endif
+            if(!vlan_enable)
+            {
+            	vlan_host_enable = 0 ;
+            	vlan_wifi_enable[0] = 0;
+            	vlan_wifi_enable[1] = 0;
+            	vlan_wifi_enable[2] = 0;
+            	vlan_wifi_enable[3] = 0;
+            	vlan_wifi_enable[4] = 0;
+            }
+
+
+            if(	vlan_host_enable||vlan_wifi_enable[0]||vlan_wifi_enable[1]||
+            	vlan_wifi_enable[1]||vlan_wifi_enable[3]||vlan_wifi_enable[4])
+      		   WRITE_MEM32(SWTCR0,(READ_MEM32(SWTCR0)| EnUkVIDtoCPU));
+      		else
+      		   WRITE_MEM32(SWTCR0,(READ_MEM32(SWTCR0)&(~EnUkVIDtoCPU)));
+	  }
+	  return len;
+}
+static int32 rtk_vlan_wan_tag_cpu_support_read( char *page, char **start, off_t off, int count, int *eof, void *data )
+{
+ 		int len;
+        len = sprintf(page, "vlan_host_enable: %d\nvlan_host_tag : %d vlan_host_pri : %d\nvlan_wifi_enable: %d %d %d %d %d \nvlan_wifi_tag : %d %d %d %d %d\nvlan_wifi_pri : %d %d %d %d %d\n",
+        //len = sprintf(page, "%d %d %d %d% %d %d %d %d %d %d %d %d %d %d %d %d %d %d\n",
+        vlan_host_enable, vlan_host_tag, vlan_host_pri,vlan_wifi_enable[0], vlan_wifi_enable[1], vlan_wifi_enable[2],vlan_wifi_enable[3], vlan_wifi_enable[4],
+           vlan_wifi_tag[0],    vlan_wifi_tag[1], vlan_wifi_tag[2], vlan_wifi_tag[3], vlan_wifi_tag[4],
+           vlan_wifi_pri[0],   vlan_wifi_pri[1], vlan_wifi_pri[2], vlan_wifi_pri[3], vlan_wifi_pri[4]);
+
+         //len = sprintf(page, "%d \n",vlan_host_enable);
+        if (len <= off+count) *eof = 1;
+        *start = page + off;
+        len -= off;
+        if (len>count)
+                len = count;
+        if (len<0)
+                len = 0;
+        return len;
+}
+static int32 rtk_vlan_wan_tag_getportmask(int bridge_port)
+{
+	int32 port_mask = 0x80;// PKTHDR_EXTPORT_LIST_P2 2=> bit 7
+
+	if(vlan_bridge_port&(1<<3))
+		port_mask |= RTL_LANPORT_MASK_1;
+
+	if(vlan_bridge_port&(1<<2))
+		port_mask |= RTL_LANPORT_MASK_2;
+
+	if(vlan_bridge_port&(1<<1))
+		port_mask |= RTL_LANPORT_MASK_3;
+
+	if(vlan_bridge_port&(1<<0))
+		port_mask |= RTL_LANPORT_MASK_4;
+
+	return port_mask;
+}
+static int32 rtk_vlan_wan_tag_support_write( struct file *filp, const char *buff,unsigned long len, void *data )
+{
+        char tmpbuf[100];
+        int lan_portmask;
+        int num ;
+		int i=0;
+		int j=0;
+		struct net_device *dev;
+		struct dev_priv	  *dp;
+ #ifdef CONFIG_RTL_IGMP_SNOOPING
+ 		int ret = 0;
+ 		rtl_multicastDeviceInfo_t devInfo;
+ #endif
+
+        if (buff && !copy_from_user(tmpbuf, buff, len))
+        {
+
+       		num = sscanf(tmpbuf, "%d %d %d %d %d %d %d", &vlan_enable,  &vlan_tag, &vlan_bridge_enable,&vlan_bridge_tag,&vlan_bridge_port,&vlan_bridge_multicast_enable,&vlan_bridge_multicast_tag);
+            if (num !=  7) {
+                    printk("invalid rtk_vlan_wan_tag_support_write parameter!\n");
+                    return len;
+            }
+            if(rtl865x_curOpMode != GATEWAY_MODE)
+			{
+				vlan_enable = 0;
+				vlan_bridge_enable = 0;
+				return len;
+			}
+
+			rtl_config_rtkVlan_vlanconfig(rtl865x_curOpMode);
+
+	        if(vlan_enable)
+	        {
+	            lan_portmask =  0;
+
+	            if(vlan_bridge_enable)
+	            {
+                    lan_portmask = rtk_vlan_wan_tag_getportmask(vlan_bridge_port);
+	            	vlanconfig[2] .vid = vlan_bridge_tag;
+	            	vlanconfig[2].memPort = lan_portmask|RTL_WANPORT_MASK;
+					vlanconfig[2].untagSet = lan_portmask;
+
+					//need verify
+					vlanconfig[2].fid = 1;
+					((struct dev_priv *)_rtl86xx_dev.dev[2]->priv)->portmask = lan_portmask|RTL_WANPORT_MASK;
+					((struct dev_priv *)_rtl86xx_dev.dev[2]->priv)->id = vlan_bridge_tag; //eth2
+	            }
+	            vlanconfig[0].memPort = RTL_LANPORT_MASK &(~lan_portmask);
+	            vlanconfig[0].vid= RTL_LANVLANID;
+	            vlanconfig[0].untagSet = RTL_LANPORT_MASK &(~lan_portmask);
+	            ((struct dev_priv *)_rtl86xx_dev.dev[0]->priv)->portmask = RTL_LANPORT_MASK &(~lan_portmask); //eth0
+	            ((struct dev_priv *)_rtl86xx_dev.dev[0]->priv)->id = RTL_LANVLANID;
+
+	            vlanconfig[1].vid = vlan_tag;
+	            vlanconfig[1].memPort = RTL_WANPORT_MASK;
+	            vlanconfig[1].untagSet = 0; // need tag
+	            ((struct dev_priv *)_rtl86xx_dev.dev[1]->priv)->portmask = RTL_WANPORT_MASK; //eth1
+	            ((struct dev_priv *)_rtl86xx_dev.dev[1]->priv)->id = vlan_tag; //eth1
+	             //PPPOE
+                 vlanconfig[5].vid = vlan_tag;
+	        }
+
+			rtl_reinit_hw_table();
+			reinit_vlan_configure(vlanconfig);
+
+
+	        if(vlan_enable)
+	        {
+
+        	    rtl865x_setVlanPortTag(vlanconfig[1].vid,RTL_WANPORT_MASK,true); //eth1 vlan port 1 tag
+	            swNic_setVlanPortTag(RTL_WANPORT_MASK);//packet from CPU, HW add tag
+
+				if(vlan_bridge_enable)
+				{
+					rtl865x_setVlanPortTag(vlan_bridge_tag, RTL_WANPORT_MASK,true); //wan port tag
+
+					if(nicIgmpModuleIndex_2==0xFFFFFFFF)
+					{
+						ret = rtl_registerIgmpSnoopingModule(&nicIgmpModuleIndex_2);
+					#if defined (CONFIG_RTL_HARDWARE_MULTICAST)
+						memset(&devInfo, 0, sizeof(rtl_multicastDeviceInfo_t ));
+						strcpy(devInfo.devName, RTL_PS_ETH_NAME_ETH2);
+						if(ret==0)
+							 rtl_setIgmpSnoopingModuleDevInfo(nicIgmpModuleIndex_2,&devInfo);
+					#endif
+					}
+                    if(vlan_bridge_multicast_enable)
+					{
+                        rtl865x_addVlan(vlan_bridge_multicast_tag);
+                        rtl865x_addVlanPortMember(vlan_bridge_multicast_tag,RTL_WANPORT_MASK);
+                        rtl865x_setVlanPortTag(vlan_bridge_multicast_tag,RTL_WANPORT_MASK,1); //wan port tag
+                        rtl865x_setVlanFilterDatabase(RTL_WANPORT_MASK,1);
+                    }
+
+				}
+				else
+				{
+                    vlan_bridge_multicast_enable = 0;
+					if(nicIgmpModuleIndex_2!=0xFFFFFFFF)
+						rtl_unregisterIgmpSnoopingModule(nicIgmpModuleIndex_2);
+				}
+	        }
+	        else
+	        {
+	        	rtl865x_setVlanPortTag(vlanconfig[1].vid,RTL_WANPORT_MASK,false); //eth1 vlan port 1 tag
+            #ifdef CONFIG_RTL_IGMP_SNOOPING
+				if(nicIgmpModuleIndex_2!=0xFFFFFFFF)
+					rtl_unregisterIgmpSnoopingModule(nicIgmpModuleIndex_2);
+			#endif
+	                swNic_setVlanPortTag(0); //packet no tag from CPU
+	        }
+
+				/*update dev port number*/
+				for(i=0; vlanconfig[i].vid != 0; i++)
+				{
+					if (IF_ETHER!=vlanconfig[i].if_type)
+					{
+						continue;
+					}
+
+					dev=_rtl86xx_dev.dev[i];
+					dp = dev->priv;
+					dp->portnum  = 0;
+					for(j=0;j<RTL8651_AGGREGATOR_NUMBER;j++)
+					{
+						if(dp->portmask & (1<<j))
+							dp->portnum++;
+					}
+
+				}
+
+			#if defined (CONFIG_RTL_IGMP_SNOOPING)
+				//need check by tim
+				re865x_reInitIgmpSetting(rtl865x_curOpMode);
+				#if defined (CONFIG_RTL_MLD_SNOOPING)
+				if(mldSnoopEnabled)
+				{
+					re865x_packVlanConfig(vlanconfig, packedVlanConfig);
+					rtl865x_addAclForMldSnooping(packedVlanConfig);
+				}
+				#endif
+			#endif
+
+				//always init the default route...
+				if(rtl8651_getAsicOperationLayer() >2)
+				{
+					rtl865x_addRoute(0,0,0,RTL_DRV_WAN0_NETIF_NAME,0);
+				}
+        }
+
+        return len;
+}
+static int32 rtk_vlan_wan_tag_support_read( char *page, char **start, off_t off, int count, int *eof, void *data )
+{
+        int len;
+        len = sprintf(page, "vlan_enable: %d vlan tag %d \nvlan_bridge_enable: %d , vlan_bridge_tag: %d, vlan_bridge_port: 0x%x \nvlan_bridge_multicast_enable: %d vlan_bridge_stream_tag: %d\n",
+        vlan_enable, vlan_tag, vlan_bridge_enable, vlan_bridge_tag, vlan_bridge_port,vlan_bridge_multicast_enable,vlan_bridge_multicast_tag);
+        if (len <= off+count) *eof = 1;
+        *start = page + off;
+        len -= off;
+        if (len>count)
+                len = count;
+        if (len<0)
+                len = 0;
+        return len;
+}
+
+#endif
+
+static int32 rtk_vlan_support_write( struct file *filp, const char *buff,unsigned long len, void *data )
+{
+	char 		tmpbuf[32];
+	int i=0;
+	int j=0;
+	struct net_device *dev;
+	struct dev_priv	  *dp;
+
+	if (buff && !copy_from_user(tmpbuf, buff, len))
+	{
+		tmpbuf[len] = '\0';
+		#if defined (CONFIG_RTL_IGMP_SNOOPING) && defined (CONFIG_RTL_MLD_SNOOPING)
+		if(mldSnoopEnabled)
+		{
+			rtl865x_removeAclForMldSnooping(vlanconfig);
+		}
+		#endif
+		if(tmpbuf[0] == '0')
+		{
+			rtk_vlan_support_enable = 0;
+
+			rtl_config_rtkVlan_vlanconfig(rtl865x_curOpMode);
+			re865x_packVlanConfig(vlanconfig, packedVlanConfig);
+			rtl_reinit_hw_table();
+			reinit_vlan_configure(packedVlanConfig);
+
+			//unknow vlan drop
+			REG32(SWTCR0) &= ~(1 << 15);
+
+#if defined(CONFIG_RTL_LAYERED_DRIVER_ACL)
+			rtl865x_enable_acl(1); //enable acl feature
+#endif
 		}
 		else if(tmpbuf[0] == '1')
 		{
@@ -7460,75 +8953,461 @@ static int32 port_mibStats_write_proc( struct file *filp, const char *buff,unsig
 }
 
 
-#endif	//#if defined(CONFIG_819X_PHY_RW)
+#endif	//#if defined(CONFIG_819X_PHY_RW)
+
+
+static int read_proc_vlan(char *page, char **start, off_t off,
+        int count, int *eof, void *data)
+{
+
+    struct net_device *dev = (struct net_device *)data;
+    struct dev_priv *cp;
+    int len;
+
+	cp = dev->priv;
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+		len = sprintf(page, "gvlan=%d, lan=%d, vlan=%d, tag=%d, vid=%d, priority=%d, cfi=%d, forwarding_rule=%d\n",
+#else
+		len = sprintf(page, "gvlan=%d, lan=%d, vlan=%d, tag=%d, vid=%d, priority=%d, cfi=%d\n",
+#endif
+		cp->vlan_setting.global_vlan, cp->vlan_setting.is_lan, cp->vlan_setting.vlan, cp->vlan_setting.tag,
+		cp->vlan_setting.id, cp->vlan_setting.pri, cp->vlan_setting.cfi
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+		,cp->vlan_setting.forwarding_rule
+#endif
+		);
+
+    if (len <= off+count)
+        *eof = 1;
+    *start = page + off;
+    len -= off;
+    if (len > count)
+        len = count;
+    if (len < 0)
+        len = 0;
+    return len;
+}
+
+static int write_proc_vlan(struct file *file, const char *buffer,
+              unsigned long count, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct dev_priv *cp;
+	#define	VLAN_MAX_INPUT_LEN	128
+	char *tmp;
+
+	tmp = kmalloc(VLAN_MAX_INPUT_LEN, GFP_KERNEL);
+	if (count < 2 || tmp==NULL)
+		goto out;
+
+	cp = dev->priv;
+	if(rtk_vlan_support_enable == 0)
+		goto out;
+
+	if (buffer && !copy_from_user(tmp, buffer, VLAN_MAX_INPUT_LEN))
+	{
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+			int num = sscanf(tmp, "%d %d %d %d %d %d %d %d",
+#else
+			int num = sscanf(tmp, "%d %d %d %d %d %d %d",
+#endif
+			&cp->vlan_setting.global_vlan, &cp->vlan_setting.is_lan,
+			&cp->vlan_setting.vlan, &cp->vlan_setting.tag,
+			&cp->vlan_setting.id, &cp->vlan_setting.pri,
+			&cp->vlan_setting.cfi
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+			, &cp->vlan_setting.forwarding_rule
+#endif
+			);
+
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+		if (num !=8)
+#else
+		if (num !=7)
+#endif
+		{
+			printk("invalid vlan parameter!\n");
+			goto out;
+		}
+
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+		rtl_add_vlan_info(&cp->vlan_setting, dev);
+#endif
+		#if 0
+		printk("===%s(%d), cp->name(%s),global_vlan(%d),is_lan(%d),vlan(%d),tag(%d),id(%d),pri(%d),cfi(%d)",__FUNCTION__,__LINE__,
+			cp->dev->name,cp->vlan_setting.global_vlan,cp->vlan_setting.is_lan,cp->vlan_setting.vlan,cp->vlan_setting.tag,
+			cp->vlan_setting.id,cp->vlan_setting.pri,cp->vlan_setting.cfi);
+		printk("-------------%s(%d),cp->portmask(%d)\n",__FUNCTION__,__LINE__,cp->portmask);
+		#endif
+	}
+out:
+	if(tmp)
+		kfree(tmp);
+
+	return count;
+}
+#endif // CONFIG_RTK_VLAN_SUPPORT
+
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+static int rtk_vlan_management_read(char *page, char **start, off_t off,
+        int count, int *eof, void *data)
+{
+
+    int len;
+
+    len = sprintf(page, "Management vlan: vid=%d, priority=%d, cfi=%d\n",
+		management_vlan.id, management_vlan.pri, management_vlan.cfi
+		);
+
+    if (len <= off+count)
+        *eof = 1;
+    *start = page + off;
+    len -= off;
+    if (len > count)
+        len = count;
+    if (len < 0)
+        len = 0;
+    return len;
+}
+
+static int rtk_vlan_management_write(struct file *file, const char *buffer,
+              unsigned long len, void *data)
+{
+	char tmpbuf[128];
+	int num;
+
+	if (buffer && !copy_from_user(tmpbuf, buffer, len))
+	{
+		tmpbuf[len] = '\0';
+
+		num = sscanf(tmpbuf, "%d %d %d",
+			&management_vlan.id, &management_vlan.pri,
+			&management_vlan.cfi);
+
+		if (num !=  3) {
+			printk("invalid vlan parameter!\n");
+		}
+
+	}
+
+	return len;
+}
+
+#endif
+
+#if defined(CONFIG_RTL_HW_VLAN_SUPPORT)
+
+uint32 rtl_hw_vlan_get_tagged_portmask(void)
+{
+	uint32 portmask = 0;
+	int i, temp;
+
+	for(i=0; i<PORT_NUMBER; i++)
+	{
+		if((hw_vlan_info[i].vlan_port_enabled) && (hw_vlan_info[i].vlan_port_tag))
+		{
+			temp = (i==0)?0:(i-1);
+			portmask |= 1<<temp;
+		}
+	}
+
+	return portmask;
+}
+
+int rtl_process_hw_vlan_tx(rtl_nicTx_info *txInfo)
+{
+	int i, temp;
+	int flag = 0;
+	unsigned short vid;
+	struct sk_buff *newskb;
+	struct sk_buff *skb = NULL;
+	unsigned short vid;
+	struct vlan_tag tag, port_tag;
+	struct vlan_tag *adding_tag = NULL;
+	struct net_device *dev;
+	struct dev_priv *cp;
+
+	memset(&tag, 0, sizeof(struct vlan_tag));
+	memset(&port_tag, 0, sizeof(struct vlan_tag));
+	skb = txInfo->out_skb;
+	dev = skb->dev;
+	cp = dev->priv;
+
+	newskb = NULL;
+	if (skb_cloned(skb))
+	{
+		newskb = skb_copy(skb, GFP_ATOMIC);
+		if (newskb == NULL)
+		{
+			cp->net_stats.tx_dropped++;
+			dev_kfree_skb_any(skb);
+			return FAILED;
+		}
+		dev_kfree_skb_any(skb);
+		skb = newskb;
+		txInfo->out_skb = skb;
+	}
+
+	//if((skb->data[0]&1) ||((skb->data[0]==0x33) &&(skb->data[1]==0x33) && (skb->data[2]!=0xFF)))
+	{
+		if(skb->tag.f.tpid == htons(ETH_P_8021Q))
+		{
+			vid = ntohs(skb->tag.f.pci & 0xfff);
+			for(i=0; i<PORT_NUMBER; i++)
+			{
+				temp = (i==0)?i:(i-1);
+				if((((struct dev_priv*)skb->dev->priv)->portmask & (0x1<<temp))&&(vid == hw_vlan_info[i].vlan_port_vid)&&
+					(hw_vlan_info[i].vlan_port_bridge == 1)&&(hw_vlan_info[i].vlan_port_tag)&&(hw_vlan_info[i].vlan_port_enabled))
+					{
+						flag = 1;
+						break;
+					}
+			}
+
+			if(flag)
+			{
+				//printk("dev name is %s, portmask is 0x%x, i is %d, vid is %d\n", skb->dev->name, ((struct dev_priv*)skb->dev->priv)->portmask, i, vid);
+				adding_tag = &skb->tag;
+			}
+		}else{
+			for(i=0; i<PORT_NUMBER; i++)
+			{
+				if(((struct dev_priv*)skb->dev->priv)->portmask & (0x1<<i))
+				{
+					flag = 1;
+					break;
+				}
+			}
+			temp = (i==0)?i:(i+1);
+			if((flag)&&(hw_vlan_info[temp].vlan_port_bridge == 1)&& (hw_vlan_info[temp].vlan_port_tag) &&
+			   (hw_vlan_info[temp].vlan_port_enabled))
+			{
+				port_tag.f.tpid =  htons(ETH_P_8021Q);
+				port_tag.f.pci = (unsigned short) ((0x3 << 13) |(0x1 << 12) |
+							((unsigned short)(hw_vlan_info[temp].vlan_port_vid&0xfff)));
+				port_tag.f.pci =  htons(port_tag.f.pci);
+				adding_tag = &port_tag;
+			}
+		}
+
+		if(adding_tag != NULL)
+		{
+			memcpy(&tag, skb->data+ETH_ALEN*2, VLAN_HLEN);
+			if (tag.f.tpid !=  htons(ETH_P_8021Q)) { // tag not existed, insert tag
+			if (skb_headroom(skb) < VLAN_HLEN && skb_cow(skb, VLAN_HLEN) !=0 ) {
+				printk("%s-%d: error! (skb_headroom(skb) == %d < 4). Enlarge it!\n",
+				__FUNCTION__, __LINE__, skb_headroom(skb));
+				while (1) ;
+			}
+			skb_push(skb, VLAN_HLEN);
+			memmove(skb->data, skb->data+VLAN_HLEN, ETH_ALEN*2);
+			}
+
+			memcpy(skb->data+ETH_ALEN*2, adding_tag, VLAN_HLEN);
+		}
+
+	}
+
+	return SUCCESS;
+
+}
+
+static int32 rtl_hw_vlan_support_read( char *page, char **start, off_t off, int count, int *eof, void *data )
+{
+        int len;
+	 int i;
+
+	 len = sprintf(page, "rtl_hw_vlan_enable: %d\n", rtl_hw_vlan_enable);
+	 for(i=0; i<PORT_NUMBER; i++)
+	 {
+	 	if(i == 1)
+			continue;
+
+		len += sprintf(page + len, "lan_%d_bridge_enabled: %d, lan_%d_bridge: %d, lan_%d_tag: %d, lan_%d_vid: %d\n",
+			((i==0)? i: i-1), hw_vlan_info[i].vlan_port_enabled, ((i==0)? i: i-1), hw_vlan_info[i].vlan_port_bridge, ((i==0)? i: i-1), hw_vlan_info[i].vlan_port_tag,
+			((i==0)? i: i-1), hw_vlan_info[i].vlan_port_vid);
+	 }
+
+	len += sprintf(page + len, "wan_port_enabled: %d, wan_port_tag: %d, wan_port_vid: %d\n", hw_vlan_info[1].vlan_port_enabled, hw_vlan_info[1].vlan_port_tag, hw_vlan_info[1].vlan_port_vid);
+
+	if (len <= off+count) *eof = 1;
+        *start = page + off;
+        len -= off;
+        if (len>count)
+                len = count;
+        if (len<0)
+                len = 0;
+        return len;
+}
+
+
+static int32 rtl_hw_vlan_support_write( struct file *filp, const char *buff,unsigned long len, void *data )
+{
+        char tmpbuf[100];
+        int lan_portmask = 0;
+        int num=0 ;
+	 int i=0;
+	 int j=0;
+	 int bridge_num = 0;
+	 struct net_device *dev;
+	 struct dev_priv	  *dp;
+
+        if (buff && !copy_from_user(tmpbuf, buff, len))
+        {
+		num = sscanf(tmpbuf, "%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d",
+			&rtl_hw_vlan_enable, &hw_vlan_info[1].vlan_port_enabled, &hw_vlan_info[1].vlan_port_tag, &hw_vlan_info[1].vlan_port_vid,
+			&hw_vlan_info[0].vlan_port_enabled, &hw_vlan_info[0].vlan_port_bridge, &hw_vlan_info[0].vlan_port_tag, &hw_vlan_info[0].vlan_port_vid,
+			&hw_vlan_info[2].vlan_port_enabled, &hw_vlan_info[2].vlan_port_bridge, &hw_vlan_info[2].vlan_port_tag, &hw_vlan_info[2].vlan_port_vid,
+			&hw_vlan_info[3].vlan_port_enabled, &hw_vlan_info[3].vlan_port_bridge, &hw_vlan_info[3].vlan_port_tag, &hw_vlan_info[3].vlan_port_vid,
+			&hw_vlan_info[4].vlan_port_enabled, &hw_vlan_info[4].vlan_port_bridge, &hw_vlan_info[4].vlan_port_tag, &hw_vlan_info[4].vlan_port_vid
+			);
+
+               if (num !=  20) {
+                    printk("invalid rtl_hw_vlan_support_write parameter!\n");
+                    return len;
+               }
+
+		rtl_config_rtkVlan_vlanconfig(rtl865x_curOpMode);
+
+		/*get rid of port who bridge with wan from RTL_LANPORT_MASK*/
+	       if(rtl_hw_vlan_enable && (rtl865x_curOpMode == GATEWAY_MODE))
+	       {
+	            lan_portmask =  RTL_LANPORT_MASK;
+
+			if((hw_vlan_info[0].vlan_port_enabled == 1)&&(hw_vlan_info[0].vlan_port_bridge == 1))
+				lan_portmask &= ~RTL_LANPORT_MASK_4;  //port0 is bridge, so port0 need to get out of lan_port_mask
+			if((hw_vlan_info[2].vlan_port_enabled == 1)&&(hw_vlan_info[2].vlan_port_bridge == 1))
+				lan_portmask &= ~RTL_LANPORT_MASK_3;
+			if((hw_vlan_info[3].vlan_port_enabled == 1)&&(hw_vlan_info[3].vlan_port_bridge == 1))
+				lan_portmask &= ~RTL_LANPORT_MASK_2;
+			if((hw_vlan_info[4].vlan_port_enabled == 1)&&(hw_vlan_info[4].vlan_port_bridge == 1))
+				lan_portmask &= ~RTL_LANPORT_MASK_1;
+
+	            vlanconfig[0].memPort = lan_portmask;
+	            vlanconfig[0].vid= RTL_LANVLANID;
+	            vlanconfig[0].untagSet = lan_portmask;
+	            ((struct dev_priv *)_rtl86xx_dev.dev[0]->priv)->portmask = lan_portmask; //eth0
+	            ((struct dev_priv *)_rtl86xx_dev.dev[0]->priv)->id = RTL_LANVLANID;
+
+	            vlanconfig[1].vid = hw_vlan_info[1].vlan_port_vid;
+	            vlanconfig[1].memPort = RTL_WANPORT_MASK;
+	            vlanconfig[1].untagSet = 0; // need tag
+	            ((struct dev_priv *)_rtl86xx_dev.dev[1]->priv)->portmask = RTL_WANPORT_MASK; //eth1
+	            ((struct dev_priv *)_rtl86xx_dev.dev[1]->priv)->id = hw_vlan_info[1].vlan_port_vid; //eth1
+
+			for(i=0; i<PORT_NUMBER; i++)
+			{
+				if(i==1)	/*bypass eth1*/
+					continue;
+
+				if((hw_vlan_info[i].vlan_port_enabled == 1)&&(hw_vlan_info[i].vlan_port_bridge == 1))
+				{
+					if(i == 0)
+					{
+						vlanconfig[2+bridge_num].memPort = 1<<i;
+						vlanconfig[2+bridge_num].vid = hw_vlan_info[i].vlan_port_vid;
+						vlanconfig[2+bridge_num].untagSet = 1<<i;
+						((struct dev_priv *)_rtl86xx_dev.dev[2+bridge_num]->priv)->portmask = 1<<i;
+						((struct dev_priv *)_rtl86xx_dev.dev[2+bridge_num]->priv)->id = hw_vlan_info[i].vlan_port_vid;
+						bridge_num ++;
+					}else{
+						vlanconfig[2+bridge_num].memPort = 1<<(i-1);
+						vlanconfig[2+bridge_num].vid = hw_vlan_info[i].vlan_port_vid;
+						vlanconfig[2+bridge_num].untagSet = 1<<(i-1);
+						((struct dev_priv *)_rtl86xx_dev.dev[2+bridge_num]->priv)->portmask = 1<<(i-1);
+						((struct dev_priv *)_rtl86xx_dev.dev[2+bridge_num]->priv)->id = hw_vlan_info[i].vlan_port_vid;
+						bridge_num ++;
+					}
+				}
+			}
+			//PPPOE
+			   vlanconfig[5].vid = hw_vlan_info[1].vlan_port_vid;
+	        }
+
+
+		re865x_packVlanConfig(vlanconfig, packedVlanConfig);
+
+		rtl_reinit_hw_table();
+		reinit_vlan_configure(packedVlanConfig);
+
+		//unknow vlan drop
+		//REG32(SWTCR0) &= ~(1 << 15);
+
+		/*update dev port number*/
+		for(i=0; vlanconfig[i].vid != 0; i++)
+		{
+			if (IF_ETHER!=vlanconfig[i].if_type)
+			{
+				continue;
+			}
+
+			dev=_rtl86xx_dev.dev[i];
+			dp = dev->priv;
+			dp->portnum  = 0;
+			for(j=0;j<RTL8651_AGGREGATOR_NUMBER;j++)
+			{
+				if(dp->portmask & (1<<j))
+					dp->portnum++;
+			}
+
+		}
+
+		#if defined (CONFIG_RTL_IGMP_SNOOPING)
+			re865x_reInitIgmpSetting(rtl865x_curOpMode);
+		#if defined (CONFIG_RTL_MLD_SNOOPING)
+			if(mldSnoopEnabled && (rtk_vlan_support_enable==0))
+			{
+				re865x_packVlanConfig(vlanconfig, packedVlanConfig);
+				rtl865x_addAclForMldSnooping(packedVlanConfig);
+			}
+		#endif
+		#endif
+
+		//always init the default route...
+		if(rtl8651_getAsicOperationLayer() >2)
+		{
+			rtl865x_addRoute(0,0,0,RTL_DRV_WAN0_NETIF_NAME,0);
+		}
+
+               rtl8651_setAsicMulticastEnable(TRUE);
+        }
+        return len;
+}
 
 
-static int read_proc_vlan(char *page, char **start, off_t off,
-        int count, int *eof, void *data)
+static int32 rtl_hw_vlan_tagged_bridge_multicast_read( char *page, char **start, off_t off, int count, int *eof, void *data )
 {
+	int len;
+	len = sprintf(page, "%s %d\n", "rtl_hw_vlan_tagged_mc:",rtl_hw_vlan_ignore_tagged_mc);
 
-    struct net_device *dev = (struct net_device *)data;
-    struct dev_priv *cp;
-    int len;
 
-	cp = dev->priv;
-    len = sprintf(page, "gvlan=%d, lan=%d, vlan=%d, tag=%d, vid=%d, priority=%d, cfi=%d\n",
-		cp->vlan_setting.global_vlan, cp->vlan_setting.is_lan, cp->vlan_setting.vlan, cp->vlan_setting.tag,
-		cp->vlan_setting.id, cp->vlan_setting.pri, cp->vlan_setting.cfi);
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count)
+		len = count;
+	if (len<0)
+	  	len = 0;
 
-    if (len <= off+count)
-        *eof = 1;
-    *start = page + off;
-    len -= off;
-    if (len > count)
-        len = count;
-    if (len < 0)
-        len = 0;
-    return len;
+	return len;
 }
 
-static int write_proc_vlan(struct file *file, const char *buffer,
-              unsigned long count, void *data)
+static int32 rtl_hw_vlan_tagged_bridge_multicast_write( struct file *filp, const char *buff,unsigned long len, void *data )
 {
-	struct net_device *dev = (struct net_device *)data;
-	struct dev_priv *cp;
-	#define	VLAN_MAX_INPUT_LEN	128
-	char *tmp;
-
-	tmp = kmalloc(VLAN_MAX_INPUT_LEN, GFP_KERNEL);
-	if (count < 2 || tmp==NULL)
-		goto out;
-
-	cp = dev->priv;
-	if(rtk_vlan_support_enable == 0)
-		goto out;
+	char 		tmpbuf[32];
 
-	if (buffer && !copy_from_user(tmp, buffer, VLAN_MAX_INPUT_LEN))
+	if (buff && !copy_from_user(tmpbuf, buff, len))
 	{
-		int num = sscanf(tmp, "%d %d %d %d %d %d %d",
-			&cp->vlan_setting.global_vlan, &cp->vlan_setting.is_lan,
-			&cp->vlan_setting.vlan, &cp->vlan_setting.tag,
-			&cp->vlan_setting.id, &cp->vlan_setting.pri,
-			&cp->vlan_setting.cfi);
+		tmpbuf[len] = '\0';
 
-		if (num !=  7) {
-			printk("invalid vlan parameter!\n");
-			goto out;
-		}
-		#if 0
-		printk("===%s(%d), cp->name(%s),global_vlan(%d),is_lan(%d),vlan(%d),tag(%d),id(%d),pri(%d),cfi(%d)",__FUNCTION__,__LINE__,
-			cp->dev->name,cp->vlan_setting.global_vlan,cp->vlan_setting.is_lan,cp->vlan_setting.vlan,cp->vlan_setting.tag,
-			cp->vlan_setting.id,cp->vlan_setting.pri,cp->vlan_setting.cfi);
-		printk("-------------%s(%d),cp->portmask(%d)\n",__FUNCTION__,__LINE__,cp->portmask);
-		#endif
+		rtl_hw_vlan_ignore_tagged_mc = tmpbuf[0] - '0';
 	}
-out:
-	if(tmp)
-		kfree(tmp);
-
-	return count;
+	return len;
 }
-#endif // CONFIG_RTK_VLAN_SUPPORT
+
+
+#endif
+
 
 #if (defined(CONFIG_RTL_CUSTOM_PASSTHRU) && !defined(CONFIG_RTL8196_RTL8366))
 
@@ -7819,7 +9698,7 @@ void __exit rtl8651_exitStormCtrl(void)
 
 #endif
 
-#if defined(CONFIG_RTL_8198)
+#if defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 static int32 proc_phyTest_read( char *page, char **start, off_t off, int count, int *eof, void *data )
 {
 	return 0;
@@ -8173,7 +10052,7 @@ int32 rtl8651_initMldSnooping(void)
 void __exit rtl8651_exitMldSnoopingCtrl(void)
 {
 	if (mldSnoopingProc) {
-		remove_proc_entry("mldSnooping", mldSnoopingProc);
+		remove_proc_entry("br_mldsnoop", mldSnoopingProc);
 		mldSnoopingProc = NULL;
 	}
 }
@@ -8563,6 +10442,7 @@ static int rtl_regist_multipleWan_dev(void)
 #endif
 
 	dev->irq = 0;
+	memcpy((char*)dev->name,rtl_multiWan_config.ifname,MAX_IFNAMESIZE);
 	rc = register_netdev(dev);
 	if(!rc){
 		rtl_multiWan_net_dev = dev;
@@ -8639,6 +10519,100 @@ static int rtl_config_multipleWan_netif(int32 cmd)
 
 	return retval;
 }
+
+static int rtl865x_addMultiCastNetif(void)
+{
+	rtl865x_netif_t netif;
+	int ret=FAILED;
+
+	rtl865x_delVlan(MULTICAST_NETIF_VLAN_ID);
+	rtl865x_addVlan(MULTICAST_NETIF_VLAN_ID);
+	ret=rtl865x_addVlanPortMember(MULTICAST_NETIF_VLAN_ID, rtl_multiWan_config.memPort);
+	ret=rtl865x_setVlanFilterDatabase(MULTICAST_NETIF_VLAN_ID, rtl_multiWan_config.fid);
+
+	if(_rtl865x_getNetifByName(multiCastNetIf)!=NULL)
+	{
+		return SUCCESS;
+	}
+
+	memset(&netif, 0, sizeof(rtl865x_netif_t));
+	strcpy(netif.name, multiCastNetIf);
+	memcpy(&netif.macAddr, multiCastNetIfMac, 6);
+	netif.mtu = 1500;
+	netif.if_type = IF_ETHER;
+	netif.vid = MULTICAST_NETIF_VLAN_ID;
+	netif.is_wan = 1;
+	netif.is_slave = 0;
+	netif.enableRoute=1;
+	netif.forMacBasedMCast=TRUE;
+	//printk("%s:%d,entry->lpNetif is %s \n",__FUNCTION__,__LINE__,entry->lpNetif);
+	ret = rtl865x_addNetif(&netif);
+	if(ret!=SUCCESS)
+	{
+		rtl865x_delVlan(MULTICAST_NETIF_VLAN_ID);
+		return FAILED;
+	}
+
+#if defined(CONFIG_RTK_VLAN_SUPPORT)
+	{
+		rtl865x_AclRule_t	rule;
+		bzero((void*)&rule,sizeof(rtl865x_AclRule_t));
+		rule.ruleType_ = RTL865X_ACL_MAC;
+		rule.pktOpApp_ = RTL865X_ACL_ALL_LAYER;
+		rule.actionType_ = RTL865X_ACL_PERMIT;
+		ret=rtl865x_add_acl(&rule, multiCastNetIf, RTL865X_ACL_SYSTEM_USED);
+	}
+#endif
+
+	return ret;
+}
+
+#if 0
+static int rtl865x_delMultiCastNetif(void)
+{
+	int ret=FAILED;
+
+#if defined(CONFIG_RTK_VLAN_SUPPORT)
+	{
+		rtl865x_AclRule_t	rule;
+		bzero((void*)&rule,sizeof(rtl865x_AclRule_t));
+		rule.ruleType_ = RTL865X_ACL_MAC;
+		rule.pktOpApp_ = RTL865X_ACL_ALL_LAYER;
+		rule.actionType_ = RTL865X_ACL_PERMIT;
+		ret=rtl865x_del_acl(&rule, multiCastNetIf, RTL865X_ACL_SYSTEM_USED);
+	}
+#endif
+
+	ret=rtl865x_delNetif(multiCastNetIf);
+
+	if(ret==SUCCESS)
+	{
+		ret=rtl865x_delVlan(MULTICAST_NETIF_VLAN_ID);
+	}
+	return ret;
+
+}
+
+int rtl865x_setMultiCastSrcMac(unsigned char *srcMac)
+{
+
+	if(srcMac==NULL)
+	{
+		return FAILED;
+	}
+
+	memcpy(multiCastNetIfMac, srcMac, 6);
+
+	if(_rtl865x_getNetifByName(multiCastNetIf)!=NULL)
+	{
+		rtl865x_delMCastNetif();
+		rtl865x_addMCastNetif();
+	}
+
+	return SUCCESS;
+}
+#endif
+
 #endif
 
 
@@ -8651,19 +10625,7 @@ int  re865x_reProbe (void)
 	local_irq_save(flags);
 	//WRITE_MEM32(PIN_MUX_SEL_2, 0x7<<21);
 	/*Initial ASIC table*/
-
-#ifdef CONFIG_RTL8198_REVISION_B
- 	if (REG32(BSP_REVR) >= BSP_RTL8198_REVISION_B)
-	{
-	  	REG32(SYS_CLK_MAG)&=(~(SYS_SW_RESET));
-		mdelay(300);
-		REG32(SYS_CLK_MAG)|=(SYS_SW_RESET);
-		mdelay(100);
-
-	}
-	else
-#endif
-		FullAndSemiReset();
+	FullAndSemiReset();
 
 	memset(&para, 0, sizeof(rtl8651_tblAsic_InitPara_t));
 
@@ -8682,6 +10644,7 @@ int  re865x_reProbe (void)
 
 
 	/*init PHY LED style*/
+#if !defined(CONFIG_RTL_819XD) && !defined(CONFIG_RTL_8196E)
 #if defined(CONFIG_RTL865X_BICOLOR_LED)
 	#ifdef BICOLOR_LED_VENDOR_BXXX
 	REG32(LEDCR) |= (1 << 19); // 5 ledmode set to 1 for bi-color LED
@@ -8703,6 +10666,7 @@ int  re865x_reProbe (void)
 	WRITE_MEM32(TCR0, 0x000002C7); //8651 demo board default: 15 LED boards
 	WRITE_MEM32(SWTACR, CMD_FORCE | ACTION_START); // force add
 #endif /* CONFIG_RTL865X_BICOLOR_LED */
+#endif
 
 /*2007-12-19*/
 #if defined(CONFIG_RTK_VLAN_SUPPORT)
@@ -8842,5 +10806,226 @@ void __exit rtl865x_destroyReInitResetSwitchCore(void)
 
 #endif
 
+#ifdef CONFIG_RTK_VOIP_PORT_LINK
+static int rtnl_fill_ifinfo_voip(struct sk_buff *skb, struct net_device *dev,
+                            int type, u32 pid, u32 seq, u32 change,
+                            unsigned int flags)
+{
+        struct ifinfomsg *ifm;
+        struct nlmsghdr *nlh;
+
+        nlh = nlmsg_put(skb, pid, seq, type, sizeof(*ifm), flags);
+        if (nlh == NULL)
+                return -ENOBUFS;
+
+        ifm = nlmsg_data(nlh);
+        ifm->ifi_family = AF_UNSPEC;
+        ifm->__ifi_pad = 0;
+        ifm->ifi_type = dev->type;
+        ifm->ifi_index = dev->ifindex;
+        ifm->ifi_flags = dev_get_flags(dev);
+        ifm->ifi_change = change;
+        return nlmsg_end(skb, nlh);
+}
+static void rtmsg_ifinfo_voip(int type, struct net_device *dev, unsigned change)
+{
+        struct net *net = dev_net(dev);
+        struct sk_buff *skb;
+        int err = -ENOBUFS;
+
+        skb = nlmsg_new(NLMSG_GOODSIZE, GFP_ATOMIC);
+        if (skb == NULL)
+                goto errout;
+
+        err = rtnl_fill_ifinfo_voip(skb, dev, type, 0, 0, change, 0);
+        if (err < 0) {
+                /* -EMSGSIZE implies BUG in if_nlmsg_size() */
+                WARN_ON(err == -EMSGSIZE);
+                kfree_skb(skb);
+                goto errout;
+        }
+        rtnl_notify(skb, net, 0, RTNLGRP_LINK, NULL, GFP_ATOMIC);
+        return;
+errout:
+        if (err < 0)
+                rtnl_set_sk_err(net, RTNLGRP_LINK, err);
+}
+#endif
+
+
+#if defined (CONFIG_RTL_SOCK_DEBUG)
+static struct proc_dir_entry *rtl865x_sockDebugProc=NULL;
+extern int dumpRawSockInfo(void);
+extern int dumpUdpSockInfo(void);
+extern int dumpTcpSockInfo(void);
+static int rtl865x_sockDebugReadProc(char *page, char **start, off_t off,
+		     int count, int *eof, void *data)
+{
+	int len=0;
+	len = 0;
+
+	if (len <= off+count)
+		*eof = 1;
+
+	*start = page + off;
+	len -= off;
+
+	if (len>count)
+		len = count;
+
+	if (len<0) len = 0;
+
+	return len;
+}
+
+static int rtl865x_sockDebugWriteProc(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+	char tmpBuf[256];
+	char		*strptr;
+	char		*tokptr;
+	unsigned int tmp;
+
+	if (buffer && !copy_from_user(tmpBuf, buffer, count))
+	{
+		tmpBuf[count-1]=0;
+		strptr=tmpBuf;
+
+		tokptr = strsep(&strptr," ");
+		if (tokptr==NULL)
+		{
+			goto errOut;
+		}
+
+		//printk("here to reset switch core\n");
+		tmp=simple_strtol(tokptr, NULL, 0);
+		if(tmp==1)
+		{
+			dumpRawSockInfo();
+			dumpUdpSockInfo();
+			dumpTcpSockInfo();
+
+		}
+
+
+		return count;
+	}
+
+errOut:
+	return -EFAULT;
+}
+
+
+int  rtl865x_creatSockDebugProc(void)
+{
+	rtl865x_sockDebugProc = create_proc_entry("sockDebug", 0, NULL);
+	if(rtl865x_sockDebugProc)
+	{
+		rtl865x_sockDebugProc->read_proc = rtl865x_sockDebugReadProc;
+		rtl865x_sockDebugProc->write_proc = rtl865x_sockDebugWriteProc;
+	}
+
+	return 0;
+}
+
+void __exit rtl865x_removeSockDebugProc(void)
+{
+	if (rtl865x_sockDebugProc) {
+		remove_proc_entry("sockDebug", rtl865x_sockDebugProc);
+		rtl865x_sockDebugProc = NULL;
+	}
+}
+#endif
+
+#ifdef CONFIG_RTL_ULINKER
+void eth_led_recover(void)
+{
+	REG32(PIN_MUX_SEL_2) = REG32(PIN_MUX_SEL_2) & ~(0x00003000);
+}
+#endif
+
+extern int eee_enabled;
+#if defined(RTL8198_EEE_MAC)
+extern void eee_phy_enable_98(void);
+extern void eee_phy_disable_98(void);
+#endif
+
+static struct proc_dir_entry *res_eee=NULL;
+static int eee_read_proc(char *page, char **start, off_t off, int count, int *eof, void *data);
+static int eee_write_proc(struct file *file, const char *buffer, unsigned long count, void *data);
+
+static int32 rtl819x_eee_proc_init(void)
+{
+	res_eee = create_proc_entry("eee", 0, NULL);
+	if(res_eee)
+	{
+		res_eee->read_proc = eee_read_proc;
+		res_eee->write_proc = eee_write_proc;
+	}
+	return 0;
+}
+
+void __exit rtl819x_eee_proc_exit(void)
+{
+	if (res_eee) {
+		remove_proc_entry("eee", res_eee);
+		res_eee = NULL;
+	}
+}
+
+static int eee_read_proc(char *page, char **start, off_t off,
+		     int count, int *eof, void *data)
+{
+	int len=0;
 
+	len += sprintf(page+len, "eee %sabled.\n", ((eee_enabled) ? "en" : "dis")  );
+
+	if (len <= off+count)
+		*eof = 1;
+
+	*start = page + off;
+	len -= off;
+
+	if (len>count)
+		len = count;
+
+	if (len<0) len = 0;
+
+	return len;
+}
+
+static int eee_write_proc(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+	char tmpBuf[32];
+
+	if (buffer && !copy_from_user(tmpBuf, buffer, count))
+	{
+#if defined(RTL8198_EEE_MAC)
+		if (tmpBuf[0] == '0') {
+			eee_enabled = FALSE;
+			eee_phy_disable_98();
+		}
+		else if (tmpBuf[0] == '1') {
+			eee_enabled = TRUE;
+			eee_phy_enable_98();
+		}
+#endif
+
+#if defined(RTL8196C_EEE_MAC)
+		if (tmpBuf[0] == '0') {
+			eee_enabled = FALSE;
+			REG32(EEECR) = 0;
+			//eee_phy_disable();
+		}
+		else if (tmpBuf[0] == '1') {
+			eee_enabled = TRUE;
+			REG32(EEECR) = 0x28318c63;
+			//eee_phy_enable();
+		}
+#endif
+		return count;
+	}
+	return -EFAULT;
+}
 
diff --git a/drivers/net/wireless/rtl8192cd/8192c_reg.h b/drivers/net/wireless/rtl8192cd/8192c_reg.h
index 3767ae1..a525eb7 100644
--- a/drivers/net/wireless/rtl8192cd/8192c_reg.h
+++ b/drivers/net/wireless/rtl8192cd/8192c_reg.h
@@ -1,2329 +1,2332 @@
-/*
- *  Header file of 8192C register
- *
- *	 $Id: 8192c_reg.h,v 1.7.2.2 2010/09/20 09:00:10 button Exp $
- *
- *  Copyright (c) 2009 Realtek Semiconductor Corp.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
- */
-
-#ifndef _8192C_REG_H_
-#define _8192C_REG_H_
-
-//============================================================
-//       8192C Regsiter offset definition
-//============================================================
-
-
-//
-// MAC register 0x000 - 0x6AFh
-// 1. System Configure Register. (Offset 0x000 - 0x0FFh)
-// 2. MACTOP General Configuration. (Offset 0x100 - 0x1FFh)
-//		General Purpose Timer. (Offset 0x150 - 0x16Fh)
-// 3. TXDMA/RXDMA Configuration. (Offset 0x200 - 0x2FFh)
-// 4. PCIE EMAC Reserved Region. (Offset 0x300 - 0x3FFh)
-// 5. PTCL/EDCA Configuration. (Offset 0x400 - 0x4FFh)
-// 6. WMAC Configuration. (Offset 0x600 - 0x7FFh)
-// 		MACID Setting Register. (Offset 0x610 - 0x62Fh)
-// 		Timing Control Register. (Offset 0x630 - 0x64Fh)
-// 		WMAC, BA, CCX Related Register. (Offset 0x650 - 0x66Fh)
-// 		Security Control Register. (Offset 0x670 - 0x68Fh)
-// 		Power Save Control Register. (Offset 0x690 - 0x69Fh)
-// 		General Purpose Register. (Offset 0x6A0 - 0x6AFh)
-//
-
-
-//
-// 1. System Configure Register. (Offset 0x000 - 0x0FFh)
-//
-#define		SYS_ISO_CTRL		0x000	// System Isolation Interface Control.
-#define		SYS_FUNC_EN		0x002	// System Function Enable.
-#define		APS_FSMCO			0x004	// Auto Power Sequence Control/Option.
-#define		SYS_CLKR			0x008	// System Clock.
-#define		CR9346				0x00A	// 93C46 (93C56) Command.
-#define		EE_VPD				0x00C	// EEPROM VPD Data.
-#define		AFE_MISC			0x010	// AFE Misc.
-#define		SPS0_CTRL			0x011	// Switching Power Supply 0 Control.
-#define		SPS_OCP_CFG		0x018	// SPS Over Current Protection Configuration.
-#define		RSV_CTRL0			0x01C	// Reserved Control.
-#define		RF_CTRL				0x01F	// RF Block Control.
-#define		LDOA15_CTRL		0x020	// V15 Digital LDO Control.
-#define		LDOV12D_CTRL		0x021	// V12 Digital LDO Control.
-#define		LDOHCI12_CTRL		0x022	// V12 Digital LDO Control.
-#define		LPLDO_CTRL			0x023	// Low Power LDO Control.
-#define		AFE_XTAL_CTRL		0x024	// AFE Crystal Control.
-#define		AFE_PLL_CTRL		0x028	// AFE_PLL_CTRL Enable.
-#define		RSV_CTRL1			0x02C	// Reserved Control.
-#define		EFUSE_CTRL			0x030	// E-Fuse Control.
-#define		EFUSE_TEST			0x034	// E-Fuse Test Control.
-#define		PWR_DATA			0x038	// Power on Data.
-#define		CAL_TIMER			0x03C	// Hardware Calibration Timer.
-#define		ACLK_MON			0x03E	// Analog Clock Monitor.
-#define		GPIO_MUXCFG		0x040	// GPIO_MUX Configuration.
-#define		GPIO_PIN_CTRL		0x044	// GPIO[7:0] PIN Control.
-#define		GPIO_INTM			0x048	// GPIO Interrupt Monitor Register.
-#define		LEDCFG				0x04C	// System PINMUX Configuration.
-#define		FSIMR				0x050	// Firmware System Interrupt Mask.
-#define		FSISR				0x054	// Firmware System Interrupt Status.
-
-#define		MCUFWDL			0x080	// MCU Firmware Down Load Control.
-#define		MCUTSTCFG			0x084	// MCU Firmware Test Configuration.
-#define		MCUDMSG_I			0x088	// MCU Firmware Debug Message.
-#define		MCUDMSG_II			0x08C	// MCU Firmware Debug Message.
-
-#define		BIST_CTRL			0x0D0  	// BIST/SCAN CONTROL
-#define		C_BIST_RPT			0x0D4  	// BIST Report
-#define		BIST_ROM_RPT		0x0D8  	// BIST ROM Report
-#define		USB_SIE_INTF		0x0E0  	// USB SIE Access Interface
-#define		PCIE_MIO_INTF		0x0E4  	// PCIE MIO Access Interface
-#define		PCIE_MIO_INTD		0x0E8	// PCIE MIO Access Interface DATA.
-#define		HPON_FSM			0x0EC	// Power On FSM Monitor/Control.
-#define		SYS_CFG			0x0F0	// System Configuration Status
-
-
-//
-// 2. MACTOP General Configuration. (Offset 0x100 - 0x1FFh)
-//
-#define		CR					0x100  // Command Register.
-#define		PBP					0x104  // Packet Buffer Page.
-#define		TRXDMA_CTRL		0x10C  // TRXDMA Control.
-#define		TRXFF_BNDY			0x114  // TX/RX FIFO Boundary
-#define		TRXFF_STATUS		0x118  // PKTFF Status
-#define		RXFF_PTR			0x11C  // RXFF Write/Read Pointer
-#define		HIMR				0x120  // Host Interrupt Mask.
-#define		HISR				0x124  // Host Interrupt Status.
-#define		HIMRE				0x128  // Host Interrupt Mask Extension.
-#define		HISRE				0x12C  // Host Interrupt Status Extension.
-#define		CPWM				0x12F  // Current Power Mode.
-#define		FWIMR				0x130  // Firmware WLAN Interrupt Mask.
-#define		FWISR				0x134  // Firmware WLAN Interrupt Status.
-#define		FTIMR				0x138  // Firmware Timer Interrupt Mask.
-#define		FTISR				0x13C  // Firmware Timer Interrupt Status.
-#define		PKTBUF_DBG_CTRL	0x140  // TX/RX Packet Buffer Debug Control.
-#define		PKTBUF_DBG_DATA_L	0x144  // TX/RX Packet Buffer Debug Data.
-#define		PKTBUF_DBG_DATA_H	0x148  // TX/RX Packet Buffer Debug Data.
-//		General Purpose Timer. (Offset 0x150 - 0x16Fh)
-#define		TC0_CTRL			0x150  // Timer/Counter 0 Control.
-#define		TC1_CTRL			0x154  // Timer/Counter 1 Control.
-#define		TC2_CTRL			0x158  // Timer/Counter 2 Control.
-#define		TC3_CTRL			0x15C  // Timer/Counter 3 Control.
-#define		TC4_CTRL			0x160	// Timer/Counter 4 Control.
-#define		TCUNIT_BASE		0x164	// Timer/Counter Unit Base.
-//		General Purpose Timer. (Offset 0x150 - 0x16Fh)
-#define		MBIST_START		0x174	// MACTOP BIST START Pulse.
-#define		MBIST_DONE			0x178	// MACTOP BIST DONE.
-#define		MBIST_FAIL			0x17C	// MACTOP BIST FAIL.
-
-#define		MCUTST_I			0x1C0	// MCU Firmware TST-I.
-#define		MCUTST_II			0x1C4	// MCU Firmware TST-II.
-#define		FMETHR				0x1C8	// Firmware Message Exchange to Host.
-#define		HMETFR				0x1CC	// Host Message Interrupt to Firmware.
-#define		HMEBOX_0	 		0x1D0	// Host Message BOX_0 to Firmware.
-#define		HMEBOX_1			0x1D4	// Host Message BOX_1 to Firmware.
-#define		HMEBOX_2			0x1D8	// Host Message BOX_2 to Firmware.
-#define		HMEBOX_3			0x1DC	// Host Message BOX_3 to Firmware.
-#define		LLT_INI				0x1E0	// LLT Entries Initial Indirect Access Control.
-#define		BB_ACCEESS_CTRL	0x1E8	// BB Indirect Access Control.
-#define		BB_ACCESS_DATA	0x1EC	// BaseBand Indirect Access Data.
-#define		MREG_HCIDBG		0x1F0	// MAC REG for HCI debug.
-#define		MREG_CPUDBG		0x1F4	// MAC REG for CPU debug.
-
-
-//
-// 3. TXDMA/RXDMA Configuration. (Offset 0x200 - 0x2FFh)
-//
-#define		RQPN				0x200	// Reserved Queue Page Number.
-#define		FIFOPAGE			0x204	// Available FIFO Page Number.
-#define		TDECTRL			0x208	// Tx DMA Engine Control.
-#define		TXDMA_OFFSET_CHK	0x20C	// TXDMA Offset Check.
-#define		TXDMA_STATUS		0x210	// TXDMA Status.
-#define		RQPN_NPQ			0x214	// RQPN for Normal Queue Register
-
-#define		RXDMA_AGG_PG_TH	0x280	// RXDMA AGG PG Threshold.
-#define		RXPKT_NUM			0x284	// RX Packet Number.
-#define		RXDMA_STATUS		0x288	// RXDMA Status.
-
-
-//
-// 4. PCIE EMAC Reserved Region. (Offset 0x300 - 0x3FFh)
-//
-#define		PCIE_CTRL_REG		0x300	// PCIE DMA Control.
-#define		INT_MIG			0x304	// Interrupt Migration.
-#define		BCNQ_DESA			0x308	// TX Beacon Descriptor Address.
-#define		HQ_DESA			0x310	// TX High Queue Descriptor.
-#define		MGQ_DESA			0x318	// TX Manage Queue Descriptor Address.
-#define		VOQ_DESA			0x320	// TX VO Queue Descriptor Address.
-#define		VIQ_DESA			0x328	// TX VI Queue Descriptor Address.
-#define		BEQ_DESA			0x330	// TX BE Queue Descriptor Address.
-#define		BKQ_DESA			0x338	// TX BK Queue Descriptor Address.
-#define		RX_DESA			0x340	// RX Queue Descriptor Address.
-#define		DBI					0x348	// Backdoor REG for Access Configuration SPACE.
-#define		MDIO				0x354	// MDIO for Access PCIE PHY.
-#define		DBG_SEL			0x360	// Debug Selection
-#define		UART_CTRL			0x364	// UART Control.
-#define		UART_TX_DESA		0x370	// UART TX Descriptor Address.
-#define		UART_RX_DESA		0x378	// UART RX Descriptor Address.
-
-
-//
-// 5. PTCL/EDCA Configuration. (Offset 0x400 - 0x4FFh)
-//
-#define		VOQ_INFO			0x400	//
-#define		VIQ_INFO			0x404	//
-#define		BEQ_INFO			0x408	//
-#define		BKQ_INFO			0x40C	//
-#define		MGQ_INFO			0x410	//
-#define		HIQ_INFO			0x414	//
-#define		BCNQ_INFO			0x418	//
-#define		TXPKT_EMPTY		0x41B	// TXPKTBUF Packet Empty.
-#define		CPU_MGQ_INFO		0x41C	// TXPKTBUF Packet Empty.
-#define		FWHW_TXQ_CTRL	0x420	// FWHW TX Queue Control.
-#define		HWSEQ_CTRL		0x423	// HW Sequence Number Control.
-#define		TXPKTBUF_BCNQ_BDNY	0x424	// BCNQ Boundary.
-#define		TXPKTBUF_MGQ_BDNY	0x425	// MGQ Boundary.
-#define		MULTI_BCNQ_EN		0x426	//
-#define		MULTI_BCNQ_OFFSET		0x427	//
-#define		SPEC_SIFS_A		0x428	//
-#define		RL					0x42A	//
-#define		DARFRC				0x430	// Data Auto Rate Fallback Retry Count.
-#define		RARFRC				0x438	// Response Auto Rate Fallback Retry Count.
-#define		RRSR				0x440	// Response Rate Set.
-#define		ARFR0				0x444	// Data Auto Rate Fallback 0.
-#define		ARFR1				0x448	// Auto Rate Fallback 1.
-#define		ARFR2				0x44C	// Auto Rate Fallback 2.
-#define		ARFR3				0x450	// Auto Rate Fallback 3.
-#define		AGGLEN_LMT		0x458	// Aggregation Length.
-#define		AMPDU_MIN_SPACE	0x45C	// AMPDU Min Space.
-#define		FAST_EDCA_CTRL	0x460	// Fast EDCA Mode.
-#define		RD_RESP_PKT_TH	0x463	// RD Responder Packet Threshold.
-#define		INIRTS_RATE_SEL	0x480	// Initial RTS Rate SEL.
-#define		INIDATA_RATE_SEL	0x484	// Initial Data Rate SEL.
-#define		POWER_STATUS		0x4A4	// POWER STATUS.
-#define		POWER_STAGE1		0x4B4	// POWER STAGE1.
-#define		POWER_STAGE2		0x4B8	// POWER STAGE2.---------------???
-#define		PKT_LIFE_TIME		0x4C0	// PKT LIFT TIME.
-#define		STBC_SETTING		0x4C4	// STBC.
-#define		PROT_MODE_CTRL	0x4C8	// PROTECT MODE Control.
-#define		BAR_MODE_CTRL		0x4CC	// BAR MODE Control.
-#define		RA_TRY_RATE_AGG_LMT	0x4CF	// Rate Adaptive Try Rate Aggregation Limit.
-#define		NQOS_SEQ			0x4DC	// Non-QoS SEQ Number.
-#define		QOS_SEQ			0x4DE	// QoS SEQ Number.
-#define		NEED_CPU_HANDLE	0x4E0	// Need CPU Handle.
-#define		PTCL_ERR_STATUS	0x4E1	// Protocol Function Error Status.
-#define		PKT_LOSE_RPT		0x4E2	// PKT Lose Report.
-#define		Dummy				0x4FC	// Dummy.
-
-#define		EDCA_VO_PARA		0x500	// EDCA Parameter.
-#define		EDCA_VI_PARA		0x504	// EDCA Parameter.
-#define		EDCA_BE_PARA		0x508	// EDCA Parameter.
-#define		EDCA_BK_PARA		0x50C	// EDCA Parameter.
-#define		BCNTCFG			0x510	// Beacon Time Configuration.
-#define		PIFS				0x512	// PIFS.
-#define		RDG_PIFS			0x513	// RDG PIFS.
-#define		SIFS_CCK			0x514	// SIFS for CCK.
-#define		SIFS_OFDM			0x516	// SIFS for OFDM.
-#define		AGGR_BK_TIME		0x51A	// AGGR BREAK TIME.
-#define		SLOT_TIME			0x51B	// Slot Time.
-#define		TX_PTCL_CTRL		0x520	// TX Protocol Control.
-#define		TXPAUSE			0x522	// Transmission Pause.
-#define		DIS_TXREQ_CLR		0x523	// Disable TX Request Clear Function.
-#define		RD_CTRL			0x524	// RD Control.
-#define		TBTT_PROHIBIT		0x540	// TBTT Prohibit.
-#define		RD_NAV_NXT		0x544	// RD NAV Protect Next Time.
-#define		NAV_PROT_LEN		0x546	// NAV Protection Length.
-#define		BCN_CTRL			0x550	// Bcnq Control.
-#define		USTIME_TSF			0x551	// US Time Tuning for TSF.
-#define		MBID_NUM			0x552	// MBSSID Beacon Number.
-#define		MBSSID_BCN_SPACE	0x554	// MBSSID Beacon Space.
-#define		DRVERLYINT			0x558	// Beacon Driver Early Interrupt.
-#define		BCNDMATIM			0x559	// BCN DMA and ATIM INT Time.-----------------???
-#define		ATIMWND			0x55A	// ATIM Window Time.
-#define		BCN_MAX_ERR		0x55D	// BCN MAX ERROR.
-#define		RXTSF_OFFSET_CCK	0x55E	// CCK BCN OFFSET.
-#define		RXTSF_OFFSET_OFDM	0x55F	// OFDM BCN OFFSET.
-#define		TSFTR				0x560	// TSF Timer.
-#define		INIT_TSFTR			0x564	// TSF Timer Initial Value.
-#define		PSTIMER			0x580	// PS TIMER and Timeout INT.
-#define		TIMER0				0x584	// TIMER0 INT.
-#define		TIMER1				0x588	// TIMER1 INT.
-#define		ACMHWCTRL			0x5C0	// ACM HW Control.
-#define		ACMRSTCTRL			0x5C1	// ACM RST.
-#define		ACMAVG				0x5C2	// ACM Average.
-#define		VO_ADMTIME		0x5C4	// VO Admission Time.
-#define		VI_ADMTIME			0x5C6	// VI Admission Time.
-#define		BE_ADMTIME		0x5C8	// BE Admission Time.
-#define		EDCA_RANDOM_GEN	0x5CC	// EDCA Random Number Generator.
-#define		C_SCH_TXCMD		0x5D0	// TX_CMD.
-#define		NOA_PARAM			0x5E0	// P2P NoA Parameter
-
-
-//
-// 6. WMAC Configuration. (Offset 0x600 - 0x7FFh)
-//
-#define		APSD_CTRL			0x600	// APSD Control.
-#define		BWOPMODE			0x603	// BW Operation Mode.
-#define		TCR					0x604	// Transmission Configuration.
-#define		RCR					0x608	// Receive Configuration.
-#define		RX_PKT_LIMIT		0x60C	// RX Packet Length Limit.
-#define		RX_DLK_TIME		0x60D	// RX Deadlock Time.
-#define		RX_DRVINFO_SZ		0x60F	// RX Driver INFO Size Register.
-//		MACID Setting Register. (Offset 0x610 - 0x62Fh)
-#define		MACID				0x610	// MAC ID.
-#define		BSSIDR				0x618	// BSSID.
-#define		MAR					0x620	// Multicast Address.
-#define		MBIDCAMCFG		0x628	// MBSSID CAM Configuration.
-//		MACID Setting Register. (Offset 0x610 - 0x62Fh)
-
-//		Timing Control Register. (Offset 0x630 - 0x64Fh)
-#define		USTIME_EDCA		0x638	// US Time Tuning for EDCA.
-#define		SPEC_SIFS_B		0x63A	// Specification SIFS.
-#define		RESP_SIFS_CCK		0x63C	// Response SIFS for CCK.
-#define		RESP_SIFS_OFDM	0x63E	// Response SIFS for OFDM.
-#define		ACKTO				0x640	// ACK Timeout.
-#define		CTS2TO				0x641	// CTS2 Timeout.
-#define		EIFS				0x642	// EIFS.
-//		Timing Control Register. (Offset 0x630 - 0x64Fh)
-
-//		WMAC, BA, CCX Related Register. (Offset 0x650 - 0x66Fh)
-#define		NAV_CTRL			0x650	// NAV Control.
-#define		BACAMCMD			0x654	// Block ACK CAM Command.
-#define		BACAMCONTENT 		0x658	// Block ACK CAM Content.
-#define		LBDLY		 		0x660	// Loopback Delay.
-#define		FWDLY		 		0x661	// FW Delay.
-#define		RXERR_RPT	 		0x664	// RX Error Report.
-#define		WMAC_TRXPTCL_CTL	0x668	// WMAC TX/RX Protocol Control.
-//		WMAC, BA, CCX Related Register. (Offset 0x650 - 0x66Fh)
-
-//		Security Control Register. (Offset 0x670 - 0x68Fh)
-#define		CAMCMD				0x670	// CAM Command.
-#define		CAMWRITE			0x674	// CAM Write.
-#define		CAMREAD			0x678	// CAM Read.
-#define		CAMDBG				0x67C	// CAM Debug.
-#define		SECCFG				0x680	// Security Configuration.
-//		Security Control Register. (Offset 0x670 - 0x68Fh)
-
-//		Power Save Control Register. (Offset 0x690 - 0x69Fh)
-#define		WOW_CTRL			0x690	// Wake On WLAN Control.
-#define		PSSTATUS			0x691	// Power Save Status.
-#define		PS_RX_INFO			0x692	// Power Save RX Information.
-#define		LPNAV_CTRL			0x694	// Low Power NAV Control.
-#define		WKFMCAM_CMD		0x698	// Wakeup Frame CAM Command.
-#define		WKFMCAM_RWD		0x69C	// Wakeup Frame Read/Write Data.
-//		Power Save Control Register. (Offset 0x690 - 0x69Fh)
-
-//		General Purpose Register. (Offset 0x6A0 - 0x6AFh)
-#define		RXFLTMAP0			0x6A0	// RX Filter Map Group 0.
-#define		RXFLTMAP1			0x6A2	// RX Filter Map Group 1.
-#define		RXFLTMAP2			0x6A4	// RX Filter Map Group 2.
-#define		BCN_PSR_RPT		0x6A8	// Beacon Parser Report.
-#define		CALB32K_CTRL		0x6AC	// Calibration 32K Control.
-//		General Purpose Register. (Offset 0x6A0 - 0x6AFh)
-#define		PKT_MON_CTRL		0x6B4	// Packet Monitor Control.
-#define		BT_COEX_TABLE		0x6C0	// BT-Coexistence Control.
-#define		WMAC_RESP_TXINFO	0x6D8	// Response TXINFO.
-
-
-//============================================================================
-//       8192C Regsiter Bit and Content definition
-//============================================================================
-
-
-//
-// 1. System Configure Register. (Offset 0x000 - 0x0FFh)
-//
-//----------------------------------------------------------------------------
-//       8192C SYS_ISO_CTRL bits				(Offset 0x0, 16bit)
-//----------------------------------------------------------------------------
-#define		PWC_EV12V			BIT(15)	// Power Cut for eFuse 1.2V, 1: Power valid; 0: Power invalid.
-#define		PWC_EV25V			BIT(14)	// Power Cut for eFuse 2.5V, 1: force PSW open; 0: PSW turn on by efuse ctrl.
-#define		ISO_DIOR			BIT(9)	// RF Digital I/O to Power On, 1: isolation; 0: attach.
-#define		ISO_EB2CORE		BIT(8)	// eFuse cell output to Power On, 1: isolation; 0: attach.
-#define		ISO_DIOE			BIT(7)	// Extra Digital I/O to Power On, 1: isolation; 0: attach.
-#define		ISO_DIOP			BIT(6)	// PCIe Digital I/O to Power On, 1: isolation; 0: attach.
-#define		ISO_IP2MAC			BIT(5)	// Analog Ips to Digital 1.2V, 1: isolation; 0: attach (no used).
-#define		ISO_PD2CORE		BIT(4)	// PCIe Digital 1.2V to Power On/Core 1.2V, 1: isolation; 0: attach.
-#define		ISO_PA2PCIE		BIT(3)	// PCIe Analog 1.2V to PCIe 3.3V and Digital 1.2V, 1: isolation; 0: attach.
-#define		ISO_UD2CORE		BIT(2)	// USB Digital 1.2V to Power On/Core 1.2V, 1: isolation; 0: attach.
-#define		ISO_UA2USB			BIT(1)	// USB Analog 1.2V to USB 3.3V and Digital 1.2V, 1: isolation; 0: attach.
-#define		ISO_MD2PP			BIT(0)	// MACTOP/BB/PCIe Digital to Power On, 1: isolation; 0: attach.
-
-//----------------------------------------------------------------------------
-//       8192C SYS_FUNC_EN bits					(Offset 0x2, 16bit)
-//----------------------------------------------------------------------------
-#define		FEN_MREGEN		BIT(15)	// MAC I/O Registers Enable.
-#define		FEN_HWPDN			BIT(14)	// 0 : force All analog blocks shutdown, 1 : keep Analog Blocks alive.
-#define		FEN_DIO_RF			BIT(13)	// Enable RF Digital I/O.
-#define		FEN_ELDR			BIT(12)	// Enable EEPROM Loader (Loader POR).
-#define		FEN_DCORE			BIT(11)	// enable Core Digital (MACTOP POR).
-#define		FEN_CPUEN			BIT(10)	// Enable MCU Core (CPU RST).
-#define		FEN_DIOE			BIT(9)	// Extra Debug I/O PAD Enable.
-#define		FEN_PCIED			BIT(8)	// enable PCIe eMAC.
-#define		FEN_PPLL			BIT(7)	// Enable PCIe PHY_PLL (no used).
-#define		FEN_PCIEA			BIT(6)	// Enable PCIe PHY.
-#define		FEN_DIO_PCIE		BIT(5)	// Enable PCIe Digital I/O (no used).
-#define		FEN_USBD			BIT(4)	// Enable USB_SIE.
-#define		FEN_UPLL			BIT(3)	// Enable USB PHY_PLL (no used).
-#define		FEN_USBA			BIT(2)	// Enable USB PHY.
-#define		FEN_BB_GLB_RST	BIT(1)	// When this bit is set to "0", whole BB is reset. When this bit is set, BB is enabled.
-#define		FEN_BBRSTB			BIT(0)	// When this bit is set to "0", CCK and OFDM are disabled,
-										// and clock are gated. Otherwise, CCK and OFDM are enabled.
-
-//----------------------------------------------------------------------------
-//       8192C APS_FSMCO bits					(Offset 0x4, 32bit)
-//----------------------------------------------------------------------------
-#define		XOP_BTCK			BIT(31)	// BT Option for never turn off XTAL & SPS.
-#define		SOP_A8M			BIT(30)	// Suspend option not to turn analog Clock Mode to 500K Hz, 1: keep 8M, 0: 500K.
-#define		SOP_RCK			BIT(29)	// Suspend option not to turn off Hreg Clock (8M/500KHz), 1: clock on, 0: clock off.
-#define		SOP_AMB			BIT(28)	// Suspend option not to turn off AFE MB, 1: MB on, 0: MB off.
-#define		SOP_ABG			BIT(27)	// Suspend option not to turn off AFE BG, 1: BG on, 0: BG off.
-#define		SOP_FUSE			BIT(26)	// Suspend option to turn off Efuse Power or reset Loader, 1: Fuse Pwr Off, 0: Fuse Pwr On.
-#define		SOP_MRST			BIT(25)	// Suspend option not to turn off MAC Reset, 1: MAC not reset, 0: MaC reset.
-#define		SOP_CRST			BIT(24)	// Susoend option not to turn off 8051 clock, 1: 8051 clock on, 0:8051 clock off.
-#define		ROP_SPS			BIT(22)	// Resume option to skip turn On SPS.
-#define		ROP_PWR			BIT(21)	// Resume option to skip wait Power Ready, 1: pwr up no delay, 0: wait pwr stable.
-#define		ROP_ALD			BIT(20)	// Resume option to skip autoload, 1: not autoload, 0: autoload.
-#define		OP_SWRST			BIT(19)	// Option for Software Reset to Reset 8051.
-#define		SUS_HOST			BIT(17)	// Power FSM turn to HOST SUS.
-#define		RDY_MACON			BIT(16)	// Power FSM turn all power, clock ready for MAC.
-#define		APDM_HPDN			BIT(15)	// Auto Power Down to CHIP-off State (Power-Down).
-#define		APDM_HOST			BIT(14)	// Auto Power Down to HOST-off State (Card-Disable).
-#define		APDM_MAC			BIT(13)	// Auto Power Down to WLAN-Off State (Radio-off).
-#define		AFSM_PCIE			BIT(12)	// When this bit is set, PCIE suspends via HW FSM control flow.
-#define		AFSM_HSUS			BIT(11)	// 1: Host Suspend through FSM operation; 0: Host Suspend by gated.
-#define		APFM_RSM			BIT(10)	// Auto Power On State Machine Resume, auto clear when EE load done.
-#define		APFM_OFF			BIT(9)	// Auto FSM to Turn Off, include clock, isolation, power control.
-#define		APFM_ONMAC		BIT(8)	// Auto FSM to Turn On, include clock, isolation, power control for MAC only.
-#define		BT_SUSEN			BIT(7)	// Enable BT suspend control.
-#define		RDY_MACDIS			BIT(6)	// Disable MAC power Ready Output for Test Mode.
-#define		PDN_PL				BIT(5)	// PDn polarity control, 0: Low active, 1: High active.
-#define		PDN_EN				BIT(4)	// Enable GPIO-11 as Hardware PowerDown/Resume Source.
-#define		PFM_WOWL			BIT(3)	// Wake On Lan indicator for H/W FSM.
-#define		PFM_LDKP			BIT(2)	// Loader Initial data when re-enable loader.
-#define		PFM_ALDN			BIT(1)	// HCI Region load done, inform HCI block.
-#define		PFM_LDALL			BIT(0)	// EEPROM autoload 0x00~60h Enable.
-
-//----------------------------------------------------------------------------
-//       8192C SYS_CLKR bits					(Offset 0x8, 16bit)
-//----------------------------------------------------------------------------
-#define		RING_CLK_EN					BIT(13)	// HPON Ring Clock Enable, 1: Enable; 0 : Disable.
-#define		SYS_CLK_EN						BIT(12)	// MCU Clock Enable, 1: Enable; 0 : Disable.
-#define		MAC_CLK_EN						BIT(11)	// MAC Clock Enable, 1: Enable, 0 : Disable.
-#define		SEC_CLK_EN						BIT(10)	// SEC Clock Enable, 1 :Enable, 0 :Disable.
-#define		PHY_SSC_RSTB					BIT(9)	// PHY SSC Enable (0: Disable, 1: Enable).
-#define		CLKR_80M_SSC_EN_HOLD_PHS0	BIT(8)	// 80M Clock Hold phase 0.
-#define		CLKR_80M_SSC_DIS				BIT(7)	// 80M Clock SSC Disable.
-#define		LOADER_CLK_EN					BIT(5)	// Loader (eFuse/EEPROM) Clock Enable.
-#define		MACSLP							BIT(4)	// MAC SLEEP.
-#define		ROMD16V_EN					BIT(2)	// Analog Clock source Divide 16 Mode for EEPROM.
-#define		ANA8M							BIT(1)	// Analog Clock source rate, 1: 8M Hz, 0: 500K Hz.
-#define		CNTD16V_EN						BIT(0)	// Analog Clock source Divide 16 Mode for Hardware Timer.
-
-//----------------------------------------------------------------------------
-//       8192C CR9346 bits						(Offset 0xA, 16bit)
-//----------------------------------------------------------------------------
-#define		VPDIDX_SHIFT		8	// VPD mode, EEPROM Index.
-#define		VPDIDX_Mask		0x0FF
-#define		EEM1_0_SHIFT		6	// Operating Mode.
-#define		EEM1_0_Mask		0x03
-#define		EEPROM_EN			BIT(5)	// EEPROM/Efuse is found when set to 1.
-#define		EERPOMSEL			BIT(4)	// System EEPROM select (power on selected by GPIO-0).
-#define		EECS				BIT(3)	// reflect the state of the EECS.
-#define		EESK				BIT(2)	// reflect the state of the EESK.
-#define		EEDI				BIT(1)	// reflect the state of the EEDI.
-#define		EEDO				BIT(0)	// reflect the state of the EEDO.
-
-
-#ifdef EN_EFUSE
-#define		CmdEEPROM_En						BIT(5)	 // EEPROM enable when set 1
-#define		CmdEERPOMSEL						BIT(4) // System EEPROM select, 0: boot from E-FUSE, 1: The EEPROM used is 9346
-#define		AutoLoadEEPROM						(CmdEEPROM_En|CmdEERPOMSEL)
-#define		AutoLoadEFUSE						CmdEEPROM_En
-
-
-#ifdef CONFIG_RTL_92C_SUPPORT
-
-#define EEPROM_TxPowerCCK			0x5A // CCK Tx Power base
-#define	EEPROM_TxPowerHT40_1S		0x60 // HT40 Tx Power base
-#define	EEPROM_TxPowerHT40_2SDiff	0x66 // HT40 Tx Power diff
-#define EEPROM_TxPowerHT20Diff		0x69 // HT20 Tx Power diff
-#define EEPROM_TxPowerOFDMDiff		0x6C // OFDM Tx Power diff
-#define EEPROM_MACADDRESS			0x16 // OFDM Tx Power diff
-#define EEPROM_THERMAL_METER		0x78 //[4:0]
-#endif
-
-#endif
-
-
-//----------------------------------------------------------------------------
-//       8192S AFE_MISC bits						(Offset 0x10, 8bits)
-//----------------------------------------------------------------------------
-#define		MAC_ID_EN			BIT(7)	// Reserved for RF_ID selection to be MAC.
-#define		AFE_MBEN			BIT(1)	// Enable AFE Macro Block's Mbias.
-#define		AFE_BGEN			BIT(0)	// Enable AFE Macro Block's Bandgap.
-
-//----------------------------------------------------------------------------
-//       8192C SPS0_CTRL bits					(Offset 0x11-17, 56bits)
-//----------------------------------------------------------------------------
-#define		SW18_LDO_R			BIT(19)	// LDO_R_L1 = 1 => LDO resistor connect.
-#define		SW18_V15ADJ_SHIFT		16	// v15adj_L1<2:0>  output.
-#define		SW18_V15ADJ_Mask		0x07
-#define		SW18_VOL_SHIFT		12	// VOL_L1<3:0>  output.
-#define		SW18_VOL_Mask			0x0F
-#define		SW18_IN_SHIFT			9	// IN_L1<2:0> output.
-#define		SW18_IN_Mask			0x07
-#define		SW18_TBOX_SHIFT		7	// TBOC_L1<1:0> output.
-#define		SW18_TBOX_Mask		0x03
-#define		SW18_SET_DELAY		BIT(6)	// SET_DELAY_L1=1=> nonoverlap delay increases.
-#define		SW18_SEL				BIT(5)	// SD_L1 = 1 => turn off quickly.
-#define		SW18_STD_SHIFT		3	// STD_L1<1:0> time.
-#define		SW18_STD_Mask			0x03
-#define		SW18_SD				BIT(2)	// SD_L1 = 1 => turn off quickly.
-#define		SW18_AREN				BIT(1)	// 3.3->1.8 for PFM  Anti-ring.
-#define		SW18_R3_B1			BIT(0)	//
-
-#define		SW18_R3_B0			BIT(31)	//
-#define		SW18_R2_SHIFT			29	//
-#define		SW18_R2_Mask			0x03
-#define		SW18_R1_SHIFT			27	//
-#define		SW18_R1_Mask			0x03
-#define		SW18_C3_SHIFT			25	//
-#define		SW18_C3_Mask			0x03
-#define		SW18_C2_SHIFT			23	//
-#define		SW18_C2_Mask			0x03
-#define		SW18_C1_SHIFT			21	//
-#define		SW18_C1_Mask			0x03
-#define		SW18_SCREF_SHIFT		19	// For FDUAL, tune reference frequency.
-#define		SW18_SCREF_Mask		0x03
-#define		SW18_SCPFM_SHIFT		17	// For FDUAL, tune pfm frequency.
-#define		SW18_SCPFM_Mask		0x03
-#define		SW18_PWFMTUNE_SHIFT	14	//
-#define		SW18_PWFMTUNE_Mask	0x07
-#define		SW18_SELSTOP			BIT(13)	// SEL_STOP_L1 = 0 => no delay.
-#define		SW18_SELD_SHIFT		11	// Bit(1)=1 enable clamp maximum duty, bit(0)=1 enable clamp minimum duty
-#define		SW18_SELD_Mask		0x03
-#define		SW18_POWOCP			BIT(10)	// POWOCP_L1=1=> enable over current protection.
-#define		SW18_OCP_SHIFT		7	//
-#define		SW18_OCP_Mask			0x07
-#define		SW18_SFREQ_SHIFT		5	//
-#define		SW18_SFREQ_Mask		0x03
-#define		SW18_SFREQC			BIT(4)	//
-#define		SW18_FPWM				BIT(3)	// FPWM_L1 = 1 => force PWM, FPWM_L1 = 0 => force PFM.
-#define		SW18_FDUAL			BIT(2)	// FDUAL_L1 =1 => PWM or PFM.
-#define		SW18_SWEN				BIT(1)	// Enable VSPS18_SW Macro Block.
-#define		SW18_LDEN				BIT(0)	// Enable VSPS18_LDO Macro Block.
-
-//----------------------------------------------------------------------------
-//       8192C SPS_OCP_CFG bits					(Offset 0x18-1B, 32bits)
-//----------------------------------------------------------------------------
-#define		SPS18_OCP_DIS			BIT(31)	// sps18 ocp, 0:enable, 1:disable.
-#define		SPS18_OCP_TH_SHIFT	16	// Sps18 ocp threshold.
-#define		SPS18_OCP_TH_Mask		0x07FFF
-#define		OCP_WINDOW_SHIFT		0	// Ocp monitor window width configure, count on ana_clk/16.
-#define		OCP_WINDOW_Mask		0x0FFFF
-
-//----------------------------------------------------------------------------
-//       8192C RSV_CTRL0 bits					(Offset 0x1C-1E, 24bits)
-//----------------------------------------------------------------------------
-#define		HREG_DBG_SHIFT	8	// HREG Access Debug.
-#define		HREG_DBG_Mask		0x0FFFF
-#define		LOCK_ALL_EN		BIT(7)	// 1:Enable 'Locked All' setting by Hardware, 0: Hardware Enable 'Locked All' denied.
-#define		R_DIS_PRST_1		BIT(6)	// Control if PERST can reset MACCORE.
-#define		R_DIS_PRST_0		BIT(5)	// Control if PERST can reset MACCORE.
-#define		WLOCK_40			BIT(4)	// 1:Register Write Locked, 0: Register Accessible by SW/FW.
-#define		WLOCK_08			BIT(3)	// 1:Register Write Locked, 0: Register Accessible by SW/FW.
-#define		WLOCK_04			BIT(2)	// 1:Register Write Locked, 0: Register Accessible by SW/FW.
-#define		WLOCK_00			BIT(1)	// 1:Register Write Locked, 0: Register Accessible by SW/FW.
-#define		WLOCK_ALL			BIT(0)	// 1:Register Write Locked, 0: Register Accessible by SW/FW.
-
-//----------------------------------------------------------------------------
-//       8192C RF_CTRL bits						(Offset 0x1F, 8bits)
-//----------------------------------------------------------------------------
-#define		RF_SDMRSTB			BIT(2)	// Reset RF SDM Module (low active).
-#define		RF_RSTB			BIT(1)	// Reset RF Module (low active).
-#define		RF_EN				BIT(0)	// Enable RF Module.
-
-//----------------------------------------------------------------------------
-//       8192C LDOA15_CTRL bits					(Offset 0x20, 8bits)
-//----------------------------------------------------------------------------
-#define		LDA15_VOADJ_SHIFT	4	//
-#define		LDA15_VOADJ_Mask	0x0F
-#define		LDA15_STBY			BIT(3)	// LDOA15 Standby Mode.
-#define		LDA15_OBUF			BIT(2)	// LDOA15 Output Buffered.
-#define		REG_VOS			BIT(1)	// LDOA15 Add Offset voltage.
-#define		LDA15_EN			BIT(0)	// Enable LDOA15 Macro Block.
-
-//----------------------------------------------------------------------------
-//       8192C LDOV12D_CTRL bits				(Offset 0x21, 8bits)
-//----------------------------------------------------------------------------
-#define		LDV12_VADJ_SHIFT	4	// LDOVD12 voltage adjust.
-#define		LDV12_VADJ_Mask	0x0F
-#define		LDV12_BUFO			BIT(2)	// LDOVD12 buffer output Mode.
-#define		LDV12_SDBY			BIT(1)	// LDOVD12 standby mode.
-#define		LDV12_EN			BIT(0)	// Enable LDOA12 Macro Block.
-
-//----------------------------------------------------------------------------
-//       8192C LDOHCI12_CTRL bits				(Offset 0x22, 8bits)
-//----------------------------------------------------------------------------
-#define		LDH12_SDBY			BIT(5)	// LDOHCI12 standby mode.
-#define		LDH12_OBUF			BIT(4)	// Enable LDOHCI12 Macro Block.
-#define		LDH12_VADJ_SHIFT	1	// LDOHCI12 voltage adjust.
-#define		LDH12_VADJ_Mask	0x07
-#define		LDH12_EN			BIT(0)	// Enable LDOHCI12 Macro Block.
-
-//----------------------------------------------------------------------------
-//       8192C LPLDO_CTRL bits					(Offset 0x23, 8bits)
-//----------------------------------------------------------------------------
-#define		LPLDH12_SLP			BIT(4)	// LPLDOH12 Sleep Mode.
-#define		LPLDH12_VADJ_SHIFT	0	// LPLDOH12 voltage adjust.
-#define		LPLDH12_VADJ_Mask		0x0F
-
-//----------------------------------------------------------------------------
-//       8192C AFE_XTAL_CTRL bits				(Offset 0x24-27, 32bits)
-//----------------------------------------------------------------------------
-#define		CKDLY_BT				BIT(29)	// Delay time of CLK_BT relate to CLK_DIG, 0: long time, 1: short time.
-#define		CKDLY_DIG				BIT(28)	// Delay time of CLK_DIG relate to CLK_AFE, 0: long time, 1: short time.
-#define		CKDLY_USB				BIT(27)	// Delay time of CLK_USB relate to CLK_AFE, 0: long time, 1: short time.
-#define		CKDLY_AFE				BIT(26)	// Delay time of CLK_AFE relate to CLK_RF, 0: long time, 1: short time.
-#define		XTAL_GPIO_SHIFT		23	//
-#define		XTAL_GPIO_Mask		0x07
-#define		XTAL_BT_DRV_SHIFT		21	// BT clock source Driving current: 11:most current, 00: less current.
-#define		XTAL_BT_DRV_Mask		0x03
-#define		XTAL_BT_GATE			BIT(20)	// Gated control: 1: BT Clock source gated, 0: clock enable (auto setting by trap data).
-#define		XTAL_DIG_DRV_SHIFT	18	// DIG clock source 11:most current, 00: less current.
-#define		XTAL_DIG_DRV_Mask		0x03
-#define		XTAL_GATE_DIG			BIT(17)	// Gated control:1: DIG Clock source gated, 0: clock enable.
-#define		XTAL_RF_DRV_SHIFT		15	// RF PLL Driving current: 11:most current, 00: less current.
-#define		XTAL_RF_DRV_Mask		0x03
-#define		XTAL_RF_GATE			BIT(14)	// Gated control: 1: RF Clock source gated, 0: clock enable.
-#define		XTAL_AFE_DRV_SHIFT	12	// AFE PLL Driving current: 11:most current, 00: less current.
-#define		XTAL_AFE_DRV_Mask		0x03
-#define		XTAL_GATE_AFE			BIT(11)	// Gated control:1: USB Clock source gated, 0: clock enable.
-#define		XTAL_USB_DRV_SHIFT	9	// USB PLL Driving current: 11:most current, 00: less current.
-#define		XTAL_USB_DRV_Mask		0x03
-#define		XTAL_GATE_USB			BIT(8)	// Gated control:1: USB Clock source gated, 0: clock enable.
-#define		XTAL_CADJ_XI_SHIFT	4	// 1:add cap, 0:degrade cap.
-#define		XTAL_CADJ_XI_Mask		0x0F
-#define		XTAL_BOSC_SHIFT		2	// The bias current control of VCO block.
-#define		XTAL_BOSC_Mask		0x03
-#define		XTAL_BSEL				BIT(1)	// 1: schmitt trigger, 0:nand.
-#define		XTAL_EN				BIT(0)	// Enable XTAL Macro block.
-
-//----------------------------------------------------------------------------
-//       8192C AFE_PLL_CTRL bits					(Offset 0x28-2B, 32bits)
-//----------------------------------------------------------------------------
-#define		AFE_DUMMY_SHIFT		25	// Dummy Registers.
-#define		AFE_DUMMY_Mask		0x07
-#define		APLL_1MEN				BIT(24)	// 1:Enable 0:output "1".
-#define		APLL_40DRV_SHIFT		22	// clk diving 00: weak 11:strong.
-#define		APLL_40DRV_Mask		0x03
-#define		APLL_PLLDRV_SHIFT		20	// clk diving 00: weak 11:strong.
-#define		APLL_PLLDRV_Mask		0x03
-#define		APLL_88DRV_SHIFT		18	// clk diving 00: weak 11:strong.
-#define		APLL_88DRV_Mask		0x03
-#define		APLL_80DRV_SHIFT		16	// clk diving 00: weak 11:strong.
-#define		APLL_80DRV_Mask		0x03
-#define		APLL_80EN				BIT(15)	// 1:Enable 0:output "1".
-#define		APLL_320EN				BIT(14)	// 1:Enable 0:output "1".
-#define		APLL_320BIAS_SHIFT	11	// pll320 CP current selection.
-#define		APLL_320BIAS_Mask		0x07
-#define		APLL_BIAS_SHIFT		8	// pll CP current selection.
-#define		APLL_BIAS_Mask			0x07
-#define		APLL_KVCO_SHIFT		6	// pll VCO KVCO selection.
-#define		APLL_KVCO_Mask		0x03
-#define		APLL_LPFEN				BIT(5)	// enable PLL Bias Current LPF.
-#define		APLL_WDOGB			BIT(4)	// enable watch dog 0: enable 1:disable.
-#define		APLL_EDGE_SEL			BIT(3)	// Reference clock: 1 : negative edge, 0 : positive edge.
-#define		APLL_FREF_SEL			BIT(2)	// Reference clock: 1 : 20MHz, 0 : 40MHz.
-#define		APLL_320_EN			BIT(1)	// Enable AFE 320 PLL Macro Block.
-#define		APLL_EN				BIT(0)	// Enable AFE PLL Macro Block.
-
-//----------------------------------------------------------------------------
-//       8192C EFUSE_CTRL bits					(Offset 0x30-33, 32bits)
-//----------------------------------------------------------------------------
-#define		EF_FLAG			BIT(31)	// Access Flag. Write "1" for Program; Write "0" for Read Access.
-#define		EF_PGPD_SHIFT		28	// E-fuse program time.
-#define		EF_PGPD_Mask		0x07
-#define		EF_RDT_SHIFT		24	// E-fuse read time: in the unit of cycle time.
-#define		EF_RDT_Mask		0x0F
-#define		EF_PGT_SHIFT		20	// Programming setup time. In the unit of cycle time.(125ns).
-#define		EF_PGT_Mask		0x0F
-#define		EF_PD				BIT(19)	// Efuse power down.
-#define		ALD_EN				BIT(18)	// Autoload Enable.
-#define		EF_ADDR_SHIFT		8	// Access Address.
-#define		EF_ADDR_Mask		0x03FF
-#define		EF_DATA_SHIFT		0	// Access Data.
-#define		EF_DATA_Mask		0x0FF
-
-//----------------------------------------------------------------------------
-//       8192C EFUSE_TEST bits					(Offset 0x34-37, 32bits)
-//----------------------------------------------------------------------------
-#define		LDOE25_EN			BIT(31)	// Enable LDOE25 Macro Block.
-#define		LDOE25_VADJ_SHIFT	28	// LDOE25 voltage adjust.
-#define		LDOE25_VADJ_Mask	0x07
-#define		ADDR_END_Shift		25	// 92D_REG, Scan effuse end (1023-addr_end)
-#define		ADDR_END_Mask		0x07
-#define		ADDR_STR_Shift		18	// 92D_REG, Scan efuse from (addr_str*8)
-#define		ADDR_STR_Mask		0x07F
-#define		BYTE_CNT_EN		BIT(17)	// 92D_REG, 1: scan efuse in byte; 0: scan efuse in bit
-#define		EF_SCAN_EN			BIT(16)	// 92D_REG, 1: efuse in scan process. 0: not in scan process
-#define		EDATA1_SHIFT		8	// EEPROM offset 1 data (EE Byte-1).
-#define		EDATA1_Mask		0x0FF
-#define		EF_TRPT			BIT(7)	// Test Scan Report: 1 : Fail, 0 : OK.
-#define		EF_TTHD_SHIFT		0	// Bit number for all cells scan test.
-#define		EF_TTHD_Mask		0x07F
-
-//----------------------------------------------------------------------------
-//       8192C PWR_DATA bits					(Offset 0x38-3B, 32bits)
-//----------------------------------------------------------------------------
-#define		EDATA0_SHIFT		24	// EEPROM offset 0 data (EE Byte-0).
-#define		EDATA0_Mask		0x0FF
-#define		HTEST_SEL_SHIFT	16	// TEST Mode Select (EE Byte-7).
-#define		HTEST_SEL_Mask	0x0FF
-#define		HPON_STBP2_SHIFT	8	// HPON Stable time parameter (EE Byte-5).
-#define		HPON_STBP2_Mask	0x0FF
-#define		HPON_STBP1_SHIFT	0	// HPON Stable time parameter (EE Byte-2).
-#define		HPON_STBP1_Mask	0x0FF
-
-//----------------------------------------------------------------------------
-//       8192C CAL_TIMER bits					(Offset 0x3C-3D, 16bits)
-//----------------------------------------------------------------------------
-#define		MATCH_CNT_SHIFT	8	// match counter for sleep mode.
-#define		MATCH_CNT_Mask	0x0FF
-#define		CAL_SCAL_SHIFT		0	// scaler fine tune for sleep mode (tune in Time unit).
-#define		CAL_SCAL_Mask		0x0FF
-
-//----------------------------------------------------------------------------
-//       8192C ACLK_MON bits					(Offset 0x3E-3F, 16bits)
-//----------------------------------------------------------------------------
-#define		RCLK_MON_SHIFT	5	// ring clock monitor (with DPSTU scale).
-#define		RCLK_MON_Mask		0x07FF
-#define		CAL_TIMER_EN		BIT(4)	// calibration timer enable. This shall be turned off before sleep mode enable.
-#define		DPSTU_SHIFT		2	// Deep Power Save Time Unit: 00: 64us, 01: 128us, 10: 192us, 11: 256 us.
-#define		DPSTU_Mask			0x03
-#define		SUS_16X			BIT(1)	// Scale timer 16x when suspend mode, (~250 S).
-#define		RSM_EN				BIT(0)	// When Timer Expired, Resume Hardware StateMachine.
-
-//----------------------------------------------------------------------------
-//       8192C GPIO_MUXCFG bits					(Offset 0x40-43, 32 bits)
-//----------------------------------------------------------------------------
-#define		GPIO_MOD_H_SHIFT		28	// When bit is zero, corresponding port configured to data port;
-										// otherwise, when a bit is set, and GPIO_IO_SEL is set to "0",
-										// then it is interrupt mode..
-#define		GPIO_MOD_H_Mask		0x0F
-#define		GPIO_IO_SEL_H_SHIFT	24	// GPIO_IO_SEL[11:8], output when bit=1;input when bit=0.
-#define		GPIO_IO_SEL_H_Mask	0x0F
-#define		GPIO_OUT_H_SHIFT		20	// GPIO_OUT[11:8], GPIO pins output value.
-#define		GPIO_OUT_H_Mask		0x0F
-#define		GPIO_IN_H_SHIFT		16	// GPIO_IN[11:8], GPIO pins input value.
-#define		GPIO_IN_H_Mask		0x0F
-#define		SIC_LBK					BIT(15)	// Enable SIC_Loop_Back Mode, (auto set by ICFG).
-#define		HTP_EN					BIT(14)   // 0 : Enable as Host Debug Port, 1 : Enable as Host Test Port.
-#define		SIC_23					BIT(13)   // Enable SIC at 0: GPIO 9,10 pins ; 1 : GPIO 2,3 pins.
-#define		SIC_EN					BIT(12)   // Enable GPIO Pins as SIC, (auto set by ICFG).
-#define		SIC_SWRST				BIT(11)	// 0 : Reset SIC by SW, prevent SIC Dead Lock.
-#define		PMAC_EN				BIT(10)	// PMAC Enable (auto set by ICFG).
-#define		UART_SEL				BIT(9)	// Enable UART at 0: GPIO 6,7 pins; 1 : GPIO 9,10 pins.
-#define		UART_EN				BIT(8)	// Enable GPIO Pins as UART.
-#define		BTMode_SHIFT			6	// Bluetooth Mode.
-#define		BTMode_Mask			0x03
-#define		BT_EN					BIT(5)	// Enable GPIO0,1,2,3,8 Pins for Bluetooth.
-#define		EROM_EN				BIT(4)	// Enable GPIO6 for EEDO, GPIO7 for EEDI, default Enable when 9346 selected
-#define		TRSW1EN				BIT(3)	// Enable GPIO9,10 for TRSWN1, TRSWP1.
-#define		TRSW0EN				BIT(2)	// Enable GPIO8 for TRSWN0.
-#define		GPIOSEL_SHIFT			0	// GPIO Select.
-#define		GPIOSEL_Mask			0x03
-
-//----------------------------------------------------------------------------
-//       8192C GPIO_PIN_CTRL bits				(Offset 0x44-47, 32 bits)
-//----------------------------------------------------------------------------
-#define		GPIO_MOD_L_SHIFT		24	// When bit is 0, corresponding port set as data port;
-										// otherwise, when a bit=1, and GPIO_IO_SEL is set to "0",
-										// then it is interrupt mode..
-#define		GPIO_MOD_L_Mask		0x0FF
-#define		GPIO_IO_SEL_L_SHIFT	16	// GPIO_IO_SEL[7:0], output when bit=1;input when bit=0.
-#define		GPIO_IO_SEL_L_Mask	0x0FF
-#define		GPIO_OUT_L_SHIFT		8	// GPIO_OUT[7:0], GPIO pins output value.
-#define		GPIO_OUT_L_Mask		0x0FF
-#define		GPIO_IN_L_SHIFT		0	// GPIO_IN[7:0], GPIO pins input value.
-#define		GPIO_IN_L_Mask			0x0FF
-
-//----------------------------------------------------------------------------
-//       8192C GPIO_INTM bits					(Offset 0x48-4B, 32 bits)
-//----------------------------------------------------------------------------
-#define		MDBG_SEL_SHIFT		30	//
-#define		MDBG_SEL_Mask			0x03
-#define		GPIO_EXT_WOL_SHIFT	12	// External WOL source control.
-#define		GPIO_EXT_WOL_Mask	0x0F
-#define		GPIOB_INT_MD			BIT(11)	// 0=positive edge, 1=negative edge,  is sensed as interrupt.
-#define		GPIOA_INT_MD			BIT(10)	// 0=positive edge, 1=negative edge,  is sensed as interrupt.
-#define		GPIO9_INT_MD			BIT(9)	// 0=positive edge, 1=negative edge,  is sensed as interrupt.
-#define		GPIO8_INT_MD			BIT(8)	// 0=positive edge, 1=negative edge,  is sensed as interrupt.
-#define		GPIO7_INT_MD			BIT(7)	// 0=positive edge, 1=negative edge,  is sensed as interrupt.
-#define		GPIO6_INT_MD			BIT(6)	// 0=positive edge, 1=negative edge,  is sensed as interrupt.
-#define		GPIO5_INT_MD			BIT(5)	// 0=positive edge, 1=negative edge,  is sensed as interrupt.
-#define		GPIO4_INT_MD			BIT(4)	// 0=positive edge, 1=negative edge,  is sensed as interrupt.
-#define		GPIO3_INT_MD			BIT(3)	// 0=positive edge, 1=negative edge,  is sensed as interrupt.
-#define		GPIO2_INT_MD			BIT(2)	// 0=positive edge, 1=negative edge,  is sensed as interrupt.
-#define		GPIO1_INT_MD			BIT(1)	// 0=positive edge, 1=negative edge,  is sensed as interrupt.
-#define		GPIO0_INT_MD			BIT(0)	// 0=positive edge, 1=negative edge,  is sensed as interrupt.
-
-//----------------------------------------------------------------------------
-//       8192C LEDCFG bits						(Offset 0x4C-4F, 32 bits)
-//----------------------------------------------------------------------------
-#define		GP8_LED			BIT(22)	// Enable GPIO-8 as LED2.
-#define		LED2EN				BIT(21)	// Enable GPIO-10/GPIO-8 as LED2.
-#define		LED2PL				BIT(20)	// LED2 polarity control.
-#define		LED2SV				BIT(19)	// LED2 software value.
-#define		LED2CM_SHIFT		16	// LED2 Control Mode.
-#define		LED2CM_Mask		0x07
-#define		LED1DIS				BIT(15)	// LED1 Disabled for analog signal usage,
-										// 1: disable (input mode), 0:Enable (output mode).
-#define		LED1PL				BIT(12)	// LED1 polarity control (auto-load configurable).
-#define		LED1SV				BIT(11)	// LED1 software value.
-#define		LED1CM_SHIFT		8	// LED1 Control Mode.
-#define		LED1CM_Mask		0x07
-#define		LED0DIS				BIT(7)	// LED1 Disabled for analog signal usage,
-										// 1: disable (input mode), 0:Enable (output mode).
-#define		LED0PL				BIT(4)	// LED0 polarity control (auto-load configurable).
-#define		LED0SV				BIT(3)	// LED0 software value.
-#define		LED0CM_SHIFT		0	// LED0 Control Mode.
-#define		LED0CM_Mask		0x07
-
-#define		LED_SW_CTRL			0
-#define		LED_OFF				1
-#define		LED_TX_RX_EVENT_ON	2
-#define		LED_TX_RX_EVENT_OFF	3
-#define		LED_TX_EVENT_ON		4
-#define		LED_TX_EVENT_OFF		5
-#define		LED_RX_EVENT_ON		6
-#define		LED_RX_EVENT_OFF		7
-
-//----------------------------------------------------------------------------
-//       8192C FSIMR bits						(Offset 0x50-53, 32 bits)
-//----------------------------------------------------------------------------
-#define		PDNINT_EN			BIT(31)	// Enable Hardware Power Down interrupt source.
-#define		SYS_TIMER_EN		BIT(30)	// Enable Hardware System Timer interrupt source.
-#define		SPS_OCP_INT_EN	BIT(29)	// Enable SPS OCP alarm interrupt source.
-#define		HPON_WRE_EN		BIT(28)	// Enable Continue access HPON registers interrupt source.
-#define		GPIOB_INT_EN		BIT(23)	// Enable GPIOB interrupt source.
-#define		GPIOA_INT_EN		BIT(22)	// Enable GPIOA interrupt source.
-#define		GPIO9_INT_EN		BIT(21)	// Enable GPIO9 interrupt source.
-#define		GPIO8_INT_EN		BIT(20)	// Enable GPIO8 interrupt source.
-#define		GPIO7_INT_EN		BIT(19)	// Enable GPIO7 interrupt source.
-#define		GPIO6_INT_EN		BIT(18)	// Enable GPIO6 interrupt source.
-#define		GPIO5_INT_EN		BIT(17)	// Enable GPIO5 interrupt source.
-#define		GPIO4_INT_EN		BIT(16)	// Enable GPIO4 interrupt source.
-#define		GPIO3_INT_EN		BIT(15)	// Enable GPIO3 interrupt source.
-#define		GPIO2_INT_EN		BIT(14)	// Enable GPIO2 interrupt source.
-#define		GPIO1_INT_EN		BIT(13)	// Enable GPIO1 interrupt source.
-#define		GPIO0_INT_EN		BIT(12)	// Enable GPIO0 interrupt source.
-
-//----------------------------------------------------------------------------
-//       8192C FSISR bits						(Offset 0x54-57, 32 bits)
-//----------------------------------------------------------------------------
-#define		PDNINT				BIT(31)	// Hardware Power Down interrupt.
-#define		HWSYS_TIMER_INT	BIT(30)	// Hardware System Timer interrupt.
-#define		SPS_OCP_INT		BIT(29)	// SPS OCP alarm interrupt.
-#define		HPON_WRE			BIT(28)	// Continue access HPON registers interrupt. Write 1 clear.
-#define		GPIOB_INT			BIT(23)	// GPIOB INT Status. Write 1 clear.
-#define		GPIOA_INT			BIT(22)	// GPIOA INT Status. Write 1 clear.
-#define		GPIO9_INT			BIT(21)	// GPIO9 INT Status. Write 1 clear.
-#define		GPIO8_INT			BIT(20)	// GPIO8 INT Status. Write 1 clear.
-#define		GPIO7_INT			BIT(19)	// GPIO7 INT Status. Write 1 clear.
-#define		GPIO6_INT			BIT(18)	// GPIO6 INT Status. Write 1 clear.
-#define		GPIO5_INT			BIT(17)	// GPIO5 INT Status. Write 1 clear.
-#define		GPIO4_INT			BIT(16)	// GPIO4 INT Status. Write 1 clear.
-#define		GPIO3_INT			BIT(15)	// GPIO3 INT Status. Write 1 clear.
-#define		GPIO2_INT			BIT(14)	// GPIO2 INT Status. Write 1 clear.
-#define		GPIO1_INT			BIT(13)	// GPIO1 INT Status. Write 1 clear.
-#define		GPIO0_INT			BIT(12)	// GPIO0 INT Status. Write 1 clear.
-
-//----------------------------------------------------------------------------
-//       8192C MCUFWDL bits						(Offset 0x80-83, 32 bits)
-//----------------------------------------------------------------------------
-#define		RPWM_SHIFT		24	// Host Request Power State.
-#define		RPWM_Mask			0x0FF
-#define		CPRST				BIT(23)	// 8051 Reset Status.
-#define		ROM_DLEN			BIT(19)	// ROM Download Enable (8051 Core will be reseted) FPGA only.
-#define		ROM_PGE_SHIFT		16	// ROM Page (FPGA only).
-#define		ROM_PGE_Mask		0x07
-#define		MAC1_RFINI_RDY	BIT(10)	// 92D_REG, MAC1 MCU Initial RF ready
-#define		MAC1_BBINI_RDY	BIT(9)	// 92D_REG, MAC1 MCU Initial BB ready
-#define		MAC1_MACINI_RDY	BIT(8)	// 92D_REG, MAC1 MCU Initial MAC ready
-#define		MCU_STATUS		BIT(7)	// 92D_REG, 1: SRAM, 0: ROM
-#define		WINTINI_RDY		BIT(6)	// WLAN Interrupt Initial ready.
-#define		MAC0_RFINI_RDY	BIT(5)	// MAC0 MCU Initial RF ready.
-#define		MAC0_BBINI_RDY	BIT(4)	// MAC0 MCU Initial BB ready.
-#define		MAC0_MACINI_RDY	BIT(3)	// MAC0 MCU Initial MAC ready.
-#define		FWDL_CHKSUM_RPT	BIT(2)	// FWDL CheckSum report, 1: OK, 0 : Faill.
-#define		MCUFWDL_RDY		BIT(1)	// Driver set this bit to notify MCU FW Download OK.
-#define		MCUFWDL_EN		BIT(0)	// MCU Firmware download enable. 1:Enable, 0:Disable.
-
-//----------------------------------------------------------------------------
-//       8192C MCUTSTCFG bits					(Offset 0x84-87, 32 bits)
-//----------------------------------------------------------------------------
-#define		LBKTST_SHIFT		0	// LBK TST indicator.
-#define		LBKTST_Mask		0x0FFFF
-
-//----------------------------------------------------------------------------
-//       8192C BIST_CTRL bits					(Offset 0xD0-D3, 32 bits)
-//----------------------------------------------------------------------------
-#define		BB_SPEED_SCAN		BIT(31)	// BB at speed scan mode Enable.
-#define		SCAN_PLL_BYPASS	BIT(30)	// 92D_REG
-#define		MBIST_RSTNI_Shift	8		// 92D_REG
-#define		MBIST_RSTNI_Mask	0x07FF
-#define		BIST_RESUME_PS	BIT(5)
-#define		BIST_RESUME		BIT(4)
-#define		BIST_DRF			BIT(3)	// 92D_REG
-#define		BIST_RETEN			BIT(3)
-#define		BIST_NORMAL		BIT(2)
-#define		BIST_RSTN			BIT(1)
-#define		BIST_CLK_EN		BIT(0)
-
-//----------------------------------------------------------------------------
-//       8192C C_BIST_RPT bits					(Offset 0xD4-D7, 32 bits)
-//----------------------------------------------------------------------------
-#define		C_MAC_BIST_FAIL			BIT(31)	// MAC_BIST_FAIL.
-#define		C_USB_IRAM_FAIL			BIT(26)	// USB IRAM BIST FAIL.
-#define		C_USB_RAM1_FAIL			BIT(25)	// USB RAM1 BIST FAIL.
-#define		C_USB_PROM_FAIL			BIT(24)	// USB PROM BIST FAIL.
-#define		C_PCIE_RETRY_BIST_FAIL	BIT(20)	// PCIE RETRY RAM BIST FAIL.
-#define		C_PCIE_SOT_BIST_FAIL		BIT(19)	// PCIE RETRY SOT RAM BIST FAIL.
-#define		C_PCIE_PH1_BIST_FAIL		BIT(18)	// PCIE PHDR RAM1 BIST FAIL.
-#define		C_PCIE_PH0_BIST_FAIL		BIT(17)	// PCIE PHDR RAM0 BIST FAIL.
-#define		C_PCIE_PD_BIST_FAIL		BIT(16)	// PCIE PDATA RAM BIST FAIL.
-#define		C_MAC_BIST_RDY			BIT(10)	// MAC MBIST Test report Ready.
-#define		C_USB_BIST_RDY			BIT(9)	// USB MBIST Test report Ready.
-#define		C_PCIE_BIST_RDY			BIT(8)	// PCIE MBIST Test report Ready.
-#define		C_MAC_BIST_START			BIT(2)	// MAC MBIST START PULSE.
-#define		C_USB_BIST_START			BIT(1)	// USB MBIST START PULSE.
-#define		C_PCIE_BIST_START			BIT(0)	// PCIE MBIST START PULSE.
-
-//----------------------------------------------------------------------------
-//       8192C USB_SIE_INTF bits					(Offset 0xE0-E3, 32 bits)
-//----------------------------------------------------------------------------
-#define		USB_SIE_INTF_WE			BIT(25)	// Write Enable of SIE interface.
-#define		USB_SIE_INTF_BYIOREG		BIT(24)	// SIE Bypass IOREG interface.
-#define		USB_SIE_INTF_ADDR_SHIFT	16	// The address of SIE register.
-#define		USB_SIE_INTF_ADDR_Mask	0x0FF
-#define		USB_SIE_INTF_RD_SHIFT		8	// The read data from USB SIE.
-#define		USB_SIE_INTF_RD_Mask		0x0FF
-#define		USB_SIE_INTF_WD_SHIFT	0	// The write data to USB SIE.
-#define		USB_SIE_INTF_WD_Mask		0x0FF
-
-//----------------------------------------------------------------------------
-//       8192C PCIE_MIO_INTF bits				(Offset 0xE4-E7, 32 bits)
-//----------------------------------------------------------------------------
-#define		PCIE_MIO_BYIOREG		BIT(13)	// MIO bypass IOREG interface.
-#define		PCIE_MIO_RE			BIT(12)	// Read Enable of MIO interface.
-#define		PCIE_MIO_WE_SHIFT		8	// Write Byte Enable of MIO interface.
-#define		PCIE_MIO_WE_Mask		0x0F
-#define		PCIE_MIO_ADDR_SHIFT	0	// The address of PCIE MIO Access register.
-#define		PCIE_MIO_ADDR_Mask	0x0FF
-
-//----------------------------------------------------------------------------
-//       8192C HPON_FSM bits					(Offset 0xEC-EF, 32 bits)
-//----------------------------------------------------------------------------
-#define		EVENT_FSM_SHIFT	16	// The State Machine Trigger Events.
-#define		EVENT_FSM_Mask	0x0FFFF
-#define		PMC_ADDR_SHIFT	8	// The Hardware Access HPON Register Addr.
-#define		PMC_ADDR_Mask		0x0FF
-#define		PMC_WR				BIT(7)	// The Hardware Access HPON Register Write Pulse.
-#define		PMC_DATA			BIT(6)	// The Hardware Access HPON Register Data.
-#define		FSM_STATE_SHIFT	0	// The State Machine Data.
-#define		FSM_STATE_Mask	0x03F
-
-//----------------------------------------------------------------------------
-//       8192C SYS_CFG bits					(Offset 0xF0-F3, 32 bits)
-//----------------------------------------------------------------------------
-#define		TRP_ICFG_SHIFT			28	// Trapped ICFG data value.
-#define		TRP_ICFG_Mask			0x0F
-#define		TYPE_ID					BIT(27)	// 1: 8191C/8192C ; 0: 8188C.
-#define		BD_HCI_SEL				BIT(26)	// Trapped HCI_SEL value.
-#define		BD_PKG_SEL				BIT(25)	// Trapped PKG_ENG_SEL value.
-#define		TRP_BT_EN				BIT(24)	// Trapped BT Chip Valid need XTAL & SPS resource.
-#define		TRP_VAUX_EN			BIT(23)	// Trapped VAUX_EN.
-#define		PAD_HWPD_IDN			BIT(22)	// HWPDN PAD status Indicator.
-#define		PSC_TESTCFG_SHIFT		20	// Test Pin configuration.
-#define		PSC_TESTCFG_Mask		0x03
-#define		CHIP_VER_RL_SHIFT		16	// Chip version (RL6111).
-#define		CHIP_VER_RL_Mask		0x0F
-#define		CHIP_VER_RTL_SHIFT	12	// Test Chip version - 8188C (RLE0307) / 8191C (RLE0308).
-#define		CHIP_VER_RTL_Mask		0x0F
-#define		IC_MACPHY_MODE		BIT(11)	// 0: IC Normal Mode, 1: force IC PHY_ASIC Mode.
-#define		BD_MAC1				BIT(10)	// Bonding option for MAC function-1 Enable.
-#define		BD_MAC2				BIT(9)	// Bonding option for MAC function-2 Enable.
-#define		SIC_IDLE				BIT(8)	// Indicator of SIC idle state.
-#define		TRP_B15V_EN			BIT(7)	// Trapped option for 1.5V of board.
-#define		OCP_SHUTDN			BIT(6)	// SPS OCP shutdown Chip.
-#define		V15_VLD				BIT(5)	// 1.5V Power Ready, 1: Power Ready.
-#define		PCIRSTB					BIT(4)	// PCIE External PERST, Pin Status.
-#define		PCLK_VLD				BIT(3)	// PCIE PHY Clock Stable, 1: Clock Stable.
-#define		UCLK_VLD				BIT(2)	// USB PHY Clock Stable, 1: Clock Stable.
-#define		ACLK_VLD				BIT(1)	// AFE Clock Stable, 1: Clock Stable.
-#define		XCLK_VLD				BIT(0)	// Xtal Clock Stable, 1: Clock Stable.
-
-
-//
-// 2. MACTOP General Configuration. (Offset 0x100 - 0x1FFh)
-//
-//----------------------------------------------------------------------------
-//       8192C CR bits						(Offset 0x100-103, 32 bits)
-//----------------------------------------------------------------------------
-#define		LBMODE_SHIFT		24	// Loopback mode.
-#define		LBMODE_Mask		0x0F
-#define		NETYPE_SHIFT		16	// Network Type.
-#define		NETYPE_Mask		0x03
-#define		MAC_SEC_EN		BIT(9)	// Enable MAC security engine.
-#define		ENSWBCN			BIT(8)	// Enable SW TX beacon.
-#define		MACRXEN			BIT(7)	// MAC Receiver Enable.
-#define		MACTXEN			BIT(6)	// MAC Transmitter Enable.
-#define		SCHEDULE_EN		BIT(5)	// Schedule Enable.
-#define		PROTOCOL_EN		BIT(4)	// protocol Block Function Enable.
-#define		RXDMA_EN			BIT(3)	// RXDMA Function Enable.
-#define		TXDMA_EN			BIT(2)	// TXDMA Function Enable.
-#define		HCI_RXDMA_EN		BIT(1)	// HCI to RXDMA Interface Enable.
-#define		HCI_TXDMA_EN		BIT(0)	// HCI to TXDMA Interface Enable.
-// Loopback mode.
-#define		LB_NORMAL			0x00
-#define		LB_MAC				0x0B
-#define		LB_MAC_DLY			0x03
-#define		LB_PHY				0x01
-#define		LB_DMA				0x07
-#define		LB_DUAL_MAC		0x1B	// 92D_REG
-// Network Type.
-#define		NETYPE_NOLINK		0x00
-#define		NETYPE_ADHOC		0x01
-#define		NETYPE_INFRA		0x02
-#define		NETYPE_AP			0x03
-
-//----------------------------------------------------------------------------
-//       8192C PBP bits						(Offset 0x104-107, 32 bits)
-//----------------------------------------------------------------------------
-#define		PSTX_SHIFT			4	// Page size of transmit packet buffer.
-#define		PSTX_Mask			0x0F
-#define		PSRX_SHIFT			0	// Page size of receive packet buffer and C2HCMD buffer.
-#define		PSRX_Mask			0x0F
-// Page size
-#define		PBP_64B			0x00
-#define		PBP_128B			0x01
-#define		PBP_256B			0x02
-#define		PBP_512B			0x03
-#define		PBP_1024B			0x04
-
-//----------------------------------------------------------------------------
-//       8192C TRXDMA_CTRL bits				(Offset 0x10C-10D, 16 bits)
-//----------------------------------------------------------------------------
-#define		HPQ_SEL_SHIFT		8	// High Priority Queue Selection.
-#define		HPQ_SEL_Mask		0x03F
-#define		RXDMA_AGG_EN		BIT(2)	//
-#define		RXSHFT_EN			BIT(1)	// When this bit is set, RX shift to fit alignment is enable.
-#define		RXDMA_ARBBW_EN	BIT(0)	// Enable RXDMA Arbitrator priority for Host interface.
-// High Priority Queue Selection.
-#define		HPQ_SEL_VOQ		BIT(0)
-#define		HPQ_SEL_VIQ		BIT(1)
-#define		HPQ_SEL_BEQ		BIT(2)
-#define		HPQ_SEL_BKQ		BIT(3)
-#define		HPQ_SEL_MGQ		BIT(4)
-#define		HPQ_SEL_HIQ		BIT(5)
-
-//----------------------------------------------------------------------------
-//       8192C TRXFF_BNDY bits				(Offset 0x114-117, 32 bits)
-//----------------------------------------------------------------------------
-#define		RXFF0_BNDY_SHIFT			16	// upper boundary of RXFF0.
-#define		RXFF0_BNDY_Mask			0x0FFFF
-#define		TXPKTBUF_PGBNDY_SHIFT	0	// From FWHW offload, sets the max pages controlled by TXDMA.
-#define		TXPKTBUF_PGBNDY_Mask		0x0FF
-
-//----------------------------------------------------------------------------
-//       8192C TRXFF_STATUS bits				(Offset 0x118-11B, 32 bits)
-//----------------------------------------------------------------------------
-#define		TXPKTFF_FULL		BIT(16)	// TXDMA block the current TX pkt due to TXPKTBUF full, status bit will be set.
-#define		RXFF1_OVF			BIT(1)	// When this bit is "1", RXFF1 is under overflow condition.
-#define		RXFF0_OVF			BIT(0)	// When this bit is "1", RXFF0 is under overflow condition.
-
-//----------------------------------------------------------------------------
-//       8192C RXFF_PTR bits					(Offset 0x11C-11F, 32 bits)
-//----------------------------------------------------------------------------
-#define		RXFF0_RDPTR_SHIFT		16	// The read pointer address of RXFF0.
-#define		RXFF0_RDPTR_Mask		0x0FFFF
-#define		RXFF0_WTPTR_SHIFT		0	// The write pointer address of RXFF0.
-#define		RXFF0_WTPTR_Mask		0x0FFFF
-
-//----------------------------------------------------------------------------
-//       8192C HIMR bits						(Offset 0x120-123, 32 bits)
-//----------------------------------------------------------------------------
-//----------------------------------------------------------------------------
-//       8192C HISR bits						(Offset 0x124-127, 32 bits)
-//----------------------------------------------------------------------------
-#define		HIMR_BCNDMA7		BIT(31)	// Beacon DMA Interrupt 7.
-#define		HIMR_BCNDMA6		BIT(30)	// Beacon DMA Interrupt 6.
-#define		HIMR_BCNDMA5		BIT(29)	// Beacon DMA Interrupt 5.
-#define		HIMR_BCNDMA4		BIT(28)	// Beacon DMA Interrupt 4.
-#define		HIMR_BCNDMA3		BIT(27)	// Beacon DMA Interrupt 3.
-#define		HIMR_BCNDMA2		BIT(26)	// Beacon DMA Interrupt 2.
-#define		HIMR_BCNDMA1		BIT(25)	// Beacon DMA Interrupt 1.
-#define		HIMR_BCNDOK7		BIT(24)	// Beacon Queue DMA OK Interrupt7.
-#define		HIMR_BCNDOK6		BIT(23)	// Beacon Queue DMA OK Interrupt6.
-#define		HIMR_BCNDOK5		BIT(22)	// Beacon Queue DMA OK Interrupt5.
-#define		HIMR_BCNDOK4		BIT(21)	// Beacon Queue DMA OK Interrupt4.
-#define		HIMR_BCNDOK3		BIT(20)	// Beacon Queue DMA OK Interrupt3.
-#define		HIMR_BCNDOK2		BIT(19)	// Beacon Queue DMA OK Interrupt2.
-#define		HIMR_BCNDOK1		BIT(18)	// Beacon Queue DMA OK Interrupt1.
-#define		HIMR_TIMEOUT2		BIT(17)	// Time Out Interrupt 2.
-#define		HIMR_TIMEOUT1		BIT(16)	// Time Out Interrupt 1.
-#define		HIMR_TXFOVW		BIT(15)	// Transmit packet buffer Overflow.
-#define		HIMR_PSTIMEOUT	BIT(14)	// Power Save Time Out Interrupt.
-#define		HIMR_BCNDMA0		BIT(13)	// Beacon DMA Interrupt 0.
-#define		HIMR_RXFOVW		BIT(12)	// Receive packet buffer Overflow.
-#define		HIMR_RDU			BIT(11)	// Receive Descriptor Unavailable.
-#define		HIMR_ATIM_END		BIT(10)	// ATIM Window End Interrupt.
-#define		HIMR_BCNDOK0		BIT(9)	// Beacon Queue DMA OK Interrupt0.
-#define		HIMR_HIGHDOK		BIT(8)	// High Queue DMA OK Interrupt.
-#define		HIMR_TXBCNOK		BIT(7)	// Transmit Beacon OK Interrupt.
-#define		HIMR_MGTDOK		BIT(6)	// Management Queue DMA OK Interrupt.
-#define		HIMR_TXBCNERR		BIT(5)	// Transmit Beacon Error Interrupt.
-#define		HIMR_BKDOK			BIT(4)	// AC_BK DMA OK Interrupt.
-#define		HIMR_BEDOK			BIT(3)	// AC_BE DMA OK Interrupt.
-#define		HIMR_VIDOK			BIT(2)	// AC_VI DMA OK Interrupt.
-#define		HIMR_VODOK		BIT(1)	// AC_VO DMA Interrupt.
-#define		HIMR_ROK			BIT(0)	// Receive DMA OK Interrupt.
-
-//----------------------------------------------------------------------------
-//       8192C HIMRE bits					(Offset 0x128-12A, 24 bits)
-//----------------------------------------------------------------------------
-//----------------------------------------------------------------------------
-//       8192C HISRE bits					(Offset 0x12C-12E, 24 bits)
-//----------------------------------------------------------------------------
-#define		HIMRE_TXERR		BIT(11)	// Enable Tx Error Flag Interrupt.
-#define		HIMRE_RXERR		BIT(10)	// Enable Rx Error Flag Interrupt.
-#define		HIMRE_C2HCMD		BIT(9)	// Enable CPU to Host Command Interrupt.
-#define		HIMRE_CPWM		BIT(8)	// Enable CPU power Mode exchange Interrupt.
-#define		HIMRE_HBT_CMD		BIT(7)	// 92D_REG, Host BT_CMD interrupt mask
-#define		HIMRE_OCPINT		BIT(1)	// Enable SPS_OCP Interrupt.
-#define		HIMRE_WLANOFF		BIT(0)	// Enable WLAN power down Interrupt.
-
-//----------------------------------------------------------------------------
-//       8192C CPWM bits					(Offset 0x12F, 8 bits)
-//----------------------------------------------------------------------------
-#define		CPWM_TOGGLING	BIT(7)	// When this bit is toggled, interrtup is send to HISRE.CPWMINT.
-#define		CPWM_MOD_SHIFT	0	// The current power mode index.
-#define		CPWM_MOD_Mask	0x07F
-
-//----------------------------------------------------------------------------
-//       8192C FWIMR bits					(Offset 0x130-133, 32 bits)
-//----------------------------------------------------------------------------
-//----------------------------------------------------------------------------
-//       8192C FWISR bits					(Offset 0x134-137, 32 bits)
-//----------------------------------------------------------------------------
-#define		FWIMR_VOQ			BIT(31)	//
-#define		FWIMR_VIQ			BIT(30)	//
-#define		FWIMR_BEQ			BIT(29)	//
-#define		FWIMR_BKQ			BIT(28)	//
-#define		FWIMR_MGTQ		BIT(27)	//
-#define		FWIMR_HIQ			BIT(26)	//
-#define		FWIMR_TXPKTIN		BIT(25)	// interrupt is issued to inform MCU.
-#define		FWIMR_TXBCNOK		BIT(24)	// interrupt is issued when a beacon frame is transmitted.
-#define		FWIMR_TXBCNERR	BIT(23)	// interrupt is issued when beacon in TXPKTBUF fails to send out.
-#define		FWIMR_RX_UMD0	BIT(22)	// receiving unicast data frame with More Data=0.
-#define		FWIMR_RX_UMD1	BIT(21)	// receiving unicast data frame with More Data=1.
-#define		FWIMR_RX_BMD0		BIT(20)	// receiving broadcast data frame with More Data=0.
-#define		FWIMR_RX_BMD1		BIT(19)	// receiving broadcast data frame with More Data=1.
-#define		FWIMR_BCN_RX		BIT(18)	// When receiving Beacon frame.
-#define		FWIMR_TBTT		BIT(17)	// The exact TBTT time interrupt.
-#define		FWIMR_BCNERLY		BIT(16)	// This interrupt is issue at the time set by DRVERLYINT register before TBTT time.
-#define		FWIMR_BCNDMA7	BIT(15)	// When BCNDMA interval arrives before TBTT7, informs MCU to prepare beacon.
-#define		FWIMR_BCNDMA6	BIT(14)	// When BCNDMA interval arrives before TBTT6, informs MCU to prepare beacon.
-#define		FWIMR_BCNDMA5	BIT(13)	// When BCNDMA interval arrives before TBTT5, informs MCU to prepare beacon.
-#define		FWIMR_BCNDMA4	BIT(12)	// When BCNDMA interval arrives before TBTT4, informs MCU to prepare beacon.
-#define		FWIMR_BCNDMA3	BIT(11)	// When BCNDMA interval arrives before TBTT3, informs MCU to prepare beacon.
-#define		FWIMR_BCNDMA2	BIT(10)	// When BCNDMA interval arrives before TBTT2, informs MCU to prepare beacon.
-#define		FWIMR_BCNDMA1	BIT(9)	// When BCNDMA interval arrives before TBTT1, informs MCU to prepare beacon.
-#define		FWIMR_BCNDMA0	BIT(8)	// When BCNDMA interval arrives before TBTT0, informs MCU to prepare beacon.
-#define		FWIMR_LP_STBY		BIT(7)	// Low Power Standby Wake interrupt.
-#define		FWIMR_ATIM		BIT(6)	// This interrupt is issued when it is at the time ATIM ms before ATIMWND expiring.
-#define		FWIMR_HRCV		BIT(5)	// Host Recover CPU Loop Instruction.
-#define		FWIMR_H2CCMD		BIT(4)	// Host To CPU Message Interrupt.
-#define		FWIMR_RXDONE		BIT(3)	//
-#define		FWIMR_ERRORHDL	BIT(2)	// FWHW/ TXDMA/ RXDMA/ WMAC error status interrupt.
-#define		FWIMR_TXCCX		BIT(1)	//
-#define		FWIMR_TXCLOSE		BIT(0)	//
-
-//----------------------------------------------------------------------------
-//       8192C FTIMR bits					(Offset 0x138-13B, 32 bits)
-//----------------------------------------------------------------------------
-//----------------------------------------------------------------------------
-//       8192C FTISR bits					(Offset 0x13C-13F, 32 bits)
-//----------------------------------------------------------------------------
-#define		FTIMR_FWBT_CMD	BIT(18)	// 92D_REG, FW BT_CMD interrupt mask
-#define		FTIMR_RPWM		BIT(8)	// RPWM INT Status. Write 1 clear.
-#define		FTIMR_PSTIMER		BIT(7)	// Enable PSTimer interrupt.
-#define		FTIMR_TIMEOUT1	BIT(6)	// Enable Timer1 interrupt.
-#define		FTIMR_TIMEOUT0	BIT(5)	// Enable Timer0 interrupt.
-#define		FTIMR_GT4			BIT(4)	// Enable General Timer[4] interrupt.
-#define		FTIMR_GT3			BIT(3)	// Enable General Timer[3] interrupt.
-#define		FTIMR_GT2			BIT(2)	// Enable General Timer[2] interrupt.
-#define		FTIMR_GT1			BIT(1)	// Enable General Timer[1] interrupt.
-#define		FTIMR_GT0			BIT(0)	// Enable General Timer[0] interrupt.
-
-//----------------------------------------------------------------------------
-//       8192C PKTBUF_DBG_CTRL bits			(Offset 0x140-143, 32 bits)
-//----------------------------------------------------------------------------
-#define		RXPKTBUF_DBG				BIT(14)	// 1: Enable RXPKTBUF debug mode.
-#define		TXPKTBUF_DBG				BIT(13)	// 1: Enable TXPKTBUF debug mode.
-#define		PKTBUF_DBG_ADDR_SHIFT	0	// The address of TRXPKTBUF to be read.
-#define		PKTBUF_DBG_ADDR_Mask		0x01FFF
-
-//		General Purpose Timer. (Offset 0x150 - 0x16Fh)
-//----------------------------------------------------------------------------
-//       8192C TC0_CTRL bits					(Offset 0x150-153, 32 bits)
-//----------------------------------------------------------------------------
-//----------------------------------------------------------------------------
-//       8192C TC1_CTRL bits					(Offset 0x154-157, 32 bits)
-//----------------------------------------------------------------------------
-//----------------------------------------------------------------------------
-//       8192C TC2_CTRL bits					(Offset 0x158-15B, 32 bits)
-//----------------------------------------------------------------------------
-//----------------------------------------------------------------------------
-//       8192C TC3_CTRL bits					(Offset 0x15C-15F, 32 bits)
-//----------------------------------------------------------------------------
-//----------------------------------------------------------------------------
-//       8192C TC4_CTRL bits					(Offset 0x160-163, 32 bits)
-//----------------------------------------------------------------------------
-#define		TCINT_EN			BIT(26)	// When write "1" to this bit, Counter starts counting down.
-#define		TCMODE				BIT(25)	// Timer/Counter mode.
-#define		TCEN				BIT(24)	// Timer/Counter enable.
-#define		TCData_SHIFT		0	// Timer/Counter data register. It specifies the time-out duration.
-#define		TCData_Mask		0x0FFFFFF
-
-//----------------------------------------------------------------------------
-//       8192C TCUNIT_BASE bits				(Offset 0x164-165, 16 bits)
-//----------------------------------------------------------------------------
-#define		TCUNIT_BASE_TIME_SHIFT	0	// num of clocks that equals to the base time unit of timer/counter.
-#define		TCUNIT_BASE_TIME_Mask	0x03FFF
-//		General Purpose Timer. (Offset 0x150 - 0x16Fh)
-
-//----------------------------------------------------------------------------
-//       8192C MBIST_START bits				(Offset 0x174-177, 32 bits)
-//----------------------------------------------------------------------------
-#define		TXLLT_BISTP		BIT(10)	// TXLLT BIST Start Pulse.
-#define		TXOQT_BISTP		BIT(9)	// TXOQT BIST Start Pulse.
-#define		TXPKT_BISTP		BIT(8)	// TXPKT Buffer BIST Start Pulse.
-#define		RXPKT_BISTP		BIT(7)	// RXPKT Buffer BIST Start Pulse.
-#define		TXDBUF_BISTP		BIT(6)	// TXDBUF BIST Start Pulse.
-#define		TXFIFO_BISTP		BIT(5)	// TXFIFO BIST Start Pulse.
-#define		RXFIFO_BISTP		BIT(4)	// RXFIFO BIST Start Pulse.
-#define		WKEYLLT_BISTP		BIT(3)	// WKEY BIST Start Pulse.
-#define		WRXBA_BISTP		BIT(2)	// WRXBA BIST Start Pulse.
-
-//----------------------------------------------------------------------------
-//       8192C MBIST_DONE bits				(Offset 0x178-17B, 32 bits)
-//----------------------------------------------------------------------------
-#define		TXLLT_BISTD		BIT(10)	// TXLLT BIST Done.
-#define		TXOQT_BISTD		BIT(9)	// TXOQT BIST Done.
-#define		TXPKT_BISTD		BIT(8)	// TXPKT Buffer BIST Done.
-#define		RXPKT_BISTD		BIT(7)	// RXPKT Buffer BIST Done.
-#define		TXDBUF_BISTD		BIT(6)	// TXDBUF BIST Done.
-#define		TXFIFO_BISTD		BIT(5)	// TXFIFO BIST Done.
-#define		RXFIFO_BISTD		BIT(4)	// RXFIFO BIST Done.
-#define		WKEYLLT_BISTD		BIT(3)	// WKEY BIST Done.
-#define		WRXBA_BISTD		BIT(2)	// WRXBA BIST Done.
-
-//----------------------------------------------------------------------------
-//       8192C MBIST_FAIL bits				(Offset 0x17C-17F, 32 bits)
-//----------------------------------------------------------------------------
-#define		TXLLT_BISTF		BIT(10)	// TXLLT BIST Fail.
-#define		TXOQT_BISTF		BIT(9)	// TXOQT BIST Fail.
-#define		TXPKT_BISTF		BIT(8)	// TXPKT Buffer BIST Fail.
-#define		RXPKT_BISTF		BIT(7)	// RXPKT Buffer BIST Fail.
-#define		TXDBUF_BISTF		BIT(6)	// TXDBUF BIST Fail.
-#define		TXFIFO_BISTF		BIT(5)	// TXFIFO BIST Fail.
-#define		RXFIFO_BISTF		BIT(4)	// RXFIFO BIST Fail.
-#define		WKEYLLT_BISTF		BIT(3)	// WKEY BIST Fail.
-#define		WRXBA_BISTF		BIT(2)	// WRXBA BIST Fail.
-
-//----------------------------------------------------------------------------
-//       8192C FMETHR bits					(Offset 0x1C8-1CB, 32 bits)
-//----------------------------------------------------------------------------
-#define		FMSG_INT			BIT(31)	// Toggle this bit will generate interrupt to Host.
-#define		FW_MSG_SHIFT		0	// User Defined Message.
-#define		FW_MSG_Mask		0x07FFFFFFF
-
-//----------------------------------------------------------------------------
-//       8192C HMETFR bits					(Offset 0x1CC-1CF, 32 bits)
-//----------------------------------------------------------------------------
-#define		HRCV_MSG_SHIFT	24	// User Defined Message.
-#define		HRCV_MSG_Mask		0x0FF
-#define		INT_BOX3			BIT(3)	// MSG_BOX_3 Valid. Enable when the Entry is write.
-#define		INT_BOX2			BIT(2)	// MSG_BOX_2 Valid. Enable when the Entry is write.
-#define		INT_BOX1			BIT(1)	// MSG_BOX_1 Valid. Enable when the Entry is write.
-#define		INT_BOX0			BIT(0)	// MSG_BOX_0 Valid. Enable when the Entry is write.
-
-//----------------------------------------------------------------------------
-//       8192C LLT_INI bits					(Offset 0x1E0-1E3, 32 bits)
-//----------------------------------------------------------------------------
-#define		LLTE_RWM_SHIFT		30	//
-#define		LLTE_RWM_Mask			0x03
-#define		LLTINI_PDATA_SHIFT	16	// LLT Entry Write/Read DATA for MCU.
-#define		LLTINI_PDATA_Mask		0x0FF
-#define		LLTINI_ADDR_SHIFT		8	// LLT Entry Access Offset.
-#define		LLTINI_ADDR_Mask		0x0FF
-#define		LLTINI_HDATA_SHIFT	0	// LLT Entry Write/Read DATA for HCI.
-#define		LLTINI_HDATA_Mask		0x0FF
-// LLTE_RWM
-#define		LLTE_RWM_NO_ACTIVE	0x00
-#define		LLTE_RWM_WR			0x01
-#define		LLTE_RWM_RD			0x03
-
-//----------------------------------------------------------------------------
-//       8192C BB_ACCEESS_CTRL bits			(Offset 0x1E8-1EB, 32 bits)
-//----------------------------------------------------------------------------
-#define		BB_WRITE_READ_SHIFT	30	//
-#define		BB_WRITE_READ_Mask	0x03
-#define		BB_WRITE_EN_SHIFT		12	// Byte Write Enable.
-#define		BB_WRITE_EN_Mask		0x0F
-#define		BB_ADDR_SHIFT			2	// Baseband Access Write/Read Address (in DW unit).
-#define		BB_ADDR_Mask			0x03FF
-#define		BB_ERRACC				BIT(0)	// Duplicate Access when previous cycle pending (write one clear).
-
-
-//
-// 3. TXDMA/RXDMA Configuration. (Offset 0x200 - 0x2FFh)
-//
-//----------------------------------------------------------------------------
-//       8192C RQPN bits						(Offset 0x200-203, 32 bits)
-//----------------------------------------------------------------------------
-#define		LD_RQPN			BIT(31)	// Write 1 to set RQPN bit[79:0] value to page numbers for initialization.
-#define		LPQ_PUBLIC_DIS		BIT(25)	// bit=1, available Tx page size excludes the public queue.
-#define		HPQ_PUBLIC_DIS		BIT(24)	// bit=1, available Tx page size excludes the public queue.
-#define		PUBQ_SHIFT			16	// Public Reserved Page Number.
-#define		PUBQ_Mask			0x0FF
-#define		LPQ_SHIFT			8	// Low Priority Queue Reserved Page Number.
-#define		LPQ_Mask			0x0FF
-#define		HPQ_SHIFT			0	// High Priority Queue Reserved Page Number.
-#define		HPQ_Mask			0x0FF
-
-//----------------------------------------------------------------------------
-//       8192C FIFOPAGE bits					(Offset 0x204-207, 32 bits)
-//----------------------------------------------------------------------------
-#define		TXPKTNUM_SHIFT		24	// Packet number in TXPKTBUF.
-#define		TXPKTNUM_Mask			0x0FF
-#define		PUB_AVAL_PG_SHIFT		16	// Available Public Queue Page Number.
-#define		PUB_AVAL_PG_Mask		0x0FF
-#define		LPQ_AVAL_PG_SHIFT		8	// Available Low Priority Queue Page Number.
-#define		LPQ_AVAL_PG_Mask		0x0FF
-#define		HPQ_AVAL_PG_SHIFT		0	// Available High Priority Queue Page Number.
-#define		HPQ_AVAL_PG_Mask		0x0FF
-
-//----------------------------------------------------------------------------
-//       8192C TDECTRL bits					(Offset 0x208-20B, 32 bits)
-//----------------------------------------------------------------------------
-#define		LLT_FREE_PAGE_SHIFT	24	// LLT Free Page.
-#define		LLT_FREE_PAGE_Mask	0x0FF
-#define		BCN_VALID				BIT(16)	// bit=1, beacon packet has finished to write to txpktbuffer.
-#define		BCN_HEAD_SHIFT		8	// head page of Bcnq packet which is Tx DMA filled.
-#define		BCN_HEAD_Mask			0x0FF
-#define		BLK_DESC_NUM_SHIFT	4	// The Most Number of Tx Descriptor per Bulk Out Only for USB.
-#define		BLK_DESC_NUM_Mask	0x0F
-
-//----------------------------------------------------------------------------
-//       8192C TXDMA_OFFSET_CHK bits		(Offset 0x20C-20F, 32 bits)
-//----------------------------------------------------------------------------
-#define		PG_UNDER_TH_SHIFT	16	// Page threshold value is check by Tx DMA engine.
-#define		PG_UNDER_TH_Mask		0x0FF
-#define		CHK_PG_TH_EN			BIT(10)	// Enable Tx DMA to check total pages if it is under page threshold.
-#define		DROP_DATA_EN			BIT(9)	// Enable Tx DMA to drop the redundant data of packet.
-#define		CHECK_OFFSET_EN		BIT(8)	// Enable Tx DMA to check offset value.
-#define		CHECK_OFFSET_SHIFT	0	// Offset value is check by Tx DMA engine.
-#define		CHECK_OFFSET_Mask		0x0FF
-
-//----------------------------------------------------------------------------
-//       8192C TXDMA_STATUS bits			(Offset 0x210-213, 32 bits)
-//----------------------------------------------------------------------------
-#define		PAYLOAD_UDN		BIT(14)	// Payload is under the packet length of Tx descriptor.
-#define		PAYLOAD_OVF		BIT(13)	// Payload is over the packet length of Tx descriptor.
-#define		DSC_CHKSUM_FAIL	BIT(12)	// Tx descriptor checksum error.
-#define		UNKNOWN_QSEL		BIT(11)	// An unknown QSEL of Tx descriptor is detected.
-#define		EP_QSEL_DIFF		BIT(10)	// Tx Endpoint is unmatched with the QSEL of descriptor.
-#define		TX_OFFS_UNMATCH	BIT(9)	// Tx offset is unmatched.
-#define		TXOQT_UDN			BIT(8)	// TXOQT Underflow.
-#define		TXOQT_OVF			BIT(7)	// TXOQT Overflow.
-#define		TXDMA_SFF_UDN		BIT(6)	// TXDMA Sync FIFO Underflow.
-#define		TXDMA_SFF_OVF		BIT(5)	// TXDMA Sync FIFO Overflow.
-#define		LLT_NULL_PG		BIT(4)	// TXDMA reads NULL page.
-#define		PAGE_UDN			BIT(3)	// Total pages included PTCL un-return pages under the total reserved pages.
-#define		PAGE_OVF			BIT(2)	// Total pages included PTCL un-return pages over the total reserved pages.
-#define		TXFF_PG_UDN		BIT(1)	// TXFF page underflow in TDE page controller.
-#define		TXFF_PG_OVF		BIT(0)	// TXFF page overflow in TDE page controller.
-
-//----------------------------------------------------------------------------
-//       8192C RXDMA_AGG_PG_TH bits		(Offset 0x280-283, 32 bits)
-//----------------------------------------------------------------------------
-#define		RXDMA_AGG_PG_TH_LMT(x)	((x & 0x0FF)<<0)	// DMA inform host to receive pkts, when exceeds the threshold.
-
-//----------------------------------------------------------------------------
-//       8192C RXPKT_NUM bits				(Offset 0x284-287, 32 bits)
-//----------------------------------------------------------------------------
-#define		RXPKT_NUM_LMT_SHIFT	24	// number of packets in RXPKTBUF.
-#define		RXPKT_NUM_LMT_Mask	0x0FF
-#define		RW_RELEASE_EN			BIT(18)	// bit=1, RXDMA will enter this mode after RXDMA packet to host completed and stop.
-#define		RXDMA_IDLE				BIT(17)	// RXDMA finishes DMA will report idle state in this bit.
-#define		RXPKT_RELEASE_POLL	BIT(16)	// bit=1, RXDMA will decrease RX PKT counter by one.
-#define		FW_UPD_RDPTR_SHIFT	0	// FW updates before write RXPKT_RELEASE_POLL to 1.
-#define		FW_UPD_RDPTR_Mask	0x0FFFF
-
-//----------------------------------------------------------------------------
-//       8192C RXDMA_STATUS bits			(Offset 0x288-28B, 32 bits)
-//----------------------------------------------------------------------------
-#define		FW_POLL_ISSUE		BIT(5)	// FW Release Poll Error.
-#define		RX_DATA_UDN		BIT(4)	// RX Data Underflow. Clear by SW.
-#define		RX_SFF_UDN			BIT(3)	// RX Sync FIFO Underflow.
-#define		RX_SFF_OVF			BIT(2)	// RX Sync FIFO Overflow.
-#define		USB_REQ_LEN_OVF	BIT(1)	// USB RXAGGEN Error due to RX length overflow.
-#define		RXPKT_OVF			BIT(0)	// When RX Packet is more than 255 packets remaining in FF.
-
-
-//
-// 4. PCIE EMAC Reserved Region. (Offset 0x300 - 0x3FFh)
-//
-//----------------------------------------------------------------------------
-//       8192C PCIE_CTRL_REG bits			(Offset 0x300-303, 32 bits)
-//----------------------------------------------------------------------------
-#define		MAX_RXDMA_SHIFT	28	// RXDMA Burst Size selection.
-#define		MAX_RXDMA_Mask	0x07
-#define		MAX_TXDMA_SHIFT	24	// TXDMA Burst Size selection.
-#define		MAX_TXDMA_Mask	0x07
-#define		En_HWENTRL		BIT(19)	// Enable HW call EMAC to enter L23 actively.
-#define		EN_SWENTR_L23		BIT(17)	// Enable SW call EMAC to enter L23.
-#define		EN_HWEXITL1		BIT(16)	// Enable HW call EMAC to exit L1.
-#define		BCNQSTOP			BIT(15)	// BCNQ DMA STOP.
-#define		HQSTOP				BIT(14)	// HQ DMA STOP.
-#define		MGQSTOP			BIT(13)	// VOKQ DMA STOP.
-#define		VOQSTOP			BIT(12)	// VOKQ DMA STOP.
-#define		VIQSTOP			BIT(11)	// VIQ DMA STOP.
-#define		BEQSTOP			BIT(10)	// BEQ DMA STOP.
-#define		BKQSTOP			BIT(9)	// BKQ DMA STOP.
-#define		RXQSTOP			BIT(8)	// RX DMA STOP.
-#define		HQ_POLL			BIT(7)	// High Queue Polling bit, read result will be hpqflag.
-#define		MGQ_POLL			BIT(6)	// Manag Queue Polling bit, read result will be mgqflag.
-#define		BCNQ_POLL			BIT(4)	// BCNQ Polling bit, read result will be bpqflag.
-#define		VOQ_POLL			BIT(3)	// VOQ Polling bit, read result will be voqflag.
-#define		VIQ_POLL			BIT(2)	// VIQ Polling bit, read result will be viqflag.
-#define		BEQ_POLL			BIT(1)	// BEQ Polling bit, read result will be beqflag.
-#define		BKQ_POLL			BIT(0)	// BKQ Polling bit, read result will be bkqflag.
-
-//----------------------------------------------------------------------------
-//       8192C INT_MIG bits					(Offset 0x304-307, 32 bits)
-//----------------------------------------------------------------------------
-#define		TTMRMIT_Shift			28	// 92D_REG, Tx timer mitigation
-#define		TTMRMIT_Mask			0x0F
-#define		TNUMMIT_Shift			24	// 92D_REG, Tx number mitigation
-#define		TNUMMIT_Mask			0x0F
-#define		RTMRMIT_Shift			20	// 92D_REG, Rx timer mitigation
-#define		RTMRMIT_Mask			0x0F
-#define		RNUMMIT_Shift			16	// 92D_REG, Rx number mitigation
-#define		RNUMMIT_Mask			0x0F
-#define		INTMT_SHIFT			16	// Interrupt Couter for setting Interrupt Migration.
-#define		INTMT_Mask				0x0FFFF
-#define		MIGRATE_TIMER_SHIFT	0	// Timer for setting Interrupt Migration.
-#define		MIGRATE_TIMER_Mask	0x0FFFF
-
-//----------------------------------------------------------------------------
-//       8192C DBI bits						(Offset 0x348-353, 96 bits)
-//----------------------------------------------------------------------------
-#define		DBI_ACC_EXT		BIT(19)	// 92D_REG, DBI access external register on ELBI
-#define		DBI_MACSEL			BIT(18)	// 92D_REG, DBI access MAC1 select
-#define		DBI_RFLAG			BIT(17)	// DBI Read Flag.
-#define		DBI_WFLAG			BIT(16)	// DBI Write Flag.
-#define		DBI_WREN_SHIFT	12	// DBI Write Enable, High active.
-#define		DBI_WREN_Mask		0x0F
-#define		DBI_ADDR_SHIFT	0	// DBI Address.
-#define		DBI_ADDR_Mask		0x0FFF
-
-//----------------------------------------------------------------------------//
-//       8192C MDIO bits						(Offset 0x354-35B, 64 bits)
-//----------------------------------------------------------------------------
-#define		ECRC_EN			BIT(7)	// ECRC Enable.
-#define		MDIO_RFLAG			BIT(6)	// MDIO Read Flag.
-#define		MDIO_WFLAG		BIT(5)	// MDIO Write Flag.
-#define		MDIO_ADDR_SHIFT	0	// MDIO Address.
-#define		MDIO_ADDR_Mask	0x01F
-
-#define		MDIO_RDATA_SHIFT	16	// MDIO Read Data.
-#define		MDIO_RDATA_Mask	0x0FFFF
-#define		MDIO_WDATA_SHIFT	0	// MDIO Write Data.
-#define		MDIO_WDATA_Mask	0x0FFFF
-
-//----------------------------------------------------------------------------
-//       8192C UART_CTRL bits				(Offset 0x364-36B, 64 bits)
-//----------------------------------------------------------------------------
-#define		UART_WDATA_H_SHIFT	0	// UART Write Data [31:8], read will be UART Read Data[31:8].
-#define		UART_WDATA_H_Mask	0x0FFFFFF
-
-#define		UART_DMA_STS_SHIFT	24	// UART DMA Status.
-#define		UART_DMA_STS_Mask	0x07
-#define		UART_DMA_MOD			BIT(20)	// UART DMA Mode.
-#define		UART_RDMA				BIT(19)	// UART RX DMA Flag.
-#define		UART_TDMA				BIT(18)	// UART TX DMA Flag.
-#define		UART_RCMD				BIT(17)	// UART Read Command.
-#define		UART_WCMD				BIT(16)	// UART Write Command.
-#define		UART_ADDR_SHIFT		10	// UART Address.
-#define		UART_ADDR_Mask		0x03F
-#define		UART_WDATA_L_SHIFT	0	// UART Write Data [7:0], read will be UART Read Data[7:0].
-#define		UART_WDATA_L_Mask	0x0FF
-
-
-//
-// 5. PTCL/EDCA Configuration. (Offset 0x400 - 0x4FFh)
-//
-//----------------------------------------------------------------------------
-//       8192C VOQ_INFO bits				(Offset 0x400-403, 32 bits)
-//----------------------------------------------------------------------------
-//----------------------------------------------------------------------------
-//       8192C VIQ_INFO bits					(Offset 0x404-407, 32 bits)
-//----------------------------------------------------------------------------
-//----------------------------------------------------------------------------
-//       8192C BEQ_INFO bits					(Offset 0x408-40B, 32 bits)
-//----------------------------------------------------------------------------
-//----------------------------------------------------------------------------
-//       8192C BKQ_INFO bits					(Offset 0x40C-40F, 32 bits)
-//----------------------------------------------------------------------------
-//----------------------------------------------------------------------------
-//       8192C MGQ_INFO bits				(Offset 0x410-413, 32 bits)
-//----------------------------------------------------------------------------
-//----------------------------------------------------------------------------
-//       8192C HIQ_INFO bits					(Offset 0x414-417, 32 bits)
-//----------------------------------------------------------------------------
-#define		Q_CPU_HEAD_SHIFT	24	// MCU will handle q_pkt head.
-#define		Q_CPU_HEAD_Mask	0x0FF
-#define		Q_PKT_NUM_SHIFT	16	// total Q pkt number in TxPktbuffer.
-#define		Q_PKT_NUM_Mask	0x0FF
-#define		Q_FW_NUM_SHIFT	8	// total Q FW number in TxPktbuffer.
-#define		Q_FW_NUM_Mask	0x0FF
-#define		Q_HEAD_PG_SHIFT	0	// head page of the first packet of Q.
-#define		Q_HEAD_PG_Mask	0x0FF
-
-//----------------------------------------------------------------------------
-//       8192C BCNQ_INFO bits				(Offset 0x418-41A, 24 bits)
-//----------------------------------------------------------------------------
-#define		BCNQ_PKT_NUM_SHIFT	16	// total BCNQ pkt number in TxPktbuffer.
-#define		BCNQ_PKT_NUM_Mask	0x0FF
-#define		BCNQ_FW_NUM_SHIFT	8	// total BCNQ FW number in TxPktbuffer.
-#define		BCNQ_FW_NUM_Mask		0x0FF
-#define		BCNQ_HEAD_PG_SHIFT	0	// head page of the first packet of BCNQ.
-#define		BCNQ_HEAD_PG_Mask	0x0FF
-
-//----------------------------------------------------------------------------
-//       8192C TXPKT_EMPTY bits				(Offset 0x41B, 8 bits)
-//----------------------------------------------------------------------------
-#define		BCNQ_EMPTY		BIT(7)	// queue is empty. Report by MAC.
-#define		HQQ_EMPTY			BIT(6)	// queue is empty. Report by MAC.
-#define		HMGQ_EMPTY		BIT(5)	// queue is empty. Report by MAC.
-#define		CMGQ_EMPTY		BIT(4)	// queue is empty. Report by MAC.
-#define		BKQ_EMPTY			BIT(3)	// queue is empty. Report by MAC.
-#define		BEQ_EMPTY			BIT(2)	// queue is empty. Report by MAC.
-#define		VIQ_EMPTY			BIT(1)	// queue is empty. Report by MAC.
-#define		VOQ_EMPTY			BIT(0)	// queue is empty. Report by MAC.
-
-//----------------------------------------------------------------------------
-//       8192C CPU_MGQ_INFO bits			(Offset 0x41C-41F, 32 bits)
-//----------------------------------------------------------------------------
-#define		CPUMGQ_FW_NUM_SHIFT		8	// total CPU MGQ fw number in TxPktbuffer.
-#define		CPUMGQ_FW_NUM_Mask		0x0FF
-#define		CPUMGQ_HEAD_PG_SHIFT	0	// head page of CPU MGQ.
-#define		CPUMGQ_HEAD_PG_Mask		0x0FF
-
-//----------------------------------------------------------------------------
-//       8192C FWHW_TXQ_CTRL bits			(Offset 0x420-422, 24 bits)
-//----------------------------------------------------------------------------
-#define		RTS_LIMIT_IN_OFDM		BIT(23)	// 92D_REG, rts rate will not down to cck rate
-#define		EN_BCNQ_DL				BIT(22)	// 92D_REG, 1: ptcl consider there is bcn pkt in txbuf; 0: mask bcn pkt num in bcnq
-#define		EN_RD_RESP_NAV_BK	BIT(21)	// Control the RD responder NAV criteria for TX.
-#define		EN_WR_FREE_TAIL		BIT(20)	// 1:Drive wirte Bcnq_boundary,Hw set free_tail in Boundary-1; 0:no update.
-#define		CHK_LOSS_QSEL_SHIFT	17	//
-#define		CHK_LOSS_QSEL_Mask	0x07
-#define		EN_CHECK_LOSS			BIT(16)	// bit=1, HW will monitor packet loss from TXDMA.
-#define		EN_QUEUE_RPT_SHIFT	8	// 1: HW will report tx_status  0: no report.
-#define		EN_QUEUE_RPT_Mask	0x07F
-#define		EN_AMPDU_RTY_NEW		BIT(7)	// AMPDU aggregation mode with retry MPDUs and new MPDUs.
-#define		LIFETIME_EN			BIT(6)	// Enable lift time drop.
-#define		EN_CPU_HANDLE_SHIFT	0	// PKT need cpu handle.
-#define		EN_CPU_HANDLE_Mask	0x03F
-
-//----------------------------------------------------------------------------
-//       8192C HWSEQ_CTRL bits				(Offset 0x423, 8 bits)
-//----------------------------------------------------------------------------
-#define		HWSEQ_BCN_EN		BIT(6)	//
-#define		HWSEQ_HI_EN		BIT(5)	//
-#define		HWSEQ_MGT_EN		BIT(4)	//
-#define		HWSEQ_BK_EN		BIT(3)	//
-#define		HWSEQ_BE_EN		BIT(2)	//
-#define		HWSEQ_VI_EN		BIT(1)	//
-#define		HWSEQ_VO_EN		BIT(0)	//
-
-//----------------------------------------------------------------------------
-//       8192C MULTI_BCNQ_EN bits			(Offset 0x426, 8 bits)
-//----------------------------------------------------------------------------
-#define		MBID_BCNQ7_EN		BIT(7)	//
-#define		MBID_BCNQ6_EN		BIT(6)	//
-#define		MBID_BCNQ5_EN		BIT(5)	//
-#define		MBID_BCNQ4_EN		BIT(4)	//
-#define		MBID_BCNQ3_EN		BIT(3)	//
-#define		MBID_BCNQ2_EN		BIT(2)	//
-#define		MBID_BCNQ1_EN		BIT(1)	//
-#define		MBID_BCNQ0_EN		BIT(0)	//
-
-//----------------------------------------------------------------------------
-//       8192C MULTI_BCNQ_OFFSET bits			(Offset 0x427, 8 bits)
-//----------------------------------------------------------------------------
-#define		MBCNQ_OFFSET_SHIFT	0	// page number between two consecutive BCNQ head page.
-#define		MBCNQ_OFFSET_Mask	0x03
-
-//----------------------------------------------------------------------------
-//       8192C SPEC_SIFS bits					(Offset 0x428-429, 16 bits)
-//----------------------------------------------------------------------------
-#define		SPEC_SIFS_OFDM_SHIFT	8	// spec SIFS value for duration calculation.
-#define		SPEC_SIFS_OFDM_Mask	0x0FF
-#define		SPEC_SIFS_CCK_SHIFT	0	// spec SIFS value for duration calculation.
-#define		SPEC_SIFS_CCK_Mask	0x0FF
-
-//----------------------------------------------------------------------------
-//       8192C RL bits							(Offset 0x42A-42B, 16 bits)
-//----------------------------------------------------------------------------
-#define		SRL_SHIFT			8	// Short Retry Limit.
-#define		SRL_Mask			0x03F
-#define		LRL_SHIFT			0	// Long Retry Limit.
-#define		LRL_Mask			0x03F
-
-//----------------------------------------------------------------------------
-//       8192C DARFRC bits						(Offset 0x430-437, 64 bits)
-//----------------------------------------------------------------------------
-//----------------------------------------------------------------------------
-//       8192C RARFRC bits						(Offset 0x438-43F, 64 bits)
-//----------------------------------------------------------------------------
-#define		ARF_RC8_SHIFT		24	// Response Auto Rate Fallback Retry Count.
-#define		ARF_RC8_Mask		0x01F
-#define		ARF_RC7_SHIFT		16	// Response Auto Rate Fallback Retry Count.
-#define		ARF_RC7_Mask		0x01F
-#define		ARF_RC6_SHIFT		8	// Response Auto Rate Fallback Retry Count.
-#define		ARF_RC6_Mask		0x01F
-#define		ARF_RC5_SHIFT		0	// Response Auto Rate Fallback Retry Count.
-#define		ARF_RC5_Mask		0x01F
-
-#define		ARF_RC4_SHIFT		24	// Response Auto Rate Fallback Retry Count.
-#define		ARF_RC4_Mask		0x01F
-#define		ARF_RC3_SHIFT		16	// Response Auto Rate Fallback Retry Count.
-#define		ARF_RC3_Mask		0x01F
-#define		ARF_RC2_SHIFT		8	// Response Auto Rate Fallback Retry Count.
-#define		ARF_RC2_Mask		0x01F
-#define		ARF_RC1_SHIFT		0	// Response Auto Rate Fallback Retry Count.
-#define		ARF_RC1_Mask		0x01F
-
-//----------------------------------------------------------------------------
-//       8192C RRSR bits							(Offset 0x440-442, 24 bits)
-//----------------------------------------------------------------------------
-#define		RRSR_SHORT			BIT(23)	// Respond with short preamble packet. Default is long preamble.
-#define		RRSR_RSC_SHIFT		21	// Response frame sub-channel configuration.
-#define		RRSR_RSC_Mask		0x03
-#define		RRSC_BITMAP_SHIFT	0	// Response Auto Rate Fallback Retry Count.
-#define		RRSC_BITMAP_Mask	0x0FFFFF
-
-//----------------------------------------------------------------------------
-//       8192C AGGLEN_LMT bits					(Offset 0x458-45B, 32 bits)
-//----------------------------------------------------------------------------
-#define		AGGLMT_MCS15S_SHIFT	28	// Aggregation Limit for MCS 15 SGI in the units of number of MPDUs.
-#define		AGGLMT_MCS15S_Mask	0x0F
-#define		AGGLMT_MCS15_SHIFT	24	// Aggregation Limit for MCS 13~15 in the units of number of MPDUs.
-#define		AGGLMT_MCS15_Mask	0x0F
-#define		AGGLMT_MCS12_SHIFT	20	// Aggregation Limit for MCS 11~12 in the units of number of MPDUs.
-#define		AGGLMT_MCS12_Mask	0x0F
-#define		AGGLMT_MCS10_SHIFT	16	// Aggregation Limit for MCS 8~10 in the units of number of MPDUs.
-#define		AGGLMT_MCS10_Mask	0x0F
-#define		AGGLMT_MCS7S_SHIFT	12	// Aggregation Limit for MCS 7 SGI in the units of number of MPDUs.
-#define		AGGLMT_MCS7S_Mask	0x0F
-#define		AGGLMT_MCS7_SHIFT	8	// Aggregation Limit for MCS 6~7 in the units of number of MPDUs.
-#define		AGGLMT_MCS7_Mask		0x0F
-#define		AGGLMT_MCS5_SHIFT	4	// Aggregation Limit for MCS 3~5 in the units of number of MPDUs.
-#define		AGGLMT_MCS5_Mask		0x0F
-#define		AGGLMT_MCS2_SHIFT	0	// Aggregation Limit for MCS 0~2 in the units of number of MPDUs.
-#define		AGGLMT_MCS2_Mask		0x0F
-
-//----------------------------------------------------------------------------
-//       8192C AMPDU_MIN_SPACE bits				(Offset 0x45C, 8 bits)
-//----------------------------------------------------------------------------
-#define		MIN_SPACE_SHIFT	0	// The spacing between sub-frame.
-#define		MIN_SPACE_Mask	0x07
-
-//----------------------------------------------------------------------------
-//       8192C FAST_EDCA_CTRL bits				(Offset 0x460-462, 24 bits)
-//----------------------------------------------------------------------------
-#define		FAST_EDCA_TO_SHIFT		16	// If pkt timeout, HW will contend channel using fast backoff.
-#define		FAST_EDCA_TO_Mask		0x01F
-#define		FAST_EDCA_PKT_TH_SHIFT	0	// If pkt in txpktbuffer over thrs. HW will fast backoff.
-#define		FAST_EDCA_PKT_TH_Mask	0x0FFFF
-
-//----------------------------------------------------------------------------
-//       8192C RD_RESP_PKT_TH bits				(Offset 0x463, 8 bits)
-//----------------------------------------------------------------------------
-#define		RD_RESP_PKT_TH_LMT_SHIFT		0	// granted ACq pkt num beyond this, responder set More PPDU=1 & piggyback.
-#define		RD_RESP_PKT_TH_LMT_Mask		0x01F
-
-//----------------------------------------------------------------------------
-//       8192C INIRTS_RATE_SEL bits				(Offset 0x480, 8 bits)
-//----------------------------------------------------------------------------
-#define		INIRTSMCS_SEL_SHIFT	0	// initial rate for Control type frame transmitted as EDCA originator.
-#define		INIRTSMCS_SEL_Mask	0x03F
-
-//----------------------------------------------------------------------------
-//       8192C POWER_STAGE1 bits				(Offset 0x4B4-4B6, 24 bits)
-//----------------------------------------------------------------------------
-#define		PWR_STAGE1_SHIFT		0	// User define Power Stage1.
-#define		PWR_STAGE1_Mask		0x0FFFFFF
-
-//----------------------------------------------------------------------------
-//       8192C POWER_STAGE2 bits				(Offset 0x4B8-4BA, 24 bits)
-//----------------------------------------------------------------------------
-#define		PWR_STAGE2_SHIFT		0	// User define Power Stage2.
-#define		PWR_STAGE2_Mask		0x0FFFFFF
-
-//----------------------------------------------------------------------------
-//       8192C STBC_SETTING bits				(Offset 0x4C4, 8 bits)
-//----------------------------------------------------------------------------
-#define		NESS_SHIFT			2	//
-#define		NESS_Mask			0x03
-#define		STBC_CFEND_SHIFT	0	// CFEND STBC.
-#define		STBC_CFEND_Mask	0x03
-
-//----------------------------------------------------------------------------
-//       8192C PROT_MODE_CTRL bits				(Offset 0x4C8-4C9, 16 bits)
-//----------------------------------------------------------------------------
-#define		RTS_TXTIME_TH_SHIFT	8	// RTS pkt txtime thrs
-#define		RTS_TXTIME_TH_Mask	0x0FF
-#define		RTS_LEN_TH_SHIFT		0	// RTS Length thrs.
-#define		RTS_LEN_TH_Mask		0x0FF
-
-//----------------------------------------------------------------------------
-//       8192C BAR_MODE_CTRL bits				(Offset 0x4CC-4CE, 24 bits)
-//----------------------------------------------------------------------------
-#define		BAR_RTY_LMT_SHIFT			16	// BAR retry limit.
-#define		BAR_RTY_LMT_Mask			0x03
-#define		BAR_PKT_TXTIME_TH_SHIFT	8	// BAR pkt txtime thrs.
-#define		BAR_PKT_TXTIME_TH_Mask	0x0FF
-#define		BAR_PKTNUM_TH_SHIFT		0	// BAR Pktnum Thrs.
-#define		BAR_PKTNUM_TH_Mask		0x0FF
-
-//----------------------------------------------------------------------------
-//       8192C RA_TRY_RATE_AGG_LMT bits			(Offset 0x4CF, 8 bits)
-//----------------------------------------------------------------------------
-#define		RA_BAR_RTY_LMT_SHIFT				5	// BAR retry limit.
-#define		RA_BAR_RTY_LMT_Mask				0x07
-#define		RA_TRY_RATE_AGG_LMT_NUM_SHIFT	0	// aggr pkt num limit for try up rate of when desc try bit=1.
-#define		RA_TRY_RATE_AGG_LMT_NUM_Mask	0x01F
-
-//----------------------------------------------------------------------------
-//       8192C NQOS_SEQ bits					(Offset 0x4DC-4DD, 16 bits)
-//----------------------------------------------------------------------------
-//----------------------------------------------------------------------------
-//       8192C QOS_SEQ bits						(Offset 0x4DE-4DF, 16 bits)
-//----------------------------------------------------------------------------
-#define		N_QOS_SSN_SHIFT	0	// TXDESC HWSEQEN is set, MAC will overwrite SEQ control by this.
-									// TXDESC HWSEQEN is set and QoS field is also set,
-									// MAC will overwrite SEQ control by this.
-#define		N_QOS_SSN_Mask	0x0FFF
-
-//----------------------------------------------------------------------------
-//       8192C NEED_CPU_HANDLE bits				(Offset 0x4E0, 8 bits)
-//----------------------------------------------------------------------------
-#define		NEED_CPU_HANDLE_Q_SHIFT	0	// 1:HW prepare ok, this q need cpu handle & poll.
-#define		NEED_CPU_HANDLE_Q_Mask	0x03F
-
-//----------------------------------------------------------------------------
-//       8192C PTCL_ERR_STATUS bits				(Offset 0x4E1, 8 bits)
-//----------------------------------------------------------------------------
-#define		PTCL_TL_PG_OVF			BIT(7)	// Protocol Total Page out of range.
-#define		TXHANG_ERR				BIT(5)	// TX time is greater than 32ms.
-#define		HW_RD_NULL_STATUS_ERR	BIT(4)	// HW read null page counter error.
-#define		HW_RD_NULL_CTN_ERR		BIT(3)	// HW Contention read null page counter error.
-#define		HW_RD_NULL_CNT_ERR		BIT(2)	// HW read null page counter error.
-#define		PTCL_TL_PG_ERR				BIT(1)	// Protocol Total page number error.
-#define		DESC_QSEL_ERR				BIT(0)	// TXDESC QSEL field mismatch error.
-
-//----------------------------------------------------------------------------
-//       8192C PKT_LOSE_RPT bits					(Offset 0x4E2, 8 bits)
-//----------------------------------------------------------------------------
-#define		PKT_LOSE_BK		BIT(3)	// 1:queue happen pkt lose, 0:no lose.
-#define		PKT_LOSE_BE		BIT(2)	// 1:queue happen pkt lose, 0:no lose.
-#define		PKT_LOSE_VI		BIT(1)	// 1:queue happen pkt lose, 0:no lose.
-#define		PKT_LOSE_VO		BIT(0)	// 1:queue happen pkt lose, 0:no lose.
-
-
-//----------------------------------------------------------------------------
-//       8192C EDCA_VO_PARA bits				(Offset 0x500-503, 32 bits)
-//----------------------------------------------------------------------------
-//----------------------------------------------------------------------------
-//       8192C EDCA_VI_PARA bits				(Offset 0x504-507, 32 bits)
-//----------------------------------------------------------------------------
-//----------------------------------------------------------------------------
-//       8192C EDCA_BE_PARA bits				(Offset 0x508-50B, 32 bits)
-//----------------------------------------------------------------------------
-//----------------------------------------------------------------------------
-//       8192C EDCA_BK_PARA bits				(Offset 0x50C-50F, 32 bits)
-//----------------------------------------------------------------------------
-#define		TXOP_SHIFT			16	// TXOP Limit.
-#define		TXOP_Mask			0x0FFFF
-#define		CW_SHIFT			8	// ECWmax/ECWmin
-#define		CW_Mask			0x0FF
-#define		AIFS_SHIFT			0	// Arbitrary Inter frame space.
-#define		AIFS_Mask			0x0FF
-
-//----------------------------------------------------------------------------
-//       8192C BCNTCFG bits						(Offset 0x510-511, 16 bits)
-//----------------------------------------------------------------------------
-#define		BCNECW_SHIFT		8	// Beacon Contention Window.
-#define		BCNECW_Mask		0x0F
-#define		BCNIFS_SHIFT		0	// Beacon Interframe Space.
-#define		BCNIFS_Mask		0x0FF
-
-//----------------------------------------------------------------------------
-//       8192C SIFS_CCK bits						(Offset 0x514-515, 16 bits)
-//----------------------------------------------------------------------------
-//----------------------------------------------------------------------------
-//       8192C SIFS_OFDM bits					(Offset 0x516-517, 16 bits)
-//----------------------------------------------------------------------------
-#define		SIFS_TRX_SHIFT		8	// SIFS time required for any immediate response.
-#define		SIFS_TRX_Mask		0x0FF
-#define		SIFS_CTX_SHIFT		0	// SIFS time required for consecutive TX events.
-#define		SIFS_CTX_Mask		0x0FF
-
-//----------------------------------------------------------------------------
-//       8192C TX_PTCL_CTRL bits					(Offset 0x520-521, 16 bits)
-//----------------------------------------------------------------------------
-#define		DIS_CCA				BIT(15)	// bit=1, disable CCA.
-#define		SIFS_BK_EN				BIT(12)	// SIFS Break Check Criteria enable for AMPDU aggregation.
-#define		TXQ_NAV_MSK_SHIFT	8	// 1:Queue BKF must wait TX Nav finished, 0:Queue not need wait.
-#define		TXQ_NAV_MSK_Mask		0x0F
-#define		DIS_CW					BIT(7)	// bit=1, disable CW.
-#define		RDG_END_TXOP			BIT(6)	// 1:Nav protect all txop, 0:Nav protect to next pkt.
-#define		NAV_END_TXOP			BIT(5)	// 1:Nav protect all txop, 0:Nav protect to next pkt.
-#define		AC_INBCN_HOLD			BIT(4)	// bit=1, HI queue will be sent first, and then AC queue will be sent.
-#define		MGTQ_TXOP_EN			BIT(3)	// bit=1, MGTQ may sent packets by using ACQ TXOP.
-#define		MGTQ_RTSMF_HOLD		BIT(2)	// bit=1, MGTQ will be hold until RTS or MF transaction finished.
-#define		HIQ_RTSMF_HOLD		BIT(1)	// bit=1, HIQ will be hold until RTS or MF transaction finished.
-#define		BCN_RTSMF_HOLD		BIT(0)	// bit=1, BCNQ will be hold until RTS or MF transaction finished.
-
-//----------------------------------------------------------------------------
-//       8192C TXPAUSE bits						(Offset 0x522, 8 bits)
-//----------------------------------------------------------------------------
-#define		STOP_BCN			BIT(6)	// Stop BCNQ Queue.
-#define		STOP_HI			BIT(5)	// Stop High Queue.
-#define		STOP_MGT			BIT(4)	// Stop Management Queue.
-#define		STOP_VO			BIT(3)	// Stop VO Queue.
-#define		STOP_VI				BIT(2)	// Stop VI Queue.
-#define		STOP_BE			BIT(1)	// Stop BE Queue.
-#define		STOP_BK			BIT(0)	// Stop BK Queue.
-
-//----------------------------------------------------------------------------
-//       8192C DIS_TXREQ_CLR bits				(Offset 0x523, 8 bits)
-//----------------------------------------------------------------------------
-#define		DIS_TXREQ_CLR_BCN		BIT(7)	// 1:if queue can't own channel ,txcmd will be cleared;0:Only TX_finish can clear txreq.
-#define		DIS_TXREQ_CLR_HI		BIT(5)	// 1:if queue can't own channel ,txcmd will be cleared;0:Only TX_finish can clear txreq.
-#define		DIS_TXREQ_CLR_MGQ		BIT(4)	// 1:if queue can't own channel ,txcmd will be cleared;0:Only TX_finish can clear txreq.
-#define		DIS_TXREQ_CLR_VO		BIT(3)	// 1:if queue can't own channel ,txcmd will be cleared;0:Only TX_finish can clear txreq.
-#define		DIS_TXREQ_CLR_VI		BIT(2)	// 1:if queue can't own channel ,txcmd will be cleared;0:Only TX_finish can clear txreq.
-#define		DIS_TXREQ_CLR_BE		BIT(1)	// 1:if queue can't own channel ,txcmd will be cleared;0:Only TX_finish can clear txreq.
-#define		DIS_TXREQ_CLR_BK		BIT(0)	// 1:if queue can't own channel ,txcmd will be cleared;0:Only TX_finish can clear txreq.
-
-//----------------------------------------------------------------------------
-//       8192C RD_CTRL bits						(Offset 0x524-525, 16 bits)
-//----------------------------------------------------------------------------
-#define		EDCCA_MSK_CNTDWN		BIT(11)	// 1: disable, 0: enable,  EDCCA count down.
-#define		DIS_TXOP_CFE			BIT(10)	// Disable TXOP_CFE function.
-#define		DIS_LSIG_CFE			BIT(9)	// Disable LSIG_TXOP CF-END function.
-#define		DIS_STBC_CFE			BIT(8)	// Disable STBC CF-END function.
-#define		BKQ_RD_INIT_EN		BIT(7)	//
-#define		BEQ_RD_INIT_EN		BIT(6)	//
-#define		VIQ_RD_INIT_EN			BIT(5)	//
-#define		VOQ_RD_INIT_EN		BIT(4)	//
-#define		BKQ_RD_RESP_EN		BIT(3)	//
-#define		BEQ_RD_RESP_EN		BIT(2)	//
-#define		VIQ_RD_RESP_EN		BIT(1)	//
-#define		VOQ_RD_RESP_EN		BIT(0)	//
-
-//----------------------------------------------------------------------------
-//       8192C TBTT_PROHIBIT bits				(Offset 0x540-541, 16 bits)
-//----------------------------------------------------------------------------
-#define		TBTT_HOLD_TIME_SHIFT			8	// TBTT_prohibit_hold, unit is 32 us.
-#define		TBTT_HOLD_TIME_Mask			0xFFFFFF
-#define		TBTT_PROHIBIT_SETUP_SHIFT	0	// TBTT_prohibit_setup, unit is 32us.
-#define		TBTT_PROHIBIT_SETUP_Mask		0x0F
-
-//----------------------------------------------------------------------------
-//       8192C BCN_CTRL bits					(Offset 0x550, 8 bits)
-//----------------------------------------------------------------------------
-
-#define 	DIS_SUB_STATE		BIT(4)
-#define 	DIS_SUB_STATE_N		BIT(1)
-#define 	DIS_TSF_UPDATE		BIT(5)
-#define 	DIS_TSF_UPDATE_N	BIT(4)
-#define 	DIS_ATIM			BIT(0)
-
-
-#define		BCN0_AUTO_SYNC	BIT(5)	// When this bit is set, TSFTR will update the timestamp in Beacon matched BSSID.
-#define		DIS_TSF_UPT		BIT(4)	// 92D_REG, When this bit is set, tsf will not update
-#define		EN_BCN_FUNCTION	BIT(3)	// bit=1, TSF and other beacon related functions are then enabled.
-#define		EN_TXBCN_RPT		BIT(2)	//
-#define		EN_MBSSID			BIT(1)	//
-#define		PBCNQSEL			BIT(0)	//
-
-//----------------------------------------------------------------------------
-//       8192C USTIME_TSF bits					(Offset 0x551, 8 bits)
-//----------------------------------------------------------------------------
-#define		USTIME_TSF_TIME_SHIFT	0	// Set the microsecond time unit used by MAC TSF clock.
-#define		USTIME_TSF_TIME_Mask		0x03F
-
-//----------------------------------------------------------------------------
-//       8192C MBID_NUM bits					(Offset 0x552, 8 bits)
-//----------------------------------------------------------------------------
-#define		MBID_BCN_NUM_SHIFT	0	// num of virtual interface num excluding the root.
-#define		MBID_BCN_NUM_Mask	0x07
-
-//----------------------------------------------------------------------------
-//       8192C MBSSID_BCN_SPACE bits			(Offset 0x554-557, 32 bits)
-//----------------------------------------------------------------------------
-#define		BCN_SPACE2_SHIFT	16	//
-#define		BCN_SPACE2_Mask	0x0FFFF
-#define		BCN_SPACE1_SHIFT	0	//
-#define		BCN_SPACE1_Mask	0x0FFFF
-
-//----------------------------------------------------------------------------
-//       8192C ACMHWCTRL bits					(Offset 0x5C0, 8 bits)
-//----------------------------------------------------------------------------
-#define		VOQ_ACM_STATUS	BIT(6)	// indicates if the used_time >= admitted_time of AC VO when HW ACM.
-#define		VIQ_ACM_STATUS	BIT(5)	// indicates if the used_time >= admitted_time of AC VI when HW ACM.
-#define		BEQ_ACM_STATUS	BIT(4)	// indicates if the used_time >= admitted_time of AC BE when HW ACM.
-#define		VOQ_ACM_EN		BIT(3)	// enable ACM of VO queue.
-#define		VIQ_ACM_EN			BIT(2)	// enable ACM of VI queue.
-#define		BEQ_ACM_EN		BIT(1)	// enable ACM of BE queue.
-#define		ACMHWEN			BIT(0)	// enable hardware to take control of ACM.
-
-//----------------------------------------------------------------------------
-//       8192C ACMRSTCTRL bits					(Offset 0x5C1, 8 bits)
-//----------------------------------------------------------------------------
-#define		VO_ACM_RST_USED_TIME		BIT(2)	// HwEn enabled, sw set this to inform hw to reset used_time.
-#define		BE_ACM_RST_USED_TIME		BIT(1)	// HwEn enabled, sw set this to inform hw to reset used_time.
-#define		VI_ACM_RST_USED_TIME		BIT(0)	// HwEn enabled, sw set this to inform hw to reset used_time.
-
-
-//
-// 6. WMAC Configuration. (Offset 0x600 - 0x7FFh)
-//
-//----------------------------------------------------------------------------
-//       8192C APSD_CTRL bits					(Offset 0x600, 8 bits)
-//----------------------------------------------------------------------------
-#define		APSDOFF_STATUS	BIT(7)	//
-#define		APSDOFF			BIT(6)	// bit=1, MAC issue sleep signal to disable BB/AFE/RF TRX function.
-
-//----------------------------------------------------------------------------
-//       8192C BWOPMODE bits					(Offset 0x603, 8 bits)
-//----------------------------------------------------------------------------
-#define		BW_20M				BIT(2)	// bit=1 indicate operating in 20Mhz bandwidth.
-
-//----------------------------------------------------------------------------
-//       8192C TCR bits							(Offset 0x604-607, 32 bits)
-//----------------------------------------------------------------------------
-#define		TSFT_CMP_SHIFT	16		// TSFT insertion compensation value.
-#define		TSFT_CMP_Mask		0x0FF
-#define		WMAC_TCR_ERRSTEN3		BIT(15)	// 92D_REG, Use phytxend_ps to reset mactx state machine
-#define		WMAC_TCR_ERRSTEN2		BIT(14)	// 92D_REG, If txd fifo underflow when txtype is cmpba, reset mactx state machine
-#define		WMAC_TCR_ERRSTEN1		BIT(13)	// 92D_REG, If txd fifo underflow, reset mactx state machine
-#define		WMAC_TCR_ERRSTEN0		BIT(12)	// 92D_REG, Phytxend_ps comes but mactx still active, reset mactx state machine
-#define		WMAC_TCR_TXSK_PERPKT		BIT(11)	// 92D_REG, Serche key for each mpdu
-#define		ICV					BIT(10)	// Integrity Check Value.
-#define		CFE_FORM			BIT(9)	// CF-End Frame Format.
-#define		CRC					BIT(8)	// Append 32-bit Cyclic Redundancy Check.
-#define		PWRBIT_OW_EN		BIT(7)	// bit=1, MAC overwrite pwr bit according to PWR_ST for data frame.
-#define		PWR_ST				BIT(6)	// MAC will overwrite pwr bit accroding to PWR_ST for data frame.
-#define		PAD_SEL			BIT(2)	// AMPDU Padding pattern selection.
-#define		DIS_GCLK			BIT(1)	// Disable MACTX clock gating control.
-#define		TSFRST				BIT(0)	// Reset TSF Timer to zero.
-
-//----------------------------------------------------------------------------
-//       8192C RCR bits							(Offset 0x608-60B, 32 bits)
-//----------------------------------------------------------------------------
-#define		RCR_APP_FCS		BIT(31)	// wmac RX will append FCS after payload.
-#define		RCR_APP_MIC		BIT(30)	// bit=1, MACRX will retain the MIC at the bottom of the packet.
-#define		RCR_APP_ICV		BIT(29)	// bit=1, MACRX will retain the ICV at the bottom of the packet.
-#define		RCR_APP_PHYSTS	BIT(28)	// Append RXFF0 PHY Status Enable.
-#define		RCR_APP_BASSN		BIT(27)	// Append SSN of previous TXBA Enable.
-#define		RCR_MBID_EN		BIT(24)	// Enable Multiple BssId.
-#define		RCR_LSIGEN			BIT(23)	// Enable LSIG TXOP Protection function.
-#define		RCR_MFBEN			BIT(22)	// Enable immediate MCS Feedback function.
-#define		RCR_BM_DATA_EN	BIT(17)	// BM_DATA_EN.
-#define		RCR_UC_DATA_EN	BIT(16)	// Unicast data packet interrupt enable.
-#define		RCR_HTC_LOC_CTRL	BIT(14)	// 1: HTC -> MFC, 0: MFC-> HTC.
-#define		RCR_AMF			BIT(13)	// Accept Management Frame.
-#define		RCR_ACF			BIT(12)	// Accept Control Frame.
-#define		RCR_ADF			BIT(11)	// Accept Data Frame.
-#define		RCR_AICV			BIT(9)	// Accept Integrity Check Value Error packets.
-#define		RCR_ACRC32			BIT(8)	// Accept CRC32 Error packets.
-
-#define		RCR_CBSSID_ADHOC		(BIT(6)|BIT(7))	// Check BSSID.
-#define		RCR_CBSSID			BIT(6)	// Check BSSID.
-#define		RCR_APWRMGT		BIT(5)	// Accept Power Management Packet.
-#define		RCR_ADD3			BIT(4)	// Accept Address 3 Match Packets.
-#define		RCR_AB				BIT(3)	// Accept Broadcast packets.
-#define		RCR_AM				BIT(2)	// Accept Multicast packets.
-#define		RCR_APM			BIT(1)	// Accept Physical Match packets.
-#define		RCR_AAP			BIT(0)	// Accept Destination Address packets.
-
-//----------------------------------------------------------------------------
-//       8192C RX_PKT_LIMIT bits					(Offset 0x60C, 8 bits)
-//----------------------------------------------------------------------------
-#define		RXPKTLMT_SHIFT	0	// RX PKT Upper Limit.
-#define		RXPKTLMT_Mask		0x03F
-
-// 		MACID Setting Register. (Offset 0x610 - 0x62Fh)
-//----------------------------------------------------------------------------
-//       8192C MBIDCAMCFG bits					(Offset 0x628-62F, 64 bits)
-//----------------------------------------------------------------------------
-#define		MBIDCAM_POLL		BIT(31)	// Pooling bit.
-#define		MBIDWRITE_EN		BIT(30)	// Write Enable.
-#define		MBIDCAM_ADDR_SHIFT	24	// CAM Address.
-#define		MBIDCAM_ADDR_Mask	0x01F
-#define		MBIDCAM_VALID		BIT(23)	// CAM Valid bit.
-
-// 		MACID Setting Register. (Offset 0x610 - 0x62Fh)
-
-// 		Timing Control Register. (Offset 0x630 - 0x64Fh)
-//----------------------------------------------------------------------------
-//       8192C SPEC_SIFS bits					(Offset 0x63A-63B, 16 bits)
-//----------------------------------------------------------------------------
-#define		SPEC_SIFS_OFDM_SHIFT	8	// SIFS value for duration calculation.
-#define		SPEC_SIFS_OFDM_Mask	0x0FF
-#define		SPEC_SIFS_CCK_SHIFT	0	// SIFS value for duration calculation.
-#define		SPEC_SIFS_CCK_Mask	0x0FF
-
-//----------------------------------------------------------------------------
-//       8192C RESP_SIFS_CCK bits				(Offset 0x63C-63D, 16 bits)
-//----------------------------------------------------------------------------
-//----------------------------------------------------------------------------
-//       8192C RESP_SIFS_OFDM bits				(Offset 0x63E-63F, 16 bits)
-//----------------------------------------------------------------------------
-#define		SIFS_R2T_SHIFT		8	// SIFS time required for any immediate response.
-#define		SIFS_R2T_Mask		0x0FF
-#define		SIFS_T2T_SHIFT		0	// SIFS time required for consecutive TX events.
-#define		SIFS_T2T_Mask		0x0FF
-
-// 		Timing Control Register. (Offset 0x630 - 0x64Fh)
-
-// 		WMAC, BA, CCX Related Register. (Offset 0x650 - 0x66Fh)
-//----------------------------------------------------------------------------
-//       8192C NAV_CTRL bits					(Offset 0x650-651, 16 bits)
-//----------------------------------------------------------------------------
-#define		NAV_UPPER_SHIFT	8	// When NAV update is beyond this, then update is aborted.
-#define		NAV_UPPER_Mask	0x0FF
-#define		RTSRST_SHIFT		0	// RTS NAV Reset Time.
-#define		RTSRST_Mask		0x0FF
-
-//----------------------------------------------------------------------------
-//       8192C BACAMCMD bits					(Offset 0x654-657, 32 bits)
-//----------------------------------------------------------------------------
-#define		BACAM_POLL			BIT(31)	// Polling bit BA CAM.
-#define		BACAM_RST			BIT(17)	// 1 to reset BA CAM. HW set invalid bit for all entries.
-#define		BACAM_RW			BIT(16)	// 1=Write, 0=Read.
-#define		BACAM_ADDR_SHIFT	0	// BA CAM address. Memory is double-word access.
-#define		BACAM_ADDR_Mask	0x03F
-
-//----------------------------------------------------------------------------
-//       8192C LBDLY bits						(Offset 0x660, 8 bits)
-//----------------------------------------------------------------------------
-#define		LBDLY_LMT_SHIFT	0	// Loopback Delay.
-#define		LBDLY_LMT_Mask	0x01F
-
-//----------------------------------------------------------------------------
-//       8192C FWDLY bits						(Offset 0x661, 8 bits)
-//----------------------------------------------------------------------------
-#define		FWDLY_LMT_SHIFT	0	// Firmware Delay.
-#define		FWDLY_LMT_Mask	0x0F
-
-//----------------------------------------------------------------------------
-//       8192C RXERR_RPT bits					(Offset 0x664-667, 32 bits)
-//----------------------------------------------------------------------------
-#define		RXERR_RPT_SEL_SHIFT	28	//
-#define		RXERR_RPT_SEL_Mask	0x0F
-#define		RXERR_RPT_RST			BIT(27)	// Write "one" to set the counter to zero.
-#define		RPT_COUNTER_SHIFT		0	// reported value corresponding to Report type selected.
-#define		RPT_COUNTER_Mask		0x0FFFFF
-
-//----------------------------------------------------------------------------
-//       8192C WMAC_TRXPTCL_CTL bits			(Offset 0x668-66F, 64 bits)
-//----------------------------------------------------------------------------
-#define		ACKBA_TYPSEL_SHIFT		28	// Determine response type for RX BA.
-#define		ACKBA_TYPSEL_Mask			0x0F
-#define		ACKBA_ACKPCHK_SHIFT		24	//
-#define		ACKBA_ACKPCHK_Mask		0x0F
-#define		ACKBAR_ACKPCHK_SHIFT		12	//
-#define		ACKBAR_ACKPCHK_Mask		0x0F
-#define		DIS_TXBA_AMPDUFCSERR		BIT(4)	// Disable to send BA for responding RX AMPDU with FCS error subframe.
-#define		DIS_TXBA_RXBARINFULL		BIT(3)	// Disable send BA for responding RX control wrapper BAR dropped by rxpkbuffer full.
-#define		DIS_TXCFE_INFULL			BIT(2)	// Disable send CFE for responding RX control wrapper CFE dropped by rxpktbuffer full.
-#define		DIS_TXCTS_INFULL			BIT(1)	// Disable send CTS for responding RX control wrapper RTS dropped by rxpktbuffer full.
-#define		EN_TXCTS_INTXOP			BIT(0)	// Enable send CTS for responding RX RTS during our TXOP period.
-
-#define		RESP_CHNBUSY_SHIFT		20	// Define channel busy condition in responder to determine RX busy.
-#define		RESP_CHNBUSY_Mask		0x03
-#define		RESP_DCTS_EN				BIT(19)	// Enable responder send dual CTS for responding Rx RTS.
-#define		RESP_DCFE_EN				BIT(18)	// Enable responder send dual CF-END for responding RX CF-END.
-#define		RESP_SPLCPEN				BIT(17)	// Enable responder send SPLCP CCK rsp for acknowledging Rx SPLCP CCK.
-#define		RESP_SGIEN					BIT(16)	// Enable responder send SGI HT-OFDM rsp for acknowledging Rx SGI HT-OFDM pkt.
-
-// 		WMAC, BA, CCX Related Register. (Offset 0x650 - 0x66Fh)
-
-// 		Security Control Register. (Offset 0x670 - 0x68Fh)
-//----------------------------------------------------------------------------
-//       8192C CAMCMD bits						(Offset 0x670-673, 32 bits)
-//----------------------------------------------------------------------------
-#define		SECCAM_POLL			BIT(31)	// Security CAM Polling.
-#define		SECCAM_CLR				BIT(30)	// Set 1 to clear all valid bits in CAM.
-#define		MFBCAM_CLR			BIT(29)	// Write 1 to clear all MFB value in CAM.
-#define		SECCAM_WE				BIT(16)	// Security CAM Write Enable.
-#define		SECCAM_ADDR_SHIFT	0	// Security CAM Address Offset.
-#define		SECCAM_ADDR_Mask		0x0FF
-
-//----------------------------------------------------------------------------
-//       8192C CAMDBG bits						(Offset 0x67C-67F, 32 bits)
-//----------------------------------------------------------------------------
-#define		SECCAM_INFO				BIT(31)	// Select TX/RX CAM Information.
-#define		SEC_KEYFOUND				BIT(30)	// Security Key Found in CAM.
-#define		SEC_CONFIG_SHIFT			24	// Security Configuration.
-#define		SEC_CONFIG_Mask			0x03F
-#define		SEC_KEYCONTENT_SHIFT		0	// Security CAM Address Offset.
-#define		SEC_KEYCONTENT_Mask		0x0FFFFFF
-
-//----------------------------------------------------------------------------
-//       8192C SECCFG bits						(Offset 0x680, 8 bits)
-//----------------------------------------------------------------------------
-#define		CHK_KEYID			BIT(8)	// Key search engine need to check if key ID matched
-#define		RXBCUSEDK			BIT(7)	// Force RX Broadcast packets Use Default Key
-#define		TXBCUSEDK			BIT(6)	// Force Tx Broadcast packets Use Default Key
-#define		NOSKMC				BIT(5)	// No Key Search for Multicast.
-#define		SKBYA2				BIT(4)	// Search Key by A2.
-#define		RXDEC				BIT(3)	// Enable Rx Decryption.
-#define		TXENC				BIT(2)	// Enable Tx Encryption.
-#define		RXUSEDK			BIT(1)	// Force Rx Use Default Key.
-#define		TXUSEDK			BIT(0)	// Force Tx Use Default Key.
-
-// 		Security Control Register. (Offset 0x670 - 0x68Fh)
-
-// 		Power Save Control Register. (Offset 0x690 - 0x69Fh)
-//----------------------------------------------------------------------------
-//       8192C WOW_CTRL bits					(Offset 0x690, 8 bits)
-//----------------------------------------------------------------------------
-#define		FORCE_WAKEUP		BIT(7)	// Let Wakeup PIN be controllable by FW/Driver.
-#define		UWF				BIT(3)	// Unicast Wakeup Frame.
-#define		MAGIC				BIT(2)	// Magic Packet.
-#define		WOWEN				BIT(1)	// WoW function on or off.
-#define		PMEN				BIT(0)	// Power Management Enable.
-
-//----------------------------------------------------------------------------
-//       8192C PSSTATUS bits					(Offset 0x691, 8 bits)
-//----------------------------------------------------------------------------
-#define		PSSTATUS_SEL_SHIFT	0	// Indicate the present power save mode.
-#define		PSSTATUS_SEL_Mask		0x0F
-
-//----------------------------------------------------------------------------
-//       8192C PS_RX_INFO bits					(Offset 0x692, 8 bits)
-//----------------------------------------------------------------------------
-#define		RXCTRLIN0			BIT(4)	// set to 1 if NIC received control frame with correct BSSID and DA.
-#define		RXMGTIN0			BIT(3)	// set to 1 if NIC received management frame with correct BSSID and DA.
-#define		RXDATAIN2			BIT(2)	// set to 1 if NIC received data frame with correct BSSID and DA.
-#define		RXDATAIN1			BIT(1)	// set to 1 if NIC received data frame with correct BSSID and DA.
-#define		RXDATAIN0			BIT(0)	// set to 1 if NIC received data frame with correct BSSID and DA.
-
-//----------------------------------------------------------------------------
-//       8192C LPNAV_CTRL bits					(Offset 0x694-697, 32 bits)
-//----------------------------------------------------------------------------
-#define		LPNAV_EN				BIT(31)	// Low Power NAV Mode Enable.
-#define		LPNAV_EARLY_SHIFT		16	// in LPNAV mode, MAC will recall BB & RF into RX idle mode.
-#define		LPNAV_EARLY_Mask		0x07FFF
-#define		LPNAV_TH_SHIFT		0	// When NAV received is greater than this, then MAC enters LPNAV mode.
-#define		LPNAV_TH_Mask			0x0FFFF
-
-//----------------------------------------------------------------------------
-//       8192C WKFMCAM_CMD bits				(Offset 0x698-69B, 32 bits)
-//----------------------------------------------------------------------------
-#define		WKFCAM_POLL			BIT(31)	// Wakeup Mask CAM Polling.
-#define		WKFCAM_CLR			BIT(30)	// Set to one to clear all valid bits in CAM. After reset will self clear to 0.
-#define		WKFCAM_WE				BIT(16)	// Wakeup Mask CAM Write Enable.
-#define		WKFCAM_ADDR_SHIFT	0	// Wakeup Mask CAM Address Offset.
-#define		WKFCAM_ADDR_Mask		0x03F
-
-// 		Power Save Control Register. (Offset 0x690 - 0x69Fh)
-
-// 		General Purpose Register. (Offset 0x6A0 - 0x6AFh)
-//----------------------------------------------------------------------------
-//       8192C RXFLTMAP0 bits					(Offset 0x6A0-6A1, 16 bits)
-//----------------------------------------------------------------------------
-#define		MGTFLTD_EN		BIT(13)	//
-#define		MGTFLTC_EN			BIT(12)	//
-#define		MGTFLTB_EN			BIT(11)	//
-#define		MGTFLTA_EN		BIT(10)	//
-#define		MGTFLT9_EN			BIT(9)	//
-#define		MGTFLT8_EN			BIT(8)	//
-#define		MGTFLT5_EN			BIT(5)	//
-#define		MGTFLT4_EN			BIT(4)	//
-#define		MGTFLT3_EN			BIT(3)	//
-#define		MGTFLT2_EN			BIT(2)	//
-#define		MGTFLT1_EN			BIT(1)	//
-#define		MGTFLT0_EN			BIT(0)	//
-
-//----------------------------------------------------------------------------
-//       8192C RXFLTMAP1 bits					(Offset 0x6A2-6A3, 16 bits)
-//----------------------------------------------------------------------------
-#define		CTRLFLTF_EN		BIT(15)	//
-#define		CTRLFLTE_EN		BIT(14)	//
-#define		CTRLFLTD_EN		BIT(13)	//
-#define		CTRLFLTC_EN		BIT(12)	//
-#define		CTRLFLTB_EN		BIT(11)	//
-#define		CTRLFLTA_EN		BIT(10)	//
-#define		CTRLFLT9_EN		BIT(9)	//
-#define		CTRLFLT8_EN		BIT(8)	//
-#define		CTRLFLT7_EN		BIT(7)	//
-#define		CTRLFLT6_EN		BIT(6)	//
-
-//----------------------------------------------------------------------------
-//       8192C RXFLTMAP2 bits					(Offset 0x6A4-6A5, 16 bits)
-//----------------------------------------------------------------------------
-#define		DATAFLTF_EN		BIT(15)	//
-#define		DATAFLTE_EN		BIT(14)	//
-#define		DATAFLTD_EN		BIT(13)	//
-#define		DATAFLTC_EN		BIT(12)	//
-#define		DATAFLTB_EN		BIT(11)	//
-#define		DATAFLTA_EN		BIT(10)	//
-#define		DATAFLT9_EN		BIT(9)	//
-#define		DATAFLT8_EN		BIT(8)	//
-#define		DATAFLT7_EN		BIT(7)	//
-#define		DATAFLT6_EN		BIT(6)	//
-#define		DATAFLT5_EN		BIT(5)	//
-#define		DATAFLT4_EN		BIT(4)	//
-#define		DATAFLT3_EN		BIT(3)	//
-#define		DATAFLT2_EN		BIT(2)	//
-#define		DATAFLT1_EN		BIT(1)	//
-#define		DATAFLT0_EN		BIT(0)	//
-
-//----------------------------------------------------------------------------
-//       8192C BCN_PSR_RPT bits					(Offset 0x6A8-6AB, 32 bits)
-//----------------------------------------------------------------------------
-#define		DTIM_CNT_SHIFT	24	//
-#define		DTIM_CNT_Mask		0x0FF
-#define		DTIM_PERIOD_SHIFT	16	//
-#define		DTIM_PERIOD_Mask	0x0FF
-#define		DTIM				BIT(15)	//
-#define		TIM					BIT(14)	//
-#define		PS_AID_SHIFT		0	//
-#define		PS_AID_Mask		0x07FF
-
-//----------------------------------------------------------------------------
-//       8192C CALB32K_CTRL bits				(Offset 0x6AC-6AF, 32 bits)
-//----------------------------------------------------------------------------
-#define		CALB32K_POLL		BIT(31)	//
-#define		CALB32K_DONE		BIT(30)	//
-#define		CAL_TIME_SHIFT		20	// Calibration time.
-#define		CAL_TIME_Mask		0x03FF
-#define		CAL_REPORT_SHIFT	0	//
-#define		CAL_REPORT_Mask	0x0FFFFF
-
-// 		General Purpose Register. (Offset 0x6A0 - 0x6AFh)
-
-//----------------------------------------------------------------------------
-//       8192C BT_COEX_TABLE bits				(Offset 0x6C0-6CF, 128 bits)
-//----------------------------------------------------------------------------
-#define		PRI_MASK_RX_RSP			BIT(30)	// Priority Mask for Rx Response Packet.
-#define		PRI_MASK_RX_OFDM			BIT(29)	// Priority Mask for Rx OFDM.
-#define		PRI_MASK_RX_CCK			BIT(28)	// Priority Mask for Rx CCK.
-#define		PRI_MASK_TX_Q_SHIFT		21	// Priority Mask for Tx Queue.
-#define		PRI_MASK_TX_Q_Mask		0x07F
-#define		PRI_MASK_TX_NAV_SHIFT	13	// Priority Mask for Tx NAV.
-#define		PRI_MASK_TX_NAV_Mask		0x0FF
-#define		PRI_MASK_TX_CCK			BIT(12)	// Priority Mask for Tx CCK.
-#define		PRI_MASK_TX_OFDM			BIT(11)	// Priority Mask for Tx OFDM.
-#define		PRI_MASK_TX_RTY			BIT(10)	// Priority Mask for Tx Retry packet.
-#define		PRI_MASK_TX_NUM_SHIFT	6	// Priority Mask for Tx packet num.
-#define		PRI_MASK_TX_NUM_Mask		0x0F
-#define		PRI_MASK_TX_TYPE_SHIFT	2	// Priority Mask for Tx packet type.
-#define		PRI_MASK_TX_TYPE_Mask	0x0F
-#define		C_OOB						BIT(1)	// out of band indication (0:in band,1:out of band).
-#define		ANT_SEL					BIT(0)	// single or dual antenna selection (0:single,1:dual).
-
-#define		BREAK_TABLE2_SHIFT		16	// Table used to break WLAN activity.
-#define		BREAK_TABLE2_Mask			0x0FFFF
-#define		BREAK_TABLE1_SHIFT		0	// Table used to break BT activity.
-#define		BREAK_TABLE1_Mask			0x0FFFF
-
-//----------------------------------------------------------------------------
-//       8192C WMAC_RESP_TXINFO bits			(Offset 0x6D8-6DA, 24 bits)
-//----------------------------------------------------------------------------
-#define		RESP_TXAGC_B_SHIFT	13	//
-#define		RESP_TXAGC_B_Mask		0x01F
-#define		RESP_TXAGC_A_SHIFT	8	//
-#define		RESP_TXAGC_A_Mask	0x01F
-#define		RESP_ANTSEL_B			BIT(7)	//
-#define		RESP_ANTSEL_A			BIT(6)	//
-#define		RESP_TXANT_CCK_SHIFT	4	//
-#define		RESP_TXANT_CCK_Mask	0x03
-#define		RESP_TXANT_L_SHIFT	2	//
-#define		RESP_TXANT_L_Mask		0x03
-#define		RESP_TXANT_HT_SHIFT	0	//
-#define		RESP_TXANT_HT_Mask	0x03
-
-/*
-//----------------------------------------------------------------------------
-//       8192C Rate Definition
-//----------------------------------------------------------------------------
-//CCK
-#define		RATR_1M				0x00000001
-#define		RATR_2M				0x00000002
-#define		RATR_55M				0x00000004
-#define		RATR_11M				0x00000008
-//OFDM
-#define		RATR_6M				0x00000010
-#define		RATR_9M				0x00000020
-#define		RATR_12M				0x00000040
-#define		RATR_18M				0x00000080
-#define		RATR_24M				0x00000100
-#define		RATR_36M				0x00000200
-#define		RATR_48M				0x00000400
-#define		RATR_54M				0x00000800
-//MCS 1 Spatial Stream
-#define		RATR_MCS0				0x00001000
-#define		RATR_MCS1				0x00002000
-#define		RATR_MCS2				0x00004000
-#define		RATR_MCS3				0x00008000
-#define		RATR_MCS4				0x00010000
-#define		RATR_MCS5				0x00020000
-#define		RATR_MCS6				0x00040000
-#define		RATR_MCS7				0x00080000
-//MCS 2 Spatial Stream
-#define		RATR_MCS8				0x00100000
-#define		RATR_MCS9				0x00200000
-#define		RATR_MCS10				0x00400000
-#define		RATR_MCS11				0x00800000
-#define		RATR_MCS12				0x01000000
-#define		RATR_MCS13				0x02000000
-#define		RATR_MCS14				0x04000000
-#define		RATR_MCS15				0x08000000
-// ALL CCK Rate
-#define	RATE_ALL_CCK				RATR_1M|RATR_2M|RATR_55M|RATR_11M
-#define	RATE_ALL_OFDM_AG			RATR_6M|RATR_9M|RATR_12M|RATR_18M|RATR_24M|\
-									RATR_36M|RATR_48M|RATR_54M
-#define	RATE_ALL_OFDM_1SS			RATR_MCS0|RATR_MCS1|RATR_MCS2|RATR_MCS3 |\
-									RATR_MCS4|RATR_MCS5|RATR_MCS6	|RATR_MCS7
-#define	RATE_ALL_OFDM_2SS			RATR_MCS8|RATR_MCS9	|RATR_MCS10|RATR_MCS11|\
-									RATR_MCS12|RATR_MCS13|RATR_MCS14|RATR_MCS15
-*/
-
-#endif // #ifndef __INC_HAL8192SEREG_H
-
+/*
+ *  Header file of 8192C register
+ *
+ *	 $Id: 8192c_reg.h,v 1.7.2.2 2010/09/20 09:00:10 button Exp $
+ *
+ *  Copyright (c) 2009 Realtek Semiconductor Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef _8192C_REG_H_
+#define _8192C_REG_H_
+
+//============================================================
+//       8192C Regsiter offset definition
+//============================================================
+
+
+//
+// MAC register 0x000 - 0x6AFh
+// 1. System Configure Register. (Offset 0x000 - 0x0FFh)
+// 2. MACTOP General Configuration. (Offset 0x100 - 0x1FFh)
+//		General Purpose Timer. (Offset 0x150 - 0x16Fh)
+// 3. TXDMA/RXDMA Configuration. (Offset 0x200 - 0x2FFh)
+// 4. PCIE EMAC Reserved Region. (Offset 0x300 - 0x3FFh)
+// 5. PTCL/EDCA Configuration. (Offset 0x400 - 0x4FFh)
+// 6. WMAC Configuration. (Offset 0x600 - 0x7FFh)
+// 		MACID Setting Register. (Offset 0x610 - 0x62Fh)
+// 		Timing Control Register. (Offset 0x630 - 0x64Fh)
+// 		WMAC, BA, CCX Related Register. (Offset 0x650 - 0x66Fh)
+// 		Security Control Register. (Offset 0x670 - 0x68Fh)
+// 		Power Save Control Register. (Offset 0x690 - 0x69Fh)
+// 		General Purpose Register. (Offset 0x6A0 - 0x6AFh)
+//
+
+
+//
+// 1. System Configure Register. (Offset 0x000 - 0x0FFh)
+//
+#define		SYS_ISO_CTRL		0x000	// System Isolation Interface Control.
+#define		SYS_FUNC_EN		0x002	// System Function Enable.
+#define		APS_FSMCO			0x004	// Auto Power Sequence Control/Option.
+#define		SYS_CLKR			0x008	// System Clock.
+#define		CR9346				0x00A	// 93C46 (93C56) Command.
+#define		EE_VPD				0x00C	// EEPROM VPD Data.
+#define		AFE_MISC			0x010	// AFE Misc.
+#define		SPS0_CTRL			0x011	// Switching Power Supply 0 Control.
+#define		SPS_OCP_CFG		0x018	// SPS Over Current Protection Configuration.
+#define		RSV_CTRL0			0x01C	// Reserved Control.
+#define		RF_CTRL				0x01F	// RF Block Control.
+#define		LDOA15_CTRL		0x020	// V15 Digital LDO Control.
+#define		LDOV12D_CTRL		0x021	// V12 Digital LDO Control.
+#define		LDOHCI12_CTRL		0x022	// V12 Digital LDO Control.
+#define		LPLDO_CTRL			0x023	// Low Power LDO Control.
+#define		AFE_XTAL_CTRL		0x024	// AFE Crystal Control.
+#define		AFE_PLL_CTRL		0x028	// AFE_PLL_CTRL Enable.
+#define		RSV_CTRL1			0x02C	// Reserved Control.
+#define		EFUSE_CTRL			0x030	// E-Fuse Control.
+#define		EFUSE_TEST			0x034	// E-Fuse Test Control.
+#define		PWR_DATA			0x038	// Power on Data.
+#define		CAL_TIMER			0x03C	// Hardware Calibration Timer.
+#define		ACLK_MON			0x03E	// Analog Clock Monitor.
+#define		GPIO_MUXCFG		0x040	// GPIO_MUX Configuration.
+#define		GPIO_PIN_CTRL		0x044	// GPIO[7:0] PIN Control.
+#define		GPIO_INTM			0x048	// GPIO Interrupt Monitor Register.
+#define		LEDCFG				0x04C	// System PINMUX Configuration.
+#define		FSIMR				0x050	// Firmware System Interrupt Mask.
+#define		FSISR				0x054	// Firmware System Interrupt Status.
+
+#define		MCUFWDL			0x080	// MCU Firmware Down Load Control.
+#define		MCUTSTCFG			0x084	// MCU Firmware Test Configuration.
+#define		MCUDMSG_I			0x088	// MCU Firmware Debug Message.
+#define		MCUDMSG_II			0x08C	// MCU Firmware Debug Message.
+
+#define		BIST_CTRL			0x0D0  	// BIST/SCAN CONTROL
+#define		C_BIST_RPT			0x0D4  	// BIST Report
+#define		BIST_ROM_RPT		0x0D8  	// BIST ROM Report
+#define		USB_SIE_INTF		0x0E0  	// USB SIE Access Interface
+#define		PCIE_MIO_INTF		0x0E4  	// PCIE MIO Access Interface
+#define		PCIE_MIO_INTD		0x0E8	// PCIE MIO Access Interface DATA.
+#define		HPON_FSM			0x0EC	// Power On FSM Monitor/Control.
+#define		SYS_CFG			0x0F0	// System Configuration Status
+
+
+//
+// 2. MACTOP General Configuration. (Offset 0x100 - 0x1FFh)
+//
+#define		CR					0x100  // Command Register.
+#define		PBP					0x104  // Packet Buffer Page.
+#define		TRXDMA_CTRL		0x10C  // TRXDMA Control.
+#define		TRXFF_BNDY			0x114  // TX/RX FIFO Boundary
+#define		TRXFF_STATUS		0x118  // PKTFF Status
+#define		RXFF_PTR			0x11C  // RXFF Write/Read Pointer
+#define		HIMR				0x120  // Host Interrupt Mask.
+#define		HISR				0x124  // Host Interrupt Status.
+#define		HIMRE				0x128  // Host Interrupt Mask Extension.
+#define		HISRE				0x12C  // Host Interrupt Status Extension.
+#define		CPWM				0x12F  // Current Power Mode.
+#define		FWIMR				0x130  // Firmware WLAN Interrupt Mask.
+#define		FWISR				0x134  // Firmware WLAN Interrupt Status.
+#define		FTIMR				0x138  // Firmware Timer Interrupt Mask.
+#define		FTISR				0x13C  // Firmware Timer Interrupt Status.
+#define		PKTBUF_DBG_CTRL	0x140  // TX/RX Packet Buffer Debug Control.
+#define		PKTBUF_DBG_DATA_L	0x144  // TX/RX Packet Buffer Debug Data.
+#define		PKTBUF_DBG_DATA_H	0x148  // TX/RX Packet Buffer Debug Data.
+//		General Purpose Timer. (Offset 0x150 - 0x16Fh)
+#define		TC0_CTRL			0x150  // Timer/Counter 0 Control.
+#define		TC1_CTRL			0x154  // Timer/Counter 1 Control.
+#define		TC2_CTRL			0x158  // Timer/Counter 2 Control.
+#define		TC3_CTRL			0x15C  // Timer/Counter 3 Control.
+#define		TC4_CTRL			0x160	// Timer/Counter 4 Control.
+#define		TCUNIT_BASE		0x164	// Timer/Counter Unit Base.
+//		General Purpose Timer. (Offset 0x150 - 0x16Fh)
+#define		MBIST_START		0x174	// MACTOP BIST START Pulse.
+#define		MBIST_DONE			0x178	// MACTOP BIST DONE.
+#define		MBIST_FAIL			0x17C	// MACTOP BIST FAIL.
+
+#define		C2H_SYNC_BYTE		0x1AF	// 8051 set to 0xFF, Driver set to 0x0 after read C2H content 
+#define		MCUTST_I			0x1C0	// MCU Firmware TST-I.
+#define		MCUTST_II			0x1C4	// MCU Firmware TST-II.
+#define		MCU_UNLOCK		 0x01C7	// is used for Unlock MCU infinite-loop
+#define		FMETHR				0x1C8	// Firmware Message Exchange to Host.
+#define		HMETFR				0x1CC	// Host Message Interrupt to Firmware.
+#define		HMEBOX_0	 		0x1D0	// Host Message BOX_0 to Firmware.
+#define		HMEBOX_1			0x1D4	// Host Message BOX_1 to Firmware.
+#define		HMEBOX_2			0x1D8	// Host Message BOX_2 to Firmware.
+#define		HMEBOX_3			0x1DC	// Host Message BOX_3 to Firmware.
+#define		LLT_INI				0x1E0	// LLT Entries Initial Indirect Access Control.
+#define		BB_ACCEESS_CTRL	0x1E8	// BB Indirect Access Control.
+#define		BB_ACCESS_DATA	0x1EC	// BaseBand Indirect Access Data.
+#define		MREG_HCIDBG		0x1F0	// MAC REG for HCI debug.
+#define		MREG_CPUDBG		0x1F4	// MAC REG for CPU debug.
+
+
+//
+// 3. TXDMA/RXDMA Configuration. (Offset 0x200 - 0x2FFh)
+//
+#define		RQPN				0x200	// Reserved Queue Page Number.
+#define		FIFOPAGE			0x204	// Available FIFO Page Number.
+#define		TDECTRL			0x208	// Tx DMA Engine Control.
+#define		TXDMA_OFFSET_CHK	0x20C	// TXDMA Offset Check.
+#define		TXDMA_STATUS		0x210	// TXDMA Status.
+#define		RQPN_NPQ			0x214	// RQPN for Normal Queue Register
+
+#define		RXDMA_AGG_PG_TH	0x280	// RXDMA AGG PG Threshold.
+#define		RXPKT_NUM			0x284	// RX Packet Number.
+#define		RXDMA_STATUS		0x288	// RXDMA Status.
+
+
+//
+// 4. PCIE EMAC Reserved Region. (Offset 0x300 - 0x3FFh)
+//
+#define		PCIE_CTRL_REG		0x300	// PCIE DMA Control.
+#define		INT_MIG			0x304	// Interrupt Migration.
+#define		BCNQ_DESA			0x308	// TX Beacon Descriptor Address.
+#define		HQ_DESA			0x310	// TX High Queue Descriptor.
+#define		MGQ_DESA			0x318	// TX Manage Queue Descriptor Address.
+#define		VOQ_DESA			0x320	// TX VO Queue Descriptor Address.
+#define		VIQ_DESA			0x328	// TX VI Queue Descriptor Address.
+#define		BEQ_DESA			0x330	// TX BE Queue Descriptor Address.
+#define		BKQ_DESA			0x338	// TX BK Queue Descriptor Address.
+#define		RX_DESA			0x340	// RX Queue Descriptor Address.
+#define		DBI					0x348	// Backdoor REG for Access Configuration SPACE.
+#define		MDIO				0x354	// MDIO for Access PCIE PHY.
+#define		DBG_SEL			0x360	// Debug Selection
+#define		UART_CTRL			0x364	// UART Control.
+#define		UART_TX_DESA		0x370	// UART TX Descriptor Address.
+#define		UART_RX_DESA		0x378	// UART RX Descriptor Address.
+
+
+//
+// 5. PTCL/EDCA Configuration. (Offset 0x400 - 0x4FFh)
+//
+#define		VOQ_INFO			0x400	//
+#define		VIQ_INFO			0x404	//
+#define		BEQ_INFO			0x408	//
+#define		BKQ_INFO			0x40C	//
+#define		MGQ_INFO			0x410	//
+#define		HIQ_INFO			0x414	//
+#define		BCNQ_INFO			0x418	//
+#define		TXPKT_EMPTY		0x41B	// TXPKTBUF Packet Empty.
+#define		CPU_MGQ_INFO		0x41C	// TXPKTBUF Packet Empty.
+#define		FWHW_TXQ_CTRL	0x420	// FWHW TX Queue Control.
+#define		HWSEQ_CTRL		0x423	// HW Sequence Number Control.
+#define		TXPKTBUF_BCNQ_BDNY	0x424	// BCNQ Boundary.
+#define		TXPKTBUF_MGQ_BDNY	0x425	// MGQ Boundary.
+#define		MULTI_BCNQ_EN		0x426	//
+#define		MULTI_BCNQ_OFFSET		0x427	//
+#define		SPEC_SIFS_A		0x428	//
+#define		RL					0x42A	//
+#define		DARFRC				0x430	// Data Auto Rate Fallback Retry Count.
+#define		RARFRC				0x438	// Response Auto Rate Fallback Retry Count.
+#define		RRSR				0x440	// Response Rate Set.
+#define		ARFR0				0x444	// Data Auto Rate Fallback 0.
+#define		ARFR1				0x448	// Auto Rate Fallback 1.
+#define		ARFR2				0x44C	// Auto Rate Fallback 2.
+#define		ARFR3				0x450	// Auto Rate Fallback 3.
+#define		AGGLEN_LMT		0x458	// Aggregation Length.
+#define		AMPDU_MIN_SPACE	0x45C	// AMPDU Min Space.
+#define		FAST_EDCA_CTRL	0x460	// Fast EDCA Mode.
+#define		RD_RESP_PKT_TH	0x463	// RD Responder Packet Threshold.
+#define		INIRTS_RATE_SEL	0x480	// Initial RTS Rate SEL.
+#define		INIDATA_RATE_SEL	0x484	// Initial Data Rate SEL.
+#define		POWER_STATUS		0x4A4	// POWER STATUS.
+#define		POWER_STAGE1		0x4B4	// POWER STAGE1.
+#define		POWER_STAGE2		0x4B8	// POWER STAGE2.---------------???
+#define		PKT_LIFE_TIME		0x4C0	// PKT LIFT TIME.
+#define		STBC_SETTING		0x4C4	// STBC.
+#define		PROT_MODE_CTRL	0x4C8	// PROTECT MODE Control.
+#define		BAR_MODE_CTRL		0x4CC	// BAR MODE Control.
+#define		RA_TRY_RATE_AGG_LMT	0x4CF	// Rate Adaptive Try Rate Aggregation Limit.
+#define		NQOS_SEQ			0x4DC	// Non-QoS SEQ Number.
+#define		QOS_SEQ			0x4DE	// QoS SEQ Number.
+#define		NEED_CPU_HANDLE	0x4E0	// Need CPU Handle.
+#define		PTCL_ERR_STATUS	0x4E1	// Protocol Function Error Status.
+#define		PKT_LOSE_RPT		0x4E2	// PKT Lose Report.
+#define		Dummy				0x4FC	// Dummy.
+
+#define		EDCA_VO_PARA		0x500	// EDCA Parameter.
+#define		EDCA_VI_PARA		0x504	// EDCA Parameter.
+#define		EDCA_BE_PARA		0x508	// EDCA Parameter.
+#define		EDCA_BK_PARA		0x50C	// EDCA Parameter.
+#define		BCNTCFG			0x510	// Beacon Time Configuration.
+#define		PIFS				0x512	// PIFS.
+#define		RDG_PIFS			0x513	// RDG PIFS.
+#define		SIFS_CCK			0x514	// SIFS for CCK.
+#define		SIFS_OFDM			0x516	// SIFS for OFDM.
+#define		AGGR_BK_TIME		0x51A	// AGGR BREAK TIME.
+#define		SLOT_TIME			0x51B	// Slot Time.
+#define		TX_PTCL_CTRL		0x520	// TX Protocol Control.
+#define		TXPAUSE			0x522	// Transmission Pause.
+#define		DIS_TXREQ_CLR		0x523	// Disable TX Request Clear Function.
+#define		RD_CTRL			0x524	// RD Control.
+#define		TBTT_PROHIBIT		0x540	// TBTT Prohibit.
+#define		RD_NAV_NXT		0x544	// RD NAV Protect Next Time.
+#define		NAV_PROT_LEN		0x546	// NAV Protection Length.
+#define		BCN_CTRL			0x550	// Bcnq Control.
+#define		USTIME_TSF			0x551	// US Time Tuning for TSF.
+#define		MBID_NUM			0x552	// MBSSID Beacon Number.
+#define		MBSSID_BCN_SPACE	0x554	// MBSSID Beacon Space.
+#define		DRVERLYINT			0x558	// Beacon Driver Early Interrupt.
+#define		BCNDMATIM			0x559	// BCN DMA and ATIM INT Time.-----------------???
+#define		ATIMWND			0x55A	// ATIM Window Time.
+#define		BCN_MAX_ERR		0x55D	// BCN MAX ERROR.
+#define		RXTSF_OFFSET_CCK	0x55E	// CCK BCN OFFSET.
+#define		RXTSF_OFFSET_OFDM	0x55F	// OFDM BCN OFFSET.
+#define		TSFTR				0x560	// TSF Timer.
+#define		INIT_TSFTR			0x564	// TSF Timer Initial Value.
+#define		PSTIMER			0x580	// PS TIMER and Timeout INT.
+#define		TIMER0				0x584	// TIMER0 INT.
+#define		TIMER1				0x588	// TIMER1 INT.
+#define		ACMHWCTRL			0x5C0	// ACM HW Control.
+#define		ACMRSTCTRL			0x5C1	// ACM RST.
+#define		ACMAVG				0x5C2	// ACM Average.
+#define		VO_ADMTIME		0x5C4	// VO Admission Time.
+#define		VI_ADMTIME			0x5C6	// VI Admission Time.
+#define		BE_ADMTIME		0x5C8	// BE Admission Time.
+#define		EDCA_RANDOM_GEN	0x5CC	// EDCA Random Number Generator.
+#define		C_SCH_TXCMD		0x5D0	// TX_CMD.
+#define		NOA_PARAM			0x5E0	// P2P NoA Parameter
+
+
+//
+// 6. WMAC Configuration. (Offset 0x600 - 0x7FFh)
+//
+#define		APSD_CTRL			0x600	// APSD Control.
+#define		BWOPMODE			0x603	// BW Operation Mode.
+#define		TCR					0x604	// Transmission Configuration.
+#define		RCR					0x608	// Receive Configuration.
+#define		RX_PKT_LIMIT		0x60C	// RX Packet Length Limit.
+#define		RX_DLK_TIME		0x60D	// RX Deadlock Time.
+#define		RX_DRVINFO_SZ		0x60F	// RX Driver INFO Size Register.
+//		MACID Setting Register. (Offset 0x610 - 0x62Fh)
+#define		MACID				0x610	// MAC ID.
+#define		BSSIDR				0x618	// BSSID.
+#define		MAR					0x620	// Multicast Address.
+#define		MBIDCAMCFG		0x628	// MBSSID CAM Configuration.
+//		MACID Setting Register. (Offset 0x610 - 0x62Fh)
+
+//		Timing Control Register. (Offset 0x630 - 0x64Fh)
+#define		USTIME_EDCA		0x638	// US Time Tuning for EDCA.
+#define		SPEC_SIFS_B		0x63A	// Specification SIFS.
+#define		RESP_SIFS_CCK		0x63C	// Response SIFS for CCK.
+#define		RESP_SIFS_OFDM	0x63E	// Response SIFS for OFDM.
+#define		ACKTO				0x640	// ACK Timeout.
+#define		CTS2TO				0x641	// CTS2 Timeout.
+#define		EIFS				0x642	// EIFS.
+//		Timing Control Register. (Offset 0x630 - 0x64Fh)
+
+//		WMAC, BA, CCX Related Register. (Offset 0x650 - 0x66Fh)
+#define		NAV_CTRL			0x650	// NAV Control.
+#define		BACAMCMD			0x654	// Block ACK CAM Command.
+#define		BACAMCONTENT 		0x658	// Block ACK CAM Content.
+#define		LBDLY		 		0x660	// Loopback Delay.
+#define		FWDLY		 		0x661	// FW Delay.
+#define		RXERR_RPT	 		0x664	// RX Error Report.
+#define		WMAC_TRXPTCL_CTL	0x668	// WMAC TX/RX Protocol Control.
+//		WMAC, BA, CCX Related Register. (Offset 0x650 - 0x66Fh)
+
+//		Security Control Register. (Offset 0x670 - 0x68Fh)
+#define		CAMCMD				0x670	// CAM Command.
+#define		CAMWRITE			0x674	// CAM Write.
+#define		CAMREAD			0x678	// CAM Read.
+#define		CAMDBG				0x67C	// CAM Debug.
+#define		SECCFG				0x680	// Security Configuration.
+//		Security Control Register. (Offset 0x670 - 0x68Fh)
+
+//		Power Save Control Register. (Offset 0x690 - 0x69Fh)
+#define		WOW_CTRL			0x690	// Wake On WLAN Control.
+#define		PSSTATUS			0x691	// Power Save Status.
+#define		PS_RX_INFO			0x692	// Power Save RX Information.
+#define		LPNAV_CTRL			0x694	// Low Power NAV Control.
+#define		WKFMCAM_CMD		0x698	// Wakeup Frame CAM Command.
+#define		WKFMCAM_RWD		0x69C	// Wakeup Frame Read/Write Data.
+//		Power Save Control Register. (Offset 0x690 - 0x69Fh)
+
+//		General Purpose Register. (Offset 0x6A0 - 0x6AFh)
+#define		RXFLTMAP0			0x6A0	// RX Filter Map Group 0.
+#define		RXFLTMAP1			0x6A2	// RX Filter Map Group 1.
+#define		RXFLTMAP2			0x6A4	// RX Filter Map Group 2.
+#define		BCN_PSR_RPT		0x6A8	// Beacon Parser Report.
+#define		CALB32K_CTRL		0x6AC	// Calibration 32K Control.
+//		General Purpose Register. (Offset 0x6A0 - 0x6AFh)
+#define		PKT_MON_CTRL		0x6B4	// Packet Monitor Control.
+#define		BT_COEX_TABLE		0x6C0	// BT-Coexistence Control.
+#define		WMAC_RESP_TXINFO	0x6D8	// Response TXINFO.
+
+
+//============================================================================
+//       8192C Regsiter Bit and Content definition
+//============================================================================
+
+
+//
+// 1. System Configure Register. (Offset 0x000 - 0x0FFh)
+//
+//----------------------------------------------------------------------------
+//       8192C SYS_ISO_CTRL bits				(Offset 0x0, 16bit)
+//----------------------------------------------------------------------------
+#define		PWC_EV12V			BIT(15)	// Power Cut for eFuse 1.2V, 1: Power valid; 0: Power invalid.
+#define		PWC_EV25V			BIT(14)	// Power Cut for eFuse 2.5V, 1: force PSW open; 0: PSW turn on by efuse ctrl.
+#define		ISO_DIOR			BIT(9)	// RF Digital I/O to Power On, 1: isolation; 0: attach.
+#define		ISO_EB2CORE		BIT(8)	// eFuse cell output to Power On, 1: isolation; 0: attach.
+#define		ISO_DIOE			BIT(7)	// Extra Digital I/O to Power On, 1: isolation; 0: attach.
+#define		ISO_DIOP			BIT(6)	// PCIe Digital I/O to Power On, 1: isolation; 0: attach.
+#define		ISO_IP2MAC			BIT(5)	// Analog Ips to Digital 1.2V, 1: isolation; 0: attach (no used).
+#define		ISO_PD2CORE		BIT(4)	// PCIe Digital 1.2V to Power On/Core 1.2V, 1: isolation; 0: attach.
+#define		ISO_PA2PCIE		BIT(3)	// PCIe Analog 1.2V to PCIe 3.3V and Digital 1.2V, 1: isolation; 0: attach.
+#define		ISO_UD2CORE		BIT(2)	// USB Digital 1.2V to Power On/Core 1.2V, 1: isolation; 0: attach.
+#define		ISO_UA2USB			BIT(1)	// USB Analog 1.2V to USB 3.3V and Digital 1.2V, 1: isolation; 0: attach.
+#define		ISO_MD2PP			BIT(0)	// MACTOP/BB/PCIe Digital to Power On, 1: isolation; 0: attach.
+
+//----------------------------------------------------------------------------
+//       8192C SYS_FUNC_EN bits					(Offset 0x2, 16bit)
+//----------------------------------------------------------------------------
+#define		FEN_MREGEN		BIT(15)	// MAC I/O Registers Enable.
+#define		FEN_HWPDN			BIT(14)	// 0 : force All analog blocks shutdown, 1 : keep Analog Blocks alive.
+#define		FEN_DIO_RF			BIT(13)	// Enable RF Digital I/O.
+#define		FEN_ELDR			BIT(12)	// Enable EEPROM Loader (Loader POR).
+#define		FEN_DCORE			BIT(11)	// enable Core Digital (MACTOP POR).
+#define		FEN_CPUEN			BIT(10)	// Enable MCU Core (CPU RST).
+#define		FEN_DIOE			BIT(9)	// Extra Debug I/O PAD Enable.
+#define		FEN_PCIED			BIT(8)	// enable PCIe eMAC.
+#define		FEN_PPLL			BIT(7)	// Enable PCIe PHY_PLL (no used).
+#define		FEN_PCIEA			BIT(6)	// Enable PCIe PHY.
+#define		FEN_DIO_PCIE		BIT(5)	// Enable PCIe Digital I/O (no used).
+#define		FEN_USBD			BIT(4)	// Enable USB_SIE.
+#define		FEN_UPLL			BIT(3)	// Enable USB PHY_PLL (no used).
+#define		FEN_USBA			BIT(2)	// Enable USB PHY.
+#define		FEN_BB_GLB_RST	BIT(1)	// When this bit is set to "0", whole BB is reset. When this bit is set, BB is enabled.
+#define		FEN_BBRSTB			BIT(0)	// When this bit is set to "0", CCK and OFDM are disabled,
+										// and clock are gated. Otherwise, CCK and OFDM are enabled.
+
+//----------------------------------------------------------------------------
+//       8192C APS_FSMCO bits					(Offset 0x4, 32bit)
+//----------------------------------------------------------------------------
+#define		XOP_BTCK			BIT(31)	// BT Option for never turn off XTAL & SPS.
+#define		SOP_A8M			BIT(30)	// Suspend option not to turn analog Clock Mode to 500K Hz, 1: keep 8M, 0: 500K.
+#define		SOP_RCK			BIT(29)	// Suspend option not to turn off Hreg Clock (8M/500KHz), 1: clock on, 0: clock off.
+#define		SOP_AMB			BIT(28)	// Suspend option not to turn off AFE MB, 1: MB on, 0: MB off.
+#define		SOP_ABG			BIT(27)	// Suspend option not to turn off AFE BG, 1: BG on, 0: BG off.
+#define		SOP_FUSE			BIT(26)	// Suspend option to turn off Efuse Power or reset Loader, 1: Fuse Pwr Off, 0: Fuse Pwr On.
+#define		SOP_MRST			BIT(25)	// Suspend option not to turn off MAC Reset, 1: MAC not reset, 0: MaC reset.
+#define		SOP_CRST			BIT(24)	// Susoend option not to turn off 8051 clock, 1: 8051 clock on, 0:8051 clock off.
+#define		ROP_SPS			BIT(22)	// Resume option to skip turn On SPS.
+#define		ROP_PWR			BIT(21)	// Resume option to skip wait Power Ready, 1: pwr up no delay, 0: wait pwr stable.
+#define		ROP_ALD			BIT(20)	// Resume option to skip autoload, 1: not autoload, 0: autoload.
+#define		OP_SWRST			BIT(19)	// Option for Software Reset to Reset 8051.
+#define		SUS_HOST			BIT(17)	// Power FSM turn to HOST SUS.
+#define		RDY_MACON			BIT(16)	// Power FSM turn all power, clock ready for MAC.
+#define		APDM_HPDN			BIT(15)	// Auto Power Down to CHIP-off State (Power-Down).
+#define		APDM_HOST			BIT(14)	// Auto Power Down to HOST-off State (Card-Disable).
+#define		APDM_MAC			BIT(13)	// Auto Power Down to WLAN-Off State (Radio-off).
+#define		AFSM_PCIE			BIT(12)	// When this bit is set, PCIE suspends via HW FSM control flow.
+#define		AFSM_HSUS			BIT(11)	// 1: Host Suspend through FSM operation; 0: Host Suspend by gated.
+#define		APFM_RSM			BIT(10)	// Auto Power On State Machine Resume, auto clear when EE load done.
+#define		APFM_OFF			BIT(9)	// Auto FSM to Turn Off, include clock, isolation, power control.
+#define		APFM_ONMAC		BIT(8)	// Auto FSM to Turn On, include clock, isolation, power control for MAC only.
+#define		BT_SUSEN			BIT(7)	// Enable BT suspend control.
+#define		RDY_MACDIS			BIT(6)	// Disable MAC power Ready Output for Test Mode.
+#define		PDN_PL				BIT(5)	// PDn polarity control, 0: Low active, 1: High active.
+#define		PDN_EN				BIT(4)	// Enable GPIO-11 as Hardware PowerDown/Resume Source.
+#define		PFM_WOWL			BIT(3)	// Wake On Lan indicator for H/W FSM.
+#define		PFM_LDKP			BIT(2)	// Loader Initial data when re-enable loader.
+#define		PFM_ALDN			BIT(1)	// HCI Region load done, inform HCI block.
+#define		PFM_LDALL			BIT(0)	// EEPROM autoload 0x00~60h Enable.
+
+//----------------------------------------------------------------------------
+//       8192C SYS_CLKR bits					(Offset 0x8, 16bit)
+//----------------------------------------------------------------------------
+#define		RING_CLK_EN					BIT(13)	// HPON Ring Clock Enable, 1: Enable; 0 : Disable.
+#define		SYS_CLK_EN						BIT(12)	// MCU Clock Enable, 1: Enable; 0 : Disable.
+#define		MAC_CLK_EN						BIT(11)	// MAC Clock Enable, 1: Enable, 0 : Disable.
+#define		SEC_CLK_EN						BIT(10)	// SEC Clock Enable, 1 :Enable, 0 :Disable.
+#define		PHY_SSC_RSTB					BIT(9)	// PHY SSC Enable (0: Disable, 1: Enable).
+#define		CLKR_80M_SSC_EN_HOLD_PHS0	BIT(8)	// 80M Clock Hold phase 0.
+#define		CLKR_80M_SSC_DIS				BIT(7)	// 80M Clock SSC Disable.
+#define		LOADER_CLK_EN					BIT(5)	// Loader (eFuse/EEPROM) Clock Enable.
+#define		MACSLP							BIT(4)	// MAC SLEEP.
+#define		ROMD16V_EN					BIT(2)	// Analog Clock source Divide 16 Mode for EEPROM.
+#define		ANA8M							BIT(1)	// Analog Clock source rate, 1: 8M Hz, 0: 500K Hz.
+#define		CNTD16V_EN						BIT(0)	// Analog Clock source Divide 16 Mode for Hardware Timer.
+
+//----------------------------------------------------------------------------
+//       8192C CR9346 bits						(Offset 0xA, 16bit)
+//----------------------------------------------------------------------------
+#define		VPDIDX_SHIFT		8	// VPD mode, EEPROM Index.
+#define		VPDIDX_Mask		0x0FF
+#define		EEM1_0_SHIFT		6	// Operating Mode.
+#define		EEM1_0_Mask		0x03
+#define		EEPROM_EN			BIT(5)	// EEPROM/Efuse is found when set to 1.
+#define		EERPOMSEL			BIT(4)	// System EEPROM select (power on selected by GPIO-0).
+#define		EECS				BIT(3)	// reflect the state of the EECS.
+#define		EESK				BIT(2)	// reflect the state of the EESK.
+#define		EEDI				BIT(1)	// reflect the state of the EEDI.
+#define		EEDO				BIT(0)	// reflect the state of the EEDO.
+
+
+#ifdef EN_EFUSE
+#define		CmdEEPROM_En						BIT(5)	 // EEPROM enable when set 1
+#define		CmdEERPOMSEL						BIT(4) // System EEPROM select, 0: boot from E-FUSE, 1: The EEPROM used is 9346
+#define		AutoLoadEEPROM						(CmdEEPROM_En|CmdEERPOMSEL)
+#define		AutoLoadEFUSE						CmdEEPROM_En
+
+
+#ifdef CONFIG_RTL_92C_SUPPORT
+
+#define EEPROM_TxPowerCCK			0x5A // CCK Tx Power base
+#define	EEPROM_TxPowerHT40_1S		0x60 // HT40 Tx Power base
+#define	EEPROM_TxPowerHT40_2SDiff	0x66 // HT40 Tx Power diff
+#define EEPROM_TxPowerHT20Diff		0x69 // HT20 Tx Power diff
+#define EEPROM_TxPowerOFDMDiff		0x6C // OFDM Tx Power diff
+#define EEPROM_MACADDRESS			0x16 // OFDM Tx Power diff
+#define EEPROM_THERMAL_METER		0x78 //[4:0]
+#endif
+
+#endif
+
+
+//----------------------------------------------------------------------------
+//       8192S AFE_MISC bits						(Offset 0x10, 8bits)
+//----------------------------------------------------------------------------
+#define		MAC_ID_EN			BIT(7)	// Reserved for RF_ID selection to be MAC.
+#define		AFE_MBEN			BIT(1)	// Enable AFE Macro Block's Mbias.
+#define		AFE_BGEN			BIT(0)	// Enable AFE Macro Block's Bandgap.
+
+//----------------------------------------------------------------------------
+//       8192C SPS0_CTRL bits					(Offset 0x11-17, 56bits)
+//----------------------------------------------------------------------------
+#define		SW18_LDO_R			BIT(19)	// LDO_R_L1 = 1 => LDO resistor connect.
+#define		SW18_V15ADJ_SHIFT		16	// v15adj_L1<2:0>  output.
+#define		SW18_V15ADJ_Mask		0x07
+#define		SW18_VOL_SHIFT		12	// VOL_L1<3:0>  output.
+#define		SW18_VOL_Mask			0x0F
+#define		SW18_IN_SHIFT			9	// IN_L1<2:0> output.
+#define		SW18_IN_Mask			0x07
+#define		SW18_TBOX_SHIFT		7	// TBOC_L1<1:0> output.
+#define		SW18_TBOX_Mask		0x03
+#define		SW18_SET_DELAY		BIT(6)	// SET_DELAY_L1=1=> nonoverlap delay increases.
+#define		SW18_SEL				BIT(5)	// SD_L1 = 1 => turn off quickly.
+#define		SW18_STD_SHIFT		3	// STD_L1<1:0> time.
+#define		SW18_STD_Mask			0x03
+#define		SW18_SD				BIT(2)	// SD_L1 = 1 => turn off quickly.
+#define		SW18_AREN				BIT(1)	// 3.3->1.8 for PFM  Anti-ring.
+#define		SW18_R3_B1			BIT(0)	//
+
+#define		SW18_R3_B0			BIT(31)	//
+#define		SW18_R2_SHIFT			29	//
+#define		SW18_R2_Mask			0x03
+#define		SW18_R1_SHIFT			27	//
+#define		SW18_R1_Mask			0x03
+#define		SW18_C3_SHIFT			25	//
+#define		SW18_C3_Mask			0x03
+#define		SW18_C2_SHIFT			23	//
+#define		SW18_C2_Mask			0x03
+#define		SW18_C1_SHIFT			21	//
+#define		SW18_C1_Mask			0x03
+#define		SW18_SCREF_SHIFT		19	// For FDUAL, tune reference frequency.
+#define		SW18_SCREF_Mask		0x03
+#define		SW18_SCPFM_SHIFT		17	// For FDUAL, tune pfm frequency.
+#define		SW18_SCPFM_Mask		0x03
+#define		SW18_PWFMTUNE_SHIFT	14	//
+#define		SW18_PWFMTUNE_Mask	0x07
+#define		SW18_SELSTOP			BIT(13)	// SEL_STOP_L1 = 0 => no delay.
+#define		SW18_SELD_SHIFT		11	// Bit(1)=1 enable clamp maximum duty, bit(0)=1 enable clamp minimum duty
+#define		SW18_SELD_Mask		0x03
+#define		SW18_POWOCP			BIT(10)	// POWOCP_L1=1=> enable over current protection.
+#define		SW18_OCP_SHIFT		7	//
+#define		SW18_OCP_Mask			0x07
+#define		SW18_SFREQ_SHIFT		5	//
+#define		SW18_SFREQ_Mask		0x03
+#define		SW18_SFREQC			BIT(4)	//
+#define		SW18_FPWM				BIT(3)	// FPWM_L1 = 1 => force PWM, FPWM_L1 = 0 => force PFM.
+#define		SW18_FDUAL			BIT(2)	// FDUAL_L1 =1 => PWM or PFM.
+#define		SW18_SWEN				BIT(1)	// Enable VSPS18_SW Macro Block.
+#define		SW18_LDEN				BIT(0)	// Enable VSPS18_LDO Macro Block.
+
+//----------------------------------------------------------------------------
+//       8192C SPS_OCP_CFG bits					(Offset 0x18-1B, 32bits)
+//----------------------------------------------------------------------------
+#define		SPS18_OCP_DIS			BIT(31)	// sps18 ocp, 0:enable, 1:disable.
+#define		SPS18_OCP_TH_SHIFT	16	// Sps18 ocp threshold.
+#define		SPS18_OCP_TH_Mask		0x07FFF
+#define		OCP_WINDOW_SHIFT		0	// Ocp monitor window width configure, count on ana_clk/16.
+#define		OCP_WINDOW_Mask		0x0FFFF
+
+//----------------------------------------------------------------------------
+//       8192C RSV_CTRL0 bits					(Offset 0x1C-1E, 24bits)
+//----------------------------------------------------------------------------
+#define		HREG_DBG_SHIFT	8	// HREG Access Debug.
+#define		HREG_DBG_Mask		0x0FFFF
+#define		LOCK_ALL_EN		BIT(7)	// 1:Enable 'Locked All' setting by Hardware, 0: Hardware Enable 'Locked All' denied.
+#define		R_DIS_PRST_1		BIT(6)	// Control if PERST can reset MACCORE.
+#define		R_DIS_PRST_0		BIT(5)	// Control if PERST can reset MACCORE.
+#define		WLOCK_40			BIT(4)	// 1:Register Write Locked, 0: Register Accessible by SW/FW.
+#define		WLOCK_08			BIT(3)	// 1:Register Write Locked, 0: Register Accessible by SW/FW.
+#define		WLOCK_04			BIT(2)	// 1:Register Write Locked, 0: Register Accessible by SW/FW.
+#define		WLOCK_00			BIT(1)	// 1:Register Write Locked, 0: Register Accessible by SW/FW.
+#define		WLOCK_ALL			BIT(0)	// 1:Register Write Locked, 0: Register Accessible by SW/FW.
+
+//----------------------------------------------------------------------------
+//       8192C RF_CTRL bits						(Offset 0x1F, 8bits)
+//----------------------------------------------------------------------------
+#define		RF_SDMRSTB			BIT(2)	// Reset RF SDM Module (low active).
+#define		RF_RSTB			BIT(1)	// Reset RF Module (low active).
+#define		RF_EN				BIT(0)	// Enable RF Module.
+
+//----------------------------------------------------------------------------
+//       8192C LDOA15_CTRL bits					(Offset 0x20, 8bits)
+//----------------------------------------------------------------------------
+#define		LDA15_VOADJ_SHIFT	4	//
+#define		LDA15_VOADJ_Mask	0x0F
+#define		LDA15_STBY			BIT(3)	// LDOA15 Standby Mode.
+#define		LDA15_OBUF			BIT(2)	// LDOA15 Output Buffered.
+#define		REG_VOS			BIT(1)	// LDOA15 Add Offset voltage.
+#define		LDA15_EN			BIT(0)	// Enable LDOA15 Macro Block.
+
+//----------------------------------------------------------------------------
+//       8192C LDOV12D_CTRL bits				(Offset 0x21, 8bits)
+//----------------------------------------------------------------------------
+#define		LDV12_VADJ_SHIFT	4	// LDOVD12 voltage adjust.
+#define		LDV12_VADJ_Mask	0x0F
+#define		LDV12_BUFO			BIT(2)	// LDOVD12 buffer output Mode.
+#define		LDV12_SDBY			BIT(1)	// LDOVD12 standby mode.
+#define		LDV12_EN			BIT(0)	// Enable LDOA12 Macro Block.
+
+//----------------------------------------------------------------------------
+//       8192C LDOHCI12_CTRL bits				(Offset 0x22, 8bits)
+//----------------------------------------------------------------------------
+#define		LDH12_SDBY			BIT(5)	// LDOHCI12 standby mode.
+#define		LDH12_OBUF			BIT(4)	// Enable LDOHCI12 Macro Block.
+#define		LDH12_VADJ_SHIFT	1	// LDOHCI12 voltage adjust.
+#define		LDH12_VADJ_Mask	0x07
+#define		LDH12_EN			BIT(0)	// Enable LDOHCI12 Macro Block.
+
+//----------------------------------------------------------------------------
+//       8192C LPLDO_CTRL bits					(Offset 0x23, 8bits)
+//----------------------------------------------------------------------------
+#define		LPLDH12_SLP			BIT(4)	// LPLDOH12 Sleep Mode.
+#define		LPLDH12_VADJ_SHIFT	0	// LPLDOH12 voltage adjust.
+#define		LPLDH12_VADJ_Mask		0x0F
+
+//----------------------------------------------------------------------------
+//       8192C AFE_XTAL_CTRL bits				(Offset 0x24-27, 32bits)
+//----------------------------------------------------------------------------
+#define		CKDLY_BT				BIT(29)	// Delay time of CLK_BT relate to CLK_DIG, 0: long time, 1: short time.
+#define		CKDLY_DIG				BIT(28)	// Delay time of CLK_DIG relate to CLK_AFE, 0: long time, 1: short time.
+#define		CKDLY_USB				BIT(27)	// Delay time of CLK_USB relate to CLK_AFE, 0: long time, 1: short time.
+#define		CKDLY_AFE				BIT(26)	// Delay time of CLK_AFE relate to CLK_RF, 0: long time, 1: short time.
+#define		XTAL_GPIO_SHIFT		23	//
+#define		XTAL_GPIO_Mask		0x07
+#define		XTAL_BT_DRV_SHIFT		21	// BT clock source Driving current: 11:most current, 00: less current.
+#define		XTAL_BT_DRV_Mask		0x03
+#define		XTAL_BT_GATE			BIT(20)	// Gated control: 1: BT Clock source gated, 0: clock enable (auto setting by trap data).
+#define		XTAL_DIG_DRV_SHIFT	18	// DIG clock source 11:most current, 00: less current.
+#define		XTAL_DIG_DRV_Mask		0x03
+#define		XTAL_GATE_DIG			BIT(17)	// Gated control:1: DIG Clock source gated, 0: clock enable.
+#define		XTAL_RF_DRV_SHIFT		15	// RF PLL Driving current: 11:most current, 00: less current.
+#define		XTAL_RF_DRV_Mask		0x03
+#define		XTAL_RF_GATE			BIT(14)	// Gated control: 1: RF Clock source gated, 0: clock enable.
+#define		XTAL_AFE_DRV_SHIFT	12	// AFE PLL Driving current: 11:most current, 00: less current.
+#define		XTAL_AFE_DRV_Mask		0x03
+#define		XTAL_GATE_AFE			BIT(11)	// Gated control:1: USB Clock source gated, 0: clock enable.
+#define		XTAL_USB_DRV_SHIFT	9	// USB PLL Driving current: 11:most current, 00: less current.
+#define		XTAL_USB_DRV_Mask		0x03
+#define		XTAL_GATE_USB			BIT(8)	// Gated control:1: USB Clock source gated, 0: clock enable.
+#define		XTAL_CADJ_XI_SHIFT	4	// 1:add cap, 0:degrade cap.
+#define		XTAL_CADJ_XI_Mask		0x0F
+#define		XTAL_BOSC_SHIFT		2	// The bias current control of VCO block.
+#define		XTAL_BOSC_Mask		0x03
+#define		XTAL_BSEL				BIT(1)	// 1: schmitt trigger, 0:nand.
+#define		XTAL_EN				BIT(0)	// Enable XTAL Macro block.
+
+//----------------------------------------------------------------------------
+//       8192C AFE_PLL_CTRL bits					(Offset 0x28-2B, 32bits)
+//----------------------------------------------------------------------------
+#define		AFE_DUMMY_SHIFT		25	// Dummy Registers.
+#define		AFE_DUMMY_Mask		0x07
+#define		APLL_1MEN				BIT(24)	// 1:Enable 0:output "1".
+#define		APLL_40DRV_SHIFT		22	// clk diving 00: weak 11:strong.
+#define		APLL_40DRV_Mask		0x03
+#define		APLL_PLLDRV_SHIFT		20	// clk diving 00: weak 11:strong.
+#define		APLL_PLLDRV_Mask		0x03
+#define		APLL_88DRV_SHIFT		18	// clk diving 00: weak 11:strong.
+#define		APLL_88DRV_Mask		0x03
+#define		APLL_80DRV_SHIFT		16	// clk diving 00: weak 11:strong.
+#define		APLL_80DRV_Mask		0x03
+#define		APLL_80EN				BIT(15)	// 1:Enable 0:output "1".
+#define		APLL_320EN				BIT(14)	// 1:Enable 0:output "1".
+#define		APLL_320BIAS_SHIFT	11	// pll320 CP current selection.
+#define		APLL_320BIAS_Mask		0x07
+#define		APLL_BIAS_SHIFT		8	// pll CP current selection.
+#define		APLL_BIAS_Mask			0x07
+#define		APLL_KVCO_SHIFT		6	// pll VCO KVCO selection.
+#define		APLL_KVCO_Mask		0x03
+#define		APLL_LPFEN				BIT(5)	// enable PLL Bias Current LPF.
+#define		APLL_WDOGB			BIT(4)	// enable watch dog 0: enable 1:disable.
+#define		APLL_EDGE_SEL			BIT(3)	// Reference clock: 1 : negative edge, 0 : positive edge.
+#define		APLL_FREF_SEL			BIT(2)	// Reference clock: 1 : 20MHz, 0 : 40MHz.
+#define		APLL_320_EN			BIT(1)	// Enable AFE 320 PLL Macro Block.
+#define		APLL_EN				BIT(0)	// Enable AFE PLL Macro Block.
+
+//----------------------------------------------------------------------------
+//       8192C EFUSE_CTRL bits					(Offset 0x30-33, 32bits)
+//----------------------------------------------------------------------------
+#define		EF_FLAG			BIT(31)	// Access Flag. Write "1" for Program; Write "0" for Read Access.
+#define		EF_PGPD_SHIFT		28	// E-fuse program time.
+#define		EF_PGPD_Mask		0x07
+#define		EF_RDT_SHIFT		24	// E-fuse read time: in the unit of cycle time.
+#define		EF_RDT_Mask		0x0F
+#define		EF_PGT_SHIFT		20	// Programming setup time. In the unit of cycle time.(125ns).
+#define		EF_PGT_Mask		0x0F
+#define		EF_PD				BIT(19)	// Efuse power down.
+#define		ALD_EN				BIT(18)	// Autoload Enable.
+#define		EF_ADDR_SHIFT		8	// Access Address.
+#define		EF_ADDR_Mask		0x03FF
+#define		EF_DATA_SHIFT		0	// Access Data.
+#define		EF_DATA_Mask		0x0FF
+
+//----------------------------------------------------------------------------
+//       8192C EFUSE_TEST bits					(Offset 0x34-37, 32bits)
+//----------------------------------------------------------------------------
+#define		LDOE25_EN			BIT(31)	// Enable LDOE25 Macro Block.
+#define		LDOE25_VADJ_SHIFT	28	// LDOE25 voltage adjust.
+#define		LDOE25_VADJ_Mask	0x07
+#define		ADDR_END_Shift		25	// 92D_REG, Scan effuse end (1023-addr_end)
+#define		ADDR_END_Mask		0x07
+#define		ADDR_STR_Shift		18	// 92D_REG, Scan efuse from (addr_str*8)
+#define		ADDR_STR_Mask		0x07F
+#define		BYTE_CNT_EN		BIT(17)	// 92D_REG, 1: scan efuse in byte; 0: scan efuse in bit
+#define		EF_SCAN_EN			BIT(16)	// 92D_REG, 1: efuse in scan process. 0: not in scan process
+#define		EDATA1_SHIFT		8	// EEPROM offset 1 data (EE Byte-1).
+#define		EDATA1_Mask		0x0FF
+#define		EF_TRPT			BIT(7)	// Test Scan Report: 1 : Fail, 0 : OK.
+#define		EF_TTHD_SHIFT		0	// Bit number for all cells scan test.
+#define		EF_TTHD_Mask		0x07F
+
+//----------------------------------------------------------------------------
+//       8192C PWR_DATA bits					(Offset 0x38-3B, 32bits)
+//----------------------------------------------------------------------------
+#define		EDATA0_SHIFT		24	// EEPROM offset 0 data (EE Byte-0).
+#define		EDATA0_Mask		0x0FF
+#define		HTEST_SEL_SHIFT	16	// TEST Mode Select (EE Byte-7).
+#define		HTEST_SEL_Mask	0x0FF
+#define		HPON_STBP2_SHIFT	8	// HPON Stable time parameter (EE Byte-5).
+#define		HPON_STBP2_Mask	0x0FF
+#define		HPON_STBP1_SHIFT	0	// HPON Stable time parameter (EE Byte-2).
+#define		HPON_STBP1_Mask	0x0FF
+
+//----------------------------------------------------------------------------
+//       8192C CAL_TIMER bits					(Offset 0x3C-3D, 16bits)
+//----------------------------------------------------------------------------
+#define		MATCH_CNT_SHIFT	8	// match counter for sleep mode.
+#define		MATCH_CNT_Mask	0x0FF
+#define		CAL_SCAL_SHIFT		0	// scaler fine tune for sleep mode (tune in Time unit).
+#define		CAL_SCAL_Mask		0x0FF
+
+//----------------------------------------------------------------------------
+//       8192C ACLK_MON bits					(Offset 0x3E-3F, 16bits)
+//----------------------------------------------------------------------------
+#define		RCLK_MON_SHIFT	5	// ring clock monitor (with DPSTU scale).
+#define		RCLK_MON_Mask		0x07FF
+#define		CAL_TIMER_EN		BIT(4)	// calibration timer enable. This shall be turned off before sleep mode enable.
+#define		DPSTU_SHIFT		2	// Deep Power Save Time Unit: 00: 64us, 01: 128us, 10: 192us, 11: 256 us.
+#define		DPSTU_Mask			0x03
+#define		SUS_16X			BIT(1)	// Scale timer 16x when suspend mode, (~250 S).
+#define		RSM_EN				BIT(0)	// When Timer Expired, Resume Hardware StateMachine.
+
+//----------------------------------------------------------------------------
+//       8192C GPIO_MUXCFG bits					(Offset 0x40-43, 32 bits)
+//----------------------------------------------------------------------------
+#define		GPIO_MOD_H_SHIFT		28	// When bit is zero, corresponding port configured to data port;
+										// otherwise, when a bit is set, and GPIO_IO_SEL is set to "0",
+										// then it is interrupt mode..
+#define		GPIO_MOD_H_Mask		0x0F
+#define		GPIO_IO_SEL_H_SHIFT	24	// GPIO_IO_SEL[11:8], output when bit=1;input when bit=0.
+#define		GPIO_IO_SEL_H_Mask	0x0F
+#define		GPIO_OUT_H_SHIFT		20	// GPIO_OUT[11:8], GPIO pins output value.
+#define		GPIO_OUT_H_Mask		0x0F
+#define		GPIO_IN_H_SHIFT		16	// GPIO_IN[11:8], GPIO pins input value.
+#define		GPIO_IN_H_Mask		0x0F
+#define		SIC_LBK					BIT(15)	// Enable SIC_Loop_Back Mode, (auto set by ICFG).
+#define		HTP_EN					BIT(14)   // 0 : Enable as Host Debug Port, 1 : Enable as Host Test Port.
+#define		SIC_23					BIT(13)   // Enable SIC at 0: GPIO 9,10 pins ; 1 : GPIO 2,3 pins.
+#define		SIC_EN					BIT(12)   // Enable GPIO Pins as SIC, (auto set by ICFG).
+#define		SIC_SWRST				BIT(11)	// 0 : Reset SIC by SW, prevent SIC Dead Lock.
+#define		PMAC_EN				BIT(10)	// PMAC Enable (auto set by ICFG).
+#define		UART_SEL				BIT(9)	// Enable UART at 0: GPIO 6,7 pins; 1 : GPIO 9,10 pins.
+#define		UART_EN				BIT(8)	// Enable GPIO Pins as UART.
+#define		BTMode_SHIFT			6	// Bluetooth Mode.
+#define		BTMode_Mask			0x03
+#define		BT_EN					BIT(5)	// Enable GPIO0,1,2,3,8 Pins for Bluetooth.
+#define		EROM_EN				BIT(4)	// Enable GPIO6 for EEDO, GPIO7 for EEDI, default Enable when 9346 selected
+#define		TRSW1EN				BIT(3)	// Enable GPIO9,10 for TRSWN1, TRSWP1.
+#define		TRSW0EN				BIT(2)	// Enable GPIO8 for TRSWN0.
+#define		GPIOSEL_SHIFT			0	// GPIO Select.
+#define		GPIOSEL_Mask			0x03
+
+//----------------------------------------------------------------------------
+//       8192C GPIO_PIN_CTRL bits				(Offset 0x44-47, 32 bits)
+//----------------------------------------------------------------------------
+#define		GPIO_MOD_L_SHIFT		24	// When bit is 0, corresponding port set as data port;
+										// otherwise, when a bit=1, and GPIO_IO_SEL is set to "0",
+										// then it is interrupt mode..
+#define		GPIO_MOD_L_Mask		0x0FF
+#define		GPIO_IO_SEL_L_SHIFT	16	// GPIO_IO_SEL[7:0], output when bit=1;input when bit=0.
+#define		GPIO_IO_SEL_L_Mask	0x0FF
+#define		GPIO_OUT_L_SHIFT		8	// GPIO_OUT[7:0], GPIO pins output value.
+#define		GPIO_OUT_L_Mask		0x0FF
+#define		GPIO_IN_L_SHIFT		0	// GPIO_IN[7:0], GPIO pins input value.
+#define		GPIO_IN_L_Mask			0x0FF
+
+//----------------------------------------------------------------------------
+//       8192C GPIO_INTM bits					(Offset 0x48-4B, 32 bits)
+//----------------------------------------------------------------------------
+#define		MDBG_SEL_SHIFT		30	//
+#define		MDBG_SEL_Mask			0x03
+#define		GPIO_EXT_WOL_SHIFT	12	// External WOL source control.
+#define		GPIO_EXT_WOL_Mask	0x0F
+#define		GPIOB_INT_MD			BIT(11)	// 0=positive edge, 1=negative edge,  is sensed as interrupt.
+#define		GPIOA_INT_MD			BIT(10)	// 0=positive edge, 1=negative edge,  is sensed as interrupt.
+#define		GPIO9_INT_MD			BIT(9)	// 0=positive edge, 1=negative edge,  is sensed as interrupt.
+#define		GPIO8_INT_MD			BIT(8)	// 0=positive edge, 1=negative edge,  is sensed as interrupt.
+#define		GPIO7_INT_MD			BIT(7)	// 0=positive edge, 1=negative edge,  is sensed as interrupt.
+#define		GPIO6_INT_MD			BIT(6)	// 0=positive edge, 1=negative edge,  is sensed as interrupt.
+#define		GPIO5_INT_MD			BIT(5)	// 0=positive edge, 1=negative edge,  is sensed as interrupt.
+#define		GPIO4_INT_MD			BIT(4)	// 0=positive edge, 1=negative edge,  is sensed as interrupt.
+#define		GPIO3_INT_MD			BIT(3)	// 0=positive edge, 1=negative edge,  is sensed as interrupt.
+#define		GPIO2_INT_MD			BIT(2)	// 0=positive edge, 1=negative edge,  is sensed as interrupt.
+#define		GPIO1_INT_MD			BIT(1)	// 0=positive edge, 1=negative edge,  is sensed as interrupt.
+#define		GPIO0_INT_MD			BIT(0)	// 0=positive edge, 1=negative edge,  is sensed as interrupt.
+
+//----------------------------------------------------------------------------
+//       8192C LEDCFG bits						(Offset 0x4C-4F, 32 bits)
+//----------------------------------------------------------------------------
+#define		GP8_LED			BIT(22)	// Enable GPIO-8 as LED2.
+#define		LED2EN				BIT(21)	// Enable GPIO-10/GPIO-8 as LED2.
+#define		LED2PL				BIT(20)	// LED2 polarity control.
+#define		LED2SV				BIT(19)	// LED2 software value.
+#define		LED2CM_SHIFT		16	// LED2 Control Mode.
+#define		LED2CM_Mask		0x07
+#define		LED1DIS				BIT(15)	// LED1 Disabled for analog signal usage,
+										// 1: disable (input mode), 0:Enable (output mode).
+#define		LED1PL				BIT(12)	// LED1 polarity control (auto-load configurable).
+#define		LED1SV				BIT(11)	// LED1 software value.
+#define		LED1CM_SHIFT		8	// LED1 Control Mode.
+#define		LED1CM_Mask		0x07
+#define		LED0DIS				BIT(7)	// LED1 Disabled for analog signal usage,
+										// 1: disable (input mode), 0:Enable (output mode).
+#define		LED0PL				BIT(4)	// LED0 polarity control (auto-load configurable).
+#define		LED0SV				BIT(3)	// LED0 software value.
+#define		LED0CM_SHIFT		0	// LED0 Control Mode.
+#define		LED0CM_Mask		0x07
+
+#define		LED_SW_CTRL			0
+#define		LED_OFF				1
+#define		LED_TX_RX_EVENT_ON	2
+#define		LED_TX_RX_EVENT_OFF	3
+#define		LED_TX_EVENT_ON		4
+#define		LED_TX_EVENT_OFF		5
+#define		LED_RX_EVENT_ON		6
+#define		LED_RX_EVENT_OFF		7
+
+//----------------------------------------------------------------------------
+//       8192C FSIMR bits						(Offset 0x50-53, 32 bits)
+//----------------------------------------------------------------------------
+#define		PDNINT_EN			BIT(31)	// Enable Hardware Power Down interrupt source.
+#define		SYS_TIMER_EN		BIT(30)	// Enable Hardware System Timer interrupt source.
+#define		SPS_OCP_INT_EN	BIT(29)	// Enable SPS OCP alarm interrupt source.
+#define		HPON_WRE_EN		BIT(28)	// Enable Continue access HPON registers interrupt source.
+#define		GPIOB_INT_EN		BIT(23)	// Enable GPIOB interrupt source.
+#define		GPIOA_INT_EN		BIT(22)	// Enable GPIOA interrupt source.
+#define		GPIO9_INT_EN		BIT(21)	// Enable GPIO9 interrupt source.
+#define		GPIO8_INT_EN		BIT(20)	// Enable GPIO8 interrupt source.
+#define		GPIO7_INT_EN		BIT(19)	// Enable GPIO7 interrupt source.
+#define		GPIO6_INT_EN		BIT(18)	// Enable GPIO6 interrupt source.
+#define		GPIO5_INT_EN		BIT(17)	// Enable GPIO5 interrupt source.
+#define		GPIO4_INT_EN		BIT(16)	// Enable GPIO4 interrupt source.
+#define		GPIO3_INT_EN		BIT(15)	// Enable GPIO3 interrupt source.
+#define		GPIO2_INT_EN		BIT(14)	// Enable GPIO2 interrupt source.
+#define		GPIO1_INT_EN		BIT(13)	// Enable GPIO1 interrupt source.
+#define		GPIO0_INT_EN		BIT(12)	// Enable GPIO0 interrupt source.
+
+//----------------------------------------------------------------------------
+//       8192C FSISR bits						(Offset 0x54-57, 32 bits)
+//----------------------------------------------------------------------------
+#define		PDNINT				BIT(31)	// Hardware Power Down interrupt.
+#define		HWSYS_TIMER_INT	BIT(30)	// Hardware System Timer interrupt.
+#define		SPS_OCP_INT		BIT(29)	// SPS OCP alarm interrupt.
+#define		HPON_WRE			BIT(28)	// Continue access HPON registers interrupt. Write 1 clear.
+#define		GPIOB_INT			BIT(23)	// GPIOB INT Status. Write 1 clear.
+#define		GPIOA_INT			BIT(22)	// GPIOA INT Status. Write 1 clear.
+#define		GPIO9_INT			BIT(21)	// GPIO9 INT Status. Write 1 clear.
+#define		GPIO8_INT			BIT(20)	// GPIO8 INT Status. Write 1 clear.
+#define		GPIO7_INT			BIT(19)	// GPIO7 INT Status. Write 1 clear.
+#define		GPIO6_INT			BIT(18)	// GPIO6 INT Status. Write 1 clear.
+#define		GPIO5_INT			BIT(17)	// GPIO5 INT Status. Write 1 clear.
+#define		GPIO4_INT			BIT(16)	// GPIO4 INT Status. Write 1 clear.
+#define		GPIO3_INT			BIT(15)	// GPIO3 INT Status. Write 1 clear.
+#define		GPIO2_INT			BIT(14)	// GPIO2 INT Status. Write 1 clear.
+#define		GPIO1_INT			BIT(13)	// GPIO1 INT Status. Write 1 clear.
+#define		GPIO0_INT			BIT(12)	// GPIO0 INT Status. Write 1 clear.
+
+//----------------------------------------------------------------------------
+//       8192C MCUFWDL bits						(Offset 0x80-83, 32 bits)
+//----------------------------------------------------------------------------
+#define		RPWM_SHIFT		24	// Host Request Power State.
+#define		RPWM_Mask			0x0FF
+#define		CPRST				BIT(23)	// 8051 Reset Status.
+#define		ROM_DLEN			BIT(19)	// ROM Download Enable (8051 Core will be reseted) FPGA only.
+#define		ROM_PGE_SHIFT		16	// ROM Page (FPGA only).
+#define		ROM_PGE_Mask		0x07
+#define		MAC1_RFINI_RDY	BIT(10)	// 92D_REG, MAC1 MCU Initial RF ready
+#define		MAC1_BBINI_RDY	BIT(9)	// 92D_REG, MAC1 MCU Initial BB ready
+#define		MAC1_MACINI_RDY	BIT(8)	// 92D_REG, MAC1 MCU Initial MAC ready
+#define		MCU_STATUS		BIT(7)	// 92D_REG, 1: SRAM, 0: ROM
+#define		WINTINI_RDY		BIT(6)	// WLAN Interrupt Initial ready.
+#define		MAC0_RFINI_RDY	BIT(5)	// MAC0 MCU Initial RF ready.
+#define		MAC0_BBINI_RDY	BIT(4)	// MAC0 MCU Initial BB ready.
+#define		MAC0_MACINI_RDY	BIT(3)	// MAC0 MCU Initial MAC ready.
+#define		FWDL_CHKSUM_RPT	BIT(2)	// FWDL CheckSum report, 1: OK, 0 : Faill.
+#define		MCUFWDL_RDY		BIT(1)	// Driver set this bit to notify MCU FW Download OK.
+#define		MCUFWDL_EN		BIT(0)	// MCU Firmware download enable. 1:Enable, 0:Disable.
+
+//----------------------------------------------------------------------------
+//       8192C MCUTSTCFG bits					(Offset 0x84-87, 32 bits)
+//----------------------------------------------------------------------------
+#define		LBKTST_SHIFT		0	// LBK TST indicator.
+#define		LBKTST_Mask		0x0FFFF
+
+//----------------------------------------------------------------------------
+//       8192C BIST_CTRL bits					(Offset 0xD0-D3, 32 bits)
+//----------------------------------------------------------------------------
+#define		BB_SPEED_SCAN		BIT(31)	// BB at speed scan mode Enable.
+#define		SCAN_PLL_BYPASS	BIT(30)	// 92D_REG
+#define		MBIST_RSTNI_Shift	8		// 92D_REG
+#define		MBIST_RSTNI_Mask	0x07FF
+#define		BIST_RESUME_PS	BIT(5)
+#define		BIST_RESUME		BIT(4)
+#define		BIST_DRF			BIT(3)	// 92D_REG
+#define		BIST_RETEN			BIT(3)
+#define		BIST_NORMAL		BIT(2)
+#define		BIST_RSTN			BIT(1)
+#define		BIST_CLK_EN		BIT(0)
+
+//----------------------------------------------------------------------------
+//       8192C C_BIST_RPT bits					(Offset 0xD4-D7, 32 bits)
+//----------------------------------------------------------------------------
+#define		C_MAC_BIST_FAIL			BIT(31)	// MAC_BIST_FAIL.
+#define		C_USB_IRAM_FAIL			BIT(26)	// USB IRAM BIST FAIL.
+#define		C_USB_RAM1_FAIL			BIT(25)	// USB RAM1 BIST FAIL.
+#define		C_USB_PROM_FAIL			BIT(24)	// USB PROM BIST FAIL.
+#define		C_PCIE_RETRY_BIST_FAIL	BIT(20)	// PCIE RETRY RAM BIST FAIL.
+#define		C_PCIE_SOT_BIST_FAIL		BIT(19)	// PCIE RETRY SOT RAM BIST FAIL.
+#define		C_PCIE_PH1_BIST_FAIL		BIT(18)	// PCIE PHDR RAM1 BIST FAIL.
+#define		C_PCIE_PH0_BIST_FAIL		BIT(17)	// PCIE PHDR RAM0 BIST FAIL.
+#define		C_PCIE_PD_BIST_FAIL		BIT(16)	// PCIE PDATA RAM BIST FAIL.
+#define		C_MAC_BIST_RDY			BIT(10)	// MAC MBIST Test report Ready.
+#define		C_USB_BIST_RDY			BIT(9)	// USB MBIST Test report Ready.
+#define		C_PCIE_BIST_RDY			BIT(8)	// PCIE MBIST Test report Ready.
+#define		C_MAC_BIST_START			BIT(2)	// MAC MBIST START PULSE.
+#define		C_USB_BIST_START			BIT(1)	// USB MBIST START PULSE.
+#define		C_PCIE_BIST_START			BIT(0)	// PCIE MBIST START PULSE.
+
+//----------------------------------------------------------------------------
+//       8192C USB_SIE_INTF bits					(Offset 0xE0-E3, 32 bits)
+//----------------------------------------------------------------------------
+#define		USB_SIE_INTF_WE			BIT(25)	// Write Enable of SIE interface.
+#define		USB_SIE_INTF_BYIOREG		BIT(24)	// SIE Bypass IOREG interface.
+#define		USB_SIE_INTF_ADDR_SHIFT	16	// The address of SIE register.
+#define		USB_SIE_INTF_ADDR_Mask	0x0FF
+#define		USB_SIE_INTF_RD_SHIFT		8	// The read data from USB SIE.
+#define		USB_SIE_INTF_RD_Mask		0x0FF
+#define		USB_SIE_INTF_WD_SHIFT	0	// The write data to USB SIE.
+#define		USB_SIE_INTF_WD_Mask		0x0FF
+
+//----------------------------------------------------------------------------
+//       8192C PCIE_MIO_INTF bits				(Offset 0xE4-E7, 32 bits)
+//----------------------------------------------------------------------------
+#define		PCIE_MIO_BYIOREG		BIT(13)	// MIO bypass IOREG interface.
+#define		PCIE_MIO_RE			BIT(12)	// Read Enable of MIO interface.
+#define		PCIE_MIO_WE_SHIFT		8	// Write Byte Enable of MIO interface.
+#define		PCIE_MIO_WE_Mask		0x0F
+#define		PCIE_MIO_ADDR_SHIFT	0	// The address of PCIE MIO Access register.
+#define		PCIE_MIO_ADDR_Mask	0x0FF
+
+//----------------------------------------------------------------------------
+//       8192C HPON_FSM bits					(Offset 0xEC-EF, 32 bits)
+//----------------------------------------------------------------------------
+#define		EVENT_FSM_SHIFT	16	// The State Machine Trigger Events.
+#define		EVENT_FSM_Mask	0x0FFFF
+#define		PMC_ADDR_SHIFT	8	// The Hardware Access HPON Register Addr.
+#define		PMC_ADDR_Mask		0x0FF
+#define		PMC_WR				BIT(7)	// The Hardware Access HPON Register Write Pulse.
+#define		PMC_DATA			BIT(6)	// The Hardware Access HPON Register Data.
+#define		FSM_STATE_SHIFT	0	// The State Machine Data.
+#define		FSM_STATE_Mask	0x03F
+
+//----------------------------------------------------------------------------
+//       8192C SYS_CFG bits					(Offset 0xF0-F3, 32 bits)
+//----------------------------------------------------------------------------
+#define		TRP_ICFG_SHIFT			28	// Trapped ICFG data value.
+#define		TRP_ICFG_Mask			0x0F
+#define		TYPE_ID					BIT(27)	// 1: 8191C/8192C ; 0: 8188C.
+#define		BD_HCI_SEL				BIT(26)	// Trapped HCI_SEL value.
+#define		BD_PKG_SEL				BIT(25)	// Trapped PKG_ENG_SEL value.
+#define		TRP_BT_EN				BIT(24)	// Trapped BT Chip Valid need XTAL & SPS resource.
+#define		TRP_VAUX_EN			BIT(23)	// Trapped VAUX_EN.
+#define		PAD_HWPD_IDN			BIT(22)	// HWPDN PAD status Indicator.
+#define		PSC_TESTCFG_SHIFT		20	// Test Pin configuration.
+#define		PSC_TESTCFG_Mask		0x03
+#define		CHIP_VER_RL_SHIFT		16	// Chip version (RL6111).
+#define		CHIP_VER_RL_Mask		0x0F
+#define		CHIP_VER_RTL_SHIFT	12	// Test Chip version - 8188C (RLE0307) / 8191C (RLE0308).
+#define		CHIP_VER_RTL_Mask		0x0F
+#define		IC_MACPHY_MODE		BIT(11)	// 0: IC Normal Mode, 1: force IC PHY_ASIC Mode.
+#define		BD_MAC1				BIT(10)	// Bonding option for MAC function-1 Enable.
+#define		BD_MAC2				BIT(9)	// Bonding option for MAC function-2 Enable.
+#define		SIC_IDLE				BIT(8)	// Indicator of SIC idle state.
+#define		TRP_B15V_EN			BIT(7)	// Trapped option for 1.5V of board.
+#define		OCP_SHUTDN			BIT(6)	// SPS OCP shutdown Chip.
+#define		V15_VLD				BIT(5)	// 1.5V Power Ready, 1: Power Ready.
+#define		PCIRSTB					BIT(4)	// PCIE External PERST, Pin Status.
+#define		PCLK_VLD				BIT(3)	// PCIE PHY Clock Stable, 1: Clock Stable.
+#define		UCLK_VLD				BIT(2)	// USB PHY Clock Stable, 1: Clock Stable.
+#define		ACLK_VLD				BIT(1)	// AFE Clock Stable, 1: Clock Stable.
+#define		XCLK_VLD				BIT(0)	// Xtal Clock Stable, 1: Clock Stable.
+
+
+//
+// 2. MACTOP General Configuration. (Offset 0x100 - 0x1FFh)
+//
+//----------------------------------------------------------------------------
+//       8192C CR bits						(Offset 0x100-103, 32 bits)
+//----------------------------------------------------------------------------
+#define		LBMODE_SHIFT		24	// Loopback mode.
+#define		LBMODE_Mask		0x0F
+#define		NETYPE_SHIFT		16	// Network Type.
+#define		NETYPE_Mask		0x03
+#define		MAC_SEC_EN		BIT(9)	// Enable MAC security engine.
+#define		ENSWBCN			BIT(8)	// Enable SW TX beacon.
+#define		MACRXEN			BIT(7)	// MAC Receiver Enable.
+#define		MACTXEN			BIT(6)	// MAC Transmitter Enable.
+#define		SCHEDULE_EN		BIT(5)	// Schedule Enable.
+#define		PROTOCOL_EN		BIT(4)	// protocol Block Function Enable.
+#define		RXDMA_EN			BIT(3)	// RXDMA Function Enable.
+#define		TXDMA_EN			BIT(2)	// TXDMA Function Enable.
+#define		HCI_RXDMA_EN		BIT(1)	// HCI to RXDMA Interface Enable.
+#define		HCI_TXDMA_EN		BIT(0)	// HCI to TXDMA Interface Enable.
+// Loopback mode.
+#define		LB_NORMAL			0x00
+#define		LB_MAC				0x0B
+#define		LB_MAC_DLY			0x03
+#define		LB_PHY				0x01
+#define		LB_DMA				0x07
+#define		LB_DUAL_MAC		0x1B	// 92D_REG
+// Network Type.
+#define		NETYPE_NOLINK		0x00
+#define		NETYPE_ADHOC		0x01
+#define		NETYPE_INFRA		0x02
+#define		NETYPE_AP			0x03
+
+//----------------------------------------------------------------------------
+//       8192C PBP bits						(Offset 0x104-107, 32 bits)
+//----------------------------------------------------------------------------
+#define		PSTX_SHIFT			4	// Page size of transmit packet buffer.
+#define		PSTX_Mask			0x0F
+#define		PSRX_SHIFT			0	// Page size of receive packet buffer and C2HCMD buffer.
+#define		PSRX_Mask			0x0F
+// Page size
+#define		PBP_64B			0x00
+#define		PBP_128B			0x01
+#define		PBP_256B			0x02
+#define		PBP_512B			0x03
+#define		PBP_1024B			0x04
+
+//----------------------------------------------------------------------------
+//       8192C TRXDMA_CTRL bits				(Offset 0x10C-10D, 16 bits)
+//----------------------------------------------------------------------------
+#define		HPQ_SEL_SHIFT		8	// High Priority Queue Selection.
+#define		HPQ_SEL_Mask		0x03F
+#define		RXDMA_AGG_EN		BIT(2)	//
+#define		RXSHFT_EN			BIT(1)	// When this bit is set, RX shift to fit alignment is enable.
+#define		RXDMA_ARBBW_EN	BIT(0)	// Enable RXDMA Arbitrator priority for Host interface.
+// High Priority Queue Selection.
+#define		HPQ_SEL_VOQ		BIT(0)
+#define		HPQ_SEL_VIQ		BIT(1)
+#define		HPQ_SEL_BEQ		BIT(2)
+#define		HPQ_SEL_BKQ		BIT(3)
+#define		HPQ_SEL_MGQ		BIT(4)
+#define		HPQ_SEL_HIQ		BIT(5)
+
+//----------------------------------------------------------------------------
+//       8192C TRXFF_BNDY bits				(Offset 0x114-117, 32 bits)
+//----------------------------------------------------------------------------
+#define		RXFF0_BNDY_SHIFT			16	// upper boundary of RXFF0.
+#define		RXFF0_BNDY_Mask			0x0FFFF
+#define		TXPKTBUF_PGBNDY_SHIFT	0	// From FWHW offload, sets the max pages controlled by TXDMA.
+#define		TXPKTBUF_PGBNDY_Mask		0x0FF
+
+//----------------------------------------------------------------------------
+//       8192C TRXFF_STATUS bits				(Offset 0x118-11B, 32 bits)
+//----------------------------------------------------------------------------
+#define		TXPKTFF_FULL		BIT(16)	// TXDMA block the current TX pkt due to TXPKTBUF full, status bit will be set.
+#define		RXFF1_OVF			BIT(1)	// When this bit is "1", RXFF1 is under overflow condition.
+#define		RXFF0_OVF			BIT(0)	// When this bit is "1", RXFF0 is under overflow condition.
+
+//----------------------------------------------------------------------------
+//       8192C RXFF_PTR bits					(Offset 0x11C-11F, 32 bits)
+//----------------------------------------------------------------------------
+#define		RXFF0_RDPTR_SHIFT		16	// The read pointer address of RXFF0.
+#define		RXFF0_RDPTR_Mask		0x0FFFF
+#define		RXFF0_WTPTR_SHIFT		0	// The write pointer address of RXFF0.
+#define		RXFF0_WTPTR_Mask		0x0FFFF
+
+//----------------------------------------------------------------------------
+//       8192C HIMR bits						(Offset 0x120-123, 32 bits)
+//----------------------------------------------------------------------------
+//----------------------------------------------------------------------------
+//       8192C HISR bits						(Offset 0x124-127, 32 bits)
+//----------------------------------------------------------------------------
+#define		HIMR_BCNDMA7		BIT(31)	// Beacon DMA Interrupt 7.
+#define		HIMR_BCNDMA6		BIT(30)	// Beacon DMA Interrupt 6.
+#define		HIMR_BCNDMA5		BIT(29)	// Beacon DMA Interrupt 5.
+#define		HIMR_BCNDMA4		BIT(28)	// Beacon DMA Interrupt 4.
+#define		HIMR_BCNDMA3		BIT(27)	// Beacon DMA Interrupt 3.
+#define		HIMR_BCNDMA2		BIT(26)	// Beacon DMA Interrupt 2.
+#define		HIMR_BCNDMA1		BIT(25)	// Beacon DMA Interrupt 1.
+#define		HIMR_BCNDOK7		BIT(24)	// Beacon Queue DMA OK Interrupt7.
+#define		HIMR_BCNDOK6		BIT(23)	// Beacon Queue DMA OK Interrupt6.
+#define		HIMR_BCNDOK5		BIT(22)	// Beacon Queue DMA OK Interrupt5.
+#define		HIMR_BCNDOK4		BIT(21)	// Beacon Queue DMA OK Interrupt4.
+#define		HIMR_BCNDOK3		BIT(20)	// Beacon Queue DMA OK Interrupt3.
+#define		HIMR_BCNDOK2		BIT(19)	// Beacon Queue DMA OK Interrupt2.
+#define		HIMR_BCNDOK1		BIT(18)	// Beacon Queue DMA OK Interrupt1.
+#define		HIMR_TIMEOUT2		BIT(17)	// Time Out Interrupt 2.
+#define		HIMR_TIMEOUT1		BIT(16)	// Time Out Interrupt 1.
+#define		HIMR_TXFOVW		BIT(15)	// Transmit packet buffer Overflow.
+#define		HIMR_PSTIMEOUT	BIT(14)	// Power Save Time Out Interrupt.
+#define		HIMR_BCNDMA0		BIT(13)	// Beacon DMA Interrupt 0.
+#define		HIMR_RXFOVW		BIT(12)	// Receive packet buffer Overflow.
+#define		HIMR_RDU			BIT(11)	// Receive Descriptor Unavailable.
+#define		HIMR_ATIM_END		BIT(10)	// ATIM Window End Interrupt.
+#define		HIMR_BCNDOK0		BIT(9)	// Beacon Queue DMA OK Interrupt0.
+#define		HIMR_HIGHDOK		BIT(8)	// High Queue DMA OK Interrupt.
+#define		HIMR_TXBCNOK		BIT(7)	// Transmit Beacon OK Interrupt.
+#define		HIMR_MGTDOK		BIT(6)	// Management Queue DMA OK Interrupt.
+#define		HIMR_TXBCNERR		BIT(5)	// Transmit Beacon Error Interrupt.
+#define		HIMR_BKDOK			BIT(4)	// AC_BK DMA OK Interrupt.
+#define		HIMR_BEDOK			BIT(3)	// AC_BE DMA OK Interrupt.
+#define		HIMR_VIDOK			BIT(2)	// AC_VI DMA OK Interrupt.
+#define		HIMR_VODOK		BIT(1)	// AC_VO DMA Interrupt.
+#define		HIMR_ROK			BIT(0)	// Receive DMA OK Interrupt.
+
+//----------------------------------------------------------------------------
+//       8192C HIMRE bits					(Offset 0x128-12A, 24 bits)
+//----------------------------------------------------------------------------
+//----------------------------------------------------------------------------
+//       8192C HISRE bits					(Offset 0x12C-12E, 24 bits)
+//----------------------------------------------------------------------------
+#define		HIMRE_TXERR		BIT(11)	// Enable Tx Error Flag Interrupt.
+#define		HIMRE_RXERR		BIT(10)	// Enable Rx Error Flag Interrupt.
+#define		HIMRE_C2HCMD		BIT(9)	// Enable CPU to Host Command Interrupt.
+#define		HIMRE_CPWM		BIT(8)	// Enable CPU power Mode exchange Interrupt.
+#define		HIMRE_HBT_CMD		BIT(7)	// 92D_REG, Host BT_CMD interrupt mask
+#define		HIMRE_OCPINT		BIT(1)	// Enable SPS_OCP Interrupt.
+#define		HIMRE_WLANOFF		BIT(0)	// Enable WLAN power down Interrupt.
+
+//----------------------------------------------------------------------------
+//       8192C CPWM bits					(Offset 0x12F, 8 bits)
+//----------------------------------------------------------------------------
+#define		CPWM_TOGGLING	BIT(7)	// When this bit is toggled, interrtup is send to HISRE.CPWMINT.
+#define		CPWM_MOD_SHIFT	0	// The current power mode index.
+#define		CPWM_MOD_Mask	0x07F
+
+//----------------------------------------------------------------------------
+//       8192C FWIMR bits					(Offset 0x130-133, 32 bits)
+//----------------------------------------------------------------------------
+//----------------------------------------------------------------------------
+//       8192C FWISR bits					(Offset 0x134-137, 32 bits)
+//----------------------------------------------------------------------------
+#define		FWIMR_VOQ			BIT(31)	//
+#define		FWIMR_VIQ			BIT(30)	//
+#define		FWIMR_BEQ			BIT(29)	//
+#define		FWIMR_BKQ			BIT(28)	//
+#define		FWIMR_MGTQ		BIT(27)	//
+#define		FWIMR_HIQ			BIT(26)	//
+#define		FWIMR_TXPKTIN		BIT(25)	// interrupt is issued to inform MCU.
+#define		FWIMR_TXBCNOK		BIT(24)	// interrupt is issued when a beacon frame is transmitted.
+#define		FWIMR_TXBCNERR	BIT(23)	// interrupt is issued when beacon in TXPKTBUF fails to send out.
+#define		FWIMR_RX_UMD0	BIT(22)	// receiving unicast data frame with More Data=0.
+#define		FWIMR_RX_UMD1	BIT(21)	// receiving unicast data frame with More Data=1.
+#define		FWIMR_RX_BMD0		BIT(20)	// receiving broadcast data frame with More Data=0.
+#define		FWIMR_RX_BMD1		BIT(19)	// receiving broadcast data frame with More Data=1.
+#define		FWIMR_BCN_RX		BIT(18)	// When receiving Beacon frame.
+#define		FWIMR_TBTT		BIT(17)	// The exact TBTT time interrupt.
+#define		FWIMR_BCNERLY		BIT(16)	// This interrupt is issue at the time set by DRVERLYINT register before TBTT time.
+#define		FWIMR_BCNDMA7	BIT(15)	// When BCNDMA interval arrives before TBTT7, informs MCU to prepare beacon.
+#define		FWIMR_BCNDMA6	BIT(14)	// When BCNDMA interval arrives before TBTT6, informs MCU to prepare beacon.
+#define		FWIMR_BCNDMA5	BIT(13)	// When BCNDMA interval arrives before TBTT5, informs MCU to prepare beacon.
+#define		FWIMR_BCNDMA4	BIT(12)	// When BCNDMA interval arrives before TBTT4, informs MCU to prepare beacon.
+#define		FWIMR_BCNDMA3	BIT(11)	// When BCNDMA interval arrives before TBTT3, informs MCU to prepare beacon.
+#define		FWIMR_BCNDMA2	BIT(10)	// When BCNDMA interval arrives before TBTT2, informs MCU to prepare beacon.
+#define		FWIMR_BCNDMA1	BIT(9)	// When BCNDMA interval arrives before TBTT1, informs MCU to prepare beacon.
+#define		FWIMR_BCNDMA0	BIT(8)	// When BCNDMA interval arrives before TBTT0, informs MCU to prepare beacon.
+#define		FWIMR_LP_STBY		BIT(7)	// Low Power Standby Wake interrupt.
+#define		FWIMR_ATIM		BIT(6)	// This interrupt is issued when it is at the time ATIM ms before ATIMWND expiring.
+#define		FWIMR_HRCV		BIT(5)	// Host Recover CPU Loop Instruction.
+#define		FWIMR_H2CCMD		BIT(4)	// Host To CPU Message Interrupt.
+#define		FWIMR_RXDONE		BIT(3)	//
+#define		FWIMR_ERRORHDL	BIT(2)	// FWHW/ TXDMA/ RXDMA/ WMAC error status interrupt.
+#define		FWIMR_TXCCX		BIT(1)	//
+#define		FWIMR_TXCLOSE		BIT(0)	//
+
+//----------------------------------------------------------------------------
+//       8192C FTIMR bits					(Offset 0x138-13B, 32 bits)
+//----------------------------------------------------------------------------
+//----------------------------------------------------------------------------
+//       8192C FTISR bits					(Offset 0x13C-13F, 32 bits)
+//----------------------------------------------------------------------------
+#define		FTIMR_FWBT_CMD	BIT(18)	// 92D_REG, FW BT_CMD interrupt mask
+#define		FTIMR_RPWM		BIT(8)	// RPWM INT Status. Write 1 clear.
+#define		FTIMR_PSTIMER		BIT(7)	// Enable PSTimer interrupt.
+#define		FTIMR_TIMEOUT1	BIT(6)	// Enable Timer1 interrupt.
+#define		FTIMR_TIMEOUT0	BIT(5)	// Enable Timer0 interrupt.
+#define		FTIMR_GT4			BIT(4)	// Enable General Timer[4] interrupt.
+#define		FTIMR_GT3			BIT(3)	// Enable General Timer[3] interrupt.
+#define		FTIMR_GT2			BIT(2)	// Enable General Timer[2] interrupt.
+#define		FTIMR_GT1			BIT(1)	// Enable General Timer[1] interrupt.
+#define		FTIMR_GT0			BIT(0)	// Enable General Timer[0] interrupt.
+
+//----------------------------------------------------------------------------
+//       8192C PKTBUF_DBG_CTRL bits			(Offset 0x140-143, 32 bits)
+//----------------------------------------------------------------------------
+#define		RXPKTBUF_DBG				BIT(14)	// 1: Enable RXPKTBUF debug mode.
+#define		TXPKTBUF_DBG				BIT(13)	// 1: Enable TXPKTBUF debug mode.
+#define		PKTBUF_DBG_ADDR_SHIFT	0	// The address of TRXPKTBUF to be read.
+#define		PKTBUF_DBG_ADDR_Mask		0x01FFF
+
+//		General Purpose Timer. (Offset 0x150 - 0x16Fh)
+//----------------------------------------------------------------------------
+//       8192C TC0_CTRL bits					(Offset 0x150-153, 32 bits)
+//----------------------------------------------------------------------------
+//----------------------------------------------------------------------------
+//       8192C TC1_CTRL bits					(Offset 0x154-157, 32 bits)
+//----------------------------------------------------------------------------
+//----------------------------------------------------------------------------
+//       8192C TC2_CTRL bits					(Offset 0x158-15B, 32 bits)
+//----------------------------------------------------------------------------
+//----------------------------------------------------------------------------
+//       8192C TC3_CTRL bits					(Offset 0x15C-15F, 32 bits)
+//----------------------------------------------------------------------------
+//----------------------------------------------------------------------------
+//       8192C TC4_CTRL bits					(Offset 0x160-163, 32 bits)
+//----------------------------------------------------------------------------
+#define		TCINT_EN			BIT(26)	// When write "1" to this bit, Counter starts counting down.
+#define		TCMODE				BIT(25)	// Timer/Counter mode.
+#define		TCEN				BIT(24)	// Timer/Counter enable.
+#define		TCData_SHIFT		0	// Timer/Counter data register. It specifies the time-out duration.
+#define		TCData_Mask		0x0FFFFFF
+
+//----------------------------------------------------------------------------
+//       8192C TCUNIT_BASE bits				(Offset 0x164-165, 16 bits)
+//----------------------------------------------------------------------------
+#define		TCUNIT_BASE_TIME_SHIFT	0	// num of clocks that equals to the base time unit of timer/counter.
+#define		TCUNIT_BASE_TIME_Mask	0x03FFF
+//		General Purpose Timer. (Offset 0x150 - 0x16Fh)
+
+//----------------------------------------------------------------------------
+//       8192C MBIST_START bits				(Offset 0x174-177, 32 bits)
+//----------------------------------------------------------------------------
+#define		TXLLT_BISTP		BIT(10)	// TXLLT BIST Start Pulse.
+#define		TXOQT_BISTP		BIT(9)	// TXOQT BIST Start Pulse.
+#define		TXPKT_BISTP		BIT(8)	// TXPKT Buffer BIST Start Pulse.
+#define		RXPKT_BISTP		BIT(7)	// RXPKT Buffer BIST Start Pulse.
+#define		TXDBUF_BISTP		BIT(6)	// TXDBUF BIST Start Pulse.
+#define		TXFIFO_BISTP		BIT(5)	// TXFIFO BIST Start Pulse.
+#define		RXFIFO_BISTP		BIT(4)	// RXFIFO BIST Start Pulse.
+#define		WKEYLLT_BISTP		BIT(3)	// WKEY BIST Start Pulse.
+#define		WRXBA_BISTP		BIT(2)	// WRXBA BIST Start Pulse.
+
+//----------------------------------------------------------------------------
+//       8192C MBIST_DONE bits				(Offset 0x178-17B, 32 bits)
+//----------------------------------------------------------------------------
+#define		TXLLT_BISTD		BIT(10)	// TXLLT BIST Done.
+#define		TXOQT_BISTD		BIT(9)	// TXOQT BIST Done.
+#define		TXPKT_BISTD		BIT(8)	// TXPKT Buffer BIST Done.
+#define		RXPKT_BISTD		BIT(7)	// RXPKT Buffer BIST Done.
+#define		TXDBUF_BISTD		BIT(6)	// TXDBUF BIST Done.
+#define		TXFIFO_BISTD		BIT(5)	// TXFIFO BIST Done.
+#define		RXFIFO_BISTD		BIT(4)	// RXFIFO BIST Done.
+#define		WKEYLLT_BISTD		BIT(3)	// WKEY BIST Done.
+#define		WRXBA_BISTD		BIT(2)	// WRXBA BIST Done.
+
+//----------------------------------------------------------------------------
+//       8192C MBIST_FAIL bits				(Offset 0x17C-17F, 32 bits)
+//----------------------------------------------------------------------------
+#define		TXLLT_BISTF		BIT(10)	// TXLLT BIST Fail.
+#define		TXOQT_BISTF		BIT(9)	// TXOQT BIST Fail.
+#define		TXPKT_BISTF		BIT(8)	// TXPKT Buffer BIST Fail.
+#define		RXPKT_BISTF		BIT(7)	// RXPKT Buffer BIST Fail.
+#define		TXDBUF_BISTF		BIT(6)	// TXDBUF BIST Fail.
+#define		TXFIFO_BISTF		BIT(5)	// TXFIFO BIST Fail.
+#define		RXFIFO_BISTF		BIT(4)	// RXFIFO BIST Fail.
+#define		WKEYLLT_BISTF		BIT(3)	// WKEY BIST Fail.
+#define		WRXBA_BISTF		BIT(2)	// WRXBA BIST Fail.
+
+//----------------------------------------------------------------------------
+//       8192C FMETHR bits					(Offset 0x1C8-1CB, 32 bits)
+//----------------------------------------------------------------------------
+#define		FMSG_INT			BIT(31)	// Toggle this bit will generate interrupt to Host.
+#define		FW_MSG_SHIFT		0	// User Defined Message.
+#define		FW_MSG_Mask		0x07FFFFFFF
+
+//----------------------------------------------------------------------------
+//       8192C HMETFR bits					(Offset 0x1CC-1CF, 32 bits)
+//----------------------------------------------------------------------------
+#define		HRCV_MSG_SHIFT	24	// User Defined Message.
+#define		HRCV_MSG_Mask		0x0FF
+#define		INT_BOX3			BIT(3)	// MSG_BOX_3 Valid. Enable when the Entry is write.
+#define		INT_BOX2			BIT(2)	// MSG_BOX_2 Valid. Enable when the Entry is write.
+#define		INT_BOX1			BIT(1)	// MSG_BOX_1 Valid. Enable when the Entry is write.
+#define		INT_BOX0			BIT(0)	// MSG_BOX_0 Valid. Enable when the Entry is write.
+
+//----------------------------------------------------------------------------
+//       8192C LLT_INI bits					(Offset 0x1E0-1E3, 32 bits)
+//----------------------------------------------------------------------------
+#define		LLTE_RWM_SHIFT		30	//
+#define		LLTE_RWM_Mask			0x03
+#define		LLTINI_PDATA_SHIFT	16	// LLT Entry Write/Read DATA for MCU.
+#define		LLTINI_PDATA_Mask		0x0FF
+#define		LLTINI_ADDR_SHIFT		8	// LLT Entry Access Offset.
+#define		LLTINI_ADDR_Mask		0x0FF
+#define		LLTINI_HDATA_SHIFT	0	// LLT Entry Write/Read DATA for HCI.
+#define		LLTINI_HDATA_Mask		0x0FF
+// LLTE_RWM
+#define		LLTE_RWM_NO_ACTIVE	0x00
+#define		LLTE_RWM_WR			0x01
+#define		LLTE_RWM_RD			0x03
+
+//----------------------------------------------------------------------------
+//       8192C BB_ACCEESS_CTRL bits			(Offset 0x1E8-1EB, 32 bits)
+//----------------------------------------------------------------------------
+#define		BB_WRITE_READ_SHIFT	30	//
+#define		BB_WRITE_READ_Mask	0x03
+#define		BB_WRITE_EN_SHIFT		12	// Byte Write Enable.
+#define		BB_WRITE_EN_Mask		0x0F
+#define		BB_ADDR_SHIFT			2	// Baseband Access Write/Read Address (in DW unit).
+#define		BB_ADDR_Mask			0x03FF
+#define		BB_ERRACC				BIT(0)	// Duplicate Access when previous cycle pending (write one clear).
+
+
+//
+// 3. TXDMA/RXDMA Configuration. (Offset 0x200 - 0x2FFh)
+//
+//----------------------------------------------------------------------------
+//       8192C RQPN bits						(Offset 0x200-203, 32 bits)
+//----------------------------------------------------------------------------
+#define		LD_RQPN			BIT(31)	// Write 1 to set RQPN bit[79:0] value to page numbers for initialization.
+#define		LPQ_PUBLIC_DIS		BIT(25)	// bit=1, available Tx page size excludes the public queue.
+#define		HPQ_PUBLIC_DIS		BIT(24)	// bit=1, available Tx page size excludes the public queue.
+#define		PUBQ_SHIFT			16	// Public Reserved Page Number.
+#define		PUBQ_Mask			0x0FF
+#define		LPQ_SHIFT			8	// Low Priority Queue Reserved Page Number.
+#define		LPQ_Mask			0x0FF
+#define		HPQ_SHIFT			0	// High Priority Queue Reserved Page Number.
+#define		HPQ_Mask			0x0FF
+
+//----------------------------------------------------------------------------
+//       8192C FIFOPAGE bits					(Offset 0x204-207, 32 bits)
+//----------------------------------------------------------------------------
+#define		TXPKTNUM_SHIFT		24	// Packet number in TXPKTBUF.
+#define		TXPKTNUM_Mask			0x0FF
+#define		PUB_AVAL_PG_SHIFT		16	// Available Public Queue Page Number.
+#define		PUB_AVAL_PG_Mask		0x0FF
+#define		LPQ_AVAL_PG_SHIFT		8	// Available Low Priority Queue Page Number.
+#define		LPQ_AVAL_PG_Mask		0x0FF
+#define		HPQ_AVAL_PG_SHIFT		0	// Available High Priority Queue Page Number.
+#define		HPQ_AVAL_PG_Mask		0x0FF
+
+//----------------------------------------------------------------------------
+//       8192C TDECTRL bits					(Offset 0x208-20B, 32 bits)
+//----------------------------------------------------------------------------
+#define		LLT_FREE_PAGE_SHIFT	24	// LLT Free Page.
+#define		LLT_FREE_PAGE_Mask	0x0FF
+#define		BCN_VALID				BIT(16)	// bit=1, beacon packet has finished to write to txpktbuffer.
+#define		BCN_HEAD_SHIFT		8	// head page of Bcnq packet which is Tx DMA filled.
+#define		BCN_HEAD_Mask			0x0FF
+#define		BLK_DESC_NUM_SHIFT	4	// The Most Number of Tx Descriptor per Bulk Out Only for USB.
+#define		BLK_DESC_NUM_Mask	0x0F
+
+//----------------------------------------------------------------------------
+//       8192C TXDMA_OFFSET_CHK bits		(Offset 0x20C-20F, 32 bits)
+//----------------------------------------------------------------------------
+#define		PG_UNDER_TH_SHIFT	16	// Page threshold value is check by Tx DMA engine.
+#define		PG_UNDER_TH_Mask		0x0FF
+#define		CHK_PG_TH_EN			BIT(10)	// Enable Tx DMA to check total pages if it is under page threshold.
+#define		DROP_DATA_EN			BIT(9)	// Enable Tx DMA to drop the redundant data of packet.
+#define		CHECK_OFFSET_EN		BIT(8)	// Enable Tx DMA to check offset value.
+#define		CHECK_OFFSET_SHIFT	0	// Offset value is check by Tx DMA engine.
+#define		CHECK_OFFSET_Mask		0x0FF
+
+//----------------------------------------------------------------------------
+//       8192C TXDMA_STATUS bits			(Offset 0x210-213, 32 bits)
+//----------------------------------------------------------------------------
+#define		PAYLOAD_UDN		BIT(14)	// Payload is under the packet length of Tx descriptor.
+#define		PAYLOAD_OVF		BIT(13)	// Payload is over the packet length of Tx descriptor.
+#define		DSC_CHKSUM_FAIL	BIT(12)	// Tx descriptor checksum error.
+#define		UNKNOWN_QSEL		BIT(11)	// An unknown QSEL of Tx descriptor is detected.
+#define		EP_QSEL_DIFF		BIT(10)	// Tx Endpoint is unmatched with the QSEL of descriptor.
+#define		TX_OFFS_UNMATCH	BIT(9)	// Tx offset is unmatched.
+#define		TXOQT_UDN			BIT(8)	// TXOQT Underflow.
+#define		TXOQT_OVF			BIT(7)	// TXOQT Overflow.
+#define		TXDMA_SFF_UDN		BIT(6)	// TXDMA Sync FIFO Underflow.
+#define		TXDMA_SFF_OVF		BIT(5)	// TXDMA Sync FIFO Overflow.
+#define		LLT_NULL_PG		BIT(4)	// TXDMA reads NULL page.
+#define		PAGE_UDN			BIT(3)	// Total pages included PTCL un-return pages under the total reserved pages.
+#define		PAGE_OVF			BIT(2)	// Total pages included PTCL un-return pages over the total reserved pages.
+#define		TXFF_PG_UDN		BIT(1)	// TXFF page underflow in TDE page controller.
+#define		TXFF_PG_OVF		BIT(0)	// TXFF page overflow in TDE page controller.
+
+//----------------------------------------------------------------------------
+//       8192C RXDMA_AGG_PG_TH bits		(Offset 0x280-283, 32 bits)
+//----------------------------------------------------------------------------
+#define		RXDMA_AGG_PG_TH_LMT(x)	((x & 0x0FF)<<0)	// DMA inform host to receive pkts, when exceeds the threshold.
+
+//----------------------------------------------------------------------------
+//       8192C RXPKT_NUM bits				(Offset 0x284-287, 32 bits)
+//----------------------------------------------------------------------------
+#define		RXPKT_NUM_LMT_SHIFT	24	// number of packets in RXPKTBUF.
+#define		RXPKT_NUM_LMT_Mask	0x0FF
+#define		RW_RELEASE_EN			BIT(18)	// bit=1, RXDMA will enter this mode after RXDMA packet to host completed and stop.
+#define		RXDMA_IDLE				BIT(17)	// RXDMA finishes DMA will report idle state in this bit.
+#define		RXPKT_RELEASE_POLL	BIT(16)	// bit=1, RXDMA will decrease RX PKT counter by one.
+#define		FW_UPD_RDPTR_SHIFT	0	// FW updates before write RXPKT_RELEASE_POLL to 1.
+#define		FW_UPD_RDPTR_Mask	0x0FFFF
+
+//----------------------------------------------------------------------------
+//       8192C RXDMA_STATUS bits			(Offset 0x288-28B, 32 bits)
+//----------------------------------------------------------------------------
+#define		FW_POLL_ISSUE		BIT(5)	// FW Release Poll Error.
+#define		RX_DATA_UDN		BIT(4)	// RX Data Underflow. Clear by SW.
+#define		RX_SFF_UDN			BIT(3)	// RX Sync FIFO Underflow.
+#define		RX_SFF_OVF			BIT(2)	// RX Sync FIFO Overflow.
+#define		USB_REQ_LEN_OVF	BIT(1)	// USB RXAGGEN Error due to RX length overflow.
+#define		RXPKT_OVF			BIT(0)	// When RX Packet is more than 255 packets remaining in FF.
+
+
+//
+// 4. PCIE EMAC Reserved Region. (Offset 0x300 - 0x3FFh)
+//
+//----------------------------------------------------------------------------
+//       8192C PCIE_CTRL_REG bits			(Offset 0x300-303, 32 bits)
+//----------------------------------------------------------------------------
+#define		MAX_RXDMA_SHIFT	28	// RXDMA Burst Size selection.
+#define		MAX_RXDMA_Mask	0x07
+#define		MAX_TXDMA_SHIFT	24	// TXDMA Burst Size selection.
+#define		MAX_TXDMA_Mask	0x07
+#define		En_HWENTRL		BIT(19)	// Enable HW call EMAC to enter L23 actively.
+#define		EN_SWENTR_L23		BIT(17)	// Enable SW call EMAC to enter L23.
+#define		EN_HWEXITL1		BIT(16)	// Enable HW call EMAC to exit L1.
+#define		BCNQSTOP			BIT(15)	// BCNQ DMA STOP.
+#define		HQSTOP				BIT(14)	// HQ DMA STOP.
+#define		MGQSTOP			BIT(13)	// VOKQ DMA STOP.
+#define		VOQSTOP			BIT(12)	// VOKQ DMA STOP.
+#define		VIQSTOP			BIT(11)	// VIQ DMA STOP.
+#define		BEQSTOP			BIT(10)	// BEQ DMA STOP.
+#define		BKQSTOP			BIT(9)	// BKQ DMA STOP.
+#define		RXQSTOP			BIT(8)	// RX DMA STOP.
+#define		HQ_POLL			BIT(7)	// High Queue Polling bit, read result will be hpqflag.
+#define		MGQ_POLL			BIT(6)	// Manag Queue Polling bit, read result will be mgqflag.
+#define		BCNQ_POLL			BIT(4)	// BCNQ Polling bit, read result will be bpqflag.
+#define		VOQ_POLL			BIT(3)	// VOQ Polling bit, read result will be voqflag.
+#define		VIQ_POLL			BIT(2)	// VIQ Polling bit, read result will be viqflag.
+#define		BEQ_POLL			BIT(1)	// BEQ Polling bit, read result will be beqflag.
+#define		BKQ_POLL			BIT(0)	// BKQ Polling bit, read result will be bkqflag.
+
+//----------------------------------------------------------------------------
+//       8192C INT_MIG bits					(Offset 0x304-307, 32 bits)
+//----------------------------------------------------------------------------
+#define		TTMRMIT_Shift			28	// 92D_REG, Tx timer mitigation
+#define		TTMRMIT_Mask			0x0F
+#define		TNUMMIT_Shift			24	// 92D_REG, Tx number mitigation
+#define		TNUMMIT_Mask			0x0F
+#define		RTMRMIT_Shift			20	// 92D_REG, Rx timer mitigation
+#define		RTMRMIT_Mask			0x0F
+#define		RNUMMIT_Shift			16	// 92D_REG, Rx number mitigation
+#define		RNUMMIT_Mask			0x0F
+#define		INTMT_SHIFT			16	// Interrupt Couter for setting Interrupt Migration.
+#define		INTMT_Mask				0x0FFFF
+#define		MIGRATE_TIMER_SHIFT	0	// Timer for setting Interrupt Migration.
+#define		MIGRATE_TIMER_Mask	0x0FFFF
+
+//----------------------------------------------------------------------------
+//       8192C DBI bits						(Offset 0x348-353, 96 bits)
+//----------------------------------------------------------------------------
+#define		DBI_ACC_EXT		BIT(19)	// 92D_REG, DBI access external register on ELBI
+#define		DBI_MACSEL			BIT(18)	// 92D_REG, DBI access MAC1 select
+#define		DBI_RFLAG			BIT(17)	// DBI Read Flag.
+#define		DBI_WFLAG			BIT(16)	// DBI Write Flag.
+#define		DBI_WREN_SHIFT	12	// DBI Write Enable, High active.
+#define		DBI_WREN_Mask		0x0F
+#define		DBI_ADDR_SHIFT	0	// DBI Address.
+#define		DBI_ADDR_Mask		0x0FFF
+
+//----------------------------------------------------------------------------//
+//       8192C MDIO bits						(Offset 0x354-35B, 64 bits)
+//----------------------------------------------------------------------------
+#define		ECRC_EN			BIT(7)	// ECRC Enable.
+#define		MDIO_RFLAG			BIT(6)	// MDIO Read Flag.
+#define		MDIO_WFLAG		BIT(5)	// MDIO Write Flag.
+#define		MDIO_ADDR_SHIFT	0	// MDIO Address.
+#define		MDIO_ADDR_Mask	0x01F
+
+#define		MDIO_RDATA_SHIFT	16	// MDIO Read Data.
+#define		MDIO_RDATA_Mask	0x0FFFF
+#define		MDIO_WDATA_SHIFT	0	// MDIO Write Data.
+#define		MDIO_WDATA_Mask	0x0FFFF
+
+//----------------------------------------------------------------------------
+//       8192C UART_CTRL bits				(Offset 0x364-36B, 64 bits)
+//----------------------------------------------------------------------------
+#define		UART_WDATA_H_SHIFT	0	// UART Write Data [31:8], read will be UART Read Data[31:8].
+#define		UART_WDATA_H_Mask	0x0FFFFFF
+
+#define		UART_DMA_STS_SHIFT	24	// UART DMA Status.
+#define		UART_DMA_STS_Mask	0x07
+#define		UART_DMA_MOD			BIT(20)	// UART DMA Mode.
+#define		UART_RDMA				BIT(19)	// UART RX DMA Flag.
+#define		UART_TDMA				BIT(18)	// UART TX DMA Flag.
+#define		UART_RCMD				BIT(17)	// UART Read Command.
+#define		UART_WCMD				BIT(16)	// UART Write Command.
+#define		UART_ADDR_SHIFT		10	// UART Address.
+#define		UART_ADDR_Mask		0x03F
+#define		UART_WDATA_L_SHIFT	0	// UART Write Data [7:0], read will be UART Read Data[7:0].
+#define		UART_WDATA_L_Mask	0x0FF
+
+
+//
+// 5. PTCL/EDCA Configuration. (Offset 0x400 - 0x4FFh)
+//
+//----------------------------------------------------------------------------
+//       8192C VOQ_INFO bits				(Offset 0x400-403, 32 bits)
+//----------------------------------------------------------------------------
+//----------------------------------------------------------------------------
+//       8192C VIQ_INFO bits					(Offset 0x404-407, 32 bits)
+//----------------------------------------------------------------------------
+//----------------------------------------------------------------------------
+//       8192C BEQ_INFO bits					(Offset 0x408-40B, 32 bits)
+//----------------------------------------------------------------------------
+//----------------------------------------------------------------------------
+//       8192C BKQ_INFO bits					(Offset 0x40C-40F, 32 bits)
+//----------------------------------------------------------------------------
+//----------------------------------------------------------------------------
+//       8192C MGQ_INFO bits				(Offset 0x410-413, 32 bits)
+//----------------------------------------------------------------------------
+//----------------------------------------------------------------------------
+//       8192C HIQ_INFO bits					(Offset 0x414-417, 32 bits)
+//----------------------------------------------------------------------------
+#define		Q_CPU_HEAD_SHIFT	24	// MCU will handle q_pkt head.
+#define		Q_CPU_HEAD_Mask	0x0FF
+#define		Q_PKT_NUM_SHIFT	16	// total Q pkt number in TxPktbuffer.
+#define		Q_PKT_NUM_Mask	0x0FF
+#define		Q_FW_NUM_SHIFT	8	// total Q FW number in TxPktbuffer.
+#define		Q_FW_NUM_Mask	0x0FF
+#define		Q_HEAD_PG_SHIFT	0	// head page of the first packet of Q.
+#define		Q_HEAD_PG_Mask	0x0FF
+
+//----------------------------------------------------------------------------
+//       8192C BCNQ_INFO bits				(Offset 0x418-41A, 24 bits)
+//----------------------------------------------------------------------------
+#define		BCNQ_PKT_NUM_SHIFT	16	// total BCNQ pkt number in TxPktbuffer.
+#define		BCNQ_PKT_NUM_Mask	0x0FF
+#define		BCNQ_FW_NUM_SHIFT	8	// total BCNQ FW number in TxPktbuffer.
+#define		BCNQ_FW_NUM_Mask		0x0FF
+#define		BCNQ_HEAD_PG_SHIFT	0	// head page of the first packet of BCNQ.
+#define		BCNQ_HEAD_PG_Mask	0x0FF
+
+//----------------------------------------------------------------------------
+//       8192C TXPKT_EMPTY bits				(Offset 0x41B, 8 bits)
+//----------------------------------------------------------------------------
+#define		BCNQ_EMPTY		BIT(7)	// queue is empty. Report by MAC.
+#define		HQQ_EMPTY			BIT(6)	// queue is empty. Report by MAC.
+#define		HMGQ_EMPTY		BIT(5)	// queue is empty. Report by MAC.
+#define		CMGQ_EMPTY		BIT(4)	// queue is empty. Report by MAC.
+#define		BKQ_EMPTY			BIT(3)	// queue is empty. Report by MAC.
+#define		BEQ_EMPTY			BIT(2)	// queue is empty. Report by MAC.
+#define		VIQ_EMPTY			BIT(1)	// queue is empty. Report by MAC.
+#define		VOQ_EMPTY			BIT(0)	// queue is empty. Report by MAC.
+
+//----------------------------------------------------------------------------
+//       8192C CPU_MGQ_INFO bits			(Offset 0x41C-41F, 32 bits)
+//----------------------------------------------------------------------------
+#define		CPUMGQ_FW_NUM_SHIFT		8	// total CPU MGQ fw number in TxPktbuffer.
+#define		CPUMGQ_FW_NUM_Mask		0x0FF
+#define		CPUMGQ_HEAD_PG_SHIFT	0	// head page of CPU MGQ.
+#define		CPUMGQ_HEAD_PG_Mask		0x0FF
+
+//----------------------------------------------------------------------------
+//       8192C FWHW_TXQ_CTRL bits			(Offset 0x420-422, 24 bits)
+//----------------------------------------------------------------------------
+#define		RTS_LIMIT_IN_OFDM		BIT(23)	// 92D_REG, rts rate will not down to cck rate
+#define		EN_BCNQ_DL				BIT(22)	// 92D_REG, 1: ptcl consider there is bcn pkt in txbuf; 0: mask bcn pkt num in bcnq
+#define		EN_RD_RESP_NAV_BK	BIT(21)	// Control the RD responder NAV criteria for TX.
+#define		EN_WR_FREE_TAIL		BIT(20)	// 1:Drive wirte Bcnq_boundary,Hw set free_tail in Boundary-1; 0:no update.
+#define		CHK_LOSS_QSEL_SHIFT	17	//
+#define		CHK_LOSS_QSEL_Mask	0x07
+#define		EN_CHECK_LOSS			BIT(16)	// bit=1, HW will monitor packet loss from TXDMA.
+#define		EN_QUEUE_RPT_SHIFT	8	// 1: HW will report tx_status  0: no report.
+#define		EN_QUEUE_RPT_Mask	0x07F
+#define		EN_AMPDU_RTY_NEW		BIT(7)	// AMPDU aggregation mode with retry MPDUs and new MPDUs.
+#define		LIFETIME_EN			BIT(6)	// Enable lift time drop.
+#define		EN_CPU_HANDLE_SHIFT	0	// PKT need cpu handle.
+#define		EN_CPU_HANDLE_Mask	0x03F
+
+//----------------------------------------------------------------------------
+//       8192C HWSEQ_CTRL bits				(Offset 0x423, 8 bits)
+//----------------------------------------------------------------------------
+#define		HWSEQ_BCN_EN		BIT(6)	//
+#define		HWSEQ_HI_EN		BIT(5)	//
+#define		HWSEQ_MGT_EN		BIT(4)	//
+#define		HWSEQ_BK_EN		BIT(3)	//
+#define		HWSEQ_BE_EN		BIT(2)	//
+#define		HWSEQ_VI_EN		BIT(1)	//
+#define		HWSEQ_VO_EN		BIT(0)	//
+
+//----------------------------------------------------------------------------
+//       8192C MULTI_BCNQ_EN bits			(Offset 0x426, 8 bits)
+//----------------------------------------------------------------------------
+#define		MBID_BCNQ7_EN		BIT(7)	//
+#define		MBID_BCNQ6_EN		BIT(6)	//
+#define		MBID_BCNQ5_EN		BIT(5)	//
+#define		MBID_BCNQ4_EN		BIT(4)	//
+#define		MBID_BCNQ3_EN		BIT(3)	//
+#define		MBID_BCNQ2_EN		BIT(2)	//
+#define		MBID_BCNQ1_EN		BIT(1)	//
+#define		MBID_BCNQ0_EN		BIT(0)	//
+
+//----------------------------------------------------------------------------
+//       8192C MULTI_BCNQ_OFFSET bits			(Offset 0x427, 8 bits)
+//----------------------------------------------------------------------------
+#define		MBCNQ_OFFSET_SHIFT	0	// page number between two consecutive BCNQ head page.
+#define		MBCNQ_OFFSET_Mask	0x03
+
+//----------------------------------------------------------------------------
+//       8192C SPEC_SIFS bits					(Offset 0x428-429, 16 bits)
+//----------------------------------------------------------------------------
+#define		SPEC_SIFS_OFDM_SHIFT	8	// spec SIFS value for duration calculation.
+#define		SPEC_SIFS_OFDM_Mask	0x0FF
+#define		SPEC_SIFS_CCK_SHIFT	0	// spec SIFS value for duration calculation.
+#define		SPEC_SIFS_CCK_Mask	0x0FF
+
+//----------------------------------------------------------------------------
+//       8192C RL bits							(Offset 0x42A-42B, 16 bits)
+//----------------------------------------------------------------------------
+#define		SRL_SHIFT			8	// Short Retry Limit.
+#define		SRL_Mask			0x03F
+#define		LRL_SHIFT			0	// Long Retry Limit.
+#define		LRL_Mask			0x03F
+
+//----------------------------------------------------------------------------
+//       8192C DARFRC bits						(Offset 0x430-437, 64 bits)
+//----------------------------------------------------------------------------
+//----------------------------------------------------------------------------
+//       8192C RARFRC bits						(Offset 0x438-43F, 64 bits)
+//----------------------------------------------------------------------------
+#define		ARF_RC8_SHIFT		24	// Response Auto Rate Fallback Retry Count.
+#define		ARF_RC8_Mask		0x01F
+#define		ARF_RC7_SHIFT		16	// Response Auto Rate Fallback Retry Count.
+#define		ARF_RC7_Mask		0x01F
+#define		ARF_RC6_SHIFT		8	// Response Auto Rate Fallback Retry Count.
+#define		ARF_RC6_Mask		0x01F
+#define		ARF_RC5_SHIFT		0	// Response Auto Rate Fallback Retry Count.
+#define		ARF_RC5_Mask		0x01F
+
+#define		ARF_RC4_SHIFT		24	// Response Auto Rate Fallback Retry Count.
+#define		ARF_RC4_Mask		0x01F
+#define		ARF_RC3_SHIFT		16	// Response Auto Rate Fallback Retry Count.
+#define		ARF_RC3_Mask		0x01F
+#define		ARF_RC2_SHIFT		8	// Response Auto Rate Fallback Retry Count.
+#define		ARF_RC2_Mask		0x01F
+#define		ARF_RC1_SHIFT		0	// Response Auto Rate Fallback Retry Count.
+#define		ARF_RC1_Mask		0x01F
+
+//----------------------------------------------------------------------------
+//       8192C RRSR bits							(Offset 0x440-442, 24 bits)
+//----------------------------------------------------------------------------
+#define		RRSR_SHORT			BIT(23)	// Respond with short preamble packet. Default is long preamble.
+#define		RRSR_RSC_SHIFT		21	// Response frame sub-channel configuration.
+#define		RRSR_RSC_Mask		0x03
+#define		RRSC_BITMAP_SHIFT	0	// Response Auto Rate Fallback Retry Count.
+#define		RRSC_BITMAP_Mask	0x0FFFFF
+
+//----------------------------------------------------------------------------
+//       8192C AGGLEN_LMT bits					(Offset 0x458-45B, 32 bits)
+//----------------------------------------------------------------------------
+#define		AGGLMT_MCS15S_SHIFT	28	// Aggregation Limit for MCS 15 SGI in the units of number of MPDUs.
+#define		AGGLMT_MCS15S_Mask	0x0F
+#define		AGGLMT_MCS15_SHIFT	24	// Aggregation Limit for MCS 13~15 in the units of number of MPDUs.
+#define		AGGLMT_MCS15_Mask	0x0F
+#define		AGGLMT_MCS12_SHIFT	20	// Aggregation Limit for MCS 11~12 in the units of number of MPDUs.
+#define		AGGLMT_MCS12_Mask	0x0F
+#define		AGGLMT_MCS10_SHIFT	16	// Aggregation Limit for MCS 8~10 in the units of number of MPDUs.
+#define		AGGLMT_MCS10_Mask	0x0F
+#define		AGGLMT_MCS7S_SHIFT	12	// Aggregation Limit for MCS 7 SGI in the units of number of MPDUs.
+#define		AGGLMT_MCS7S_Mask	0x0F
+#define		AGGLMT_MCS7_SHIFT	8	// Aggregation Limit for MCS 6~7 in the units of number of MPDUs.
+#define		AGGLMT_MCS7_Mask		0x0F
+#define		AGGLMT_MCS5_SHIFT	4	// Aggregation Limit for MCS 3~5 in the units of number of MPDUs.
+#define		AGGLMT_MCS5_Mask		0x0F
+#define		AGGLMT_MCS2_SHIFT	0	// Aggregation Limit for MCS 0~2 in the units of number of MPDUs.
+#define		AGGLMT_MCS2_Mask		0x0F
+
+//----------------------------------------------------------------------------
+//       8192C AMPDU_MIN_SPACE bits				(Offset 0x45C, 8 bits)
+//----------------------------------------------------------------------------
+#define		MIN_SPACE_SHIFT	0	// The spacing between sub-frame.
+#define		MIN_SPACE_Mask	0x07
+
+//----------------------------------------------------------------------------
+//       8192C FAST_EDCA_CTRL bits				(Offset 0x460-462, 24 bits)
+//----------------------------------------------------------------------------
+#define		FAST_EDCA_TO_SHIFT		16	// If pkt timeout, HW will contend channel using fast backoff.
+#define		FAST_EDCA_TO_Mask		0x01F
+#define		FAST_EDCA_PKT_TH_SHIFT	0	// If pkt in txpktbuffer over thrs. HW will fast backoff.
+#define		FAST_EDCA_PKT_TH_Mask	0x0FFFF
+
+//----------------------------------------------------------------------------
+//       8192C RD_RESP_PKT_TH bits				(Offset 0x463, 8 bits)
+//----------------------------------------------------------------------------
+#define		RD_RESP_PKT_TH_LMT_SHIFT		0	// granted ACq pkt num beyond this, responder set More PPDU=1 & piggyback.
+#define		RD_RESP_PKT_TH_LMT_Mask		0x01F
+
+//----------------------------------------------------------------------------
+//       8192C INIRTS_RATE_SEL bits				(Offset 0x480, 8 bits)
+//----------------------------------------------------------------------------
+#define		INIRTSMCS_SEL_SHIFT	0	// initial rate for Control type frame transmitted as EDCA originator.
+#define		INIRTSMCS_SEL_Mask	0x03F
+
+//----------------------------------------------------------------------------
+//       8192C POWER_STAGE1 bits				(Offset 0x4B4-4B6, 24 bits)
+//----------------------------------------------------------------------------
+#define		PWR_STAGE1_SHIFT		0	// User define Power Stage1.
+#define		PWR_STAGE1_Mask		0x0FFFFFF
+
+//----------------------------------------------------------------------------
+//       8192C POWER_STAGE2 bits				(Offset 0x4B8-4BA, 24 bits)
+//----------------------------------------------------------------------------
+#define		PWR_STAGE2_SHIFT		0	// User define Power Stage2.
+#define		PWR_STAGE2_Mask		0x0FFFFFF
+
+//----------------------------------------------------------------------------
+//       8192C STBC_SETTING bits				(Offset 0x4C4, 8 bits)
+//----------------------------------------------------------------------------
+#define		NESS_SHIFT			2	//
+#define		NESS_Mask			0x03
+#define		STBC_CFEND_SHIFT	0	// CFEND STBC.
+#define		STBC_CFEND_Mask	0x03
+
+//----------------------------------------------------------------------------
+//       8192C PROT_MODE_CTRL bits				(Offset 0x4C8-4C9, 16 bits)
+//----------------------------------------------------------------------------
+#define		RTS_TXTIME_TH_SHIFT	8	// RTS pkt txtime thrs
+#define		RTS_TXTIME_TH_Mask	0x0FF
+#define		RTS_LEN_TH_SHIFT		0	// RTS Length thrs.
+#define		RTS_LEN_TH_Mask		0x0FF
+
+//----------------------------------------------------------------------------
+//       8192C BAR_MODE_CTRL bits				(Offset 0x4CC-4CE, 24 bits)
+//----------------------------------------------------------------------------
+#define		BAR_RTY_LMT_SHIFT			16	// BAR retry limit.
+#define		BAR_RTY_LMT_Mask			0x03
+#define		BAR_PKT_TXTIME_TH_SHIFT	8	// BAR pkt txtime thrs.
+#define		BAR_PKT_TXTIME_TH_Mask	0x0FF
+#define		BAR_PKTNUM_TH_SHIFT		0	// BAR Pktnum Thrs.
+#define		BAR_PKTNUM_TH_Mask		0x0FF
+
+//----------------------------------------------------------------------------
+//       8192C RA_TRY_RATE_AGG_LMT bits			(Offset 0x4CF, 8 bits)
+//----------------------------------------------------------------------------
+#define		RA_BAR_RTY_LMT_SHIFT				5	// BAR retry limit.
+#define		RA_BAR_RTY_LMT_Mask				0x07
+#define		RA_TRY_RATE_AGG_LMT_NUM_SHIFT	0	// aggr pkt num limit for try up rate of when desc try bit=1.
+#define		RA_TRY_RATE_AGG_LMT_NUM_Mask	0x01F
+
+//----------------------------------------------------------------------------
+//       8192C NQOS_SEQ bits					(Offset 0x4DC-4DD, 16 bits)
+//----------------------------------------------------------------------------
+//----------------------------------------------------------------------------
+//       8192C QOS_SEQ bits						(Offset 0x4DE-4DF, 16 bits)
+//----------------------------------------------------------------------------
+#define		N_QOS_SSN_SHIFT	0	// TXDESC HWSEQEN is set, MAC will overwrite SEQ control by this.
+									// TXDESC HWSEQEN is set and QoS field is also set,
+									// MAC will overwrite SEQ control by this.
+#define		N_QOS_SSN_Mask	0x0FFF
+
+//----------------------------------------------------------------------------
+//       8192C NEED_CPU_HANDLE bits				(Offset 0x4E0, 8 bits)
+//----------------------------------------------------------------------------
+#define		NEED_CPU_HANDLE_Q_SHIFT	0	// 1:HW prepare ok, this q need cpu handle & poll.
+#define		NEED_CPU_HANDLE_Q_Mask	0x03F
+
+//----------------------------------------------------------------------------
+//       8192C PTCL_ERR_STATUS bits				(Offset 0x4E1, 8 bits)
+//----------------------------------------------------------------------------
+#define		PTCL_TL_PG_OVF			BIT(7)	// Protocol Total Page out of range.
+#define		TXHANG_ERR				BIT(5)	// TX time is greater than 32ms.
+#define		HW_RD_NULL_STATUS_ERR	BIT(4)	// HW read null page counter error.
+#define		HW_RD_NULL_CTN_ERR		BIT(3)	// HW Contention read null page counter error.
+#define		HW_RD_NULL_CNT_ERR		BIT(2)	// HW read null page counter error.
+#define		PTCL_TL_PG_ERR				BIT(1)	// Protocol Total page number error.
+#define		DESC_QSEL_ERR				BIT(0)	// TXDESC QSEL field mismatch error.
+
+//----------------------------------------------------------------------------
+//       8192C PKT_LOSE_RPT bits					(Offset 0x4E2, 8 bits)
+//----------------------------------------------------------------------------
+#define		PKT_LOSE_BK		BIT(3)	// 1:queue happen pkt lose, 0:no lose.
+#define		PKT_LOSE_BE		BIT(2)	// 1:queue happen pkt lose, 0:no lose.
+#define		PKT_LOSE_VI		BIT(1)	// 1:queue happen pkt lose, 0:no lose.
+#define		PKT_LOSE_VO		BIT(0)	// 1:queue happen pkt lose, 0:no lose.
+
+
+//----------------------------------------------------------------------------
+//       8192C EDCA_VO_PARA bits				(Offset 0x500-503, 32 bits)
+//----------------------------------------------------------------------------
+//----------------------------------------------------------------------------
+//       8192C EDCA_VI_PARA bits				(Offset 0x504-507, 32 bits)
+//----------------------------------------------------------------------------
+//----------------------------------------------------------------------------
+//       8192C EDCA_BE_PARA bits				(Offset 0x508-50B, 32 bits)
+//----------------------------------------------------------------------------
+//----------------------------------------------------------------------------
+//       8192C EDCA_BK_PARA bits				(Offset 0x50C-50F, 32 bits)
+//----------------------------------------------------------------------------
+#define		TXOP_SHIFT			16	// TXOP Limit.
+#define		TXOP_Mask			0x0FFFF
+#define		CW_SHIFT			8	// ECWmax/ECWmin
+#define		CW_Mask			0x0FF
+#define		AIFS_SHIFT			0	// Arbitrary Inter frame space.
+#define		AIFS_Mask			0x0FF
+
+//----------------------------------------------------------------------------
+//       8192C BCNTCFG bits						(Offset 0x510-511, 16 bits)
+//----------------------------------------------------------------------------
+#define		BCNECW_SHIFT		8	// Beacon Contention Window.
+#define		BCNECW_Mask		0x0F
+#define		BCNIFS_SHIFT		0	// Beacon Interframe Space.
+#define		BCNIFS_Mask		0x0FF
+
+//----------------------------------------------------------------------------
+//       8192C SIFS_CCK bits						(Offset 0x514-515, 16 bits)
+//----------------------------------------------------------------------------
+//----------------------------------------------------------------------------
+//       8192C SIFS_OFDM bits					(Offset 0x516-517, 16 bits)
+//----------------------------------------------------------------------------
+#define		SIFS_TRX_SHIFT		8	// SIFS time required for any immediate response.
+#define		SIFS_TRX_Mask		0x0FF
+#define		SIFS_CTX_SHIFT		0	// SIFS time required for consecutive TX events.
+#define		SIFS_CTX_Mask		0x0FF
+
+//----------------------------------------------------------------------------
+//       8192C TX_PTCL_CTRL bits					(Offset 0x520-521, 16 bits)
+//----------------------------------------------------------------------------
+#define		DIS_CCA				BIT(15)	// bit=1, disable CCA.
+#define		SIFS_BK_EN				BIT(12)	// SIFS Break Check Criteria enable for AMPDU aggregation.
+#define		TXQ_NAV_MSK_SHIFT	8	// 1:Queue BKF must wait TX Nav finished, 0:Queue not need wait.
+#define		TXQ_NAV_MSK_Mask		0x0F
+#define		DIS_CW					BIT(7)	// bit=1, disable CW.
+#define		RDG_END_TXOP			BIT(6)	// 1:Nav protect all txop, 0:Nav protect to next pkt.
+#define		NAV_END_TXOP			BIT(5)	// 1:Nav protect all txop, 0:Nav protect to next pkt.
+#define		AC_INBCN_HOLD			BIT(4)	// bit=1, HI queue will be sent first, and then AC queue will be sent.
+#define		MGTQ_TXOP_EN			BIT(3)	// bit=1, MGTQ may sent packets by using ACQ TXOP.
+#define		MGTQ_RTSMF_HOLD		BIT(2)	// bit=1, MGTQ will be hold until RTS or MF transaction finished.
+#define		HIQ_RTSMF_HOLD		BIT(1)	// bit=1, HIQ will be hold until RTS or MF transaction finished.
+#define		BCN_RTSMF_HOLD		BIT(0)	// bit=1, BCNQ will be hold until RTS or MF transaction finished.
+
+//----------------------------------------------------------------------------
+//       8192C TXPAUSE bits						(Offset 0x522, 8 bits)
+//----------------------------------------------------------------------------
+#define		STOP_BCN			BIT(6)	// Stop BCNQ Queue.
+#define		STOP_HI			BIT(5)	// Stop High Queue.
+#define		STOP_MGT			BIT(4)	// Stop Management Queue.
+#define		STOP_VO			BIT(3)	// Stop VO Queue.
+#define		STOP_VI				BIT(2)	// Stop VI Queue.
+#define		STOP_BE			BIT(1)	// Stop BE Queue.
+#define		STOP_BK			BIT(0)	// Stop BK Queue.
+
+//----------------------------------------------------------------------------
+//       8192C DIS_TXREQ_CLR bits				(Offset 0x523, 8 bits)
+//----------------------------------------------------------------------------
+#define		DIS_TXREQ_CLR_BCN		BIT(7)	// 1:if queue can't own channel ,txcmd will be cleared;0:Only TX_finish can clear txreq.
+#define		DIS_TXREQ_CLR_HI		BIT(5)	// 1:if queue can't own channel ,txcmd will be cleared;0:Only TX_finish can clear txreq.
+#define		DIS_TXREQ_CLR_MGQ		BIT(4)	// 1:if queue can't own channel ,txcmd will be cleared;0:Only TX_finish can clear txreq.
+#define		DIS_TXREQ_CLR_VO		BIT(3)	// 1:if queue can't own channel ,txcmd will be cleared;0:Only TX_finish can clear txreq.
+#define		DIS_TXREQ_CLR_VI		BIT(2)	// 1:if queue can't own channel ,txcmd will be cleared;0:Only TX_finish can clear txreq.
+#define		DIS_TXREQ_CLR_BE		BIT(1)	// 1:if queue can't own channel ,txcmd will be cleared;0:Only TX_finish can clear txreq.
+#define		DIS_TXREQ_CLR_BK		BIT(0)	// 1:if queue can't own channel ,txcmd will be cleared;0:Only TX_finish can clear txreq.
+
+//----------------------------------------------------------------------------
+//       8192C RD_CTRL bits						(Offset 0x524-525, 16 bits)
+//----------------------------------------------------------------------------
+#define		HIQ_NO_LMT_EN			BIT(12)
+#define		EDCCA_MSK_CNTDWN		BIT(11)	// 1: disable, 0: enable,  EDCCA count down.
+#define		DIS_TXOP_CFE			BIT(10)	// Disable TXOP_CFE function.
+#define		DIS_LSIG_CFE			BIT(9)	// Disable LSIG_TXOP CF-END function.
+#define		DIS_STBC_CFE			BIT(8)	// Disable STBC CF-END function.
+#define		BKQ_RD_INIT_EN		BIT(7)	//
+#define		BEQ_RD_INIT_EN		BIT(6)	//
+#define		VIQ_RD_INIT_EN			BIT(5)	//
+#define		VOQ_RD_INIT_EN		BIT(4)	//
+#define		BKQ_RD_RESP_EN		BIT(3)	//
+#define		BEQ_RD_RESP_EN		BIT(2)	//
+#define		VIQ_RD_RESP_EN		BIT(1)	//
+#define		VOQ_RD_RESP_EN		BIT(0)	//
+
+//----------------------------------------------------------------------------
+//       8192C TBTT_PROHIBIT bits				(Offset 0x540-541, 16 bits)
+//----------------------------------------------------------------------------
+#define		TBTT_HOLD_TIME_SHIFT			8	// TBTT_prohibit_hold, unit is 32 us.
+#define		TBTT_HOLD_TIME_Mask			0xFFFFFF
+#define		TBTT_PROHIBIT_SETUP_SHIFT	0	// TBTT_prohibit_setup, unit is 32us.
+#define		TBTT_PROHIBIT_SETUP_Mask		0x0F
+
+//----------------------------------------------------------------------------
+//       8192C BCN_CTRL bits					(Offset 0x550, 8 bits)
+//----------------------------------------------------------------------------
+
+#define 	DIS_SUB_STATE		BIT(4)
+#define 	DIS_SUB_STATE_N		BIT(1)
+#define 	DIS_TSF_UPDATE		BIT(5)
+#define 	DIS_TSF_UPDATE_N	BIT(4)
+#define 	DIS_ATIM			BIT(0)
+
+
+#define		BCN0_AUTO_SYNC	BIT(5)	// When this bit is set, TSFTR will update the timestamp in Beacon matched BSSID.
+#define		DIS_TSF_UPT		BIT(4)	// 92D_REG, When this bit is set, tsf will not update
+#define		EN_BCN_FUNCTION	BIT(3)	// bit=1, TSF and other beacon related functions are then enabled.
+#define		EN_TXBCN_RPT		BIT(2)	//
+#define		EN_MBSSID			BIT(1)	//
+#define		PBCNQSEL			BIT(0)	//
+
+//----------------------------------------------------------------------------
+//       8192C USTIME_TSF bits					(Offset 0x551, 8 bits)
+//----------------------------------------------------------------------------
+#define		USTIME_TSF_TIME_SHIFT	0	// Set the microsecond time unit used by MAC TSF clock.
+#define		USTIME_TSF_TIME_Mask		0x03F
+
+//----------------------------------------------------------------------------
+//       8192C MBID_NUM bits					(Offset 0x552, 8 bits)
+//----------------------------------------------------------------------------
+#define		MBID_BCN_NUM_SHIFT	0	// num of virtual interface num excluding the root.
+#define		MBID_BCN_NUM_Mask	0x07
+
+//----------------------------------------------------------------------------
+//       8192C MBSSID_BCN_SPACE bits			(Offset 0x554-557, 32 bits)
+//----------------------------------------------------------------------------
+#define		BCN_SPACE2_SHIFT	16	//
+#define		BCN_SPACE2_Mask	0x0FFFF
+#define		BCN_SPACE1_SHIFT	0	//
+#define		BCN_SPACE1_Mask	0x0FFFF
+
+//----------------------------------------------------------------------------
+//       8192C ACMHWCTRL bits					(Offset 0x5C0, 8 bits)
+//----------------------------------------------------------------------------
+#define		VOQ_ACM_STATUS	BIT(6)	// indicates if the used_time >= admitted_time of AC VO when HW ACM.
+#define		VIQ_ACM_STATUS	BIT(5)	// indicates if the used_time >= admitted_time of AC VI when HW ACM.
+#define		BEQ_ACM_STATUS	BIT(4)	// indicates if the used_time >= admitted_time of AC BE when HW ACM.
+#define		VOQ_ACM_EN		BIT(3)	// enable ACM of VO queue.
+#define		VIQ_ACM_EN			BIT(2)	// enable ACM of VI queue.
+#define		BEQ_ACM_EN		BIT(1)	// enable ACM of BE queue.
+#define		ACMHWEN			BIT(0)	// enable hardware to take control of ACM.
+
+//----------------------------------------------------------------------------
+//       8192C ACMRSTCTRL bits					(Offset 0x5C1, 8 bits)
+//----------------------------------------------------------------------------
+#define		VO_ACM_RST_USED_TIME		BIT(2)	// HwEn enabled, sw set this to inform hw to reset used_time.
+#define		BE_ACM_RST_USED_TIME		BIT(1)	// HwEn enabled, sw set this to inform hw to reset used_time.
+#define		VI_ACM_RST_USED_TIME		BIT(0)	// HwEn enabled, sw set this to inform hw to reset used_time.
+
+
+//
+// 6. WMAC Configuration. (Offset 0x600 - 0x7FFh)
+//
+//----------------------------------------------------------------------------
+//       8192C APSD_CTRL bits					(Offset 0x600, 8 bits)
+//----------------------------------------------------------------------------
+#define		APSDOFF_STATUS	BIT(7)	//
+#define		APSDOFF			BIT(6)	// bit=1, MAC issue sleep signal to disable BB/AFE/RF TRX function.
+
+//----------------------------------------------------------------------------
+//       8192C BWOPMODE bits					(Offset 0x603, 8 bits)
+//----------------------------------------------------------------------------
+#define		BW_20M				BIT(2)	// bit=1 indicate operating in 20Mhz bandwidth.
+
+//----------------------------------------------------------------------------
+//       8192C TCR bits							(Offset 0x604-607, 32 bits)
+//----------------------------------------------------------------------------
+#define		TSFT_CMP_SHIFT	16		// TSFT insertion compensation value.
+#define		TSFT_CMP_Mask		0x0FF
+#define		WMAC_TCR_ERRSTEN3		BIT(15)	// 92D_REG, Use phytxend_ps to reset mactx state machine
+#define		WMAC_TCR_ERRSTEN2		BIT(14)	// 92D_REG, If txd fifo underflow when txtype is cmpba, reset mactx state machine
+#define		WMAC_TCR_ERRSTEN1		BIT(13)	// 92D_REG, If txd fifo underflow, reset mactx state machine
+#define		WMAC_TCR_ERRSTEN0		BIT(12)	// 92D_REG, Phytxend_ps comes but mactx still active, reset mactx state machine
+#define		WMAC_TCR_TXSK_PERPKT		BIT(11)	// 92D_REG, Serche key for each mpdu
+#define		ICV					BIT(10)	// Integrity Check Value.
+#define		CFE_FORM			BIT(9)	// CF-End Frame Format.
+#define		CRC					BIT(8)	// Append 32-bit Cyclic Redundancy Check.
+#define		PWRBIT_OW_EN		BIT(7)	// bit=1, MAC overwrite pwr bit according to PWR_ST for data frame.
+#define		PWR_ST				BIT(6)	// MAC will overwrite pwr bit accroding to PWR_ST for data frame.
+#define		PAD_SEL			BIT(2)	// AMPDU Padding pattern selection.
+#define		DIS_GCLK			BIT(1)	// Disable MACTX clock gating control.
+#define		TSFRST				BIT(0)	// Reset TSF Timer to zero.
+
+//----------------------------------------------------------------------------
+//       8192C RCR bits							(Offset 0x608-60B, 32 bits)
+//----------------------------------------------------------------------------
+#define		RCR_APP_FCS		BIT(31)	// wmac RX will append FCS after payload.
+#define		RCR_APP_MIC		BIT(30)	// bit=1, MACRX will retain the MIC at the bottom of the packet.
+#define		RCR_APP_ICV		BIT(29)	// bit=1, MACRX will retain the ICV at the bottom of the packet.
+#define		RCR_APP_PHYSTS	BIT(28)	// Append RXFF0 PHY Status Enable.
+#define		RCR_APP_BASSN		BIT(27)	// Append SSN of previous TXBA Enable.
+#define		RCR_MBID_EN		BIT(24)	// Enable Multiple BssId.
+#define		RCR_LSIGEN			BIT(23)	// Enable LSIG TXOP Protection function.
+#define		RCR_MFBEN			BIT(22)	// Enable immediate MCS Feedback function.
+#define		RCR_BM_DATA_EN	BIT(17)	// BM_DATA_EN.
+#define		RCR_UC_DATA_EN	BIT(16)	// Unicast data packet interrupt enable.
+#define		RCR_HTC_LOC_CTRL	BIT(14)	// 1: HTC -> MFC, 0: MFC-> HTC.
+#define		RCR_AMF			BIT(13)	// Accept Management Frame.
+#define		RCR_ACF			BIT(12)	// Accept Control Frame.
+#define		RCR_ADF			BIT(11)	// Accept Data Frame.
+#define		RCR_AICV			BIT(9)	// Accept Integrity Check Value Error packets.
+#define		RCR_ACRC32			BIT(8)	// Accept CRC32 Error packets.
+
+#define		RCR_CBSSID_ADHOC		(BIT(6)|BIT(7))	// Check BSSID.
+#define		RCR_CBSSID			BIT(6)	// Check BSSID.
+#define		RCR_APWRMGT		BIT(5)	// Accept Power Management Packet.
+#define		RCR_ADD3			BIT(4)	// Accept Address 3 Match Packets.
+#define		RCR_AB				BIT(3)	// Accept Broadcast packets.
+#define		RCR_AM				BIT(2)	// Accept Multicast packets.
+#define		RCR_APM			BIT(1)	// Accept Physical Match packets.
+#define		RCR_AAP			BIT(0)	// Accept Destination Address packets.
+
+//----------------------------------------------------------------------------
+//       8192C RX_PKT_LIMIT bits					(Offset 0x60C, 8 bits)
+//----------------------------------------------------------------------------
+#define		RXPKTLMT_SHIFT	0	// RX PKT Upper Limit.
+#define		RXPKTLMT_Mask		0x03F
+
+// 		MACID Setting Register. (Offset 0x610 - 0x62Fh)
+//----------------------------------------------------------------------------
+//       8192C MBIDCAMCFG bits					(Offset 0x628-62F, 64 bits)
+//----------------------------------------------------------------------------
+#define		MBIDCAM_POLL		BIT(31)	// Pooling bit.
+#define		MBIDWRITE_EN		BIT(30)	// Write Enable.
+#define		MBIDCAM_ADDR_SHIFT	24	// CAM Address.
+#define		MBIDCAM_ADDR_Mask	0x01F
+#define		MBIDCAM_VALID		BIT(23)	// CAM Valid bit.
+
+// 		MACID Setting Register. (Offset 0x610 - 0x62Fh)
+
+// 		Timing Control Register. (Offset 0x630 - 0x64Fh)
+//----------------------------------------------------------------------------
+//       8192C SPEC_SIFS bits					(Offset 0x63A-63B, 16 bits)
+//----------------------------------------------------------------------------
+#define		SPEC_SIFS_OFDM_SHIFT	8	// SIFS value for duration calculation.
+#define		SPEC_SIFS_OFDM_Mask	0x0FF
+#define		SPEC_SIFS_CCK_SHIFT	0	// SIFS value for duration calculation.
+#define		SPEC_SIFS_CCK_Mask	0x0FF
+
+//----------------------------------------------------------------------------
+//       8192C RESP_SIFS_CCK bits				(Offset 0x63C-63D, 16 bits)
+//----------------------------------------------------------------------------
+//----------------------------------------------------------------------------
+//       8192C RESP_SIFS_OFDM bits				(Offset 0x63E-63F, 16 bits)
+//----------------------------------------------------------------------------
+#define		SIFS_R2T_SHIFT		8	// SIFS time required for any immediate response.
+#define		SIFS_R2T_Mask		0x0FF
+#define		SIFS_T2T_SHIFT		0	// SIFS time required for consecutive TX events.
+#define		SIFS_T2T_Mask		0x0FF
+
+// 		Timing Control Register. (Offset 0x630 - 0x64Fh)
+
+// 		WMAC, BA, CCX Related Register. (Offset 0x650 - 0x66Fh)
+//----------------------------------------------------------------------------
+//       8192C NAV_CTRL bits					(Offset 0x650-651, 16 bits)
+//----------------------------------------------------------------------------
+#define		NAV_UPPER_SHIFT	8	// When NAV update is beyond this, then update is aborted.
+#define		NAV_UPPER_Mask	0x0FF
+#define		RTSRST_SHIFT		0	// RTS NAV Reset Time.
+#define		RTSRST_Mask		0x0FF
+
+//----------------------------------------------------------------------------
+//       8192C BACAMCMD bits					(Offset 0x654-657, 32 bits)
+//----------------------------------------------------------------------------
+#define		BACAM_POLL			BIT(31)	// Polling bit BA CAM.
+#define		BACAM_RST			BIT(17)	// 1 to reset BA CAM. HW set invalid bit for all entries.
+#define		BACAM_RW			BIT(16)	// 1=Write, 0=Read.
+#define		BACAM_ADDR_SHIFT	0	// BA CAM address. Memory is double-word access.
+#define		BACAM_ADDR_Mask	0x03F
+
+//----------------------------------------------------------------------------
+//       8192C LBDLY bits						(Offset 0x660, 8 bits)
+//----------------------------------------------------------------------------
+#define		LBDLY_LMT_SHIFT	0	// Loopback Delay.
+#define		LBDLY_LMT_Mask	0x01F
+
+//----------------------------------------------------------------------------
+//       8192C FWDLY bits						(Offset 0x661, 8 bits)
+//----------------------------------------------------------------------------
+#define		FWDLY_LMT_SHIFT	0	// Firmware Delay.
+#define		FWDLY_LMT_Mask	0x0F
+
+//----------------------------------------------------------------------------
+//       8192C RXERR_RPT bits					(Offset 0x664-667, 32 bits)
+//----------------------------------------------------------------------------
+#define		RXERR_RPT_SEL_SHIFT	28	//
+#define		RXERR_RPT_SEL_Mask	0x0F
+#define		RXERR_RPT_RST			BIT(27)	// Write "one" to set the counter to zero.
+#define		RPT_COUNTER_SHIFT		0	// reported value corresponding to Report type selected.
+#define		RPT_COUNTER_Mask		0x0FFFFF
+
+//----------------------------------------------------------------------------
+//       8192C WMAC_TRXPTCL_CTL bits			(Offset 0x668-66F, 64 bits)
+//----------------------------------------------------------------------------
+#define		ACKBA_TYPSEL_SHIFT		28	// Determine response type for RX BA.
+#define		ACKBA_TYPSEL_Mask			0x0F
+#define		ACKBA_ACKPCHK_SHIFT		24	//
+#define		ACKBA_ACKPCHK_Mask		0x0F
+#define		ACKBAR_ACKPCHK_SHIFT		12	//
+#define		ACKBAR_ACKPCHK_Mask		0x0F
+#define		DIS_TXBA_AMPDUFCSERR		BIT(4)	// Disable to send BA for responding RX AMPDU with FCS error subframe.
+#define		DIS_TXBA_RXBARINFULL		BIT(3)	// Disable send BA for responding RX control wrapper BAR dropped by rxpkbuffer full.
+#define		DIS_TXCFE_INFULL			BIT(2)	// Disable send CFE for responding RX control wrapper CFE dropped by rxpktbuffer full.
+#define		DIS_TXCTS_INFULL			BIT(1)	// Disable send CTS for responding RX control wrapper RTS dropped by rxpktbuffer full.
+#define		EN_TXCTS_INTXOP			BIT(0)	// Enable send CTS for responding RX RTS during our TXOP period.
+
+#define		RESP_CHNBUSY_SHIFT		20	// Define channel busy condition in responder to determine RX busy.
+#define		RESP_CHNBUSY_Mask		0x03
+#define		RESP_DCTS_EN				BIT(19)	// Enable responder send dual CTS for responding Rx RTS.
+#define		RESP_DCFE_EN				BIT(18)	// Enable responder send dual CF-END for responding RX CF-END.
+#define		RESP_SPLCPEN				BIT(17)	// Enable responder send SPLCP CCK rsp for acknowledging Rx SPLCP CCK.
+#define		RESP_SGIEN					BIT(16)	// Enable responder send SGI HT-OFDM rsp for acknowledging Rx SGI HT-OFDM pkt.
+
+// 		WMAC, BA, CCX Related Register. (Offset 0x650 - 0x66Fh)
+
+// 		Security Control Register. (Offset 0x670 - 0x68Fh)
+//----------------------------------------------------------------------------
+//       8192C CAMCMD bits						(Offset 0x670-673, 32 bits)
+//----------------------------------------------------------------------------
+#define		SECCAM_POLL			BIT(31)	// Security CAM Polling.
+#define		SECCAM_CLR				BIT(30)	// Set 1 to clear all valid bits in CAM.
+#define		MFBCAM_CLR			BIT(29)	// Write 1 to clear all MFB value in CAM.
+#define		SECCAM_WE				BIT(16)	// Security CAM Write Enable.
+#define		SECCAM_ADDR_SHIFT	0	// Security CAM Address Offset.
+#define		SECCAM_ADDR_Mask		0x0FF
+
+//----------------------------------------------------------------------------
+//       8192C CAMDBG bits						(Offset 0x67C-67F, 32 bits)
+//----------------------------------------------------------------------------
+#define		SECCAM_INFO				BIT(31)	// Select TX/RX CAM Information.
+#define		SEC_KEYFOUND				BIT(30)	// Security Key Found in CAM.
+#define		SEC_CONFIG_SHIFT			24	// Security Configuration.
+#define		SEC_CONFIG_Mask			0x03F
+#define		SEC_KEYCONTENT_SHIFT		0	// Security CAM Address Offset.
+#define		SEC_KEYCONTENT_Mask		0x0FFFFFF
+
+//----------------------------------------------------------------------------
+//       8192C SECCFG bits						(Offset 0x680, 8 bits)
+//----------------------------------------------------------------------------
+#define		CHK_KEYID			BIT(8)	// Key search engine need to check if key ID matched
+#define		RXBCUSEDK			BIT(7)	// Force RX Broadcast packets Use Default Key
+#define		TXBCUSEDK			BIT(6)	// Force Tx Broadcast packets Use Default Key
+#define		NOSKMC				BIT(5)	// No Key Search for Multicast.
+#define		SKBYA2				BIT(4)	// Search Key by A2.
+#define		RXDEC				BIT(3)	// Enable Rx Decryption.
+#define		TXENC				BIT(2)	// Enable Tx Encryption.
+#define		RXUSEDK			BIT(1)	// Force Rx Use Default Key.
+#define		TXUSEDK			BIT(0)	// Force Tx Use Default Key.
+
+// 		Security Control Register. (Offset 0x670 - 0x68Fh)
+
+// 		Power Save Control Register. (Offset 0x690 - 0x69Fh)
+//----------------------------------------------------------------------------
+//       8192C WOW_CTRL bits					(Offset 0x690, 8 bits)
+//----------------------------------------------------------------------------
+#define		FORCE_WAKEUP		BIT(7)	// Let Wakeup PIN be controllable by FW/Driver.
+#define		UWF				BIT(3)	// Unicast Wakeup Frame.
+#define		MAGIC				BIT(2)	// Magic Packet.
+#define		WOWEN				BIT(1)	// WoW function on or off.
+#define		PMEN				BIT(0)	// Power Management Enable.
+
+//----------------------------------------------------------------------------
+//       8192C PSSTATUS bits					(Offset 0x691, 8 bits)
+//----------------------------------------------------------------------------
+#define		PSSTATUS_SEL_SHIFT	0	// Indicate the present power save mode.
+#define		PSSTATUS_SEL_Mask		0x0F
+
+//----------------------------------------------------------------------------
+//       8192C PS_RX_INFO bits					(Offset 0x692, 8 bits)
+//----------------------------------------------------------------------------
+#define		RXCTRLIN0			BIT(4)	// set to 1 if NIC received control frame with correct BSSID and DA.
+#define		RXMGTIN0			BIT(3)	// set to 1 if NIC received management frame with correct BSSID and DA.
+#define		RXDATAIN2			BIT(2)	// set to 1 if NIC received data frame with correct BSSID and DA.
+#define		RXDATAIN1			BIT(1)	// set to 1 if NIC received data frame with correct BSSID and DA.
+#define		RXDATAIN0			BIT(0)	// set to 1 if NIC received data frame with correct BSSID and DA.
+
+//----------------------------------------------------------------------------
+//       8192C LPNAV_CTRL bits					(Offset 0x694-697, 32 bits)
+//----------------------------------------------------------------------------
+#define		LPNAV_EN				BIT(31)	// Low Power NAV Mode Enable.
+#define		LPNAV_EARLY_SHIFT		16	// in LPNAV mode, MAC will recall BB & RF into RX idle mode.
+#define		LPNAV_EARLY_Mask		0x07FFF
+#define		LPNAV_TH_SHIFT		0	// When NAV received is greater than this, then MAC enters LPNAV mode.
+#define		LPNAV_TH_Mask			0x0FFFF
+
+//----------------------------------------------------------------------------
+//       8192C WKFMCAM_CMD bits				(Offset 0x698-69B, 32 bits)
+//----------------------------------------------------------------------------
+#define		WKFCAM_POLL			BIT(31)	// Wakeup Mask CAM Polling.
+#define		WKFCAM_CLR			BIT(30)	// Set to one to clear all valid bits in CAM. After reset will self clear to 0.
+#define		WKFCAM_WE				BIT(16)	// Wakeup Mask CAM Write Enable.
+#define		WKFCAM_ADDR_SHIFT	0	// Wakeup Mask CAM Address Offset.
+#define		WKFCAM_ADDR_Mask		0x03F
+
+// 		Power Save Control Register. (Offset 0x690 - 0x69Fh)
+
+// 		General Purpose Register. (Offset 0x6A0 - 0x6AFh)
+//----------------------------------------------------------------------------
+//       8192C RXFLTMAP0 bits					(Offset 0x6A0-6A1, 16 bits)
+//----------------------------------------------------------------------------
+#define		MGTFLTD_EN		BIT(13)	//
+#define		MGTFLTC_EN			BIT(12)	//
+#define		MGTFLTB_EN			BIT(11)	//
+#define		MGTFLTA_EN		BIT(10)	//
+#define		MGTFLT9_EN			BIT(9)	//
+#define		MGTFLT8_EN			BIT(8)	//
+#define		MGTFLT5_EN			BIT(5)	//
+#define		MGTFLT4_EN			BIT(4)	//
+#define		MGTFLT3_EN			BIT(3)	//
+#define		MGTFLT2_EN			BIT(2)	//
+#define		MGTFLT1_EN			BIT(1)	//
+#define		MGTFLT0_EN			BIT(0)	//
+
+//----------------------------------------------------------------------------
+//       8192C RXFLTMAP1 bits					(Offset 0x6A2-6A3, 16 bits)
+//----------------------------------------------------------------------------
+#define		CTRLFLTF_EN		BIT(15)	//
+#define		CTRLFLTE_EN		BIT(14)	//
+#define		CTRLFLTD_EN		BIT(13)	//
+#define		CTRLFLTC_EN		BIT(12)	//
+#define		CTRLFLTB_EN		BIT(11)	//
+#define		CTRLFLTA_EN		BIT(10)	//
+#define		CTRLFLT9_EN		BIT(9)	//
+#define		CTRLFLT8_EN		BIT(8)	//
+#define		CTRLFLT7_EN		BIT(7)	//
+#define		CTRLFLT6_EN		BIT(6)	//
+
+//----------------------------------------------------------------------------
+//       8192C RXFLTMAP2 bits					(Offset 0x6A4-6A5, 16 bits)
+//----------------------------------------------------------------------------
+#define		DATAFLTF_EN		BIT(15)	//
+#define		DATAFLTE_EN		BIT(14)	//
+#define		DATAFLTD_EN		BIT(13)	//
+#define		DATAFLTC_EN		BIT(12)	//
+#define		DATAFLTB_EN		BIT(11)	//
+#define		DATAFLTA_EN		BIT(10)	//
+#define		DATAFLT9_EN		BIT(9)	//
+#define		DATAFLT8_EN		BIT(8)	//
+#define		DATAFLT7_EN		BIT(7)	//
+#define		DATAFLT6_EN		BIT(6)	//
+#define		DATAFLT5_EN		BIT(5)	//
+#define		DATAFLT4_EN		BIT(4)	//
+#define		DATAFLT3_EN		BIT(3)	//
+#define		DATAFLT2_EN		BIT(2)	//
+#define		DATAFLT1_EN		BIT(1)	//
+#define		DATAFLT0_EN		BIT(0)	//
+
+//----------------------------------------------------------------------------
+//       8192C BCN_PSR_RPT bits					(Offset 0x6A8-6AB, 32 bits)
+//----------------------------------------------------------------------------
+#define		DTIM_CNT_SHIFT	24	//
+#define		DTIM_CNT_Mask		0x0FF
+#define		DTIM_PERIOD_SHIFT	16	//
+#define		DTIM_PERIOD_Mask	0x0FF
+#define		DTIM				BIT(15)	//
+#define		TIM					BIT(14)	//
+#define		PS_AID_SHIFT		0	//
+#define		PS_AID_Mask		0x07FF
+
+//----------------------------------------------------------------------------
+//       8192C CALB32K_CTRL bits				(Offset 0x6AC-6AF, 32 bits)
+//----------------------------------------------------------------------------
+#define		CALB32K_POLL		BIT(31)	//
+#define		CALB32K_DONE		BIT(30)	//
+#define		CAL_TIME_SHIFT		20	// Calibration time.
+#define		CAL_TIME_Mask		0x03FF
+#define		CAL_REPORT_SHIFT	0	//
+#define		CAL_REPORT_Mask	0x0FFFFF
+
+// 		General Purpose Register. (Offset 0x6A0 - 0x6AFh)
+
+//----------------------------------------------------------------------------
+//       8192C BT_COEX_TABLE bits				(Offset 0x6C0-6CF, 128 bits)
+//----------------------------------------------------------------------------
+#define		PRI_MASK_RX_RSP			BIT(30)	// Priority Mask for Rx Response Packet.
+#define		PRI_MASK_RX_OFDM			BIT(29)	// Priority Mask for Rx OFDM.
+#define		PRI_MASK_RX_CCK			BIT(28)	// Priority Mask for Rx CCK.
+#define		PRI_MASK_TX_Q_SHIFT		21	// Priority Mask for Tx Queue.
+#define		PRI_MASK_TX_Q_Mask		0x07F
+#define		PRI_MASK_TX_NAV_SHIFT	13	// Priority Mask for Tx NAV.
+#define		PRI_MASK_TX_NAV_Mask		0x0FF
+#define		PRI_MASK_TX_CCK			BIT(12)	// Priority Mask for Tx CCK.
+#define		PRI_MASK_TX_OFDM			BIT(11)	// Priority Mask for Tx OFDM.
+#define		PRI_MASK_TX_RTY			BIT(10)	// Priority Mask for Tx Retry packet.
+#define		PRI_MASK_TX_NUM_SHIFT	6	// Priority Mask for Tx packet num.
+#define		PRI_MASK_TX_NUM_Mask		0x0F
+#define		PRI_MASK_TX_TYPE_SHIFT	2	// Priority Mask for Tx packet type.
+#define		PRI_MASK_TX_TYPE_Mask	0x0F
+#define		C_OOB						BIT(1)	// out of band indication (0:in band,1:out of band).
+#define		ANT_SEL					BIT(0)	// single or dual antenna selection (0:single,1:dual).
+
+#define		BREAK_TABLE2_SHIFT		16	// Table used to break WLAN activity.
+#define		BREAK_TABLE2_Mask			0x0FFFF
+#define		BREAK_TABLE1_SHIFT		0	// Table used to break BT activity.
+#define		BREAK_TABLE1_Mask			0x0FFFF
+
+//----------------------------------------------------------------------------
+//       8192C WMAC_RESP_TXINFO bits			(Offset 0x6D8-6DA, 24 bits)
+//----------------------------------------------------------------------------
+#define		RESP_TXAGC_B_SHIFT	13	//
+#define		RESP_TXAGC_B_Mask		0x01F
+#define		RESP_TXAGC_A_SHIFT	8	//
+#define		RESP_TXAGC_A_Mask	0x01F
+#define		RESP_ANTSEL_B			BIT(7)	//
+#define		RESP_ANTSEL_A			BIT(6)	//
+#define		RESP_TXANT_CCK_SHIFT	4	//
+#define		RESP_TXANT_CCK_Mask	0x03
+#define		RESP_TXANT_L_SHIFT	2	//
+#define		RESP_TXANT_L_Mask		0x03
+#define		RESP_TXANT_HT_SHIFT	0	//
+#define		RESP_TXANT_HT_Mask	0x03
+
+/*
+//----------------------------------------------------------------------------
+//       8192C Rate Definition
+//----------------------------------------------------------------------------
+//CCK
+#define		RATR_1M				0x00000001
+#define		RATR_2M				0x00000002
+#define		RATR_55M				0x00000004
+#define		RATR_11M				0x00000008
+//OFDM
+#define		RATR_6M				0x00000010
+#define		RATR_9M				0x00000020
+#define		RATR_12M				0x00000040
+#define		RATR_18M				0x00000080
+#define		RATR_24M				0x00000100
+#define		RATR_36M				0x00000200
+#define		RATR_48M				0x00000400
+#define		RATR_54M				0x00000800
+//MCS 1 Spatial Stream
+#define		RATR_MCS0				0x00001000
+#define		RATR_MCS1				0x00002000
+#define		RATR_MCS2				0x00004000
+#define		RATR_MCS3				0x00008000
+#define		RATR_MCS4				0x00010000
+#define		RATR_MCS5				0x00020000
+#define		RATR_MCS6				0x00040000
+#define		RATR_MCS7				0x00080000
+//MCS 2 Spatial Stream
+#define		RATR_MCS8				0x00100000
+#define		RATR_MCS9				0x00200000
+#define		RATR_MCS10				0x00400000
+#define		RATR_MCS11				0x00800000
+#define		RATR_MCS12				0x01000000
+#define		RATR_MCS13				0x02000000
+#define		RATR_MCS14				0x04000000
+#define		RATR_MCS15				0x08000000
+// ALL CCK Rate
+#define	RATE_ALL_CCK				RATR_1M|RATR_2M|RATR_55M|RATR_11M
+#define	RATE_ALL_OFDM_AG			RATR_6M|RATR_9M|RATR_12M|RATR_18M|RATR_24M|\
+									RATR_36M|RATR_48M|RATR_54M
+#define	RATE_ALL_OFDM_1SS			RATR_MCS0|RATR_MCS1|RATR_MCS2|RATR_MCS3 |\
+									RATR_MCS4|RATR_MCS5|RATR_MCS6	|RATR_MCS7
+#define	RATE_ALL_OFDM_2SS			RATR_MCS8|RATR_MCS9	|RATR_MCS10|RATR_MCS11|\
+									RATR_MCS12|RATR_MCS13|RATR_MCS14|RATR_MCS15
+*/
+
+#endif // #ifndef __INC_HAL8192SEREG_H
+
diff --git a/drivers/net/wireless/rtl8192cd/8192cd.h b/drivers/net/wireless/rtl8192cd/8192cd.h
index e72e048..754a302 100644
--- a/drivers/net/wireless/rtl8192cd/8192cd.h
+++ b/drivers/net/wireless/rtl8192cd/8192cd.h
@@ -37,6 +37,10 @@
 #include "./8192cd_mib.h"
 #endif
 
+#ifdef P2P_SUPPORT
+#include "./8192cd_p2p.h"
+#endif
+
 #define TRUE		1
 #define FALSE		0
 
@@ -93,10 +97,10 @@ typedef signed long long	INT64;
 #endif
 
 #ifdef CONFIG_RTK_MESH
-#include "./mesh_ext/mesh.h"
-#include "./mesh_ext/hash_table.h"
-#include "./mesh_ext/mesh_route.h"
-#include "./mesh_ext/mesh_security.h"
+#include "../mesh_ext/mesh.h"
+#include "../mesh_ext/hash_table.h"
+#include "../mesh_ext/mesh_route.h"
+#include "../mesh_ext/mesh_security.h"
 #endif
 #define DWNGRADE_PROBATION_TIME		3
 #define UPGRADE_PROBATION_TIME		3
@@ -197,6 +201,9 @@ enum wifi_state {
 	WIFI_MP_CTX_OFDM_HW				= 0x00800000,	// in ofdm continuous tx
 	WIFI_MP_RX							= 0x01000000,
 	WIFI_MP_ARX_FILTER				= 0x02000000,
+#if 1//def CONFIG_RTL8672
+	WIFI_MP_CTX_BACKGROUND_STOPPING	= 0x04000000,	// stopping ctx
+#endif
 #endif
 
 #ifdef WIFI_SIMPLE_CONFIG
@@ -212,6 +219,15 @@ enum wifi_state {
 #ifdef A4_STA
 	WIFI_A4_STA		=	0x04000000,
 #endif
+
+
+#ifdef CONFIG_RTL8672
+    WIFI_WAIT_FOR_CHANNEL_SELECT    = 0x04000000,
+#endif
+
+#ifdef P2P_SUPPORT
+	WIFI_P2P_SUPPORT	=	0x08000000
+#endif
 };
 
 enum frag_chk_state {
@@ -236,8 +252,10 @@ enum led_type {
 	LEDTYPE_SW_LED2_GPIO8_ENABLETXRXDATA,
 	LEDTYPE_SW_LED2_GPIO10_LINKTXRX,				//13
 	LEDTYPE_SW_LED1_GPIO10_LINKTXRX,				//14 for 92D LED Control = 92C LED_TYPE 13
+	LEDTYPE_SW_LED2_GPIO8_LINKTXRXDATA,				//15
+	LEDTYPE_SW_LED2_GPIO8_ASOCTXRXDATA,  			// 16, mark_led	
 	// Latest 92D customized LED types start from 50
-	LEDTYPE_SW_LED1_ENABLETXRXDATA = 50,			// 50 for 92D LED Control = 92C LED_TYPE 7	
+	LEDTYPE_SW_LED1_ENABLETXRXDATA = 50,			// 50 for 92D LED Control = 92C LED_TYPE 7
 	LEDTYPE_SW_MAX,
 };
 
@@ -354,7 +372,7 @@ enum _ANTENNA_ {
 };
 
 enum qos_prio { BK, BE, VI, VO, VI_AG, VO_AG };
-  	 
+
 #ifdef WIFI_HAPD
 enum HAPD_EVENT{
 	HAPD_EXIRED = 0,
@@ -377,7 +395,7 @@ enum WPAS_EVENT{
 	WPAS_EXIRED = 10,
 	WPAS_REGISTERED = 11,
 	WPAS_MIC_FAILURE = 12,
-	WPAS_ASSOC_INFO = 13, 
+	WPAS_ASSOC_INFO = 13,
 	WPAS_SCAN_DONE = 14
 };
 
@@ -392,7 +410,7 @@ typedef struct _WPAS_ASSOCIATION_INFO
         char            RespIE[RESPIELEN];
 } WPAS_ASSOCIATION_INFO;
 #endif
-  	 
+
 static const struct ParaRecord rtl_ap_EDCA[] =
 {
 //ACM,AIFSN, ECWmin, ECWmax, TXOplimit
@@ -482,6 +500,9 @@ __PACK struct wlan_hdr {
 
 struct wlan_hdrnode {
 	struct list_head	list;
+#ifdef TX_EARLY_MODE
+	unsigned char		em_info[8];		// early mode info
+#endif		
 	struct wlan_hdr		hdr;
 };
 
@@ -508,6 +529,9 @@ __PACK struct wlanllc_hdr {
 
 struct wlanllc_node {
 	struct list_head	list;
+#ifdef TX_EARLY_MODE
+	unsigned char		em_info[8];		// early mode info
+#endif	
 	struct wlanllc_hdr	hdr;
 
 #ifdef CONFIG_RTK_MESH
@@ -604,6 +628,10 @@ struct tx_insn	{
 	struct  lls_mesh_header mesh_header;
 #endif
 
+#ifdef SUPPORT_TX_MCAST2UNI
+	unsigned char		isMC2UC;
+#endif
+
 };
 
 struct reorder_ctrl_entry
@@ -683,6 +711,10 @@ struct stat_info {
 	WPA_STA_INFO		*wpa_sta_info;
 #endif
 
+#ifdef TLN_STATS
+	unsigned int		enterpise_wpa_info;
+#endif
+
 #ifdef WIFI_HAPD
 	u_int8_t wpa_ie[256];
 #ifndef HAPD_DRV_PSK_WPS
@@ -720,9 +752,9 @@ struct stat_info {
 	unsigned short		tpcache[8][TUPLE_WINDOW];
 	unsigned short		tpcache_mgt;	// mgt cache number
 
-#ifdef CLIENT_MODE 
-    unsigned short      tpcache_mcast;  // for client mode broadcast or multicast used 
-#endif 
+#ifdef CLIENT_MODE
+    unsigned short      tpcache_mcast;  // for client mode broadcast or multicast used
+#endif
 
 #ifdef _DEBUG_RTL8192CD_
 	unsigned int		rx_amsdu_err;
@@ -813,6 +845,7 @@ struct stat_info {
 	unsigned char		is_realtek_sta;
 	unsigned char		is_apclient;
 	unsigned char		is_rtl8192s_sta;
+	unsigned char		is_rtl8192cd_apclient;
 	unsigned char		is_rtl81xxc_sta;
 	unsigned char		is_broadcom_sta;
 	unsigned char		is_ralink_sta;
@@ -838,6 +871,8 @@ struct stat_info {
 
 	unsigned int		tx_bytes;
 	unsigned int		rx_bytes;
+	unsigned int		tx_bytes_1m;
+	unsigned int		rx_bytes_1m;
 	unsigned int		tx_pkts;
 	unsigned int		rx_pkts;
 	unsigned int		tx_fail;
@@ -915,6 +950,21 @@ struct stat_info {
 		char CurAntenna;
 #endif
 	unsigned int		retry_inc;
+#ifdef P2P_SUPPORT
+		unsigned char is_p2p_client;
+#endif
+
+#ifdef TX_EARLY_MODE
+	int empkt_num;	// how many pending packet in next
+	int emextra_len;	// extra 802.11 length for each 802.3 pkt
+	int empkt_len[5];	// packet length for next pending packet
+#endif
+	unsigned long def_expired_time;
+	unsigned long def_expired_throughput;
+#ifdef CONFIG_RTL_88E_SUPPORT
+	unsigned char txpause_flag;
+	unsigned long txpause_time;
+#endif
 };
 
 
@@ -962,6 +1012,54 @@ struct extra_stats {
 #endif
 };
 
+
+#ifdef TLN_STATS
+struct tln_wifi_stats {
+	unsigned long		connected_sta;
+	unsigned long		max_sta;
+	unsigned long		max_sta_timestamp;
+	unsigned long		rejected_sta;
+};
+
+
+struct tln_ext_wifi_stats {
+	unsigned long		rson_UNSPECIFIED_1;
+	unsigned long		rson_AUTH_INVALID_2;
+	unsigned long		rson_DEAUTH_STA_LEAVING_3;
+	unsigned long		rson_INACTIVITY_4;
+	unsigned long		rson_RESOURCE_INSUFFICIENT_5;
+	unsigned long		rson_UNAUTH_CLS2FRAME_6;
+	unsigned long		rson_UNAUTH_CLS3FRAME_7;
+	unsigned long		rson_DISASSOC_STA_LEAVING_8;
+	unsigned long		rson_ASSOC_BEFORE_AUTH_9;
+	unsigned long		rson_INVALID_IE_13;
+	unsigned long		rson_MIC_FAILURE_14;
+	unsigned long		rson_4WAY_TIMEOUT_15;
+	unsigned long		rson_GROUP_KEY_TIMEOUT_16;
+	unsigned long		rson_DIFF_IE_17;
+	unsigned long		rson_MCAST_CIPHER_INVALID_18;
+	unsigned long		rson_UCAST_CIPHER_INVALID_19;
+	unsigned long		rson_AKMP_INVALID_20;
+	unsigned long		rson_UNSUPPORT_RSNIE_VER_21;
+	unsigned long		rson_RSNIE_CAP_INVALID_22;
+	unsigned long		rson_802_1X_AUTH_FAIL_23;
+	unsigned long		rson_OUT_OF_SCOPE;
+
+	unsigned long		status_FAILURE_1;
+	unsigned long		status_CAP_FAIL_10;
+	unsigned long		status_NO_ASSOC_11;
+	unsigned long		status_OTHER_12;
+	unsigned long		status_NOT_SUPPORT_ALG_13;
+	unsigned long		status_OUT_OF_AUTH_SEQ_14;
+	unsigned long		status_CHALLENGE_FAIL_15;
+	unsigned long		status_AUTH_TIMEOUT_16;
+	unsigned long		status_RESOURCE_INSUFFICIENT_17;
+	unsigned long		status_RATE_FAIL_18;
+	unsigned long		status_OUT_OF_SCOPE;
+};
+#endif
+
+
 #ifdef WIFI_SIMPLE_CONFIG
 #ifndef INCLUDE_WPS
 struct wps_ie_info {
@@ -1006,6 +1104,9 @@ struct ss_res {
 	struct rsn_ie_info	rsn_ie[MAX_BSS_NUM];
 	struct rsn_ie_info	rsn_ie_backup[MAX_BSS_NUM];
 #endif
+#ifdef CONFIG_RTL_NEW_AUTOCH
+	unsigned int		to_scan_40M;
+#endif
 };
 
 #if defined(CONFIG_RTL_NEW_AUTOCH) && defined(SS_CH_LOAD_PROC)
@@ -1016,7 +1117,7 @@ struct ss_report{
 	unsigned char	rssi;
 	unsigned short	fa_count;
 	unsigned short	cca_count;
-	unsigned int	ch_load; 
+	unsigned int	ch_load;
 };
 
 #endif
@@ -1027,6 +1128,11 @@ struct ss_report{
 //	unsigned char		hwaddr[6];
 //};
 
+struct mc2u_flood_mac_entry 
+{
+	unsigned char macAddr[MACADDRLEN] __attribute__ ((packed));
+};
+
 struct rf_finetune_var {
 	unsigned char		ofdm_1ss_oneAnt;// for 2T2R
 	unsigned char		pathB_1T; // for 1T2R, 1T1R
@@ -1046,6 +1152,10 @@ struct rf_finetune_var {
 	unsigned char		rssiTx20MUpper;
 	unsigned char		rssiTx20MLower;
 	unsigned char		rssi_expire_to;
+#ifdef INTERFERENCE_CONTROL
+	unsigned char		nbi_filter_enable;
+#endif
+	unsigned char		rts_init_rate;
 
 	unsigned char		cck_pwr_max;
 	unsigned char		cck_tx_pathB;
@@ -1063,6 +1173,16 @@ struct rf_finetune_var {
 	// TXOP enlarge
 	unsigned char		txop_enlarge_upper;
 	unsigned char		txop_enlarge_lower;
+#ifdef LOW_TP_TXOP
+	unsigned char		low_tp_txop;
+	unsigned int		low_tp_txop_thd_n;
+	unsigned int		low_tp_txop_thd_g;
+	unsigned int		low_tp_txop_thd_low;
+	unsigned char		low_tp_txop_close;
+	unsigned char		low_tp_txop_count;
+	unsigned char		low_tp_txop_delay;
+	unsigned int		cwmax_enhance_thd;
+#endif
 
 	// 2.3G support
 	unsigned char		use_frq_2_3G;
@@ -1078,6 +1198,11 @@ struct rf_finetune_var {
 #ifdef IGMP_FILTER_CMO
 	unsigned char		igmp_deny;
 #endif
+	unsigned char 		mc2u_drop_unknown;
+	unsigned int		mc2u_flood_ctrl;	
+	struct mc2u_flood_mac_entry mc2u_flood_mac[MAX_FLOODING_MAC_NUM] __attribute__ ((packed));
+	unsigned int		mc2u_flood_mac_num __attribute__ ((packed));
+
 #endif
 
 #ifdef	HIGH_POWER_EXT_PA
@@ -1143,9 +1268,9 @@ struct rf_finetune_var {
 	int             	swq_dbg;
 #endif
 
-#ifdef A4_STA	
+#ifdef A4_STA
 	unsigned char		a4_enable;
-#endif	
+#endif
 
 #ifdef SW_ANT_SWITCH
 	unsigned char		antSw_enable;
@@ -1169,6 +1294,9 @@ struct rf_finetune_var {
 #endif
 
 	unsigned char		pwr_by_rate;
+#ifdef DPK_92D
+	unsigned char		dpk_on;
+#endif
 
 #if defined(TXPWR_LMT)
 	unsigned char		disable_txpwrlmt;
@@ -1176,6 +1304,30 @@ struct rf_finetune_var {
 #ifdef CONFIG_RTL_92D_DMDP
 	unsigned char		peerReinit;
 #endif
+#ifdef WIFI_WMM
+	unsigned char		wifi_beq_iot;
+#endif
+	unsigned char		bcast_to_dzq;
+#ifdef TLN_STATS
+	unsigned int		stats_time_interval;
+#endif
+#ifdef TX_EARLY_MODE
+	unsigned char		em_enable;
+#endif
+#ifdef CLIENT_MODE
+	unsigned char		sta_mode_ps;
+#endif
+#ifdef CONFIG_RTL_WLAN_DOS_FILTER
+	unsigned int		dos_block_time;
+#endif
+
+	unsigned int		intel_rtylmt_tp_margin;
+#ifdef CONFIG_RTL_88E_SUPPORT
+	unsigned char		disable_pkt_pause;
+	unsigned char		disable_pkt_nolink;
+	unsigned char		max_pkt_fail;
+	unsigned char		min_pkt_fail;	
+#endif
 };
 
 
@@ -1227,7 +1379,7 @@ enum {
 #endif
 
 #ifdef CHECK_TX_HANGUP
-#define PENDING_PERIOD		60	// max time of pending period
+#define PENDING_PERIOD		40	// max time of pending period
 
 
 struct desc_check_info {
@@ -1279,6 +1431,43 @@ struct ring_que {
 };
 #endif
 
+#ifdef USE_TXQUEUE
+struct txq_node {
+	struct list_head list;
+	struct sk_buff *skb;
+	struct net_device *dev;
+};
+struct txq_list_head {
+	struct list_head list;
+	unsigned int qlen;
+};
+
+#define init_txq_head(_q) \
+	do { \
+		INIT_LIST_HEAD(&((_q)->list)); \
+		(_q)->qlen = 0; \
+	}while(0)
+#define is_txq_empty(_q) ((_q)->qlen ? 0 : 1)
+#define txq_len(_q) ((_q)->qlen)
+#define add_txq_tail(_q, _n) \
+	do { \
+		list_add_tail(&((_n)->list), &((_q)->list)); \
+		(_q)->qlen ++; \
+	}while(0)
+#define add_txq_head(_q, _n) \
+	do { \
+		list_add(&((_n)->list), &((_q)->list)); \
+		(_q)->qlen ++; \
+	}while(0)
+#define unlink_txq(_q, _n) \
+	do { \
+		list_del(&((_n)->list)); \
+		(_q)->qlen --; \
+	}while(0)
+#define deq_txq(_q) \
+	( (_q)->qlen ? (struct txq_node *)((_q)->list.next) : NULL ); \
+	unlink_txq(_q, (struct txq_node *)((_q)->list.next));
+#endif
 
 #ifdef A4_STA
 #define A4_STA_HASH_BITS		3
@@ -1296,7 +1485,7 @@ struct a4_sta_db_entry {
 
 struct a4_tbl_entry {
 	int used;
-	struct a4_sta_db_entry	entry;	
+	struct a4_sta_db_entry	entry;
 };
 #endif
 
@@ -1319,7 +1508,7 @@ struct a4_tbl_entry {
 #define SELANT_MAP_SIZE	8
 
 // 20100514 Joseph: Add definition for antenna switching test after link.
-// This indicates two different the steps. 
+// This indicates two different the steps.
 // In SWAW_STEP_PEAK, driver needs to switch antenna and listen to the signal on the air.
 // In SWAW_STEP_DETERMINE, driver just compares the signal captured in SWAW_STEP_PEAK
 // with original RSSI to determine if it is necessary to switch antenna.
@@ -1352,6 +1541,40 @@ typedef enum tag_SW_Antenna_Switch_Definition
 #endif
 
 
+#if defined(CONFIG_RTL_88E_SUPPORT) && defined(TXREPORT)
+typedef struct StationInfoRAStruct
+{
+	unsigned char RateID;	// old rate id, by every conn per station
+	unsigned int RateMask;	// old rate mask
+	unsigned int RAUseRate;
+	unsigned char RateSGI;	// use SGI by decision
+	unsigned char RssiStaRA;
+	unsigned char PreRssiStaRA;
+	unsigned char SGIEnable;	// set if station support SGI, by every conn per station
+	unsigned char DecisionRate;	// update txrate info for desc setting
+	unsigned char PreRate;
+	unsigned char HighestRate;
+	unsigned char LowestRate;
+	unsigned int NscUp;
+	unsigned int NscDown;
+	unsigned short RTY[5];
+	unsigned int TOTAL;
+	unsigned short DROP;
+	unsigned char Active;
+	unsigned short RptTime;
+#if 1
+	unsigned char RAWaitingCounter;
+	unsigned char RAPendingCounter;
+#endif
+#if 0
+	unsigned char TryingState;
+	unsigned char RateBeforeTrying;
+#endif
+	struct stat_info *pstat;
+} STATION_RA_INFO,*PSTATION_RA_INFO;
+#endif
+
+
 // common private structure which info are shared between root interface and virtual interface
 struct priv_shared_info {
 	unsigned int			type;
@@ -1460,6 +1683,14 @@ struct priv_shared_info {
 	unsigned int			tgpwr_HT2S;
 #endif
 
+#ifdef _TRACKING_TABLE_FILE
+	unsigned char			txpwr_tracking_2G_CCK[4][index_mapping_NUM_MAX];
+	unsigned char			txpwr_tracking_2G_OFDM[4][index_mapping_NUM_MAX];
+	unsigned char			txpwr_tracking_5GL[4][index_mapping_NUM_MAX];
+	unsigned char			txpwr_tracking_5GM[4][index_mapping_NUM_MAX];
+	unsigned char			txpwr_tracking_5GH[4][index_mapping_NUM_MAX];
+#endif
+
 //	unsigned char			phy_reg_2to1[PHY_REG_1T2R];
 	unsigned short			fw_IMEM_len;
 	unsigned short			fw_EMEM_len;
@@ -1491,7 +1722,15 @@ struct priv_shared_info {
 	unsigned char			rssi_min;
 #ifdef WIFI_WMM
 	unsigned char			iot_mode_enable;
+	unsigned int			iot_mode_VI_exist;
 	unsigned int			iot_mode_VO_exist;
+#ifdef WMM_VIBE_PRI
+	unsigned int            iot_mode_BE_exist;
+#endif
+#endif
+
+#ifdef LOW_TP_TXOP
+	unsigned char			BE_cwmax_enhance;
 #endif
 
 	int						is_40m_bw;
@@ -1533,6 +1772,17 @@ struct priv_shared_info {
 	struct wsc_context		WSC_CONT_S;
 #endif
 
+	unsigned int			current_num_tx_desc;
+
+#ifdef CONFIG_RTL_88E_SUPPORT
+#ifdef SUPPORT_RTL8188E_TC
+	unsigned int			rtl8188e_testchip_checked;
+#endif
+#ifdef TXREPORT
+	STATION_RA_INFO  RaInfo[RTL8188E_NUM_STAT];
+#endif
+#endif
+
 	/*********************************************************
 	 * from here on, data will be clear in rtl8192cd_init_sw() *
 	 *********************************************************/
@@ -1577,12 +1827,12 @@ struct priv_shared_info {
 	unsigned char			bDPKdone[2];
 	unsigned char			bDPKstore;
 	short					index_mapping_DPK_current[4][index_mapping_DPK_NUM];
-	int						OFDM_min_index_internalPA_DPK[2];
-	int						TxPowerLevelDPK[2];
+	unsigned char			OFDM_min_index_internalPA_DPK[2];
+	unsigned char			TxPowerLevelDPK[2];
 #endif
 	unsigned int			RegRF18[2];
 	unsigned int			RegRF28[2];
-#endif
+#endif // CONFIG_RTL_92D_SUPPORT
 
 
 	unsigned int			RegE94;
@@ -1597,15 +1847,22 @@ struct priv_shared_info {
 	unsigned int			ADDA_backup[IQK_ADDA_REG_NUM];
 	unsigned int			IQK_MAC_backup[IQK_MAC_REG_NUM];
 
+	//for 8188E IQK
+	unsigned int			IQK_BB_backup[IQK_BB_REG_NUM];
+	unsigned int 			IQK_BB_backup_recover[IQK_BB_REG_NUM];
+	unsigned char			bRfPiEnable;
+	unsigned char			IQK_88E_done;
+	
+
 #if 0 //def SMART_CONCURRENT_92D
 	unsigned int			bcnCount;
 #endif
 
-#ifdef MBSSID
+//#ifdef MBSSID
 	struct rtl8192cd_priv	*bcnDOk_priv;
-#endif
+//#endif
 
-#ifdef TXREPORT
+#if defined(TXREPORT) && (defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT))
 		int sta_query_idx;
 #endif
 
@@ -1656,6 +1913,11 @@ struct priv_shared_info {
 	unsigned char			mp_cck_swing_idx;
 	unsigned char			mp_txpwr_tracking;
 
+#ifdef MP_SWITCH_LNA
+	unsigned char			rx_packet_ss_a;
+	unsigned char			rx_packet_ss_b;
+#endif
+
 #ifdef B2B_TEST
 	volatile unsigned long	mp_rx_ok, mp_rx_sequence, mp_rx_lost_packet, mp_rx_dup;
 	volatile unsigned short	mp_cached_seq;
@@ -1690,11 +1952,11 @@ struct priv_shared_info {
 	unsigned int			rx_rpt_ht;
 	unsigned int			successive_bb_hang;
 #ifdef CLIENT_MODE
-	unsigned int			AP_BW;
+	int					AP_BW;
 #endif
 
 	unsigned long			rxFiFoO_pre;
-	unsigned int			pkt_in_hiQ;
+//	unsigned int			pkt_in_hiQ;
 
 #ifdef RTK_QUE
 	struct ring_que 		skb_queue;
@@ -1715,6 +1977,9 @@ struct priv_shared_info {
 #ifdef WIFI_WMM
 	unsigned int			ht_sta_num;
 	unsigned int			mimo_ps_dynamic_sta;
+#ifdef CONFIG_RTL_88E_SUPPORT
+	unsigned int			mimo_ps_dynamic_sta_88e_hw_ext;
+#endif
 #ifdef STA_EXT
 	unsigned int			mimo_ps_dynamic_sta_ext;
 #endif
@@ -1745,6 +2010,9 @@ struct priv_shared_info {
 	unsigned short			ofdm_FA_cnt3;
 	unsigned short			ofdm_FA_cnt4;
 	unsigned short			cck_FA_cnt;
+#ifdef INTERFERENCE_CONTROL
+	unsigned int			ofdm_FA_total_cnt;
+#endif
 	unsigned int			FA_total_cnt;
 	unsigned int			CCA_total_cnt;
 
@@ -1761,7 +2029,7 @@ struct priv_shared_info {
 	unsigned int			Reg664_cnt;
 	unsigned int			Reg664_cntOK;
 #endif
-	
+
 	int 					digDownCount;
 	int 					digDeadPoint;
 	int 					digDeadPointCandidate;
@@ -1783,6 +2051,11 @@ struct priv_shared_info {
 	unsigned int			num_txdesc_cnt;		// less or equal max available tx desc
 	unsigned int			num_txdesc_upper_limit;
 	unsigned int			num_txdesc_lower_limit;
+#ifdef USE_TXQUEUE
+	unsigned int			num_txq_cnt;
+	unsigned int			num_txq_upper_limit;
+	unsigned int			num_txq_lower_limit;
+#endif
 #endif
 
 	// Retry Limit register content
@@ -1811,7 +2084,7 @@ struct priv_shared_info {
 #ifdef DETECT_STA_EXISTANCE
 	struct timer_list			rl_recover_timer;
 	unsigned char				bRLShortened;
-#endif	
+#endif
 
 #ifdef DFS
 	unsigned int			dfsSwitchChannel;
@@ -1820,17 +2093,53 @@ struct priv_shared_info {
 #endif
 
 #ifdef RX_BUFFER_GATHER
-	unsigned int 			gather_state;	
-	struct list_head		gather_list;	
+	unsigned int 			gather_state;
+	struct list_head		gather_list;
 	int					gather_len;
 #endif
 
+#ifdef USE_TXQUEUE
+	struct txq_list_head	txq_list[7];
+	unsigned int			txq_isr;
+	unsigned int			txq_stop;
+	unsigned int			txq_check;
+	struct list_head		txq_pool;
+	unsigned char			*txq_pool_addr;
+#endif
+
 	unsigned char  	Reg_RRSR_2;
 	unsigned char  	Reg_81b;
 	unsigned int 	marvellMapBit;
+#ifdef CONFIG_RTL_88E_SUPPORT
+	unsigned int 	marvellMapBit_88e_hw_ext;
+#endif
 #ifdef STA_EXT
 	unsigned int 	marvellMapBitExt;
 #endif
+
+#ifdef TX_EARLY_MODE
+	unsigned int	em_waitq_on;
+	unsigned int	em_tx_byte_cnt;
+	unsigned int	reach_tx_limit_cnt;
+#endif
+
+	unsigned int	iqk_2g_done;	
+#ifdef CONFIG_RTL_92D_SUPPORT	
+	unsigned int	iqk_5g_done;
+#endif	
+
+	unsigned int	intel_active_sta;
+	unsigned int	intel_rty_lmt;
+
+#if defined(CONFIG_RTL_88E_SUPPORT) && defined(TXREPORT)
+	unsigned int total_assoc_num;
+	unsigned int txRptMacid;
+#endif
+
+#ifdef SMART_REPEATER_MODE
+	struct timer_list	check_vxd_ap;
+	unsigned int		switch_chan_rp;		
+#endif	
 };
 
 #ifdef CONFIG_RTL8186_KB
@@ -1844,7 +2153,7 @@ typedef struct guestmac {
 struct rtl8192cd_priv {
 
 #ifdef NETDEV_NO_PRIV
-	struct rtl8192cd_priv*	wlan_priv;		//This element shall be put at top of this struct	
+	struct rtl8192cd_priv*	wlan_priv;		//This element shall be put at top of this struct
 #endif
 
 	int						drv_state;		// bit0 - init, bit1 - open/close
@@ -1892,6 +2201,9 @@ struct rtl8192cd_priv {
 	struct rtl8192cd_priv		*proot_priv;	// ptr of private structure of root interface
 #ifdef RESERVE_TXDESC_FOR_EACH_IF
 	unsigned int			use_txdesc_cnt[7];
+#ifdef USE_TXQUEUE
+	unsigned int			use_txq_cnt[7];
+#endif
 #endif
 #endif
 #ifdef UNIVERSAL_REPEATER
@@ -1930,6 +2242,9 @@ struct rtl8192cd_priv {
 	 */
 	unsigned int			NOP_chnl[15];
 	unsigned int			NOP_chnl_num;
+
+	unsigned int			Not_DFS_chnl[32];
+	unsigned int			Not_DFS_chnl_num;
 #endif
 
 #if defined(INCLUDE_WPA_PSK) || defined(WIFI_HAPD)
@@ -2026,6 +2341,11 @@ struct rtl8192cd_priv {
 	unsigned int			ch_ss_rpt_cnt;
 	struct ss_report		ch_ss_rpt[MAX_BSS_NUM];
 #endif
+#ifdef P2P_SUPPORT
+	struct timer_list		p2p_listen_timer_t;
+	struct timer_list		p2p_search_timer_t;
+	struct p2p_context*		p2pPtr;
+#endif
 
 	/*********************************************************
 	 * from here on, data will be clear in rtl8192cd_init_sw() *
@@ -2033,6 +2353,11 @@ struct rtl8192cd_priv {
 
 	struct net_device_stats	net_stats;
 	struct extra_stats		ext_stats;
+#ifdef TLN_STATS
+	struct tln_wifi_stats		wifi_stats;
+	struct tln_ext_wifi_stats	ext_wifi_stats;
+	unsigned int			stats_time_countdown;
+#endif
 
 	struct timer_list		frag_to_filter;
 	unsigned int			frag_to;
@@ -2077,10 +2402,10 @@ struct timer_list			ps_timer;
 	struct bss_desc			dot11Bss_original;
 	int						hidden_ap_mib_backup;
 	unsigned	char		*pbeacon_ssid;
-	/*WPS client improve ; WPS2DOTX */
+
 	unsigned	char 		orig_SSID[33];
 	int 					orig_SSID_LEN;
-	/*WPS client improve ; WPS2DOTX */	
+
 #else
 	unsigned int			beaconbuf[128];
 #endif
@@ -2089,7 +2414,8 @@ struct timer_list			ps_timer;
 	unsigned int			ht_cap_len;
 	struct ht_info_elmt		ht_ie_buf;
 	unsigned int			ht_ie_len;
-	unsigned int			ht_legacy_obss_to;
+	unsigned int			ht_legacy_obss_to;	
+	unsigned int			ht_nomember_legacy_sta_to;
 	unsigned int			ht_legacy_sta_num;
 	unsigned int			ht_protection;
 	unsigned int			dc_th_current_state;
@@ -2108,6 +2434,7 @@ struct timer_list			ps_timer;
 	unsigned short			timoffset;
 	unsigned char			dtimcount;
 	unsigned char			pkt_in_dtimQ;
+	unsigned char			pkt_in_hiQ;
 
 	//struct stat_info_cache	stainfo_cache;
 	struct stat_info		*pstat_cache;
@@ -2125,12 +2452,18 @@ struct timer_list			ps_timer;
 	unsigned int			available_chnl[76];		// all available channel we can use
 	unsigned int			available_chnl_num;		// record the number
 
-#ifdef CONFIG_RTL_NEW_AUTOCH	
+#ifdef CONFIG_RTL_NEW_AUTOCH
 	unsigned int			chnl_ss_fa_count[76];	// record FA count while ss
 	unsigned int			chnl_ss_cca_count[76];	// record CCA count while ss
 #ifdef SS_CH_LOAD_PROC
 	unsigned char			chnl_ss_load[76];	// record noise level while ss
-#endif	
+#endif
+	unsigned int			chnl_ss_mac_rx_count[76];
+	unsigned int			chnl_ss_mac_rx_count_40M[76];
+#endif
+#ifdef P2P_SUPPORT
+	unsigned int	back_available_chnl[76];		// all available channel we can use
+	unsigned int	back_available_chnl_num;		// record the number
 #endif
 
 
@@ -2201,6 +2534,10 @@ struct timer_list			ps_timer;
 #endif
 	unsigned int					force_20_sta;
 	unsigned int					switch_20_sta;
+#ifdef CONFIG_RTL_88E_SUPPORT
+	unsigned int					force_20_sta_88e_hw_ext;
+	unsigned int					switch_20_sta_88e_hw_ext;
+#endif
 #ifdef STA_EXT
 	unsigned int					force_20_sta_ext;
 	unsigned int					switch_20_sta_ext;
@@ -2214,6 +2551,10 @@ struct timer_list			ps_timer;
 	unsigned int			join_res;
 	unsigned int			beacon_period;
 	unsigned short			aid;
+	unsigned int			ps_state;
+#if defined(WIFI_WMM) && defined (WMM_APSD)
+	unsigned int			uapsd_assoc;
+#endif
 #ifdef RTK_BR_EXT
 	unsigned int			macclone_completed;
 	struct nat25_network_db_entry	*nethash[NAT25_HASH_SIZE];
@@ -2224,6 +2565,8 @@ struct timer_list			ps_timer;
 	struct nat25_network_db_entry	*scdb_entry;
 	unsigned char			br_mac[MACADDRLEN];
 	unsigned char			br_ip[4];
+	unsigned char			ukpro_mac[MACADDRLEN];	// mac address of unknown protocol
+	unsigned char			ukpro_mac_valid;		// if the above entry is valid
 #endif
 	unsigned char 			up_flag;
 #endif
@@ -2240,6 +2583,7 @@ struct timer_list			ps_timer;
 #ifdef DFS
 	struct timer_list		DFS_timer;			/* timer for radar detection */
 	struct timer_list		ch_avail_chk_timer;	/* timer for channel availability check */
+	struct timer_list		dfs_chk_timer;	/* timer for dfs trigger */
 #endif
 
 #ifdef GBWC
@@ -2389,12 +2733,12 @@ struct timer_list			ps_timer;
 	struct list_head			a4_sta_list;
 	struct a4_sta_db_entry		*machash[A4_STA_HASH_SIZE];
 	struct a4_tbl_entry 		a4_ent[MAX_A4_TBL_NUM];
-#endif	
+#endif
 
 #ifdef WIFI_WPAS
 	unsigned char 	wpas_manual_assoc; //_Eric ??
 #endif
-	int		update_bcn_period;
+	int update_bcn_period;
 };
 
 struct rtl8192cd_chr_priv {
@@ -2406,10 +2750,35 @@ struct rtl8192cd_chr_priv {
 
 #ifdef NETDEV_NO_PRIV
 struct rtl8192cd_wds_priv {
-	struct rtl8192cd_priv*	wlan_priv;      //This element shall be put at top of this struct	
+	struct rtl8192cd_priv*	wlan_priv;      //This element shall be put at top of this struct
 };
 #endif
 
+/* station info, reported to web server */
+typedef struct _sta_info_2_web {
+	unsigned short	aid;
+	unsigned char	addr[6];
+	unsigned long	tx_packets;
+	unsigned long	rx_packets;
+	unsigned long	expired_time;	// 10 msec unit
+	unsigned short	flags;
+	unsigned char	TxOperaRate;
+	unsigned char	rssi;
+	unsigned long	link_time;		// 1 sec unit
+	unsigned long	tx_fail;
+	unsigned long	tx_bytes;
+	unsigned long	rx_bytes;
+	unsigned char	network;
+	unsigned char	ht_info;		// bit0: 0=20M mode, 1=40M mode; bit1: 0=longGI, 1=shortGI
+#ifdef TLN_STATS
+	unsigned char		RxOperaRate;
+	unsigned char		auth_type;
+	unsigned char		enc_type;
+	unsigned char 	resv[3];
+#else
+	unsigned char 	resv[6];
+#endif
+} sta_info_2_web;
 
 #define NULL_MAC_ADDR		("\x0\x0\x0\x0\x0\x0")
 
@@ -2451,6 +2820,14 @@ struct rtl8192cd_wds_priv {
 
 #define IEEE8021X_FUN	((GET_MIB(priv))->dot118021xAuthEntry.dot118021xAlgrthm)
 
+#define ACCT_FUN		((GET_MIB(priv))->dot118021xAuthEntry.acct_enabled)
+
+#define ACCT_FUN_TIME	((GET_MIB(priv))->dot118021xAuthEntry.acct_timeout_period)
+
+#define ACCT_FUN_TP		((GET_MIB(priv))->dot118021xAuthEntry.acct_timeout_throughput)
+
+#define ACCT_TP_INT		60
+
 #define SHORTPREAMBLE	((GET_MIB(priv))->dot11RFEntry.shortpreamble)
 
 #define SSID2SCAN		((GET_MIB(priv))->dot11StationConfigEntry.dot11SSIDtoScan)
@@ -2483,6 +2860,15 @@ struct rtl8192cd_wds_priv {
 #define COUNTRY_CODE_ENABLED 	((GET_MIB(priv))->dot11dCountry.dot11CountryCodeSwitch)
 #endif
 
+#ifdef P2P_SUPPORT
+#define P2PMODE			((GET_MIB(priv))->p2p_mib.p2p_type)
+#define P2P_STATE		((GET_MIB(priv))->p2p_mib.p2p_state)
+#define P2P_DISCOVERY		((GET_MIB(priv))->p2p_mib.p2p_on_discovery)
+#define P2P_EVENT_INDICATE		((GET_MIB(priv))->p2p_mib.p2p_event_indiate)
+
+#endif
+
+
 #define AMPDU_ENABLE	((GET_MIB(priv))->dot11nConfigEntry.dot11nAMPDU)
 #define AMSDU_ENABLE	((GET_MIB(priv))->dot11nConfigEntry.dot11nAMSDU)
 
@@ -2548,6 +2934,16 @@ struct rtl8192cd_wds_priv {
 #define NONE_OCCUPANCY_PERIOD	RTL_10MILISECONDS_TO_JIFFIES(priv->pmib->dot11DFSEntry.NOP_timeout)
 #endif
 
+#ifdef TX_EARLY_MODE
+#define GET_TX_EARLY_MODE			(priv->pshare->rf_ft_var.em_enable)
+#define GET_EM_SWQ_ENABLE			(priv->pshare->em_waitq_on)
+#define MAX_EM_QUE_NUM			30
+#define EM_TP_UP_BOUND				6000000 /* 48M */
+#define EM_TP_LOW_BOUND			2000000 /* 16M */
+#define WAIT_TP_TIME				3	/* wait TP limit for this period in sec */
+#endif
+
+
 #ifdef _DEBUG_RTL8192CD_
 #define ASSERT(expr) \
         if(!(expr)) {					\
@@ -2631,19 +3027,26 @@ struct rtl8192cd_wds_priv {
 
 
 #ifdef CONFIG_RTK_VLAN_SUPPORT
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+extern int  rx_vlan_process(struct net_device *dev, struct VlanConfig *info_ori, struct sk_buff *skb, struct sk_buff **new_skb);
+extern int  tx_vlan_process(struct net_device *dev, struct VlanConfig *info_ori, struct sk_buff *skb, int wlan_pri);
+#else
 extern int  rx_vlan_process(struct net_device *dev, struct VlanConfig *info, struct sk_buff *skb);
 extern int  tx_vlan_process(struct net_device *dev, struct VlanConfig *info, struct sk_buff *skb, int wlan_pri);
 #endif
+#endif
 
 
 #ifdef  SUPPORT_TX_MCAST2UNI
 #define IP_MCAST_MAC(mac)		((mac[0]==0x01)&&(mac[1]==0x00)&&(mac[2]==0x5e))
 
-/*match is  (1)ipv4 && (2)(IGMP control/management packet) */ 
+/*match is  (1)ipv4 && (2)(IGMP control/management packet) */
 #define IS_IGMP_PROTO(mac)	((mac[12]==0x08) && (mac[13]==0x00) && (mac[23]==0x02))
 
 #define IS_ICMPV6_PROTO(mac)		( (mac[12]==0x86)&&(mac[13]==0xdd) && mac[54]==0x3a)
 
+#define IS_MDNSV4_MAC(mac) ((mac[0]==0x01)&&(mac[1]==0x00)&&(mac[2]==0x5e)&& (mac[3]==0x00)&&(mac[4]==0x00)&&(mac[5]==0xFB)&&(mac[12]==0x08)&&(mac[13]==0x00))
+#define IS_MDNSV6_MAC(mac) ((mac[0]==0x33)&&(mac[1]==0x33)&&(mac[2]==0x00)&& (mac[3]==0x00)&&(mac[4]==0x00)&&(mac[5]==0xFB)&&(mac[12]==0x86)&&(mac[13]==0xdd))
 
 #ifdef	TX_SUPPORT_IPV6_MCAST2UNI
 #define ICMPV6_MCAST_MAC(mac)	((mac[0]==0x33)&&(mac[1]==0x33)&&(mac[2]!=0xff))
@@ -2690,9 +3093,9 @@ typedef struct countryIE {
 } COUNTRY_IE_ELEMENT;
 #endif
 
-#ifdef TXREPORT
+#if defined(TXREPORT) && (defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT))
 struct tx_rpt{
-	unsigned short		txfail;   
+	unsigned short		txfail;
 	unsigned short      txok;
 	unsigned short      macid;
 };
@@ -2706,5 +3109,14 @@ struct _device_info_ {
 	struct rtl8192cd_priv *priv;
 };
 
+// andrew, define a compatible data macro
+#if defined(LINUX_2_6_22_)
+#define SKB_MAC_HEADER(s) skb_mac_header(s)
+#define SKB_IP_HEADER(s) (struct iphdr *)(skb_mac_header(s) + ETH_HLEN);
+#else // older 2.6 header
+#define SKB_MAC_HEADER(s) (s)->mac.raw
+#define SKB_IP_HEADER(s) (struct iphdr *)((s)->mac.raw + ETH_HLEN);
+#endif
+
 #endif // _8192CD_H_
 
diff --git a/drivers/net/wireless/rtl8192cd/8192cd_br_ext.c b/drivers/net/wireless/rtl8192cd/8192cd_br_ext.c
index 5d57a5c..0ca2cec 100644
--- a/drivers/net/wireless/rtl8192cd/8192cd_br_ext.c
+++ b/drivers/net/wireless/rtl8192cd/8192cd_br_ext.c
@@ -60,14 +60,14 @@
 
 /*-----------------------------------------------------------------
   How database records network address:
-           0    1    2    3    4    5    6    7    8    9   10
-        |----|----|----|----|----|----|----|----|----|----|----|
+  0    1    2    3    4    5    6    7    8    9   10
+  |----|----|----|----|----|----|----|----|----|----|----|
   IPv4  |type|                             |      IP addr      |
   IPX   |type|      Net addr     |          Node addr          |
   IPX   |type|      Net addr     |Sckt addr|
   Apple |type| Network |node|
   PPPoE |type|   SID   |           AC MAC            |
------------------------------------------------------------------*/
+  -----------------------------------------------------------------*/
 
 
 //Find a tag in pppoe frame and return the pointer
@@ -140,7 +140,7 @@ static __inline__ unsigned long __nat25_timeout(struct rtl8192cd_priv *priv)
 
 
 static __inline__ int  __nat25_has_expired(struct rtl8192cd_priv *priv,
-				struct nat25_network_db_entry *fdb)
+		struct nat25_network_db_entry *fdb)
 {
 	if(time_before_eq(fdb->ageing_timer, __nat25_timeout(priv)))
 		return 1;
@@ -150,7 +150,7 @@ static __inline__ int  __nat25_has_expired(struct rtl8192cd_priv *priv,
 
 
 static __inline__ void __nat25_generate_ipv4_network_addr(unsigned char *networkAddr,
-				unsigned int *ipAddr)
+		unsigned int *ipAddr)
 {
 	memset(networkAddr, 0, MAX_NETWORK_ADDR_LEN);
 
@@ -160,7 +160,7 @@ static __inline__ void __nat25_generate_ipv4_network_addr(unsigned char *network
 
 
 static __inline__ void __nat25_generate_ipx_network_addr_with_node(unsigned char *networkAddr,
-				unsigned int *ipxNetAddr, unsigned char *ipxNodeAddr)
+		unsigned int *ipxNetAddr, unsigned char *ipxNodeAddr)
 {
 	memset(networkAddr, 0, MAX_NETWORK_ADDR_LEN);
 
@@ -171,7 +171,7 @@ static __inline__ void __nat25_generate_ipx_network_addr_with_node(unsigned char
 
 
 static __inline__ void __nat25_generate_ipx_network_addr_with_socket(unsigned char *networkAddr,
-				unsigned int *ipxNetAddr, unsigned short *ipxSocketAddr)
+		unsigned int *ipxNetAddr, unsigned short *ipxSocketAddr)
 {
 	memset(networkAddr, 0, MAX_NETWORK_ADDR_LEN);
 
@@ -182,7 +182,7 @@ static __inline__ void __nat25_generate_ipx_network_addr_with_socket(unsigned ch
 
 
 static __inline__ void __nat25_generate_apple_network_addr(unsigned char *networkAddr,
-				unsigned short *network, unsigned char *node)
+		unsigned short *network, unsigned char *node)
 {
 	memset(networkAddr, 0, MAX_NETWORK_ADDR_LEN);
 
@@ -193,7 +193,7 @@ static __inline__ void __nat25_generate_apple_network_addr(unsigned char *networ
 
 
 static __inline__ void __nat25_generate_pppoe_network_addr(unsigned char *networkAddr,
-				unsigned char *ac_mac, unsigned short *sid)
+		unsigned char *ac_mac, unsigned short *sid)
 {
 	memset(networkAddr, 0, MAX_NETWORK_ADDR_LEN);
 
@@ -205,7 +205,7 @@ static __inline__ void __nat25_generate_pppoe_network_addr(unsigned char *networ
 
 #ifdef CL_IPV6_PASS
 static  void __nat25_generate_ipv6_network_addr(unsigned char *networkAddr,
-				unsigned int *ipAddr)
+		unsigned int *ipAddr)
 {
 	memset(networkAddr, 0, MAX_NETWORK_ADDR_LEN);
 
@@ -219,7 +219,7 @@ static unsigned char *scan_tlv(unsigned char *data, int len, unsigned char tag,
 	while (len > 0) {
 		if (*data == tag && *(data+1) == len8b && len >= len8b*8)
 			return data+2;	
-		
+
 		len -= (*(data+1))*8;		
 		data += (*(data+1))*8;		
 	}
@@ -231,14 +231,14 @@ static int update_nd_link_layer_addr(unsigned char *data, int len, unsigned char
 {
 	struct icmp6hdr *icmphdr = (struct icmp6hdr *)data;
 	unsigned char *mac;
-	
+
 	if (icmphdr->icmp6_type == NDISC_ROUTER_SOLICITATION) { 
 		if (len >= 8) {
 			mac = scan_tlv(&data[8], len-8, 1, 1);
 			if (mac) {
 				_DEBUG_INFO("Router Solicitation, replace MAC From: %02x:%02x:%02x:%02x:%02x:%02x, To: %02x:%02x:%02x:%02x:%02x:%02x\n",
-					mac[0],mac[1],mac[2],mac[3],mac[4],mac[5],					
-					replace_mac[0],replace_mac[1],replace_mac[2],replace_mac[3],replace_mac[4],replace_mac[5]);
+						mac[0],mac[1],mac[2],mac[3],mac[4],mac[5],					
+						replace_mac[0],replace_mac[1],replace_mac[2],replace_mac[3],replace_mac[4],replace_mac[5]);
 				memcpy(mac, replace_mac, 6);	
 				return 1;				
 			}
@@ -249,8 +249,8 @@ static int update_nd_link_layer_addr(unsigned char *data, int len, unsigned char
 			mac = scan_tlv(&data[16], len-16, 1, 1);
 			if (mac) {
 				_DEBUG_INFO("Router Advertisement, replace MAC From: %02x:%02x:%02x:%02x:%02x:%02x, To: %02x:%02x:%02x:%02x:%02x:%02x\n",
-					mac[0],mac[1],mac[2],mac[3],mac[4],mac[5],					
-					replace_mac[0],replace_mac[1],replace_mac[2],replace_mac[3],replace_mac[4],replace_mac[5]);
+						mac[0],mac[1],mac[2],mac[3],mac[4],mac[5],					
+						replace_mac[0],replace_mac[1],replace_mac[2],replace_mac[3],replace_mac[4],replace_mac[5]);
 				memcpy(mac, replace_mac, 6);			
 				return 1;				
 			}
@@ -261,8 +261,8 @@ static int update_nd_link_layer_addr(unsigned char *data, int len, unsigned char
 			mac = scan_tlv(&data[24], len-24, 1, 1);
 			if (mac) {		
 				_DEBUG_INFO("Neighbor Solicitation, replace MAC From: %02x:%02x:%02x:%02x:%02x:%02x, To: %02x:%02x:%02x:%02x:%02x:%02x\n",
-					mac[0],mac[1],mac[2],mac[3],mac[4],mac[5],					
-					replace_mac[0],replace_mac[1],replace_mac[2],replace_mac[3],replace_mac[4],replace_mac[5]);
+						mac[0],mac[1],mac[2],mac[3],mac[4],mac[5],					
+						replace_mac[0],replace_mac[1],replace_mac[2],replace_mac[3],replace_mac[4],replace_mac[5]);
 				memcpy(mac, replace_mac, 6);	
 				return 1;								
 			}
@@ -273,8 +273,8 @@ static int update_nd_link_layer_addr(unsigned char *data, int len, unsigned char
 			mac = scan_tlv(&data[24], len-24, 2, 1);
 			if (mac) {
 				_DEBUG_INFO("Neighbor Advertisement, replace MAC From: %02x:%02x:%02x:%02x:%02x:%02x, To: %02x:%02x:%02x:%02x:%02x:%02x\n",
-					mac[0],mac[1],mac[2],mac[3],mac[4],mac[5],					
-					replace_mac[0],replace_mac[1],replace_mac[2],replace_mac[3],replace_mac[4],replace_mac[5]);
+						mac[0],mac[1],mac[2],mac[3],mac[4],mac[5],					
+						replace_mac[0],replace_mac[1],replace_mac[2],replace_mac[3],replace_mac[4],replace_mac[5]);
 				memcpy(mac, replace_mac, 6);		
 				return 1;				
 			}
@@ -285,8 +285,8 @@ static int update_nd_link_layer_addr(unsigned char *data, int len, unsigned char
 			mac = scan_tlv(&data[40], len-40, 2, 1);
 			if (mac) {				
 				_DEBUG_INFO("Redirect,  replace MAC From: %02x:%02x:%02x:%02x:%02x:%02x, To: %02x:%02x:%02x:%02x:%02x:%02x\n",
-					mac[0],mac[1],mac[2],mac[3],mac[4],mac[5],					
-					replace_mac[0],replace_mac[1],replace_mac[2],replace_mac[3],replace_mac[4],replace_mac[5]);
+						mac[0],mac[1],mac[2],mac[3],mac[4],mac[5],					
+						replace_mac[0],replace_mac[1],replace_mac[2],replace_mac[3],replace_mac[4],replace_mac[5]);
 				memcpy(mac, replace_mac, 6);	
 				return 1;				
 			}
@@ -307,10 +307,10 @@ static void convert_ipv6_mac_to_mc(struct sk_buff *skb)
 	dst_mac[0] = 0x33;
 	dst_mac[1] = 0x33;
 	memcpy(&dst_mac[2], &iph->daddr.s6_addr32[3], 4);
-	#if defined(__LINUX_2_6__) 
+#if defined(__LINUX_2_6__) 
 	/*modified by qinjunjie,warning:should not remove next line*/
 	skb->pkt_type = PACKET_MULTICAST;
-	#endif
+#endif
 }
 #endif /* CL_IPV6_PASS */
 
@@ -359,7 +359,7 @@ static __inline__ int __nat25_network_hash(unsigned char *networkAddr)
 			networkAddr[6] ^ networkAddr[7] ^ networkAddr[8] ^ networkAddr[9] ^ networkAddr[10] ^
 			networkAddr[11] ^ networkAddr[12] ^ networkAddr[13] ^ networkAddr[14] ^ networkAddr[15] ^
 			networkAddr[16];
-	
+
 		return x & (NAT25_HASH_SIZE - 1);
 	}
 #endif	
@@ -377,7 +377,7 @@ static __inline__ int __nat25_network_hash(unsigned char *networkAddr)
 
 
 static __inline__ void __network_hash_link(struct rtl8192cd_priv *priv,
-				struct nat25_network_db_entry *ent, int hash)
+		struct nat25_network_db_entry *ent, int hash)
 {
 	ent->next_hash = priv->nethash[hash];
 	if(ent->next_hash != NULL)
@@ -398,7 +398,7 @@ static __inline__ void __network_hash_unlink(struct nat25_network_db_entry *ent)
 
 
 static int __nat25_db_network_lookup_and_replace(struct rtl8192cd_priv *priv,
-				struct sk_buff *skb, unsigned char *networkAddr)
+		struct sk_buff *skb, unsigned char *networkAddr)
 {
 	struct nat25_network_db_entry *db;
 
@@ -415,49 +415,49 @@ static int __nat25_db_network_lookup_and_replace(struct rtl8192cd_priv *priv,
 
 #ifdef CL_IPV6_PASS
 				DEBUG_INFO("NAT25: Lookup M:%02x%02x%02x%02x%02x%02x N:%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"	
-							"%02x%02x%02x%02x%02x%02x\n",				
-					db->macAddr[0],
-					db->macAddr[1],
-					db->macAddr[2],
-					db->macAddr[3],
-					db->macAddr[4],
-					db->macAddr[5],
-					db->networkAddr[0],
-					db->networkAddr[1],
-					db->networkAddr[2],
-					db->networkAddr[3],
-					db->networkAddr[4],
-					db->networkAddr[5],
-					db->networkAddr[6],
-					db->networkAddr[7],
-					db->networkAddr[8],
-					db->networkAddr[9],
-					db->networkAddr[10],
-					db->networkAddr[11],
-					db->networkAddr[12],
-					db->networkAddr[13],
-					db->networkAddr[14],
-					db->networkAddr[15],
-					db->networkAddr[16]);
+						"%02x%02x%02x%02x%02x%02x\n",				
+						db->macAddr[0],
+						db->macAddr[1],
+						db->macAddr[2],
+						db->macAddr[3],
+						db->macAddr[4],
+						db->macAddr[5],
+						db->networkAddr[0],
+						db->networkAddr[1],
+						db->networkAddr[2],
+						db->networkAddr[3],
+						db->networkAddr[4],
+						db->networkAddr[5],
+						db->networkAddr[6],
+						db->networkAddr[7],
+						db->networkAddr[8],
+						db->networkAddr[9],
+						db->networkAddr[10],
+						db->networkAddr[11],
+						db->networkAddr[12],
+						db->networkAddr[13],
+						db->networkAddr[14],
+						db->networkAddr[15],
+						db->networkAddr[16]);
 #else				
 				DEBUG_INFO("NAT25: Lookup M:%02x%02x%02x%02x%02x%02x N:%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n",
-					db->macAddr[0],
-					db->macAddr[1],
-					db->macAddr[2],
-					db->macAddr[3],
-					db->macAddr[4],
-					db->macAddr[5],
-					db->networkAddr[0],
-					db->networkAddr[1],
-					db->networkAddr[2],
-					db->networkAddr[3],
-					db->networkAddr[4],
-					db->networkAddr[5],
-					db->networkAddr[6],
-					db->networkAddr[7],
-					db->networkAddr[8],
-					db->networkAddr[9],
-					db->networkAddr[10]);
+						db->macAddr[0],
+						db->macAddr[1],
+						db->macAddr[2],
+						db->macAddr[3],
+						db->macAddr[4],
+						db->macAddr[5],
+						db->networkAddr[0],
+						db->networkAddr[1],
+						db->networkAddr[2],
+						db->networkAddr[3],
+						db->networkAddr[4],
+						db->networkAddr[5],
+						db->networkAddr[6],
+						db->networkAddr[7],
+						db->networkAddr[8],
+						db->networkAddr[9],
+						db->networkAddr[10]);
 #endif
 			}
 			return 1;
@@ -471,7 +471,7 @@ static int __nat25_db_network_lookup_and_replace(struct rtl8192cd_priv *priv,
 
 
 static void __nat25_db_network_insert(struct rtl8192cd_priv *priv,
-				unsigned char *macAddr, unsigned char *networkAddr)
+		unsigned char *macAddr, unsigned char *networkAddr)
 {
 	struct nat25_network_db_entry *db;
 	int hash;
@@ -523,54 +523,54 @@ static void __nat25_db_print(struct rtl8192cd_priv *priv)
 #ifdef CL_IPV6_PASS
 			panic_printk("NAT25: DB(%d) H(%02d) C(%d) M:%02x%02x%02x%02x%02x%02x N:%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
 					"%02x%02x%02x%02x%02x%02x\n",
-				j,
-				i,
-				atomic_read(&db->use_count),
-				db->macAddr[0],
-				db->macAddr[1],
-				db->macAddr[2],
-				db->macAddr[3],
-				db->macAddr[4],
-				db->macAddr[5],
-				db->networkAddr[0],
-				db->networkAddr[1],
-				db->networkAddr[2],
-				db->networkAddr[3],
-				db->networkAddr[4],
-				db->networkAddr[5],
-				db->networkAddr[6],
-				db->networkAddr[7],
-				db->networkAddr[8],
-				db->networkAddr[9],
-				db->networkAddr[10],
-				db->networkAddr[11],
-				db->networkAddr[12],
-				db->networkAddr[13],
-				db->networkAddr[14],
-				db->networkAddr[15],
-				db->networkAddr[16]);
+					j,
+					i,
+					atomic_read(&db->use_count),
+					db->macAddr[0],
+					db->macAddr[1],
+					db->macAddr[2],
+					db->macAddr[3],
+					db->macAddr[4],
+					db->macAddr[5],
+					db->networkAddr[0],
+					db->networkAddr[1],
+					db->networkAddr[2],
+					db->networkAddr[3],
+					db->networkAddr[4],
+					db->networkAddr[5],
+					db->networkAddr[6],
+					db->networkAddr[7],
+					db->networkAddr[8],
+					db->networkAddr[9],
+					db->networkAddr[10],
+					db->networkAddr[11],
+					db->networkAddr[12],
+					db->networkAddr[13],
+					db->networkAddr[14],
+					db->networkAddr[15],
+					db->networkAddr[16]);
 #else
 			panic_printk("NAT25: DB(%d) H(%02d) C(%d) M:%02x%02x%02x%02x%02x%02x N:%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n",
-				j,
-				i,
-				atomic_read(&db->use_count),
-				db->macAddr[0],
-				db->macAddr[1],
-				db->macAddr[2],
-				db->macAddr[3],
-				db->macAddr[4],
-				db->macAddr[5],
-				db->networkAddr[0],
-				db->networkAddr[1],
-				db->networkAddr[2],
-				db->networkAddr[3],
-				db->networkAddr[4],
-				db->networkAddr[5],
-				db->networkAddr[6],
-				db->networkAddr[7],
-				db->networkAddr[8],
-				db->networkAddr[9],
-				db->networkAddr[10]);
+					j,
+					i,
+					atomic_read(&db->use_count),
+					db->macAddr[0],
+					db->macAddr[1],
+					db->macAddr[2],
+					db->macAddr[3],
+					db->macAddr[4],
+					db->macAddr[5],
+					db->networkAddr[0],
+					db->networkAddr[1],
+					db->networkAddr[2],
+					db->networkAddr[3],
+					db->networkAddr[4],
+					db->networkAddr[5],
+					db->networkAddr[6],
+					db->networkAddr[7],
+					db->networkAddr[8],
+					db->networkAddr[9],
+					db->networkAddr[10]);
 #endif
 			j++;
 
@@ -632,51 +632,51 @@ void nat25_db_expire(struct rtl8192cd_priv *priv)
 #ifdef CL_IPV6_PASS
 						panic_printk("NAT25 Expire H(%02d) M:%02x%02x%02x%02x%02x%02x N:%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
 								"%02x%02x%02x%02x%02x%02x\n",
-							i,
-							f->macAddr[0],
-							f->macAddr[1],
-							f->macAddr[2],
-							f->macAddr[3],
-							f->macAddr[4],
-							f->macAddr[5],
-							f->networkAddr[0],
-							f->networkAddr[1],
-							f->networkAddr[2],
-							f->networkAddr[3],
-							f->networkAddr[4],
-							f->networkAddr[5],
-							f->networkAddr[6],
-							f->networkAddr[7],
-							f->networkAddr[8],
-							f->networkAddr[9],
-							f->networkAddr[10],
-							f->networkAddr[11],
-							f->networkAddr[12],
-							f->networkAddr[13],
-							f->networkAddr[14],
-							f->networkAddr[15],
-							f->networkAddr[16]);
+								i,
+								f->macAddr[0],
+								f->macAddr[1],
+								f->macAddr[2],
+								f->macAddr[3],
+								f->macAddr[4],
+								f->macAddr[5],
+								f->networkAddr[0],
+								f->networkAddr[1],
+								f->networkAddr[2],
+								f->networkAddr[3],
+								f->networkAddr[4],
+								f->networkAddr[5],
+								f->networkAddr[6],
+								f->networkAddr[7],
+								f->networkAddr[8],
+								f->networkAddr[9],
+								f->networkAddr[10],
+								f->networkAddr[11],
+								f->networkAddr[12],
+								f->networkAddr[13],
+								f->networkAddr[14],
+								f->networkAddr[15],
+								f->networkAddr[16]);
 #else
 
 						panic_printk("NAT25 Expire H(%02d) M:%02x%02x%02x%02x%02x%02x N:%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n",
-							i,
-							f->macAddr[0],
-							f->macAddr[1],
-							f->macAddr[2],
-							f->macAddr[3],
-							f->macAddr[4],
-							f->macAddr[5],
-							f->networkAddr[0],
-							f->networkAddr[1],
-							f->networkAddr[2],
-							f->networkAddr[3],
-							f->networkAddr[4],
-							f->networkAddr[5],
-							f->networkAddr[6],
-							f->networkAddr[7],
-							f->networkAddr[8],
-							f->networkAddr[9],
-							f->networkAddr[10]);
+								i,
+								f->macAddr[0],
+								f->macAddr[1],
+								f->macAddr[2],
+								f->macAddr[3],
+								f->macAddr[4],
+								f->macAddr[5],
+								f->networkAddr[0],
+								f->networkAddr[1],
+								f->networkAddr[2],
+								f->networkAddr[3],
+								f->networkAddr[4],
+								f->networkAddr[5],
+								f->networkAddr[6],
+								f->networkAddr[7],
+								f->networkAddr[8],
+								f->networkAddr[9],
+								f->networkAddr[10]);
 #endif
 #endif
 						if (!memcmp(priv->scdb_mac, f->macAddr, ETH_ALEN)) {
@@ -772,9 +772,9 @@ int nat25_db_handle(struct rtl8192cd_priv *priv, struct sk_buff *skb, int method
 #ifdef SUPPORT_TX_MCAST2UNI
 					if (priv->pshare->rf_ft_var.mc2u_disable ||
 							((((OPMODE & (WIFI_STATION_STATE|WIFI_ASOC_STATE))
-							== (WIFI_STATION_STATE|WIFI_ASOC_STATE)) &&
-							!checkIPMcAndReplace(priv, skb, &iph->daddr)) ||
-							(OPMODE & WIFI_ADHOC_STATE)))
+							   == (WIFI_STATION_STATE|WIFI_ASOC_STATE)) &&
+							  !checkIPMcAndReplace(priv, skb, &iph->daddr)) ||
+							 (OPMODE & WIFI_ADHOC_STATE)))
 #endif
 					{
 						__nat25_generate_ipv4_network_addr(networkAddr, &iph->daddr);
@@ -823,7 +823,7 @@ int nat25_db_handle(struct rtl8192cd_priv *priv, struct sk_buff *skb, int method
 			case NAT25_INSERT:
 				{
 					DEBUG_INFO("NAT25: Insert ARP, MAC=%02x%02x%02x%02x%02x%02x\n", arp_ptr[0],
-						arp_ptr[1], arp_ptr[2], arp_ptr[3], arp_ptr[4], arp_ptr[5]);
+							arp_ptr[1], arp_ptr[2], arp_ptr[3], arp_ptr[4], arp_ptr[5]);
 
 					// change to ARP sender mac address to wlan STA address
 					memcpy(arp_ptr, GET_MY_HWADDR, ETH_ALEN);
@@ -868,7 +868,7 @@ int nat25_db_handle(struct rtl8192cd_priv *priv, struct sk_buff *skb, int method
 	/*         Handle IPX and Apple Talk frame           */
 	/*---------------------------------------------------*/
 	else if((protocol == __constant_htons(ETH_P_IPX)) ||
-		(protocol <= __constant_htons(ETH_FRAME_LEN)))
+			(protocol <= __constant_htons(ETH_FRAME_LEN)))
 	{
 		unsigned char ipx_header[2] = {0xFF, 0xFF};
 		struct ipxhdr	*ipx = NULL;
@@ -923,7 +923,7 @@ int nat25_db_handle(struct rtl8192cd_priv *priv, struct sk_buff *skb, int method
 					else
 					{
 						DEBUG_WARN("NAT25: Protocol=Ethernet SNAP %02x%02x%02x%02x%02x\n", framePtr[0],
-							framePtr[1], framePtr[2], framePtr[3], framePtr[4]);
+								framePtr[1], framePtr[2], framePtr[3], framePtr[4]);
 						return -1;
 					}
 				}
@@ -962,22 +962,22 @@ int nat25_db_handle(struct rtl8192cd_priv *priv, struct sk_buff *skb, int method
 				case NAT25_INSERT:
 					{
 						DEBUG_INFO("NAT25: Insert IPX, Dest=%08x,%02x%02x%02x%02x%02x%02x,%04x Source=%08x,%02x%02x%02x%02x%02x%02x,%04x\n",
-							ipx->ipx_dest.net,
-							ipx->ipx_dest.node[0],
-							ipx->ipx_dest.node[1],
-							ipx->ipx_dest.node[2],
-							ipx->ipx_dest.node[3],
-							ipx->ipx_dest.node[4],
-							ipx->ipx_dest.node[5],
-							ipx->ipx_dest.sock,
-							ipx->ipx_source.net,
-							ipx->ipx_source.node[0],
-							ipx->ipx_source.node[1],
-							ipx->ipx_source.node[2],
-							ipx->ipx_source.node[3],
-							ipx->ipx_source.node[4],
-							ipx->ipx_source.node[5],
-							ipx->ipx_source.sock);
+								ipx->ipx_dest.net,
+								ipx->ipx_dest.node[0],
+								ipx->ipx_dest.node[1],
+								ipx->ipx_dest.node[2],
+								ipx->ipx_dest.node[3],
+								ipx->ipx_dest.node[4],
+								ipx->ipx_dest.node[5],
+								ipx->ipx_dest.sock,
+								ipx->ipx_source.net,
+								ipx->ipx_source.node[0],
+								ipx->ipx_source.node[1],
+								ipx->ipx_source.node[2],
+								ipx->ipx_source.node[3],
+								ipx->ipx_source.node[4],
+								ipx->ipx_source.node[5],
+								ipx->ipx_source.sock);
 
 						if(!memcmp(skb->data+ETH_ALEN, ipx->ipx_source.node, ETH_ALEN))
 						{
@@ -1047,10 +1047,10 @@ int nat25_db_handle(struct rtl8192cd_priv *priv, struct sk_buff *skb, int method
 						memcpy(ea->hw_src, GET_MY_HWADDR, ETH_ALEN);
 
 						DEBUG_INFO("NAT25: Insert AARP, Source=%d,%d Destination=%d,%d\n",
-							ea->pa_src_net,
-							ea->pa_src_node,
-							ea->pa_dst_net,
-							ea->pa_dst_node);
+								ea->pa_src_net,
+								ea->pa_src_node,
+								ea->pa_dst_net,
+								ea->pa_dst_node);
 
 						__nat25_generate_apple_network_addr(networkAddr, &ea->pa_src_net, &ea->pa_src_node);
 
@@ -1063,10 +1063,10 @@ int nat25_db_handle(struct rtl8192cd_priv *priv, struct sk_buff *skb, int method
 				case NAT25_LOOKUP:
 					{
 						DEBUG_INFO("NAT25: Lookup AARP, Source=%d,%d Destination=%d,%d\n",
-							ea->pa_src_net,
-							ea->pa_src_node,
-							ea->pa_dst_net,
-							ea->pa_dst_node);
+								ea->pa_src_net,
+								ea->pa_src_node,
+								ea->pa_dst_net,
+								ea->pa_dst_node);
 
 						__nat25_generate_apple_network_addr(networkAddr, &ea->pa_dst_net, &ea->pa_dst_node);
 
@@ -1093,10 +1093,10 @@ int nat25_db_handle(struct rtl8192cd_priv *priv, struct sk_buff *skb, int method
 				case NAT25_INSERT:
 					{
 						DEBUG_INFO("NAT25: Insert DDP, Source=%d,%d Destination=%d,%d\n",
-							ddp->deh_snet,
-							ddp->deh_snode,
-							ddp->deh_dnet,
-							ddp->deh_dnode);
+								ddp->deh_snet,
+								ddp->deh_snode,
+								ddp->deh_dnet,
+								ddp->deh_dnode);
 
 						__nat25_generate_apple_network_addr(networkAddr, &ddp->deh_snet, &ddp->deh_snode);
 
@@ -1109,10 +1109,10 @@ int nat25_db_handle(struct rtl8192cd_priv *priv, struct sk_buff *skb, int method
 				case NAT25_LOOKUP:
 					{
 						DEBUG_INFO("NAT25: Lookup DDP, Source=%d,%d Destination=%d,%d\n",
-							ddp->deh_snet,
-							ddp->deh_snode,
-							ddp->deh_dnet,
-							ddp->deh_dnode);
+								ddp->deh_snet,
+								ddp->deh_snode,
+								ddp->deh_dnet,
+								ddp->deh_dnode);
 
 						__nat25_generate_apple_network_addr(networkAddr, &ddp->deh_dnet, &ddp->deh_dnode);
 
@@ -1132,7 +1132,7 @@ int nat25_db_handle(struct rtl8192cd_priv *priv, struct sk_buff *skb, int method
 	/*                Handle PPPoE frame                 */
 	/*---------------------------------------------------*/
 	else if((protocol == __constant_htons(ETH_P_PPP_DISC)) ||
-		(protocol == __constant_htons(ETH_P_PPP_SES)))
+			(protocol == __constant_htons(ETH_P_PPP_SES)))
 	{
 		struct pppoe_hdr *ph = (struct pppoe_hdr *)(skb->data + ETH_HLEN);
 		unsigned short *pMagic;
@@ -1164,7 +1164,7 @@ int nat25_db_handle(struct rtl8192cd_priv *priv, struct sk_buff *skb, int method
 								}
 
 								memcpy(tag->tag_data+MAGIC_CODE_LEN+RTL_RELAY_TAG_LEN,
-									pOldTag->tag_data, old_tag_len);
+										pOldTag->tag_data, old_tag_len);
 
 								if (skb_pull_and_merge(skb, (unsigned char *)pOldTag, TAG_HDR_LEN+old_tag_len) < 0) {
 									DEBUG_ERR("call skb_pull_and_merge() failed in PADI/R packet!\n");
@@ -1186,7 +1186,7 @@ int nat25_db_handle(struct rtl8192cd_priv *priv, struct sk_buff *skb, int method
 								return -1;
 
 							DEBUG_INFO("NAT25: Insert PPPoE, forward %s packet\n",
-											(ph->code == PADI_CODE ? "PADI" : "PADR"));
+									(ph->code == PADI_CODE ? "PADI" : "PADR"));
 						}
 						else { // not add relay tag
 							if (priv->pppoe_connection_in_progress &&
@@ -1206,18 +1206,18 @@ int nat25_db_handle(struct rtl8192cd_priv *priv, struct sk_buff *skb, int method
 				}
 				else	// session phase
 				{
-						DEBUG_INFO("NAT25: Insert PPPoE, insert session packet to %s\n", skb->dev->name);
+					DEBUG_INFO("NAT25: Insert PPPoE, insert session packet to %s\n", skb->dev->name);
 
-						__nat25_generate_pppoe_network_addr(networkAddr, skb->data, &(ph->sid));
+					__nat25_generate_pppoe_network_addr(networkAddr, skb->data, &(ph->sid));
 
-						__nat25_db_network_insert(priv, skb->data+ETH_ALEN, networkAddr);
+					__nat25_db_network_insert(priv, skb->data+ETH_ALEN, networkAddr);
 
-						__nat25_db_print(priv);
+					__nat25_db_print(priv);
 
-						if (!priv->pmib->ethBrExtInfo.addPPPoETag &&
-								priv->pppoe_connection_in_progress &&
-									!memcmp(skb->data+ETH_ALEN, priv->pppoe_addr, ETH_ALEN))
-							priv->pppoe_connection_in_progress = 0;
+					if (!priv->pmib->ethBrExtInfo.addPPPoETag &&
+							priv->pppoe_connection_in_progress &&
+							!memcmp(skb->data+ETH_ALEN, priv->pppoe_addr, ETH_ALEN))
+						priv->pppoe_connection_in_progress = 0;
 				}
 				return 0;
 
@@ -1247,7 +1247,7 @@ int nat25_db_handle(struct rtl8192cd_priv *priv, struct sk_buff *skb, int method
 						pMagic = (unsigned short *)tag->tag_data;
 						if (ntohs(*pMagic) != MAGIC_CODE) {
 							DEBUG_ERR("Can't find MAGIC_CODE in %s packet!\n",
-								(ph->code == PADO_CODE ? "PADO" : "PADS"));
+									(ph->code == PADO_CODE ? "PADO" : "PADS"));
 							return -1;
 						}
 
@@ -1265,7 +1265,7 @@ int nat25_db_handle(struct rtl8192cd_priv *priv, struct sk_buff *skb, int method
 							tag->tag_len = htons(tagLen-MAGIC_CODE_LEN-RTL_RELAY_TAG_LEN);
 
 						DEBUG_INFO("NAT25: Lookup PPPoE, forward %s Packet from %s\n",
-							(ph->code == PADO_CODE ? "PADO" : "PADS"),	skb->dev->name);
+								(ph->code == PADO_CODE ? "PADO" : "PADS"),	skb->dev->name);
 					}
 					else { // not add relay tag
 						if (!priv->pppoe_connection_in_progress) {
@@ -1318,11 +1318,30 @@ int nat25_db_handle(struct rtl8192cd_priv *priv, struct sk_buff *skb, int method
 		}
 	}
 
+	/*                 Handle LLTD frame                  */
+	/*---------------------------------------------------*/
+	else if(protocol == __constant_htons(0x88d9))
+	{
+		switch(method)
+		{
+			case NAT25_CHECK:
+				return -1;
+
+			case NAT25_INSERT:
+				return 0;
+
+			case NAT25_LOOKUP:
+				return 0;
+
+			default:
+				return -1;
+		}
+	}
 	/*---------------------------------------------------*/
 	/*         Handle C-Media proprietary frame          */
 	/*---------------------------------------------------*/
 	else if((protocol == __constant_htons(0xe2ae)) ||
-		(protocol == __constant_htons(0xe2af)))
+			(protocol == __constant_htons(0xe2af)))
 	{
 		switch(method)
 		{
@@ -1364,11 +1383,11 @@ int nat25_db_handle(struct rtl8192cd_priv *priv, struct sk_buff *skb, int method
 			case NAT25_INSERT:
 				{
 					DEBUG_INFO("NAT25: Insert IP, SA=%4x:%4x:%4x:%4x:%4x:%4x:%4x:%4x,"
-									" DA=%4x:%4x:%4x:%4x:%4x:%4x:%4x:%4x\n", 
-						iph->saddr.s6_addr16[0],iph->saddr.s6_addr16[1],iph->saddr.s6_addr16[2],iph->saddr.s6_addr16[3],
-						iph->saddr.s6_addr16[4],iph->saddr.s6_addr16[5],iph->saddr.s6_addr16[6],iph->saddr.s6_addr16[7],
-						iph->daddr.s6_addr16[0],iph->daddr.s6_addr16[1],iph->daddr.s6_addr16[2],iph->daddr.s6_addr16[3],
-						iph->daddr.s6_addr16[4],iph->daddr.s6_addr16[5],iph->daddr.s6_addr16[6],iph->daddr.s6_addr16[7]);
+							" DA=%4x:%4x:%4x:%4x:%4x:%4x:%4x:%4x\n", 
+							iph->saddr.s6_addr16[0],iph->saddr.s6_addr16[1],iph->saddr.s6_addr16[2],iph->saddr.s6_addr16[3],
+							iph->saddr.s6_addr16[4],iph->saddr.s6_addr16[5],iph->saddr.s6_addr16[6],iph->saddr.s6_addr16[7],
+							iph->daddr.s6_addr16[0],iph->daddr.s6_addr16[1],iph->daddr.s6_addr16[2],iph->daddr.s6_addr16[3],
+							iph->daddr.s6_addr16[4],iph->daddr.s6_addr16[5],iph->daddr.s6_addr16[6],iph->daddr.s6_addr16[7]);
 
 					if (memcmp(&iph->saddr, "\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0", 16)) {
 						__nat25_generate_ipv6_network_addr(networkAddr, (unsigned int *)&iph->saddr);
@@ -1378,13 +1397,13 @@ int nat25_db_handle(struct rtl8192cd_priv *priv, struct sk_buff *skb, int method
 						if (iph->nexthdr == IPPROTO_ICMPV6 && 
 								skb->len > (ETH_HLEN +  sizeof(*iph) + 4)) {
 							if (update_nd_link_layer_addr(skb->data + ETH_HLEN + sizeof(*iph), 
-								skb->len - ETH_HLEN - sizeof(*iph), GET_MY_HWADDR)) {							
+										skb->len - ETH_HLEN - sizeof(*iph), GET_MY_HWADDR)) {							
 								struct icmp6hdr  *hdr = (struct icmp6hdr *)(skb->data + ETH_HLEN + sizeof(*iph));
 								hdr->icmp6_cksum = 0;
 								hdr->icmp6_cksum = csum_ipv6_magic(&iph->saddr, &iph->daddr,
-												iph->payload_len,
-												IPPROTO_ICMPV6,
-												csum_partial((__u8 *)hdr, iph->payload_len, 0));
+										iph->payload_len,
+										IPPROTO_ICMPV6,
+										csum_partial((__u8 *)hdr, iph->payload_len, 0));
 							}
 						}						
 					}
@@ -1393,12 +1412,12 @@ int nat25_db_handle(struct rtl8192cd_priv *priv, struct sk_buff *skb, int method
 
 			case NAT25_LOOKUP:
 				DEBUG_INFO("NAT25: Lookup IP, SA=%4x:%4x:%4x:%4x:%4x:%4x:%4x:%4x,"
-								" DA=%4x:%4x:%4x:%4x:%4x:%4x:%4x:%4x\n", 
+						" DA=%4x:%4x:%4x:%4x:%4x:%4x:%4x:%4x\n", 
 						iph->saddr.s6_addr16[0],iph->saddr.s6_addr16[1],iph->saddr.s6_addr16[2],iph->saddr.s6_addr16[3],
 						iph->saddr.s6_addr16[4],iph->saddr.s6_addr16[5],iph->saddr.s6_addr16[6],iph->saddr.s6_addr16[7],
 						iph->daddr.s6_addr16[0],iph->daddr.s6_addr16[1],iph->daddr.s6_addr16[2],iph->daddr.s6_addr16[3],
 						iph->daddr.s6_addr16[4],iph->daddr.s6_addr16[5],iph->daddr.s6_addr16[6],iph->daddr.s6_addr16[7]);
-			
+
 
 				__nat25_generate_ipv6_network_addr(networkAddr, (unsigned int *)&iph->daddr);
 				if (!__nat25_db_network_lookup_and_replace(priv, skb, networkAddr)) {
@@ -1414,7 +1433,46 @@ int nat25_db_handle(struct rtl8192cd_priv *priv, struct sk_buff *skb, int method
 		}
 	}
 #endif
-	return -1;
+
+	/*---------------------------------------------------*/
+	/*         Handle all other unknown format           */
+	/*---------------------------------------------------*/
+	else
+	{
+		DEBUG_INFO("NAT25: Unknown protocol: 0x%04x\n", ntohs(protocol));
+		switch(method)
+		{
+			case NAT25_CHECK:
+				return -1;
+
+			case NAT25_INSERT:
+				if (memcmp(skb->data+ETH_ALEN, GET_MY_HWADDR, ETH_ALEN) &&
+						memcmp(skb->data+ETH_ALEN, priv->br_mac, ETH_ALEN))
+				{
+					if (memcmp(skb->data+ETH_ALEN, priv->ukpro_mac, ETH_ALEN)) {
+						memcpy(priv->ukpro_mac, skb->data+ETH_ALEN, ETH_ALEN);
+						priv->ukpro_mac_valid = 1;
+						DEBUG_INFO("NAT25: Insert unknown protocol, MAC=%02x%02x%02x%02x%02x%02x\n",
+								priv->ukpro_mac[0], priv->ukpro_mac[1], priv->ukpro_mac[2],
+								priv->ukpro_mac[3], priv->ukpro_mac[4], priv->ukpro_mac[5]);
+					}
+				}
+				return 0;
+
+			case NAT25_LOOKUP:
+				// replace the destination mac address
+				if (priv->ukpro_mac_valid) {
+					memcpy(skb->data, priv->ukpro_mac, ETH_ALEN);
+					DEBUG_INFO("NAT25: Lookup unknown protocol, MAC=%02x%02x%02x%02x%02x%02x\n",
+							priv->ukpro_mac[0], priv->ukpro_mac[1], priv->ukpro_mac[2],
+							priv->ukpro_mac[3], priv->ukpro_mac[4], priv->ukpro_mac[5]);
+				}
+				return 0;
+
+			default:
+				return -1;
+		}
+	}
 }
 
 
@@ -1424,18 +1482,18 @@ int nat25_handle_frame(struct rtl8192cd_priv *priv, struct sk_buff *skb)
 	if((!priv->pmib->ethBrExtInfo.nat25_disable) && (!(skb->data[0] & 1)))
 	{
 		panic_printk("NAT25: Input Frame: DA=%02x%02x%02x%02x%02x%02x SA=%02x%02x%02x%02x%02x%02x\n",
-			skb->data[0],
-			skb->data[1],
-			skb->data[2],
-			skb->data[3],
-			skb->data[4],
-			skb->data[5],
-			skb->data[6],
-			skb->data[7],
-			skb->data[8],
-			skb->data[9],
-			skb->data[10],
-			skb->data[11]);
+				skb->data[0],
+				skb->data[1],
+				skb->data[2],
+				skb->data[3],
+				skb->data[4],
+				skb->data[5],
+				skb->data[6],
+				skb->data[7],
+				skb->data[8],
+				skb->data[9],
+				skb->data[10],
+				skb->data[11]);
 	}
 #endif
 
@@ -1460,8 +1518,8 @@ int nat25_handle_frame(struct rtl8192cd_priv *priv, struct sk_buff *skb)
 			 *	corresponding network protocol is NOT support.
 			 */
 			if (!priv->pmib->ethBrExtInfo.nat25sc_disable &&
-				(*((unsigned short *)(skb->data+ETH_ALEN*2)) == __constant_htons(ETH_P_IP)) &&
-				!memcmp(priv->scdb_ip, skb->data+ETH_HLEN+16, 4)) {
+					(*((unsigned short *)(skb->data+ETH_ALEN*2)) == __constant_htons(ETH_P_IP)) &&
+					!memcmp(priv->scdb_ip, skb->data+ETH_HLEN+16, 4)) {
 				memcpy(skb->data, priv->scdb_mac, ETH_ALEN);
 			}
 			else
@@ -1469,9 +1527,9 @@ int nat25_handle_frame(struct rtl8192cd_priv *priv, struct sk_buff *skb)
 		}
 		else {
 			if (((*((unsigned short *)(skb->data+ETH_ALEN*2)) == __constant_htons(ETH_P_IP)) &&
-					!memcmp(priv->br_ip, skb->data+ETH_HLEN+16, 4)) ||
-				((*((unsigned short *)(skb->data+ETH_ALEN*2)) == __constant_htons(ETH_P_ARP)) &&
-					!memcmp(priv->br_ip, skb->data+ETH_HLEN+24, 4))) {
+						!memcmp(priv->br_ip, skb->data+ETH_HLEN+16, 4)) ||
+					((*((unsigned short *)(skb->data+ETH_ALEN*2)) == __constant_htons(ETH_P_ARP)) &&
+					 !memcmp(priv->br_ip, skb->data+ETH_HLEN+24, 4))) {
 				// for traffic to upper TCP/IP
 				retval = nat25_db_handle(priv, skb, NAT25_LOOKUP);
 			}
@@ -1501,7 +1559,7 @@ void mac_clone(struct rtl8192cd_priv *priv, unsigned char *addr)
 
 	memcpy(sa.sa_data, addr, ETH_ALEN);
 	DEBUG_INFO("MAC Clone: Addr=%02x%02x%02x%02x%02x%02x\n",
-		addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
+			addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
 	rtl8192cd_set_hwaddr(priv->dev, &sa);
 }
 
@@ -1513,8 +1571,8 @@ int mac_clone_handle_frame(struct rtl8192cd_priv *priv, struct sk_buff *skb)
 		if(!(skb->data[ETH_ALEN] & 1))	//// check any other particular MAC add
 		{
 			if(memcmp(skb->data+ETH_ALEN, GET_MY_HWADDR, ETH_ALEN) &&
-				((priv->dev->br_port) &&
-				 memcmp(skb->data+ETH_ALEN, priv->br_mac, ETH_ALEN)))
+					((priv->dev->br_port) &&
+					 memcmp(skb->data+ETH_ALEN, priv->br_mac, ETH_ALEN)))
 			{
 				mac_clone(priv, skb->data+ETH_ALEN);
 				priv->macclone_completed = 1;
@@ -1531,6 +1589,19 @@ int mac_clone_handle_frame(struct rtl8192cd_priv *priv, struct sk_buff *skb)
 #define DHCP_MAGIC			0x63825363
 #define BROADCAST_FLAG		0x8000
 
+#define OPT_CODE 	0
+#define OPT_LEN 	1
+#define OPT_DATA 	2
+#define OPTION_FIELD	0
+#define FILE_FIELD	1
+#define SNAME_FIELD	2
+
+/* DHCP option codes (partial list) */
+#define DHCP_PADDING            0x00
+#define DHCP_REQUESTED_IP       0x32
+#define DHCP_OPTION_OVER	0x34
+#define DHCP_END		0xFF
+
 struct dhcpMessage {
 	u_int8_t op;
 	u_int8_t htype;
@@ -1550,55 +1621,161 @@ struct dhcpMessage {
 	u_int8_t options[308]; /* 312 - cookie */
 };
 
+static int end_option(unsigned char *optionptr)
+{
+	int i = 0;
+
+	while (optionptr[i] != DHCP_END) {
+		if (optionptr[i] == DHCP_PADDING) i++;
+		else i += optionptr[i + OPT_LEN] + 2;
+	}
+	return i;
+}
+
+unsigned char *get_dhcp_option(struct dhcpMessage *packet, int code)
+{
+	int i, length;
+	unsigned char *optionptr=NULL;
+	int over = 0, done = 0, curr = OPTION_FIELD;
+
+	optionptr = packet->options;
+	i = 0;
+	length = 308;
+	while (!done) {
+		if (i >= length) {
+			return NULL;
+		}
+		if (optionptr[i + OPT_CODE] == code) {
+			if (i + 1 + optionptr[i + OPT_LEN] >= length) {
+				return NULL;
+			}
+			return optionptr + i + 2;
+		}
+		switch (optionptr[i + OPT_CODE]) {
+			case DHCP_PADDING:
+				i++;
+				break;
+			case DHCP_OPTION_OVER:
+				if (i + 1 + optionptr[i + OPT_LEN] >= length) {
+					return NULL;
+				}
+				over = optionptr[i + 3];
+				i += optionptr[OPT_LEN] + 2;
+				break;
+			case DHCP_END:
+				if (curr == OPTION_FIELD && over & FILE_FIELD) {
+					optionptr = packet->file;
+					i = 0;
+					length = 128;
+					curr = FILE_FIELD;
+				} else if (curr == FILE_FIELD && over & SNAME_FIELD) {
+					optionptr = packet->sname;
+					i = 0;
+					length = 64;
+					curr = SNAME_FIELD;
+				} else done = 1;
+				break;
+			default:
+				i += optionptr[OPT_LEN + i] + 2;
+		}
+	}
+	return NULL;
+}
+
+
+void dhcp_add_reqip_option(struct rtl8192cd_priv *priv, struct sk_buff *skb)
+{
+	struct iphdr* iph = (struct iphdr *)(skb->data + ETH_HLEN);
+	struct udphdr *udph = (struct udphdr *)((unsigned int)iph + (iph->ihl << 2));
+	struct dhcpMessage *dhcph = (struct dhcpMessage *)((unsigned int)udph + sizeof(struct udphdr));
+	unsigned char opt[6] = {0};
+	unsigned char *opt_end;
+	unsigned int end_offset;
+
+	DEBUG_INFO("=======> %s - chaddr : %02X:%02X:%02X:%02X:%02X:%02X\n", __FUNCTION__, dhcph->chaddr[0], dhcph->chaddr[1],
+			dhcph->chaddr[2], dhcph->chaddr[3], dhcph->chaddr[4], dhcph->chaddr[5]);
+
+	opt[0] = (unsigned char)DHCP_REQUESTED_IP;
+	opt[1] = (unsigned char)4;
+	memcpy(&opt[2], &(dhcph->ciaddr), 4);
+	dhcph->ciaddr = 0;
+
+	skb_put(skb, 6);
+
+	end_offset = end_option(dhcph->options);
+	if (end_offset + dhcph->options[OPT_LEN] + 2 + 1 >= 308) {
+		DEBUG_ERR("*** %s add option error!!! ***\n", __FUNCTION__);
+		return;
+	}
+
+	opt_end = (unsigned char *)&(dhcph->options) + end_offset;
+
+	memcpy(opt_end, opt, 6);
+	dhcph->options[end_offset+6] = DHCP_END;
+	udph->len = htons(ntohs(udph->len) + 6);
+	iph->tot_len = htons(ntohs(iph->tot_len) + 6);
+}
+
+
 void dhcp_flag_bcast(struct rtl8192cd_priv *priv, struct sk_buff *skb)
 {
+	unsigned int ip_check_recalc = 0;
+	unsigned int udp_check_recalc = 0;
+
 	if(skb == NULL)
 		return;
 
-	if(!priv->pmib->ethBrExtInfo.dhcp_bcst_disable)
-	{
+	if(!priv->pmib->ethBrExtInfo.dhcp_bcst_disable) {
 		unsigned short protocol = *((unsigned short *)(skb->data + 2 * ETH_ALEN));
 
-		if(protocol == __constant_htons(ETH_P_IP)) // IP
-		{
+		if(protocol == __constant_htons(ETH_P_IP)) {
 			struct iphdr* iph = (struct iphdr *)(skb->data + ETH_HLEN);
 
-			if(iph->protocol == IPPROTO_UDP) // UDP
-			{
+			if(iph->protocol == IPPROTO_UDP) {
 				struct udphdr *udph = (struct udphdr *)((unsigned int)iph + (iph->ihl << 2));
 
-				if((udph->source == __constant_htons(CLIENT_PORT))
-					&& (udph->dest == __constant_htons(SERVER_PORT))) // DHCP request
-				{
-					struct dhcpMessage *dhcph =
-						(struct dhcpMessage *)((unsigned int)udph + sizeof(struct udphdr));
-
-					if(dhcph->cookie == __constant_htonl(DHCP_MAGIC)) // match magic word
-					{
-						if(!(dhcph->flags & htons(BROADCAST_FLAG))) // if not broadcast
-						{
-							register int sum = 0;
+				if((udph->source == __constant_htons(CLIENT_PORT)) && (udph->dest == __constant_htons(SERVER_PORT))) {// DHCP request
+					struct dhcpMessage *dhcph = (struct dhcpMessage *)((unsigned int)udph + sizeof(struct udphdr));
 
+					if(dhcph->cookie == __constant_htonl(DHCP_MAGIC)) {
+						if(!(dhcph->flags & htons(BROADCAST_FLAG))) {
 							DEBUG_INFO("DHCP: change flag of DHCP request to broadcast.\n");
 							// or BROADCAST flag
 							dhcph->flags |= htons(BROADCAST_FLAG);
-							// recalculate checksum
-							sum = ~(udph->check) & 0xffff;
-							sum += dhcph->flags;
-							while(sum >> 16)
-								sum = (sum & 0xffff) + (sum >> 16);
-							udph->check = ~sum;
+							udp_check_recalc++;
+						}
+
+						if (dhcph->ciaddr && memcmp(dhcph->chaddr, GET_MY_HWADDR, MACADDRLEN)) {
+							if (!get_dhcp_option(dhcph, DHCP_REQUESTED_IP)) {
+								dhcp_add_reqip_option(priv, skb);
+								udp_check_recalc++;
+								ip_check_recalc++;
+							} else {
+								dhcph->ciaddr = 0;
+								udp_check_recalc++;
+							}
 						}
 					}
 				}
+
+				if (udph->check && udp_check_recalc) {
+					udph->check = 0;
+					udph->check = csum_tcpudp_magic(iph->saddr, iph->daddr,
+							udph->len, IPPROTO_UDP,
+							csum_partial((char *)udph,
+								udph->len, 0));
+				}
 			}
+
+			if (ip_check_recalc)
+				ip_send_check(iph);
 		}
 	}
 }
 
 
 void *scdb_findEntry(struct rtl8192cd_priv *priv, unsigned char *macAddr,
-				unsigned char *ipAddr)
+		unsigned char *ipAddr)
 {
 	unsigned char networkAddr[MAX_NETWORK_ADDR_LEN];
 	struct nat25_network_db_entry *db;
diff --git a/drivers/net/wireless/rtl8192cd/8192cd_cfg.h b/drivers/net/wireless/rtl8192cd/8192cd_cfg.h
index 3af16a5..7da9174 100644
--- a/drivers/net/wireless/rtl8192cd/8192cd_cfg.h
+++ b/drivers/net/wireless/rtl8192cd/8192cd_cfg.h
@@ -120,7 +120,7 @@
 
 #define CONFIG_RTL_CUSTOM_PASSTHRU
 #if defined(CONFIG_RTL_CUSTOM_PASSTHRU)
-#define CONFIG_RTL_CUSTOM_PASSTHRU_PPPOE
+//#define CONFIG_RTL_CUSTOM_PASSTHRU_PPPOE
 
 #define IP6_PASSTHRU_MASK 0x1
 #if	defined(CONFIG_RTL_CUSTOM_PASSTHRU_PPPOE)
@@ -146,9 +146,9 @@
 #endif
 #endif
 
-#if defined(CONFIG_RTL_92D_SUPPORT) && defined(CONFIG_RTL_8198)
+#if defined(CONFIG_RTL_92D_SUPPORT) && (defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD)) || defined(CONFIG_RTL_8196E)
 /*	Currenlty 98 support 92D should use pcie slot 1	*/
-	#if defined(CONFIG_RTK_VOIP_BOARD)
+	#if defined(CONFIG_RTK_VOIP_BOARD) || defined(CONFIG_RTL_8196D) || defined(CONFIG_RTL_8196E)
 	#define	RTL_USED_PCIE_SLOT	0
 	#else
 	#define	RTL_USED_PCIE_SLOT	1
@@ -157,9 +157,9 @@
 #define	RTL_USED_PCIE_SLOT	0
 #endif
 
-#if defined(CONFIG_RTL_8198)
+#if defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 
-	#if defined(CONFIG_RTK_VOIP_BOARD)
+	#if defined(CONFIG_RTK_VOIP_BOARD) || defined(CONFIG_RTL_8196D) || defined(CONFIG_RTL_8196E)
 	#define	RTL_MAX_PCIE_SLOT_NUM	1
 	#else
 	#define	RTL_MAX_PCIE_SLOT_NUM	2
@@ -167,7 +167,7 @@
 
 	#if defined(CONFIG_RTL_92D_SUPPORT)
 
-		#if defined(CONFIG_RTK_VOIP_BOARD)
+		#if defined(CONFIG_RTK_VOIP_BOARD) || defined(CONFIG_RTL_8196D) || defined(CONFIG_RTL_8196E)
 		#define	RTL_USED_PCIE_SLOT	0
 		#else
 		#define	RTL_USED_PCIE_SLOT	1
@@ -176,17 +176,17 @@
 	#else	/*	defined(CONFIG_RTL_92D_SUPPORT)	*/
 		#define	RTL_USED_PCIE_SLOT	0
 	#endif	/*	defined(CONFIG_RTL_92D_SUPPORT)	*/
-#else	/*	defined(CONFIG_RTL_8198)	*/
+#else	/*	defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)	*/
 	#define	RTL_MAX_PCIE_SLOT_NUM	1
 	#define	RTL_USED_PCIE_SLOT	0
-#endif	/*	defined(CONFIG_RTL_8198)	*/
+#endif	/*	defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)	*/
 
 #ifdef CONFIG_RTK_MESH
-#include "mesh_ext/mesh_cfg.h"
+#include "../mesh_ext/mesh_cfg.h"
 #endif
 
 #if defined(CONFIG_RTL8196B) || defined(CONFIG_RTL_819X)
-	#if defined(CONFIG_RTL8196B_AP_ROOT) || defined(CONFIG_RTL8196B_TR) || defined(CONFIG_RTL8196B_GW) || defined(CONFIG_RTL_8196C_GW) || defined(CONFIG_RTL_8198_GW) || defined(CONFIG_RTL8196B_KLD) || defined(CONFIG_RTL8196B_TLD) || defined(CONFIG_RTL8196C_AP_ROOT) || defined(CONFIG_RTL8196C_AP_HCM) || defined(CONFIG_RTL8198_AP_ROOT) || defined(CONFIG_RTL_8198_AP_ROOT) || defined(CONFIG_RTL8196C_CLIENT_ONLY) || defined(CONFIG_RTL_8198_NFBI_BOARD) || defined(CONFIG_RTL8196C_KLD) || defined(CONFIG_RTL8196C_EC) || defined(CONFIG_RTL_8196C_iNIC) || defined(CONFIG_RTL_8198_INBAND_AP)
+	#if defined(CONFIG_RTL8196B_AP_ROOT) || defined(CONFIG_RTL8196B_TR) || defined(CONFIG_RTL8196B_GW) || defined(CONFIG_RTL_8196C_GW) || defined(CONFIG_RTL_8198_GW) || defined(CONFIG_RTL8196B_KLD) || defined(CONFIG_RTL8196B_TLD) || defined(CONFIG_RTL8196C_AP_ROOT) || defined(CONFIG_RTL8196C_AP_HCM) || defined(CONFIG_RTL8198_AP_ROOT) || defined(CONFIG_RTL_8198_AP_ROOT) || defined(CONFIG_RTL8196C_CLIENT_ONLY) || defined(CONFIG_RTL_8198_NFBI_BOARD) || defined(CONFIG_RTL8196C_KLD) || defined(CONFIG_RTL8196C_EC) || defined(CONFIG_RTL_8196C_iNIC) || defined(CONFIG_RTL_8198_INBAND_AP) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 		#define USE_RTL8186_SDK
 	#endif
 #endif
@@ -206,12 +206,16 @@
 #define MAX_NUM(_x_, _y_)	(((_x_)>(_y_))? (_x_) : (_y_))
 #define MIN_NUM(_x_, _y_)	(((_x_)<(_y_))? (_x_) : (_y_))
 
+#define POWER_MIN_CHECK(a,b)            (((a) > (b)) ? (b) : (a))
+#define POWER_RANGE_CHECK(val)		(((val) > 0x3f)? 0x3f : ((val < 0) ? 0 : val))
+#define COUNT_SIGN_OFFSET(val, oft)	(((oft & 0x08) == 0x08)? (val - (0x10 - oft)) : (val + oft))
+
 //-------------------------------------------------------------
 // Driver version information
 //-------------------------------------------------------------
 #define DRV_VERSION_H	1
-#define DRV_VERSION_L	6
-#define DRV_RELDATE		"2011-07-18"
+#define DRV_VERSION_L	4
+#define DRV_RELDATE		"2010-12-22"
 #ifdef LINUX_2_6_22_
 #define DRV_NAME		"RTL8192C/RTL8188C"
 #else
@@ -263,6 +267,8 @@
 #define SW_TX_QUEUE
 #if defined(CONFIG_RTL_8198)
 #define MAX_AGGR_NUM    16
+#elif defined(CONFIG_RTL_819XD)
+#define MAX_AGGR_NUM    4
 #else
 #define MAX_AGGR_NUM    8
 #endif
@@ -271,12 +277,10 @@
 //-------------------------------------------------------------
 // Support Tx Report
 //-------------------------------------------------------------
-//#ifndef CONFIG_RTL_92D_SUPPORT
 #define TXREPORT
 #ifdef TXREPORT
 #define DETECT_STA_EXISTANCE
 #endif
-//#endif
 //#define LEAVESTADETECT
 
 
@@ -284,16 +288,9 @@
 // PCIe power saving function
 //-------------------------------------------------------------
 #ifdef CONFIG_PCIE_POWER_SAVING
-#if !defined(CONFIG_NET_PCI) && !defined(CONFIG_RTL_8196CS)
+#if !defined(CONFIG_NET_PCI) && !defined(CONFIG_RTL_8196CS) && (!defined(CONFIG_RTL_8196E) || defined(CONFIG_RTL_ULINKER))
 #define PCIE_POWER_SAVING
 #endif
-#if	defined(CONFIG_RTL_92D_SUPPORT) && defined(CONFIG_RTL_92C_SUPPORT)
-#undef PCIE_POWER_SAVING
-#endif
-#if	defined(CONFIG_RTL_92D_SUPPORT) && defined(CONFIG_RTL_8198)
-#undef PCIE_POWER_SAVING
-#endif
-
 
 #endif
 
@@ -316,7 +313,7 @@
 #define CONFIG_SLOT1S	0xb8b30000
 
 
-#if defined(CONFIG_RTL_8198)
+#if defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 #define CFG_92C_SLOTH		CONFIG_SLOT0H
 #define CFG_92C_SLOTS		CONFIG_SLOT0S
 #if (RTL_USED_PCIE_SLOT==1)
@@ -426,7 +423,16 @@
 #if defined(CONFIG_RTK_MESH) && defined(RX_SHORTCUT)
 #define RX_RL_SHORTCUT
 #endif
+#if !defined(CONFIG_RTL_FASTBRIDGE)
+#ifdef CONFIG_RTL8672
+#ifndef CONFIG_RTL8672_BRIDGE_FASTPATH
+#define BR_SHORTCUT
+#endif
+#else
 #define BR_SHORTCUT
+#define BR_SHORTCUT_C2
+#endif
+#endif
 #if defined(CONFIG_RTK_MESH) && defined(TX_SHORTCUT)
 	#define MESH_TX_SHORTCUT
 #endif
@@ -469,6 +475,10 @@
 //-------------------------------------------------------------
 #if defined(CONFIG_RTL_REPEATER_MODE_SUPPORT)
 #define UNIVERSAL_REPEATER
+#define SMART_REPEATER_MODE
+#ifdef SMART_REPEATER_MODE
+	#define CHECK_VXD_AP_TIMEOUT	RTL_SECONDS_TO_JIFFIES(10)
+#endif
 #endif
 
 
@@ -518,6 +528,10 @@
 //#ifdef CONFIG_RTL_HOSTAPD_SUPPORT 
 //#define WIFI_HAPD
 //#endif
+#ifdef CONFIG_RTL_P2P_SUPPORT
+#define P2P_SUPPORT  //  support for WIFI_Direct
+//#define P2P_DEBUGMSG
+#endif
 
 #ifdef WIFI_HAPD
 
@@ -552,7 +566,7 @@
 #ifdef WPS2DOTX
 #define SUPPORT_PROBE_REQ_REASSEM	//for AP mode
 #define SUPPORT_PROBE_RSP_REASSEM	// for STA mode
-#define WPS2DOTX_DEBUG
+//#define WPS2DOTX_DEBUG
 #endif
 
 #ifdef	WPS2DOTX_DEBUG	  //0614 for wps2.0  trace
@@ -586,7 +600,7 @@
 //-------------------------------------------------------------
 #ifdef CONFIG_RTL_TX_RESERVE_DESC
 #if defined(UNIVERSAL_REPEATER) || defined(MBSSID)
-//#define RESERVE_TXDESC_FOR_EACH_IF
+#define RESERVE_TXDESC_FOR_EACH_IF
 #endif
 #endif
 
@@ -621,6 +635,13 @@
 #ifdef CONFIG_ANT_SWITCH
 //#define SW_ANT_SWITCH
 #define HW_ANT_SWITCH
+//#define GPIO_ANT_SWITCH
+#ifdef HW_ANT_SWITCH
+#define HW_DIV_ENABLE	(priv->pshare->rf_ft_var.antHw_enable&1)
+#endif
+#ifdef SW_ANT_SWITCH
+#define SW_DIV_ENABLE	(priv->pshare->rf_ft_var.antSw_enable&1)
+#endif
 #endif
 
 //-------------------------------------------------------------
@@ -647,7 +668,7 @@
 //Support IP multicast->unicast
 //-------------------------------------------------------------
 #define SUPPORT_TX_MCAST2UNI
-//#define MCAST2UI_REFINE
+#define MCAST2UI_REFINE
 
 #ifdef CLIENT_MODE
 #define SUPPORT_RX_UNI2MCAST
@@ -755,7 +776,7 @@
 //-------------------------------------------------------------
 // Cache station info for bridge
 //-------------------------------------------------------------
-//#define RTL_CACHED_BR_STA
+#define RTL_CACHED_BR_STA
 
 
 //-------------------------------------------------------------
@@ -773,7 +794,7 @@
 //-------------------------------------------------------------
 // Auto test support
 //-------------------------------------------------------------
-#ifndef CONFIG_RTL_92D_SUPPORT
+#ifdef CONFIG_RTL_92C_SUPPORT
 #define AUTO_TEST_SUPPORT
 #endif
 
@@ -804,7 +825,11 @@
 //-------------------------------------------------------------
 // Rx buffer gather feature
 //-------------------------------------------------------------
+#ifdef CONFIG_RTL8672
+//#define RX_BUFFER_GATHER
+#else
 #define RX_BUFFER_GATHER
+#endif
 
 
 //-------------------------------------------------------------
@@ -835,6 +860,37 @@
 //#define PACK_STRUCTURE
 
 
+//-------------------------------------------------------------
+// customers proprietary info display
+//-------------------------------------------------------------
+//#define TLN_STATS
+
+
+//-------------------------------------------------------------
+// Tx early mode
+//-------------------------------------------------------------
+#ifdef CONFIG_RTL_TX_EARLY_MODE_SUPPORT
+	#define TX_EARLY_MODE
+#endif
+
+
+//-------------------------------------------------------------
+// Dynamically switch LNA for 97d High Power in MP mode to pass Rx Test
+//-------------------------------------------------------------
+
+#if defined(CONFIG_RTL_819XD) && !defined(CONFIG_RTL_8196D) && defined(CONFIG_HIGH_POWER_EXT_PA) //for 97d High Power only
+//#define MP_SWITCH_LNA
+#endif
+
+
+//-------------------------------------------------------------
+// Import Tx Power Tracking Tables from TXT files
+//-------------------------------------------------------------
+#ifdef MERGE_FW
+//#define _TRACKING_TABLE_FILE 
+#endif
+
+
 /*********************************************************************/
 /* some definitions in 8192cd driver, we set them as NULL definition */
 /*********************************************************************/
@@ -1112,7 +1168,7 @@
 #ifdef CONFIG_RTL8672
 
 #undef DRV_RELDATE
-#define DRV_RELDATE		"2009-11-18/2010-0104"
+#define DRV_RELDATE		"2010-03-31/2011-07-08"
 
 #ifndef RX_TASKLET
 	#define RX_TASKLET
@@ -1126,7 +1182,7 @@
 	#undef RTL8190_ISR_RX
 #endif
 
-#ifdef USE_RLX_BSP
+#if defined(USE_RLX_BSP) && !defined(LINUX_2_6_22_)
 	#undef USE_RLX_BSP
 #endif
 
@@ -1152,6 +1208,20 @@
 	#undef PCIE_POWER_SAVING
 #endif
 
+#define USE_TXQUEUE
+#ifdef USE_TXQUEUE
+	#define TXQUEUE_SIZE	512
+#endif
+
+// Support dynamically adjust TXOP in low throughput feature
+#define LOW_TP_TXOP
+
+// Support four different AC stream
+#define WMM_VIBE_PRI
+
+// Resist interference 
+#define INTERFERENCE_CONTROL
+
 #endif // CONFIG_RTL8672
 
 
@@ -1160,6 +1230,7 @@
 //-------------------------------------------------------------
 #ifdef CONFIG_RTL_92D_SUPPORT
 #define SW_LCK_92D
+#define DPK_92D
 
 #ifdef CONFIG_TXPWR_LMT
 #define TXPWR_LMT
@@ -1174,8 +1245,29 @@
 //#ifdef CONFIG_RTL_92D_INT_PA
 #define RTL8192D_INT_PA
 //#endif
+
+#ifdef RTL8192D_INT_PA
+//Use Gain Table with suffix '_new'  for purpose
+//1. refine the large gap between power index 39 &40
+//#define RTL8192D_INT_PA_GAIN_TABLE_NEW //for both Non-USB & USB Power
+
+//Use Gain Table with suffix '_new1' for purpose
+//1. refine the large gap between power index 39 &40
+//2. increase tx power 
+//#define RTL8192D_INT_PA_GAIN_TABLE_NEW1 //for USB Power only
 #endif
 
+#endif
+
+
+//-------------------------------------------------------------
+// Define flag of RTL8188E features
+//-------------------------------------------------------------
+#ifdef CONFIG_RTL_88E_SUPPORT
+/* RTL8188E test chip support*/
+#define SUPPORT_RTL8188E_TC
+
+#endif
 
 
 #if 0
@@ -1270,6 +1362,11 @@
 #endif
 
 
+#if defined(TX_EARLY_MODE) && !defined(SW_TX_QUEUE)
+	#error "Define flag error, SW_TX_QUEUE is not defined!\n"
+#endif
+
+
 /*=============================================================*/
 /*------ Compiler Portability Macros --------------------------*/
 /*=============================================================*/
@@ -1368,7 +1465,7 @@
 /*=============================================================*/
 /*-----------_ Driver module flags ----------------------------*/
 /*=============================================================*/
-#ifdef CONFIG_WIRELESS_LAN_MODULE
+#if defined(CONFIG_WIRELESS_LAN_MODULE) || defined(CONFIG_RTL_ULINKER_WLAN_DELAY_INIT)
 	#define	MODULE_NAME		"Realtek WirelessLan Driver"
 	#define	MODULE_VERSION	"v1.00"
 
@@ -1385,6 +1482,8 @@
 	#define MDL_DEVINITDATA	__devinitdata
 #endif
 
+#define RADIUS_ACCOUNTING
+
 
 /*=============================================================*/
 /*----------- System configuration ----------------------------*/
@@ -1392,7 +1491,7 @@
 #if defined(CONFIG_RTL8196B_GW_8M)
 #define NUM_TX_DESC		200
 #else
-#if defined(CONFIG_RTL_8198)
+#if defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 #if defined(CONFIG_RTL_DUAL_PCIESLOT_BIWLAN_D)
 #define NUM_TX_DESC		640
 #else
@@ -1403,7 +1502,7 @@
 #endif
 #endif
 
-#if defined(CONFIG_RTL_8198)
+#if defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 	#if defined(CONFIG_RTL_DUAL_PCIESLOT_BIWLAN_D)
 		#define NUM_RX_DESC		256
 	#else
@@ -1424,11 +1523,19 @@
 	#endif
 #endif
 
+#define CURRENT_NUM_TX_DESC	priv->pshare->current_num_tx_desc
+#if defined (CONFIG_RTL_92D_SUPPORT) && defined(CONFIG_RTL_92D_DMDP)
+#define MAX_NUM_TX_DESC_DMDP		256
+#endif
+
 #ifdef DELAY_REFILL_RX_BUF
 	#define REFILL_THRESHOLD	NUM_RX_DESC
 #endif
 
 #define FW_NUM_STAT 32
+#ifdef CONFIG_RTL_88E_SUPPORT
+#define RTL8188E_NUM_STAT 64
+#endif
 
 #if (defined(CONFIG_RTL8196B_KLD) || defined(CONFIG_RTL8196C_KLD)) && defined(MBSSID)
 #define NUM_CMD_DESC	2
@@ -1439,7 +1546,11 @@
 #ifdef STA_EXT
 #define NUM_STAT		64
 #else
-#define NUM_STAT		31 //32
+#ifdef CONFIG_RTL_88E_SUPPORT
+#define NUM_STAT		(RTL8188E_NUM_STAT - 1)
+#else
+#define NUM_STAT		(FW_NUM_STAT - 1)
+#endif
 #endif
 #define MAX_GUEST_NUM   NUM_STAT
 
@@ -1596,6 +1707,7 @@
 
 #ifdef SUPPORT_TX_MCAST2UNI
 #define MAX_IP_MC_ENTRY		8
+#define MAX_FLOODING_MAC_NUM 32
 #endif
 
 #define IQK_ADDA_REG_NUM	16
@@ -1603,6 +1715,8 @@
 #define	IQK_DELAY_TIME		1		//ms
 #define IQK_MAC_REG_NUM		4
 
+#define IQK_BB_REG_NUM		9		//for 8188E IQK
+
 #define SKIP_MIC_NUM	300
 
 //Analog Pre-distortion calibration
@@ -1614,12 +1728,15 @@
 // for dynamic mechanism of reserving tx desc
 #if defined(RESERVE_TXDESC_FOR_EACH_IF) && (defined(UNIVERSAL_REPEATER) || defined(MBSSID))
 #define IF_TXDESC_UPPER_LIMIT	70	// percentage
+#ifdef USE_TXQUEUE
+#define IF_TXQ_UPPER_LIMIT		85	// percentage
+#endif
 #endif
 
 // for dynamic mechanism of retry count
 #define RETRY_TRSHLD_H	3750000
 #define RETRY_TRSHLD_L	3125000
-
+#define MP_PSD_SUPPORT 1
 //-------------------------------------------------------------
 // Define flag for 8M gateway configuration
 //-------------------------------------------------------------
diff --git a/drivers/net/wireless/rtl8192cd/8192cd_debug.h b/drivers/net/wireless/rtl8192cd/8192cd_debug.h
index c7b72ec..5561956 100644
--- a/drivers/net/wireless/rtl8192cd/8192cd_debug.h
+++ b/drivers/net/wireless/rtl8192cd/8192cd_debug.h
@@ -60,6 +60,15 @@ enum _module_define_ {
 	_MESH_=			0x00010000,	//plus add 0119
 	_WPS_ =			0x00020000,	
 	_DHW_ = 		0x00040000,
+	_HAL_ = 		0x01000000,
+	_DM_ =			0x00080000,
+	_88E_HW_ = 	0x00100000,
+	_MESH_SME_ =    0x02000000,
+        _MESH_SECURITY_ =       0x04000000,
+        _MESH_TX_ =             0x08000000,
+        _MESH_RX_ =             0x10000000,
+        _MESH_UTIL_ =   0x20000000,
+        _MESH_ROUTE_ =  0x40000000,
 };
 
 #if defined(_8192CD_OSDEP_C_)
@@ -74,6 +83,10 @@ enum _module_define_ {
 	#define _MODULE_DEFINE _IOCTL_
 	#define _MODULE_NAME	"ioctl"
 
+#elif defined(_8192CD_PROC_C_)
+	#define _MODULE_DEFINE _PROC_
+	#define _MODULE_NAME	"proc"
+
 #elif defined(_8192CD_TX_C_)
 	#define _MODULE_DEFINE _TX_
 	#define _MODULE_NAME	"tx"
@@ -130,6 +143,13 @@ enum _module_define_ {
 	#define _MODULE_DEFINE _MIB_
 	#define _MODULE_NAME	"mib"
 
+#elif defined(_8192CD_DMEM_C_)
+	//not yet
+
+#elif defined(_HAL8192CDM_C_)
+	#define _MODULE_DEFINE _HAL_
+	#define _MODULE_NAME	"hal"
+
 #elif defined(_MESH_MOD_)	//plus add 0119
 	#define _MODULE_DEFINE _MESH_
 	#define _MODULE_NAME	"mesh"
@@ -142,6 +162,45 @@ enum _module_define_ {
 	#define _MODULE_DEFINE _WPS_
 	#define _MODULE_NAME	"wps"
 
+#elif defined(_MESH_SME_C_)
+	#define _MODULE_DEFINE _MESH_SME_
+	#define _MODULE_NAME	"mesh_sme"
+
+#elif defined(_MESH_TX_C_)
+	#define _MODULE_DEFINE _MESH_TX_
+	#define _MODULE_NAME	"mesh_tx"
+	
+#elif defined(_MESH_RX_C_)
+	#define _MODULE_DEFINE _MESH_RX_
+	#define _MODULE_NAME	"mehs_rx"
+
+#elif defined(_MESH_SECURITY_C_)
+	#define _MODULE_DEFINE _MESH_SECURITY_
+	#define _MODULE_NAME	"mesh_secutiry"
+
+#elif defined(_MESH_UTILS_C_)
+	#define _MODULE_DEFINE _MESH_UTIL_
+	#define _MODULE_NAME	"mesh_util"
+
+#elif defined(_MESH_ROUTE_C_)
+	#define _MODULE_DEFINE _MESH_ROUTE_
+	#define _MODULE_NAME	"mesh_route"
+
+#elif defined(_MESH_PROC_C_)
+	#define _MODULE_DEFINE _MESH_PROC_
+	#define _MODULE_NAME	"mesh_proc"
+
+#elif defined(_MESH_11KV_C_)
+	//not yet
+	
+#elif defined(_HAL8192CDM_C_)
+	#define _MODULE_DEFINE _DM_
+        #define _MODULE_NAME    "DM"
+
+#elif defined(_8188E_HW_C_)
+	#define _MODULE_DEFINE _88E_HW_
+        #define _MODULE_NAME    "88E_hw"
+
 #else
 	#error "error, no debug module is specified!\n"
 #endif
diff --git a/drivers/net/wireless/rtl8192cd/8192cd_dmem.c b/drivers/net/wireless/rtl8192cd/8192cd_dmem.c
index 6d2a8d1..ce09af0 100644
--- a/drivers/net/wireless/rtl8192cd/8192cd_dmem.c
+++ b/drivers/net/wireless/rtl8192cd/8192cd_dmem.c
@@ -1,274 +1,279 @@
-/*
- *  D-MEM supporting module for RTL8190 802.11N wireless NIC on RTL865x platform
- *
- *  $Id: 8192cd_dmem.c,v 1.2 2010/01/19 06:04:03 jimmylin Exp $
- *
- *  Copyright (c) 2009 Realtek Semiconductor Corp.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
- */
-
-#include "./8192cd.h"
-//#include "./8190n_fastExtDev.h"
-#include "./8192cd_cfg.h"
-
-#ifdef RTL8192CD_VARIABLE_USED_DMEM
-#include "./8192cd_dmem.h"
-
-#define RTL8192CD_MAX_SPEEDUP_STA			2
-#define RTL8192CD_SPEEDUP_PRIV_COUNT		1
-
-/* ========================== All variables using D-MEM ========================== */
-static void rtl8192cd_dmem_AID_OBJ_init(void);
-static void *rtl8192cd_dmem_AID_OBJ_alloc(void *miscInfo);
-static void rtl8192cd_dmem_AID_OBJ_free(void *miscInfo);
-
-static void rtl8192cd_dmem_pmib_init(void);
-static void *rtl8192cd_dmem_pmib_alloc(void *miscInfo);
-static void rtl8192cd_dmem_pmib_free(void *miscInfo);
-
-#ifdef PRIV_STA_BUF
-	extern struct aid_obj *alloc_sta_obj(void);
-	extern void free_sta_obj(struct rtl8192cd_priv *priv, struct aid_obj *obj);
-#endif
-
-static _rtl8192cd_dmem_callBack_t _8192cd_dmem_callBack_list[] =
-{
-		/*		ID			Init CallBack				Allocate CallBack				Free CallBack */
-		{		AID_OBJ,	rtl8192cd_dmem_AID_OBJ_init,	rtl8192cd_dmem_AID_OBJ_alloc,		rtl8192cd_dmem_AID_OBJ_free},
-		{		PMIB,		rtl8192cd_dmem_pmib_init,		rtl8192cd_dmem_pmib_alloc,		rtl8192cd_dmem_pmib_free},
-		/* ==================================================================== */
-		{		_RTL8192CD_DMEM_ITEM_MAX,	NULL,								NULL},
-};
-
-/* ========================== External APIs of D-MEM module ========================== */
-
-/*
-	Initiation function for DMEM library
-*/
-void rtl8192cd_dmem_init( void )
-{
-	_rtl8192cd_dmem_callBack_t *ptr;
-
-	ptr = &_8192cd_dmem_callBack_list[0];
-
-	while (	(ptr->id > _RTL8192CD_DMEM_ITEM_MIN) &&
-			(ptr->id < _RTL8192CD_DMEM_ITEM_MAX))
-	{
-		/* Call the Callback function to decide the memory of allocated */
-		if (ptr->initCallBackFunc)
-		{
-			((_dummyFunc_void_void)(ptr->initCallBackFunc))();
-		}
-
-		/* Next Entry */
-		ptr ++;
-	}
-}
-
-void *rtl8192cd_dmem_alloc( enum _RTL8192CD_DMEM_ITEM_ID id, void *miscInfo )
-{
-	void *retval;
-	_rtl8192cd_dmem_callBack_t *ptr;
-
-	retval = NULL;
-
-	if (	(id <= _RTL8192CD_DMEM_ITEM_MIN) ||
-		(id >= _RTL8192CD_DMEM_ITEM_MAX))
-	{
-		printk("%s %d : ERROR (%d)\n", __FUNCTION__, __LINE__, id);
-		goto out;
-	}
-
-	ptr = &_8192cd_dmem_callBack_list[0];
-
-	while ( ptr->allcateCallBackFunc )
-	{
-		if ( ptr->id == id )
-		{
-			/* Call the Callback function to decide the memory of allocated */
-			retval = ((_dummyFunc_voidStar_voidStar)(ptr->allcateCallBackFunc))(miscInfo);
-			goto out;
-		}
-		/* Next Entry */
-		ptr ++;
-	}
-
-out:
-	return retval;
-}
-
-void rtl8192cd_dmem_free( enum _RTL8192CD_DMEM_ITEM_ID id, void *miscInfo )
-{
-	_rtl8192cd_dmem_callBack_t *ptr;
-
-	if (	(id <= _RTL8192CD_DMEM_ITEM_MIN) ||
-		(id >= _RTL8192CD_DMEM_ITEM_MAX))
-	{
-		printk("%s %d : ERROR (%d)\n", __FUNCTION__, __LINE__, id);
-		goto out;
-	}
-
-	ptr = &_8192cd_dmem_callBack_list[0];
-
-	while ( ptr->freeCallBackFunc )
-	{
-		if ( ptr->id == id )
-		{
-			/* Call the Callback function to decide the memory of allocated */
-			((_dummyFunc_void_voidStar)(ptr->freeCallBackFunc))(miscInfo);
-			goto out;
-		}
-		/* Next Entry */
-		ptr ++;
-	}
-
-out:
-	return;
-}
-
-
-/* ========================== Internal APIs for per-variable of D-MEM module ========================== */
-
-/* ==============================================
-  *
-  *		AID_OBJ
-  *
-  *
-  * ============================================== */
-__DRAM_IN_865X struct aid_obj _rtl8192cd_aid_Array[RTL8192CD_MAX_SPEEDUP_STA];
-void *_rtl8192cd_aid_externalMem_Array[NUM_STAT];
-
-static void rtl8192cd_dmem_AID_OBJ_init(void)
-{
-	memset(_rtl8192cd_aid_Array, 0, sizeof(struct aid_obj) * RTL8192CD_MAX_SPEEDUP_STA);
-	memset(_rtl8192cd_aid_externalMem_Array, 0, sizeof(_rtl8192cd_aid_externalMem_Array));
-}
-
-static void *rtl8192cd_dmem_AID_OBJ_alloc(void *miscInfo)
-{
-	/* For AID_OBJ : miscInfo would be [unsigned int *] to decision the index of aidarray to allocate */
-	unsigned int index = *((unsigned int*)miscInfo);
-
-	if (	(index < 0) ||
-		(index >= NUM_STAT))
-	{
-		printk("%s %d : ERROR ( Index : %d )\n", __FUNCTION__, __LINE__, index);
-		return NULL;
-	}
-
-	/* Allocate from external memory */
-	if ( index >= RTL8192CD_MAX_SPEEDUP_STA )
-	{
-#ifdef PRIV_STA_BUF
-		_rtl8192cd_aid_externalMem_Array[index] = alloc_sta_obj();
-#else
-		_rtl8192cd_aid_externalMem_Array[index] = kmalloc(sizeof(struct aid_obj), GFP_ATOMIC);
-#endif
-		if (_rtl8192cd_aid_externalMem_Array[index] == NULL)
-		{
-			printk("%s %d : Error : Allocation FAILED!\n", __FUNCTION__, __LINE__);
-			return NULL;
-		}
-		return _rtl8192cd_aid_externalMem_Array[index];
-	}
-
-	memset(&(_rtl8192cd_aid_Array[index]), 0, sizeof(struct aid_obj));
-
-	return (void*)(&(_rtl8192cd_aid_Array[index]));
-}
-
-static void rtl8192cd_dmem_AID_OBJ_free(void *miscInfo)
-{
-	/* For AID_OBJ : miscInfo would be [unsigned int *] to decision the index of aidarray to free */
-	unsigned int index = *((unsigned int*)miscInfo);
-
-	if (	(index < 0) ||
-		(index >= NUM_STAT))
-	{
-		printk("%s %d : ERROR ( Index : %d )\n", __FUNCTION__, __LINE__, index);
-		return;
-	}
-
-	/* Free memory to external memory module */
-	if ( index >= RTL8192CD_MAX_SPEEDUP_STA )
-	{
-		if ( _rtl8192cd_aid_externalMem_Array[index] )
-		{
-#ifdef PRIV_STA_BUF
-			free_sta_obj(NULL, _rtl8192cd_aid_externalMem_Array[index]);
-#else
-			kfree(_rtl8192cd_aid_externalMem_Array[index]);
-#endif
-			_rtl8192cd_aid_externalMem_Array[index] = NULL;
-		}
-
-		return;
-	}
-
-	memset(&(_rtl8192cd_aid_Array[index]), 0, sizeof(struct aid_obj));
-}
-
-
-/* =================== The following variable are mapped to PRIV =================== */
-
-/* ==============================================
-  *
-  *		PMIB
-  *
-  *
-  * ============================================== */
-__DRAM_IN_865X struct wifi_mib _rtl8192cd_pmib[RTL8192CD_SPEEDUP_PRIV_COUNT];
-int _rtl8192cd_pmib_usageMap[RTL8192CD_SPEEDUP_PRIV_COUNT];
-
-static void rtl8192cd_dmem_pmib_init(void)
-{
-	memset(_rtl8192cd_pmib_usageMap, 0, sizeof(int) * RTL8192CD_SPEEDUP_PRIV_COUNT);
-	memset(_rtl8192cd_pmib, 0, sizeof(struct wifi_mib) * RTL8192CD_SPEEDUP_PRIV_COUNT);
-}
-
-static void *rtl8192cd_dmem_pmib_alloc(void *miscInfo)
-{
-	int idx ;
-
-	/* miscInfo is useless */
-	for ( idx = 0 ; idx < RTL8192CD_SPEEDUP_PRIV_COUNT ; idx ++ )
-	{
-		if ( _rtl8192cd_pmib_usageMap[idx] == 0 )
-		{	/* Unused entry : use it */
-			_rtl8192cd_pmib_usageMap[idx] = 1;
-			memset(&(_rtl8192cd_pmib[idx]), 0, sizeof(struct wifi_mib));
-			return &(_rtl8192cd_pmib[idx]);
-		}
-	}
-
-	/* Allocate from externel memory if speedup PMIB is exhausted */
-	return kmalloc(sizeof(struct wifi_mib), GFP_ATOMIC);
-
-}
-
-static void rtl8192cd_dmem_pmib_free(void *miscInfo)
-{
-	int idx;
-
-	/* miscInfo is pointed to the address of PMIB to free */
-
-	/* Free PMIB if it is speeded up by DMEM */
-	for ( idx = 0 ; idx < RTL8192CD_SPEEDUP_PRIV_COUNT ; idx ++ )
-	{
-		if ( (unsigned int)(&(_rtl8192cd_pmib[idx])) == (unsigned int)miscInfo )
-		{	/* Entry is found : free it */
-			memset(&(_rtl8192cd_pmib[idx]), 0, sizeof(struct wifi_mib));
-			_rtl8192cd_pmib_usageMap[idx] = 0;
-			return;
-		}
-	}
-
-	/* It would be allocated from external memory: kfree it */
-	kfree(miscInfo);
-
-}
-#endif // RTL8192CD_VARIABLE_USED_DMEM
-
+/*
+ *  D-MEM supporting module for RTL8190 802.11N wireless NIC on RTL865x platform
+ *
+ *  $Id: 8192cd_dmem.c,v 1.2 2010/01/19 06:04:03 jimmylin Exp $
+ *
+ *  Copyright (c) 2009 Realtek Semiconductor Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef _8192CD_DMEM_C_
+#define _8192CD_DMEM_C_
+
+#include "./8192cd.h"
+//#include "./8190n_fastExtDev.h"
+#include "./8192cd_cfg.h"
+
+#ifdef RTL8192CD_VARIABLE_USED_DMEM
+#include "./8192cd_dmem.h"
+
+#define RTL8192CD_MAX_SPEEDUP_STA			2
+#define RTL8192CD_SPEEDUP_PRIV_COUNT		1
+
+/* ========================== All variables using D-MEM ========================== */
+static void rtl8192cd_dmem_AID_OBJ_init(void);
+static void *rtl8192cd_dmem_AID_OBJ_alloc(void *miscInfo);
+static void rtl8192cd_dmem_AID_OBJ_free(void *miscInfo);
+
+static void rtl8192cd_dmem_pmib_init(void);
+static void *rtl8192cd_dmem_pmib_alloc(void *miscInfo);
+static void rtl8192cd_dmem_pmib_free(void *miscInfo);
+
+#ifdef PRIV_STA_BUF
+	extern struct aid_obj *alloc_sta_obj(void);
+	extern void free_sta_obj(struct rtl8192cd_priv *priv, struct aid_obj *obj);
+#endif
+
+static _rtl8192cd_dmem_callBack_t _8192cd_dmem_callBack_list[] =
+{
+		/*		ID			Init CallBack				Allocate CallBack				Free CallBack */
+		{		AID_OBJ,	rtl8192cd_dmem_AID_OBJ_init,	rtl8192cd_dmem_AID_OBJ_alloc,		rtl8192cd_dmem_AID_OBJ_free},
+		{		PMIB,		rtl8192cd_dmem_pmib_init,		rtl8192cd_dmem_pmib_alloc,		rtl8192cd_dmem_pmib_free},
+		/* ==================================================================== */
+		{		_RTL8192CD_DMEM_ITEM_MAX,	NULL,								NULL},
+};
+
+/* ========================== External APIs of D-MEM module ========================== */
+
+/*
+	Initiation function for DMEM library
+*/
+void rtl8192cd_dmem_init( void )
+{
+	_rtl8192cd_dmem_callBack_t *ptr;
+
+	ptr = &_8192cd_dmem_callBack_list[0];
+
+	while (	(ptr->id > _RTL8192CD_DMEM_ITEM_MIN) &&
+			(ptr->id < _RTL8192CD_DMEM_ITEM_MAX))
+	{
+		/* Call the Callback function to decide the memory of allocated */
+		if (ptr->initCallBackFunc)
+		{
+			((_dummyFunc_void_void)(ptr->initCallBackFunc))();
+		}
+
+		/* Next Entry */
+		ptr ++;
+	}
+}
+
+void *rtl8192cd_dmem_alloc( enum _RTL8192CD_DMEM_ITEM_ID id, void *miscInfo )
+{
+	void *retval;
+	_rtl8192cd_dmem_callBack_t *ptr;
+
+	retval = NULL;
+
+	if (	(id <= _RTL8192CD_DMEM_ITEM_MIN) ||
+		(id >= _RTL8192CD_DMEM_ITEM_MAX))
+	{
+		printk("%s %d : ERROR (%d)\n", __FUNCTION__, __LINE__, id);
+		goto out;
+	}
+
+	ptr = &_8192cd_dmem_callBack_list[0];
+
+	while ( ptr->allcateCallBackFunc )
+	{
+		if ( ptr->id == id )
+		{
+			/* Call the Callback function to decide the memory of allocated */
+			retval = ((_dummyFunc_voidStar_voidStar)(ptr->allcateCallBackFunc))(miscInfo);
+			goto out;
+		}
+		/* Next Entry */
+		ptr ++;
+	}
+
+out:
+	return retval;
+}
+
+void rtl8192cd_dmem_free( enum _RTL8192CD_DMEM_ITEM_ID id, void *miscInfo )
+{
+	_rtl8192cd_dmem_callBack_t *ptr;
+
+	if (	(id <= _RTL8192CD_DMEM_ITEM_MIN) ||
+		(id >= _RTL8192CD_DMEM_ITEM_MAX))
+	{
+		printk("%s %d : ERROR (%d)\n", __FUNCTION__, __LINE__, id);
+		goto out;
+	}
+
+	ptr = &_8192cd_dmem_callBack_list[0];
+
+	while ( ptr->freeCallBackFunc )
+	{
+		if ( ptr->id == id )
+		{
+			/* Call the Callback function to decide the memory of allocated */
+			((_dummyFunc_void_voidStar)(ptr->freeCallBackFunc))(miscInfo);
+			goto out;
+		}
+		/* Next Entry */
+		ptr ++;
+	}
+
+out:
+	return;
+}
+
+
+/* ========================== Internal APIs for per-variable of D-MEM module ========================== */
+
+/* ==============================================
+  *
+  *		AID_OBJ
+  *
+  *
+  * ============================================== */
+__DRAM_IN_865X struct aid_obj _rtl8192cd_aid_Array[RTL8192CD_MAX_SPEEDUP_STA];
+void *_rtl8192cd_aid_externalMem_Array[NUM_STAT];
+
+static void rtl8192cd_dmem_AID_OBJ_init(void)
+{
+	memset(_rtl8192cd_aid_Array, 0, sizeof(struct aid_obj) * RTL8192CD_MAX_SPEEDUP_STA);
+	memset(_rtl8192cd_aid_externalMem_Array, 0, sizeof(_rtl8192cd_aid_externalMem_Array));
+}
+
+static void *rtl8192cd_dmem_AID_OBJ_alloc(void *miscInfo)
+{
+	/* For AID_OBJ : miscInfo would be [unsigned int *] to decision the index of aidarray to allocate */
+	unsigned int index = *((unsigned int*)miscInfo);
+
+	if (	(index < 0) ||
+		(index >= NUM_STAT))
+	{
+		printk("%s %d : ERROR ( Index : %d )\n", __FUNCTION__, __LINE__, index);
+		return NULL;
+	}
+
+	/* Allocate from external memory */
+	if ( index >= RTL8192CD_MAX_SPEEDUP_STA )
+	{
+#ifdef PRIV_STA_BUF
+		_rtl8192cd_aid_externalMem_Array[index] = alloc_sta_obj();
+#else
+		_rtl8192cd_aid_externalMem_Array[index] = kmalloc(sizeof(struct aid_obj), GFP_ATOMIC);
+#endif
+		if (_rtl8192cd_aid_externalMem_Array[index] == NULL)
+		{
+			printk("%s %d : Error : Allocation FAILED!\n", __FUNCTION__, __LINE__);
+			return NULL;
+		}
+		return _rtl8192cd_aid_externalMem_Array[index];
+	}
+
+	memset(&(_rtl8192cd_aid_Array[index]), 0, sizeof(struct aid_obj));
+
+	return (void*)(&(_rtl8192cd_aid_Array[index]));
+}
+
+static void rtl8192cd_dmem_AID_OBJ_free(void *miscInfo)
+{
+	/* For AID_OBJ : miscInfo would be [unsigned int *] to decision the index of aidarray to free */
+	unsigned int index = *((unsigned int*)miscInfo);
+
+	if (	(index < 0) ||
+		(index >= NUM_STAT))
+	{
+		printk("%s %d : ERROR ( Index : %d )\n", __FUNCTION__, __LINE__, index);
+		return;
+	}
+
+	/* Free memory to external memory module */
+	if ( index >= RTL8192CD_MAX_SPEEDUP_STA )
+	{
+		if ( _rtl8192cd_aid_externalMem_Array[index] )
+		{
+#ifdef PRIV_STA_BUF
+			free_sta_obj(NULL, _rtl8192cd_aid_externalMem_Array[index]);
+#else
+			kfree(_rtl8192cd_aid_externalMem_Array[index]);
+#endif
+			_rtl8192cd_aid_externalMem_Array[index] = NULL;
+		}
+
+		return;
+	}
+
+	memset(&(_rtl8192cd_aid_Array[index]), 0, sizeof(struct aid_obj));
+}
+
+
+/* =================== The following variable are mapped to PRIV =================== */
+
+/* ==============================================
+  *
+  *		PMIB
+  *
+  *
+  * ============================================== */
+__DRAM_IN_865X struct wifi_mib _rtl8192cd_pmib[RTL8192CD_SPEEDUP_PRIV_COUNT];
+int _rtl8192cd_pmib_usageMap[RTL8192CD_SPEEDUP_PRIV_COUNT];
+
+static void rtl8192cd_dmem_pmib_init(void)
+{
+	memset(_rtl8192cd_pmib_usageMap, 0, sizeof(int) * RTL8192CD_SPEEDUP_PRIV_COUNT);
+	memset(_rtl8192cd_pmib, 0, sizeof(struct wifi_mib) * RTL8192CD_SPEEDUP_PRIV_COUNT);
+}
+
+static void *rtl8192cd_dmem_pmib_alloc(void *miscInfo)
+{
+	int idx ;
+
+	/* miscInfo is useless */
+	for ( idx = 0 ; idx < RTL8192CD_SPEEDUP_PRIV_COUNT ; idx ++ )
+	{
+		if ( _rtl8192cd_pmib_usageMap[idx] == 0 )
+		{	/* Unused entry : use it */
+			_rtl8192cd_pmib_usageMap[idx] = 1;
+			memset(&(_rtl8192cd_pmib[idx]), 0, sizeof(struct wifi_mib));
+			return &(_rtl8192cd_pmib[idx]);
+		}
+	}
+
+	/* Allocate from externel memory if speedup PMIB is exhausted */
+	return kmalloc(sizeof(struct wifi_mib), GFP_ATOMIC);
+
+}
+
+static void rtl8192cd_dmem_pmib_free(void *miscInfo)
+{
+	int idx;
+
+	/* miscInfo is pointed to the address of PMIB to free */
+
+	/* Free PMIB if it is speeded up by DMEM */
+	for ( idx = 0 ; idx < RTL8192CD_SPEEDUP_PRIV_COUNT ; idx ++ )
+	{
+		if ( (unsigned int)(&(_rtl8192cd_pmib[idx])) == (unsigned int)miscInfo )
+		{	/* Entry is found : free it */
+			memset(&(_rtl8192cd_pmib[idx]), 0, sizeof(struct wifi_mib));
+			_rtl8192cd_pmib_usageMap[idx] = 0;
+			return;
+		}
+	}
+
+	/* It would be allocated from external memory: kfree it */
+	kfree(miscInfo);
+
+}
+#endif // RTL8192CD_VARIABLE_USED_DMEM
+
+#endif
+
diff --git a/drivers/net/wireless/rtl8192cd/8192cd_headers.h b/drivers/net/wireless/rtl8192cd/8192cd_headers.h
index fc1e4e6..c04e318 100644
--- a/drivers/net/wireless/rtl8192cd/8192cd_headers.h
+++ b/drivers/net/wireless/rtl8192cd/8192cd_headers.h
@@ -23,6 +23,29 @@
 
 #include "./8192cd_tx.h"
 
+#ifdef CONFIG_RTL_88E_SUPPORT
+#include "HalPwrSeqCmd.h"
+#endif
+
+
+
+#ifdef P2P_DEBUGMSG
+#define P2P_DEBUG(fmt, args...) printk("(%s %d):"fmt,__FUNCTION__ , __LINE__ , ## args)
+#define P2P_TAG_PRINT(fmt, args...) printk("Tag:"fmt, ## args)
+#define P2P_PRINT(fmt, args...) printk(""fmt,## args)
+#define MAC_PRINT(fmt) printk("%02X%02X%02X:%02X%02X%02X\n",\
+		 fmt[0],fmt[1],fmt[2],fmt[3],fmt[4],fmt[5])
+	
+#else
+#define P2P_TAG_PRINT(fmt, args...)
+#define P2P_DEBUG(fmt, args...)
+#define P2P_PRINT(fmt, args...)
+#define MAC_PRINT(fmt) 
+
+#endif
+
+
+
 
 /*-----------------------------------------------------------------------------
 								8192cd_util.c
@@ -45,7 +68,9 @@ EXTERN struct stat_info *alloc_stainfo(struct rtl8192cd_priv *priv, unsigned cha
 EXTERN void free_sta_tx_skb(struct rtl8192cd_priv *priv, struct stat_info *pstat);
 EXTERN void free_sta_skb(struct rtl8192cd_priv *priv, struct stat_info *pstat);
 EXTERN int free_stainfo(struct rtl8192cd_priv *priv, struct	stat_info *pstat);
-EXTERN __MIPS16 __IRAM_IN_865X struct stat_info *get_stainfo (struct rtl8192cd_priv *priv, unsigned char *hwaddr);
+__MIPS16
+__IRAM_IN_865X
+EXTERN struct stat_info *get_stainfo (struct rtl8192cd_priv *priv, unsigned char *hwaddr);
 EXTERN struct stat_info *get_aidinfo (struct rtl8192cd_priv *priv, unsigned int aid);
 EXTERN int IS_BSSID(struct rtl8192cd_priv *priv, unsigned char *da);
 EXTERN int IS_MCAST(unsigned char *da);
@@ -55,7 +80,9 @@ EXTERN int skb_p80211_to_ether(struct net_device *dev, int wep_mode, struct rx_f
 EXTERN int strip_amsdu_llc(struct rtl8192cd_priv *priv, struct sk_buff *skb, struct stat_info *pstat);
 EXTERN unsigned char *get_da(unsigned char *pframe);
 EXTERN unsigned char *get_bssid_mp(unsigned char *pframe);
-EXTERN __MIPS16 __IRAM_IN_865X unsigned char get_hdrlen(struct rtl8192cd_priv *priv, UINT8 *pframe);
+__MIPS16
+__IRAM_IN_865X
+EXTERN unsigned char get_hdrlen(struct rtl8192cd_priv *priv, UINT8 *pframe);
 EXTERN unsigned int get_mcast_privacy(struct rtl8192cd_priv *priv, unsigned int *iv, unsigned int *icv,
 				unsigned int *mic);
 EXTERN unsigned int	get_privacy(struct rtl8192cd_priv *priv, struct stat_info *pstat,
@@ -116,25 +143,16 @@ EXTERN void enable_vxd_ap(struct rtl8192cd_priv *priv);
 #ifdef GBWC
 EXTERN void rtl8192cd_GBWC_timer(unsigned long task_priv);
 #endif
-EXTERN void add_update_RATid(struct rtl8192cd_priv *priv, struct stat_info *pstat);
 
 #ifdef STA_EXT
 EXTERN void release_remapAid(struct rtl8192cd_priv *priv, struct stat_info *pstat);
 #endif
 
-EXTERN void add_update_rssi(struct rtl8192cd_priv * priv, struct stat_info * pstat);
-
 // to avoid add RAtid fail
-EXTERN void add_RATid_timer(unsigned long task_priv);
-EXTERN void add_rssi_timer(unsigned long task_priv);
 EXTERN unsigned int is_h2c_buf_occupy(struct rtl8192cd_priv *priv);
 EXTERN short signin_h2c_cmd(struct rtl8192cd_priv *priv, unsigned int content, unsigned short ext_content);
 EXTERN void add_ps_timer(unsigned long task_priv);
 
-#if defined(CONFIG_RTL_92D_SUPPORT) && defined(CONFIG_RTL_NOISE_CONTROL)
-EXTERN void dnc_timer(unsigned long task_priv);
-#endif
-
 #ifdef SMART_CONCURRENT_92D
 EXTERN void smcc_prb_timer(unsigned long task_priv);
 #endif
@@ -161,9 +179,7 @@ EXTERN int is_rtl8190_priv_buf(unsigned char *head);
 EXTERN void free_rtl8190_priv_buf(unsigned char *head);
 #endif
 
-EXTERN void choose_IOT_main_sta(struct rtl8192cd_priv *priv, struct stat_info *pstat);
-EXTERN void rxBB_dm(struct rtl8192cd_priv *priv);
-EXTERN void IOT_engine(struct rtl8192cd_priv *priv);
+
 
 #ifdef STA_EXT
 EXTERN unsigned char fw_was_full(struct rtl8192cd_priv *priv);
@@ -178,7 +194,7 @@ EXTERN UINT8 dot11_rate_table[];
 EXTERN unsigned int set_fw_reg(struct rtl8192cd_priv *priv, unsigned int cmd, unsigned int val, unsigned int with_val);
 EXTERN void set_fw_A2_entry(struct rtl8192cd_priv * priv, unsigned int cmd, unsigned char * addr);
 */
-EXTERN void set_RATid_cmd(struct rtl8192cd_priv * priv, unsigned int macid, unsigned int rateid, unsigned int ratemask);
+
 
 #ifdef CONFIG_RTK_MESH
 #ifdef _11s_TEST_MODE_
@@ -220,12 +236,9 @@ EXTERN void free_sta_mgt_que(struct rtl8192cd_priv *priv, struct dz_mgmt_queue *
 EXTERN int string_to_hex(char *string, unsigned char *key, int len);
 #endif
 
-#ifdef TXREPORT
+#if defined(TXREPORT) && (defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT))
 EXTERN void requestTxReport(struct rtl8192cd_priv *priv);
 EXTERN void C2H_isr(struct rtl8192cd_priv *priv);
-EXTERN void DetectSTAExistance(struct rtl8192cd_priv *priv, struct tx_rpt *report, struct stat_info *pstat );
-EXTERN void RetryLimitRecovery(unsigned long task_priv);
-EXTERN void LeavingSTA_RLCheck(struct rtl8192cd_priv *priv);
 #endif
 
 #ifdef SW_ANT_SWITCH
@@ -237,6 +250,11 @@ void merge_pool(struct rtl8192cd_priv *priv);
 void split_pool(struct rtl8192cd_priv *priv);
 #endif
 
+#ifdef TLN_STATS
+EXTERN void stats_conn_rson_counts(struct rtl8192cd_priv * priv, unsigned int reason);
+EXTERN void stats_conn_status_counts(struct rtl8192cd_priv * priv, unsigned int status);
+#endif
+
 #undef EXTERN
 
 
@@ -260,15 +278,23 @@ EXTERN __MIPS16 __IRAM_IN_865X void assign_wlanseq(struct rtl8192cd_hw *phw, uns
 EXTERN void signin_txdesc(struct rtl8190_priv *priv, struct tx_insn* txcfg);
 #endif
 EXTERN int rtl8192cd_start_xmit(struct sk_buff *skb, struct net_device *dev);
+#ifdef SUPPORT_TX_MCAST2UNI
+EXTERN int rtl8192cd_start_xmit_noM2U(struct sk_buff *skb, struct net_device *dev);
+#else
+#define		rtl8192cd_start_xmit_noM2U		rtl8192cd_start_xmit
+#endif
 EXTERN int rtl8192cd_wlantx(struct rtl8192cd_priv *priv, struct tx_insn *txcfg);
 EXTERN void rtl8192cd_tx_dsr(unsigned long task_priv);
 EXTERN int rtl8192cd_firetx(struct rtl8192cd_priv *priv, struct tx_insn *txcfg);
+#ifdef CONFIG_RTK_MESH
+EXTERN int rtl8192cd_signin_txdesc(struct rtl8192cd_priv *priv, struct tx_insn* txcfg, struct wlan_ethhdr_t *pethdhr);
+#else
 EXTERN int rtl8192cd_signin_txdesc(struct rtl8192cd_priv *priv, struct tx_insn* txcfg);
-
+#endif
 
 #ifdef TX_SHORTCUT
 //EXTERN void signin_txdesc_shortcut(struct rtl8190_priv *priv, struct tx_insn *txcfg);
-EXTERN __MIPS16 __IRAM_IN_865X int rtl8192cd_signin_txdesc_shortcut(struct rtl8192cd_priv *priv, struct tx_insn *txcfg, int idx);
+EXTERN __MIPS16 int rtl8192cd_signin_txdesc_shortcut(struct rtl8192cd_priv *priv, struct tx_insn *txcfg, int idx);
 #endif
 EXTERN int SetupOneCmdPacket(struct rtl8192cd_priv *priv, unsigned char *dat_content,
 				unsigned short txLength, unsigned char LastPkt);
@@ -328,7 +354,7 @@ EXTERN void enable_sw_LED(struct rtl8192cd_priv *priv, int init);
 EXTERN void disable_sw_LED(struct rtl8192cd_priv *priv);
 EXTERN void calculate_sw_LED_interval(struct rtl8192cd_priv *priv);
 EXTERN int chklink_wkstaQ(struct rtl8192cd_priv *priv);
-EXTERN void check_txrate_by_reg(struct rtl8192cd_priv *priv, struct stat_info *pstat);
+
 #ifdef CLIENT_MODE
 EXTERN void start_clnt_join(struct rtl8192cd_priv *priv);
 EXTERN void start_clnt_lookup(struct rtl8192cd_priv *priv, int rescan);
@@ -338,6 +364,7 @@ EXTERN void rtl8192cd_idle_timer(unsigned long task_priv);
 #ifdef DFS
 EXTERN void rtl8192cd_dfs_cntdwn_timer(unsigned long task_priv);
 #endif
+EXTERN void issue_PsPoll(struct rtl8192cd_priv *priv);
 #endif
 
 #ifdef DFS
@@ -411,13 +438,20 @@ EXTERN void proxy_table_chkcln(struct rtl8192cd_priv* priv, struct sk_buff *pskb
 EXTERN int fire_data_frame(struct sk_buff *skb, struct net_device *dev, struct tx_insn* txinsn);
 
 #endif
-EXTERN void reset_1r_sta_RA(struct rtl8192cd_priv *priv, unsigned int sg_rate);
 
 EXTERN void default_WMM_para(struct rtl8192cd_priv *priv);
-
+EXTERN unsigned char *search_wsc_tag(unsigned char *data, unsigned short id, int len, int *out_len);
 #ifdef CONFIG_RTL_92D_DMDP
 EXTERN void reset_dmdp_peer(struct rtl8192cd_priv *from);
 #endif
+#ifdef CONFIG_RTL_92D_SUPPORT
+int clnt_ss_check_band(struct rtl8192cd_priv *priv, unsigned int channel);
+#endif
+
+#ifdef SMART_REPEATER_MODE
+void check_vxd_ap_timer(unsigned long task_priv);
+#endif 
+
 #undef EXTERN
 
 
@@ -434,7 +468,10 @@ EXTERN void reset_dmdp_peer(struct rtl8192cd_priv *from);
 #ifdef RX_TASKLET
 EXTERN void rtl8192cd_rx_tkl_isr(unsigned long task_priv);
 #endif
-EXTERN void rtl8192cd_rx_isr(struct rtl8192cd_priv *priv);
+#ifndef __LINUX_2_6__
+__MIPS16
+#endif
+EXTERN  void rtl8192cd_rx_isr(struct rtl8192cd_priv *priv);
 EXTERN void rtl8192cd_rx_dsr(unsigned long task_priv);
 EXTERN __MIPS16 __IRAM_IN_865X void rtl_netif_rx(struct rtl8192cd_priv *priv, struct sk_buff *pskb, struct stat_info *pstat);
 //EXTERN void rtl8190_rxcmd_isr(struct rtl8190_priv *priv);
@@ -442,6 +479,8 @@ EXTERN void reorder_ctrl_timeout(unsigned long task_priv);
 
 #ifdef CONFIG_RTK_MESH
 EXTERN void rtl8192cd_rx_mgntframe(struct rtl8192cd_priv*, struct list_head *,struct rx_frinfo*);
+__MIPS16
+__IRAM_IN_865X
 EXTERN void rtl8192cd_rx_dataframe(struct rtl8192cd_priv*, struct list_head *,struct rx_frinfo*);
 #endif
 
@@ -500,7 +539,7 @@ EXTERN void set_slot_time(struct rtl8192cd_priv *priv, int use_short);
 EXTERN void SetTxPowerLevel(struct rtl8192cd_priv *priv);
 EXTERN void SwChnl(struct rtl8192cd_priv *priv, unsigned char channel, int offset);
 EXTERN void enable_hw_LED(struct rtl8192cd_priv *priv, unsigned int led_type);
-EXTERN void init_EDCA_para(struct rtl8192cd_priv *priv, int mode);
+
 EXTERN unsigned int PHY_QueryRFReg(struct rtl8192cd_priv *priv, RF92CD_RADIO_PATH_E eRFPath,
 				unsigned int RegAddr, unsigned int BitMask, unsigned int dbg_avoid);
 EXTERN unsigned int PHY_QueryBBReg(struct rtl8192cd_priv *priv, unsigned int RegAddr, unsigned int BitMask);
@@ -510,35 +549,29 @@ EXTERN void PHY_SetRFReg(struct rtl8192cd_priv *priv, RF92CD_RADIO_PATH_E eRFPat
 EXTERN int phy_RF8256_Config_ParaFile(struct rtl8192cd_priv *priv);
 //EXTERN int PHY_ConfigMACWithParaFile(struct rtl8192cd_priv *priv);
 EXTERN void SwBWMode(struct rtl8192cd_priv *priv, unsigned int bandwidth, int offset);
-EXTERN void check_EDCCA(struct rtl8192cd_priv * priv, short rssi);
+
 EXTERN void setup_timer1(struct rtl8192cd_priv *priv, int timeout);
 EXTERN void cancel_timer1(struct rtl8192cd_priv *priv);
 EXTERN void setup_timer2(struct rtl8192cd_priv *priv, unsigned int timeout);
 EXTERN void cancel_timer2(struct rtl8192cd_priv *priv);
-EXTERN void set_DIG_state(struct rtl8192cd_priv *priv, int state);
-EXTERN void DIG_process(struct rtl8192cd_priv *priv);
-EXTERN void check_DIG_by_rssi(struct rtl8192cd_priv *priv, unsigned char rssi_strength);
-EXTERN void DIG_for_site_survey(struct rtl8192cd_priv *priv, int do_ss);
-EXTERN void CCK_txpower_by_rssi(struct rtl8192cd_priv *priv, unsigned char rssi_strength);
+
+
+//EXTERN void CCK_txpower_by_rssi(struct rtl8192cd_priv *priv, unsigned char rssi_strength);
 EXTERN void reload_txpwr_pg(struct rtl8192cd_priv *priv);
 EXTERN int rtl8192cd_init_hw_PCI(struct rtl8192cd_priv *priv);
 EXTERN int rtl8192cd_stop_hw(struct rtl8192cd_priv *priv);
-EXTERN int CheckNoResetHwExceptionCase(struct rtl8192cd_priv *priv);
+EXTERN int check_MAC_IO_Enable(struct rtl8192cd_priv *priv);
 
 #ifdef CONFIG_RTL_92D_SUPPORT
-EXTERN int get_CCK_swing_index(struct rtl8192cd_priv *priv);
-EXTERN void set_CCK_swing_index(struct rtl8192cd_priv * priv,short CCK_index);
 
-EXTERN void PHY_IQCalibrate(struct rtl8192cd_priv * priv);
 EXTERN unsigned int get_mean_of_2_close_value(unsigned int *val_array);
-EXTERN unsigned int PHY_QueryBBReg(struct rtl8192cd_priv *priv, unsigned int RegAddr, unsigned int BitMask);
-EXTERN void PHY_SetBBReg(struct rtl8192cd_priv * priv,unsigned int RegAddr,unsigned int BitMask,unsigned int Data);
-EXTERN unsigned int PHY_QueryRFReg(struct rtl8192cd_priv * priv,RF92CD_RADIO_PATH_E eRFPath,unsigned int RegAddr,unsigned int BitMask,unsigned int dbg_avoid);
-EXTERN void PHY_SetRFReg(struct rtl8192cd_priv * priv,RF92CD_RADIO_PATH_E eRFPath,unsigned int RegAddr,unsigned int BitMask,unsigned int Data);
 EXTERN int PHY_ConfigBBWithParaFile(struct rtl8192cd_priv *priv, int reg_file);
 #ifdef TXPWR_LMT
 EXTERN int PHY_ConfigTXLmtWithParaFile(struct rtl8192cd_priv * priv);
 #endif
+#ifdef _TRACKING_TABLE_FILE
+EXTERN int PHY_ConfigTXPwrTrackingWithParaFile(struct rtl8192cd_priv * priv);
+#endif
 
 #ifdef CONFIG_RTL_92D_DMDP
 void Sw_PCIE_Func(int func);
@@ -546,51 +579,21 @@ void Sw_PCIE_Func(int func);
 #endif
 
 EXTERN void HostPCIe_Close(void);
-#ifdef WIFI_WMM
-EXTERN void IOT_EDCA_switch(struct rtl8192cd_priv *priv, int mode, char enable);
-#endif
+
 //EXTERN void tx_path_by_rssi(struct rtl8192cd_priv *priv, struct stat_info *pstat, unsigned char enable);
 //EXTERN void rx_path_by_rssi(struct rtl8192cd_priv *priv, struct stat_info *pstat, int enable);
-EXTERN void rx_path_by_rssi_cck_v2(struct rtl8192cd_priv *priv, struct stat_info *pstat);
-#ifdef HIGH_POWER_EXT_PA
-EXTERN void tx_power_control(struct rtl8192cd_priv *priv);
-#endif
-EXTERN void tx_power_tracking(struct rtl8192cd_priv *priv);
+//EXTERN void rx_path_by_rssi_cck_v2(struct rtl8192cd_priv *priv, struct stat_info *pstat);
 //EXTERN void rtl8192cd_tpt_timer(unsigned long task_priv);
 
-#ifdef SW_ANT_SWITCH
-EXTERN void dm_SW_AntennaSwitchCallback(unsigned long task_priv) ;
-EXTERN void dm_SWAW_RSSI_Check(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinfo);
-EXTERN void dm_SW_AntennaSwitchInit(struct rtl8192cd_priv *priv);
-EXTERN void dm_SW_AntennaSwitch(struct rtl8192cd_priv *priv, char Step);
-#endif
 
-#if defined(SW_ANT_SWITCH) || defined(HW_ANT_SWITCH)
-EXTERN int diversity_antenna_select(struct rtl8192cd_priv *priv, unsigned char *data);
-#endif
-#if defined(HW_ANT_SWITCH)
-EXTERN void dm_HW_AntennaSwitchInit(struct rtl8192cd_priv *priv);
-EXTERN void setRxIdleAnt(struct rtl8192cd_priv *priv, char nextAnt) ;
-EXTERN void dm_STA_Ant_Select(struct rtl8192cd_priv *priv, struct stat_info *pstat);
-EXTERN void dm_HW_IdleAntennaSelect(struct rtl8192cd_priv *priv);
-
-#endif
 
 //EXTERN void SwitchExtAnt(struct rtl8192cd_priv *priv, unsigned char EXT_ANT_PATH);
 //EXTERN void rtl8192cd_ePhyInit(struct rtl8192cd_priv * priv);
 //EXTERN void Switch_1SS_Antenna(struct rtl8192cd_priv *priv, unsigned int antPath );
 //EXTERN void Switch_OFDM_Antenna(struct rtl8192cd_priv *priv, unsigned int antPath );
-EXTERN void FA_statistic(struct rtl8192cd_priv * priv);
 
-#ifdef CONFIG_RTL_NEW_AUTOCH
-EXTERN void _FA_statistic(struct rtl8192cd_priv* priv);
-EXTERN void reset_FA_reg(struct rtl8192cd_priv* priv);
-EXTERN void hold_CCA_FA_counter(struct rtl8192cd_priv* priv);
-EXTERN void release_CCA_FA_counter(struct rtl8192cd_priv* priv);
-#endif
 
-EXTERN void CCK_CCA_dynamic_enhance(struct rtl8192cd_priv * priv, unsigned char rssi_strength);
-EXTERN void check_NAV_prot_len(struct rtl8192cd_priv * priv, struct stat_info * pstat, unsigned int disassoc);
+
 
 // CAM related functions
 EXTERN int CamAddOneEntry(struct rtl8192cd_priv *priv, unsigned char *pucMacAddr,
@@ -608,10 +611,12 @@ EXTERN unsigned char *get_line(unsigned char **line);
 EXTERN void find_pwr_limit(struct rtl8192cd_priv *priv);
 #endif
 
+#ifdef _DEBUG_RTL8192CD_	
 //_TXPWR_REDEFINE
 EXTERN void Read_PG_File(struct rtl8192cd_priv *priv, int reg_file, int table_number, 
 				char *MCSTxAgcOffset_A, char *MCSTxAgcOffset_B, char *OFDMTxAgcOffset_A,
 				char *OFDMTxAgcOffset_B, char *CCKTxAgc_A, char *CCKTxAgc_B);
+#endif
 
 
 #ifdef MERGE_FW
@@ -627,6 +632,10 @@ EXTERN void Read_PG_File(struct rtl8192cd_priv *priv, int reg_file, int table_nu
 	EXTERN unsigned char *data_TXPWR_LMT_FCC_start, *data_TXPWR_LMT_FCC_end;
 	EXTERN unsigned char *data_TXPWR_LMT_CE_start, *data_TXPWR_LMT_CE_end;
 #endif
+#ifdef _TRACKING_TABLE_FILE
+	EXTERN unsigned char *data_REG_TXPWR_TRK_n_92d_start, *data_REG_TXPWR_TRK_n_92d_end;
+	EXTERN unsigned char *data_REG_TXPWR_TRK_n_92d_hp_start, *data_REG_TXPWR_TRK_n_92d_hp_end;
+#endif
 	EXTERN unsigned char *data_AGC_TAB_n_start, *data_AGC_TAB_n_end;
 	EXTERN unsigned char *data_AGC_TAB_2G_n_start, *data_AGC_TAB_2G_n_end;
 	EXTERN unsigned char *data_AGC_TAB_5G_n_start, *data_AGC_TAB_5G_n_end;
@@ -634,16 +643,36 @@ EXTERN void Read_PG_File(struct rtl8192cd_priv *priv, int reg_file, int table_nu
 	EXTERN unsigned char *data_radio_b_n_start, *data_radio_b_n_end;
 #ifdef RTL8192D_INT_PA
 #ifdef USB_POWER_SUPPORT
+
+#if defined (RTL8192D_INT_PA_GAIN_TABLE_NEW)
+	EXTERN unsigned char *data_radio_a_intPA_GM_new_start, *data_radio_a_intPA_GM_new_end;
+	EXTERN unsigned char *data_radio_b_intPA_GM_new_start, *data_radio_b_intPA_GM_new_end;
+#elif defined (RTL8192D_INT_PA_GAIN_TABLE_NEW1)
+	EXTERN unsigned char *data_radio_a_intPA_GM_new1_start, *data_radio_a_intPA_GM_new1_end;
+	EXTERN unsigned char *data_radio_b_intPA_GM_new1_start, *data_radio_b_intPA_GM_new1_end;
+#else
 	EXTERN unsigned char *data_radio_a_intPA_GM_start, *data_radio_a_intPA_GM_end;
 	EXTERN unsigned char *data_radio_b_intPA_GM_start, *data_radio_b_intPA_GM_end;
+#endif
+
+#else //USB_POWER_SUPPORT
+
+#if defined (RTL8192D_INT_PA_GAIN_TABLE_NEW)
+	EXTERN unsigned char *data_radio_a_intPA_new_start, *data_radio_a_intPA_new_end;
+	EXTERN unsigned char *data_radio_b_intPA_new_start, *data_radio_b_intPA_new_end;
 #else
 	EXTERN unsigned char *data_radio_a_intPA_start, *data_radio_a_intPA_end;
 	EXTERN unsigned char *data_radio_b_intPA_start, *data_radio_b_intPA_end;
 #endif
-#endif
+
+#endif //USB_POWER_SUPPORT
+#endif //RTL8192D_INT_PA
 
 //_TXPWR_REDEFINE
 #ifdef HIGH_POWER_EXT_PA
+	EXTERN unsigned char *data_AGC_TAB_n_92d_hp_start, *data_AGC_TAB_n_92d_hp_end;
+	EXTERN unsigned char *data_PHY_REG_PG_92d_hp_start, *data_PHY_REG_PG_92d_hp_end;
+	EXTERN unsigned char *data_PHY_REG_n_92d_hp_start, *data_PHY_REG_n_92d_hp_end;
 	EXTERN unsigned char *data_radio_a_n_92d_hp_start, *data_radio_a_n_92d_hp_end;
 	EXTERN unsigned char *data_radio_b_n_92d_hp_start, *data_radio_b_n_92d_hp_end;
 #endif
@@ -687,9 +716,41 @@ EXTERN unsigned char *data_radio_b_2T_n_lna_start, *data_radio_b_2T_n_lna_end;
 	EXTERN unsigned char *data_PHY_REG_PG_hp_start, *data_PHY_REG_PG_hp_end;
 #endif
 
+#ifdef _TRACKING_TABLE_FILE
+	EXTERN unsigned char *data_REG_TXPWR_TRK_start, *data_REG_TXPWR_TRK_end;
+	EXTERN unsigned char *data_REG_TXPWR_TRK_hp_start, *data_REG_TXPWR_TRK_hp_end;
+#endif
+
+
 #endif //CONFIG_RTL_92C_SUPPORT
+
+//For 8188E IQK
+EXTERN unsigned char *data_AGC_TAB_1T_88E_start, *data_AGC_TAB_1T_88E_end;
+EXTERN unsigned char *data_MAC_REG_88E_start, *data_MAC_REG_88E_end;
+EXTERN unsigned char *data_PHY_REG_1T_88E_start, *data_PHY_REG_1T_88E_end;
+EXTERN unsigned char *data_PHY_REG_MP_88E_start, *data_PHY_REG_MP_88E_end;
+EXTERN unsigned char *data_PHY_REG_PG_88E_start, *data_PHY_REG_PG_88E_end;
+EXTERN unsigned char *data_radio_a_1T_88E_start, *data_radio_a_1T_88E_end;
+
 #endif //MERGE_FW
 
+EXTERN void _PHY_SaveADDARegisters(struct rtl8192cd_priv *priv, unsigned int *ADDAReg,	unsigned int *ADDABackup, unsigned int RegisterNum);
+EXTERN void _PHY_SetADDARegisters(struct rtl8192cd_priv *priv, unsigned int* ADDAReg,	unsigned int* ADDASettings, unsigned int RegisterNum);
+EXTERN void _PHY_SaveMACRegisters(struct rtl8192cd_priv *priv, unsigned int *MACReg, unsigned int *MACBackup);
+EXTERN void _PHY_ReloadADDARegisters(struct rtl8192cd_priv *priv, unsigned int *ADDAReg, unsigned int *ADDABackup, unsigned int RegiesterNum);
+EXTERN void _PHY_ReloadMACRegisters(struct rtl8192cd_priv *priv,unsigned int *MACReg, unsigned int *MACBackup);
+EXTERN void _PHY_MACSettingCalibration(struct rtl8192cd_priv *priv, unsigned int* MACReg, unsigned int* MACBackup);
+EXTERN void _PHY_PathADDAOn(struct rtl8192cd_priv *priv, unsigned int* ADDAReg, char isPathAOn, char is2T);
+
+
+EXTERN void PHY_LCCalibrate(struct rtl8192cd_priv *priv);
+EXTERN void PHY_IQCalibrate(struct rtl8192cd_priv *priv);
+
+#ifdef TX_EARLY_MODE
+EXTERN void enable_em(struct rtl8192cd_priv *priv);
+EXTERN void disable_em(struct rtl8192cd_priv *priv);
+#endif
+
 #undef EXTERN
 
 
@@ -732,7 +793,6 @@ EXTERN void phy_ReloadLCKSetting(struct rtl8192cd_priv *priv);
 #endif
 EXTERN int Load_92D_Firmware(struct rtl8192cd_priv *priv);
 EXTERN void UpdateBBRFVal8192DE(struct rtl8192cd_priv *priv);
-EXTERN void tx_power_tracking_92D(struct rtl8192cd_priv * priv);
 EXTERN void Update92DRFbyChannel(struct rtl8192cd_priv * priv,unsigned char channel);
 
 #ifdef CONFIG_RTL_92D_DMDP
@@ -745,6 +805,12 @@ EXTERN void IQK_92D_5G_n(struct rtl8192cd_priv * priv);
 #ifdef CONFIG_RTL_92D_DMDP
 EXTERN void IQK_92D_5G_phy0_n(struct rtl8192cd_priv * priv);
 #endif
+
+#ifdef DPK_92D
+EXTERN void rtl8192cd_DPK_timer(unsigned long task_priv);
+EXTERN void PHY_DPCalibrate(struct rtl8192cd_priv *priv);
+#endif
+
 #undef EXTERN
 
 #endif //CONFIG_RTL_92D_SUPPORT
@@ -801,7 +867,7 @@ EXTERN int rtl8192cd_ss_req(struct rtl8192cd_priv *priv, unsigned char *data, in
 EXTERN void delay_us(unsigned int t);
 EXTERN void delay_ms(unsigned int t);
 
-#if defined(CLIENT_MODE)&&defined(WIFI_WPAS)
+#ifdef WIFI_WPAS
 EXTERN int check_bss_encrypt(struct rtl8192cd_priv *priv);
 #endif
 
@@ -1047,6 +1113,7 @@ EXTERN void ClientSendEAPOL(struct rtl8192cd_priv *priv, struct stat_info *pstat
 #define EXTERN
 #endif
 
+EXTERN char *get_value_by_token(char *data, char *token);
 EXTERN void mp_start_test(struct rtl8192cd_priv *priv);
 EXTERN void mp_stop_test(struct rtl8192cd_priv *priv);
 EXTERN void mp_set_datarate(struct rtl8192cd_priv *priv, unsigned char *data);
@@ -1058,6 +1125,9 @@ EXTERN int mp_query_stats(struct rtl8192cd_priv *priv, unsigned char *data);
 EXTERN void mp_txpower_tracking(struct rtl8192cd_priv *priv, unsigned char *data);
 EXTERN int mp_query_tssi(struct rtl8192cd_priv *priv, unsigned char *data);
 EXTERN int mp_query_ther(struct rtl8192cd_priv *priv, unsigned char *data);
+#ifdef MP_PSD_SUPPORT
+EXTERN int mp_query_psd(struct rtl8192cd_priv *priv, unsigned char * data);
+#endif
 EXTERN int mp_tx(struct rtl8192cd_priv *priv, unsigned char *data);
 EXTERN void mp_validate_rx_packet(struct rtl8192cd_priv *priv, unsigned char *data, int len);
 EXTERN int mp_brx(struct rtl8192cd_priv *priv, unsigned char *data);
@@ -1218,33 +1288,33 @@ EXTERN int rtl_wpas_custom(struct net_device *dev, struct iw_request_info *info,
 #endif
 
 EXTERN int dump_mesh_one_mpflow_sta(int num, struct stat_info *pstat, char *buf, char **start, off_t offset, int length, int *eof, void *data);
-EXTERN int rtk8190_proc_flow_stats(char *buf, char **start, off_t offset, int length, int *eof, void *data);
-EXTERN int rtk8190_proc_flow_stats_write(struct file *file, const char *buffer, unsigned long count, void *data);
-EXTERN int rtl8190_mesh_assoc_mpinfo(char *buf, char **start, off_t offset, int length, int *eof, void *data);
+EXTERN int mesh_proc_flow_stats(char *buf, char **start, off_t offset, int length, int *eof, void *data);
+EXTERN int mesh_proc_flow_stats_write(struct file *file, const char *buffer, unsigned long count, void *data);
+EXTERN int mesh_assoc_mpinfo(char *buf, char **start, off_t offset, int length, int *eof, void *data);
 
 #ifdef MESH_BOOTSEQ_AUTH
-EXTERN int rtl8190_mesh_auth_mpinfo(char *buf, char **start, off_t offset, int length, int *eof, void *data);
+EXTERN int mesh_auth_mpinfo(char *buf, char **start, off_t offset, int length, int *eof, void *data);
 #endif
 
-EXTERN int rtl8190_mesh_unEstablish_mpinfo(char *buf, char **start, off_t offset, int length, int *eof, void *data);
-EXTERN int rtl8190_pathsel_routetable_info(char *buf, char **start, off_t offset, int length, int *eof, void *data);
-EXTERN int rtl8190_portal_table_info(char *buf, char **start, off_t offset, int length, int *eof, void *data);
-EXTERN int rtl8190_proc_mesh_stats(char *buf, char **start, off_t offset, int length, int *eof, void *data);
-EXTERN int rtl8190_proxy_table_info(char *buf, char **start, off_t offset, int length, int *eof, void *data);
-EXTERN int rtl8190_root_info(char *buf, char **start, off_t offset, int length, int *eof, void *data);
+EXTERN int mesh_unEstablish_mpinfo(char *buf, char **start, off_t offset, int length, int *eof, void *data);
+EXTERN int mesh_pathsel_routetable_info(char *buf, char **start, off_t offset, int length, int *eof, void *data);
+EXTERN int mesh_portal_table_info(char *buf, char **start, off_t offset, int length, int *eof, void *data);
+EXTERN int mesh_stats(char *buf, char **start, off_t offset, int length, int *eof, void *data);
+EXTERN int mesh_proxy_table_info(char *buf, char **start, off_t offset, int length, int *eof, void *data);
+EXTERN int mesh_root_info(char *buf, char **start, off_t offset, int length, int *eof, void *data);
 #ifdef MESH_USE_METRICOP
-EXTERN int rtl8190_mesh_metric_w (struct file *file, const char *buffer, unsigned long count, void *data);
-EXTERN int rtl8190_mesh_metric_r(char *buf, char **start, off_t offset, int length, int *eof, void *data);
+EXTERN int mesh_metric_w (struct file *file, const char *buffer, unsigned long count, void *data);
+EXTERN int mesh_metric_r(char *buf, char **start, off_t offset, int length, int *eof, void *data);
 #endif
 #if DBG_NCTU_MESH
-EXTERN int rtl8190_setMeshDebugLevel (struct file *file, const char *buffer, unsigned long count, void *data);
-EXTERN int hasMeshDebugLevel (int lv);
-EXTERN int clearMeshDebugLevel (int lv);
-EXTERN int showAllSkbs(char *buf, char **start, off_t offset, int length, int *eof, void *data);
-EXTERN int decMySkb(struct sk_buff *);
-EXTERN int tagMySkb(struct sk_buff *, UINT8);
-EXTERN int isMySkb(struct sk_buff *);
-EXTERN int showSpecificSkbs(UINT8 type);
+EXTERN int mesh_setDebugLevel (struct file *file, const char *buffer, unsigned long count, void *data);
+EXTERN int mesh_hasDebugLevel (int lv);
+EXTERN int mesh_clearDebugLevel (int lv);
+EXTERN int mesh_showAllSkbs(char *buf, char **start, off_t offset, int length, int *eof, void *data);
+EXTERN int mesh_decMySkb(struct sk_buff *);
+EXTERN int mesh_tagMySkb(struct sk_buff *, UINT8);
+EXTERN int mesh_isMySkb(struct sk_buff *);
+EXTERN int mesh_showSpecificSkbs(UINT8 type);
 #endif
 
 
@@ -1294,7 +1364,7 @@ EXTERN unsigned char* getMeshHeader(struct rtl8192cd_priv *priv, int wep_mode, u
 #endif
 
 EXTERN int process_11s_datafrme(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinfo, struct stat_info *pstat);
-EXTERN int rtl8190_rx_dispatch_mesh(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinfo);
+EXTERN int rx_dispatch_mesh(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinfo);
 #undef EXTERN
 
 
@@ -1317,7 +1387,7 @@ EXTERN int mesh_txsc_decision(struct tx_insn* cfgNew, struct tx_insn* cfgOld);
 EXTERN int dot11s_datapath_decision(struct sk_buff *skb, /*struct net_device *dev,*/ struct tx_insn* ptxinsn, int isUpdateProxyTable);
 EXTERN int issue_11s_mesh_action(struct sk_buff *skb, struct net_device *dev);
 EXTERN int notify_path_found(unsigned char *destaddr, struct rtl8192cd_priv *priv);
-EXTERN int rtl8190_start_relay_11s_dataframe(struct sk_buff *skb, /*struct net_device *dev,*/ int privacy, struct rx_frinfo *pfrinfo);
+EXTERN int relay_11s_dataframe(struct sk_buff *skb, /*struct net_device *dev,*/ int privacy, struct rx_frinfo *pfrinfo);
 EXTERN void toAllPortal(struct sk_buff *pskb,struct rtl8192cd_priv *priv);
 
 #ifdef	_11s_TEST_MODE_
@@ -1339,7 +1409,7 @@ EXTERN void signin_txdesc_galileo(struct rtl8192cd_priv *priv, struct tx_insn* t
 #else
 #define EXTERN
 #endif
-
+EXTERN int init_mesh(struct rtl8192cd_priv *priv);
 EXTERN unsigned int acl_query(struct rtl8192cd_priv *priv, unsigned char *sa);
 EXTERN int close_MeshPeerLink(struct rtl8192cd_priv *priv, UINT8 *da);
 EXTERN int is_11s_mgt_frame(int num, struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinfo);
@@ -1417,6 +1487,7 @@ EXTERN void DOT11_InitQueue2(DOT11_QUEUE2 * q, int szMaxItem, int szMaxData);
 #undef EXTERN
 
 #endif // CONFIG_RTK_MESH
+
 /*-----------------------------------------------------------------------------
 								8192cd_a4_sta.c
 ------------------------------------------------------------------------------*/
@@ -1435,5 +1506,213 @@ EXTERN struct stat_info *a4_sta_lookup(struct rtl8192cd_priv *priv, unsigned cha
 #undef EXTERN
 
 #endif
+
+
+/*-----------------------------------------------------------------------------
+								HAL_8192CDMl.c
+------------------------------------------------------------------------------*/
+#ifndef _HAL8192CDM_C_
+#define EXTERN  extern
+#else
+#define EXTERN
+#endif
+
+// DIG
+EXTERN void set_DIG_state(struct rtl8192cd_priv *priv, int state);
+EXTERN void DIG_process(struct rtl8192cd_priv *priv);
+EXTERN void check_DIG_by_rssi(struct rtl8192cd_priv *priv, unsigned char rssi_strength);
+EXTERN void DIG_for_site_survey(struct rtl8192cd_priv *priv, int do_ss);
+#ifdef INTERFERENCE_CONTROL
+EXTERN void check_NBI_by_rssi(struct rtl8192cd_priv *priv, unsigned char rssi_strength);
+#endif
+
+// Tx Power
+#ifdef HIGH_POWER_EXT_PA
+EXTERN void tx_power_control(struct rtl8192cd_priv *priv);
+#endif
+EXTERN void tx_power_tracking(struct rtl8192cd_priv *priv);
+EXTERN int get_CCK_swing_index(struct rtl8192cd_priv *priv);
+EXTERN void set_CCK_swing_index(struct rtl8192cd_priv * priv,short CCK_index);
+#ifdef CONFIG_RTL_92D_SUPPORT
+EXTERN void tx_power_tracking_92D(struct rtl8192cd_priv * priv);
+#endif
+
+// EDCA
+EXTERN void init_EDCA_para(struct rtl8192cd_priv *priv, int mode);
+EXTERN void choose_IOT_main_sta(struct rtl8192cd_priv *priv, struct stat_info *pstat);
+EXTERN void rxBB_dm(struct rtl8192cd_priv *priv);
+EXTERN void IOT_engine(struct rtl8192cd_priv *priv);
+#ifdef WIFI_WMM
+EXTERN void IOT_EDCA_switch(struct rtl8192cd_priv *priv, int mode, char enable);
+EXTERN void check_NAV_prot_len(struct rtl8192cd_priv * priv, struct stat_info * pstat, unsigned int disassoc);
+#endif
+
+// FA
+EXTERN void FA_statistic(struct rtl8192cd_priv * priv);
+#ifdef CONFIG_RTL_NEW_AUTOCH
+EXTERN void _FA_statistic(struct rtl8192cd_priv* priv);
+EXTERN void reset_FA_reg(struct rtl8192cd_priv* priv);
+EXTERN void hold_CCA_FA_counter(struct rtl8192cd_priv* priv);
+EXTERN void release_CCA_FA_counter(struct rtl8192cd_priv* priv);
+#endif
+
+// Rate Adaptive
+EXTERN void check_RA_by_rssi(struct rtl8192cd_priv *priv, struct stat_info *pstat);
+EXTERN void check_txrate_by_reg(struct rtl8192cd_priv *priv, struct stat_info *pstat);
+EXTERN void add_RATid(struct rtl8192cd_priv *priv, struct stat_info *pstat);
+EXTERN void set_RATid_cmd(struct rtl8192cd_priv * priv, unsigned int macid, unsigned int rateid, unsigned int ratemask);
+EXTERN void add_update_RATid(struct rtl8192cd_priv *priv, struct stat_info *pstat);
+EXTERN void add_update_rssi(struct rtl8192cd_priv * priv, struct stat_info * pstat);
+EXTERN void add_RATid_timer(unsigned long task_priv);
+EXTERN void add_rssi_timer(unsigned long task_priv);
+
+// EDCCA
+EXTERN void check_EDCCA(struct rtl8192cd_priv * priv, short rssi);
+
+// Antenna diversity
+#ifdef SW_ANT_SWITCH
+EXTERN void dm_SW_AntennaSwitchCallback(unsigned long task_priv) ;
+EXTERN void dm_SWAW_RSSI_Check(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinfo);
+EXTERN void dm_SW_AntennaSwitchInit(struct rtl8192cd_priv *priv);
+EXTERN void dm_SW_AntennaSwitch(struct rtl8192cd_priv *priv, char Step);
+#endif
+#if defined(SW_ANT_SWITCH) || defined(HW_ANT_SWITCH)
+EXTERN int diversity_antenna_select(struct rtl8192cd_priv *priv, unsigned char *data);
+#endif
+#if defined(HW_ANT_SWITCH)
+EXTERN void dm_HW_AntennaSwitchInit(struct rtl8192cd_priv *priv);
+EXTERN void setRxIdleAnt(struct rtl8192cd_priv *priv, char nextAnt) ;
+EXTERN void dm_STA_Ant_Select(struct rtl8192cd_priv *priv, struct stat_info *pstat);
+EXTERN void dm_HW_IdleAntennaSelect(struct rtl8192cd_priv *priv);
+#endif
+
+// Dynamic Noise Control
+#if defined(CONFIG_RTL_92D_SUPPORT) && defined(CONFIG_RTL_NOISE_CONTROL)
+EXTERN void dnc_timer(unsigned long task_priv);
+#endif
+
+// Leaving STA check
+#if defined(TXREPORT) && (defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT))
+EXTERN void DetectSTAExistance(struct rtl8192cd_priv *priv, struct tx_rpt *report, struct stat_info *pstat );
+EXTERN void RetryLimitRecovery(unsigned long task_priv);
+EXTERN void LeavingSTA_RLCheck(struct rtl8192cd_priv *priv);
+#endif
+
+
+#undef EXTERN
+
+
+// P2P_SUPPORT
+/*-----------------------------------------------------------------------------
+								8192cd_p2p.c
+------------------------------------------------------------------------------*/
+#ifdef P2P_SUPPORT
+#undef EXTERN
+#ifndef _8192CD_P2P_C_
+#define EXTERN  extern
+#else
+#define EXTERN
+#endif
+
+EXTERN void issue_probersp(struct rtl8192cd_priv *priv, unsigned char *da,
+				UINT8 *ssid, int ssid_len, int set_privacy);
+
+EXTERN unsigned char *get_ie(unsigned char *pbuf, int index, int *len, int limit);
+EXTERN int process_p2p_cmd(struct rtl8192cd_priv *priv, unsigned char *data);
+EXTERN int	P2P_on_public_action(struct rtl8192cd_priv *priv,struct rx_frinfo *pfrinfo);
+
+EXTERN void P2P_on_probe_req(
+	struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinfo, 
+	unsigned char *IEaddr, unsigned int IElen );
+
+EXTERN void p2p_init(struct rtl8192cd_priv *priv);
+
+
+EXTERN int P2P_scan(struct rtl8192cd_priv *priv, unsigned char *data);
+EXTERN void P2P_1sec_timer(struct rtl8192cd_priv *priv);
+EXTERN void P2P_listen_timer(unsigned long task_priv);	
+EXTERN void p2p_start_timer(unsigned long task_priv);
+EXTERN void p2p_search_timer(unsigned long task_priv);
+
+EXTERN int req_p2p_wsc_confirm(struct rtl8192cd_priv *priv, unsigned char *data);
+EXTERN int req_p2p_provision_req(struct rtl8192cd_priv *priv,unsigned char *data);
+
+EXTERN int p2p_get_role(struct rtl8192cd_priv *priv,unsigned char *p2p_ie ,int p2pIElen );
+EXTERN void  p2p_get_device_info(struct rtl8192cd_priv *priv, 
+	unsigned char *p2p_ie ,int p2pIElen ,struct device_info_s* devinfo_ptr);
+
+EXTERN int  p2p_get_GO_p2p_info(struct rtl8192cd_priv *priv, 
+	unsigned char *p2p_ie ,int p2pIElen ,struct device_info_s* devinfo_ptr);
+
+EXTERN void  p2p_get_GO_wsc_info(struct rtl8192cd_priv *priv, 
+	unsigned char *wsc_ie ,int wscIElen ,struct device_info_s *devinfo_ptr);
+
+
+EXTERN int p2p_build_beacon_ie(struct rtl8192cd_priv *priv, unsigned char *data);
+
+EXTERN void P2P_on_assoc_req(struct rtl8192cd_priv *priv,
+	unsigned char *IEaddr, unsigned int IElen ,unsigned char *sa);
+EXTERN int p2pcmd_apply(struct rtl8192cd_priv *priv, unsigned char *data);
+EXTERN void P2P_client_on_beacon(struct rtl8192cd_priv *priv,
+	unsigned char *IEaddr, unsigned int IElen, int seq);
+EXTERN void p2p_noa_timer(struct rtl8192cd_priv *priv);
+EXTERN int P2P_on_action(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinfo);
+EXTERN void p2p_client_remove(struct rtl8192cd_priv *priv , struct stat_info *pstat );
+EXTERN int p2p_build_assocRsp_ie(struct rtl8192cd_priv *priv, unsigned char *data
+		,unsigned char status);
+EXTERN void P2P_on_assoc_rsp(struct rtl8192cd_priv *priv,unsigned char *sa);
+EXTERN int P2P_filter_manage_ap(struct rtl8192cd_priv *priv,
+		unsigned char *IEaddr, unsigned int IElen );
+EXTERN void p2p_debug_out(unsigned char *label, unsigned char *data, int data_length);
+#endif
+
+
+
+
+#ifdef CONFIG_RTL_88E_SUPPORT
+#define EXTERN  extern
+
+
+/*-----------------------------------------------------------------------------
+								HalPwrSeqCmd.c
+------------------------------------------------------------------------------*/
+EXTERN unsigned int HalPwrSeqCmdParsing(struct rtl8192cd_priv *priv, unsigned char CutVersion, 
+				unsigned char FabVersion, unsigned char InterfaceType, WLAN_PWR_CFG PwrSeqCmd[ ]);
+
+
+
+
+/*-----------------------------------------------------------------------------
+								8188e_hw.c
+------------------------------------------------------------------------------*/
+EXTERN void RTL8188E_MACID_NOLINK(struct rtl8192cd_priv * priv, unsigned int nolink, unsigned int aid);
+EXTERN void RTL8188E_MACID_PAUSE(struct rtl8192cd_priv * priv, unsigned int pause, unsigned int aid);
+
+#ifdef SUPPORT_RTL8188E_TC
+EXTERN void check_RTL8188E_testChip(struct rtl8192cd_priv * priv);
+#endif
+
+#ifdef TXREPORT
+EXTERN void RTL8188E_EnableTxReport(struct rtl8192cd_priv *priv);
+EXTERN void RTL8188E_DisableTxReport(struct rtl8192cd_priv *priv);
+EXTERN void RTL8188E_ResumeTxReport(struct rtl8192cd_priv *priv);
+EXTERN void RTL8188E_SuspendTxReport(struct rtl8192cd_priv *priv);
+EXTERN void RTL8188E_AssignTxReportMacId(struct rtl8192cd_priv *priv);
+EXTERN void RTL8188E_TxReportHandler(struct rtl8192cd_priv *priv, struct sk_buff *pskb, unsigned int bitmapLowByte,
+	unsigned int bitmapHighByte, struct rx_desc *pdesc);
+EXTERN void RTL8188E_SetTxReportTimeByRA(struct rtl8192cd_priv *priv, int extend);
+EXTERN void PHY_IQCalibrate_8188E(struct rtl8192cd_priv *priv, char bReCovery);
+
+/*-----------------------------------------------------------------------------
+								RateAdaptive.c
+------------------------------------------------------------------------------*/
+EXTERN int RateAdaptiveInfoInit(PSTATION_RA_INFO  pRaInfo);
+EXTERN int ARFBRefresh(struct rtl8192cd_priv *priv, PSTATION_RA_INFO  pRaInfo);
+EXTERN void RateDecision(struct rtl8192cd_priv *priv, PSTATION_RA_INFO  pRaInfo);
+#endif
+
+
+#undef EXTERN
+#endif
 #endif // _8192CD_HEADERS_H_
 
diff --git a/drivers/net/wireless/rtl8192cd/8192cd_hw.c b/drivers/net/wireless/rtl8192cd/8192cd_hw.c
index 25bbe31..0146e47 100644
--- a/drivers/net/wireless/rtl8192cd/8192cd_hw.c
+++ b/drivers/net/wireless/rtl8192cd/8192cd_hw.c
@@ -29,6 +29,9 @@
 #include "./8192cd_hw.h"
 #include "./8192cd_headers.h"
 #include "./8192cd_debug.h"
+#ifdef CONFIG_RTL_88E_SUPPORT
+#include "Hal8188EPwrSeq.h"
+#endif
 
 #ifdef __KERNEL__
 #ifdef __LINUX_2_6__
@@ -39,17 +42,17 @@
 #endif
 
 #ifdef USE_RTL8186_SDK
-#ifdef CONFIG_RTL8672
-	#include <platform.h>
-#else
+//#ifdef CONFIG_RTL8672
+//	#include <platform.h>
+//#else
 #if defined(__LINUX_2_6__)
 #include <bsp/bspchip.h>
 #else
 	#include <asm/rtl865x/platform.h>
 #endif
-#endif
+//#endif
 
-#if defined(__LINUX_2_6__) && !defined(CONFIG_RTL8672)
+#if defined(__LINUX_2_6__) //&& !defined(CONFIG_RTL8672)
 #define _WDTCNR_			BSP_WDTCNR
 #else
 #define _WDTCNR_			WDTCNR
@@ -76,210 +79,6 @@ static int Load_92C_Firmware(struct rtl8192cd_priv *priv);
 #endif
 
 
-static unsigned int OFDMSwingTable[] = {
-	0x7f8001fe, // 0, +6.0dB
-	0x788001e2, // 1, +5.5dB
-	0x71c001c7, // 2, +5.0dB
-	0x6b8001ae, // 3, +4.5dB
-	0x65400195, // 4, +4.0dB
-	0x5fc0017f, // 5, +3.5dB
-	0x5a400169, // 6, +3.0dB
-	0x55400155, // 7, +2.5dB
-	0x50800142, // 8, +2.0dB
-	0x4c000130, // 9, +1.5dB
-	0x47c0011f, // 10, +1.0dB
-	0x43c0010f, // 11, +0.5dB
-	0x40000100, // 12, +0dB
-	0x3c8000f2, // 13, -0.5dB
-	0x390000e4, // 14, -1.0dB
-	0x35c000d7, // 15, -1.5dB
-	0x32c000cb, // 16, -2.0dB
-	0x300000c0, // 17, -2.5dB
-	0x2d4000b5, // 18, -3.0dB
-	0x2ac000ab, // 19, -3.5dB
-	0x288000a2, // 20, -4.0dB
-	0x26000098, // 21, -4.5dB
-	0x24000090, // 22, -5.0dB
-	0x22000088, // 23, -5.5dB
-	0x20000080, // 24, -6.0dB
-	0x1e400079, // 25, -6.5dB
-	0x1c800072, // 26, -7.0dB
-	0x1b00006c, // 27. -7.5dB
-	0x19800066, // 28, -8.0dB
-	0x18000060, // 29, -8.5dB
-	0x16c0005b, // 30, -9.0dB
-	0x15800056, // 31, -9.5dB
-	0x14400051, // 32, -10.0dB
-	0x1300004c, // 33, -10.5dB
-	0x12000048, // 34, -11.0dB
-	0x11000044, // 35, -11.5dB
-	0x10000040, // 36, -12.0dB
-};
-
-unsigned int TxPwrTrk_OFDM_SwingTbl[TxPwrTrk_OFDM_SwingTbl_Len] = {
-	/*  +6.0dB */ 0x7f8001fe,
-	/*  +5.5dB */ 0x788001e2,
-	/*  +5.0dB */ 0x71c001c7,
-	/*  +4.5dB */ 0x6b8001ae,
-	/*  +4.0dB */ 0x65400195,
-	/*  +3.5dB */ 0x5fc0017f,
-	/*  +3.0dB */ 0x5a400169,
-	/*  +2.5dB */ 0x55400155,
-	/*  +2.0dB */ 0x50800142,
-	/*  +1.5dB */ 0x4c000130,
-	/*  +1.0dB */ 0x47c0011f,
-	/*  +0.5dB */ 0x43c0010f,
-	/*   0.0dB */ 0x40000100,
-	/*  -0.5dB */ 0x3c8000f2,
-	/*  -1.0dB */ 0x390000e4,
-	/*  -1.5dB */ 0x35c000d7,
-	/*  -2.0dB */ 0x32c000cb,
-	/*  -2.5dB */ 0x300000c0,
-	/*  -3.0dB */ 0x2d4000b5,
-	/*  -3.5dB */ 0x2ac000ab,
-	/*  -4.0dB */ 0x288000a2,
-	/*  -4.5dB */ 0x26000098,
-	/*  -5.0dB */ 0x24000090,
-	/*  -5.5dB */ 0x22000088,
-	/*  -6.0dB */ 0x20000080,
-	/*  -6.5dB */ 0x1a00006c,
-	/*  -7.0dB */ 0x1c800072,
-	/*  -7.5dB */ 0x18000060,
-	/*  -8.0dB */ 0x19800066,
-	/*  -8.5dB */ 0x15800056,
-	/*  -9.0dB */ 0x26c0005b,
-	/*  -9.5dB */ 0x14400051,
-	/* -10.0dB */ 0x24400051,
-	/* -10.5dB */ 0x1300004c,
-	/* -11.0dB */ 0x12000048,
-	/* -11.5dB */ 0x11000044,
-	/* -12.0dB */ 0x10000040
-};
-
-unsigned char TxPwrTrk_CCK_SwingTbl[TxPwrTrk_CCK_SwingTbl_Len][8] = {
-	/*   0.0dB */ {0x36, 0x35, 0x2e, 0x25, 0x1c, 0x12, 0x09, 0x04},
-	/*   0.5dB */ {0x33, 0x32, 0x2b, 0x23, 0x1a, 0x11, 0x08, 0x04},
-	/*   1.0dB */ {0x30, 0x2f, 0x29, 0x21, 0x19, 0x10, 0x08, 0x03},
-	/*   1.5dB */ {0x2d, 0x2d, 0x27, 0x1f, 0x18, 0x0f, 0x08, 0x03},
-	/*   2.0dB */ {0x2b, 0x2a, 0x25, 0x1e, 0x16, 0x0e, 0x07, 0x03},
-	/*   2.5dB */ {0x28, 0x28, 0x22, 0x1c, 0x15, 0x0d, 0x07, 0x03},
-	/*   3.0dB */ {0x26, 0x25, 0x21, 0x1b, 0x14, 0x0d, 0x06, 0x03},
-	/*   3.5dB */ {0x24, 0x23, 0x1f, 0x19, 0x13, 0x0c, 0x06, 0x03},
-	/*   4.0dB */ {0x22, 0x21, 0x1d, 0x18, 0x11, 0x0b, 0x06, 0x02},
-	/*   4.5dB */ {0x20, 0x20, 0x1b, 0x16, 0x11, 0x08, 0x05, 0x02},
-	/*   5.0dB */ {0x1f, 0x1e, 0x1a, 0x15, 0x10, 0x0a, 0x05, 0x02},
-	/*   5.5dB */ {0x1d, 0x1c, 0x18, 0x14, 0x0f, 0x0a, 0x05, 0x02},
-	/*   6.0dB */ {0x1b, 0x1a, 0x17, 0x13, 0x0e, 0x09, 0x04, 0x02},
-	/*   6.5dB */ {0x1a, 0x19, 0x16, 0x12, 0x0d, 0x09, 0x04, 0x02},
-	/*   7.0dB */ {0x18, 0x17, 0x15, 0x11, 0x0c, 0x08, 0x04, 0x02},
-	/*   7.5dB */ {0x17, 0x16, 0x13, 0x10, 0x0c, 0x08, 0x04, 0x02},
-	/*   8.0dB */ {0x16, 0x15, 0x12, 0x0f, 0x0b, 0x07, 0x04, 0x01},
-	/*   8.5dB */ {0x14, 0x14, 0x11, 0x0e, 0x0b, 0x07, 0x03, 0x02},
-	/*   9.0dB */ {0x13, 0x13, 0x10, 0x0d, 0x0a, 0x06, 0x03, 0x01},
-	/*   9.5dB */ {0x12, 0x12, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},
-	/*  10.0dB */ {0x11, 0x11, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},
-	/*  10.5dB */ {0x10, 0x10, 0x0e, 0x0b, 0x08, 0x05, 0x03, 0x01},
-	/*  11.0dB */ {0x0f, 0x0f, 0x0d, 0x0b, 0x08, 0x05, 0x03, 0x01}
-};
-
-unsigned char TxPwrTrk_CCK_SwingTbl_CH14[TxPwrTrk_CCK_SwingTbl_Len][8] = {
-	/*   0.0dB */ {0x36, 0x35, 0x2e, 0x1b, 0x00, 0x00, 0x00, 0x00},
-	/*   0.5dB */ {0x33, 0x32, 0x2b, 0x19, 0x00, 0x00, 0x00, 0x00},
-	/*   1.0dB */ {0x30, 0x2f, 0x29, 0x18, 0x00, 0x00, 0x00, 0x00},
-	/*   1.5dB */ {0x2d, 0x2d, 0x27, 0x17, 0x00, 0x00, 0x00, 0x00},
-	/*   2.0dB */ {0x2b, 0x2a, 0x25, 0x15, 0x00, 0x00, 0x00, 0x00},
-	/*   2.5dB */ {0x28, 0x28, 0x22, 0x14, 0x00, 0x00, 0x00, 0x00},
-	/*   3.0dB */ {0x26, 0x25, 0x21, 0x13, 0x00, 0x00, 0x00, 0x00},
-	/*   3.5dB */ {0x24, 0x23, 0x1f, 0x12, 0x00, 0x00, 0x00, 0x00},
-	/*   4.0dB */ {0x22, 0x21, 0x1d, 0x11, 0x00, 0x00, 0x00, 0x00},
-	/*   4.5dB */ {0x20, 0x20, 0x1b, 0x10, 0x00, 0x00, 0x00, 0x00},
-	/*   5.0dB */ {0x1f, 0x1e, 0x1a, 0x0f, 0x00, 0x00, 0x00, 0x00},
-	/*   5.5dB */ {0x1d, 0x1c, 0x18, 0x0e, 0x00, 0x00, 0x00, 0x00},
-	/*   6.0dB */ {0x1b, 0x1a, 0x17, 0x0e, 0x00, 0x00, 0x00, 0x00},
-	/*   6.5dB */ {0x1a, 0x19, 0x16, 0x0d, 0x00, 0x00, 0x00, 0x00},
-	/*   7.0dB */ {0x18, 0x17, 0x15, 0x0c, 0x00, 0x00, 0x00, 0x00},
-	/*   7.5dB */ {0x17, 0x16, 0x13, 0x0b, 0x00, 0x00, 0x00, 0x00},
-	/*   8.0dB */ {0x16, 0x15, 0x12, 0x0b, 0x00, 0x00, 0x00, 0x00},
-	/*   8.5dB */ {0x14, 0x14, 0x11, 0x0a, 0x00, 0x00, 0x00, 0x00},
-	/*   9.0dB */ {0x13, 0x13, 0x10, 0x0a, 0x00, 0x00, 0x00, 0x00},
-	/*   9.5dB */ {0x12, 0x12, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},
-	/*  10.0dB */ {0x11, 0x11, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},
-	/*  10.5dB */ {0x10, 0x10, 0x0e, 0x08, 0x00, 0x00, 0x00, 0x00},
-	/*  11.0dB */ {0x0f, 0x0f, 0x0d, 0x08, 0x00, 0x00, 0x00, 0x00}
-};
-
-static unsigned char CCKSwingTable_Ch1_Ch13[][8] = {
-{0x36, 0x35, 0x2e, 0x25, 0x1c, 0x12, 0x09, 0x04},	// 0, +0dB
-{0x33, 0x32, 0x2b, 0x23, 0x1a, 0x11, 0x08, 0x04},	// 1, -0.5dB
-{0x30, 0x2f, 0x29, 0x21, 0x19, 0x10, 0x08, 0x03},	// 2, -1.0dB
-{0x2d, 0x2d, 0x27, 0x1f, 0x18, 0x0f, 0x08, 0x03},	// 3, -1.5dB
-{0x2b, 0x2a, 0x25, 0x1e, 0x16, 0x0e, 0x07, 0x03},	// 4, -2.0dB
-{0x28, 0x28, 0x22, 0x1c, 0x15, 0x0d, 0x07, 0x03},	// 5, -2.5dB
-{0x26, 0x25, 0x21, 0x1b, 0x14, 0x0d, 0x06, 0x03},	// 6, -3.0dB
-{0x24, 0x23, 0x1f, 0x19, 0x13, 0x0c, 0x06, 0x03},	// 7, -3.5dB
-{0x22, 0x21, 0x1d, 0x18, 0x11, 0x0b, 0x06, 0x02},	// 8, -4.0dB
-{0x20, 0x20, 0x1b, 0x16, 0x11, 0x08, 0x05, 0x02},	// 9, -4.5dB
-{0x1f, 0x1e, 0x1a, 0x15, 0x10, 0x0a, 0x05, 0x02},	// 10, -5.0dB
-{0x1d, 0x1c, 0x18, 0x14, 0x0f, 0x0a, 0x05, 0x02},	// 11, -5.5dB
-{0x1b, 0x1a, 0x17, 0x13, 0x0e, 0x09, 0x04, 0x02},	// 12, -6.0dB
-{0x1a, 0x19, 0x16, 0x12, 0x0d, 0x09, 0x04, 0x02},	// 13, -6.5dB
-{0x18, 0x17, 0x15, 0x11, 0x0c, 0x08, 0x04, 0x02},	// 14, -7.0dB
-{0x17, 0x16, 0x13, 0x10, 0x0c, 0x08, 0x04, 0x02},	// 15, -7.5dB
-{0x16, 0x15, 0x12, 0x0f, 0x0b, 0x07, 0x04, 0x01},	// 16, -8.0dB
-{0x14, 0x14, 0x11, 0x0e, 0x0b, 0x07, 0x03, 0x02},	// 17, -8.5dB
-{0x13, 0x13, 0x10, 0x0d, 0x0a, 0x06, 0x03, 0x01},	// 18, -9.0dB
-{0x12, 0x12, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},	// 19, -9.5dB
-{0x11, 0x11, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},	// 20, -10.0dB
-{0x10, 0x10, 0x0e, 0x0b, 0x08, 0x05, 0x03, 0x01},	// 21, -10.5dB
-{0x0f, 0x0f, 0x0d, 0x0b, 0x08, 0x05, 0x03, 0x01},	// 22, -11.0dB
-{0x0e, 0x0e, 0x0c, 0x0a, 0x08, 0x05, 0x02, 0x01},	// 23, -11.5dB
-{0x0d, 0x0d, 0x0c, 0x0a, 0x07, 0x05, 0x02, 0x01},	// 24, -12.0dB
-{0x0d, 0x0c, 0x0b, 0x09, 0x07, 0x04, 0x02, 0x01},	// 25, -12.5dB
-{0x0c, 0x0c, 0x0a, 0x09, 0x06, 0x04, 0x02, 0x01},	// 26, -13.0dB
-{0x0b, 0x0b, 0x0a, 0x08, 0x06, 0x04, 0x02, 0x01},	// 27, -13.5dB
-{0x0b, 0x0a, 0x09, 0x08, 0x06, 0x04, 0x02, 0x01},	// 28, -14.0dB
-{0x0a, 0x0a, 0x09, 0x07, 0x05, 0x03, 0x02, 0x01},	// 29, -14.5dB
-{0x0a, 0x09, 0x08, 0x07, 0x05, 0x03, 0x02, 0x01},	// 30, -15.0dB
-{0x09, 0x09, 0x08, 0x06, 0x05, 0x03, 0x01, 0x01},	// 31, -15.5dB
-{0x09, 0x08, 0x07, 0x06, 0x04, 0x03, 0x01, 0x01}	// 32, -16.0dB
-};
-
-static unsigned char CCKSwingTable_Ch14 [][8]= {
-{0x36, 0x35, 0x2e, 0x1b, 0x00, 0x00, 0x00, 0x00},	// 0, +0dB
-{0x33, 0x32, 0x2b, 0x19, 0x00, 0x00, 0x00, 0x00},	// 1, -0.5dB
-{0x30, 0x2f, 0x29, 0x18, 0x00, 0x00, 0x00, 0x00},	// 2, -1.0dB
-{0x2d, 0x2d, 0x17, 0x17, 0x00, 0x00, 0x00, 0x00},	// 3, -1.5dB
-{0x2b, 0x2a, 0x25, 0x15, 0x00, 0x00, 0x00, 0x00},	// 4, -2.0dB
-{0x28, 0x28, 0x24, 0x14, 0x00, 0x00, 0x00, 0x00},	// 5, -2.5dB
-{0x26, 0x25, 0x21, 0x13, 0x00, 0x00, 0x00, 0x00},	// 6, -3.0dB
-{0x24, 0x23, 0x1f, 0x12, 0x00, 0x00, 0x00, 0x00},	// 7, -3.5dB
-{0x22, 0x21, 0x1d, 0x11, 0x00, 0x00, 0x00, 0x00},	// 8, -4.0dB
-{0x20, 0x20, 0x1b, 0x10, 0x00, 0x00, 0x00, 0x00},	// 9, -4.5dB
-{0x1f, 0x1e, 0x1a, 0x0f, 0x00, 0x00, 0x00, 0x00},	// 10, -5.0dB
-{0x1d, 0x1c, 0x18, 0x0e, 0x00, 0x00, 0x00, 0x00},	// 11, -5.5dB
-{0x1b, 0x1a, 0x17, 0x0e, 0x00, 0x00, 0x00, 0x00},	// 12, -6.0dB
-{0x1a, 0x19, 0x16, 0x0d, 0x00, 0x00, 0x00, 0x00},	// 13, -6.5dB
-{0x18, 0x17, 0x15, 0x0c, 0x00, 0x00, 0x00, 0x00},	// 14, -7.0dB
-{0x17, 0x16, 0x13, 0x0b, 0x00, 0x00, 0x00, 0x00},	// 15, -7.5dB
-{0x16, 0x15, 0x12, 0x0b, 0x00, 0x00, 0x00, 0x00},	// 16, -8.0dB
-{0x14, 0x14, 0x11, 0x0a, 0x00, 0x00, 0x00, 0x00},	// 17, -8.5dB
-{0x13, 0x13, 0x10, 0x0a, 0x00, 0x00, 0x00, 0x00},	// 18, -9.0dB
-{0x12, 0x12, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},	// 19, -9.5dB
-{0x11, 0x11, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},	// 20, -10.0dB
-{0x10, 0x10, 0x0e, 0x08, 0x00, 0x00, 0x00, 0x00},	// 21, -10.5dB
-{0x0f, 0x0f, 0x0d, 0x08, 0x00, 0x00, 0x00, 0x00},	// 22, -11.0dB
-{0x0e, 0x0e, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},	// 23, -11.5dB
-{0x0d, 0x0d, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},	// 24, -12.0dB
-{0x0d, 0x0c, 0x0b, 0x06, 0x00, 0x00, 0x00, 0x00},	// 25, -12.5dB
-{0x0c, 0x0c, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},	// 26, -13.0dB
-{0x0b, 0x0b, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},	// 27, -13.5dB
-{0x0b, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},	// 28, -14.0dB
-{0x0a, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},	// 29, -14.5dB
-{0x0a, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},	// 30, -15.0dB
-{0x09, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},	// 31, -15.5dB
-{0x09, 0x08, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00}	// 32, -16.0dB
-};
-
 #ifdef ADD_TX_POWER_BY_CMD
 #define ASSIGN_TX_POWER_OFFSET(offset, setting) { \
 	if (setting != 0x7f) \
@@ -287,14 +86,6 @@ static unsigned char CCKSwingTable_Ch14 [][8]= {
 }
 #endif
 
-#define POWER_MIN_CHECK(a,b)            (((a) > (b)) ? (b) : (a))
-#define POWER_RANGE_CHECK(val)		(((val) > 0x3f)? 0x3f : ((val < 0) ? 0 : val))
-#define COUNT_SIGN_OFFSET(val, oft)	(((oft & 0x08) == 0x08)? (val - (0x10 - oft)) : (val + oft))
-
-#ifdef HW_ANT_SWITCH
-#define RXDVY_A_EN		((priv->pshare->rf_ft_var.antHw_enable && !priv->pshare->rf_ft_var.antSw_select) ? 0x80 : 0)
-#define RXDVY_B_EN		((priv->pshare->rf_ft_var.antHw_enable &&  priv->pshare->rf_ft_var.antSw_select) ? 0x80 : 0)
-#endif
 
 #ifdef MERGE_FW
 #define VAR_MAPPING(dst,src) \
@@ -310,17 +101,37 @@ unsigned char *data_##dst##_end   = &data_##src[sizeof(data_##src)]; \
 #include "data_radio_b_n.c"
 #ifdef RTL8192D_INT_PA
 #ifdef USB_POWER_SUPPORT
+
+#if defined (RTL8192D_INT_PA_GAIN_TABLE_NEW)
+#include "data_radio_a_intPA_GM_new.c"
+#include "data_radio_b_intPA_GM_new.c"
+#elif defined (RTL8192D_INT_PA_GAIN_TABLE_NEW1)
+#include "data_radio_a_intPA_GM_new1.c"
+#include "data_radio_b_intPA_GM_new1.c"
+#else
 #include "data_radio_a_intPA_GM.c"
 #include "data_radio_b_intPA_GM.c"
+#endif
+
+#else //USB_POWER_SUPPORT
+
+#if defined (RTL8192D_INT_PA_GAIN_TABLE_NEW)
+#include "data_radio_a_intPA_new.c"
+#include "data_radio_b_intPA_new.c"
 #else
 #include "data_radio_a_intPA.c"
 #include "data_radio_b_intPA.c"
 #endif
-#endif
+
+#endif //USB_POWER_SUPPORT
+#endif //RTL8192D_INT_PA
 //_TXPWR_REDEFINE
 #ifdef HIGH_POWER_EXT_PA
+#include "data_AGC_TAB_n_92d_hp.c"
+#include "data_PHY_REG_n_92d_hp.c"
 #include "data_radio_a_n_92d_hp.c"
 #include "data_radio_b_n_92d_hp.c"
+#include "data_PHY_REG_PG_92d_hp.c"
 #endif
 #include "data_PHY_REG_PG.c"
 #include "data_PHY_REG_PG_FCC.c"
@@ -330,6 +141,10 @@ unsigned char *data_##dst##_end   = &data_##src[sizeof(data_##src)]; \
 #include "data_TXPWR_LMT_FCC.c"
 #include "data_TXPWR_LMT_CE.c"
 #endif
+#ifdef _TRACKING_TABLE_FILE
+#include "data_REG_TXPWR_TRK_n_92d.c"
+#include "data_REG_TXPWR_TRK_n_92d_hp.c"
+#endif
 #include "data_PHY_REG_MP_n.c"
 #include "data_MACPHY_REG.c"
 #include "data_rtl8192dfw_n.c"
@@ -341,17 +156,37 @@ VAR_MAPPING(radio_a_n, radio_a_n);
 VAR_MAPPING(radio_b_n, radio_b_n);
 #ifdef RTL8192D_INT_PA
 #ifdef USB_POWER_SUPPORT
+
+#if defined (RTL8192D_INT_PA_GAIN_TABLE_NEW)
+VAR_MAPPING(radio_a_intPA_GM_new, radio_a_intPA_GM_new);
+VAR_MAPPING(radio_b_intPA_GM_new, radio_b_intPA_GM_new);
+#elif defined (RTL8192D_INT_PA_GAIN_TABLE_NEW1)
+VAR_MAPPING(radio_a_intPA_GM_new1, radio_a_intPA_GM_new1);
+VAR_MAPPING(radio_b_intPA_GM_new1, radio_b_intPA_GM_new1);
+#else
 VAR_MAPPING(radio_a_intPA_GM, radio_a_intPA_GM);
 VAR_MAPPING(radio_b_intPA_GM, radio_b_intPA_GM);
+#endif
+
+#else //USB_POWER_SUPPORT
+
+#if defined (RTL8192D_INT_PA_GAIN_TABLE_NEW)
+VAR_MAPPING(radio_a_intPA_new, radio_a_intPA_new);
+VAR_MAPPING(radio_b_intPA_new, radio_b_intPA_new);
 #else
 VAR_MAPPING(radio_a_intPA, radio_a_intPA);
 VAR_MAPPING(radio_b_intPA, radio_b_intPA);
 #endif
-#endif
+
+#endif //USB_POWER_SUPPORT
+#endif //RTL8192D_INT_PA
 //_TXPWR_REDEFINE
 #ifdef HIGH_POWER_EXT_PA
+VAR_MAPPING(AGC_TAB_n_92d_hp, AGC_TAB_n_92d_hp);
+VAR_MAPPING(PHY_REG_n_92d_hp, PHY_REG_n_92d_hp);
 VAR_MAPPING(radio_a_n_92d_hp, radio_a_n_92d_hp);
 VAR_MAPPING(radio_b_n_92d_hp, radio_b_n_92d_hp);
+VAR_MAPPING(PHY_REG_PG_92d_hp, PHY_REG_PG_92d_hp);
 #endif
 VAR_MAPPING(PHY_REG_PG, PHY_REG_PG);
 VAR_MAPPING(PHY_REG_PG_FCC, PHY_REG_PG_FCC);
@@ -361,6 +196,10 @@ VAR_MAPPING(TXPWR_LMT, TXPWR_LMT);
 VAR_MAPPING(TXPWR_LMT_FCC, TXPWR_LMT_FCC);
 VAR_MAPPING(TXPWR_LMT_CE, TXPWR_LMT_CE);
 #endif
+#ifdef _TRACKING_TABLE_FILE
+VAR_MAPPING(REG_TXPWR_TRK_n_92d, REG_TXPWR_TRK_n_92d);
+VAR_MAPPING(REG_TXPWR_TRK_n_92d_hp, REG_TXPWR_TRK_n_92d_hp);
+#endif
 VAR_MAPPING(PHY_REG_MP_n, PHY_REG_MP_n);
 VAR_MAPPING(MACPHY_REG, MACPHY_REG);
 VAR_MAPPING(rtl8192dfw_n, rtl8192dfw_n);
@@ -405,6 +244,11 @@ VAR_MAPPING(rtl8192dfw_n, rtl8192dfw_n);
 #include "data_PHY_REG_PG_hp.c"
 #endif
 
+#ifdef _TRACKING_TABLE_FILE
+#include "data_REG_TXPWR_TRK.c"
+#include "data_REG_TXPWR_TRK_hp.c"
+#endif
+
 
 #define VAR_MAPPING(dst,src) \
 	unsigned char *data_##dst##_start = &data_##src[0]; \
@@ -444,7 +288,29 @@ VAR_MAPPING(radio_a_2T_n_hp, radio_a_2T_n_hp);
 VAR_MAPPING(radio_b_2T_n_hp, radio_b_2T_n_hp);
 VAR_MAPPING(PHY_REG_PG_hp, PHY_REG_PG_hp);
 #endif
+
+#ifdef _TRACKING_TABLE_FILE
+VAR_MAPPING(REG_TXPWR_TRK, REG_TXPWR_TRK);
+VAR_MAPPING(REG_TXPWR_TRK_hp, REG_TXPWR_TRK_hp);
+#endif
+
 #endif //CONFIG_RTL_92C_SUPPORT
+
+#ifdef CONFIG_RTL_88E_SUPPORT
+#include "data_AGC_TAB_1T_88E.c"
+#include "data_MAC_REG_88E.c"
+#include "data_PHY_REG_PG_88E.c"
+#include "data_PHY_REG_1T_88E.c"
+#include "data_PHY_REG_MP_88E.c"
+#include "data_radio_a_1T_88E.c"
+
+VAR_MAPPING(AGC_TAB_1T_88E, AGC_TAB_1T_88E);
+VAR_MAPPING(MAC_REG_88E, MAC_REG_88E);
+VAR_MAPPING(PHY_REG_1T_88E, PHY_REG_1T_88E);
+VAR_MAPPING(PHY_REG_PG_88E, PHY_REG_PG_88E);
+VAR_MAPPING(PHY_REG_MP_88E, PHY_REG_MP_88E);
+VAR_MAPPING(radio_a_1T_88E, radio_a_1T_88E);
+#endif //CONFIG_RTL_88E_SUPPORT
 #endif
 
 
@@ -652,7 +518,12 @@ void phy_RFSerialWrite(struct rtl8192cd_priv *priv, RF92CD_RADIO_PATH_E eRFPath,
 	BB_REGISTER_DEFINITION_T	*pPhyReg = &phw->PHYRegDef[eRFPath];
 	unsigned int				NewOffset;
 
-	Offset &= 0x7f;
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv) == VERSION_8188E)
+		Offset &= 0xff;
+	else
+#endif
+		Offset &= 0x7f;
 	//
 	// Switch page for 8256 RF IC
 	//
@@ -700,7 +571,12 @@ unsigned int phy_RFSerialRead(struct rtl8192cd_priv *priv, RF92CD_RADIO_PATH_E e
 	//
 	// Make sure RF register offset is correct
 	//
-	Offset &= 0x7f;
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv) == VERSION_8188E)
+		Offset &= 0xff;
+	else
+#endif
+		Offset &= 0x7f;
 
 	//
 	// Switch page for 8256 RF IC
@@ -719,9 +595,23 @@ unsigned int phy_RFSerialRead(struct rtl8192cd_priv *priv, RF92CD_RADIO_PATH_E e
 	delay_us(20);
 	RTL_W32(pPhyReg->rfHSSIPara2,tmplong2);
 	delay_us(20);
-	RTL_W32(rFPGA0_XA_HSSIParameter2,tmplong|bLSSIReadEdge);
-	delay_us(20);
-	RTL_W32(rFPGA0_XA_HSSIParameter2,tmplong&(~bLSSIReadEdge));
+#if defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT)
+	if (
+#ifdef CONFIG_RTL_92C_SUPPORT
+		(GET_CHIP_VER(priv)==VERSION_8192C) || (GET_CHIP_VER(priv)==VERSION_8188C) 
+#endif
+#ifdef CONFIG_RTL_92D_SUPPORT
+#ifdef CONFIG_RTL_92C_SUPPORT
+		|| 
+#endif
+		(GET_CHIP_VER(priv)==VERSION_8192D)
+#endif
+		) {
+		RTL_W32(rFPGA0_XA_HSSIParameter2,tmplong|bLSSIReadEdge);
+		delay_us(20);
+		RTL_W32(rFPGA0_XA_HSSIParameter2,tmplong&(~bLSSIReadEdge));
+	}
+#endif
 
 	//Read from BBreg8a0, 12 bits for 8190, 20 bits for T65 RF
 	if (((eRFPath == RF92CD_PATH_A) && (RTL_R32(0x820)&BIT(8)))
@@ -1217,7 +1107,7 @@ int PHY_ConfigTXLmtWithParaFile(struct rtl8192cd_priv *priv)
 	unsigned int  ch_start, ch_end, limit, target;
 	unsigned char *mem_ptr, *line_head, *next_head;
 	int	idx=0, tbl_idx[6], set_en=0, type;
-
+	
 	priv->pshare->txpwr_lmt_CCK = 0;
 	priv->pshare->txpwr_lmt_OFDM = 0;
 	priv->pshare->txpwr_lmt_HT1S = 0;
@@ -1419,174 +1309,549 @@ set_fs(old_fs);
 
 #endif
 
-//_TXPWR_REDEFINE
-void Read_PG_File(struct rtl8192cd_priv *priv, int reg_file, int table_number, 
-				char *MCSTxAgcOffset_A, char *MCSTxAgcOffset_B, char *OFDMTxAgcOffset_A,
-				char *OFDMTxAgcOffset_B, char *CCKTxAgc_A, char *CCKTxAgc_B)
-{
-	int                read_bytes=0, num, len=0;
-	unsigned int       u4bRegOffset, u4bRegValue, u4bRegMask;
-	unsigned char      *mem_ptr, *line_head, *next_head=NULL;
-	struct PhyRegTable *phyreg_table=NULL;
-	struct MacRegTable *macreg_table=NULL;
-	unsigned short     max_len=0;
-	int                file_format=TWO_COLUMN;
-#ifndef MERGE_FW
-	int                fd=0;
-	mm_segment_t       old_fs;
-	unsigned char      *pFileName=NULL;
-	extern ssize_t     sys_read(unsigned int fd, char * buf, size_t count);
-#endif
 
-#ifdef CONFIG_RTL_92D_SUPPORT
-	int				idx=0, pg_tbl_idx=table_number, write_en=0;
-#endif
+#ifdef _TRACKING_TABLE_FILE
 
-	int tmp_rTxAGC_A_CCK1_Mcs32= 0;
-	int tmp_rTxAGC_B_CCK5_1_Mcs32 = 0;
-	int prev_reg = 0;
 
-	//printk("PHYREG_PG = %d\n", PHYREG_PG);
+#ifndef TXPWR_LMT
 
-#ifdef MERGE_FW
+int _convert_2_pwr_tracking(char *s, int base)
+{
+	int k = 0;
 
-	if (reg_file == PHYREG_PG) {
-		//printk("[%s][PHY_REG_PG]\n",__FUNCTION__);
-		
-#ifdef CONFIG_RTL_92D_SUPPORT
-		if (GET_CHIP_VER(priv) == VERSION_8192D){
+	k = 0;
+	if (base == 10) {
+		while (*s >= '0' && *s <= '9') {
+			k = 10 * k + (*s - '0');
+			s++;
+		}
+	}
+	else
+		return 0;
 
-			if(priv->pmib->dot11StationConfigEntry.dot11RegDomain == DOMAIN_FCC){
-				//printk("\nFCC PG!!!\n");
-				next_head = data_PHY_REG_PG_FCC_start;
-				read_bytes = (int)(data_PHY_REG_PG_FCC_end - data_PHY_REG_PG_FCC_start);
-			}
-			else if(priv->pmib->dot11StationConfigEntry.dot11RegDomain == DOMAIN_ETSI){
-				//printk("\nCE PG!!!\n");
-				next_head = data_PHY_REG_PG_CE_start;
-				read_bytes = (int)(data_PHY_REG_PG_CE_end - data_PHY_REG_PG_CE_start);
-			}
-			else{
-				//printk("\nOTHER PG!!!\n");
-				next_head = data_PHY_REG_PG_start;
-				read_bytes = (int)(data_PHY_REG_PG_end - data_PHY_REG_PG_start);
-			}
+	return k;
+}
 
-		}
-#endif //CONFIG_RTL_92D_SUPPORT
 
-#ifdef CONFIG_RTL_92C_SUPPORT
-		if ((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)){
-#ifdef HIGH_POWER_EXT_PA
-			if( priv->pshare->rf_ft_var.use_ext_pa) {
-				//printk("[%s][data_PHY_REG_PG_hp]\n", __FUNCTION__);
-				next_head = data_PHY_REG_PG_hp_start;
-				read_bytes = (int)(data_PHY_REG_PG_hp_end - data_PHY_REG_PG_hp_start);
+static unsigned char *get_digit_tracking(unsigned char **data)
+{
+	unsigned char *buf=*data;
+	int i=0;
+	
+	*data = &buf[i];
 
-			} else
-#endif
-			{
-				//printk("[%s][data_PHY_REG_PG_92C]\n", __FUNCTION__);
-				next_head = data_PHY_REG_PG_92C_start;
-				read_bytes = (int)(data_PHY_REG_PG_92C_end - data_PHY_REG_PG_92C_start);
-			}
+	while(1)
+	{
+		if((buf[i] == '\n') || (buf[i] == '\r'))
+		{
+			return NULL;
 		}
-#endif //CONFIG_RTL_92C_SUPPORT
-		macreg_table = (struct MacRegTable *)priv->pshare->phy_reg_pg_buf;
-		max_len = PHY_REG_PG_SIZE;
-		file_format = THREE_COLUMN;
-	}
 
-#ifdef CONFIG_RTL_92D_SUPPORT
-	else if (reg_file == PHYREG) {
-		if (GET_CHIP_VER(priv)==VERSION_8192D) {
-			phyreg_table = (struct PhyRegTable *)priv->pshare->phy_reg_buf;
-			//printk("[%s][PHY_REG_n]\n",__FUNCTION__);
-			next_head = data_PHY_REG_n_start;
-			read_bytes = (int)(data_PHY_REG_n_end - data_PHY_REG_n_start);
-			max_len = PHY_REG_SIZE;
-		}
+		if((buf[i] == ' ') || (buf[i] == '\t'))
+			break;
+
+		i++;
 	}
-#endif // CONFIG_RTL_92D_SUPPORT
 
-#ifdef MP_TEST
-	else if (reg_file == PHYREG_MP) {
-#ifdef CONFIG_RTL_92D_SUPPORT
-		if (GET_CHIP_VER(priv)==VERSION_8192D) {
-			phyreg_table = (struct PhyRegTable *)priv->pshare->phy_reg_mp_buf;
-			//printk("[%s][PHY_REG_MP_n]\n",__FUNCTION__);
-			next_head = data_PHY_REG_MP_n_start;
-			read_bytes = (int)(data_PHY_REG_MP_n_end - data_PHY_REG_MP_n_start);
-			max_len = PHY_REG_SIZE;
+	while(1) 
+	{		
+
+		if((buf[i] == '\n') || (buf[i] == '\r'))
+		{
+			return NULL;
 		}
-#endif
-#ifdef CONFIG_RTL_92C_SUPPORT
-		if ((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)){
-			phyreg_table = (struct PhyRegTable *)priv->pshare->phy_reg_mp_buf;
-			next_head = data_PHY_REG_MP_n_92C_start;
-			read_bytes = (int)(data_PHY_REG_MP_n_92C_end - data_PHY_REG_MP_n_92C_start);
-			max_len = PHY_REG_SIZE;
+
+		if((buf[i]>= '0') && (buf[i] <= '9'))
+		{
+			//printk("found buf[i] = %c \n", buf[i]);
+			return &buf[i];
 		}
-#endif
+
+		i++;
 	}
+	
+}
+
 #endif
 
-#else	// !MERGE_FW
 
-	switch (reg_file) {
-	case PHYREG_PG:
-		pFileName = "/usr/rtl8192Pci/PHY_REG_PG.txt";
-		macreg_table = (struct MacRegTable *)priv->pshare->phy_reg_pg_buf;
-		max_len = PHY_REG_PG_SIZE;
-		file_format = THREE_COLUMN;
-		break;
+void input_tracking_value(struct rtl8192cd_priv *priv, int offset, int num, int value)
+{
+
+	switch (offset) {
+		case CCKA_P:
+		case CCKA_N:
+		case CCKB_P:
+		case CCKB_N:
+			offset = (offset%4);
+			priv->pshare->txpwr_tracking_2G_CCK[offset][num] = value;
+			break;
+		case A_P:
+		case A_N:
+		case B_P:
+		case B_N:
+			offset = (offset%4);
+			priv->pshare->txpwr_tracking_2G_OFDM[offset][num] = value;
+			break;
+		case LA_P:
+		case LA_N:
+		case LB_P:
+		case LB_N:
+			offset = (offset%4);
+			priv->pshare->txpwr_tracking_5GL[offset][num] = value;
+			break;
+		case MA_P:
+		case MA_N:
+		case MB_P:
+		case MB_N:
+			offset = (offset%4);
+			priv->pshare->txpwr_tracking_5GM[offset][num] = value;
+			break;
+		case HA_P:
+		case HA_N:
+		case HB_P:
+		case HB_N:
+			offset = (offset%4);
+			priv->pshare->txpwr_tracking_5GH[offset][num] = value;
+			break;
+	default:
+			break;
+
 	}
-#endif // MERGE_FW
 
+
+}
+
+
+
+static int get_tracking_table(struct rtl8192cd_priv *priv, unsigned char *line_head)
+{
+	unsigned char *next, *next2;
+	int base, idx;
+	int num=0;
+	int offset = 0;
+	unsigned char *swim;
+	extern int _atoi(char *s, int base);
+
+	// remove comments
+	swim = line_head+1;
+	
+	for(offset=0; offset<TXPWR_TRACKING_NAME_NUM; offset++)
 	{
-		if((mem_ptr = (unsigned char *)kmalloc(MAX_CONFIG_FILE_SIZE, GFP_ATOMIC)) == NULL) {
-			printk("PHY_ConfigBBWithParaFile(): not enough memory\n");
-			return -1;
-		}
+		if(!memcmp(line_head, TXPWR_TRACKING_NAME[offset], strlen(TXPWR_TRACKING_NAME[offset])))
+			break;
+	}
 
-		memset(mem_ptr, 0, MAX_CONFIG_FILE_SIZE); // clear memory
+	if(offset >= TXPWR_TRACKING_NAME_NUM)
+		return offset;
 
-#ifdef MERGE_FW
-		memcpy(mem_ptr, next_head, read_bytes);
-#else
+	//printk("_Eric offset = %d \n", offset);
+	//printk("_Eric line_head = %s \n", line_head);
 
-		old_fs = get_fs();
-		set_fs(KERNEL_DS);
+	next = get_digit_tracking(&swim);
 
-		if ((fd = sys_open(pFileName, O_RDONLY, 0)) < 0) {
-			printk("PHY_ConfigBBWithParaFile(): cannot open %s\n", pFileName);
-			set_fs(old_fs);
-			kfree(mem_ptr);
-			return -1;
+	while(1)
+	{
+		
+		if (next == NULL)
+			break;
+		
+		if (next) 
+		{
+			
+			base = 10;
+			idx = 0;
+			
+			//printk("num#%d = %d \n", num, _convert_2_pwr_tracking((char *)&next[idx], base));
+			input_tracking_value(priv, offset, num, _convert_2_pwr_tracking((char *)&next[idx], base));
+
+			num++;
 		}
+		else
+			break;
 
-		read_bytes = sys_read(fd, mem_ptr, MAX_CONFIG_FILE_SIZE);
-		sys_close(fd);
-		set_fs(old_fs);
-#endif // MERGE_FW
+		if(num >= index_mapping_NUM_MAX)
+			break;
 
-		next_head = mem_ptr;
-		while (1) {
-			line_head = next_head;
-			next_head = get_line(&line_head);
-			if (line_head == NULL)
-				break;
+		next = get_digit_tracking(&next);
 
-			if (line_head[0] == '/')
-				continue;
+	}
 
-			if (file_format == TWO_COLUMN) {
+
+	return offset;
+	
+}
+
+
+void check_tracking_table(struct rtl8192cd_priv *priv)
+{
+
+	int tmp = 0;
+	int tmp2 = 0;
+
+	for(tmp = 0; tmp<4; tmp++)
+	{
+		for(tmp2 = 1; tmp2<index_mapping_NUM_MAX; tmp2 ++)
+		{
+			if(priv->pshare->txpwr_tracking_2G_CCK[tmp][tmp2] < priv->pshare->txpwr_tracking_2G_CCK[tmp][tmp2-1])
+				priv->pshare->txpwr_tracking_2G_CCK[tmp][tmp2] = priv->pshare->txpwr_tracking_2G_CCK[tmp][tmp2-1];
+		}
+	}
+
+	for(tmp = 0; tmp<4; tmp++)
+	{
+		for(tmp2 = 1; tmp2<index_mapping_NUM_MAX; tmp2 ++)
+		{
+			if(priv->pshare->txpwr_tracking_2G_OFDM[tmp][tmp2] < priv->pshare->txpwr_tracking_2G_OFDM[tmp][tmp2-1])
+				priv->pshare->txpwr_tracking_2G_OFDM[tmp][tmp2] = priv->pshare->txpwr_tracking_2G_OFDM[tmp][tmp2-1];
+		}
+	}
+
+	for(tmp = 0; tmp<4; tmp++)
+	{
+		for(tmp2 = 1; tmp2<index_mapping_NUM_MAX; tmp2 ++)
+		{
+			if(priv->pshare->txpwr_tracking_5GL[tmp][tmp2] < priv->pshare->txpwr_tracking_5GL[tmp][tmp2-1])
+				priv->pshare->txpwr_tracking_5GL[tmp][tmp2] = priv->pshare->txpwr_tracking_5GL[tmp][tmp2-1];
+		}
+	}
+
+	for(tmp = 0; tmp<4; tmp++)
+	{
+		for(tmp2 = 1; tmp2<index_mapping_NUM_MAX; tmp2 ++)
+		{
+			if(priv->pshare->txpwr_tracking_5GM[tmp][tmp2] < priv->pshare->txpwr_tracking_5GM[tmp][tmp2-1])
+				priv->pshare->txpwr_tracking_5GM[tmp][tmp2] = priv->pshare->txpwr_tracking_5GM[tmp][tmp2-1];
+		}
+	}
+
+	for(tmp = 0; tmp<4; tmp++)
+	{
+		for(tmp2 = 1; tmp2<index_mapping_NUM_MAX; tmp2 ++)
+		{
+			if(priv->pshare->txpwr_tracking_5GH[tmp][tmp2] < priv->pshare->txpwr_tracking_5GH[tmp][tmp2-1])
+				priv->pshare->txpwr_tracking_5GH[tmp][tmp2] = priv->pshare->txpwr_tracking_5GH[tmp][tmp2-1];
+		}
+	}
+
+}
+
+int PHY_ConfigTXPwrTrackingWithParaFile(struct rtl8192cd_priv *priv)
+{
+	int read_bytes, num, len=0;
+	unsigned int  ch_start, ch_end, limit, target;
+	unsigned char *mem_ptr, *line_head, *next_head;
+	int	idx=0, tbl_idx[6], set_en=0, type;
+
+	memset(priv->pshare->txpwr_tracking_2G_CCK, 0, (4*index_mapping_NUM_MAX));
+	memset(priv->pshare->txpwr_tracking_2G_OFDM, 0, (4*index_mapping_NUM_MAX));
+	memset(priv->pshare->txpwr_tracking_5GL, 0, (4*index_mapping_NUM_MAX));
+	memset(priv->pshare->txpwr_tracking_5GM, 0, (4*index_mapping_NUM_MAX));
+	memset(priv->pshare->txpwr_tracking_5GH, 0, (4*index_mapping_NUM_MAX));
+
+	if((mem_ptr = (unsigned char *)kmalloc(MAX_CONFIG_FILE_SIZE, GFP_ATOMIC)) == NULL) {
+		printk("PHY_ConfigMACWithParaFile(): not enough memory\n");
+		return -1;
+	}
+
+	memset(mem_ptr, 0, MAX_CONFIG_FILE_SIZE); // clear memory
+
+
+	if((GET_CHIP_VER(priv)== VERSION_8188C) || (GET_CHIP_VER(priv)== VERSION_8192C)) //_Eric_?? any other IC types ??
+	{
+#ifdef HIGH_POWER_EXT_PA
+		printk("[%s][REG_TXPWR_TRK_hp]\n",__FUNCTION__);
+		next_head = data_REG_TXPWR_TRK_hp_start;
+		read_bytes = (int)(data_REG_TXPWR_TRK_hp_end - data_REG_TXPWR_TRK_hp_start);
+#else
+		printk("[%s][REG_TXPWR_TRK]\n",__FUNCTION__);
+		next_head = data_REG_TXPWR_TRK_start;
+		read_bytes = (int)(data_REG_TXPWR_TRK_end - data_REG_TXPWR_TRK_start);
+#endif
+	}
+	else if(GET_CHIP_VER(priv)== VERSION_8192D)
+	{
+#ifdef HIGH_POWER_EXT_PA
+		printk("[%s][REG_TXPWR_TRK_n_92d_hp]\n",__FUNCTION__);
+		next_head = data_REG_TXPWR_TRK_n_92d_hp_start;
+		read_bytes = (int)(data_REG_TXPWR_TRK_n_92d_hp_end - data_REG_TXPWR_TRK_n_92d_hp_start);
+#else
+		printk("[%s][REG_TXPWR_TRK_n_92d]\n",__FUNCTION__);
+		next_head = data_REG_TXPWR_TRK_n_92d_start;
+		read_bytes = (int)(data_REG_TXPWR_TRK_n_92d_end - data_REG_TXPWR_TRK_n_92d_start);
+#endif
+	}
+	else
+	{
+		printk("[%s][NOT SUPPORT]\n",__FUNCTION__);
+		return -1;
+	}
+
+	memcpy(mem_ptr, next_head, read_bytes);
+
+	next_head = mem_ptr;
+	
+	while (1) {
+		line_head = next_head;
+		next_head = get_line(&line_head);
+
+		if (line_head == NULL)
+			break;
+
+		if (line_head[0] == '/')
+			continue;
+
+		num = get_tracking_table(priv, line_head);
+
+	}
+
+	check_tracking_table(priv); 
+
+#if 0
+
+{
+	int tmp = 0;
+	int tmp2 = 0;
+
+	for(tmp = 0; tmp<4; tmp++)
+	{
+		printk("txpwr_tracking_2G_CCK #%d = ", tmp);
+		for(tmp2 = 0; tmp2<index_mapping_NUM_MAX; tmp2 ++)
+		{
+			printk("%d ", priv->pshare->txpwr_tracking_2G_CCK[tmp][tmp2]); 
+		}
+		printk("\n");
+	}
+
+	for(tmp = 0; tmp<4; tmp++)
+	{
+		printk("txpwr_tracking_2G_OFDM #%d = ", tmp);
+		for(tmp2 = 0; tmp2<index_mapping_NUM_MAX; tmp2 ++)
+		{
+			printk("%d ", priv->pshare->txpwr_tracking_2G_OFDM[tmp][tmp2]); 
+		}
+		printk("\n");
+	}
+
+	for(tmp = 0; tmp<4; tmp++)
+	{
+		printk("txpwr_tracking_5GL #%d = ", tmp);
+		for(tmp2 = 0; tmp2<index_mapping_NUM_MAX; tmp2 ++)
+		{
+			printk("%d ", priv->pshare->txpwr_tracking_5GL[tmp][tmp2]); 
+		}
+		printk("\n");
+	}
+
+	for(tmp = 0; tmp<4; tmp++)
+	{
+		printk("txpwr_tracking_5GM #%d = ", tmp);
+		for(tmp2 = 0; tmp2<index_mapping_NUM_MAX; tmp2 ++)
+		{
+			printk("%d ", priv->pshare->txpwr_tracking_5GM[tmp][tmp2]); 
+		}
+		printk("\n");
+	}
+
+	for(tmp = 0; tmp<4; tmp++)
+	{
+		printk("txpwr_tracking_5GH #%d = ", tmp);
+		for(tmp2 = 0; tmp2<index_mapping_NUM_MAX; tmp2 ++)
+		{
+			printk("%d ", priv->pshare->txpwr_tracking_5GH[tmp][tmp2]); 
+		}
+		printk("\n");
+	}
+
+}
+
+#endif
+
+	kfree(mem_ptr);
+
+	return 0;
+}
+#endif
+
+
+#ifdef _DEBUG_RTL8192CD_
+
+//_TXPWR_REDEFINE
+void Read_PG_File(struct rtl8192cd_priv *priv, int reg_file, int table_number, 
+				char *MCSTxAgcOffset_A, char *MCSTxAgcOffset_B, char *OFDMTxAgcOffset_A,
+				char *OFDMTxAgcOffset_B, char *CCKTxAgc_A, char *CCKTxAgc_B)
+{
+	int                read_bytes=0, num, len=0;
+	unsigned int       u4bRegOffset, u4bRegValue, u4bRegMask;
+	unsigned char      *mem_ptr, *line_head, *next_head=NULL;
+	struct PhyRegTable *phyreg_table=NULL;
+	struct MacRegTable *macreg_table=NULL;
+	unsigned short     max_len=0;
+	int                file_format=TWO_COLUMN;
+#ifndef MERGE_FW
+	int                fd=0;
+	mm_segment_t       old_fs;
+	unsigned char      *pFileName=NULL;
+	extern ssize_t     sys_read(unsigned int fd, char * buf, size_t count);
+#endif
+
+#ifdef CONFIG_RTL_92D_SUPPORT
+	int				idx=0, pg_tbl_idx=table_number, write_en=0;
+#endif
+
+	int tmp_rTxAGC_A_CCK1_Mcs32= 0;
+	int tmp_rTxAGC_B_CCK5_1_Mcs32 = 0;
+	int prev_reg = 0;
+
+	//printk("PHYREG_PG = %d\n", PHYREG_PG);
+
+#ifdef MERGE_FW
+
+	if (reg_file == PHYREG_PG) {
+		//printk("[%s][PHY_REG_PG]\n",__FUNCTION__);
+		
+#ifdef CONFIG_RTL_92D_SUPPORT
+		if (GET_CHIP_VER(priv) == VERSION_8192D){
+
+			if(priv->pmib->dot11StationConfigEntry.dot11RegDomain == DOMAIN_FCC){
+				//printk("\nFCC PG!!!\n");
+				next_head = data_PHY_REG_PG_FCC_start;
+				read_bytes = (int)(data_PHY_REG_PG_FCC_end - data_PHY_REG_PG_FCC_start);
+			}
+			else if(priv->pmib->dot11StationConfigEntry.dot11RegDomain == DOMAIN_ETSI){
+				//printk("\nCE PG!!!\n");
+				next_head = data_PHY_REG_PG_CE_start;
+				read_bytes = (int)(data_PHY_REG_PG_CE_end - data_PHY_REG_PG_CE_start);
+			}
+			else{
+				//printk("\nOTHER PG!!!\n");
+				next_head = data_PHY_REG_PG_start;
+				read_bytes = (int)(data_PHY_REG_PG_end - data_PHY_REG_PG_start);
+			}
+
+#ifdef HIGH_POWER_EXT_PA
+			if( priv->pshare->rf_ft_var.use_ext_pa) {
+				//printk("[%s][data_PHY_REG_PG_92d_hp]\n", __FUNCTION__);
+				next_head = data_PHY_REG_PG_92d_hp_start;
+				read_bytes = (int)(data_PHY_REG_PG_92d_hp_end - data_PHY_REG_PG_92d_hp_start);
+			}
+#endif
+
+		}
+#endif //CONFIG_RTL_92D_SUPPORT
+
+#ifdef CONFIG_RTL_92C_SUPPORT
+		if ((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)){
+#ifdef HIGH_POWER_EXT_PA
+			if( priv->pshare->rf_ft_var.use_ext_pa) {
+				//printk("[%s][data_PHY_REG_PG_hp]\n", __FUNCTION__);
+				next_head = data_PHY_REG_PG_hp_start;
+				read_bytes = (int)(data_PHY_REG_PG_hp_end - data_PHY_REG_PG_hp_start);
+
+			} else
+#endif
+			{
+				//printk("[%s][data_PHY_REG_PG_92C]\n", __FUNCTION__);
+				next_head = data_PHY_REG_PG_92C_start;
+				read_bytes = (int)(data_PHY_REG_PG_92C_end - data_PHY_REG_PG_92C_start);
+			}
+		}
+#endif //CONFIG_RTL_92C_SUPPORT
+		macreg_table = (struct MacRegTable *)priv->pshare->phy_reg_pg_buf;
+		max_len = PHY_REG_PG_SIZE;
+		file_format = THREE_COLUMN;
+	}
+
+#ifdef CONFIG_RTL_92D_SUPPORT
+	else if (reg_file == PHYREG) {
+		if (GET_CHIP_VER(priv)==VERSION_8192D) {
+			phyreg_table = (struct PhyRegTable *)priv->pshare->phy_reg_buf;
+			//printk("[%s][PHY_REG_n]\n",__FUNCTION__);
+			next_head = data_PHY_REG_n_start;
+			read_bytes = (int)(data_PHY_REG_n_end - data_PHY_REG_n_start);
+			max_len = PHY_REG_SIZE;
+		}
+	}
+#endif // CONFIG_RTL_92D_SUPPORT
+
+#ifdef MP_TEST
+	else if (reg_file == PHYREG_MP) {
+#ifdef CONFIG_RTL_92D_SUPPORT
+		if (GET_CHIP_VER(priv)==VERSION_8192D) {
+			phyreg_table = (struct PhyRegTable *)priv->pshare->phy_reg_mp_buf;
+			//printk("[%s][PHY_REG_MP_n]\n",__FUNCTION__);
+			next_head = data_PHY_REG_MP_n_start;
+			read_bytes = (int)(data_PHY_REG_MP_n_end - data_PHY_REG_MP_n_start);
+			max_len = PHY_REG_SIZE;
+		}
+#endif
+#ifdef CONFIG_RTL_92C_SUPPORT
+		if ((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)){
+			phyreg_table = (struct PhyRegTable *)priv->pshare->phy_reg_mp_buf;
+			next_head = data_PHY_REG_MP_n_92C_start;
+			read_bytes = (int)(data_PHY_REG_MP_n_92C_end - data_PHY_REG_MP_n_92C_start);
+			max_len = PHY_REG_SIZE;
+		}
+#endif
+	}
+#endif
+
+#else	// !MERGE_FW
+
+	switch (reg_file) {
+	case PHYREG_PG:
+		pFileName = "/usr/rtl8192Pci/PHY_REG_PG.txt";
+		macreg_table = (struct MacRegTable *)priv->pshare->phy_reg_pg_buf;
+		max_len = PHY_REG_PG_SIZE;
+		file_format = THREE_COLUMN;
+		break;
+	}
+#endif // MERGE_FW
+
+	{
+		if((mem_ptr = (unsigned char *)kmalloc(MAX_CONFIG_FILE_SIZE, GFP_ATOMIC)) == NULL) {
+			printk("PHY_ConfigBBWithParaFile(): not enough memory\n");
+			return -1;
+		}
+
+		memset(mem_ptr, 0, MAX_CONFIG_FILE_SIZE); // clear memory
+
+#ifdef MERGE_FW
+		memcpy(mem_ptr, next_head, read_bytes);
+#else
+
+		old_fs = get_fs();
+		set_fs(KERNEL_DS);
+
+		if ((fd = sys_open(pFileName, O_RDONLY, 0)) < 0) {
+			printk("PHY_ConfigBBWithParaFile(): cannot open %s\n", pFileName);
+			set_fs(old_fs);
+			kfree(mem_ptr);
+			return -1;
+		}
+
+		read_bytes = sys_read(fd, mem_ptr, MAX_CONFIG_FILE_SIZE);
+		sys_close(fd);
+		set_fs(old_fs);
+#endif // MERGE_FW
+
+		next_head = mem_ptr;
+		while (1) {
+			line_head = next_head;
+			next_head = get_line(&line_head);
+			if (line_head == NULL)
+				break;
+
+			if (line_head[0] == '/')
+				continue;
+
+			if (file_format == TWO_COLUMN) {
 				num = get_offset_val(line_head, &u4bRegOffset, &u4bRegValue);
 				if (num > 0) {
 					phyreg_table[len].offset = u4bRegOffset;
 					phyreg_table[len].value = u4bRegValue;
 					len++;
-#if defined(CONFIG_RTL_8198) && defined(CONFIG_RTL_92D_SUPPORT)
+#if (defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)) && defined(CONFIG_RTL_92D_SUPPORT)
 					//if ((len&0x7ff)==0)
 						//REG32(BSP_WDTCNR) |=  1 << 23;
 #endif
@@ -1607,7 +1872,7 @@ void Read_PG_File(struct rtl8192cd_priv *priv, int reg_file, int table_number,
 						break;
 					if ((len * sizeof(struct MacRegTable)) > max_len)
 						break;
-#if defined(CONFIG_RTL_8198) && defined(CONFIG_RTL_92D_SUPPORT)
+#if (defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)) && defined(CONFIG_RTL_92D_SUPPORT)
 					//if ((len&0x7ff)==0)
 						//REG32(BSP_WDTCNR) |=  1 << 23;
 #endif
@@ -1746,7 +2011,7 @@ void Read_PG_File(struct rtl8192cd_priv *priv, int reg_file, int table_number,
 	return 0;
 }
 
-
+#endif
 
 /*-----------------------------------------------------------------------------
  * Function:    PHY_ConfigBBWithParaFile()
@@ -1778,7 +2043,7 @@ int PHY_ConfigBBWithParaFile(struct rtl8192cd_priv *priv, int reg_file)
 	extern ssize_t     sys_read(unsigned int fd, char * buf, size_t count);
 #endif
 
-#ifdef CONFIG_RTL_92D_SUPPORT
+#if defined(CONFIG_RTL_92D_SUPPORT) || defined(CONFIG_RTL_88E_SUPPORT)
 	int				idx=0, pg_tbl_idx=BGN_2040_ALL, write_en=0;
 #endif
 
@@ -1787,6 +2052,20 @@ int PHY_ConfigBBWithParaFile(struct rtl8192cd_priv *priv, int reg_file)
 		phyreg_table = (struct PhyRegTable *)priv->pshare->agc_tab_buf;
 #ifdef CONFIG_RTL_92D_SUPPORT
 		if (GET_CHIP_VER(priv)==VERSION_8192D) {
+#ifdef HIGH_POWER_EXT_PA //_eric_?? DMDP & SMSP ??
+				if(priv->pshare->rf_ft_var.use_ext_pa)
+				{
+					//printk("[%s][AGC_TAB_n_92d_hp]\n",__FUNCTION__);
+					next_head = data_AGC_TAB_n_92d_hp_start;
+					read_bytes = (int)(data_AGC_TAB_n_92d_hp_end - data_AGC_TAB_n_92d_hp_start);
+				}
+				else
+				{
+					//printk("[%s][AGC_TAB_n]\n",__FUNCTION__);
+					next_head = data_AGC_TAB_n_start;
+					read_bytes = (int)(data_AGC_TAB_n_end - data_AGC_TAB_n_start);
+				}
+#else //HIGH_POWER_EXT_PA
 #ifdef CONFIG_RTL_92D_DMDP
 			if (priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY && priv->pshare->wlandev_idx==1) {
 				if (priv->pmib->dot11RFEntry.phyBandSelect & PHY_BAND_5G) {
@@ -1805,6 +2084,7 @@ int PHY_ConfigBBWithParaFile(struct rtl8192cd_priv *priv, int reg_file)
 				next_head = data_AGC_TAB_n_start;
 				read_bytes = (int)(data_AGC_TAB_n_end - data_AGC_TAB_n_start);
 			}
+#endif //HIGH_POWER_EXT_PA
 		}
 #endif //CONFIG_RTL_92D_SUPPORT
 
@@ -1831,6 +2111,15 @@ int PHY_ConfigBBWithParaFile(struct rtl8192cd_priv *priv, int reg_file)
 			}
 		}
 #endif
+
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv) == VERSION_8188E) {
+			DEBUG_INFO("[%s][AGC_TAB_1T_88E]\n",__FUNCTION__);
+			next_head = data_AGC_TAB_1T_88E_start;
+			read_bytes = (int)(data_AGC_TAB_1T_88E_end - data_AGC_TAB_1T_88E_start);
+		}
+#endif
+
 		max_len = AGC_TAB_SIZE;
 	}
 	else if (reg_file == PHYREG_PG) {
@@ -1854,6 +2143,14 @@ int PHY_ConfigBBWithParaFile(struct rtl8192cd_priv *priv, int reg_file)
 			read_bytes = (int)(data_PHY_REG_PG_end - data_PHY_REG_PG_start);
 			}
 
+#ifdef HIGH_POWER_EXT_PA
+			if( priv->pshare->rf_ft_var.use_ext_pa) {
+				//printk("[%s][data_PHY_REG_PG_92d_hp]\n", __FUNCTION__);
+				next_head = data_PHY_REG_PG_92d_hp_start;
+				read_bytes = (int)(data_PHY_REG_PG_92d_hp_end - data_PHY_REG_PG_92d_hp_start);
+			}
+#endif
+
 //_TXPWR_REDEFINE ?? Why 5G no need working channel ??
 //_TXPWR_REDEFINE in MP Tool, 3 Groups: 36-99 100-148 149-165 
 			if (priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_5G){
@@ -1908,7 +2205,7 @@ int PHY_ConfigBBWithParaFile(struct rtl8192cd_priv *priv, int reg_file)
 
 			//In Noraml Driver mode, and if mib 'pwr_by_rate' = 0 >> Use default power by rate table 
 			if( (priv->pshare->rf_ft_var.mp_specific == 0) && (priv->pshare->rf_ft_var.pwr_by_rate == 0) )
-				pg_tbl_idx = BGN_2040_ALL;
+				pg_tbl_idx=BGN_2040_ALL;
 
 			DEBUG_INFO("channel=%d pg_tbl_idx=%d\n",priv->pmib->dot11RFEntry.dot11channel, pg_tbl_idx);
 
@@ -1932,6 +2229,50 @@ int PHY_ConfigBBWithParaFile(struct rtl8192cd_priv *priv, int reg_file)
 			}
 		}
 #endif //CONFIG_RTL_92C_SUPPORT
+
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv) == VERSION_8188E) {
+#ifdef SUPPORT_RTL8188E_TC
+			if (IS_TEST_CHIP(priv))
+				return 0;
+#endif
+			DEBUG_INFO("[%s][PHY_REG_PG_88E]\n",__FUNCTION__);
+			next_head = data_PHY_REG_PG_88E_start;
+			read_bytes = (int)(data_PHY_REG_PG_88E_end - data_PHY_REG_PG_88E_start);
+
+			/* In Noraml Driver mode, and if mib 'pwr_by_rate' = 0 >> Use default power by rate table  */
+			if (priv->pshare->rf_ft_var.mp_specific || priv->pshare->rf_ft_var.pwr_by_rate) {
+				if (priv->pshare->is_40m_bw == 0) {
+					if (priv->pmib->dot11RFEntry.dot11channel<=3)
+						pg_tbl_idx = BGN_20_CH1_3;
+					else if (priv->pmib->dot11RFEntry.dot11channel<=9)
+						pg_tbl_idx = BGN_20_CH4_9;
+					else
+						pg_tbl_idx = BGN_20_CH10_14;
+				} else {
+					int val = priv->pmib->dot11RFEntry.dot11channel;
+					
+					if (priv->pshare->offset_2nd_chan == 1)
+						val -= 2;
+					else
+						val += 2;
+
+					if (val<=3)
+						pg_tbl_idx = BGN_40_CH1_3;
+					else if (val<=9)
+						pg_tbl_idx = BGN_40_CH4_9;
+					else
+						pg_tbl_idx = BGN_40_CH10_14;
+				}
+			}
+
+			if(priv->pshare->rf_ft_var.mp_specific)
+				pg_tbl_idx = 0;
+
+			DEBUG_INFO("channel=%d pg_tbl_idx=%d\n",priv->pmib->dot11RFEntry.dot11channel, pg_tbl_idx);
+		}
+#endif
+
 		macreg_table = (struct MacRegTable *)priv->pshare->phy_reg_pg_buf;
 		max_len = PHY_REG_PG_SIZE;
 		file_format = THREE_COLUMN;
@@ -1955,9 +2296,15 @@ int PHY_ConfigBBWithParaFile(struct rtl8192cd_priv *priv, int reg_file)
 	else if (reg_file == PHYREG) {
 		if (GET_CHIP_VER(priv)==VERSION_8192D) {
 			phyreg_table = (struct PhyRegTable *)priv->pshare->phy_reg_buf;
+#ifdef HIGH_POWER_EXT_PA
+			//printk("[%s][PHY_REG_n_92d_hp]\n",__FUNCTION__);
+			next_head = data_PHY_REG_n_92d_hp_start;
+			read_bytes = (int)(data_PHY_REG_n_92d_hp_end - data_PHY_REG_n_92d_hp_start);
+#else
 			//printk("[%s][PHY_REG_n]\n",__FUNCTION__);
 			next_head = data_PHY_REG_n_start;
 			read_bytes = (int)(data_PHY_REG_n_end - data_PHY_REG_n_start);
+#endif
 			max_len = PHY_REG_SIZE;
 		}
 	}
@@ -1982,34 +2329,52 @@ int PHY_ConfigBBWithParaFile(struct rtl8192cd_priv *priv, int reg_file)
 			max_len = PHY_REG_SIZE;
 		}
 #endif
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv) == VERSION_8188E){
+			phyreg_table = (struct PhyRegTable *)priv->pshare->phy_reg_mp_buf;
+			next_head = data_PHY_REG_MP_88E_start;
+			read_bytes = (int)(data_PHY_REG_MP_88E_end - data_PHY_REG_MP_88E_start);
+			max_len = PHY_REG_SIZE;
+		}
+#endif
 	}
 #endif
-#ifdef CONFIG_RTL_92C_SUPPORT
+#if defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_88E_SUPPORT)
 	else if (reg_file == PHYREG_1T1R) { // PATH A
 		phyreg_table = (struct PhyRegTable *)priv->pshare->phy_reg_buf;
+#ifdef CONFIG_RTL_92C_SUPPORT
+		if ((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)) {
 #ifdef TESTCHIP_SUPPORT
-		if( IS_TEST_CHIP(priv) ) {
-			next_head = data_PHY_REG_1T_start;
-			read_bytes = (int)(data_PHY_REG_1T_end - data_PHY_REG_1T_start);
-		} else
+			if( IS_TEST_CHIP(priv) ) {
+				next_head = data_PHY_REG_1T_start;
+				read_bytes = (int)(data_PHY_REG_1T_end - data_PHY_REG_1T_start);
+			} else
 #endif
-		{
+			{
 
-			if (priv->pshare->rf_ft_var.use_ext_lna
+				if (priv->pshare->rf_ft_var.use_ext_lna
 #ifdef HIGH_POWER_EXT_PA
-			|| priv->pshare->rf_ft_var.use_ext_pa
+				|| priv->pshare->rf_ft_var.use_ext_pa
 #endif
-			) {
-				//printk("[%s][PHY_REG_1T_n_hp]\n", __FUNCTION__);
-				next_head = data_PHY_REG_1T_n_hp_start;
-				read_bytes = (int)(data_PHY_REG_1T_n_hp_end - data_PHY_REG_1T_n_hp_start);
-			}
-			else {
-				//printk("[%s][PHY_REG_1T_n]\n", __FUNCTION__);
-				next_head = data_PHY_REG_1T_n_start;
-				read_bytes = (int)(data_PHY_REG_1T_n_end - data_PHY_REG_1T_n_start);
+				) {
+					//printk("[%s][PHY_REG_1T_n_hp]\n", __FUNCTION__);
+					next_head = data_PHY_REG_1T_n_hp_start;
+					read_bytes = (int)(data_PHY_REG_1T_n_hp_end - data_PHY_REG_1T_n_hp_start);
+				} else {
+					//printk("[%s][PHY_REG_1T_n]\n", __FUNCTION__);
+					next_head = data_PHY_REG_1T_n_start;
+					read_bytes = (int)(data_PHY_REG_1T_n_end - data_PHY_REG_1T_n_start);
+				}
 			}
 		}
+#endif
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv) == VERSION_8188E) {
+			DEBUG_INFO("[%s][PHY_REG_1T_88E]\n",__FUNCTION__);
+			next_head = data_PHY_REG_1T_88E_start;
+			read_bytes = (int)(data_PHY_REG_1T_88E_end - data_PHY_REG_1T_88E_start);
+		}
+#endif
 
 		max_len = PHY_REG_SIZE;
 #if 0
@@ -2023,6 +2388,8 @@ int PHY_ConfigBBWithParaFile(struct rtl8192cd_priv *priv, int reg_file)
 		}
 #endif
 	}
+#endif
+#ifdef CONFIG_RTL_92C_SUPPORT
 	else if (reg_file == PHYREG_2T2R) {
 #ifdef TESTCHIP_SUPPORT
 		if (IS_TEST_CHIP(priv)) {
@@ -2148,28 +2515,43 @@ int PHY_ConfigBBWithParaFile(struct rtl8192cd_priv *priv, int reg_file)
 					phyreg_table[len].offset = u4bRegOffset;
 					phyreg_table[len].value = u4bRegValue;
 					len++;
-#if defined(CONFIG_RTL_8198) && defined(CONFIG_RTL_92D_SUPPORT)
+#if (defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)) && defined(CONFIG_RTL_92D_SUPPORT)
 					if ((len&0x7ff)==0)
 						REG32(BSP_WDTCNR) |=  1 << 23;
 #endif
-					if (u4bRegOffset == 0xff)
-						break;
+#ifdef CONFIG_RTL_88E_SUPPORT
+					if (GET_CHIP_VER(priv)==VERSION_8188E) {
+						if (u4bRegOffset == 0xffff)
+							break;
+					} else
+#endif
+					{
+						if (u4bRegOffset == 0xff)
+							break;
+					}
 					if ((len * sizeof(struct PhyRegTable)) > max_len)
 						break;
 				}
-			}
-			else {
+			} else {
 				num = get_offset_mask_val(line_head, &u4bRegOffset, &u4bRegMask ,&u4bRegValue);
 				if (num > 0) {
 					macreg_table[len].offset = u4bRegOffset;
 					macreg_table[len].mask = u4bRegMask;
 					macreg_table[len].value = u4bRegValue;
 					len++;
-					if (u4bRegOffset == 0xff)
-						break;
+#ifdef CONFIG_RTL_88E_SUPPORT
+					if (GET_CHIP_VER(priv)==VERSION_8188E) {
+						if (u4bRegOffset == 0xffff)
+							break;
+					} else
+#endif
+					{
+						if (u4bRegOffset == 0xff)
+							break;
+					}
 					if ((len * sizeof(struct MacRegTable)) > max_len)
 						break;
-#if defined(CONFIG_RTL_8198) && defined(CONFIG_RTL_92D_SUPPORT)
+#if (defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)) && defined(CONFIG_RTL_92D_SUPPORT)
 					if ((len&0x7ff)==0)
 						REG32(BSP_WDTCNR) |=  1 << 23;
 #endif
@@ -2201,11 +2583,30 @@ int PHY_ConfigBBWithParaFile(struct rtl8192cd_priv *priv, int reg_file)
 			u4bRegValue = phyreg_table[num].value;
 		}
 
-		if (u4bRegOffset == 0xff)
-			break;
-		else if (file_format == THREE_COLUMN){
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv)==VERSION_8188E) {
+			if (u4bRegOffset == 0xffff)
+				break;
+		} else
+#endif
+		{
+			if (u4bRegOffset == 0xff)
+				break;
+		}
+
+		if (file_format == THREE_COLUMN){
+#if defined(CONFIG_RTL_92D_SUPPORT) || defined(CONFIG_RTL_88E_SUPPORT)
+			if (reg_file == PHYREG_PG && (
 #ifdef CONFIG_RTL_92D_SUPPORT
-			if (reg_file == PHYREG_PG && GET_CHIP_VER(priv)==VERSION_8192D) {
+				(GET_CHIP_VER(priv)==VERSION_8192D) 
+#endif
+#ifdef CONFIG_RTL_88E_SUPPORT
+#ifdef CONFIG_RTL_92D_SUPPORT
+				|| 
+#endif
+				(GET_CHIP_VER(priv)==VERSION_8188E)
+#endif
+				)) {
 				if (u4bRegOffset==0xe00){
 					if (idx == pg_tbl_idx)
 						write_en=1;
@@ -2309,16 +2710,30 @@ int PHY_ConfigRFWithParaFile(struct rtl8192cd_priv *priv,
 
 		num = get_offset_val(line_head, &u4bRegOffset, &u4bRegValue);
 		if (num > 0) {
-			if (u4bRegOffset == 0xff)
-				break;
-			else if (u4bRegOffset == 0xfe)
-				delay_ms(50);	// Delay 50 ms. Only RF configuration require delay
-			else if (num == 2) {
-				PHY_SetRFReg(priv, eRFPath, u4bRegOffset, bMask20Bits, u4bRegValue);
-				delay_ms(1);
+#ifdef CONFIG_RTL_88E_SUPPORT
+			if (GET_CHIP_VER(priv) == VERSION_8188E) {
+				if (u4bRegOffset == 0xffff) {
+					break;
+				} else if (u4bRegOffset == 0xffe) {
+					delay_ms(50);	// Delay 50 ms. Only RF configuration require delay
+				} else if (num == 2) {
+					PHY_SetRFReg(priv, eRFPath, u4bRegOffset, bMask20Bits, u4bRegValue);
+					delay_ms(1);
+				}
+			} else
+#endif
+			{
+				if (u4bRegOffset == 0xff) {
+					break;
+				} else if (u4bRegOffset == 0xfe) {
+					delay_ms(50);	// Delay 50 ms. Only RF configuration require delay
+				} else if (num == 2) {
+					PHY_SetRFReg(priv, eRFPath, u4bRegOffset, bMask20Bits, u4bRegValue);
+					delay_ms(1);
+				}
 			}
 		}
-#if defined(CONFIG_RTL_8198) && defined(CONFIG_RTL_92D_SUPPORT)
+#if (defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)) && defined(CONFIG_RTL_92D_SUPPORT)
 		REG32(BSP_WDTCNR) |=  1 << 23;
 #endif
 	}
@@ -2367,6 +2782,13 @@ int PHY_ConfigMACWithParaFile(struct rtl8192cd_priv *priv)
 			memcpy(mem_ptr, data_MACPHY_REG_92C_start, read_bytes);
 		}
 #endif
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv) == VERSION_8188E) {
+			DEBUG_INFO("[%s][MAC_REG_88E]\n",__FUNCTION__);
+			read_bytes = (int)(data_MAC_REG_88E_end - data_MAC_REG_88E_start);
+			memcpy(mem_ptr, data_MAC_REG_88E_start, read_bytes);
+		}
+#endif
 #else
 
 		old_fs = get_fs();
@@ -2404,13 +2826,26 @@ int PHY_ConfigMACWithParaFile(struct rtl8192cd_priv *priv)
 				reg_table[len].offset = u4bRegOffset;
 				reg_table[len].value = u4bRegValue;
 				len++;
-				if (u4bRegOffset == 0xff)
-					break;
+#ifdef CONFIG_RTL_88E_SUPPORT
+				if (GET_CHIP_VER(priv)==VERSION_8188E) {
+					if (u4bRegOffset == 0xffff)
+						break;
+				} else
+#endif
+				{
+					if (u4bRegOffset == 0xff)
+						break;
+				}
 				if ((len * sizeof(struct MacRegTable)) > MAC_REG_SIZE)
 					break;
 			}
 		}
-		reg_table[len].offset = 0xff;
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv)==VERSION_8188E)
+			reg_table[len].offset = 0xffff;
+		else
+#endif
+			reg_table[len].offset = 0xff;
 
 		kfree(mem_ptr);
 
@@ -2425,10 +2860,18 @@ int PHY_ConfigMACWithParaFile(struct rtl8192cd_priv *priv)
 		u4bRegOffset = reg_table[num].offset;
 		u4bRegValue = reg_table[num].value;
 
-		if (u4bRegOffset == 0xff)
-			break;
-		else
-			RTL_W8(u4bRegOffset, u4bRegValue);
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv)==VERSION_8188E) {
+			if (u4bRegOffset == 0xffff)
+				break;
+		} else
+#endif
+		{
+			if (u4bRegOffset == 0xff)
+				break;
+		}
+
+		RTL_W8(u4bRegOffset, u4bRegValue);
 		num++;
 	}
 
@@ -2520,8 +2963,18 @@ void SwChnl(struct rtl8192cd_priv *priv, unsigned char channel, int offset)
 			val += 14;
 
 	for(eRFPath = RF92CD_PATH_A; eRFPath < curMaxRFPath; eRFPath++)	{
+#if defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_88E_SUPPORT)
+	if (
 #ifdef CONFIG_RTL_92C_SUPPORT
-	if ((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C))
+		(GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)
+#endif
+#ifdef CONFIG_RTL_88E_SUPPORT
+#ifdef CONFIG_RTL_92C_SUPPORT
+		||
+#endif
+		(GET_CHIP_VER(priv) == VERSION_8188E)
+#endif
+		)
 		PHY_SetRFReg(priv, eRFPath, rRfChannel, 0xff, val);
 #endif
 #ifdef CONFIG_RTL_92D_SUPPORT
@@ -2578,6 +3031,7 @@ void SwChnl(struct rtl8192cd_priv *priv, unsigned char channel, int offset)
 		SetIMR_n(priv, val);
 
 		Update92DRFbyChannel(priv, val);
+
 	}
 #endif
 
@@ -2589,10 +3043,12 @@ void SwChnl(struct rtl8192cd_priv *priv, unsigned char channel, int offset)
 
 	priv->pshare->working_channel = val;
 
-#ifdef TXPWR_LMT	
+#ifdef TXPWR_LMT
+{	
 	if (!priv->pshare->rf_ft_var.disable_txpwrlmt){
 		find_pwr_limit(priv);
 	}
+}
 #endif
 
 	PHY_RF6052SetOFDMTxPower(priv, val);
@@ -2817,42 +3273,55 @@ void phy_InitBBRFRegisterDefinition(struct rtl8192cd_priv *priv)
 
 void check_chipID_MIMO(struct rtl8192cd_priv *priv)
 {
-	unsigned int val32;
-	val32 = RTL_R32(SYS_CFG);
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv) == VERSION_8188E)	{
+		priv->pshare->phw->MIMO_TR_hw_support = MIMO_1T1R;
+		goto exit_func;
+	}
+#endif
+
 #ifdef CONFIG_RTL_92D_SUPPORT
 	if (GET_CHIP_VER(priv) == VERSION_8192D) {
 		if (priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY)
 			priv->pshare->phw->MIMO_TR_hw_support = MIMO_1T1R;
 		else
-		priv->pshare->phw->MIMO_TR_hw_support = MIMO_2T2R;
-	} else
-#endif
-	if (val32 & BIT(27)) {
-		priv->pshare->version_id = VERSION_8192C;
-		priv->pshare->phw->MIMO_TR_hw_support = MIMO_2T2R;
-	} else {
-		priv->pshare->version_id = VERSION_8188C;
-		priv->pshare->phw->MIMO_TR_hw_support = MIMO_1T1R;
-
-		if ((0x3 &(RTL_R32(0xec)>>22))== 0x01 )
-			priv->pshare->version_id |= 0x200;		// 88RE
+			priv->pshare->phw->MIMO_TR_hw_support = MIMO_2T2R;
+		goto exit_func;
 	}
+#endif
 
-	if (val32 & BIT(23)) {
-		priv->pshare->version_id |= 0x100;
-	}
 #ifdef CONFIG_RTL_92C_SUPPORT
-	if ((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)){
-		if (val32 & BIT(19)) {
-			priv->pshare->version_id |= 0x400;			// UMC
-			priv->pshare->version_id |= (0xf0 & (val32>>8));	//	0:  a-cut
+	{
+		unsigned int val32;
+		val32 = RTL_R32(SYS_CFG);
+		if (val32 & BIT(27)) {
+			priv->pshare->version_id = VERSION_8192C;
+			priv->pshare->phw->MIMO_TR_hw_support = MIMO_2T2R;
+		} else {
+			priv->pshare->version_id = VERSION_8188C;
+			priv->pshare->phw->MIMO_TR_hw_support = MIMO_1T1R;
+
+			if ((0x3 &(RTL_R32(0xec)>>22))== 0x01)
+				priv->pshare->version_id |= 0x200;		// 88RE
 		}
-		if( ((0x0f & (val32>>16)) ==0 ) && ((0x0f & (val32>>12)) ==1 ) ) {		//6195B
-			priv->pshare->version_id |= 0x400;
-			priv->pshare->version_id |= 0x10;					//	0x10:	b-cut
+
+		if (val32 & BIT(23)) {
+			priv->pshare->version_id |= 0x100;
 		}
-    }
+		if ((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)) {
+			if (val32 & BIT(19)) {
+				priv->pshare->version_id |= 0x400;			// UMC
+				priv->pshare->version_id |= (0xf0 & (val32>>8));	//	0:  a-cut
+			}
+			if(((0x0f & (val32>>16)) ==0) && ((0x0f & (val32>>12)) ==1)) {		//6195B
+				priv->pshare->version_id |= 0x400;
+				priv->pshare->version_id |= 0x10;					//	0x10:	b-cut
+			}
+		}
+	}
 #endif
+
+exit_func:
 	return;
 }
 
@@ -2883,10 +3352,23 @@ void selectMinPowerIdex(struct rtl8192cd_priv *priv)
 		}
 	}
 
-	if (GET_CHIP_VER(priv) != VERSION_8188C)
-	{
-		for (idx=0 ; idx < 8 ; idx++)
-		{
+#if defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT)
+	if (
+#ifdef CONFIG_RTL_92C_SUPPORT
+		(GET_CHIP_VER(priv) == VERSION_8192C) 
+#endif
+#ifdef CONFIG_RTL_92D_SUPPORT
+#ifdef CONFIG_RTL_92C_SUPPORT
+		|| 
+#endif
+		((GET_CHIP_VER(priv) == VERSION_8192D)
+#ifdef CONFIG_RTL_92D_DMDP
+		&& (priv->pmib->dot11RFEntry.macPhyMode == SINGLEMAC_SINGLEPHY)
+#endif
+		)
+#endif
+		) {
+		for (idx=0 ; idx < 8 ; idx++) {
 			val32 = RTL_R32(pwr_regB[idx]);
 			switch (pwr_regB[idx]) {
 			case 0x86c:
@@ -2905,6 +3387,7 @@ void selectMinPowerIdex(struct rtl8192cd_priv *priv)
 			}
 		}
 	}
+#endif
 
 	priv->pshare->rf_ft_var.min_pwr_idex = pwr_min;
 }
@@ -2932,9 +3415,15 @@ void PHY_RF6052SetOFDMTxPower(struct rtl8192cd_priv *priv, unsigned int channel)
 #endif
 	unsigned int ori_channel = channel; //Keep the original channel setting
 
+#ifdef CONFIG_RTL_88E_SUPPORT
+	/* for testchip only */
+	if (GET_CHIP_VER(priv)==VERSION_8188E)
+		defValue =0x21;
+#endif
+
 #ifdef CONFIG_RTL_92D_SUPPORT
 	if (GET_CHIP_VER(priv)==VERSION_8192D) {
-#ifdef CONFIG_RTL_8198
+#if defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 		if (priv->pmib->dot11RFEntry.phyBandSelect & PHY_BAND_5G)
 			defValue=0x28;
 		else
@@ -2963,18 +3452,18 @@ void PHY_RF6052SetOFDMTxPower(struct rtl8192cd_priv *priv, unsigned int channel)
 			pwrdiffHT40_2S = priv->pmib->dot11RFEntry.pwrdiff5GHT40_2S[channel-1];
 			pwrdiffHT20 = priv->pmib->dot11RFEntry.pwrdiff5GHT20[channel-1];
 			pwrdiffOFDM = priv->pmib->dot11RFEntry.pwrdiff5GOFDM[channel-1];
-			}
+		}
 
 #ifdef USB_POWER_SUPPORT
 //_TXPWR_REDEFINE
 //MCS 8 - 15: No Power By Rate
 //Others: Power by Rate (Add Power)
 //Remove PWR_5G_DIFF
-			
+
 //?? phyBandSelect will auto swtich or 2G | 5G ??
 		{
 			int i;
-
+			
 			if (priv->pmib->dot11RFEntry.phyBandSelect & PHY_BAND_5G) {
 				pwrlevelHT40_6dBm_1S_A = priv->pmib->dot11RFEntry.pwrlevel5GHT40_1S_A[channel];
 				pwrlevelHT40_6dBm_1S_B = priv->pmib->dot11RFEntry.pwrlevel5GHT40_1S_B[channel];
@@ -2990,7 +3479,7 @@ void PHY_RF6052SetOFDMTxPower(struct rtl8192cd_priv *priv, unsigned int channel)
 			}
 		}
 #endif
-
+			
 
 #ifdef CONFIG_RTL_92D_DMDP
 		if (priv->pmib->dot11RFEntry.macPhyMode==DUALMAC_DUALPHY &&
@@ -3086,8 +3575,8 @@ void PHY_RF6052SetOFDMTxPower(struct rtl8192cd_priv *priv, unsigned int channel)
 
 #ifdef USB_POWER_SUPPORT
 //_TXPWR_REDEFINE, pwrlevelHT40_1S_A == 0 >> No 6dBm Power >> default value >> so USB = def - 14
-		writeVal = POWER_RANGE_CHECK(defValue - USB_HT_2S_DIFF);
-		writeVal |= (writeVal<<24)|(writeVal<<16)|(writeVal<<8);
+			writeVal = POWER_RANGE_CHECK(defValue - USB_HT_2S_DIFF);
+			writeVal |= (writeVal<<24)|(writeVal<<16)|(writeVal<<8);
 #endif
 		RTL_W32(rTxAGC_A_Mcs11_Mcs08, writeVal);
 		RTL_W32(rTxAGC_A_Mcs15_Mcs12, writeVal);
@@ -3150,13 +3639,13 @@ void PHY_RF6052SetOFDMTxPower(struct rtl8192cd_priv *priv, unsigned int channel)
 
 //_TXPWR_REDEFINE
 #ifdef USB_POWER_SUPPORT
-		byte0 = byte1 = byte2 = byte3 = -USB_HT_2S_DIFF;
+			byte0 = byte1 = byte2 = byte3 = -USB_HT_2S_DIFF;
 #else
-		byte0 = byte1 = byte2 = byte3 = 0;
-		ASSIGN_TX_POWER_OFFSET(byte0, priv->pshare->rf_ft_var.txPowerPlus_mcs_11);
-		ASSIGN_TX_POWER_OFFSET(byte1, priv->pshare->rf_ft_var.txPowerPlus_mcs_10);
-		ASSIGN_TX_POWER_OFFSET(byte2, priv->pshare->rf_ft_var.txPowerPlus_mcs_9);
-		ASSIGN_TX_POWER_OFFSET(byte3, priv->pshare->rf_ft_var.txPowerPlus_mcs_8);
+			byte0 = byte1 = byte2 = byte3 = 0;
+			ASSIGN_TX_POWER_OFFSET(byte0, priv->pshare->rf_ft_var.txPowerPlus_mcs_11);
+			ASSIGN_TX_POWER_OFFSET(byte1, priv->pshare->rf_ft_var.txPowerPlus_mcs_10);
+			ASSIGN_TX_POWER_OFFSET(byte2, priv->pshare->rf_ft_var.txPowerPlus_mcs_9);
+			ASSIGN_TX_POWER_OFFSET(byte3, priv->pshare->rf_ft_var.txPowerPlus_mcs_8);
 #endif
 
 		byte0 = POWER_RANGE_CHECK(base + byte0);
@@ -3169,13 +3658,13 @@ void PHY_RF6052SetOFDMTxPower(struct rtl8192cd_priv *priv, unsigned int channel)
 
 //_TXPWR_REDEFINE
 #ifdef USB_POWER_SUPPORT
-		byte0 = byte1 = byte2 = byte3 = -USB_HT_2S_DIFF;
+			byte0 = byte1 = byte2 = byte3 = -USB_HT_2S_DIFF;
 #else
-		byte0 = byte1 = byte2 = byte3 = 0;
-		ASSIGN_TX_POWER_OFFSET(byte0, priv->pshare->rf_ft_var.txPowerPlus_mcs_15);
-		ASSIGN_TX_POWER_OFFSET(byte1, priv->pshare->rf_ft_var.txPowerPlus_mcs_14);
-		ASSIGN_TX_POWER_OFFSET(byte2, priv->pshare->rf_ft_var.txPowerPlus_mcs_13);
-		ASSIGN_TX_POWER_OFFSET(byte3, priv->pshare->rf_ft_var.txPowerPlus_mcs_12);
+			byte0 = byte1 = byte2 = byte3 = 0;
+			ASSIGN_TX_POWER_OFFSET(byte0, priv->pshare->rf_ft_var.txPowerPlus_mcs_15);
+			ASSIGN_TX_POWER_OFFSET(byte1, priv->pshare->rf_ft_var.txPowerPlus_mcs_14);
+			ASSIGN_TX_POWER_OFFSET(byte2, priv->pshare->rf_ft_var.txPowerPlus_mcs_13);
+			ASSIGN_TX_POWER_OFFSET(byte3, priv->pshare->rf_ft_var.txPowerPlus_mcs_12);
 #endif
 
 		byte0 = POWER_RANGE_CHECK(base + byte0);
@@ -3241,7 +3730,7 @@ void PHY_RF6052SetOFDMTxPower(struct rtl8192cd_priv *priv, unsigned int channel)
 	writeVal = (byte0<<24) | (byte1<<16) |(byte2<<8) | byte3;
 	RTL_W32(rTxAGC_A_Mcs07_Mcs04, writeVal);
 
-	offset = (pwrdiffHT40_2S & 0x0f);
+	offset = (pwrdiffHT40_2S & 0x0f);	
 #if defined(CONFIG_RTL_92D_SUPPORT)&& defined(CONFIG_RTL_92D_DMDP)
 //_TXPWR_REDEFINE??
 	if (priv->pmib->dot11RFEntry.macPhyMode==DUALMAC_DUALPHY && priv->pshare->wlandev_idx == 1) {
@@ -3281,17 +3770,17 @@ void PHY_RF6052SetOFDMTxPower(struct rtl8192cd_priv *priv, unsigned int channel)
 	if ((pwrlevelHT40_6dBm_1S_A != 0) && (pwrlevelHT40_6dBm_1S_A != pwrlevelHT40_1S_A))
 		byte0 = byte1 = byte2 = byte3 =	base_6dBm;
 	else if((base - USB_HT_2S_DIFF) > 0)
-		byte0 = byte1 = byte2 = byte3 =	POWER_RANGE_CHECK(base - USB_HT_2S_DIFF);
+		byte0 = byte1 = byte2 = byte3 =	POWER_RANGE_CHECK(base -USB_HT_2S_DIFF);
 	else
 		byte0 = byte1 = byte2 = byte3 =	POWER_RANGE_CHECK(defValue - USB_HT_2S_DIFF);
 
 
 #else
 //_TXPWR_REDEFINE ?? MCS 8 - 11, shall NOT add power by rate even NOT USB power ??
-	byte0 = POWER_RANGE_CHECK(base + priv->pshare->phw->MCSTxAgcOffset_A[8]);
-	byte1 = POWER_RANGE_CHECK(base + priv->pshare->phw->MCSTxAgcOffset_A[9]);
-	byte2 = POWER_RANGE_CHECK(base + priv->pshare->phw->MCSTxAgcOffset_A[10]);
-	byte3 = POWER_RANGE_CHECK(base + priv->pshare->phw->MCSTxAgcOffset_A[11]);
+		byte0 = POWER_RANGE_CHECK(base + priv->pshare->phw->MCSTxAgcOffset_A[8]);
+		byte1 = POWER_RANGE_CHECK(base + priv->pshare->phw->MCSTxAgcOffset_A[9]);
+		byte2 = POWER_RANGE_CHECK(base + priv->pshare->phw->MCSTxAgcOffset_A[10]);
+		byte3 = POWER_RANGE_CHECK(base + priv->pshare->phw->MCSTxAgcOffset_A[11]);
 #endif
 
 	writeVal = (byte0<<24) | (byte1<<16) |(byte2<<8) | byte3;
@@ -3305,15 +3794,15 @@ void PHY_RF6052SetOFDMTxPower(struct rtl8192cd_priv *priv, unsigned int channel)
 	if ((pwrlevelHT40_6dBm_1S_A != 0) && (pwrlevelHT40_6dBm_1S_A != pwrlevelHT40_1S_A))
 		byte0 = byte1 = byte2 = byte3 =	base_6dBm;
 	else if((base - USB_HT_2S_DIFF) > 0)
-		byte0 = byte1 = byte2 = byte3 =	POWER_RANGE_CHECK(base - USB_HT_2S_DIFF);
+		byte0 = byte1 = byte2 = byte3 =	POWER_RANGE_CHECK(base -USB_HT_2S_DIFF);
 	else
 		byte0 = byte1 = byte2 = byte3 =	POWER_RANGE_CHECK(defValue - USB_HT_2S_DIFF);
 
 #else
-	byte0 = POWER_RANGE_CHECK(base + priv->pshare->phw->MCSTxAgcOffset_A[12]);
-	byte1 = POWER_RANGE_CHECK(base + priv->pshare->phw->MCSTxAgcOffset_A[13]);
-	byte2 = POWER_RANGE_CHECK(base + priv->pshare->phw->MCSTxAgcOffset_A[14]);
-	byte3 = POWER_RANGE_CHECK(base + priv->pshare->phw->MCSTxAgcOffset_A[15]);
+		byte0 = POWER_RANGE_CHECK(base + priv->pshare->phw->MCSTxAgcOffset_A[12]);
+		byte1 = POWER_RANGE_CHECK(base + priv->pshare->phw->MCSTxAgcOffset_A[13]);
+		byte2 = POWER_RANGE_CHECK(base + priv->pshare->phw->MCSTxAgcOffset_A[14]);
+		byte3 = POWER_RANGE_CHECK(base + priv->pshare->phw->MCSTxAgcOffset_A[15]);
 #endif
 
 	writeVal = (byte0<<24) | (byte1<<16) |(byte2<<8) | byte3;
@@ -3375,15 +3864,15 @@ void PHY_RF6052SetOFDMTxPower(struct rtl8192cd_priv *priv, unsigned int channel)
 	if (( pwrlevelHT40_6dBm_1S_B != 0 ) && (pwrlevelHT40_6dBm_1S_B != pwrlevelHT40_1S_B))
 		byte0 = byte1 = byte2 = byte3 = base_6dBm;
 	else if((base - USB_HT_2S_DIFF) > 0)
-		byte0 = byte1 = byte2 = byte3 =	POWER_RANGE_CHECK(base - USB_HT_2S_DIFF);
+		byte0 = byte1 = byte2 = byte3 = POWER_RANGE_CHECK(base -USB_HT_2S_DIFF);
 	else
 		byte0 = byte1 = byte2 = byte3 =	POWER_RANGE_CHECK(defValue - USB_HT_2S_DIFF);
 
 #else
-	byte0 = POWER_RANGE_CHECK(base + priv->pshare->phw->MCSTxAgcOffset_B[8]);
-	byte1 = POWER_RANGE_CHECK(base + priv->pshare->phw->MCSTxAgcOffset_B[9]);
-	byte2 = POWER_RANGE_CHECK(base + priv->pshare->phw->MCSTxAgcOffset_B[10]);
-	byte3 = POWER_RANGE_CHECK(base + priv->pshare->phw->MCSTxAgcOffset_B[11]);
+		byte0 = POWER_RANGE_CHECK(base + priv->pshare->phw->MCSTxAgcOffset_B[8]);
+		byte1 = POWER_RANGE_CHECK(base + priv->pshare->phw->MCSTxAgcOffset_B[9]);
+		byte2 = POWER_RANGE_CHECK(base + priv->pshare->phw->MCSTxAgcOffset_B[10]);
+		byte3 = POWER_RANGE_CHECK(base + priv->pshare->phw->MCSTxAgcOffset_B[11]);
 #endif
 
 	writeVal = (byte0<<24) | (byte1<<16) |(byte2<<8) | byte3;
@@ -3394,15 +3883,15 @@ void PHY_RF6052SetOFDMTxPower(struct rtl8192cd_priv *priv, unsigned int channel)
 	if (( pwrlevelHT40_6dBm_1S_B != 0 ) && (pwrlevelHT40_6dBm_1S_B != pwrlevelHT40_1S_B))
 		byte0 = byte1 = byte2 = byte3 = base_6dBm;
 	else if((base - USB_HT_2S_DIFF) > 0)
-		byte0 = byte1 = byte2 = byte3 =	POWER_RANGE_CHECK(base - USB_HT_2S_DIFF);
+		byte0 = byte1 = byte2 = byte3 = POWER_RANGE_CHECK(base -USB_HT_2S_DIFF);
 	else
 		byte0 = byte1 = byte2 = byte3 =	POWER_RANGE_CHECK(defValue - USB_HT_2S_DIFF);
 
 #else
-	byte0 = POWER_RANGE_CHECK(base + priv->pshare->phw->MCSTxAgcOffset_B[12]);
-	byte1 = POWER_RANGE_CHECK(base + priv->pshare->phw->MCSTxAgcOffset_B[13]);
-	byte2 = POWER_RANGE_CHECK(base + priv->pshare->phw->MCSTxAgcOffset_B[14]);
-	byte3 = POWER_RANGE_CHECK(base + priv->pshare->phw->MCSTxAgcOffset_B[15]);
+		byte0 = POWER_RANGE_CHECK(base + priv->pshare->phw->MCSTxAgcOffset_B[12]);
+		byte1 = POWER_RANGE_CHECK(base + priv->pshare->phw->MCSTxAgcOffset_B[13]);
+		byte2 = POWER_RANGE_CHECK(base + priv->pshare->phw->MCSTxAgcOffset_B[14]);
+		byte3 = POWER_RANGE_CHECK(base + priv->pshare->phw->MCSTxAgcOffset_B[15]);
 #endif
 
 	writeVal = (byte0<<24) | (byte1<<16) |(byte2<<8) | byte3;
@@ -3466,6 +3955,12 @@ void PHY_RF6052SetCCKTxPower(struct rtl8192cd_priv *priv, unsigned int channel)
 #endif
 			byte = 0x24;
 
+#ifdef CONFIG_RTL_88E_SUPPORT
+	/* for testchip only */
+	if (GET_CHIP_VER(priv)==VERSION_8188E)
+		byte =0x21;
+#endif
+
 #ifndef ADD_TX_POWER_BY_CMD
 		writeVal = byte;
 		PHY_SetBBReg(priv, rTxAGC_A_CCK1_Mcs32, 0x0000ff00, writeVal);
@@ -3530,12 +4025,39 @@ static int phy_BB8192CD_Config_ParaFile(struct rtl8192cd_priv *priv)
 	RTL_W16(REG_SYS_FUNC_EN, val16|BIT(13)|BIT(0)|BIT(1));
 
 	// 20090923 Joseph: Advised by Steven and Jenyu. Power sequence before init RF.
-	RTL_W8(REG_AFE_PLL_CTRL, 0x83);
-	RTL_W8(REG_AFE_PLL_CTRL+1, 0xdb);
+#if defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT)
+	if (
+#ifdef CONFIG_RTL_92C_SUPPORT
+		(GET_CHIP_VER(priv)==VERSION_8192C) || (GET_CHIP_VER(priv)==VERSION_8188C) 
+#endif
+#ifdef CONFIG_RTL_92D_SUPPORT
+#ifdef CONFIG_RTL_92C_SUPPORT
+		|| 
+#endif
+		(GET_CHIP_VER(priv)==VERSION_8192D)
+#endif
+		) {
+		RTL_W8(REG_AFE_PLL_CTRL, 0x83);
+		RTL_W8(REG_AFE_PLL_CTRL+1, 0xdb);
+	}
+#endif
 	RTL_W8(REG_RF_CTRL, RF_EN|RF_RSTB|RF_SDMRSTB);
 	//RTL_W8(REG_SYS_FUNC_EN, FEN_PPLL|FEN_PCIEA|FEN_DIO_PCIE|FEN_USBA|FEN_BB_GLB_RST|FEN_BBRSTB);
 	//RTL_W8(REG_LDOHCI12_CTRL, 0x1f);
-	RTL_W8(REG_AFE_XTAL_CTRL+1, 0x80);
+#if defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT)
+	if (
+#ifdef CONFIG_RTL_92C_SUPPORT
+		(GET_CHIP_VER(priv)==VERSION_8192C) || (GET_CHIP_VER(priv)==VERSION_8188C) 
+#endif
+#ifdef CONFIG_RTL_92D_SUPPORT
+#ifdef CONFIG_RTL_92C_SUPPORT
+		|| 
+#endif
+		(GET_CHIP_VER(priv)==VERSION_8192D)
+#endif
+		)
+		RTL_W8(REG_AFE_XTAL_CTRL+1, 0x80);
+#endif
 
 	val32 = RTL_R32(REG_AFE_XTAL_CTRL);
 	val32 = (val32 & (~(BIT(11) | BIT(14)))) | (BIT(18) | BIT(19) | BIT(21) | BIT(22));
@@ -3558,13 +4080,27 @@ static int phy_BB8192CD_Config_ParaFile(struct rtl8192cd_priv *priv)
 			rtStatus = PHY_ConfigBBWithParaFile(priv, PHYREG_1T1R);
 	}
 #endif
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv) == VERSION_8188E)
+		rtStatus = PHY_ConfigBBWithParaFile(priv, PHYREG_1T1R);
+#endif
 
 #ifdef MP_TEST
-	if ((priv->pshare->rf_ft_var.mp_specific) && (!IS_TEST_CHIP(priv)
+	if ((priv->pshare->rf_ft_var.mp_specific)
+#if defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT)
+		&& (
+#ifdef CONFIG_RTL_92C_SUPPORT
+		!IS_TEST_CHIP(priv)
+#endif
 #ifdef CONFIG_RTL_92D_SUPPORT
-		|| (GET_CHIP_VER(priv)==VERSION_8192D)
+#ifdef CONFIG_RTL_92C_SUPPORT
+		|| 
+#endif
+		(GET_CHIP_VER(priv)==VERSION_8192D)
 #endif
-		)) {
+		)
+#endif
+		) {
 		delay_ms(10);
 		rtStatus |= PHY_ConfigBBWithParaFile(priv, PHYREG_MP);
 	}
@@ -3636,7 +4172,12 @@ int phy_RF6052_Config_ParaFile(struct rtl8192cd_priv *priv)
 		priv->pshare->phw->NumTotalRFPath = 1;
 	else
 #endif
-	priv->pshare->phw->NumTotalRFPath = 2;
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv)==VERSION_8188E)
+		priv->pshare->phw->NumTotalRFPath = 1;
+	else
+#endif
+		priv->pshare->phw->NumTotalRFPath = 2;
 
 	for (eRFPath = RF92CD_PATH_A; eRFPath<priv->pshare->phw->NumTotalRFPath; eRFPath++)
 	{
@@ -3677,15 +4218,35 @@ int phy_RF6052_Config_ParaFile(struct rtl8192cd_priv *priv)
 #ifdef RTL8192D_INT_PA
 					if (priv->pshare->rf_ft_var.use_intpa92d){
 #ifdef USB_POWER_SUPPORT
+
+#if defined (RTL8192D_INT_PA_GAIN_TABLE_NEW)
+						printk("[%s][radio_b_intPA_GM_new]\n",__FUNCTION__);
+						rtStatus = PHY_ConfigRFWithParaFile(priv, data_radio_b_intPA_GM_new_start,
+							(int)(data_radio_b_intPA_GM_new_end - data_radio_b_intPA_GM_new_start), eRFPath);										
+#elif defined (RTL8192D_INT_PA_GAIN_TABLE_NEW1)
+						printk("[%s][radio_b_intPA_GM_new1]\n",__FUNCTION__);
+						rtStatus = PHY_ConfigRFWithParaFile(priv, data_radio_b_intPA_GM_new1_start,
+							(int)(data_radio_b_intPA_GM_new1_end - data_radio_b_intPA_GM_new1_start), eRFPath);						
+#else
 						printk("[%s][radio_b_intPA_GM]\n",__FUNCTION__);
 						rtStatus = PHY_ConfigRFWithParaFile(priv, data_radio_b_intPA_GM_start,
 							(int)(data_radio_b_intPA_GM_end - data_radio_b_intPA_GM_start), eRFPath);
+#endif
+						
+#else //USB_POWER_SUPPORT
+
+#if defined (RTL8192D_INT_PA_GAIN_TABLE_NEW)
+						printk("[%s][radio_b_intPA_new]\n",__FUNCTION__);
+						rtStatus = PHY_ConfigRFWithParaFile(priv, data_radio_b_intPA_new_start,
+							(int)(data_radio_b_intPA_new_end - data_radio_b_intPA_new_start), eRFPath);
 #else
 						printk("[%s][radio_b_intPA]\n",__FUNCTION__);
 						rtStatus = PHY_ConfigRFWithParaFile(priv, data_radio_b_intPA_start,
 							(int)(data_radio_b_intPA_end - data_radio_b_intPA_start), eRFPath);
 #endif
 
+#endif //USB_POWER_SUPPORT
+
 					} else
 #endif
 					{
@@ -3699,10 +4260,10 @@ int phy_RF6052_Config_ParaFile(struct rtl8192cd_priv *priv)
 						else
 #endif
 						{
-							printk("[%s] [radio_b_n]\n",__FUNCTION__);
-							rtStatus = PHY_ConfigRFWithParaFile(priv, data_radio_b_n_start,
-								(int)(data_radio_b_n_end - data_radio_b_n_start), eRFPath);
-						}
+					printk("[%s][radio_b_n]\n",__FUNCTION__);
+					rtStatus = PHY_ConfigRFWithParaFile(priv, data_radio_b_n_start,
+						(int)(data_radio_b_n_end - data_radio_b_n_start), eRFPath);
+					}
 					}
 				} else
 #endif
@@ -3711,14 +4272,36 @@ int phy_RF6052_Config_ParaFile(struct rtl8192cd_priv *priv)
 					if (priv->pshare->rf_ft_var.use_intpa92d)
 					{
 #ifdef USB_POWER_SUPPORT
+
+#if defined (RTL8192D_INT_PA_GAIN_TABLE_NEW)	
+						printk("[%s][radio_a_intPA_GM_new]\n",__FUNCTION__);
+						rtStatus = PHY_ConfigRFWithParaFile(priv, data_radio_a_intPA_GM_new_start,
+							(int)(data_radio_a_intPA_GM_new_end - data_radio_a_intPA_GM_new_start), eRFPath);						
+#elif defined (RTL8192D_INT_PA_GAIN_TABLE_NEW1)
+						printk("[%s][radio_a_intPA_GM_new1]\n",__FUNCTION__);
+						rtStatus = PHY_ConfigRFWithParaFile(priv, data_radio_a_intPA_GM_new1_start,
+							(int)(data_radio_a_intPA_GM_new1_end - data_radio_a_intPA_GM_new1_start), eRFPath);						
+#else
 						printk("[%s][radio_a_intPA_GM]\n",__FUNCTION__);
 						rtStatus = PHY_ConfigRFWithParaFile(priv, data_radio_a_intPA_GM_start,
 							(int)(data_radio_a_intPA_GM_end - data_radio_a_intPA_GM_start), eRFPath);
+#endif
+
+#else //USB_POWER_SUPPORT
+
+#if defined (RTL8192D_INT_PA_GAIN_TABLE_NEW)
+
+						printk("[%s][radio_a_intPA_new]\n",__FUNCTION__);
+						rtStatus = PHY_ConfigRFWithParaFile(priv, data_radio_a_intPA_new_start,
+							(int)(data_radio_a_intPA_new_end - data_radio_a_intPA_new_start), eRFPath);
+
 #else
 						printk("[%s][radio_a_intPA]\n",__FUNCTION__);
 						rtStatus = PHY_ConfigRFWithParaFile(priv, data_radio_a_intPA_start,
 							(int)(data_radio_a_intPA_end - data_radio_a_intPA_start), eRFPath);
 #endif
+
+#endif //USB_POWER_SUPPORT
 					} else
 #endif
 					{
@@ -3727,15 +4310,15 @@ int phy_RF6052_Config_ParaFile(struct rtl8192cd_priv *priv)
 						if (priv->pshare->rf_ft_var.use_ext_pa)
 						{
 							printk("[%s][radio_a_n_92d_hp]\n",__FUNCTION__);
-							rtStatus = PHY_ConfigRFWithParaFile(priv, data_radio_a_n_92d_hp_start,
-								(int)(data_radio_a_n_92d_hp_end - data_radio_a_n_92d_hp_start), eRFPath);
+					rtStatus = PHY_ConfigRFWithParaFile(priv, data_radio_a_n_92d_hp_start,
+						(int)(data_radio_a_n_92d_hp_end - data_radio_a_n_92d_hp_start), eRFPath);
 						}
 						else
 #endif
 						{
-							printk("[%s][radio_a_n]\n",__FUNCTION__);
-							rtStatus = PHY_ConfigRFWithParaFile(priv, data_radio_a_n_start,
-								(int)(data_radio_a_n_end - data_radio_a_n_start), eRFPath);
+					printk("[%s][radio_a_n]\n",__FUNCTION__);
+					rtStatus = PHY_ConfigRFWithParaFile(priv, data_radio_a_n_start,
+						(int)(data_radio_a_n_end - data_radio_a_n_start), eRFPath);
 						}
 					}
 				}
@@ -3743,15 +4326,36 @@ int phy_RF6052_Config_ParaFile(struct rtl8192cd_priv *priv)
 			case RF92CD_PATH_B:
 #ifdef RTL8192D_INT_PA
 				if (priv->pshare->rf_ft_var.use_intpa92d){
-#ifdef USB_POWER_SUPPORT 
+#ifdef USB_POWER_SUPPORT
+
+#if defined (RTL8192D_INT_PA_GAIN_TABLE_NEW)	
+					printk("[%s][radio_b_intPA_GM_new]\n",__FUNCTION__);
+					rtStatus = PHY_ConfigRFWithParaFile(priv, data_radio_b_intPA_GM_new_start,
+						(int)(data_radio_b_intPA_GM_new_end - data_radio_b_intPA_GM_new_start), eRFPath);					
+#elif defined (RTL8192D_INT_PA_GAIN_TABLE_NEW1)
+					printk("[%s][radio_b_intPA_GM_new1]\n",__FUNCTION__);
+					rtStatus = PHY_ConfigRFWithParaFile(priv, data_radio_b_intPA_GM_new1_start,
+						(int)(data_radio_b_intPA_GM_new1_end - data_radio_b_intPA_GM_new1_start), eRFPath);					
+#else
 					printk("[%s][radio_b_intPA_GM]\n",__FUNCTION__);
 					rtStatus = PHY_ConfigRFWithParaFile(priv, data_radio_b_intPA_GM_start,
 						(int)(data_radio_b_intPA_GM_end - data_radio_b_intPA_GM_start), eRFPath);
+#endif
+
+
+#else //USB_POWER_SUPPORT
+
+#if defined (RTL8192D_INT_PA_GAIN_TABLE_NEW)	
+					printk("[%s][radio_b_intPA_new]\n",__FUNCTION__);
+					rtStatus = PHY_ConfigRFWithParaFile(priv, data_radio_b_intPA_new_start,
+						(int)(data_radio_b_intPA_new_end - data_radio_b_intPA_new_start), eRFPath);
 #else
 					printk("[%s][radio_b_intPA]\n",__FUNCTION__);
 					rtStatus = PHY_ConfigRFWithParaFile(priv, data_radio_b_intPA_start,
 						(int)(data_radio_b_intPA_end - data_radio_b_intPA_start), eRFPath);
 #endif
+
+#endif //USB_POWER_SUPPORT
 				} else
 #endif
 				{
@@ -3765,10 +4369,10 @@ int phy_RF6052_Config_ParaFile(struct rtl8192cd_priv *priv)
 					else
 #endif
 					{
-						printk("[%s][radio_b_n]\n",__FUNCTION__);
-						rtStatus = PHY_ConfigRFWithParaFile(priv, data_radio_b_n_start,
-							(int)(data_radio_b_n_end - data_radio_b_n_start), eRFPath);
-					}
+				printk("[%s][radio_b_n]\n",__FUNCTION__);
+				rtStatus = PHY_ConfigRFWithParaFile(priv, data_radio_b_n_start,
+					(int)(data_radio_b_n_end - data_radio_b_n_start), eRFPath);
+				}
 				}
 				break;
 #else
@@ -3808,18 +4412,18 @@ int phy_RF6052_Config_ParaFile(struct rtl8192cd_priv *priv)
 					else
 #endif
 					{
-						if (priv->pshare->rf_ft_var.use_ext_lna)
+					if (priv->pshare->rf_ft_var.use_ext_lna)
 						{
 							//printk("[%s][data_radio_a_2T_n_lna]\n", __FUNCTION__);
-							rtStatus = PHY_ConfigRFWithParaFile(priv, data_radio_a_2T_n_lna_start,
-											(int)(data_radio_a_2T_n_lna_end - data_radio_a_2T_n_lna_start), eRFPath);
+						rtStatus = PHY_ConfigRFWithParaFile(priv, data_radio_a_2T_n_lna_start,
+										(int)(data_radio_a_2T_n_lna_end - data_radio_a_2T_n_lna_start), eRFPath);
 						}
-						else
+					else
 						{
 							//printk("[%s][data_radio_a_2T_n]\n", __FUNCTION__);
-							rtStatus = PHY_ConfigRFWithParaFile(priv, data_radio_a_2T_n_start,
-											(int)(data_radio_a_2T_n_end - data_radio_a_2T_n_start), eRFPath);
-						}
+						rtStatus = PHY_ConfigRFWithParaFile(priv, data_radio_a_2T_n_start,
+										(int)(data_radio_a_2T_n_end - data_radio_a_2T_n_start), eRFPath);
+				}
 					}
 				}
 			} else if (get_rf_mimo_mode(priv) == MIMO_1T1R)	{
@@ -3867,18 +4471,18 @@ int phy_RF6052_Config_ParaFile(struct rtl8192cd_priv *priv)
 					else
 #endif
 					{
-						if (priv->pshare->rf_ft_var.use_ext_lna)
+					if (priv->pshare->rf_ft_var.use_ext_lna)
 						{
 							//printk("[%s][data_radio_b_2T_n_lna]\n", __FUNCTION__);
-							rtStatus = PHY_ConfigRFWithParaFile(priv, data_radio_b_2T_n_lna_start,
-											(int)(data_radio_b_2T_n_lna_end - data_radio_b_2T_n_lna_start), eRFPath);
+						rtStatus = PHY_ConfigRFWithParaFile(priv, data_radio_b_2T_n_lna_start,
+										(int)(data_radio_b_2T_n_lna_end - data_radio_b_2T_n_lna_start), eRFPath);
 						}
-						else
+					else
 						{
 							//printk("[%s][data_radio_b_2T_n]\n", __FUNCTION__);
-							rtStatus = PHY_ConfigRFWithParaFile(priv, data_radio_b_2T_n_start,
-										(int)(data_radio_b_2T_n_end - data_radio_b_2T_n_start), eRFPath);
-						}
+						rtStatus = PHY_ConfigRFWithParaFile(priv, data_radio_b_2T_n_start,
+									(int)(data_radio_b_2T_n_end - data_radio_b_2T_n_start), eRFPath);
+				}
 					}
 				}
 			} else if (get_rf_mimo_mode(priv) == MIMO_1T1R)
@@ -3897,6 +4501,30 @@ int phy_RF6052_Config_ParaFile(struct rtl8192cd_priv *priv)
 		}
 	}
 #endif
+
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv) == VERSION_8188E) {
+		switch (eRFPath) {
+#ifdef MERGE_FW
+		case RF92CD_PATH_A:
+			if (get_rf_mimo_mode(priv) == MIMO_1T1R) {
+				DEBUG_INFO("[%s][radio_a_1T_88E]\n",__FUNCTION__);
+				rtStatus = PHY_ConfigRFWithParaFile(priv, data_radio_a_1T_88E_start,
+				(int)(data_radio_a_1T_88E_end - data_radio_a_1T_88E_start), eRFPath);
+			}
+			break;
+#else
+		/*case RF92CD_PATH_A:
+			rtStatus = PHY_ConfigRFWithParaFile(priv, "/usr/rtl8192Pci/radio_a.txt", eRFPath);
+			break;*/ /* porting later, 20120202*/
+#endif
+		default:
+			DEBUG_ERR("%s Line %d, wrong Ant settings\n", __FUNCTION__, __LINE__);
+			break;
+		}
+	}
+#endif
+
 		/*----Restore RFENV control type----*/;
 		switch(eRFPath)
 		{
@@ -3945,13 +4573,26 @@ static void LLT_table_init(struct rtl8192cd_priv *priv)
 	unsigned txpktbufSz, bufBd;
 #ifdef CONFIG_RTL_92D_DMDP
 	if (priv->pmib->dot11RFEntry.macPhyMode != SINGLEMAC_SINGLEPHY) {
-		txpktbufSz = 120; 
+		txpktbufSz = 120; //0x7C
 		bufBd = 127;
 	} else
 #endif
 	{
-		txpktbufSz = 246; 
-		bufBd = 255;
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv)==VERSION_8188E) {
+#ifdef DRVMAC_LB
+			txpktbufSz = 83; // 0x53
+			bufBd = 87;
+#else
+			txpktbufSz = 171; // 0xAB
+			bufBd = 175;
+#endif
+		} else
+#endif
+		{
+			txpktbufSz = 246; // 0xF6
+			bufBd = 255;
+		}
 	}
 #else
 	unsigned txpktbufSz = 252; //174(0xAE) 120(0x78) 252(0xFC)
@@ -4022,18 +4663,32 @@ static void LLT_table_init(struct rtl8192cd_priv *priv)
 #ifdef CONFIG_RTL_92D_DMDP
 	if (priv->pmib->dot11RFEntry.macPhyMode != SINGLEMAC_SINGLEPHY )
 	{
-		RTL_W8(RQPN_NPQ, 0x10);
 		//RTL_W32(RQPN, 0x80501010);
+		RTL_W8(RQPN_NPQ, 0x10);
 		//RTL_W32(RQPN, 0x80630410);
 		RTL_W32(RQPN, 0x80600404);
 	}
 	else
 #endif
 	{
-		RTL_W8(RQPN_NPQ, 0x29);
-		//RTL_W32(RQPN, 0x809f2929);
-		//RTL_W32(RQPN, 0x80a82029);
-		RTL_W32(RQPN, 0x80a92004);
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv)==VERSION_8188E) {
+			//RTL_W8(RQPN_NPQ, 4);
+			RTL_W8(RQPN_NPQ, 0x29);
+#ifdef DRVMAC_LB
+			RTL_W32(RQPN, 0x80460404);
+#else
+			//RTL_W32(RQPN, 0x805d2029);
+			RTL_W32(RQPN, 0x805d2004);
+#endif
+		} else
+#endif
+		{
+			RTL_W8(RQPN_NPQ, 0x29);
+			//RTL_W32(RQPN, 0x809f2929);
+			//RTL_W32(RQPN, 0x80a82029);
+			RTL_W32(RQPN, 0x80a92004);
+		}
 	}
 #else
 	if(txpktbufSz == 120)
@@ -4061,11 +4716,25 @@ static void LLT_table_init(struct rtl8192cd_priv *priv)
 
 static void MacInit(struct rtl8192cd_priv *priv)
 {
-	unsigned int bytetmp, retry;
+	volatile unsigned char bytetmp;
+	volatile unsigned int Qbytetmp;
+	unsigned short retry;
 	DEBUG_INFO("CP: MacInit===>>");
 
 	RTL_W8(RSV_CTRL0, 0x00);
 
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv)==VERSION_8188E) {
+		if (!HalPwrSeqCmdParsing(priv, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, 
+				PWR_INTF_PCI_MSK, rtl8188E_card_enable_flow))
+			panic_printk("%s %d, HalPwrSeqCmdParsing init fail!!!\n", __FUNCTION__, __LINE__);
+
+#ifdef SUPPORT_RTL8188E_TC
+		check_RTL8188E_testChip(priv);
+#endif
+	}
+#endif
+
 #ifdef CONFIG_RTL_92D_SUPPORT
 	if (GET_CHIP_VER(priv)==VERSION_8192D) {
 		RTL_W8(SYS_FUNC_EN, FEN_PPLL | FEN_PCIEA | FEN_DIO_PCIE);
@@ -4076,20 +4745,47 @@ static void MacInit(struct rtl8192cd_priv *priv)
 		/* advise by MAC team */
 		RTL_W8(LDOHCI12_CTRL, 0x1f);
 
-#ifndef CONFIG_RTL_8198
+#if !defined(CONFIG_RTL_8198) && !defined(CONFIG_RTL_819XD) && !defined(CONFIG_RTL_8196E)
 		/* temp modifying, for 96c pocket ap better performance */
-		bytetmp = REG32(0xb8000048);
-		bytetmp &= ~(BIT(10) | BIT(8));
-		bytetmp |= BIT(19);
-		REG32(0xb8000048) = bytetmp;
+		Qbytetmp = REG32(0xb8000048);
+		Qbytetmp &= ~(BIT(10) | BIT(8));
+		Qbytetmp |= BIT(19);
+		REG32(0xb8000048) = Qbytetmp;
 #endif
 	}
 
 #endif
 
 	// Power on when re-enter from IPS/Radio off/card disable
-	RTL_W8(AFE_XTAL_CTRL, 0x0d);	// enable XTAL		// clk inverted
-	RTL_W8(SPS0_CTRL, 0x2b);		// enable SPS into PWM
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv)==VERSION_8188E) {
+		RTL_W8(AFE_XTAL_CTRL, RTL_R8(AFE_XTAL_CTRL) | BIT(0));
+
+		Qbytetmp = RTL_R16(APS_FSMCO);
+		Qbytetmp &= 0xE7ff;
+		Qbytetmp |= 0x0800;
+		RTL_W16(APS_FSMCO, Qbytetmp);
+
+		while (!((Qbytetmp = RTL_R32(APS_FSMCO)) & 0x00020000));
+
+		Qbytetmp = RTL_R16(APS_FSMCO);
+		Qbytetmp &= 0x7FFF;
+		RTL_W16(APS_FSMCO, Qbytetmp);
+
+		Qbytetmp = RTL_R16(APS_FSMCO);
+		Qbytetmp &= 0xE7ff;
+		Qbytetmp |= 0x0000;
+		RTL_W16(APS_FSMCO, Qbytetmp);
+	} else
+#endif
+	{
+#ifdef CONFIG_RTL8672
+		RTL_W8(AFE_XTAL_CTRL, RTL_R8(AFE_XTAL_CTRL) | BIT(0));	// enable XTAL
+#else
+		RTL_W8(AFE_XTAL_CTRL, 0x0d);	// enable XTAL		// clk inverted
+#endif
+		RTL_W8(SPS0_CTRL, 0x2b);		// enable SPS into PWM
+	}
 	delay_ms(1);
 	
 #if 0
@@ -4159,12 +4855,29 @@ static void MacInit(struct rtl8192cd_priv *priv)
 		DEBUG_ERR("%s ERROR: auto enable WLAN failed!!(0x%02X)\n", __FUNCTION__, bytetmp);
 	}
 	
-	// Enable Radio off, GPIO, and LED function
-	RTL_W16(APS_FSMCO, 0x1012);			// when enable HWPDN
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv)==VERSION_8188E) 
+		RTL_W16(SYS_FUNC_EN, RTL_R16(SYS_FUNC_EN) & ~FEN_CPUEN);
+	else		/*Enable Radio off, GPIO, and LED function*/
+#endif
+		RTL_W16(APS_FSMCO, 0x1012);			// when enable HWPDN
 	
 	// release RF digital isolation
-	RTL_W8(SYS_ISO_CTRL+1, 0x82);
-	
+#if defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT)
+	if (
+#ifdef CONFIG_RTL_92C_SUPPORT
+		(GET_CHIP_VER(priv)==VERSION_8192C) || (GET_CHIP_VER(priv)==VERSION_8188C) 
+#endif
+#ifdef CONFIG_RTL_92D_SUPPORT
+#ifdef CONFIG_RTL_92C_SUPPORT
+		|| 
+#endif
+		(GET_CHIP_VER(priv)==VERSION_8192D)
+#endif
+		)
+		RTL_W8(SYS_ISO_CTRL+1, 0x82);
+#endif
+
 	delay_us(2);
 #endif
 
@@ -4176,8 +4889,16 @@ static void MacInit(struct rtl8192cd_priv *priv)
 	LLT_table_init(priv);
 
 	// Clear interrupt and enable interrupt
-	RTL_W32(HISR, 0xFFFFFFFF);
-	RTL_W16(HISRE, 0xFFFF);
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv)==VERSION_8188E) {
+		RTL_W32(REG_88E_HISR, 0xFFFFFFFF);
+		RTL_W32(REG_88E_HISRE, 0xFFFFFFFF);
+	} else
+#endif
+	{
+		RTL_W32(HISR, 0xFFFFFFFF);
+		RTL_W16(HISRE, 0xFFFF);
+	}
 
 #ifdef CONFIG_RTL_92D_SUPPORT
 	if (GET_CHIP_VER(priv)==VERSION_8192D) {
@@ -4186,20 +4907,18 @@ static void MacInit(struct rtl8192cd_priv *priv)
 
 		switch(priv->pmib->dot11RFEntry.macPhyMode) {
 		case SINGLEMAC_SINGLEPHY:
-#if 0			
-			RTL_W8(reg, 0xf4); //enable super mac
-#else
-			RTL_W8(reg, 0xfc); //enable super mac
 			RTL_W8(MAC_PHY_CTRL_T, 0xfc); 
-#endif
+			RTL_W8(MAC_PHY_CTRL_MP, 0xfc); //enable super mac
 			RTL_W32(AGGLEN_LMT, 0xb972a841);
 			break;
 		case DUALMAC_SINGLEPHY:
-			RTL_W8(reg, 0xf1); //enable supermac
+			RTL_W8(MAC_PHY_CTRL_T, 0xf1); 			
+			RTL_W8(MAC_PHY_CTRL_MP, 0xf1); //enable supermac
 			RTL_W32(AGGLEN_LMT, 0x54325521);
 			break;
 		case DUALMAC_DUALPHY:
-			RTL_W8(reg, 0xf3); //DMDP
+			RTL_W8(MAC_PHY_CTRL_T, 0xf3); 
+			RTL_W8(MAC_PHY_CTRL_MP, 0xf3); //DMDP
 			RTL_W32(AGGLEN_LMT, 0x54325521);
 			break;
 		default:
@@ -4215,16 +4934,19 @@ static void MacInit(struct rtl8192cd_priv *priv)
 #endif
 			RTL_W32(TRXFF_BNDY, (RTL_R32(TRXFF_BNDY)&0x0000FFFF)|(0x27ff&RXFF0_BNDY_Mask)<<RXFF0_BNDY_SHIFT);
 
-	}
-	else
+	} else
+#endif
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv)==VERSION_8188E) {
+		RTL_W32(TRXFF_BNDY, (RTL_R32(TRXFF_BNDY)&0x0000FFFF)|(0x13ff&RXFF0_BNDY_Mask)<<RXFF0_BNDY_SHIFT);
+	} else
+#endif
 	{
+		// Set Rx FF0 boundary : 9K/10K
 		RTL_W32(TRXFF_BNDY, (RTL_R32(TRXFF_BNDY)&0x0000FFFF)|(0x27FF&RXFF0_BNDY_Mask)<<RXFF0_BNDY_SHIFT);
 	}
 
-#else
-	// Set Rx FF0 boundary : 9K/10K
-	RTL_W32(TRXFF_BNDY, (RTL_R32(TRXFF_BNDY)&0x0000FFFF)|(0x27FF&RXFF0_BNDY_Mask)<<RXFF0_BNDY_SHIFT);
-
+#ifdef CONFIG_RTL_92C_SUPPORT
 	if (IS_TEST_CHIP(priv)) {
 		// Set High priority queue select : HPQ:BC/H/VO/VI/MG, LPQ:BE/BK
 		// [5]:H, [4]:MG, [3]:BK, [2]:BE, [1]:VI, [0]:VO
@@ -4237,8 +4959,13 @@ static void MacInit(struct rtl8192cd_priv *priv)
 	} else
 #endif
 	{
-		//RTL_W16(TRXDMA_CTRL, (0xB770 | RXSHFT_EN | RXDMA_ARBBW_EN));
-		RTL_W16(TRXDMA_CTRL, (0x5660 | RXSHFT_EN | RXDMA_ARBBW_EN));
+#if 0//def CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv)==VERSION_8188E)
+			RTL_W16(TRXDMA_CTRL, (/*0xF5B1*/ 0xB5B1 | RXSHFT_EN | RXDMA_ARBBW_EN));
+		else
+#endif
+			//RTL_W16(TRXDMA_CTRL, (0xB770 | RXSHFT_EN | RXDMA_ARBBW_EN));
+			RTL_W16(TRXDMA_CTRL, (0x5660 | RXSHFT_EN | RXDMA_ARBBW_EN));
 	}
 
 
@@ -4284,30 +5011,27 @@ static void MacInit(struct rtl8192cd_priv *priv)
 #ifdef CONFIG_RTL_92D_SUPPORT
 
 	if (GET_CHIP_VER(priv)==VERSION_8192D) {
-	/*
-	 *	Set RRSR at here before MACPHY_REG.txt is ready
-	 */
-	if (priv->pmib->dot11RFEntry.phyBandSelect & PHY_BAND_5G) {
-		/*
-		 *	PHY_BAND_5G
-		 */
-		RTL_W16(RRSR, 0x150);
-	} else{
 		/*
-		 *	PHY_BAND_2G
+		 *	Set RRSR at here before MACPHY_REG.txt is ready
 		 */
-		RTL_W16(RRSR, 0x15D);
-	}
-	RTL_W8(RRSR+2, 0);
+		if (priv->pmib->dot11RFEntry.phyBandSelect & PHY_BAND_5G) {
+			/*
+			 *	PHY_BAND_5G
+			 */
+			RTL_W16(RRSR, 0x150);
+		} else{
+			/*
+			 *	PHY_BAND_2G
+			 */
+			RTL_W16(RRSR, 0x15F); //Set 0x15F for NDSi Client Connection Issue
+		}
+		RTL_W8(RRSR+2, 0);
 
-	RTL_W8(RCR, 0x0e);		//follow 92c MACPHY_REG
-	RTL_W8(RCR+1, 0x2a); 	//follow 92c MACPHY_REG
-        }
-	else
-	{
+		RTL_W8(RCR, 0x0e);		//follow 92c MACPHY_REG
+		RTL_W8(RCR+1, 0x2a); 	//follow 92c MACPHY_REG
+	} else {
 		RTL_W16(RRSR, 0xFFFF);
 		RTL_W8(RRSR+2, 0xFF);
-
 	}
 #else
 	RTL_W16(RRSR, 0xFFFF);
@@ -4332,13 +5056,13 @@ static void MacInit(struct rtl8192cd_priv *priv)
 	priv->pshare->RLShort = 0x10;//0x30;
 	priv->pshare->RLLong = 0x10; //0x30;
 
-#ifdef CLIENT_MODE
-    if (priv->pmib->dot11OperationEntry.opmode & WIFI_STATION_STATE)
-    {
-        priv->pshare->RLShort = 0x30;
-        priv->pshare->RLLong = 0x30;
-    }
-#endif
+#ifdef CLIENT_MODE 
+    if (priv->pmib->dot11OperationEntry.opmode & WIFI_STATION_STATE) 
+    { 
+	    priv->pshare->RLShort = 0x30; 
+        priv->pshare->RLLong = 0x30; 
+    } 
+#endif 
 
 	RTL_W16(RL, (priv->pshare->RLShort&SRL_Mask)<<SRL_SHIFT|(priv->pshare->RLLong&LRL_Mask)<<LRL_SHIFT);
 
@@ -4363,8 +5087,8 @@ static void MacInit(struct rtl8192cd_priv *priv)
 			|(0x03&MAX_TXDMA_Mask)<<MAX_TXDMA_SHIFT | BCNQSTOP);
 	else
 #endif
-	RTL_W32(PCIE_CTRL_REG, RTL_R32(PCIE_CTRL_REG)|(0x07&MAX_RXDMA_Mask)<<MAX_RXDMA_SHIFT
-		|(0x07&MAX_TXDMA_Mask)<<MAX_TXDMA_SHIFT | BCNQSTOP);
+		RTL_W32(PCIE_CTRL_REG, RTL_R32(PCIE_CTRL_REG)|(0x07&MAX_RXDMA_Mask)<<MAX_RXDMA_SHIFT
+			|(0x07&MAX_TXDMA_Mask)<<MAX_TXDMA_SHIFT | BCNQSTOP);
 
 	// 20090928 Joseph
 	// Reconsider when to do this operation after asking HWSD.
@@ -4385,32 +5109,32 @@ static void MacInit(struct rtl8192cd_priv *priv)
 	if (GET_CHIP_VER(priv)==VERSION_8192D){
 		RTL_W16(TCR, RTL_R16(TCR) | WMAC_TCR_ERRSTEN3 | WMAC_TCR_ERRSTEN2
  	                         | WMAC_TCR_ERRSTEN1 | WMAC_TCR_ERRSTEN0);
-/*
- *	For 92DE,Mac0 and Mac1 power off.
- *	0x1F	BIT6: 0 mac0 off, 1: mac0 on
- *		BIT7: 0 mac1 off, 1: mac1 on.
- */
+	/*
+	 *	For 92DE,Mac0 and Mac1 power off.
+	 *	0x1F	BIT6: 0 mac0 off, 1: mac0 on
+	 *		BIT7: 0 mac1 off, 1: mac1 on.
+	 */
 #ifdef CONFIG_RTL_92D_DMDP
- 	 if (priv->pshare->wlandev_idx == 0)
+	 	 if (priv->pshare->wlandev_idx == 0)
 #endif
-	{
-		RTL_W8(RSV_MAC0_CTRL, RTL_R8(RSV_MAC0_CTRL)|MAC0_EN);
+		{
+			RTL_W8(RSV_MAC0_CTRL, RTL_R8(RSV_MAC0_CTRL)|MAC0_EN);
 
-		if (priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_5G)
-			RTL_W8(RSV_MAC0_CTRL, RTL_R8(RSV_MAC0_CTRL) & (~BAND_STAT));
-		else
-			RTL_W8(RSV_MAC0_CTRL, RTL_R8(RSV_MAC0_CTRL) | BAND_STAT);
-	}
+			if (priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_5G)
+				RTL_W8(RSV_MAC0_CTRL, RTL_R8(RSV_MAC0_CTRL) & (~BAND_STAT));
+			else
+				RTL_W8(RSV_MAC0_CTRL, RTL_R8(RSV_MAC0_CTRL) | BAND_STAT);
+		}
 
 #ifdef CONFIG_RTL_92D_DMDP
-	if (priv->pshare->wlandev_idx ==1)
-	{
-		RTL_W8(RSV_MAC1_CTRL, RTL_R8(RSV_MAC1_CTRL)|MAC1_EN);
-		if (priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_5G)
-			RTL_W8(RSV_MAC1_CTRL, RTL_R8(RSV_MAC1_CTRL) & (~BAND_STAT));
-		else
-			RTL_W8(RSV_MAC1_CTRL, RTL_R8(RSV_MAC1_CTRL) | BAND_STAT);
-	}
+		if (priv->pshare->wlandev_idx ==1)
+		{
+			RTL_W8(RSV_MAC1_CTRL, RTL_R8(RSV_MAC1_CTRL)|MAC1_EN);
+			if (priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_5G)
+				RTL_W8(RSV_MAC1_CTRL, RTL_R8(RSV_MAC1_CTRL) & (~BAND_STAT));
+			else
+				RTL_W8(RSV_MAC1_CTRL, RTL_R8(RSV_MAC1_CTRL) | BAND_STAT);
+		}
 #endif
 	}
 #endif //CONFIG_RTL_92D_SUPPORT
@@ -4421,7 +5145,9 @@ static void MacInit(struct rtl8192cd_priv *priv)
 
 static void MacConfig(struct rtl8192cd_priv *priv)
 {
-	RTL_W8(INIRTS_RATE_SEL, 0x8); // 24M
+	//RTL_W8(INIRTS_RATE_SEL, 0x8); // 24M
+	priv->pshare->phw->RTSInitRate_Candidate = priv->pshare->phw->RTSInitRate = 0x8; // 24M
+	RTL_W8(INIRTS_RATE_SEL, priv->pshare->phw->RTSInitRate);
 
 	// 2007/02/07 Mark by Emily becasue we have not verify whether this register works
 	//For 92C,which reg?
@@ -4454,13 +5180,15 @@ static void MacConfig(struct rtl8192cd_priv *priv)
 	RTL_W16(RD_CTRL, RTL_R16(RD_CTRL) | DIS_TXOP_CFE);
 
 #ifdef CONFIG_RTL_92D_SUPPORT
-	RTL_W8(MAC_SEL, 0);
-	RTL_W8(0x526, 0xff);		/* enable all MBID interface beacon */
+	if (GET_CHIP_VER(priv)==VERSION_8192D) {
+		RTL_W8(MAC_SEL, 0);
+		RTL_W8(0x526, 0xff);		/* enable all MBID interface beacon */
 
-	/*
-	 *	Protection mode control for hw RTS
-	 */
-	RTL_W16(PROT_MODE_CTRL, 0xff0D);
+		/*
+		 *	Protection mode control for hw RTS
+		 */
+		RTL_W16(PROT_MODE_CTRL, 0xff0D);
+	}
 #endif
 
 	/*
@@ -4472,6 +5200,16 @@ static void MacConfig(struct rtl8192cd_priv *priv)
 	 *	Max mpdu number per aggr
 	 */
 	RTL_W16(PROT_MODE_CTRL+2, 0x0909);
+
+#if defined(CONFIG_RTL_92D_SUPPORT) && defined(TX_EARLY_MODE)
+	if (GET_CHIP_VER(priv) == VERSION_8192D)
+		disable_em(priv);
+#endif
+
+#if defined(CONFIG_RTL_88E_SUPPORT) && defined(TXREPORT)
+	if (GET_CHIP_VER(priv)==VERSION_8188E)
+		RTL8188E_EnableTxReport(priv);
+#endif
 }
 
 
@@ -4508,6 +5246,79 @@ unsigned int get_mean_of_2_close_value(unsigned int *val_array)
 	return tmp1;
 }
 
+void _PHY_SaveADDARegisters(struct rtl8192cd_priv *priv, unsigned int* ADDAReg,	unsigned int* ADDABackup, unsigned int RegisterNum)
+{
+	unsigned int	i;
+	for( i = 0 ; i < RegisterNum ; i++){
+		ADDABackup[i] = PHY_QueryBBReg(priv, ADDAReg[i], bMaskDWord);
+	}
+}
+
+void _PHY_SetADDARegisters(struct rtl8192cd_priv *priv, unsigned int* ADDAReg,	unsigned int* ADDASettings, unsigned int RegisterNum)
+{
+	unsigned int	i;
+
+	for( i = 0 ; i < RegisterNum ; i++){
+		PHY_SetBBReg(priv, ADDAReg[i], bMaskDWord, ADDASettings[i]);
+	}
+}
+
+void _PHY_SaveMACRegisters(struct rtl8192cd_priv *priv, unsigned int* MACReg, unsigned int* MACBackup)
+{
+	unsigned int	i;
+	for( i = 0 ; i < (IQK_MAC_REG_NUM - 1); i++){
+		MACBackup[i] = RTL_R8(MACReg[i]);
+	}
+	MACBackup[i] = RTL_R32( MACReg[i]);
+}
+
+void _PHY_ReloadADDARegisters(struct rtl8192cd_priv *priv, unsigned int* ADDAReg, unsigned int*	ADDABackup, unsigned int RegiesterNum)
+{
+	unsigned int	i;
+	for(i = 0 ; i < RegiesterNum; i++){
+		PHY_SetBBReg(priv, ADDAReg[i], bMaskDWord, ADDABackup[i]);
+	}
+}
+
+void _PHY_ReloadMACRegisters(struct rtl8192cd_priv *priv,unsigned int* MACReg, unsigned int*	 MACBackup)
+{
+	unsigned int	i;
+	for(i = 0 ; i < (IQK_MAC_REG_NUM - 1); i++){
+		RTL_W8( MACReg[i], (unsigned char)MACBackup[i]);
+	}
+	RTL_W32( MACReg[i], MACBackup[i]);
+}
+
+void _PHY_MACSettingCalibration(struct rtl8192cd_priv *priv, unsigned int* MACReg, unsigned int* MACBackup)
+{
+	unsigned int	i = 0;
+	RTL_W8(MACReg[i], 0x3F);
+	for(i = 1 ; i < (IQK_MAC_REG_NUM - 1); i++){
+		RTL_W8( MACReg[i], (unsigned char)(MACBackup[i]&(~ BIT(3))));
+	}
+	RTL_W8( MACReg[i], (unsigned char)(MACBackup[i]&(~ BIT(5))));
+}
+
+void _PHY_PathADDAOn(struct rtl8192cd_priv *priv, unsigned int* ADDAReg, char isPathAOn, char is2T)
+{
+	unsigned int	pathOn;
+	unsigned int	i;
+
+	pathOn = isPathAOn ? 0x04db25a4 : 0x0b1b25a4;
+	if(FALSE == is2T){
+		pathOn = 0x0bdb25a0;
+		PHY_SetBBReg(priv, ADDAReg[0], bMaskDWord, 0x0b1b25a0);
+	}
+	else{
+		PHY_SetBBReg(priv, ADDAReg[0], bMaskDWord, pathOn);
+	}
+
+	for( i = 1 ; i < IQK_ADDA_REG_NUM ; i++){
+		PHY_SetBBReg(priv, ADDAReg[i], bMaskDWord, pathOn);
+	}
+
+}
+
 #ifdef CONFIG_RTL_92C_SUPPORT
 #ifndef CONFIG_RTL_NEW_IQK
 static void IQK_92CD(struct rtl8192cd_priv *priv)
@@ -4537,6 +5348,15 @@ static void IQK_92CD(struct rtl8192cd_priv *priv)
 	unsigned int temp_ee0 = RTL_R32(0xee0);
 	unsigned int temp_eec = RTL_R32(0xeec);
 
+#ifdef MP_TEST
+	if (!priv->pshare->rf_ft_var.mp_specific)
+#endif
+	{
+		if (priv->pshare->iqk_2g_done)
+			return;
+		priv->pshare->iqk_2g_done = 1;
+	}
+
 printk(">> %s \n",__FUNCTION__);
 
 #ifdef HIGH_POWER_EXT_PA
@@ -4829,6 +5649,15 @@ static void IQK_88C(struct rtl8192cd_priv *priv)
 	unsigned int temp_ee0 = RTL_R32(0xee0);
 	unsigned int temp_eec = RTL_R32(0xeec);
 
+#ifdef MP_TEST
+	if (!priv->pshare->rf_ft_var.mp_specific)
+#endif
+	{
+		if (priv->pshare->iqk_2g_done)
+			return;
+		priv->pshare->iqk_2g_done = 1;
+	}
+
 #ifdef HIGH_POWER_EXT_PA
 	if (priv->pshare->rf_ft_var.use_ext_pa) {
 		temp_870 = RTL_R32(0x870);
@@ -4984,54 +5813,10 @@ static void IQK_88C(struct rtl8192cd_priv *priv)
 	RTL_W32(0xed4, temp_ed4);
 	RTL_W32(0xed8, temp_ed8);
 	RTL_W32(0xedc, temp_edc);
-	RTL_W32(0xee0, temp_ee0);
-	RTL_W32(0xeec, temp_eec);
-}	// IQK
-#endif
-
-void _PHY_SaveADDARegisters(struct rtl8192cd_priv *priv, unsigned int* ADDAReg,	unsigned int* ADDABackup, unsigned int RegisterNum)
-{
-	unsigned int	i;
-	for( i = 0 ; i < RegisterNum ; i++){
-		ADDABackup[i] = PHY_QueryBBReg(priv, ADDAReg[i], bMaskDWord);
-	}
-}
-
-void _PHY_SaveMACRegisters(struct rtl8192cd_priv *priv, unsigned int* MACReg, unsigned int* MACBackup)
-{
-	unsigned int	i;
-	for( i = 0 ; i < (IQK_MAC_REG_NUM - 1); i++){
-		MACBackup[i] = RTL_R8(MACReg[i]);
-	}
-	MACBackup[i] = RTL_R32( MACReg[i]);
-}
-
-void _PHY_ReloadADDARegisters(struct rtl8192cd_priv *priv, unsigned int* ADDAReg, unsigned int*	ADDABackup, unsigned int RegiesterNum)
-{
-	unsigned int	i;
-	for(i = 0 ; i < RegiesterNum; i++){
-		PHY_SetBBReg(priv, ADDAReg[i], bMaskDWord, ADDABackup[i]);
-	}
-}
-
-void _PHY_ReloadMACRegisters(struct rtl8192cd_priv *priv,unsigned int* MACReg, unsigned int*	 MACBackup)
-{
-	unsigned int	i;
-	for(i = 0 ; i < (IQK_MAC_REG_NUM - 1); i++){
-		RTL_W8( MACReg[i], (unsigned char)MACBackup[i]);
-	}
-	RTL_W32( MACReg[i], MACBackup[i]);
-}
-
-void _PHY_MACSettingCalibration(struct rtl8192cd_priv *priv, unsigned int* MACReg, unsigned int* MACBackup)
-{
-	unsigned int	i = 0;
-	RTL_W8(MACReg[i], 0x3F);
-	for(i = 1 ; i < (IQK_MAC_REG_NUM - 1); i++){
-		RTL_W8( MACReg[i], (unsigned char)(MACBackup[i]&(~ BIT(3))));
-	}
-	RTL_W8( MACReg[i], (unsigned char)(MACBackup[i]&(~ BIT(5))));
-}
+	RTL_W32(0xee0, temp_ee0);
+	RTL_W32(0xeec, temp_eec);
+}	// IQK
+#endif
 
 void _PHY_PathAStandBy(struct rtl8192cd_priv *priv)
 {
@@ -5040,26 +5825,6 @@ void _PHY_PathAStandBy(struct rtl8192cd_priv *priv)
 	PHY_SetBBReg(priv, 0xe28, bMaskDWord, 0x80800000);
 }
 
-void _PHY_PathADDAOn(struct rtl8192cd_priv *priv, unsigned int* ADDAReg, char isPathAOn, char is2T)
-{
-	unsigned int	pathOn;
-	unsigned int	i;
-
-	pathOn = isPathAOn ? 0x04db25a4 : 0x0b1b25a4;
-	if(FALSE == is2T){
-		pathOn = 0x0bdb25a0;
-		PHY_SetBBReg(priv, ADDAReg[0], bMaskDWord, 0x0b1b25a0);
-	}
-	else{
-		PHY_SetBBReg(priv, ADDAReg[0], bMaskDWord, pathOn);
-	}
-
-	for( i = 1 ; i < IQK_ADDA_REG_NUM ; i++){
-		PHY_SetBBReg(priv, ADDAReg[i], bMaskDWord, pathOn);
-	}
-
-}
-
 /*
  *	PA Analog Pre-distortion Calibration R06
  */
@@ -5879,6 +6644,15 @@ void PHY_IQCalibrate_new(struct rtl8192cd_priv *priv)
 	char			is12simular, is13simular, is23simular;
 	unsigned int 	temp_870, temp_860, temp_864, temp_800;
 
+#ifdef MP_TEST
+	if (!priv->pshare->rf_ft_var.mp_specific)
+#endif
+	{
+		if (priv->pshare->iqk_2g_done)
+			return;
+		priv->pshare->iqk_2g_done = 1;
+	}
+
 	temp_870 = PHY_QueryBBReg(priv, 0x870, bMaskDWord);
 	temp_860 = PHY_QueryBBReg(priv, 0x860, bMaskDWord);
 	temp_864 = PHY_QueryBBReg(priv, 0x864, bMaskDWord);
@@ -6029,35 +6803,41 @@ void PHY_IQCalibrate(struct rtl8192cd_priv *priv)
 	}
 #endif
 #ifdef CONFIG_RTL_92C_SUPPORT
-if ((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)){
+	if ((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)) {
 #ifdef CONFIG_RTL_NEW_IQK
 		PHY_IQCalibrate_new(priv);
 #else
-	if( IS_UMC_A_CUT_88C(priv)
+		if( IS_UMC_A_CUT_88C(priv)
 #ifdef HIGH_POWER_EXT_PA
-		||(priv->pshare->rf_ft_var.use_ext_pa)
+			||(priv->pshare->rf_ft_var.use_ext_pa)
+#endif
+		) {
+			 PHY_IQCalibrate_new(priv);
+		} else {
+			if (GET_CHIP_VER(priv) == VERSION_8192C)
+				IQK_92CD(priv);
+			else
+				IQK_88C(priv);
+		}
 #endif
-	) {
-		 PHY_IQCalibrate_new(priv);
-	} else {
-		if (GET_CHIP_VER(priv) == VERSION_8192C)
-			IQK_92CD(priv);
-		else
-			IQK_88C(priv);
 	}
 #endif
-}
+
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv) == VERSION_8188E) 
+			PHY_IQCalibrate_8188E(priv, FALSE);
 #endif
+
 }
 
 
-static void PHY_LCCalibrate(struct rtl8192cd_priv *priv)
+void PHY_LCCalibrate(struct rtl8192cd_priv *priv)
 {
 	unsigned char tmpReg, value_IGI;
 	unsigned int LC_Cal;
 	int isNormal;
 
-#ifdef TESTCHIP_SUPPORT
+#if defined(TESTCHIP_SUPPORT) && defined(CONFIG_RTL_92C_SUPPORT)
 	isNormal = (IS_TEST_CHIP(priv)? 0 : 1);
 #else
 	isNormal = 1;
@@ -6087,7 +6867,7 @@ static void PHY_LCCalibrate(struct rtl8192cd_priv *priv)
 	/* 4. Set LC calibration begin */
 	PHY_SetRFReg(priv, RF92CD_PATH_A, 0x18, bMask12Bits, LC_Cal|0x08000);
 
-#if defined(CONFIG_RTL_8198) && defined(CONFIG_RTL_92D_SUPPORT)
+#if (defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)) && defined(CONFIG_RTL_92D_SUPPORT)
 	if (GET_CHIP_VER(priv)==VERSION_8192D)
 		REG32(BSP_WDTCNR) |=  1 << 23;
 #endif
@@ -6124,347 +6904,6 @@ static void PHY_LCCalibrate(struct rtl8192cd_priv *priv)
 }
 
 
-const int OFDM_TABLE_SIZE= sizeof(OFDMSwingTable)/sizeof(int);
-const int CCK_TABLE_SIZE= sizeof(CCKSwingTable_Ch1_Ch13) >>3;
-
-
-int get_CCK_swing_index(struct rtl8192cd_priv *priv)
-{
-	int TempCCk, index=12, i;
-	short channel;
-#ifdef MP_TEST
-	if ((OPMODE & WIFI_MP_STATE) || priv->pshare->rf_ft_var.mp_specific)
-		channel=priv->pshare->working_channel;
-	else
-#endif
-		channel = (priv->pmib->dot11RFEntry.dot11channel);
-
-	//Query CCK default setting From 0xa24
-	TempCCk = PHY_QueryBBReg(priv, rCCK0_TxFilter2, bMaskDWord)&bMaskCCK;
-	TempCCk = cpu_to_le32(TempCCk);
-	for(i=0 ; i<CCK_TABLE_SIZE ; i++)		{
-		if(channel==14) {
-			if(memcmp((void*)&TempCCk, (void*)&CCKSwingTable_Ch14[i][2], 4)==0) {
-				index = i;
-				break;
-			}
-		} else {
-			if(memcmp((void*)&TempCCk, (void*)&CCKSwingTable_Ch1_Ch13[i][2], 4)==0) {
-				index = i;
-				break;
-			}
-		}
-	}
-	DEBUG_INFO("Initial reg0x%x = 0x%lx, CCK_index=0x%x, ch %d\n",
-							rCCK0_TxFilter2, TempCCk, index, channel);
-	return index;
-}
-
-void set_CCK_swing_index(struct rtl8192cd_priv *priv, short CCK_index)
-{
-	short channel;
-#ifdef MP_TEST
-	if ((OPMODE & WIFI_MP_STATE) || priv->pshare->rf_ft_var.mp_specific)
-		channel=priv->pshare->working_channel;
-	else
-#endif
-		channel = (priv->pmib->dot11RFEntry.dot11channel);
-
-	if(channel !=14) {
-		RTL_W8( 0xa22, CCKSwingTable_Ch1_Ch13[CCK_index][0]);
-		RTL_W8( 0xa23, CCKSwingTable_Ch1_Ch13[CCK_index][1]);
-		RTL_W8( 0xa24, CCKSwingTable_Ch1_Ch13[CCK_index][2]);
-		RTL_W8( 0xa25, CCKSwingTable_Ch1_Ch13[CCK_index][3]);
-		RTL_W8( 0xa26, CCKSwingTable_Ch1_Ch13[CCK_index][4]);
-		RTL_W8( 0xa27, CCKSwingTable_Ch1_Ch13[CCK_index][5]);
-		RTL_W8( 0xa28, CCKSwingTable_Ch1_Ch13[CCK_index][6]);
-		RTL_W8( 0xa29, CCKSwingTable_Ch1_Ch13[CCK_index][7]);
-	}
-	else{
-		RTL_W8( 0xa22, CCKSwingTable_Ch14[CCK_index][0]);
-		RTL_W8( 0xa23, CCKSwingTable_Ch14[CCK_index][1]);
-		RTL_W8( 0xa24, CCKSwingTable_Ch14[CCK_index][2]);
-		RTL_W8( 0xa25, CCKSwingTable_Ch14[CCK_index][3]);
-		RTL_W8( 0xa26, CCKSwingTable_Ch14[CCK_index][4]);
-		RTL_W8( 0xa27, CCKSwingTable_Ch14[CCK_index][5]);
-		RTL_W8( 0xa28, CCKSwingTable_Ch14[CCK_index][6]);
-		RTL_W8( 0xa29, CCKSwingTable_Ch14[CCK_index][7]);
-	}
-}
-
-#ifdef HIGH_POWER_EXT_PA
-void swingIndexRemap(int *a, int b)
-{
-	int d = (RTL_ABS(*a, b) *3)>>1;
-	if(*a < b )
-		*a = b - d;
-	else
-		*a = b + d;
-}
-#endif
-
-unsigned char getThermalValue(struct rtl8192cd_priv *priv)
-{
-	unsigned char	ThermalValue;
-	int sum=0, i=0;
-	PHY_SetRFReg(priv, RF92CD_PATH_A, RF_T_METER, bMask20Bits, 0x60);
-	ThermalValue =(unsigned char)PHY_QueryRFReg(priv, RF92CD_PATH_A, RF_T_METER, bMask20Bits, 1) & 0x01f;
-	priv->pshare->Thermal_idx = (priv->pshare->Thermal_idx+1)%8;
-	priv->pshare->Thermal_log[ priv->pshare->Thermal_idx ] = ThermalValue;
-	for(i=0; i<8; i++) {
-		if(!priv->pshare->Thermal_log[i])
-			return ThermalValue;
-		sum += priv->pshare->Thermal_log[i];
-	}
-	return (sum+4)>>3;
-}
-void tx_power_tracking(struct rtl8192cd_priv *priv)
-{
-	unsigned char	ThermalValue = 0, delta, delta_LCK, delta_IQK;
-	int 			ele_A, ele_D, value32, X, Y, ele_C;
-	int			OFDM_index[2]={0,0}, CCK_index;
-	int	    		i = 0;
-	char			is2T = ((GET_CHIP_VER(priv) == VERSION_8192C) ?1 :0);
-	unsigned char		TxPwrLevel[2];
-	unsigned char 		channel, OFDM_min_index = 6, rf=1; //OFDM BB Swing should be less than +3.0dB, which is required by Arthur
-#ifdef MP_TEST
-	if ((OPMODE & WIFI_MP_STATE) || priv->pshare->rf_ft_var.mp_specific) {
-		channel=priv->pshare->working_channel;
-		if(priv->pshare->mp_txpwr_tracking == FALSE)
-			return;
-	} else
-#endif
-	{
-		channel = (priv->pmib->dot11RFEntry.dot11channel);
-	}
-
-	ThermalValue = getThermalValue(priv);
-
-	rf += is2T;
-	if(ThermalValue)	{
-
-		if(!priv->pshare->ThermalValue)	{
-			priv->pshare->ThermalValue = priv->pmib->dot11RFEntry.ther;
-			priv->pshare->ThermalValue_LCK = ThermalValue;
-			priv->pshare->ThermalValue_IQK = ThermalValue;
-
-			//Query OFDM path A default setting
-			ele_D = PHY_QueryBBReg(priv, rOFDM0_XATxIQImbalance, bMaskDWord)&bMaskOFDM_D;
-			for(i=0; i<OFDM_TABLE_SIZE; i++)	{
-				if(ele_D == (OFDMSwingTable[i]&bMaskOFDM_D))	{
-					priv->pshare->OFDM_index[0] = i;
-					priv->pshare->OFDM_index0[0] = i;
-					break;
-				}
-			}
-
-			//Query OFDM path B default setting
-			if(is2T)	{
-				ele_D = PHY_QueryBBReg(priv, rOFDM0_XBTxIQImbalance, bMaskDWord)&bMaskOFDM_D;
-				for(i=0; i<OFDM_TABLE_SIZE; i++)			{
-					if(ele_D == (OFDMSwingTable[i]&bMaskOFDM_D))	{
-						priv->pshare->OFDM_index[1] = i;
-						priv->pshare->OFDM_index0[1] = i;
-						break;
-					}
-				}
-			}
-			priv->pshare->CCK_index = get_CCK_swing_index(priv);
-			priv->pshare->CCK_index0 = priv->pshare->CCK_index;
-
-		}
-
-		delta     = RTL_ABS(ThermalValue, priv->pshare->ThermalValue);
-		delta_LCK = RTL_ABS(ThermalValue, priv->pshare->ThermalValue_LCK);
-		delta_IQK = RTL_ABS(ThermalValue, priv->pshare->ThermalValue_IQK);
-
-//		printk("Readback Thermal Meter = 0x%lx pre thermal meter 0x%lx EEPROMthermalmeter 0x%lx delta 0x%lx delta_LCK 0x%lx delta_IQK 0x%lx\n",
-//			ThermalValue, priv->pshare->ThermalValue, priv->pmib->dot11RFEntry.ther, delta, delta_LCK, delta_IQK);
-
-		if(delta_LCK > 1)	{
-			priv->pshare->ThermalValue_LCK = ThermalValue;
-			PHY_LCCalibrate(priv);
-		}
-
-		if(delta > 0)	{
-			if(ThermalValue > priv->pshare->ThermalValue)	{
-				for(i = 0; i < rf; i++)
-				 	priv->pshare->OFDM_index[i] -= delta;
-				priv->pshare->CCK_index -= delta;
-			} else {
-				for(i = 0; i < rf; i++)
-					priv->pshare->OFDM_index[i] += delta;
-				priv->pshare->CCK_index += delta;
-			}
-			if(ThermalValue > priv->pmib->dot11RFEntry.ther)	{
-				for(i = 0; i < rf; i++)
-					OFDM_index[i] = priv->pshare->OFDM_index[i]+1;
-				CCK_index = priv->pshare->CCK_index+1;
-			} else {
-				for(i = 0; i < rf; i++)
-					OFDM_index[i] = priv->pshare->OFDM_index[i];
-				CCK_index = priv->pshare->CCK_index;
-			}
-#ifdef MP_TEST
-			if ((OPMODE & WIFI_MP_STATE) || priv->pshare->rf_ft_var.mp_specific) {
-				TxPwrLevel[0] = priv->pshare->mp_txpwr_patha;
-				TxPwrLevel[1] = priv->pshare->mp_txpwr_pathb;
-			} else
-#endif
-			{
-				TxPwrLevel[0] = priv->pmib->dot11RFEntry.pwrlevelHT40_1S_A[channel-1];
-				TxPwrLevel[1] = priv->pmib->dot11RFEntry.pwrlevelHT40_1S_B[channel-1];
-
-				if (priv->pshare->CurrentChannelBW == HT_CHANNEL_WIDTH_20) {
-					unsigned char offset = (priv->pmib->dot11RFEntry.pwrdiffHT20[channel-1] & 0x0f);
-					TxPwrLevel[0] = COUNT_SIGN_OFFSET(TxPwrLevel[0], offset);
-					offset = ((priv->pmib->dot11RFEntry.pwrdiffOFDM[channel-1] & 0xf0) >> 4);
-					TxPwrLevel[1] = COUNT_SIGN_OFFSET(TxPwrLevel[1], offset);
-				}
-			}
-
-//			printk("TxPwrLevel[0]=%d, TxPwrLevel[1]=%d\n", TxPwrLevel[0], TxPwrLevel[1]);
-			for(i = 0; i < rf; i++)		{
-				if(/*TxPwrLevel[i] >=0 &&*/ TxPwrLevel[i] <=26)	{
-					if(ThermalValue > priv->pmib->dot11RFEntry.ther) {
-						if (delta < 5)
-							OFDM_index[i] -= 1;
-						else
-							OFDM_index[i] -= 2;
-					} else if(delta > 5 && ThermalValue < priv->pmib->dot11RFEntry.ther) {
-						OFDM_index[i] += 1;
-					}
-				} else if (TxPwrLevel[i] >= 27 && TxPwrLevel[i] <= 32 && ThermalValue > priv->pmib->dot11RFEntry.ther) {
-					if (delta < 5)
-						OFDM_index[i] -= 1;
-					else
-						OFDM_index[i] -= 2;
-				} else if (TxPwrLevel[i] >= 32 && TxPwrLevel[i] <= 38 && ThermalValue > priv->pmib->dot11RFEntry.ther && delta > 5) {
-					OFDM_index[i] -= 1;
-				}
-#ifdef HIGH_POWER_EXT_PA
-				if (priv->pshare->rf_ft_var.use_ext_pa) {
-					OFDM_index[i] = priv->pshare->OFDM_index[i];
-					swingIndexRemap(&OFDM_index[i], priv->pshare->OFDM_index0[i]);
-				}
-#endif
-				if(OFDM_index[i] > OFDM_TABLE_SIZE-1)
-					OFDM_index[i] = OFDM_TABLE_SIZE-1;
-				else if (OFDM_index[i] < OFDM_min_index)
-					OFDM_index[i] = OFDM_min_index;
-			}
-			i=0;
-			{
-				if(/*TxPwrLevel[i] >=0 &&*/ TxPwrLevel[i] <=26)		{
-					if(ThermalValue > priv->pmib->dot11RFEntry.ther)	{
-						if (delta < 5)
-							CCK_index -= 1;
-						else
-							CCK_index -= 2;
-					} else if(delta > 5 && ThermalValue < priv->pmib->dot11RFEntry.ther) {
-						CCK_index += 1;
-					}
-				} else if (TxPwrLevel[i] >= 27 && TxPwrLevel[i] <= 32 && ThermalValue > priv->pmib->dot11RFEntry.ther) {
-					if (delta < 5)
-						CCK_index -= 1;
-					else
-						CCK_index -= 2;
-				} else if (TxPwrLevel[i] >= 32 && TxPwrLevel[i] <= 38 && ThermalValue > priv->pmib->dot11RFEntry.ther && delta > 5) {
-					CCK_index -= 1;
-				}
-
-#ifdef HIGH_POWER_EXT_PA
-				if (priv->pshare->rf_ft_var.use_ext_pa) {
-					CCK_index = priv->pshare->CCK_index;
-					swingIndexRemap( &CCK_index, priv->pshare->CCK_index0);
-				}
-#endif
-				if(CCK_index > CCK_TABLE_SIZE-1)
-					CCK_index = CCK_TABLE_SIZE-1;
-				else if (CCK_index < 0)
-					CCK_index = 0;
-			}
-
-			//Adujst OFDM Ant_A according to IQK result
-			ele_D = (OFDMSwingTable[(unsigned int)OFDM_index[0]] & 0xFFC00000)>>22;
-			X = priv->pshare->RegE94;
-			Y = priv->pshare->RegE9C;
-
-			if(X != 0)		{
-				if ((X & 0x00000200) != 0)
-					X = X | 0xFFFFFC00;
-				ele_A = ((X * ele_D)>>8)&0x000003FF;
-
-				//new element C = element D x Y
-				if ((Y & 0x00000200) != 0)
-					Y = Y | 0xFFFFFC00;
-				ele_C = ((Y * ele_D)>>8)&0x000003FF;
-
-				//wirte new elements A, C, D to regC80 and regC94, element B is always 0
-				value32 = (ele_D<<22)|((ele_C&0x3F)<<16)|ele_A;
-				PHY_SetBBReg(priv, rOFDM0_XATxIQImbalance, bMaskDWord, value32);
-
-				value32 = (ele_C&0x000003C0)>>6;
-				PHY_SetBBReg(priv, rOFDM0_XCTxAFE, bMaskH4Bits, value32);
-
-				value32 = ((X * ele_D)>>7)&0x01;
-				PHY_SetBBReg(priv, rOFDM0_ECCAThreshold, BIT(24), value32);
-
-			}	else	{
-				PHY_SetBBReg(priv, rOFDM0_XATxIQImbalance, bMaskDWord, OFDMSwingTable[(unsigned int)OFDM_index[0]]);
-				PHY_SetBBReg(priv, rOFDM0_XCTxAFE, bMaskH4Bits, 0x00);
-				PHY_SetBBReg(priv, rOFDM0_ECCAThreshold, BIT(24), 0x00);
-			}
-
-
-			set_CCK_swing_index(priv, CCK_index);
-
-
-			if(is2T) {
-				ele_D = (OFDMSwingTable[(unsigned int)OFDM_index[1]] & 0xFFC00000)>>22;
-				X = priv->pshare->RegEB4;
-				Y = priv->pshare->RegEBC;
-
-				if(X != 0){
-					if ((X & 0x00000200) != 0)	//consider minus
-						X = X | 0xFFFFFC00;
-					ele_A = ((X * ele_D)>>8)&0x000003FF;
-
-					//new element C = element D x Y
-					if ((Y & 0x00000200) != 0)
-						Y = Y | 0xFFFFFC00;
-					ele_C = ((Y * ele_D)>>8)&0x00003FF;
-
-					//wirte new elements A, C, D to regC88 and regC9C, element B is always 0
-					value32=(ele_D<<22)|((ele_C&0x3F)<<16) |ele_A;
-					PHY_SetBBReg(priv, rOFDM0_XBTxIQImbalance, bMaskDWord, value32);
-
-					value32 = (ele_C&0x000003C0)>>6;
-					PHY_SetBBReg(priv, rOFDM0_XDTxAFE, bMaskH4Bits, value32);
-
-					value32 = ((X * ele_D)>>7)&0x01;
-					PHY_SetBBReg(priv, rOFDM0_ECCAThreshold, BIT(28), value32);
-
-				} else{
-					PHY_SetBBReg(priv, rOFDM0_XBTxIQImbalance, bMaskDWord, OFDMSwingTable[(unsigned int)OFDM_index[1]]);
-					PHY_SetBBReg(priv, rOFDM0_XDTxAFE, bMaskH4Bits, 0x00);
-					PHY_SetBBReg(priv, rOFDM0_ECCAThreshold, BIT(28), 0x00);
-				}
-			}
-		}
-
-		if(delta_IQK > 3) {
-			priv->pshare->ThermalValue_IQK = ThermalValue;
-			PHY_IQCalibrate(priv);
-		}
-
-		//update thermal meter value
-		priv->pshare->ThermalValue = ThermalValue;
-
-	}
-}
-
-
 #ifdef ADD_TX_POWER_BY_CMD
 static void assign_txpwr_offset(struct rtl8192cd_priv *priv)
 {
@@ -6538,7 +6977,7 @@ void reload_txpwr_pg(struct rtl8192cd_priv *priv)
 {
 	PHY_ConfigBBWithParaFile(priv, PHYREG_PG);
 
-#ifdef HIGH_POWER_EXT_PA
+#if 0 //def HIGH_POWER_EXT_PA
 	if (!priv->pshare->rf_ft_var.use_ext_pa)
 #endif
 	{
@@ -6552,6 +6991,19 @@ void reload_txpwr_pg(struct rtl8192cd_priv *priv)
 	*(unsigned int *)(&priv->pshare->phw->OFDMTxAgcOffset_A[4]) = cpu_to_be32(RTL_R32(rTxAGC_A_Rate54_24));
 	*(unsigned int *)(&priv->pshare->phw->CCKTxAgc_A[0]) = cpu_to_be32((RTL_R32(rTxAGC_A_CCK11_2_B_CCK11) & 0xffffff00)
 		| RTL_R8(rTxAGC_A_CCK1_Mcs32 + 1));
+	
+#if defined(CONFIG_RTL_92D_SUPPORT)&& defined(CONFIG_RTL_92D_DMDP)
+	if (priv->pmib->dot11RFEntry.macPhyMode==DUALMAC_DUALPHY && priv->pshare->wlandev_idx == 1) {
+		*(unsigned int *)(&priv->pshare->phw->MCSTxAgcOffset_A[0])	= cpu_to_be32(RTL_R32(rTxAGC_B_Mcs03_Mcs00));
+		*(unsigned int *)(&priv->pshare->phw->MCSTxAgcOffset_A[4])	= cpu_to_be32(RTL_R32(rTxAGC_B_Mcs07_Mcs04));
+		*(unsigned int *)(&priv->pshare->phw->MCSTxAgcOffset_A[8])	= cpu_to_be32(RTL_R32(rTxAGC_B_Mcs11_Mcs08));
+		*(unsigned int *)(&priv->pshare->phw->MCSTxAgcOffset_A[12]) = cpu_to_be32(RTL_R32(rTxAGC_B_Mcs15_Mcs12));
+		*(unsigned int *)(&priv->pshare->phw->OFDMTxAgcOffset_A[0]) = cpu_to_be32(RTL_R32(rTxAGC_B_Rate18_06));
+		*(unsigned int *)(&priv->pshare->phw->OFDMTxAgcOffset_A[4]) = cpu_to_be32(RTL_R32(rTxAGC_B_Rate54_24));
+		*(unsigned int *)(&priv->pshare->phw->CCKTxAgc_A[0]) = cpu_to_be32((RTL_R8(rTxAGC_A_CCK11_2_B_CCK11) << 24)
+			| (RTL_R32(rTxAGC_B_CCK5_1_Mcs32) >> 8));
+	}
+#endif	
 
 	*(unsigned int *)(&priv->pshare->phw->MCSTxAgcOffset_B[0])	= cpu_to_be32(RTL_R32(rTxAGC_B_Mcs03_Mcs00));
 	*(unsigned int *)(&priv->pshare->phw->MCSTxAgcOffset_B[4])	= cpu_to_be32(RTL_R32(rTxAGC_B_Mcs07_Mcs04));
@@ -6786,6 +7238,7 @@ int rtl8192cd_init_hw_PCI(struct rtl8192cd_priv *priv)
 			if (val32)
 				return -1;
 
+#ifdef CONFIG_RTL_92C_SUPPORT
 			if(IS_UMC_A_CUT_88C(priv))	{
 				PHY_SetRFReg(priv, RF92CD_PATH_A, RF_RX_G1, bMask20Bits, 0x30255);
 				PHY_SetRFReg(priv, RF92CD_PATH_A, RF_RX_G2, bMask20Bits, 0x50a00);
@@ -6793,13 +7246,13 @@ int rtl8192cd_init_hw_PCI(struct rtl8192cd_priv *priv)
 
 				PHY_SetRFReg(priv, RF92CD_PATH_A, 0x1e, bMask20Bits, 0x03 |(PHY_QueryRFReg(priv, RF92CD_PATH_A, 0x1e, bMaskDWord, 1)&0xff0f0));
 				PHY_SetRFReg(priv, RF92CD_PATH_A, 0x1f, bMask20Bits, 0x200|(PHY_QueryRFReg(priv, RF92CD_PATH_A, 0x1f, bMaskDWord, 1)&0xff0ff));
-
+#if 0
 				PHY_SetRFReg(priv, RF92CD_PATH_A, 0x0c, bMask20Bits, 0x0008992f);
 				PHY_SetRFReg(priv, RF92CD_PATH_A, 0x0a, bMask20Bits, 0x0001aef1);
 				PHY_SetRFReg(priv, RF92CD_PATH_A, 0x15, bMask20Bits, 0x0008f425);
-
+#endif
 			}
-
+#endif
 		}
 	}
 
@@ -7130,7 +7583,6 @@ int rtl8192cd_init_hw_PCI(struct rtl8192cd_priv *priv)
 #endif
 	//here add if legacy WEP
 	// if 1x is enabled, do not set default key, david
-//#if 0	// marked by victoryman, use pairwise key at present, 20070627
 #ifdef USE_WEP_DEFAULT_KEY
 #ifdef MBSSID
 	if (!(OPMODE & WIFI_AP_STATE) || !priv->pmib->miscEntry.vap_enable)
@@ -7157,7 +7609,7 @@ int rtl8192cd_init_hw_PCI(struct rtl8192cd_priv *priv)
 //	delay_ms(1);
 //	while(RTL_R32(0x2A0) != 0){};
 	//RTL_W16(TBTT_PROHIBIT, 0xc804);
-	if (GET_ROOT(priv)->pmib->miscEntry.vap_enable)
+	if ((GET_ROOT(priv)->pmib->miscEntry.vap_enable) || (priv->pmib->dot11StationConfigEntry.dot11BeaconPeriod <= 40))
 		RTL_W32(TBTT_PROHIBIT, 0x1df04);
 	else
 		RTL_W32(TBTT_PROHIBIT, 0x40004);
@@ -7172,7 +7624,13 @@ int rtl8192cd_init_hw_PCI(struct rtl8192cd_priv *priv)
 #endif
 		RTL_W8(DRVERLYINT, 10);
 	RTL_W8(BCNDMATIM, 1);
-	RTL_W16(ATIMWND, 5);
+/*
+	if (priv->pshare->rf_ft_var.bcast_to_dzq)
+		RTL_W16(ATIMWND, 0x0a);
+	else
+		RTL_W16(ATIMWND, 5);
+*/
+	RTL_W16(ATIMWND, 1);
 /*
 	if (!((OPMODE & WIFI_AP_STATE)
 #if defined(WDS) && defined(CONFIG_RTK_MESH)
@@ -7195,6 +7653,7 @@ int rtl8192cd_init_hw_PCI(struct rtl8192cd_priv *priv)
 		RTL_W8(DRVERLYINT, 6);
 #endif
 
+#ifdef CONFIG_RTL_92C_SUPPORT
 	if (IS_TEST_CHIP(priv) && ((GET_CHIP_VER(priv)==VERSION_8188C) || (GET_CHIP_VER(priv)==VERSION_8192C))) {
 		RTL_W8(BCN_CTRL, 0);
 		RTL_W8(0x553, 1);
@@ -7206,7 +7665,9 @@ int rtl8192cd_init_hw_PCI(struct rtl8192cd_priv *priv)
 		if (OPMODE & WIFI_ADHOC_STATE)
 			RTL_W8(BCN_MAX_ERR, 0xff);
 #endif
-	} else {
+	} else 
+#endif
+	{
 		RTL_W8(BCN_CTRL, DIS_TSF_UPDATE_N|  DIS_SUB_STATE_N  );
 		RTL_W8(BCN_MAX_ERR, 0xff);
 		RTL_W16(0x518, 0);
@@ -7217,7 +7678,7 @@ int rtl8192cd_init_hw_PCI(struct rtl8192cd_priv *priv)
 #ifdef MP_TEST
 		if (!priv->pshare->rf_ft_var.mp_specific)
 #endif
-		RTL_W8(BCN_CTRL, RTL_R8(BCN_CTRL) | EN_BCN_FUNCTION | EN_TXBCN_RPT  );
+		RTL_W8(BCN_CTRL, RTL_R8(BCN_CTRL) | EN_BCN_FUNCTION | EN_TXBCN_RPT);
 	}
 
 
@@ -7247,18 +7708,46 @@ int rtl8192cd_init_hw_PCI(struct rtl8192cd_priv *priv)
 	IMR_BcnInt/* | IMR_TXFOVW*/ /*| IMR_TBDOK | IMR_TBDER*/);// IMR_ROK | IMR_BcnInt | IMR_RDU | IMR_RXFOVW | IMR_RXCMDOK;
 #endif
 	//priv->pshare->InterruptMask = HIMR_ROK | HIMR_BCNDMA0 | HIMR_RDU | HIMR_RXFOVW;
-	priv->pshare->InterruptMask = HIMR_ROK | HIMR_BCNDMA0 | HIMR_RXFOVW;
+
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv)==VERSION_8188E) {
+		priv->pshare->InterruptMask = HIMR_88E_ROK | HIMR_88E_HISR1_IND_INT;
+		priv->pshare->InterruptMaskExt = HIMRE_88E_RXFOVW;
+	} else
+#endif
+	{
+		priv->pshare->InterruptMask = HIMR_ROK | HIMR_BCNDMA0 | HIMR_RXFOVW;
+		priv->pshare->InterruptMaskExt = 0;
+	}
+
 #ifdef MP_TEST
-	if (priv->pshare->rf_ft_var.mp_specific)
-		priv->pshare->InterruptMask	|= HIMR_BEDOK;
+	if (priv->pshare->rf_ft_var.mp_specific) {
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv)==VERSION_8188E)
+			priv->pshare->InterruptMask |= HIMR_88E_BEDOK;
+		else
+#endif
+			priv->pshare->InterruptMask	|= HIMR_BEDOK;
+	}
 #endif
-	priv->pshare->InterruptMaskExt = 0;
 
-	if (opmode & WIFI_AP_STATE)
-		priv->pshare->InterruptMask |= HIMR_BCNDOK0 | HIMR_TXBCNERR;
+	if (opmode & WIFI_AP_STATE) {
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv)==VERSION_8188E)
+			priv->pshare->InterruptMask |= HIMR_88E_BcnInt | HIMR_88E_TBDOK | HIMR_88E_TBDER;
+		else
+#endif
+			priv->pshare->InterruptMask |= HIMR_BCNDOK0 | HIMR_TXBCNERR;
+	}
 #ifdef CLIENT_MODE
-	else if (opmode & WIFI_ADHOC_STATE)
-		priv->pshare->InterruptMaskExt |= (HIMR_TXBCNERR | HIMR_TXBCNOK);
+	else if (opmode & WIFI_ADHOC_STATE) {
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv)==VERSION_8188E)
+			priv->pshare->InterruptMaskExt |= HIMR_88E_BcnInt | HIMR_88E_TBDOK | HIMR_88E_TBDER;
+		else
+#endif
+			priv->pshare->InterruptMaskExt |= (HIMR_TXBCNERR | HIMR_TXBCNOK);
+	}
 #endif
 
 #endif
@@ -7277,37 +7766,51 @@ int rtl8192cd_init_hw_PCI(struct rtl8192cd_priv *priv)
 			LoadPktSize, PCI_DMA_TODEVICE);
 */
 
-	/* currently need not to download fw	*/
-	rtl8192cd_ReadFwHdr(priv);
+#if defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT)
+	if (
+#ifdef CONFIG_RTL_92C_SUPPORT
+		(GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)
+#endif
+#ifdef CONFIG_RTL_92D_SUPPORT
+#ifdef CONFIG_RTL_92C_SUPPORT
+		||
+#endif
+		(GET_CHIP_VER(priv)==VERSION_8192D)
+#endif
+		) {
+		/* currently need not to download fw	*/
+		rtl8192cd_ReadFwHdr(priv);
 
-	while(dwnRetry-- && !fwStatus) {
+		while(dwnRetry-- && !fwStatus) {
 #ifdef CONFIG_RTL_92D_SUPPORT
-		if (GET_CHIP_VER(priv)==VERSION_8192D)
-			fwStatus = Load_92D_Firmware(priv);
+			if (GET_CHIP_VER(priv)==VERSION_8192D)
+				fwStatus = Load_92D_Firmware(priv);
 #endif
 #ifdef CONFIG_RTL_92C_SUPPORT
-		if ((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C))
-			fwStatus = Load_92C_Firmware(priv);
+			if ((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C))
+				fwStatus = Load_92C_Firmware(priv);
 #endif
-		delay_ms(20);
-	};
-	if(fwStatus) {
-		DEBUG_INFO("Load firmware successful!\n");
-	}
-	else {
-		DEBUG_INFO("Load firmware check!\n");
+			delay_ms(20);
+		};
+		if(fwStatus) {
+			DEBUG_INFO("Load firmware successful!\n");
+		}
+		else {
+			DEBUG_INFO("Load firmware check!\n");
 #ifdef PCIE_POWER_SAVING
-		priv->pshare->rf_ft_var.power_save &= ~( L1_en|L2_en);
+			priv->pshare->rf_ft_var.power_save &= ~( L1_en|L2_en);
 #endif
 #ifdef CONFIG_RTL_92D_SUPPORT
-		if (GET_CHIP_VER(priv)==VERSION_8192D){
-			if (RTL_R8(0x1c5)==0xE0){
-				DEBUG_INFO("RTL8192D part number failed!!\n");
-				return -1;
+			if (GET_CHIP_VER(priv)==VERSION_8192D){
+				if (RTL_R8(0x1c5)==0xE0){
+					DEBUG_INFO("RTL8192D part number failed!!\n");
+					return -1;
+				}
 			}
-		}
 #endif
+		}
 	}
+#endif
 
 /*
 	MacConfigAfterFwDownload(priv);
@@ -7333,6 +7836,12 @@ int rtl8192cd_init_hw_PCI(struct rtl8192cd_priv *priv)
 		} while (delay_count);
 	}
 
+#ifdef P2P_SUPPORT
+	if(OPMODE&WIFI_P2P_SUPPORT){
+		P2P_DEBUG("managment frame G only \n");
+		set_RATid_cmd(priv, 0, ARFR_G_ONLY, val32);	// under P2P mode
+	}else
+#endif
 #ifdef CONFIG_RTL_92D_SUPPORT
 	if (GET_CHIP_VER(priv)==VERSION_8192D) {
 		if (priv->pmib->dot11RFEntry.phyBandSelect & PHY_BAND_5G) {
@@ -7344,13 +7853,16 @@ int rtl8192cd_init_hw_PCI(struct rtl8192cd_priv *priv)
 		else
 			set_RATid_cmd(priv, 0, ARFR_BMC, val32);
 	}
+#ifdef CONFIG_RTL_92C_SUPPORT
 	else if ((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)){
                  set_RATid_cmd(priv, 0, ARFR_BMC, val32);
         }
+#endif
         else
-
 #endif
+	{
 		set_RATid_cmd(priv, 0, ARFR_BMC, val32);
+	}
 
 //	kfree(priv->pshare->txcmd_buf);
 
@@ -7366,7 +7878,15 @@ int rtl8192cd_init_hw_PCI(struct rtl8192cd_priv *priv)
 	}
 
 	//enable interrupt
-	RTL_W32(HIMR, priv->pshare->InterruptMask);
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv)==VERSION_8188E) {
+		RTL_W32(REG_88E_HIMR, priv->pshare->InterruptMask);
+		RTL_W32(REG_88E_HIMRE, priv->pshare->InterruptMaskExt);
+	} else
+#endif
+	{
+		RTL_W32(HIMR, priv->pshare->InterruptMask);
+	}
 //	RTL_W32(IMR+4, priv->pshare->InterruptMaskExt);
 //	RTL_W32(IMR, 0xffffffff);
 //	RTL_W8(IMR+4, 0x3f);
@@ -7385,29 +7905,46 @@ int rtl8192cd_init_hw_PCI(struct rtl8192cd_priv *priv)
 			priv->pshare->CurrentChannelBW = HT_CHANNEL_WIDTH_20;
 	}
 
-#ifdef HIGH_POWER_EXT_PA
-	if (!priv->pshare->rf_ft_var.use_ext_pa)
+#ifdef SUPPORT_RTL8188E_TC
+	if (!((GET_CHIP_VER(priv)==VERSION_8188E) && IS_TEST_CHIP(priv)))
 #endif
 	{
-	// get default Tx AGC offset
-	*(unsigned int *)(&priv->pshare->phw->MCSTxAgcOffset_A[0])  = cpu_to_be32(RTL_R32(rTxAGC_A_Mcs03_Mcs00));
-	*(unsigned int *)(&priv->pshare->phw->MCSTxAgcOffset_A[4])  = cpu_to_be32(RTL_R32(rTxAGC_A_Mcs07_Mcs04));
-	*(unsigned int *)(&priv->pshare->phw->MCSTxAgcOffset_A[8])  = cpu_to_be32(RTL_R32(rTxAGC_A_Mcs11_Mcs08));
-	*(unsigned int *)(&priv->pshare->phw->MCSTxAgcOffset_A[12]) = cpu_to_be32(RTL_R32(rTxAGC_A_Mcs15_Mcs12));
-	*(unsigned int *)(&priv->pshare->phw->OFDMTxAgcOffset_A[0]) = cpu_to_be32(RTL_R32(rTxAGC_A_Rate18_06));
-	*(unsigned int *)(&priv->pshare->phw->OFDMTxAgcOffset_A[4]) = cpu_to_be32(RTL_R32(rTxAGC_A_Rate54_24));
-	*(unsigned int *)(&priv->pshare->phw->CCKTxAgc_A[0]) = cpu_to_be32((RTL_R32(rTxAGC_A_CCK11_2_B_CCK11) & 0xffffff00)
-		| RTL_R8(rTxAGC_A_CCK1_Mcs32 + 1));
+#ifdef HIGH_POWER_EXT_PA
+		if (!priv->pshare->rf_ft_var.use_ext_pa)
+#endif
+		{
+			// get default Tx AGC offset
+			*(unsigned int *)(&priv->pshare->phw->MCSTxAgcOffset_A[0])  = cpu_to_be32(RTL_R32(rTxAGC_A_Mcs03_Mcs00));
+			*(unsigned int *)(&priv->pshare->phw->MCSTxAgcOffset_A[4])  = cpu_to_be32(RTL_R32(rTxAGC_A_Mcs07_Mcs04));
+			*(unsigned int *)(&priv->pshare->phw->MCSTxAgcOffset_A[8])  = cpu_to_be32(RTL_R32(rTxAGC_A_Mcs11_Mcs08));
+			*(unsigned int *)(&priv->pshare->phw->MCSTxAgcOffset_A[12]) = cpu_to_be32(RTL_R32(rTxAGC_A_Mcs15_Mcs12));
+			*(unsigned int *)(&priv->pshare->phw->OFDMTxAgcOffset_A[0]) = cpu_to_be32(RTL_R32(rTxAGC_A_Rate18_06));
+			*(unsigned int *)(&priv->pshare->phw->OFDMTxAgcOffset_A[4]) = cpu_to_be32(RTL_R32(rTxAGC_A_Rate54_24));
+			*(unsigned int *)(&priv->pshare->phw->CCKTxAgc_A[0]) = cpu_to_be32((RTL_R32(rTxAGC_A_CCK11_2_B_CCK11) & 0xffffff00)
+				| RTL_R8(rTxAGC_A_CCK1_Mcs32 + 1));
 
-	*(unsigned int *)(&priv->pshare->phw->MCSTxAgcOffset_B[0])  = cpu_to_be32(RTL_R32(rTxAGC_B_Mcs03_Mcs00));
-	*(unsigned int *)(&priv->pshare->phw->MCSTxAgcOffset_B[4])  = cpu_to_be32(RTL_R32(rTxAGC_B_Mcs07_Mcs04));
-	*(unsigned int *)(&priv->pshare->phw->MCSTxAgcOffset_B[8])  = cpu_to_be32(RTL_R32(rTxAGC_B_Mcs11_Mcs08));
-	*(unsigned int *)(&priv->pshare->phw->MCSTxAgcOffset_B[12]) = cpu_to_be32(RTL_R32(rTxAGC_B_Mcs15_Mcs12));
-	*(unsigned int *)(&priv->pshare->phw->OFDMTxAgcOffset_B[0]) = cpu_to_be32(RTL_R32(rTxAGC_B_Rate18_06));
-	*(unsigned int *)(&priv->pshare->phw->OFDMTxAgcOffset_B[4]) = cpu_to_be32(RTL_R32(rTxAGC_B_Rate54_24));
-	*(unsigned int *)(&priv->pshare->phw->CCKTxAgc_B[0]) = cpu_to_be32((RTL_R8(rTxAGC_A_CCK11_2_B_CCK11) << 24)
-		| (RTL_R32(rTxAGC_B_CCK5_1_Mcs32) >> 8));
+#if defined(CONFIG_RTL_92D_SUPPORT)&& defined(CONFIG_RTL_92D_DMDP)
+			if (priv->pmib->dot11RFEntry.macPhyMode==DUALMAC_DUALPHY && priv->pshare->wlandev_idx == 1) {
+				*(unsigned int *)(&priv->pshare->phw->MCSTxAgcOffset_A[0])	= cpu_to_be32(RTL_R32(rTxAGC_B_Mcs03_Mcs00));
+				*(unsigned int *)(&priv->pshare->phw->MCSTxAgcOffset_A[4])	= cpu_to_be32(RTL_R32(rTxAGC_B_Mcs07_Mcs04));
+				*(unsigned int *)(&priv->pshare->phw->MCSTxAgcOffset_A[8])	= cpu_to_be32(RTL_R32(rTxAGC_B_Mcs11_Mcs08));
+				*(unsigned int *)(&priv->pshare->phw->MCSTxAgcOffset_A[12]) = cpu_to_be32(RTL_R32(rTxAGC_B_Mcs15_Mcs12));
+				*(unsigned int *)(&priv->pshare->phw->OFDMTxAgcOffset_A[0]) = cpu_to_be32(RTL_R32(rTxAGC_B_Rate18_06));
+				*(unsigned int *)(&priv->pshare->phw->OFDMTxAgcOffset_A[4]) = cpu_to_be32(RTL_R32(rTxAGC_B_Rate54_24));
+				*(unsigned int *)(&priv->pshare->phw->CCKTxAgc_A[0]) = cpu_to_be32((RTL_R8(rTxAGC_A_CCK11_2_B_CCK11) << 24)
+					| (RTL_R32(rTxAGC_B_CCK5_1_Mcs32) >> 8));
+			}
+#endif	
 
+			*(unsigned int *)(&priv->pshare->phw->MCSTxAgcOffset_B[0])  = cpu_to_be32(RTL_R32(rTxAGC_B_Mcs03_Mcs00));
+			*(unsigned int *)(&priv->pshare->phw->MCSTxAgcOffset_B[4])  = cpu_to_be32(RTL_R32(rTxAGC_B_Mcs07_Mcs04));
+			*(unsigned int *)(&priv->pshare->phw->MCSTxAgcOffset_B[8])  = cpu_to_be32(RTL_R32(rTxAGC_B_Mcs11_Mcs08));
+			*(unsigned int *)(&priv->pshare->phw->MCSTxAgcOffset_B[12]) = cpu_to_be32(RTL_R32(rTxAGC_B_Mcs15_Mcs12));
+			*(unsigned int *)(&priv->pshare->phw->OFDMTxAgcOffset_B[0]) = cpu_to_be32(RTL_R32(rTxAGC_B_Rate18_06));
+			*(unsigned int *)(&priv->pshare->phw->OFDMTxAgcOffset_B[4]) = cpu_to_be32(RTL_R32(rTxAGC_B_Rate54_24));
+			*(unsigned int *)(&priv->pshare->phw->CCKTxAgc_B[0]) = cpu_to_be32((RTL_R8(rTxAGC_A_CCK11_2_B_CCK11) << 24)
+				| (RTL_R32(rTxAGC_B_CCK5_1_Mcs32) >> 8));
+		}
 	}
 #ifdef ADD_TX_POWER_BY_CMD
 	assign_txpwr_offset(priv);
@@ -7418,6 +7955,10 @@ int rtl8192cd_init_hw_PCI(struct rtl8192cd_priv *priv)
 		PHY_ConfigTXLmtWithParaFile(priv);
 #endif
 
+#ifdef _TRACKING_TABLE_FILE
+		PHY_ConfigTXPwrTrackingWithParaFile(priv);
+#endif
+
 
 	if ((priv->pmib->dot11RFEntry.ther < 0x07) || (priv->pmib->dot11RFEntry.ther > 0x1d)) {
 		DEBUG_ERR("TPT: unreasonable target ther %d, disable tpt\n", priv->pmib->dot11RFEntry.ther);
@@ -7456,11 +7997,19 @@ int rtl8192cd_init_hw_PCI(struct rtl8192cd_priv *priv)
 		SwBWMode(priv, priv->pshare->CurrentChannelBW, priv->pshare->offset_2nd_chan);
 		SwChnl(priv, priv->pmib->dot11RFEntry.dot11channel, priv->pshare->offset_2nd_chan);
 
+		if (priv->pmib->dot11RFEntry.macPhyMode == SINGLEMAC_SINGLEPHY) 			
+			clnt_ss_check_band(priv, priv->pmib->dot11RFEntry.dot11channel);			
+
 	/*
 	 *	IQK
 	 */
 		PHY_IQCalibrate(priv);
 
+#ifdef DPK_92D
+		if (priv->pmib->dot11RFEntry.phyBandSelect==PHY_BAND_5G && priv->pshare->rf_ft_var.dpk_on)
+			PHY_DPCalibrate(priv);
+#endif
+
 #ifdef SMART_CONCURRENT_92D
 		if (priv->pmib->dot11RFEntry.smcc==1 && priv->pmib->dot11RFEntry.macPhyMode != SINGLEMAC_SINGLEPHY){
 			if((priv->MAC_info = (struct SMCC_MAC_Info_Tbl*)kmalloc(sizeof(struct SMCC_MAC_Info_Tbl), GFP_ATOMIC)) == NULL) {
@@ -7509,9 +8058,28 @@ int rtl8192cd_init_hw_PCI(struct rtl8192cd_priv *priv)
 	}
 #endif // CONFIG_RTL_92D_SUPPORT
 
+#if defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_88E_SUPPORT)
+	if (
 #ifdef CONFIG_RTL_92C_SUPPORT
-	if ((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)) {
-		PHY_IQCalibrate(priv);		// IQK_92C IQK_88c
+		(GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)
+#endif
+#ifdef CONFIG_RTL_88E_SUPPORT
+#ifdef CONFIG_RTL_92C_SUPPORT
+		||
+#endif
+		(GET_CHIP_VER(priv) == VERSION_8188E)
+#endif
+		) {
+
+		if(GET_CHIP_VER(priv) == VERSION_8188E)
+		{
+			// switch to channel 7 before doing IQK
+			printk("Switch to channel 7 before doing 88E IQK\n");
+			SwBWMode(priv, priv->pshare->CurrentChannelBW, priv->pshare->offset_2nd_chan);
+			SwChnl(priv, 7, priv->pshare->offset_2nd_chan);
+		}
+
+		PHY_IQCalibrate(priv);		// IQK_92C IQK_88c IQK_88e
 
 #if defined(__LINUX_2_6__) && !defined(NOT_RTK_BSP)
 		REG32(_WDTCNR_) |=  1 << 23;
@@ -7530,10 +8098,11 @@ int rtl8192cd_init_hw_PCI(struct rtl8192cd_priv *priv)
 		 */
 		if (priv->pmib->dot11BssType.net_work_type & (WIRELESS_11G |WIRELESS_11N)) {
 			if ((priv->pmib->dot11StationConfigEntry.autoRate) || !(priv->pmib->dot11StationConfigEntry.fixedTxRate & 0xf)) {
-
+#ifdef CONFIG_RTL_92C_SUPPORT
 				if( IS_UMC_A_CUT_88C(priv) || GET_CHIP_VER(priv) == VERSION_8192C )
 					PHY_SetRFReg(priv, 0, 0x26, bMask20Bits, 0x4f000);
 				else
+#endif
 					PHY_SetRFReg(priv, 0, 0x26, bMask20Bits, 0x4f200);
 
 //				RTL_W32(RRSR, RTL_R32(RRSR) & ~(0x0c));
@@ -7544,7 +8113,7 @@ int rtl8192cd_init_hw_PCI(struct rtl8192cd_priv *priv)
 			PHY_SetRFReg(priv, 0, 0x26, bMask20Bits, 0x0f400);
 		}
 	}
-#endif // CONFIG_RTL_92C_SUPPORT
+#endif // CONFIG_RTL_92C_SUPPORT || CONFIG_RTL_88E_SUPPORT
 /*
 	if(priv->pshare->rf_ft_var.ofdm_1ss_oneAnt == 1){// use one PATH for ofdm and 1SS
 		Switch_1SS_Antenna(priv, 2);
@@ -7574,6 +8143,15 @@ int rtl8192cd_init_hw_PCI(struct rtl8192cd_priv *priv)
 	priv->pshare->digDeadPoint = 0;
 	priv->pshare->digDeadPointHitCount = 0;
 
+#ifdef INTERFERENCE_CONTROL
+	set_DIG_state(priv, 1);		// DIG on
+
+	if (priv->pshare->rf_ft_var.nbi_filter_enable) {
+		priv->pshare->phw->nbi_filter_on = 1;
+		RTL_W16(rOFDM0_RxDSP, RTL_R16(rOFDM0_RxDSP) | BIT(9));		// NBI on
+	}
+#endif
+
 // CCK path A Tx
 #ifdef CONFIG_POCKET_ROUTER_SUPPORT
 #ifdef CONFIG_RTL_92D_SUPPORT
@@ -7585,7 +8163,7 @@ int rtl8192cd_init_hw_PCI(struct rtl8192cd_priv *priv)
 	}
 #endif
 
-#ifdef CONFIG_RTL_8198
+#if defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 	RTL_W8(AGGR_BK_TIME, 0x18);
 	RTL_W16(0x4ca, 0x0a0a);
 //	RTL_W32(RESP_SIFS_CCK, 0x0e0e0a0a);
@@ -7599,13 +8177,17 @@ int rtl8192cd_init_hw_PCI(struct rtl8192cd_priv *priv)
 	//CBN debug
 	if (GET_CHIP_VER(priv)==VERSION_8192D) {
 #ifndef SMART_CONCURRENT_92D
-		RTL_W32(RD_CTRL, RTL_R32(RD_CTRL)|BIT(13)); // enable force tx beacon
+//		RTL_W32(RD_CTRL, RTL_R32(RD_CTRL)|BIT(13)); // enable force tx beacon
 		RTL_W8(BCN_MAX_ERR, 0); // tx beacon error threshold
 #endif
-		RTL_W16(EIFS, 0x0040);	// eifs < tbtt_prohibit
+//		RTL_W16(EIFS, 0x0040);	// eifs < tbtt_prohibit
+		if (opmode & WIFI_AP_STATE)
+			RTL_W16(rFPGA0_RFTiming1, 0x5388);
 	}
 #endif
 
+	RTL_W16(EIFS, 0x0040);	// eifs = 40 us
+
 	RTL_W32(0x350, RTL_R32(0x350) | BIT(26));	// tx status check
 
 #ifdef HIGH_POWER_EXT_PA
@@ -7620,7 +8202,7 @@ int rtl8192cd_init_hw_PCI(struct rtl8192cd_priv *priv)
 #endif
 
 #if defined(SW_ANT_SWITCH) || defined(HW_ANT_SWITCH)
-	priv->pmib->dot11RFEntry.trswitch = 1;
+//	priv->pmib->dot11RFEntry.trswitch = 1;
 #endif
 
 	if (priv->pmib->dot11RFEntry.trswitch)
@@ -7636,6 +8218,41 @@ int rtl8192cd_init_hw_PCI(struct rtl8192cd_priv *priv)
         }
 #endif
 
+	if (get_rf_mimo_mode(priv) == MIMO_2T2R)
+	{
+		if (priv->pmib->dot11RFEntry.tx2path)
+		{
+			RTL_W32(0x90C, 0x83321333);
+			RTL_W32(0x80C, RTL_R32(0x80C) & ~BIT(31));
+			RTL_W8(0x6D8, RTL_R8(0x6D8) | 0x3F);
+
+			RTL_W8(0xA07, 0xC1);
+			RTL_W8(0xA11, RTL_R8(0xA11) & ~BIT(5));
+			RTL_W8(0xA20, (RTL_R8(0xA20) & ~BIT(5)) | BIT(4));
+			RTL_W8(0xA2E, RTL_R8(0xA2E) | BIT(3) | BIT(2));
+			RTL_W8(0xA2F, (RTL_R8(0xA2F) & ~BIT(5)) | BIT(4));
+			RTL_W8(0xA75, RTL_R8(0xA75) | BIT(0));
+			RTL_W32(0xC8C, 0xa0240000);
+			RTL_W8(0x800, RTL_R8(0x800) & ~BIT(1));
+		}
+
+		// TX Beamforming
+		if (priv->pmib->dot11RFEntry.txbf)
+			PHY_SetBBReg(priv, 0x90C, BIT(30), 1);
+		else
+			PHY_SetBBReg(priv, 0x90C, BIT(30), 0);
+	}
+	else {
+		if (priv->pmib->dot11RFEntry.tx2path) {
+			DEBUG_INFO("Not 2T2R, disable tx2path\n");
+			priv->pmib->dot11RFEntry.tx2path = 0;
+		}
+		if (priv->pmib->dot11RFEntry.txbf) {
+			DEBUG_INFO("Not 2T2R, disable txbf\n");
+			priv->pmib->dot11RFEntry.txbf = 0;
+		}
+	}
+
 	DBFEXIT;
 
 	return 0;
@@ -7892,1099 +8509,377 @@ static int Load_92C_Firmware(struct rtl8192cd_priv *priv)
 		RTL_W8(0x28, 0x00);								\
 		RTL_W8(0x20, 0x50);								\
 		RTL_W8(0x26, 0x0E);								\
-	} while (FALSE);									\
-}
-
-void FirmwareSelfReset(struct rtl8192cd_priv *priv)
-{
-	unsigned char u1bTmp;
-	unsigned char  Delay = 100;
-	if(priv->pshare->fw_version > 0x21
-#ifdef CONFIG_RTL_92D_SUPPORT
-		|| GET_CHIP_VER(priv) == VERSION_8192D
-#endif
-		)	{
-		RTL_W32(FWIMR, 0x20);
-		RTL_W8(REG_HMETFR+3, 0x20);
-	 	u1bTmp = RTL_R8( REG_SYS_FUNC_EN+1);
-	 	while(u1bTmp& BIT(2)) {
-		  	Delay--;
-		  	DEBUG_INFO("polling 0x03[2] Delay = %d \n", Delay);
-		  	if(Delay == 0)
-		   		break;
-		  	delay_us(50);
-		  	u1bTmp = RTL_R8( REG_SYS_FUNC_EN+1);
-		}
-		if((u1bTmp& BIT(2)) && (Delay == 0)) {
-			DEBUG_ERR("FirmwareSelfReset fail: 0x03 = %x\n", u1bTmp);
-		}else{
-			DEBUG_INFO("FirmwareSelfReset success: 0x03 = %x\n", u1bTmp);
-		}
-	}
-}
-
-//Return Value:
-//	1: Exception Case. Previous Operation is not terminated.
-//	0: Correct Case.
-int CheckNoResetHwExceptionCase(struct rtl8192cd_priv *priv)
-{
-	//Check PON register to decide
-	return ( (RTL_R16(SYS_FUNC_EN) & (FEN_MREGEN|FEN_DCORE))==(FEN_MREGEN|FEN_DCORE) );
-}
-
-int rtl8192cd_stop_hw(struct rtl8192cd_priv *priv)
-{
-	RTL_W32(HIMR, 0);
-	RTL_W16(HIMRE, 0);
-	RTL_W16(HIMRE+2, 0);
-	RTL_W32(CR, (RTL_R32(CR) & ~(NETYPE_Mask << NETYPE_SHIFT)) | ((NETYPE_NOLINK & NETYPE_Mask) << NETYPE_SHIFT));
-	
-	RTL_W8(RCR, 0);
-	RTL_W8(TXPAUSE, 0xff);
-	RTL_W8(CR, RTL_R8(CR) & ~(MACTXEN|MACRXEN));
-
-#ifdef CONFIG_RTL_92D_DMDP
-	if (priv->pshare->wlandev_idx == 0)
-		RTL_W8(RSV_MAC0_CTRL, RTL_R8(RSV_MAC0_CTRL)&(~MAC0_EN));
-	else
-		RTL_W8(RSV_MAC1_CTRL, RTL_R8(RSV_MAC1_CTRL)&(~MAC1_EN));
-
-	if ((RTL_R8(RSV_MAC0_CTRL)& MAC0_EN) || (RTL_R8(RSV_MAC1_CTRL)& MAC1_EN)) { // check if another interface exists
-		DEBUG_INFO("Another MAC exists, cannot stop hw!!\n");
-	} else
-#endif
-	{
-		//3 2.) ==== RF Off Sequence ====
-		phy_InitBBRFRegisterDefinition(priv);		// preparation for read/write RF register
-		
-		RTL_W8(TXPAUSE, 0xff);								// Pause MAC TX queue
-		PHY_SetRFReg(priv, RF92CD_PATH_A, 0x00, bMask20Bits, 0x00);	// disable RF
-		RTL_W8(RF_CTRL, 0x00);
-		RTL_W8(APSD_CTRL, 0x40);
-		RTL_W8(SYS_FUNC_EN, 0xe2);		// reset BB state machine
-		RTL_W8(SYS_FUNC_EN, 0xe0);		// reset BB state machine
-
-
-
-		//3 3.) ==== Reset digital sequence ====
-		if (RTL_R8(MCUFWDL) & BIT(1)) {
-			//Make sure that Host Recovery Interrupt is handled by 8051 ASAP.
-			RTL_W32(FSIMR, 0);				// clear FSIMR
-			RTL_W32(FWIMR, 0x20);			// clear FWIMR except HRCV_INT
-			RTL_W32(FTIMR, 0);				// clear FTIMR			
-			FirmwareSelfReset(priv);
-
-			//Clear FWIMR to guarantee if 8051 runs in ROM, it is impossible to run FWISR Interrupt handler
-			RTL_W32(FWIMR, 0x0);			// clear All FWIMR
-		} else {
-			//Critical Error.
-			//the operation that reset 8051 is necessary to be done by 8051
-			DEBUG_ERR("%s %d ERROR: (RTL_R8(MCUFWDL) & BIT(1))=0\n", __FUNCTION__, __LINE__);
-			DEBUG_ERR("%s %d ERROR: the operation that reset 8051 is necessary to be done by 8051,%d\n", __FUNCTION__, __LINE__, RTL_R8(MCUFWDL));
-		}
-
-		// ==== Reset digital sequence ====
-		RTL_W8(SYS_FUNC_EN+1, 0x51);								// reset MCU, MAC register, DCORE
-		RTL_W8(MCUFWDL, 0);											// reset MCU ready status
-
-		//3 4.) ==== Disable analog sequence ====
-		RTL_W8(AFE_PLL_CTRL, 0x80);			// disable PLL
-
-#if defined(CONFIG_RTL_92C_SUPPORT) && defined(CONFIG_RTL_92D_SUPPORT)
-		if (GET_CHIP_VER(priv) != VERSION_8192D)
-			RTL_W8(SPS0_CTRL, 0x2b);
-		else
-#endif
-		{
-			if(IS_UMC_B_CUT_88C(priv))
-				RTL_W8(SPS0_CTRL, 0x2b);
-			else		
-				RTL_W8(SPS0_CTRL, 0x23);
-		}
-#ifdef CONFIG_RTL8672
-		RTL_W8(AFE_XTAL_CTRL, RTL_R8(AFE_XTAL_CTRL)&~BIT(0));		// only for ADSL platform because 40M crystal is only used by WiFi chip // disable XTAL, if No BT COEX
-#endif
-		RTL_W8(APS_FSMCO+1, 0x10);
-		RTL_W8(RSV_CTRL0, 0x0e);				// lock ISO/CLK/Power control register
-
-		//3 5.) ==== interface into suspend ====
-//		RTL_W16(APS_FSMCO, (RTL_R16(APS_FSMCO) & 0x00ff) | (0x18 << 8));	// PCIe suspend mode
-	}
-	return SUCCESS;
-}
-
-
-void SwBWMode(struct rtl8192cd_priv *priv, unsigned int bandwidth, int offset)
-{
-	unsigned char regBwOpMode, regRRSR_RSC, nCur40MhzPrimeSC;
-	unsigned int eRFPath, curMaxRFPath, val;
-
-	DEBUG_INFO("SwBWMode(): Switch to %s bandwidth\n", bandwidth?"40MHz":"20MHz");
-
-#ifdef CONFIG_RTL_92D_DMDP
-	if (priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY)
-		curMaxRFPath = RF92CD_PATH_B;
-	else
-#endif
-		curMaxRFPath = RF92CD_PATH_MAX;
-
-	if (offset == 1)
-		nCur40MhzPrimeSC = 2;
-	else
-		nCur40MhzPrimeSC = 1;
-
-	//3 <1> Set MAC register
-	regBwOpMode = RTL_R8(BWOPMODE);
-	regRRSR_RSC = RTL_R8(RRSR+2);
-
-	switch (bandwidth)
-	{
-	case HT_CHANNEL_WIDTH_20:
-		regBwOpMode |= BW_OPMODE_20MHZ;
-		RTL_W8(BWOPMODE, regBwOpMode);
-		break;
-	case HT_CHANNEL_WIDTH_20_40:
-		regBwOpMode &= ~BW_OPMODE_20MHZ;
-		RTL_W8(BWOPMODE, regBwOpMode);
-		regRRSR_RSC = (regRRSR_RSC&0x90) | (nCur40MhzPrimeSC<<5);
-		RTL_W8(RRSR+2, regRRSR_RSC);
-
-		// Let 812cd_rx, re-assign value
-		if (priv->pshare->is_40m_bw){
-			priv->pshare->Reg_RRSR_2 = 0;
-			priv->pshare->Reg_81b = 0;
-		}
-		break;
-	default:
-		DEBUG_ERR("SwBWMode(): bandwidth mode error!\n");
-		return;
-		break;
-	}
-
-	//3 <2> Set PHY related register
-	switch (bandwidth)
-	{
-	case HT_CHANNEL_WIDTH_20:
-		PHY_SetBBReg(priv, rFPGA0_RFMOD, bRFMOD, 0x0);
-		PHY_SetBBReg(priv, rFPGA1_RFMOD, bRFMOD, 0x0);
-#ifdef CONFIG_RTL_92D_SUPPORT
-		if (GET_CHIP_VER(priv)==VERSION_8192D) {
-			PHY_SetBBReg(priv, rFPGA0_AnalogParameter2, BIT(11) | BIT(10), 3);// SET BIT10 BIT11  for receive cck
-		} else
-#endif
-		{
-			PHY_SetBBReg(priv, rFPGA0_AnalogParameter2, BIT(10), 1);
-		}
-		break;
-	case HT_CHANNEL_WIDTH_20_40:
-		PHY_SetBBReg(priv, rFPGA0_RFMOD, bRFMOD, 0x1);
-		PHY_SetBBReg(priv, rFPGA1_RFMOD, bRFMOD, 0x1);
-		// Set Control channel to upper or lower. These settings are required only for 40MHz
-		PHY_SetBBReg(priv, rCCK0_System, bCCKSideBand, (nCur40MhzPrimeSC>>1));
-		PHY_SetBBReg(priv, rOFDM1_LSTF, 0xC00, nCur40MhzPrimeSC);
-#ifdef CONFIG_RTL_92D_SUPPORT
-		if (GET_CHIP_VER(priv)==VERSION_8192D) {
-			PHY_SetBBReg(priv, rFPGA0_AnalogParameter2, BIT(11) | BIT(10), 0);// SET BIT10 BIT11  for receive cck
-		} else
-#endif
-		{
-			PHY_SetBBReg(priv, rFPGA0_AnalogParameter2, BIT(10), 0);
-		}
-		PHY_SetBBReg(priv, 0x818, (BIT(26)|BIT(27)), (nCur40MhzPrimeSC==2)?1:2);
-		break;
-	default:
-		DEBUG_ERR("SwBWMode(): bandwidth mode error! %d\n", __LINE__);
-		return;
-		break;
-	}
-
-	//3<3> Set RF related register
-	switch (bandwidth)
-	{
-	case HT_CHANNEL_WIDTH_20:
-		val = 1;
-		break;
-	case HT_CHANNEL_WIDTH_20_40:
-		val = 0;
-		break;
-	default:
-		DEBUG_ERR("SwBWMode(): bandwidth mode error! %d\n", __LINE__);
-		return;
-		break;
-	}
-
-	for(eRFPath = RF92CD_PATH_A; eRFPath < curMaxRFPath; eRFPath++)	{
-#ifdef CONFIG_RTL_92C_SUPPORT
-		if ((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)){
-			PHY_SetRFReg(priv, eRFPath, rRfChannel, (BIT(11)|BIT(10)), val);
-		}
-#endif
-#ifdef CONFIG_RTL_92D_SUPPORT
-		if (GET_CHIP_VER(priv) == VERSION_8192D){
-			priv->pshare->RegRF18[eRFPath] = RTL_SET_MASK(priv->pshare->RegRF18[eRFPath],(BIT(11)|BIT(10)),val,10);
-			PHY_SetRFReg(priv, eRFPath, rRfChannel, bMask20Bits, priv->pshare->RegRF18[eRFPath]);
-			//PHY_SetRFReg(priv, eRFPath, rRfChannel, (BIT(11)|BIT(10)), val);
-		}
-#endif
-	}
-
-#if 0
-	if (priv->pshare->rf_ft_var.use_frq_2_3G)
-		PHY_SetRFReg(priv, RF90_PATH_C, 0x2c, 0x60, 0);
-#endif
-}
-
-
-void init_EDCA_para(struct rtl8192cd_priv *priv, int mode)
-{
-	static unsigned int slot_time, VO_TXOP, VI_TXOP, sifs_time;
-
-     struct ParaRecord EDCA[4];
-#ifdef RTL_MANUAL_EDCA
-     //unsigned char acm_bitmap;
-#endif
-
-	slot_time = 20;
-	sifs_time = 10;
-
-	if (mode & WIRELESS_11N)
-		sifs_time = 16;
-
-#ifdef RTL_MANUAL_EDCA
-	 if( priv->pmib->dot11QosEntry.ManualEDCA ) {
-		 memset(EDCA, 0, 4*sizeof(struct ParaRecord));
-		 if( OPMODE & WIFI_AP_STATE )
-			 memcpy(EDCA, priv->pmib->dot11QosEntry.AP_manualEDCA, 4*sizeof(struct ParaRecord));
-		 else
-			 memcpy(EDCA, priv->pmib->dot11QosEntry.STA_manualEDCA, 4*sizeof(struct ParaRecord));
-
-
-		if ((mode & WIRELESS_11N) ||
-			(mode & WIRELESS_11G)) {
-			slot_time = 9;
-		}
-
-
-		RTL_W32(EDCA_VO_PARA, (EDCA[VO].TXOPlimit << 16) | (EDCA[VO].ECWmax << 12) | (EDCA[VO].ECWmin << 8) | (sifs_time + EDCA[VO].AIFSN * slot_time));
-#ifdef WIFI_WMM
-		if (QOS_ENABLE)
-			RTL_W32(EDCA_VI_PARA, (EDCA[VI].TXOPlimit << 16) | (EDCA[VI].ECWmax << 12) | (EDCA[VI].ECWmin << 8) | (sifs_time + EDCA[VI].AIFSN * slot_time));
-		else
-#endif
-			RTL_W32(EDCA_VI_PARA, (EDCA[BE].TXOPlimit << 16) | (EDCA[BE].ECWmax << 12) | (EDCA[BE].ECWmin << 8) | (sifs_time + EDCA[VI].AIFSN * slot_time));
-
-		RTL_W32(EDCA_BE_PARA, (EDCA[BE].TXOPlimit << 16) | (EDCA[BE].ECWmax << 12) | (EDCA[BE].ECWmin << 8) | (sifs_time + EDCA[BE].AIFSN * slot_time));
-
-		RTL_W32(EDCA_BK_PARA, (EDCA[BK].TXOPlimit << 16) | (EDCA[BK].ECWmax << 12) | (EDCA[BK].ECWmin << 8) | (sifs_time + EDCA[BK].AIFSN * slot_time));
-	}else
-#endif //RTL_MANUAL_EDCA
-	{
-		 memset(EDCA, 0, 4*sizeof(struct ParaRecord));
-		 /* copy BE, BK from static data */
-		 if( OPMODE & WIFI_AP_STATE )
-				 memcpy(EDCA, rtl_ap_EDCA, 2*sizeof(struct ParaRecord));
-		 else
-				 memcpy(EDCA, rtl_sta_EDCA, 2*sizeof(struct ParaRecord));
-
-		 /* VI, VO apply settings in AG by default */
-		 if( OPMODE & WIFI_AP_STATE )
-				 memcpy(&EDCA[2], &rtl_ap_EDCA[VI_AG], 2*sizeof(struct ParaRecord));
-		 else
-				 memcpy(&EDCA[2], &rtl_sta_EDCA[VI_AG], 2*sizeof(struct ParaRecord));
-
-		 if ((mode & WIRELESS_11N) ||
-				 (mode & WIRELESS_11G)) {
-				 slot_time = 9;
-		 } else {
-				 /* replace with settings in B */
-				 if( OPMODE & WIFI_AP_STATE )
-						 memcpy(&EDCA[2], &rtl_ap_EDCA[VI], 2*sizeof(struct ParaRecord));
-				 else
-						 memcpy(&EDCA[2], &rtl_sta_EDCA[VI], 2*sizeof(struct ParaRecord));
-		 }
-		 VO_TXOP = EDCA[VO].TXOPlimit;
-		 VI_TXOP = EDCA[VI].TXOPlimit;
-
-		 RTL_W32(EDCA_VO_PARA, (VO_TXOP << 16) | (EDCA[VO].ECWmax << 12) | (EDCA[VO].ECWmin << 8) | (sifs_time + EDCA[VO].AIFSN * slot_time));
-#ifdef WIFI_WMM
-		 if (QOS_ENABLE)
-				 RTL_W32(EDCA_VI_PARA, (VI_TXOP << 16) | (EDCA[VI].ECWmax << 12) | (EDCA[VI].ECWmin << 8) | (sifs_time + EDCA[VI].AIFSN * slot_time));
-		 else
-#endif
-				 RTL_W32(EDCA_VI_PARA, (EDCA[BK].ECWmax << 12) | (EDCA[BK].ECWmin << 8) | (sifs_time + EDCA[VI].AIFSN * slot_time));
-
-		 RTL_W32(EDCA_BE_PARA, ((EDCA[BE].ECWmax) << 12) | (EDCA[BE].ECWmin << 8) | (sifs_time + EDCA[BE].AIFSN * slot_time));
-		 RTL_W32(EDCA_BK_PARA, (EDCA[BK].ECWmax << 12) | (EDCA[BK].ECWmin << 8) | (sifs_time + EDCA[BK].AIFSN * slot_time));
-
-
-		RTL_W8(ACMHWCTRL, 0x00);
-	}
-
-	priv->pshare->iot_mode_enable = 0;
-	priv->pshare->iot_mode_VO_exist = 0;
+	} while (FALSE);									\
 }
 
-
-#ifdef WIFI_WMM
-void IOT_EDCA_switch(struct rtl8192cd_priv *priv, int mode, char enable)
+void Unlock_MCU(struct rtl8192cd_priv *priv)
 {
-	unsigned int slot_time = 20, sifs_time = 10, BE_TXOP = 47, VI_TXOP = 94;
-	unsigned int vi_cw_max = 4, vi_cw_min = 3, vi_aifs;
-
-	if (!(!priv->pmib->dot11OperationEntry.wifi_specific ||
-		((OPMODE & WIFI_AP_STATE) && (priv->pmib->dot11OperationEntry.wifi_specific == 2))))
-		return;
-
-	if ((mode & WIRELESS_11N) && (priv->pshare->ht_sta_num
-#ifdef WDS
-		|| ((OPMODE & WIFI_AP_STATE) && priv->pmib->dot11WdsInfo.wdsEnabled && priv->pmib->dot11WdsInfo.wdsNum)
-#endif
-		))
-		sifs_time = 16;
-
-	if ((mode & WIRELESS_11N) || (mode & WIRELESS_11G)) {
-		slot_time = 9;
-	} else {
-		BE_TXOP = 94;
-		VI_TXOP = 188;
-	}
-
-	if ((OPMODE & WIFI_AP_STATE) && priv->pmib->dot11OperationEntry.wifi_specific) {
-		if (priv->pshare->iot_mode_VO_exist) {
-			vi_cw_max = 6;
-			vi_cw_min = 4;
-			vi_aifs = 0x2b;
-		} else {
-			vi_aifs = (sifs_time + ((OPMODE & WIFI_AP_STATE)?1:2) * slot_time);
-		}
-
-		RTL_W32(EDCA_VI_PARA, ((VI_TXOP*(1-priv->pshare->iot_mode_VO_exist)) << 16)
-			| (vi_cw_max << 12) | (vi_cw_min << 8) | vi_aifs);
-	}
+	// 1. To clear C2H
+	RTL_W8(C2H_SYNC_BYTE, 0x0);
+	// 2. Unlock Overall MCU while(1)
+	RTL_W8(MCU_UNLOCK, 0xFF);
+}
 
-	if (!enable) {
-		RTL_W32(EDCA_BE_PARA, (((OPMODE & WIFI_AP_STATE)?6:10) << 12) | (4 << 8)
-				| (sifs_time + 3 * slot_time));
-	} else {
-		if (priv->pshare->ht_sta_num
-#ifdef WDS
-			|| ((OPMODE & WIFI_AP_STATE) && (mode & WIRELESS_11N) &&
-			priv->pmib->dot11WdsInfo.wdsEnabled && priv->pmib->dot11WdsInfo.wdsNum)
+void FirmwareSelfReset(struct rtl8192cd_priv *priv)
+{
+	unsigned char u1bTmp;
+	unsigned char  Delay = 1000;
+	if(priv->pshare->fw_version > 0x21
+#ifdef CONFIG_RTL_92D_SUPPORT
+		|| GET_CHIP_VER(priv) == VERSION_8192D
 #endif
-			) {
-/*
-			if (priv->pshare->txop_enlarge == 0xf) {
-				// is 8192S client
-				RTL_W32(EDCA_BE_PARA, ((BE_TXOP*2) << 16) |
-							(6 << 12) | (4 << 8) | (sifs_time + slot_time+ 0xf)); // 0xf is 92s circuit delay
-				priv->pshare->txop_enlarge = 2;
-			}
-			else
-*/
-			if (priv->pshare->txop_enlarge == 0xe) {
-				// is intel client, use a different edca value
-				RTL_W32(EDCA_BE_PARA, (BE_TXOP*2 << 16) | (6 << 12) | (4 << 8) | 0x1f);
-				priv->pshare->txop_enlarge = 2;
-			} else if (priv->pshare->txop_enlarge == 0xd) {
-				// is intel ralink, use a different edca value
-				RTL_W32(EDCA_BE_PARA, (BE_TXOP*2 << 16) | (4 << 12) | (3 << 8) | 0x19);
-				priv->pshare->txop_enlarge = 2;
-			} else {
-				if (get_rf_mimo_mode(priv) == MIMO_2T2R)
-				RTL_W32(EDCA_BE_PARA, ((BE_TXOP*priv->pshare->txop_enlarge) << 16) |
-						(6 << 12) | (4 << 8) | (sifs_time + 3 * slot_time));
-				else
-				RTL_W32(EDCA_BE_PARA, ((BE_TXOP*priv->pshare->txop_enlarge) << 16) |
-						(5 << 12) | (3 << 8) | (sifs_time + 2 * slot_time));
-			}
-		} else {
-			RTL_W32(EDCA_BE_PARA, (BE_TXOP*2 << 16) | (6 << 12) | (4 << 8) | (sifs_time + 3 * slot_time));
+		)	{
+		RTL_W32(FWIMR, 0x20);
+		RTL_W8(REG_HMETFR+3, 0x20);
+	 	u1bTmp = RTL_R8( REG_SYS_FUNC_EN+1);
+	 	while(u1bTmp& BIT(2)) {
+		  	Delay--;
+		  	DEBUG_INFO("polling 0x03[2] Delay = %d \n", Delay);
+		  	if(Delay == 0)
+		   		break;
+		  	delay_us(50);
+			Unlock_MCU(priv);
+		  	u1bTmp = RTL_R8( REG_SYS_FUNC_EN+1);
 		}
-/*
-		if (priv->pmib->dot11OperationEntry.wifi_specific == 2) {
-			RTL_W16(NAV_PROT_LEN, 0x01C0);
-			RTL_W8(CFEND_TH, 0xFF);
-			set_fw_reg(priv, 0xfd000ab0, 0, 0);
+		// restore MCU internal while(1) loop
+		RTL_W8(MCU_UNLOCK, 0);
+		if(u1bTmp& BIT(2)) {
+			DEBUG_ERR("FirmwareSelfReset fail: 0x03=%02x, 0x1EB=0x%02x\n", u1bTmp, RTL_R8(0x1EB));
+		}else{
+			DEBUG_INFO("FirmwareSelfReset success: 0x03 = %x\n", u1bTmp);
 		}
-*/
 	}
 }
-#endif
-
-
-#ifdef SMART_CONCURRENT_92D
-void setup_timer1(struct rtl8192cd_priv *priv, int timeout)
-{
-	unsigned int current_value=RTL_R32(TSFTR);
-
-	if (TSF_LESS(timeout, current_value))
-		timeout = current_value+20;
-
-	RTL_W32(TIMER0, timeout);
-	RTL_W32(HIMR, RTL_R32(HIMR) | HIMR_TIMEOUT1);
-}
-
-
-void cancel_timer1(struct rtl8192cd_priv *priv)
-{
-	RTL_W32(HIMR, RTL_R32(HIMR) & ~HIMR_TIMEOUT1);
-}
-
 
-void setup_timer2(struct rtl8192cd_priv *priv, unsigned int timeout)
+//Return Value:
+//	1: MAC I/O Registers Enable
+//	0: MAC I/O Registers Disable
+int check_MAC_IO_Enable(struct rtl8192cd_priv *priv)
 {
-	unsigned int current_value=RTL_R32(TSFTR);
-
-	if (TSF_LESS(timeout, current_value))
-		timeout = current_value+20;
-
-	RTL_W32(TIMER1, timeout);
-	RTL_W32(HIMR, RTL_R32(HIMR) | HIMR_TIMEOUT2);
+	//Check PON register to decide
+	return ( (RTL_R16(SYS_FUNC_EN) & (FEN_MREGEN|FEN_DCORE))==(FEN_MREGEN|FEN_DCORE) );
 }
 
-
-void cancel_timer2(struct rtl8192cd_priv *priv)
+int rtl8192cd_stop_hw(struct rtl8192cd_priv *priv)
 {
-	RTL_W32(HIMR, RTL_R32(HIMR) & ~HIMR_TIMEOUT2);
-}
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv)==VERSION_8188E) {
+#ifdef TXREPORT
+		RTL8188E_DisableTxReport(priv);
 #endif
+		RTL_W32(REG_88E_HIMR, 0);
+		RTL_W32(REG_88E_HIMRE, 0);
+		HalPwrSeqCmdParsing(priv, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, 
+			PWR_INTF_PCI_MSK, rtl8188E_leave_lps_flow);
+	} else
+#endif
+	{
+		RTL_W32(HIMR, 0);
+		RTL_W16(HIMRE, 0);
+		RTL_W16(HIMRE+2, 0);
+		RTL_W32(CR, (RTL_R32(CR) & ~(NETYPE_Mask << NETYPE_SHIFT)) | ((NETYPE_NOLINK & NETYPE_Mask) << NETYPE_SHIFT));
+	}
 
-
-void check_EDCCA(struct rtl8192cd_priv *priv, short rssi)
-{
-	if ((priv->pshare->rf_ft_var.edcca_thd) && (priv->pmib->dot11RFEntry.dot11channel==14
-		|| priv->pshare->is_40m_bw
-#if defined(CONFIG_RTL_92D_SUPPORT)
-		||  (priv->pmib->dot11RFEntry.phyBandSelect & PHY_BAND_5G)
+	RTL_W8(RCR, 0);
+	RTL_W8(TXPAUSE, 0xff);								// Pause MAC TX queue
+#if defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT)
+	if (
+#ifdef CONFIG_RTL_92C_SUPPORT
+		(GET_CHIP_VER(priv)==VERSION_8192C) || (GET_CHIP_VER(priv)==VERSION_8188C)
 #endif
-	)) {
-		if((rssi > priv->pshare->rf_ft_var.edcca_thd) && (priv->pshare->phw->EDCCA_on == 0)) {
-			RTL_W32(rOFDM0_ECCAThreshold, 0xfc03fd);
-#if defined(CONFIG_RTL_92D_SUPPORT)
-			if (GET_CHIP_VER(priv)==VERSION_8192D)
-				RTL_W32(RD_CTRL, RTL_R32(RD_CTRL)& ~(BIT(13)));
+#ifdef CONFIG_RTL_92D_SUPPORT
+#ifdef CONFIG_RTL_92C_SUPPORT
+		|| 
 #endif
-			priv->pshare->phw->EDCCA_on =1;
-		} else if( (rssi < priv->pshare->rf_ft_var.edcca_thd-5) && priv->pshare->phw->EDCCA_on) {
-			RTL_W32(rOFDM0_ECCAThreshold, 0x7f037f);
-#if defined(CONFIG_RTL_92D_SUPPORT)
-			if (GET_CHIP_VER(priv)==VERSION_8192D)
-				RTL_W32(RD_CTRL, RTL_R32(RD_CTRL)|BIT(13));
+		(GET_CHIP_VER(priv)==VERSION_8192D)
 #endif
-			priv->pshare->phw->EDCCA_on =0;
+		) {
+		//	RTL_W8(CR, RTL_R8(CR) & ~(MACTXEN|MACRXEN));
+			RTL_W8(CR, 0);
 		}
-	}
-	if ((!priv->pshare->rf_ft_var.edcca_thd) && priv->pshare->phw->EDCCA_on) {
-		RTL_W32(0xc4c, 0x7f037f);
-#if defined(CONFIG_RTL_92D_SUPPORT)
-		if (GET_CHIP_VER(priv)==VERSION_8192D)
-			RTL_W32(RD_CTRL, RTL_R32(RD_CTRL)|BIT(13));
 #endif
-		priv->pshare->phw->EDCCA_on = 0;
-	}	
-}
-
 
-/*
- * FA statistic functions
- */
-#if !defined(CONFIG_RTL_NEW_AUTOCH)
-static
-#endif
-void reset_FA_reg(struct rtl8192cd_priv *priv)
-{
-#if !defined(CONFIG_RTL_NEW_AUTOCH)
-	unsigned char value8;
-
-	value8 = RTL_R8(0xd03);
-	RTL_W8(0xd03, value8 | 0x08);	// regD00[27]=1 to reset these OFDM FA counters
-	value8 = RTL_R8(0xd03);
-	RTL_W8(0xd03, value8 & 0xF7);	// regD00[27]=0 to start counting
-	value8 = RTL_R8(0xa2d);
-	RTL_W8(0xa2d, value8 & 0x3F);	// regA2D[7:6]=00 to disable counting
-	value8 = RTL_R8(0xa2d);
-	RTL_W8(0xa2d, value8 | 0x80);	// regA2D[7:6]=10 to enable counting
-#else
-	/* cck CCA */
-	PHY_SetBBReg(priv, 0xa2c, BIT(13) | BIT(12), 0);
-	PHY_SetBBReg(priv, 0xa2c, BIT(13) | BIT(12), 2);
-	/* cck FA*/
-	PHY_SetBBReg(priv, 0xa2c, BIT(15) | BIT(14), 0);
-	PHY_SetBBReg(priv, 0xa2c, BIT(15) | BIT(14), 2);
-	/* ofdm */
-	PHY_SetBBReg(priv, 0xd00, BIT(27), 1);
-	PHY_SetBBReg(priv, 0xd00, BIT(27), 0);
+#ifdef CONFIG_RTL_92D_DMDP
+	if (priv->pshare->wlandev_idx == 0)
+		RTL_W8(RSV_MAC0_CTRL, RTL_R8(RSV_MAC0_CTRL)&(~MAC0_EN));
+	else
+		RTL_W8(RSV_MAC1_CTRL, RTL_R8(RSV_MAC1_CTRL)&(~MAC1_EN));
 
+	if ((RTL_R8(RSV_MAC0_CTRL)& MAC0_EN) || (RTL_R8(RSV_MAC1_CTRL)& MAC1_EN)) { // check if another interface exists
+		DEBUG_INFO("Another MAC exists, cannot stop hw!!\n");
+	} else
 #endif
-
-#if defined(CONFIG_RTL_92D_SUPPORT) && defined(CONFIG_RTL_NOISE_CONTROL)
-	if (GET_CHIP_VER(priv) == VERSION_8192D){
-		PHY_SetBBReg(priv, 0xf14, BIT(16),1);
-		PHY_SetBBReg(priv, 0xf14, BIT(16),0);
-		RTL_W32(RXERR_RPT, RTL_R32(RXERR_RPT)|BIT(27));
-		RTL_W32(RXERR_RPT, RTL_R32(RXERR_RPT)&(~BIT(27)));
-	}
+	{
+#if defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT)
+		if (
+#ifdef CONFIG_RTL_92C_SUPPORT
+			(GET_CHIP_VER(priv)==VERSION_8192C) || (GET_CHIP_VER(priv)==VERSION_8188C)
 #endif
-
-}
-
-#if defined(CONFIG_RTL_NEW_AUTOCH)
-void hold_CCA_FA_counter(struct rtl8192cd_priv *priv)
-{
-	/* hold cck CCA & FA counter */
-	PHY_SetBBReg(priv, 0xa2c, BIT(12), 1);
-	PHY_SetBBReg(priv, 0xa2c, BIT(14), 1);
-
-	/* hold ofdm CCA & FA counter */
-	PHY_SetBBReg(priv, 0xc00, BIT(31), 1);
-	PHY_SetBBReg(priv, 0xd00, BIT(31), 1);
-}
-
-void release_CCA_FA_counter(struct rtl8192cd_priv *priv)
-{
-	/* release cck CCA & FA counter */
-	PHY_SetBBReg(priv, 0xa2c, BIT(12), 0);
-	PHY_SetBBReg(priv, 0xa2c, BIT(14), 0);
-
-	/* release ofdm CCA & FA counter */
-	PHY_SetBBReg(priv, 0xc00, BIT(31), 0);
-	PHY_SetBBReg(priv, 0xd00, BIT(31), 0);
-}
-
-
-void _FA_statistic(struct rtl8192cd_priv *priv)
-{
-	// read OFDM FA counters
-	priv->pshare->ofdm_FA_cnt1 = RTL_R16(0xda2);
-	priv->pshare->ofdm_FA_cnt2 = RTL_R16(0xda4);
-	priv->pshare->ofdm_FA_cnt3 = RTL_R16(0xda6);
-	priv->pshare->ofdm_FA_cnt4 = RTL_R16(0xda8);
-
-	priv->pshare->cck_FA_cnt = (RTL_R8(0xa5b) << 8) + RTL_R8(0xa5c);
-
-	priv->pshare->FA_total_cnt = priv->pshare->ofdm_FA_cnt1 + priv->pshare->ofdm_FA_cnt2 +
-	                             priv->pshare->ofdm_FA_cnt3 + priv->pshare->ofdm_FA_cnt4 +
-	                             priv->pshare->cck_FA_cnt + RTL_R16(0xcf0) + RTL_R16(0xcf2);
-}
+#ifdef CONFIG_RTL_92D_SUPPORT
+#ifdef CONFIG_RTL_92C_SUPPORT
+			|| 
 #endif
-
-void FA_statistic(struct rtl8192cd_priv *priv)
-{
-
-#if defined(CONFIG_RTL_92D_SUPPORT) && defined(CONFIG_RTL_NOISE_CONTROL)
-	if (GET_CHIP_VER(priv) == VERSION_8192D){
-//		priv->pshare->F90_cnt = PHY_QueryBBReg(priv, 0xf90, bMaskHWord);
-		priv->pshare->F94_cnt = PHY_QueryBBReg(priv, 0xf94, bMaskHWord);
-		priv->pshare->F94_cntOK = PHY_QueryBBReg(priv, 0xf94, bMaskLWord);
-		RTL_W32(RXERR_RPT,(RTL_R32(RXERR_RPT)&0x0fffffff)|0x70000000);
-		priv->pshare->Reg664_cnt = RTL_R32(RXERR_RPT) & 0xfffff;
-		RTL_W32(RXERR_RPT,(RTL_R32(RXERR_RPT)&0x0fffffff)|0x60000000);
-		priv->pshare->Reg664_cntOK = RTL_R32(RXERR_RPT) & 0xfffff;
-	}
-#endif
-
-#if !defined(CONFIG_RTL_NEW_AUTOCH)
-	signed char value8;
-
-	// read OFDM FA counters
-	priv->pshare->ofdm_FA_cnt1 = RTL_R16(0xda2);
-	priv->pshare->ofdm_FA_cnt2 = RTL_R16(0xda4);
-	priv->pshare->ofdm_FA_cnt3 = RTL_R16(0xda6);
-	priv->pshare->ofdm_FA_cnt4 = RTL_R16(0xda8);
-
-	// read the CCK FA counters
-	value8 = RTL_R8(0xa2d);
-	RTL_W8(0xa2d, value8 | 0x40);	// regA2D[6]=1 to hold and read the CCK FA counters
-	priv->pshare->cck_FA_cnt = RTL_R8(0xa5b);
-	priv->pshare->cck_FA_cnt = priv->pshare->cck_FA_cnt << 8;
-	priv->pshare->cck_FA_cnt += RTL_R8(0xa5c);
-
-	priv->pshare->FA_total_cnt = priv->pshare->ofdm_FA_cnt1 + priv->pshare->ofdm_FA_cnt2 +
-	                             priv->pshare->ofdm_FA_cnt3 + priv->pshare->ofdm_FA_cnt4 +
-	                             priv->pshare->cck_FA_cnt + RTL_R16(0xcf0) + RTL_R16(0xcf2);
-
-	if (priv->pshare->rf_ft_var.rssi_dump)
-		priv->pshare->CCA_total_cnt = ((RTL_R8(0xa60)<<8)|RTL_R8(0xa61)) + RTL_R16(0xda0);
-#else
-	hold_CCA_FA_counter(priv);
-	_FA_statistic(priv);
-
-	if (priv->pshare->rf_ft_var.rssi_dump)
-		priv->pshare->CCA_total_cnt = ((RTL_R8(0xa60)<<8)|RTL_R8(0xa61)) + RTL_R16(0xda0);
-
-	release_CCA_FA_counter(priv);
+			(GET_CHIP_VER(priv)==VERSION_8192D)
 #endif
+			) {
+			//3 2.) ==== RF Off Sequence ====
+			phy_InitBBRFRegisterDefinition(priv);		// preparation for read/write RF register
+			
+			PHY_SetRFReg(priv, RF92CD_PATH_A, 0x00, bMask20Bits, 0x00);	// disable RF
+			RTL_W8(RF_CTRL, 0x00);
+			RTL_W8(APSD_CTRL, 0x40);
+			RTL_W8(SYS_FUNC_EN, 0xe2);		// reset BB state machine
+			RTL_W8(SYS_FUNC_EN, 0xe0);		// reset BB state machine
 
-	reset_FA_reg(priv);
 
-#if defined(CONFIG_RTL_92D_SUPPORT) && defined(CONFIG_RTL_NOISE_CONTROL)
-	if (GET_CHIP_VER(priv) == VERSION_8192D){
-		if (priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_5G  && !(OPMODE & WIFI_SITE_MONITOR)) {
-			if (priv->pshare->DNC_on == 0){
-				//if ((priv->pshare->F94_cnt + priv->pshare->F90_cnt)> 3000){
-				/* Reg 664: x > y && x > 1000
-				    Reg F94: x > 0.75*y && x > 1000 */
-				if (((priv->pshare->Reg664_cnt>priv->pshare->Reg664_cntOK) && (priv->pshare->Reg664_cnt > 1000))||
-					((priv->pshare->F94_cnt > ((priv->pshare->Reg664_cntOK*3)>>2)) && (priv->pshare->F94_cnt > 1000))) {
-					priv->ext_stats.tp_average_pre = (priv->ext_stats.tx_avarage+priv->ext_stats.rx_avarage)>>17;
-					priv->pshare->DNC_on = 1;
-					priv->pshare->DNC_chk_cnt = 1;
-					priv->pshare->DNC_chk = 2; // 0: don't check, 1; check, 2: just entering DNC
-					//PHY_SetBBReg(priv, 0xb30, bMaskDWord, 0x00a00000);
-					PHY_SetBBReg(priv, 0x870, bMaskDWord, 0x07600760);
-					PHY_SetBBReg(priv, 0xc50, bMaskByte0, 0x20);
-					PHY_SetBBReg(priv, 0xc58, bMaskByte0, 0x20);
-					//printk("Dynamic Noise Control ON\n");
-				}
-			} else {
-				if ((priv->pshare->DNC_chk_cnt % 5)==0){ // check every 5*2=10 seconds
-					unsigned long tp_now = (priv->ext_stats.tx_avarage+priv->ext_stats.rx_avarage)>>17;
-					priv->pshare->DNC_chk_cnt = 0;
-
- 					if ((priv->pshare->DNC_chk == 2) && (tp_now < priv->ext_stats.tp_average_pre+5)){
-						//no advantage, leave DNC state
-						priv->pshare->DNC_on = 0;
-						priv->pshare->DNC_chk = 0;
-						//PHY_SetBBReg(priv, 0xb30, bMaskDWord, 0);
-						PHY_SetBBReg(priv, 0x870, bMaskDWord, 0x07000700);
-					}
-					else
-					{
-						priv->pshare->DNC_chk = 0;
-
-						/* If TP < 20M or TP varies more than 5M. Start Checking...*/
-						if ((tp_now < 20) || ((tp_now < (priv->ext_stats.tp_average_pre-5))|| (tp_now > (priv->ext_stats.tp_average_pre+5)))){
-							priv->pshare->DNC_chk = 1;
-							//PHY_SetBBReg(priv, 0xb30, bMaskDWord, 0);
-							PHY_SetBBReg(priv, 0x870, bMaskDWord, 0x07000700);
-							if (!timer_pending(&priv->dnc_timer)) {
-								//printk("... Start Check Noise ...\n");
-								mod_timer(&priv->dnc_timer, jiffies + 10);	// 100 ms
-							}
-						}
-					}
 
-					priv->ext_stats.tp_average_pre = tp_now;
+			//3 3.) ==== Reset digital sequence ====
+			if (RTL_R8(MCUFWDL) & BIT(1)) {
+				//Make sure that Host Recovery Interrupt is handled by 8051 ASAP.
+				RTL_W32(FSIMR, 0);				// clear FSIMR
+				RTL_W32(FWIMR, 0x20);			// clear FWIMR except HRCV_INT
+				RTL_W32(FTIMR, 0);				// clear FTIMR
+				FirmwareSelfReset(priv);
 
-				} else if ((priv->pshare->DNC_chk_cnt % 5)==1 && priv->pshare->DNC_chk == 1) {
-					priv->pshare->DNC_chk = 0;
-					//if ((priv->pshare->F94_cnt + priv->pshare->F90_cnt) < 120) {
-					if ((priv->pshare->F94_cnt + priv->pshare->Reg664_cnt) < 120) {
-						priv->pshare->DNC_on = 0;
-						//PHY_SetBBReg(priv, 0xb30, bMaskDWord, 0);
-						PHY_SetBBReg(priv, 0x870, bMaskDWord, 0x07000700);
-						//printk("Dynamic Noise Control OFF\n");
-					}
-				}
-				priv->pshare->DNC_chk_cnt++;
+				//Clear FWIMR to guarantee if 8051 runs in ROM, it is impossible to run FWISR Interrupt handler
+				RTL_W32(FWIMR, 0x0);			// clear All FWIMR
+			} else {
+				//Critical Error.
+				//the operation that reset 8051 is necessary to be done by 8051
+				DEBUG_ERR("%s %d ERROR: (RTL_R8(MCUFWDL) & BIT(1))=0\n", __FUNCTION__, __LINE__);
+				DEBUG_ERR("%s %d ERROR: the operation that reset 8051 is necessary to be done by 8051,%d\n", __FUNCTION__, __LINE__, RTL_R8(MCUFWDL));
 			}
 		}
-	}
 #endif
-}
-
 
-/*
- *
- * DIG related functions
- *
- */
+		// ==== Reset digital sequence ====
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv)==VERSION_8188E)
+			RTL_W8(SYS_FUNC_EN+1, RTL_R8(SYS_FUNC_EN+1) & ~BIT(2));
+		else			
+#endif
+			RTL_W8(SYS_FUNC_EN+1, 0x51);								// reset MCU, MAC register, DCORE
+		RTL_W8(MCUFWDL, 0);											// reset MCU ready status
 
-int getIGIFor1RCCA(int value_IGI)
-{
-	#define ONERCCA_LOW_TH		0x30
-	#define ONERCCA_LOW_DIFF	8
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv)==VERSION_8188E) {
+			HalPwrSeqCmdParsing(priv, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK, rtl8188E_card_disable_flow);
+		} else
+#endif
+		{
+			//3 4.) ==== Disable analog sequence ====
+			RTL_W8(AFE_PLL_CTRL, 0x80);			// disable PLL
 
-	if (value_IGI < ONERCCA_LOW_TH) {
-		if ((ONERCCA_LOW_TH - value_IGI) < ONERCCA_LOW_DIFF)
-			return ONERCCA_LOW_TH;
-		else
-			return value_IGI + ONERCCA_LOW_DIFF;
-	} else {
-		return value_IGI;
-	}
-}
+#if defined(CONFIG_RTL_92C_SUPPORT) && defined(CONFIG_RTL_92D_SUPPORT)
+			if (GET_CHIP_VER(priv) == VERSION_8192C) {
+				RTL_W8(SPS0_CTRL, 0x2b);
+			} else
+#endif
+			{
+#ifdef CONFIG_RTL_92C_SUPPORT
+				if(IS_UMC_B_CUT_88C(priv))
+					RTL_W8(SPS0_CTRL, 0x2b);
+				else	
+#endif
+					RTL_W8(SPS0_CTRL, 0x23);
+			}
+		}
+#ifdef CONFIG_RTL8672
+		RTL_W8(AFE_XTAL_CTRL, RTL_R8(AFE_XTAL_CTRL)&~BIT(0));		// only for ADSL platform because 40M crystal is only used by WiFi chip // disable XTAL, if No BT COEX
+#endif
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv)==VERSION_8188E) {
+			RTL_W8(AFE_XTAL_CTRL, 0x06);
 
+			// Reset MCU IO Wrapper
+			RTL_W8(RSV_CTRL0+1, RTL_R8(RSV_CTRL0+1) & ~BIT(3));
+			RTL_W8(RSV_CTRL0+1, RTL_R8(RSV_CTRL0+1) | BIT(3));
+		} else
+#endif
+		{
+			RTL_W8(APS_FSMCO+1, 0x10);
+		}
+		RTL_W8(RSV_CTRL0, 0x0e);				// lock ISO/CLK/Power control register
 
-void set_DIG_state(struct rtl8192cd_priv *priv, int state)
-{
-	int value_IGI;
+		//3 5.) ==== interface into suspend ====
+//		RTL_W16(APS_FSMCO, (RTL_R16(APS_FSMCO) & 0x00ff) | (0x18 << 8));	// PCIe suspend mode
 
-	if (state) {
-		priv->pshare->DIG_on = 1;
-		priv->pshare->restore = 0;
-	}
-	else {
-		priv->pshare->DIG_on = 0;
-		if (priv->pshare->restore == 0) {
-			if (priv->pshare->rf_ft_var.use_ext_lna == 1)
-				value_IGI = 0x30;
-			else
-				value_IGI = 0x20;
-
-#if defined(HW_ANT_SWITCH)
-			// wirte new initial gain index into regC50/C58
-			if (priv->pshare->rf_ft_var.one_path_cca == 0)	{
-				RTL_W8(0xc50, value_IGI | RXDVY_A_EN);
-				RTL_W8(0xc58, value_IGI | RXDVY_B_EN);
-			} else if (priv->pshare->rf_ft_var.one_path_cca == 1) {
-				RTL_W8(0xc50, value_IGI | RXDVY_A_EN);
-				RTL_W8(0xc58, getIGIFor1RCCA(value_IGI) | RXDVY_B_EN);
-			} else if (priv->pshare->rf_ft_var.one_path_cca == 2) {
-				RTL_W8(0xc50, getIGIFor1RCCA(value_IGI) | RXDVY_A_EN);
-				RTL_W8(0xc58, value_IGI | RXDVY_B_EN);
-			}
-#else
-			// Write IGI into HW
-			if (priv->pshare->rf_ft_var.one_path_cca == 0) 	{
-				RTL_W8(0xc50, value_IGI);
-				RTL_W8(0xc58, value_IGI);
-			} else if (priv->pshare->rf_ft_var.one_path_cca == 1) {
-				RTL_W8(0xc50, value_IGI);
-				RTL_W8(0xc58, getIGIFor1RCCA(value_IGI));
-			} else if (priv->pshare->rf_ft_var.one_path_cca == 2) {
-				RTL_W8(0xc50, getIGIFor1RCCA(value_IGI));
-				RTL_W8(0xc58, value_IGI);
-			}
+#ifdef CONFIG_RTL8672
+		// 6.) Switch to XTAL_BSEL: NAND
+		RTL_W8(AFE_XTAL_CTRL, RTL_R8(AFE_XTAL_CTRL) & ~ BIT(1));
 #endif
-			priv->pshare->restore = 1;
-		}
 	}
+	return SUCCESS;
 }
 
 
-void DIG_process(struct rtl8192cd_priv *priv)
+void SwBWMode(struct rtl8192cd_priv *priv, unsigned int bandwidth, int offset)
 {
-	#define DEAD_POINT_TH		10000
-	#define DOWN_IG_HIT_TH		5
-	#define DEAD_POINT_HIT_TH	3
+	unsigned char regBwOpMode, regRRSR_RSC, nCur40MhzPrimeSC;
+	unsigned int eRFPath, curMaxRFPath, val;
 
-	unsigned char value_IGI;
-	signed char value8;
+	DEBUG_INFO("SwBWMode(): Switch to %s bandwidth\n", bandwidth?"40MHz":"20MHz");
 
-	if (priv->pshare->DIG_on == 1)
-	{
-		if (priv->pshare->rf_ft_var.use_ext_lna == 1) {
-			priv->pshare->FA_upper = 0x42;
-			priv->pshare->FA_lower = 0x30;
-		} else {
-			// Reset initial gain upper & lower bounds
-#ifdef DFS
-                        if (!priv->pmib->dot11DFSEntry.disable_DFS &&
-                                (OPMODE & WIFI_AP_STATE) &&
-                                (((priv->pmib->dot11RFEntry.dot11channel >= 52) &&
-                                (priv->pmib->dot11RFEntry.dot11channel <= 64)) ||
-                                ((priv->pmib->dot11RFEntry.dot11channel >= 100) &&
-                                (priv->pmib->dot11RFEntry.dot11channel <= 140))))
-                                priv->pshare->FA_upper = 0x24;
-                        else
-#endif
-			priv->pshare->FA_upper = 0x32;
-			priv->pshare->FA_lower = 0x20;
-
-			if (priv->pshare->rssi_min > 30)
-				priv->pshare->FA_lower = 0x24;
-			else if (priv->pshare->rssi_min > 25)
-				priv->pshare->FA_lower = 0x22;
-		}
-
-		// determine a new initial gain index according to the sumation of all FA counters as well as upper & lower bounds
-		value8 = RTL_R8(0xc50);
-		value_IGI = (value8 & 0x7F);
-
-#if  defined(CONFIG_RTL_NOISE_CONTROL_92C)
-	if(priv->pshare->rf_ft_var.dnc_enable)
-	if ((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)){
-		unsigned long tp_now = (priv->ext_stats.tx_avarage+priv->ext_stats.rx_avarage)>>17;
-		if(priv->pshare->rf_ft_var.use_ext_lna) {
-			if( (priv->pshare->rssi_min > 50)  )  {
-				if((!priv->pshare->DNC_on) && (value_IGI >= priv->pshare->FA_upper) && (priv->pshare->FA_total_cnt > priv->pshare->threshold2)) {
-					priv->pshare->DNC_on = 1;
-					priv->ext_stats.tp_average_pre = tp_now;
-					priv->pshare->FA_lower = 0x20;
-					PHY_SetBBReg(priv, 0x870, bMaskDWord, RTL_R32(0x870)|BIT(5)|BIT(6)|BIT(21)|BIT(22));
-
-#ifdef HW_ANT_SWITCH
-					PHY_SetBBReg(priv, 0xc50, bMaskByte0, priv->pshare->FA_lower | RXDVY_A_EN);
-					PHY_SetBBReg(priv, 0xc58, bMaskByte0, priv->pshare->FA_lower | RXDVY_B_EN);
-#else
-					PHY_SetBBReg(priv, 0xc50, bMaskByte0, priv->pshare->FA_lower);
-					PHY_SetBBReg(priv, 0xc58, bMaskByte0, priv->pshare->FA_lower);
+#ifdef CONFIG_RTL_92D_DMDP
+	if (priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY)
+		curMaxRFPath = RF92CD_PATH_B;
+	else
 #endif
+		curMaxRFPath = RF92CD_PATH_MAX;
 
-				} else if(priv->pshare->DNC_on ==1)  {
-					if(tp_now < priv->ext_stats.tp_average_pre + 2) {
-						priv->pshare->DNC_on = 0;
-					}
-					else {
-						priv->pshare->DNC_on =2;
-						priv->ext_stats.tp_average_pre = tp_now;
-					}
-				} else if(priv->pshare->DNC_on >= 2 ) {
-					if(( tp_now+10 < priv->ext_stats.tp_average_pre ) || (tp_now < 1) ) {
-							priv->pshare->DNC_on = 0;
-					} else if(priv->pshare->DNC_on<5) {
-						priv->ext_stats.tp_average_pre = tp_now;
-						++priv->pshare->DNC_on;
-					}
-				}
-			 }else {
-				priv->pshare->DNC_on = 0;
-			}
+	if (offset == 1)
+		nCur40MhzPrimeSC = 2;
+	else
+		nCur40MhzPrimeSC = 1;
 
-			if(	priv->pshare->DNC_on )
-				return;
-			else
-				PHY_SetBBReg(priv, 0x870, bMaskDWord, RTL_R32(0x870)&  ~(BIT(5)|BIT(6)|BIT(21)|BIT(22)));
+	//3 <1> Set MAC register
+	regBwOpMode = RTL_R8(BWOPMODE);
+	regRRSR_RSC = RTL_R8(RRSR+2);
 
-		} else {
-			if( (priv->pshare->rssi_min > 40) && (value_IGI >= priv->pshare->FA_upper) )  {
-//				unsigned long tp_now = (priv->ext_stats.tx_avarage+priv->ext_stats.rx_avarage)>>17;
-				if((!priv->pshare->DNC_on) && (priv->pshare->FA_total_cnt > priv->pshare->threshold2)) {
-					priv->pshare->DNC_on = 1;
-					priv->ext_stats.tp_average_pre = tp_now;
-				} else if(priv->pshare->DNC_on ==1)  {
-					if(tp_now < priv->ext_stats.tp_average_pre + 2) {
-						priv->pshare->DNC_on = 0;
-					}
-					else {
-						priv->pshare->DNC_on = 2;
-						priv->ext_stats.tp_average_pre = tp_now;
-					}
-				} else if(priv->pshare->DNC_on >= 2 ) {
-					if((tp_now +10 < priv->ext_stats.tp_average_pre )
-						|| ((priv->ext_stats.tp_average_pre < 10) && (priv->pshare->FA_total_cnt < priv->pshare->threshold1))) {
-						priv->pshare->DNC_on = 0;
-					} else 	if(priv->pshare->DNC_on<6) {
-						priv->ext_stats.tp_average_pre = tp_now;
-						++priv->pshare->DNC_on;
-					}
-				}
-				if(priv->pshare->DNC_on) {
-					priv->pshare->FA_upper = 0x3e;
-				}
-			}else {
-				priv->pshare->DNC_on = 0;
-			}
+	switch (bandwidth)
+	{
+	case HT_CHANNEL_WIDTH_20:
+		regBwOpMode |= BW_OPMODE_20MHZ;
+		RTL_W8(BWOPMODE, regBwOpMode);
+		break;
+	case HT_CHANNEL_WIDTH_20_40:
+		regBwOpMode &= ~BW_OPMODE_20MHZ;
+		RTL_W8(BWOPMODE, regBwOpMode);
+		regRRSR_RSC = (regRRSR_RSC&0x90) | (nCur40MhzPrimeSC<<5);
+		RTL_W8(RRSR+2, regRRSR_RSC);
+
+		// Let 812cd_rx, re-assign value
+		if (priv->pshare->is_40m_bw){
+			priv->pshare->Reg_RRSR_2 = 0;
+			priv->pshare->Reg_81b = 0;
 		}
+		break;
+	default:
+		DEBUG_ERR("SwBWMode(): bandwidth mode error!\n");
+		return;
+		break;
 	}
-#endif
 
-		if ((priv->pshare->digDeadPoint == 0) && (priv->pshare->FA_total_cnt > DEAD_POINT_TH)) {
-			if ((priv->pshare->digDeadPointHitCount > 0) && (priv->pshare->digDeadPointCandidate == value_IGI)) {
-				priv->pshare->digDeadPointHitCount++;
-				if (priv->pshare->digDeadPointHitCount == DEAD_POINT_HIT_TH) {
-					priv->pshare->digDeadPoint = priv->pshare->digDeadPointCandidate;
-				}
-			} else {
-				priv->pshare->digDeadPointCandidate = value_IGI;
-				priv->pshare->digDeadPointHitCount = 1;
-			}
+	//3 <2> Set PHY related register
+	switch (bandwidth)
+	{
+	case HT_CHANNEL_WIDTH_20:
+		PHY_SetBBReg(priv, rFPGA0_RFMOD, bRFMOD, 0x0);
+		PHY_SetBBReg(priv, rFPGA1_RFMOD, bRFMOD, 0x0);
+#ifdef CONFIG_RTL_92D_SUPPORT
+		if (GET_CHIP_VER(priv)==VERSION_8192D) {
+			PHY_SetBBReg(priv, rFPGA0_AnalogParameter2, BIT(11) | BIT(10), 3);// SET BIT10 BIT11  for receive cck
 		}
-
-		if (priv->pshare->FA_total_cnt < priv->pshare->threshold0) {
-			priv->pshare->digDownCount++;
-			if (priv->pshare->digDownCount > DOWN_IG_HIT_TH) {
-				// Reset deadpoint hit count
-				if ((priv->pshare->digDeadPoint == 0) && (priv->pshare->digDeadPointHitCount > 0) && (value_IGI == priv->pshare->digDeadPointCandidate))
-					priv->pshare->digDeadPointHitCount = 0;
-
-				value_IGI--;
-
-				// Check if the new value is dead point
-				if ((priv->pshare->digDeadPoint > 0) && (value_IGI == priv->pshare->digDeadPoint))
-					value_IGI++;
-			}
-		} else if (priv->pshare->FA_total_cnt < priv->pshare->threshold1) {
-			value_IGI += 0;
-			priv->pshare->digDownCount = 0;
-		} else if (priv->pshare->FA_total_cnt < priv->pshare->threshold2) {
-			value_IGI++;
-			priv->pshare->digDownCount = 0;
-		} else if (priv->pshare->FA_total_cnt >= priv->pshare->threshold2) {
-			value_IGI += 2;
-			priv->pshare->digDownCount = 0;
-		} else {
-			priv->pshare->digDownCount = 0;
-		}
-
-		if (value_IGI > priv->pshare->FA_upper)
-			value_IGI = priv->pshare->FA_upper;
-		else if (value_IGI < priv->pshare->FA_lower)
-			value_IGI = priv->pshare->FA_lower;
-
-#if defined(HW_ANT_SWITCH)
-		// wirte new initial gain index into regC50/C58
-		if (priv->pshare->rf_ft_var.one_path_cca == 0)	{
-			RTL_W8(0xc50, value_IGI | RXDVY_A_EN);
-			RTL_W8(0xc58, value_IGI | RXDVY_B_EN);
-		} else if (priv->pshare->rf_ft_var.one_path_cca == 1)	{
-			RTL_W8(0xc50, value_IGI | RXDVY_A_EN);
-			RTL_W8(0xc58, getIGIFor1RCCA(value_IGI) | RXDVY_B_EN);
-		} else if (priv->pshare->rf_ft_var.one_path_cca == 2)		{
-			RTL_W8(0xc50, getIGIFor1RCCA(value_IGI) | RXDVY_A_EN);
-			RTL_W8(0xc58, value_IGI| RXDVY_B_EN);
+#endif
+#ifdef CONFIG_RTL_92C_SUPPORT
+		if ((GET_CHIP_VER(priv)==VERSION_8192C) || (GET_CHIP_VER(priv)==VERSION_8188C)) {
+			PHY_SetBBReg(priv, rFPGA0_AnalogParameter2, BIT(10), 1);
 		}
-#else
-		// Write IGI into HW
-		if (priv->pshare->rf_ft_var.one_path_cca == 0) {
-			RTL_W8(0xc50, value_IGI);
-			RTL_W8(0xc58, value_IGI);
-		} else if (priv->pshare->rf_ft_var.one_path_cca == 1) {
-			RTL_W8(0xc50, value_IGI);
-			RTL_W8(0xc58, getIGIFor1RCCA(value_IGI));
-		} else if (priv->pshare->rf_ft_var.one_path_cca == 2) {
-			RTL_W8(0xc50, getIGIFor1RCCA(value_IGI));
-			RTL_W8(0xc58, value_IGI);
+#endif
+		break;
+	case HT_CHANNEL_WIDTH_20_40:
+		PHY_SetBBReg(priv, rFPGA0_RFMOD, bRFMOD, 0x1);
+		PHY_SetBBReg(priv, rFPGA1_RFMOD, bRFMOD, 0x1);
+		// Set Control channel to upper or lower. These settings are required only for 40MHz
+		PHY_SetBBReg(priv, rCCK0_System, bCCKSideBand, (nCur40MhzPrimeSC>>1));
+		PHY_SetBBReg(priv, rOFDM1_LSTF, 0xC00, nCur40MhzPrimeSC);
+#ifdef CONFIG_RTL_92D_SUPPORT
+		if (GET_CHIP_VER(priv)==VERSION_8192D) {
+			PHY_SetBBReg(priv, rFPGA0_AnalogParameter2, BIT(11) | BIT(10), 0);// SET BIT10 BIT11  for receive cck
 		}
 #endif
-
+#ifdef CONFIG_RTL_92C_SUPPORT
+		if ((GET_CHIP_VER(priv)==VERSION_8192C) || (GET_CHIP_VER(priv)==VERSION_8188C)) {
+			PHY_SetBBReg(priv, rFPGA0_AnalogParameter2, BIT(10), 0);
+		}
+#endif
+		PHY_SetBBReg(priv, 0x818, (BIT(26)|BIT(27)), (nCur40MhzPrimeSC==2)?1:2);
+		break;
+	default:
+		DEBUG_ERR("SwBWMode(): bandwidth mode error! %d\n", __LINE__);
+		return;
+		break;
 	}
-}
-
-
-void check_DIG_by_rssi(struct rtl8192cd_priv *priv, unsigned char rssi_strength)
-{
-	unsigned int dig_on = 0;
 
-	if (OPMODE & WIFI_SITE_MONITOR)
+	//3<3> Set RF related register
+	switch (bandwidth)
+	{
+	case HT_CHANNEL_WIDTH_20:
+		val = 1;
+		break;
+	case HT_CHANNEL_WIDTH_20_40:
+		val = 0;
+		break;
+	default:
+		DEBUG_ERR("SwBWMode(): bandwidth mode error! %d\n", __LINE__);
 		return;
+		break;
+	}
 
-	if ((rssi_strength > priv->pshare->rf_ft_var.digGoUpperLevel)
-		&& (rssi_strength < HP_LOWER+1) && (priv->pshare->phw->signal_strength != 2)) {
-#ifndef CONFIG_RTL_92D_SUPPORT
-		if (priv->pshare->is_40m_bw)
-			// RTL_W8(0xc87, (RTL_R8(0xc87) & 0xf) | 0x30); 92D
-			RTL_W8(0xc87, 0x30);
-		else
-			RTL_W8(0xc30, 0x44);
+	for(eRFPath = RF92CD_PATH_A; eRFPath < curMaxRFPath; eRFPath++)	{
+#ifdef CONFIG_RTL_92C_SUPPORT
+		if ((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)){
+			PHY_SetRFReg(priv, eRFPath, rRfChannel, (BIT(11)|BIT(10)), val);
+		}
 #endif
-
-		if (priv->pshare->phw->signal_strength != 3)
-			dig_on++;
-
-		priv->pshare->phw->signal_strength = 2;
-	}
-	else if ((rssi_strength > HP_LOWER+5) && (priv->pshare->phw->signal_strength != 3)) {
-#ifndef CONFIG_RTL_92D_SUPPORT
-		if (priv->pshare->is_40m_bw)
-			// RTL_W8(0xc87, (RTL_R8(0xc87) & 0xf) | 0x30); 92D
-			RTL_W8(0xc87, 0x30);
-		else
-			RTL_W8(0xc30, 0x44);
+#ifdef CONFIG_RTL_92D_SUPPORT
+		if (GET_CHIP_VER(priv) == VERSION_8192D){
+			priv->pshare->RegRF18[eRFPath] = RTL_SET_MASK(priv->pshare->RegRF18[eRFPath],(BIT(11)|BIT(10)),val,10);
+			PHY_SetRFReg(priv, eRFPath, rRfChannel, bMask20Bits, priv->pshare->RegRF18[eRFPath]);
+			//PHY_SetRFReg(priv, eRFPath, rRfChannel, (BIT(11)|BIT(10)), val);
+		}
 #endif
-
-		if (priv->pshare->phw->signal_strength != 2)
-			dig_on++;
-
-		priv->pshare->phw->signal_strength = 3;
-	}
-	else if (((rssi_strength < priv->pshare->rf_ft_var.digGoLowerLevel)
-		&& (priv->pshare->phw->signal_strength != 1)) || !priv->pshare->phw->signal_strength) {
-		// DIG off
-#ifndef CONFIG_RTL8672
-		set_DIG_state(priv, 0);
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv) == VERSION_8188E) {
+			unsigned int orig_val = PHY_QueryRFReg(priv, eRFPath, rRfChannel, bMask20Bits, 1);
+			if (val)
+				PHY_SetRFReg(priv, eRFPath, rRfChannel, bMask20Bits, orig_val|0x400|val);
+			else
+				PHY_SetRFReg(priv, eRFPath, rRfChannel, bMask20Bits, orig_val|val);
+		}
 #endif
+	}
 
-#ifndef CONFIG_RTL_92D_SUPPORT
-		if (priv->pshare->is_40m_bw)
-			//RTL_W8(0xc87, (RTL_R8(0xc87) & 0xf) | 0x30); 92D
-			RTL_W8(0xc87, 0x30);
-		else
-			RTL_W8(0xc30, 0x44);
+#if 0
+	if (priv->pshare->rf_ft_var.use_frq_2_3G)
+		PHY_SetRFReg(priv, RF90_PATH_C, 0x2c, 0x60, 0);
 #endif
+}
 
-		priv->pshare->phw->signal_strength = 1;
-	}
 
-	if (dig_on) {
-		// DIG on
-		set_DIG_state(priv, 1);
-	}
+void setup_timer1(struct rtl8192cd_priv *priv, int timeout)
+{
+	unsigned int current_value=RTL_R32(TSFTR);
+
+	if (TSF_LESS(timeout, current_value))
+		timeout = current_value+20;
 
-	//check_DC_TH_by_rssi(priv, rssi_strength);
+	RTL_W32(TIMER0, timeout);
+	RTL_W32(HIMR, RTL_R32(HIMR) | HIMR_TIMEOUT1);
 }
 
 
-void DIG_for_site_survey(struct rtl8192cd_priv *priv, int do_ss)
+void cancel_timer1(struct rtl8192cd_priv *priv)
 {
-	if (do_ss) {
-		// DIG off
-		set_DIG_state(priv, 0);
-	}
-	else {
-		// DIG on
-		if (priv->pshare->phw->signal_strength > 1) {
-			set_DIG_state(priv, 1);
-		}
-	}
+	RTL_W32(HIMR, RTL_R32(HIMR) & ~HIMR_TIMEOUT1);
 }
 
 
-/*
- * dynamic CCK CCA enhance by rssi
- */
-void CCK_CCA_dynamic_enhance(struct rtl8192cd_priv *priv, unsigned char rssi_strength)
+void setup_timer2(struct rtl8192cd_priv *priv, unsigned int timeout)
 {
-#if 1
-	unsigned int cck_fa = priv->pshare->FA_total_cnt;
-	int rssi_thd = 30;
-
-	if (rssi_strength == 0xff) {
-		if (cck_fa < 1000) {
-			if (priv->pshare->phw->CCK_CCA_enhanced != 2) {
-				RTL_W8(0xa0a, 0x40);
-				priv->pshare->phw->CCK_CCA_enhanced = 2;
-			}
-		} else {
-			if (priv->pshare->phw->CCK_CCA_enhanced != 1) {
-				RTL_W8(0xa0a, 0x83);
-				priv->pshare->phw->CCK_CCA_enhanced = 1;
-			}
-		}
-		return;
-	}
+	unsigned int current_value=RTL_R32(TSFTR);
 
-	if (rssi_strength > rssi_thd+5) {
-		if (priv->pshare->phw->CCK_CCA_enhanced != 0) {
-			RTL_W8(0xa0a, 0xcd);
-			priv->pshare->phw->CCK_CCA_enhanced = 0;
-		}
-	} else if (rssi_strength< rssi_thd) {
-		if ((rssi_strength > 9) || (priv->assoc_num >1)) {
-			if (priv->pshare->phw->CCK_CCA_enhanced != 1) {
-				RTL_W8(0xa0a, 0x83);
-				priv->pshare->phw->CCK_CCA_enhanced = 1;
-			}
-		} else {
-			if(cck_fa<1000) {
-				if (priv->pshare->phw->CCK_CCA_enhanced != 2) {
-					RTL_W8(0xa0a, 0x40);
-					priv->pshare->phw->CCK_CCA_enhanced = 2;
-				}
-			} else {
-				if (priv->pshare->phw->CCK_CCA_enhanced != 1) {
-					RTL_W8(0xa0a, 0x83);
-					priv->pshare->phw->CCK_CCA_enhanced = 1;
-				}
-			}
-		}
-	}
+	if (TSF_LESS(timeout, current_value))
+		timeout = current_value+20;
 
-#else
+	RTL_W32(TIMER1, timeout);
+	RTL_W32(HIMR, RTL_R32(HIMR) | HIMR_TIMEOUT2);
+}
 
-	if (rssi_strength == 0xff)
-		return;
 
-	if (!priv->pshare->phw->CCK_CCA_enhanced && (rssi_strength < 30)) {
-		priv->pshare->phw->CCK_CCA_enhanced = TRUE;
-		RTL_W8(0xa0a, 0x83);
-	}
-	else if (priv->pshare->phw->CCK_CCA_enhanced && (rssi_strength > 35)) {
-		priv->pshare->phw->CCK_CCA_enhanced = FALSE;
-		RTL_W8(0xa0a, 0xcd);
-	}
-#endif
+void cancel_timer2(struct rtl8192cd_priv *priv)
+{
+	RTL_W32(HIMR, RTL_R32(HIMR) & ~HIMR_TIMEOUT2);
 }
 
 
@@ -9260,108 +9155,6 @@ void rtl8192cd_tpt_timer(unsigned long task_priv)
 }
 #endif
 
-#ifdef HIGH_POWER_EXT_PA
-void tx_power_control(struct rtl8192cd_priv *priv)
-{
-	unsigned long x;
-
-	int pwr_value = 0x10101010;
-	if( priv->pshare->phw->signal_strength == 3 && priv->pshare->phw->lower_tx_power== 0) {
-		SAVE_INT_AND_CLI(x);
-		priv->pshare->phw->power_backup[0x00] = RTL_R32(rTxAGC_A_Rate18_06);
-		priv->pshare->phw->power_backup[0x01] = RTL_R32(rTxAGC_A_Rate54_24);
-		priv->pshare->phw->power_backup[0x02] = RTL_R32(rTxAGC_B_Rate18_06);
-		priv->pshare->phw->power_backup[0x03] = RTL_R32(rTxAGC_B_Rate54_24);
-		priv->pshare->phw->power_backup[0x04] = RTL_R32(rTxAGC_A_Mcs03_Mcs00);
-		priv->pshare->phw->power_backup[0x05] = RTL_R32(rTxAGC_A_Mcs07_Mcs04);
-		priv->pshare->phw->power_backup[0x06] = RTL_R32(rTxAGC_A_Mcs11_Mcs08);
-		priv->pshare->phw->power_backup[0x07] = RTL_R32(rTxAGC_A_Mcs15_Mcs12);
-		priv->pshare->phw->power_backup[0x08] = RTL_R32(rTxAGC_B_Mcs03_Mcs00);
-		priv->pshare->phw->power_backup[0x09] = RTL_R32(rTxAGC_B_Mcs07_Mcs04);
-		priv->pshare->phw->power_backup[0x0a] = RTL_R32(rTxAGC_B_Mcs11_Mcs08);
-		priv->pshare->phw->power_backup[0x0b] = RTL_R32(rTxAGC_B_Mcs15_Mcs12);
-		priv->pshare->phw->power_backup[0x0c] = RTL_R32(rTxAGC_A_CCK11_2_B_CCK11);
-		priv->pshare->phw->power_backup[0x0d] = RTL_R32(rTxAGC_A_CCK1_Mcs32);
-		priv->pshare->phw->power_backup[0x0e] = RTL_R32(rTxAGC_B_CCK5_1_Mcs32);
-		RTL_W32(rTxAGC_A_Rate18_06, pwr_value);
-		RTL_W32(rTxAGC_A_Rate54_24, pwr_value);
-		RTL_W32(rTxAGC_B_Rate18_06, pwr_value);
-		RTL_W32(rTxAGC_B_Rate54_24, pwr_value);
-		RTL_W32(rTxAGC_A_Mcs03_Mcs00, pwr_value);
-		RTL_W32(rTxAGC_A_Mcs07_Mcs04, pwr_value);
-		RTL_W32(rTxAGC_A_Mcs11_Mcs08, pwr_value);
-		RTL_W32(rTxAGC_A_Mcs15_Mcs12, pwr_value);
-		RTL_W32(rTxAGC_B_Mcs03_Mcs00, pwr_value);
-		RTL_W32(rTxAGC_B_Mcs07_Mcs04, pwr_value);
-		RTL_W32(rTxAGC_B_Mcs11_Mcs08, pwr_value);
-		RTL_W32(rTxAGC_B_Mcs15_Mcs12, pwr_value);
-		RTL_W32(rTxAGC_A_CCK11_2_B_CCK11, pwr_value);
-		RTL_W32(rTxAGC_A_CCK1_Mcs32, (pwr_value & 0x0000ff00) | (priv->pshare->phw->power_backup[0x0d] &0xffff00ff));
-		RTL_W32(rTxAGC_B_CCK5_1_Mcs32, (pwr_value & 0xffffff00) | (priv->pshare->phw->power_backup[0x0e] &0x000000ff));
-		priv->pshare->phw->lower_tx_power = 1;
-		RESTORE_INT(x);
-	}
-	else if( priv->pshare->phw->signal_strength != 3 && priv->pshare->phw->lower_tx_power) {
-		SAVE_INT_AND_CLI(x);
-		RTL_W32(rTxAGC_A_Rate18_06, priv->pshare->phw->power_backup[0x00]);
-		RTL_W32(rTxAGC_A_Rate54_24, priv->pshare->phw->power_backup[0x01]);
-		RTL_W32(rTxAGC_B_Rate18_06, priv->pshare->phw->power_backup[0x02]);
-		RTL_W32(rTxAGC_B_Rate54_24, priv->pshare->phw->power_backup[0x03]);
-		RTL_W32(rTxAGC_A_Mcs03_Mcs00, priv->pshare->phw->power_backup[0x04]);
-		RTL_W32(rTxAGC_A_Mcs07_Mcs04, priv->pshare->phw->power_backup[0x05]);
-		RTL_W32(rTxAGC_A_Mcs11_Mcs08, priv->pshare->phw->power_backup[0x06]);
-		RTL_W32(rTxAGC_A_Mcs15_Mcs12, priv->pshare->phw->power_backup[0x07]);
-		RTL_W32(rTxAGC_B_Mcs03_Mcs00, priv->pshare->phw->power_backup[0x08]);
-		RTL_W32(rTxAGC_B_Mcs07_Mcs04, priv->pshare->phw->power_backup[0x09]);
-		RTL_W32(rTxAGC_B_Mcs11_Mcs08, priv->pshare->phw->power_backup[0x0a]);
-		RTL_W32(rTxAGC_B_Mcs15_Mcs12, priv->pshare->phw->power_backup[0x0b]);
-		RTL_W32(rTxAGC_A_CCK11_2_B_CCK11, priv->pshare->phw->power_backup[0x0c]);
-		RTL_W32(rTxAGC_A_CCK1_Mcs32,  priv->pshare->phw->power_backup[0x0d]);
-		RTL_W32(rTxAGC_B_CCK5_1_Mcs32,  priv->pshare->phw->power_backup[0x0e]);
-		priv->pshare->phw->lower_tx_power = 0;
-		RESTORE_INT(x);
-	}
-}
-#endif
-
-#ifdef WIFI_WMM
-void check_NAV_prot_len(struct rtl8192cd_priv *priv, struct stat_info *pstat, unsigned int disassoc)
-{
-	if ((priv->pmib->dot11BssType.net_work_type & WIRELESS_11N) && pstat
-		&& pstat->ht_cap_len && pstat->is_intel_sta) {
-		if (!disassoc && (pstat->MIMO_ps & _HT_MIMO_PS_DYNAMIC_)) {
-#ifdef STA_EXT
-			if (pstat->aid <= FW_NUM_STAT)
-				priv->pshare->mimo_ps_dynamic_sta |= BIT(pstat->aid - 1);
-			else
-				priv->pshare->mimo_ps_dynamic_sta_ext |= BIT(pstat->aid - 1 - FW_NUM_STAT);
-#else
-			priv->pshare->mimo_ps_dynamic_sta |= BIT(pstat->aid -1);
-#endif
-		} else {
-#ifdef STA_EXT
-			if (pstat->aid <= FW_NUM_STAT)
-				priv->pshare->mimo_ps_dynamic_sta &= ~BIT(pstat->aid - 1);
-			else
-				priv->pshare->mimo_ps_dynamic_sta_ext &= ~BIT(pstat->aid - 1 - FW_NUM_STAT);
-#else
-			priv->pshare->mimo_ps_dynamic_sta &= ~BIT(pstat->aid -1);
-#endif
-		}
-
-		if (priv->pshare->mimo_ps_dynamic_sta
-#ifdef STA_EXT
-			|| priv->pshare->mimo_ps_dynamic_sta_ext
-#endif
-			) {
-			RTL_W8(NAV_PROT_LEN, 0x40);
-		} else {
-			RTL_W8(NAV_PROT_LEN, 0x20);
-		}
-	}
-}
-#endif
-
 
 /*
  *
@@ -9389,6 +9182,30 @@ static UCHAR CAM_find_usable(struct rtl8192cd_priv *priv)
 	unsigned char index;
 	int for_begin = 4;
 
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv) == VERSION_8188E) {
+#ifdef CONFIG_RTL_HW_WAPI_SUPPORT
+		for_begin = 3;
+#else
+		for_begin = 2;
+#endif
+#ifdef MBSSID
+		if (GET_ROOT(priv)->pmib->miscEntry.vap_enable)
+			for_begin = 0;
+#endif
+#ifdef UNIVERSAL_REPEATER
+		if (IS_VXD_INTERFACE(priv)) {
+			for_begin = 0;
+		} else {
+			if (IS_ROOT_INTERFACE(priv)) {
+				if (IS_DRV_OPEN(GET_VXD_PRIV(priv)))
+					for_begin = 0;
+			}
+		}
+#endif
+	}
+#endif
+
 	for (index=for_begin; index<TOTAL_CAM_ENTRY; index++) {
 		// polling bit, and No Write enable, and address
 		command = CAM_CONTENT_COUNT*index;
@@ -9466,6 +9283,7 @@ int CamAddOneEntry(struct rtl8192cd_priv *priv,unsigned char *pucMacAddr, unsign
 {
 	unsigned char retVal = 0, camIndex = 0, wpaContent = 0;
 	unsigned short usConfig = 0;
+	unsigned int set_dk_margin = 4;
 
     //use Hardware Polling to check the valid bit.
     //in reality it should be done by software link-list
@@ -9505,7 +9323,31 @@ int CamAddOneEntry(struct rtl8192cd_priv *priv,unsigned char *pucMacAddr, unsign
 		RTL_W16(SECCFG, RTL_R16(SECCFG) | RXDEC | TXENC | wpaContent | NOSKMC | CHK_KEYID);
 	}
 
-	if (camIndex < 4)
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv) == VERSION_8188E) {
+#ifdef CONFIG_RTL_HW_WAPI_SUPPORT
+		set_dk_margin = 3;
+#else
+		set_dk_margin = 2;
+#endif
+#ifdef MBSSID
+		if (GET_ROOT(priv)->pmib->miscEntry.vap_enable)
+			set_dk_margin = 0;
+#endif
+#ifdef UNIVERSAL_REPEATER
+		if (IS_VXD_INTERFACE(priv)) {
+			set_dk_margin = 0;
+		} else {
+			if (IS_ROOT_INTERFACE(priv)) {
+				if (IS_DRV_OPEN(GET_VXD_PRIV(priv)))
+					set_dk_margin = 0;
+			}
+		}
+#endif
+	}
+#endif
+
+	if (camIndex < set_dk_margin)
 		RTL_W16(SECCFG, (RTL_R16(SECCFG) & ~NOSKMC) | (RXBCUSEDK | TXBCUSEDK));
 
     return 1;
@@ -9597,7 +9439,7 @@ int CamDeleteOneEntry(struct rtl8192cd_priv *priv, unsigned char *pMacAddr, unsi
 	unsigned char ucIndex;
 	unsigned char ucTempMAC[6];
 	unsigned short usTempConfig=0;
-	int for_begin=0;
+	int for_begin=4;
 
 	// group key processing
 	if ((!memcmp(pMacAddr, "\xff\xff\xff\xff\xff\xff", 6)) || (useDK)) {
@@ -9612,7 +9454,29 @@ int CamDeleteOneEntry(struct rtl8192cd_priv *priv, unsigned char *pMacAddr, unsi
 			return 0;
 	}
 
-	for_begin = 4;
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv) == VERSION_8188E) {
+#ifdef CONFIG_RTL_HW_WAPI_SUPPORT
+		for_begin = 3;
+#else
+		for_begin = 2;
+#endif
+#ifdef MBSSID
+		if (GET_ROOT(priv)->pmib->miscEntry.vap_enable)
+			for_begin = 0;
+#endif
+#ifdef UNIVERSAL_REPEATER
+		if (IS_VXD_INTERFACE(priv)) {
+			for_begin = 0;
+		} else {
+			if (IS_ROOT_INTERFACE(priv)) {
+				if (IS_DRV_OPEN(GET_VXD_PRIV(priv)))
+					for_begin = 0;
+			}
+		}
+#endif
+	}
+#endif
 
 	// unicast key processing
 	// key processing for RTL818X(B) series
@@ -10091,7 +9955,7 @@ int PCIE_PowerDown(struct rtl8192cd_priv *priv, unsigned char *data)
 		signin_h2c_cmd(priv,cmd, 0 );
 		printk("sign in h2c cmd:%x, 0x284=%x\n", cmd, RTL_R32(0x284));
 
-#ifdef CONFIG_RTL_8198
+#if defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 		REG32(0xb8003000) |= BIT(16);		// GIMR
 #else
 		REG32(0xb8003000) |= BIT(9);		// GIMR
@@ -10112,12 +9976,22 @@ int PCIE_PowerDown(struct rtl8192cd_priv *priv, unsigned char *data)
 	 if(mode==0xa3) {
 		unsigned char tmp;
 
-#ifdef CONFIG_RTL_8198
-		REG32(0xb8000044) |= BIT(24);		//LEDPHASE4
-		REG32(0xb8003500) &= ~(BIT(20));	//PABCD_CNR , gpio pin
-		REG32(0xb8003508) &= ~(BIT(20));	//PABCD_DIR
-		REG32(0xb8003518) &= (~(0x03 << 8));
-		REG32(0xb8003518) |= (0x01 << 8);	// PCD_IMR		// enable interrupt in falling-edge
+#if defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+
+     if(GET_CHIP_VER(priv) == VERSION_8192D) {
+        REG32(0xb8000044) |= BIT(16)| BIT(17);                  //LEDPHASE1
+        REG32(0xb8003500) &= ~(BIT(17));                        //PABCD_CNR , gpio pin
+        REG32(0xb8003508) &= ~(BIT(17));                        //PABCD_DIR
+        REG32(0xb8003518) &= (~(0x03 << 2));
+        REG32(0xb8003518) |= (0x01 << 2);                       // PCD_IMR       
+      } else {
+        REG32(0xb8000044) |= BIT(24);                           //LEDPHASE4
+        REG32(0xb8003500) &= ~(BIT(20));                        //PABCD_CNR , gpio pin
+        REG32(0xb8003508) &= ~(BIT(20));                        //PABCD_DIR
+        REG32(0xb8003518) &= (~(0x03 << 8));
+        REG32(0xb8003518) |= (0x01 << 8);                       // PCD_IMR      
+      }
+
 		REG32(0xb8003000) |= BIT(16);		// GIMR
 #else
 		REG32(0xb8000040) |= 0x0c00;		//LEDPHASE1 :GPIOB7
@@ -10133,15 +10007,15 @@ int PCIE_PowerDown(struct rtl8192cd_priv *priv, unsigned char *data)
 		Sw_PCIE_Func2(priv->pshare->wlandev_idx);
 #endif
 
-		REG32(0xb8b10044) = 0x8108;
+		REG32(saddr+0x44) = 0x8108;
 		tmp = RTL_R8(0x690);
 		if(tmp&1)		{
 			tmp ^=0x1;
 			RTL_W8(0x690, tmp);
 		}
-		dprintf("0xb8b10044=%x,690=%x,3000=%x, 3514=%x\n",	REG32(0xb8b10044), RTL_R8(0x690), REG32(0xb8003000),REG32(0xb8003514) );
+		dprintf("0xb8b10044=%x,690=%x,3000=%x, 3514=%x\n",	REG32(saddr+0x44), RTL_R8(0x690), REG32(0xb8003000),REG32(0xb8003514) );
 		RTL_W8(0x690, tmp |0x1 );
-		dprintf("0xb8b10044=%x,690=%x\n",	REG32(0xb8b10044), RTL_R8(0x690) );
+		dprintf("0xb8b10044=%x,690=%x\n",	REG32(saddr+0x44), RTL_R8(0x690) );
 	 }
 
 	if(mode==0x5a)
@@ -10311,13 +10185,12 @@ void switch_to_1x1(struct rtl8192cd_priv *priv, int mode)
 		}
 	} else if(mode==OUT)	 {
 
-#ifdef CONFIG_RTL_92D_SUPPORT
-		 if (!(GET_CHIP_VER(priv)==VERSION_8192D))		 
-#endif
-		 {
+#ifdef CONFIG_RTL_92C_SUPPORT
+		 if (GET_CHIP_VER(priv)==VERSION_8192C) {
 		 	PHY_SetBBReg(priv, 0x88c, bMaskDWord, priv->pshare->rf_phy_bb_backup[21]);
 		 	PHY_SetBBReg(priv, 0x844, bMaskDWord, priv->pshare->rf_phy_bb_backup[0]);
 		 }		 
+#endif
 		 PHY_SetBBReg(priv, 0x85c, bMaskDWord, priv->pshare->rf_phy_bb_backup[1]);
 		 PHY_SetBBReg(priv, 0xe6c, bMaskDWord, priv->pshare->rf_phy_bb_backup[2]);
 
@@ -10344,10 +10217,10 @@ void switch_to_1x1(struct rtl8192cd_priv *priv, int mode)
 		 PHY_SetBBReg(priv, 0x90c, bMaskDWord , priv->pshare->rf_phy_bb_backup[19]);
 		 PHY_SetBBReg(priv, 0xa04, bMaskDWord , priv->pshare->rf_phy_bb_backup[22]);
 		 
-#ifdef CONFIG_RTL_92D_SUPPORT
-	  	if (!(GET_CHIP_VER(priv)==VERSION_8192D)) 	  
+#ifdef CONFIG_RTL_92C_SUPPORT
+	  	if (GET_CHIP_VER(priv)==VERSION_8192C) 	  
+			PHY_SetBBReg(priv, 0x804, bMaskDWord , priv->pshare->rf_phy_bb_backup[20]);
 #endif
-		 PHY_SetBBReg(priv, 0x804, bMaskDWord , priv->pshare->rf_phy_bb_backup[20]);
  	}
 }
 
@@ -10494,14 +10367,68 @@ int request_irq_for_wakeup_pin(struct net_device *dev)
 	else
 		saddr = CFG_92C_SLOTS;
 
-#ifdef CONFIG_RTL_8198
+#if defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+
+	#if defined(CONFIG_RTL_ULINKER)
+	{
+		// GPIO B5, b8000044 [10:9] = 2'b 11
+		REG32(0xb8000044) = (REG32(0xb8000044) & ~0x600) | 0x600;       //LEDPHASE1
+		REG32(0xb8003500) &= ~(BIT(13));			//PABCD_CNR , gpio pin
+		REG32(0xb8003508) &= ~(BIT(13));			//PABCD_DIR
+		REG32(0xb8003514) &= (~(0x03 << 26));
+		REG32(0xb8003514) |= (0x01 << 26);			// enable interrupt in falling-edge
+		REG32(PABCD_ISR) = BIT(13) ;				// clear int status
+	}
+	#else
+
+#if defined(CONFIG_RTL_92D_SUPPORT) && defined(CONFIG_RTL_8197D)
+	if(GET_CHIP_VER(priv) == VERSION_8192D) {
+		// GPIO B7, b8000044 [17:15] =3'b 100
+		REG32(0xb8000044) = (REG32(0xb8000044) & ~0x00038000) | BIT(17);       //LEDPHASE1
+		REG32(0xb8003500) &= ~(BIT(15));			//PABCD_CNR , gpio pin
+		REG32(0xb8003508) &= ~(BIT(15));			//PABCD_DIR
+		REG32(0xb8003514) &= (~(0x03 << 30));
+		REG32(0xb8003514) |= (0x01 << 30);			// enable interrupt in falling-edge
+		REG32(PABCD_ISR) = BIT(15) ;				// clear int status
+		
+	} else 
+#endif
+	{
+		// GPIO A4, b8000040 [2:0] = 3'b 110
+		REG32(0xb8000040) = (REG32(0xb8000040) & ~0x7) | 0x6;                //JTAG_TMS
+		REG32(0xb8003500) &= ~(BIT(4));			//PABCD_CNR , gpio pin
+		REG32(0xb8003508) &= ~(BIT(4));			//PABCD_DIR
+		REG32(0xb8003514) &= (~(0x03 << 8));
+		REG32(0xb8003514) |= (0x01 << 8);			// enable interrupt in falling-edge
+		REG32(PABCD_ISR) = BIT(4) ;					// clear int status
+	}
+	#endif /* #if defined(CONFIG_RTL_ULINKER) */
+
+  	REG32(0xb8003000) |= BIT(16);                   // GIMR
+
+#elif defined(CONFIG_RTL_8198)
+#ifdef CONFIG_RTL_92D_SUPPORT
+	if(GET_CHIP_VER(priv) == VERSION_8192D) {
+// GPIO C1
+		REG32(0xb8000044) |= BIT(16)|BIT(17);       //LEDPHASE1
+		REG32(0xb8003500) &= ~(BIT(17));			//PABCD_CNR , gpio pin
+		REG32(0xb8003508) &= ~(BIT(17));			//PABCD_DIR
+		REG32(0xb8003518) &= (~(0x03 << 2));
+		REG32(0xb8003518) |= (0x01 << 2);			// enable interrupt in falling-edge
+		REG32(PABCD_ISR) = BIT(17) ;				// clear int status
+		
+	} else 
+#endif
+	{
 // GPIO C4
-	REG32(0xb8000044) |= BIT(24);				//LEDPHASE4
-	REG32(0xb8003500) &= ~(BIT(20));			//PABCD_CNR , gpio pin
-	REG32(0xb8003508) &= ~(BIT(20));			//PABCD_DIR
-	REG32(0xb8003518) &= (~(0x03 << 8));
-	REG32(0xb8003518) |= (0x01 << 8);			// PCD_IMR		// enable interrupt in falling-edge
-	REG32(0xb8003000) |= BIT(16);				// GIMR
+		REG32(0xb8000044) |= BIT(24);                //LEDPHASE4
+		REG32(0xb8003500) &= ~(BIT(20));			//PABCD_CNR , gpio pin
+		REG32(0xb8003508) &= ~(BIT(20));			//PABCD_DIR
+		REG32(0xb8003518) &= (~(0x03 << 8));
+		REG32(0xb8003518) |= (0x01 << 8);			// enable interrupt in falling-edge
+		REG32(PABCD_ISR) = BIT(20) ;					// clear int status
+	}
+  	REG32(0xb8003000) |= BIT(16);                   // GIMR
 #else
 // GPIO B7
 	REG32(0xb8000040) |= 0x0c00;				//LEDPHASE1 :GPIOB7
@@ -10510,6 +10437,8 @@ int request_irq_for_wakeup_pin(struct net_device *dev)
 	REG32(0xb8003514) &= (~(0x03 << 30));
 	REG32(0xb8003514) |= (0x01 << 30);			// PAB_IMR		// enable interrupt in falling-edge
 	REG32(0xb8003000) |= BIT(9);				// GIMR
+
+	REG32(PABCD_ISR) = BIT(15) ;		// clear int status
 #endif
 
 #ifdef CONFIG_RTL_92D_DMDP
@@ -10517,7 +10446,6 @@ int request_irq_for_wakeup_pin(struct net_device *dev)
 #endif	
 
 	REG32(saddr+0x44) = 0x8108; 						// clear pme status
-	REG32(PABCD_ISR) = REG32(PABCD_ISR) ;		// clear int status
 
 #ifdef CONFIG_RTL_92D_DMDP
 	Sw_PCIE_Func2(0);
@@ -10528,6 +10456,7 @@ int request_irq_for_wakeup_pin(struct net_device *dev)
 #else
 	return request_irq(1, gpio_wakeup_isr, SA_SHIRQ, "rtl_gpio", dev);
 #endif
+
 }
 #endif
 
@@ -10540,7 +10469,7 @@ void init_pcie_power_saving(struct rtl8192cd_priv *priv)
 		saddr = CFG_92D_SLOTS;
 	else
 		saddr = CFG_92C_SLOTS;
-
+	
 // Jason : clk req
 #if 0
 		REG32(0xb9000354)=8;
@@ -10574,7 +10503,9 @@ void init_pcie_power_saving(struct rtl8192cd_priv *priv)
 #endif
 
 	REG32(saddr+ 0x80)|= 0x0100;
+#ifdef ASPM_ENABLE
 	REG32(saddr+ 0x80)|= 0x43;
+#endif
 	REG32(saddr+ 0x0778)|= BIT(5)<<8;
 
 #ifdef CONFIG_RTL_92C_SUPPORT
@@ -10595,13 +10526,18 @@ void init_pcie_power_saving(struct rtl8192cd_priv *priv)
 //	RTL_W16(0x558, 0x040a);
 //	RTL_W16(0x100 , RTL_R16(0x100) | BIT(8));		// enable sw beacon
 
+#ifdef CONFIG_RTL_92C_SUPPORT
 	if (IS_TEST_CHIP(priv)) {
 		priv->pshare->rf_ft_var.power_save &= (~ L2_en);
 		priv->pshare->rf_ft_var.power_save &= (~ASPM_en);
-	} else {
+	} else 
+#endif
+	{
 		RTL_W8(0x08, RTL_R8(0x08) | BIT(3));		// WAKEPAN_EN
+#ifdef CONFIG_RTL_92C_SUPPORT		
 		if(IS_UMC_A_CUT_88C(priv))
 			priv->pshare->rf_ft_var.power_save &= (~ASPM_en);
+#endif			
 
 	}
 #ifdef ASPM_ENABLE
@@ -10609,7 +10545,7 @@ void init_pcie_power_saving(struct rtl8192cd_priv *priv)
 #endif
 
 #ifdef CONFIG_RTL_92D_DMDP
-	Sw_PCIE_Func2(0);
+	Sw_PCIE_Func2(1);
 #endif
 
 }
@@ -10690,7 +10626,7 @@ void PCIe_power_save_timer(unsigned long task_priv)
 						tasklet_schedule(&priv->pshare->ps_tasklet);
 				} else {
 					priv->offload_ctrl = 1;
-					RTL_W16(0x100 , RTL_R16(0x100) | BIT(8));		// enable sw beacon
+					RTL_W16(CR , RTL_R16(CR) | ENSWBCN);		// enable sw beacon
 					mod_timer(&priv->ps_timer, jiffies + RTL_SECONDS_TO_JIFFIES(1));
 					return;
 				}
@@ -10734,10 +10670,9 @@ void PCIe_power_save_tasklet(unsigned long task_priv)
 {
 	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *)task_priv;
 	char in_out, L1_L2;
-	unsigned int tmp32=0,status=0,portnum=0, page=0, ctr;
+	unsigned int tmp32=0,status=0,portnum=0, page=0, ctr, i;
 	unsigned long flags;
 
-
 	unsigned int saddr, haddr;
 	if (GET_CHIP_VER(priv) == VERSION_8192D) {
 		saddr = CFG_92D_SLOTS;
@@ -10779,7 +10714,7 @@ void PCIe_power_save_tasklet(unsigned long task_priv)
 			  REG32(saddr+0x80) &= ~(0x3);
 			}
 #endif			
-			RTL_W8(0x302, 0x2);   // sw L123
+			RTL_W8(PCIE_CTRL_REG+2, 0x2);   // sw L123
 			RTL_W16(PCIE_CTRL_REG, 0xff00 );
 			REG32(saddr+0x44) |= 0x8108;
 
@@ -10794,7 +10729,6 @@ void PCIe_power_save_tasklet(unsigned long task_priv)
 			return;
 		}
 #endif
-		RTL_W8(0x286,  4);
 
 #ifdef ASPM_ENABLE
 		if( priv->pwr_state==ASPM_L0s_L1) {
@@ -10804,16 +10738,39 @@ void PCIe_power_save_tasklet(unsigned long task_priv)
 #endif
 
 //		RTL_W8(0x286,  4);
-		RTL_W8(0x302, 0x2);   // sw L123
+		RTL_W8(PCIE_CTRL_REG+2, 0x2);   // sw L123
 		REG32(saddr+0x44) |= 0x8108; 		// clear pme status
 
-		RTL_W16(0x4dc, priv->pshare->phw->seq);
-		RTL_W8(0x423, 0x7f);			// mac seq
+		RTL_W16(NQOS_SEQ, priv->pshare->phw->seq);
+		RTL_W8(HWSEQ_CTRL, 0x7f);			// mac seq
 
-		if(priv->pshare->rf_ft_var.power_save&stop_dma_en) {
-				RTL_W16(PCIE_CTRL_REG, 0xff00 );
-				delay_ms(1);
+		ctr=3000;
+		do {
+			  delay_us(100);
+			if(!RTL_R8(PCIE_CTRL_REG)) {
+				RTL_W8(PCIE_CTRL_REG+1, 0xfe );
+				break;
+			}
+		} while(ctr--);
+		if(!ctr) {
+			status = 1;
+		}
+		ctr=3000;
+		do {
+			  delay_us(100);
+			if( ((RTL_R32(0x200) ^ RTL_R32(0x204))==0) && 
+				(((RTL_R32(VOQ_INFO) |RTL_R32(VIQ_INFO)|RTL_R32(BEQ_INFO)|RTL_R32(BKQ_INFO)
+				|RTL_R32(MGQ_INFO)|RTL_R32(HIQ_INFO))&0xffff00)==0)
+				) { 				
+				break;
+			}
+		} while(ctr--); 
+		if(!ctr) {
+			status = 1;
 		}
+		RTL_W8(TXPAUSE, 0x2f);
+		delay_ms(1);
+
 #ifdef PCIE_L2_ENABLE
 		if (L1_L2 == L2) {
 			int 	tx_head, tx_tail, q_num;
@@ -10825,7 +10782,7 @@ void PCIe_power_save_tasklet(unsigned long task_priv)
 				while (tx_tail != tx_head) {
 					pdesc	  = phdesc + (tx_tail);
 					pdesc->Dword0 &= set_desc(~TX_OWN);
-					tx_tail = (tx_tail + 1) % NUM_TX_DESC;
+					tx_tail = (tx_tail + 1) % CURRENT_NUM_TX_DESC;
 				}
 			}
 #ifdef SMP_SYNC
@@ -10843,6 +10800,9 @@ void PCIe_power_save_tasklet(unsigned long task_priv)
 			switch_to_1x1(priv,	IN);
 
 		page = ((priv->offload_ctrl)>>7)&0xff;
+		RTL_W16(RCR, RTL_R16(RCR) & ~(BIT(11)|BIT(12)|BIT(13)));
+		RTL_W16(RXFLTMAP0, RTL_R16(RXFLTMAP0) |BIT(11)|BIT(4));
+
 		if(priv->pshare->rf_ft_var.power_save&offload_en)  {
 
 			if(GET_CHIP_VER(priv) != VERSION_8192D)
@@ -10851,6 +10811,9 @@ void PCIe_power_save_tasklet(unsigned long task_priv)
 				status |= signin_h2c_cmd(priv, _RSVDPAGE_CMD_ | BIT(7) | (page<<8), (page<<8)| (page) );
 
 			status |= signin_h2c_cmd(priv, _AP_OFFLOAD_CMD_ | (1<<8) |(HIDDEN_AP<<16) | ((GET_MIB(priv))->dot11OperationEntry.deny_any)<<24, 0 );
+#if defined(__LINUX_2_6__)
+			RTL_W32(HIMR, 0);
+#endif
 			DEBUG_INFO("%s, LINE:%d, h2c %x, %x, %x\n", __FUNCTION__, __LINE__,
 				(_RSVDPAGE_CMD_ | page<<8), (_RSVDPAGE_CMD_ | BIT(7) | (page<<8), (page<<8)| (page)),
 				(_AP_OFFLOAD_CMD_ | (1<<8) |(HIDDEN_AP<<16) | ((GET_MIB(priv))->dot11OperationEntry.deny_any)<<24)
@@ -10858,21 +10821,30 @@ void PCIe_power_save_tasklet(unsigned long task_priv)
 				ctr=3000;
 				do {
 					  delay_us(10);
-					page = RTL_R8(0x286) ;
-					if(page & 4)
+					page = RTL_R8(RXPKT_NUM+2)&6 ;
+					if(page==6)
 						break;
 				} while(ctr--);
-			if(status || !(page&4)) {
+				
+			if(status || (page!=6)) {
 				DEBUG_INFO("signin_h2c_cmd fail(ap offload), 286=%x\n", page);
 				if ((get_rf_mimo_mode(priv) == MIMO_2T2R) && (priv->pshare->rf_ft_var.power_save&_1x1_en))
 					switch_to_1x1(priv, OUT);
-				RTL_W16(PCIE_CTRL_REG, 0xff);
-				RTL_W8(0x423, 0x0); 		// mac seq disable
-				RTL_W8(0x286, 0);
+				RTL_W8(HWSEQ_CTRL, 0x0); 		// mac seq disable
+				RTL_W8(RXPKT_NUM+2, 0);
+
+				RTL_W16(RCR, RTL_R16(RCR) | (BIT(11)|BIT(13)));
+				RTL_W16(RXFLTMAP0, RTL_R16(RXFLTMAP0) & ~(BIT(11)|BIT(4))); 
+
+				RTL_W8(PCIE_CTRL_REG+1, 0x00);	// enable DMA
+				RTL_W8(TXPAUSE, 0x0);
+
+				priv->offload_ctrl =0;
 				RESTORE_INT(flags);
 				return;
 			}
 		}
+		RTL_W16(CR , RTL_R16(CR) | ENSWBCN);		// enable sw beacon
 
 		if( L1_L2 == L1){
   		
@@ -10920,7 +10892,7 @@ void PCIe_power_save_tasklet(unsigned long task_priv)
 			printk("PME turn off -> L2\n");		  
 		}
 #endif
-#ifdef CONFIG_RTL_8198
+#if defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 		REG32(0xb8003000) |= BIT(16);		// GIMR
 #else
 		REG32(0xb8003000) |= BIT(9);		// GIMR
@@ -10959,8 +10931,8 @@ void PCIe_power_save_tasklet(unsigned long task_priv)
 			 if( priv->pwr_state == L1) {
 			 
 #ifdef CONFIG_RTL_92D_DMDP
-				for(page=0; page<2; page++) {
-					Sw_PCIE_Func2(page);
+				for(i=0; i<2; i++) {
+					Sw_PCIE_Func2(i);
 #endif
 					ctr=3000;
 #if 0 //saving more power, leave L1 write
@@ -10980,7 +10952,7 @@ void PCIe_power_save_tasklet(unsigned long task_priv)
 						panic_printk("change to L0 fail!!!, status=%x, MAC0\n", status);
 					else
 #ifdef CONFIG_RTL_92D_DMDP
-					((struct rtl8192cd_priv *)if_priv[page])->pwr_state = L0;
+					((struct rtl8192cd_priv *)if_priv[i])->pwr_state = L0;
 				}
 #else
 			  priv->pwr_state = L0;
@@ -10997,7 +10969,7 @@ void PCIe_power_save_tasklet(unsigned long task_priv)
 
 		if(priv->pshare->rf_ft_var.power_save&offload_en) {
 			signin_h2c_cmd(priv, _AP_OFFLOAD_CMD_ , 0 );		// offload
-			delay_ms(1);
+			delay_ms(2);		
 		}
 
 		if ((get_rf_mimo_mode(priv) == MIMO_2T2R) &&(priv->pshare->rf_ft_var.power_save&_1x1_en))
@@ -11019,23 +10991,24 @@ void PCIe_power_save_tasklet(unsigned long task_priv)
 			RTL_W32(RX_DESA, priv->pshare->phw->ring_dma_addr);
 		}
 #endif
-		if(priv->pshare->rf_ft_var.power_save&stop_dma_en) {
-			RTL_W16(PCIE_CTRL_REG, 0xff);
-		}
-
 		// wait until FW stop parsing packet
 		ctr = 1000;
 		do {
 			if(!(RTL_R8(FWIMR) & FWIMR_RXDONE))
 				break;
-			delay_us(100);
+			delay_us(200);
 		} while(ctr--) ;
 		if(!ctr)
 			DEBUG_ERR("stop offload fail\n");
 
-		RTL_W8(0x423, 0x0); 		// mac seq disable
-		RTL_W8(0x286, 0);			// RW_RELEASE_ENABLE
-		RTL_W8(0x302, 0x3);			// sw L123
+		RTL_W8(HWSEQ_CTRL, 0x0); 		// mac seq disable
+		RTL_W8(RXPKT_NUM+2, 0);			// RW_RELEASE_ENABLE
+		RTL_W16(RCR, RTL_R16(RCR) | (BIT(11)|BIT(13)));
+		RTL_W16(RXFLTMAP0, RTL_R16(RXFLTMAP0) & ~(BIT(11)|BIT(4)));	
+		RTL_W8(PCIE_CTRL_REG+1, 0x00);	// enable DMA
+		RTL_W8(PCIE_CTRL_REG+2, 0x3);	// sw L123		
+		RTL_W8(TXPAUSE, 0x0);
+		RTL_W16(CR , RTL_R16(CR) & ~ENSWBCN);
 
 #ifdef CONFIG_RTL_92D_DMDP
 		if((priv->pshare->wlandev_idx ==0) && (priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY)) {
@@ -11080,7 +11053,7 @@ void PCIeWakeUp(struct rtl8192cd_priv *priv, unsigned int expTime)
 		} else 
 #endif
 		{
-			priv->ps_ctrl = 0x82 | (priv->pwr_state<<4);
+			priv->ps_ctrl = 0x02 | (priv->pwr_state<<4);
 			PCIe_power_save_tasklet((unsigned long)priv);
 		}
 		
@@ -11101,22 +11074,47 @@ gpio_wakeup_isr(int irq, void *dev_instance, struct pt_regs *regs)
 	struct rtl8192cd_priv *priv = NULL;
 
 	unsigned int saddr;
+
+	dev = (struct net_device *)dev_instance;
+	priv = (struct rtl8192cd_priv *)dev->priv;
+
 	if (GET_CHIP_VER(priv) == VERSION_8192D) {
 		saddr = CFG_92D_SLOTS;
 	} else {
 		saddr = CFG_92C_SLOTS;
 	}
 
-	dev = (struct net_device *)dev_instance;
-	priv = (struct rtl8192cd_priv *)dev->priv;
-
 #ifdef CONFIG_RTL_92D_DMDP
 	Sw_PCIE_Func2(priv->pshare->wlandev_idx);
 #endif
 
 	DEBUG_INFO("%s, PABCD_ISR=%x\t", dev->name, REG32(PABCD_ISR));
-	REG32(PABCD_ISR) = REG32(PABCD_ISR) ;
-	DEBUG_INFO("\nPABCD_ISR=%x,0xb8100044=%x\n", REG32(PABCD_ISR), REG32(saddr+0x44));
+	
+#if defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+
+	#if defined(CONFIG_RTL_ULINKER)
+		REG32(PABCD_ISR) = BIT(13) ; 	// clear int status
+	#else
+#if defined(CONFIG_RTL_92D_SUPPORT) && defined(CONFIG_RTL_8197D)
+	if(GET_CHIP_VER(priv) == VERSION_8192D)		
+		REG32(PABCD_ISR) = BIT(15) ;
+	else 
+#endif
+		REG32(PABCD_ISR) = BIT(4) ;		// clear int status
+	#endif /* #if defined(CONFIG_RTL_ULINKER) */
+
+#elif defined(CONFIG_RTL_8198)
+#ifdef CONFIG_RTL_92D_SUPPORT
+	if(GET_CHIP_VER(priv) == VERSION_8192D)		
+		REG32(PABCD_ISR) = BIT(17) ;
+	else 
+#endif
+		REG32(PABCD_ISR) = BIT(20) ;		// clear int status
+#else
+	REG32(PABCD_ISR) = BIT(15) ;			// clear int status
+#endif
+
+	DEBUG_INFO(", PABCD_ISR=%x,0xb8100044=%x\n", REG32(PABCD_ISR), REG32(saddr+0x44));
 
 #ifdef GPIO_WAKEPIN
 #ifdef PCIE_POWER_SAVING_DEBUG
@@ -11126,7 +11124,7 @@ gpio_wakeup_isr(int irq, void *dev_instance, struct pt_regs *regs)
 		del_timer_sync(&priv->ps_timer);
 
 	if( priv->pwr_state == L1 || priv->pwr_state == L2) {
-		priv->ps_ctrl = 0x82 | (priv->pwr_state<<4);
+		priv->ps_ctrl = 0x02 | (priv->pwr_state<<4);
 		PCIe_power_save_tasklet((unsigned long)priv);
 	}		
 	
@@ -11152,6 +11150,7 @@ void radio_off(struct rtl8192cd_priv *priv)
 
 
 #ifdef EN_EFUSE
+#define VOLTAGE_V25		0x03
 /*-----------------------------------------------------------------------------
  * Function:	efuse_PowerSwitch
  *
@@ -11170,7 +11169,7 @@ void radio_off(struct rtl8192cd_priv *priv)
  * 11/17/2008 	MHC		Create Version 0.
  *
  *---------------------------------------------------------------------------*/
-static void efuse_PowerSwitch(struct rtl8192cd_priv *priv, unsigned char PwrState)
+static	void efuse_PowerSwitch(struct rtl8192cd_priv *priv, unsigned char bWrite, unsigned char PwrState)
 {
 	unsigned char tempval;
 	short tmpV16;
@@ -11193,17 +11192,23 @@ static void efuse_PowerSwitch(struct rtl8192cd_priv *priv, unsigned char PwrStat
 			tmpV16 |= (LOADER_CLK_EN |ANA8M);
 			RTL_W16(SYS_CLKR, tmpV16);
 		}
-		// Enable LDO 2.5V before read/write action
-		tempval = RTL_R8(EFUSE_TEST+3);
-		RTL_W8(EFUSE_TEST+3, (tempval | 0x80));
+
+		if (bWrite == TRUE) {
+			// Enable LDO 2.5V before read/write action
+			tempval = RTL_R8(EFUSE_TEST+3);
+			tempval &= 0x0F;
+			tempval |= (VOLTAGE_V25 << 4);
+			RTL_W8(EFUSE_TEST+3, (tempval | 0x80));
+		}
 	} else {
-		// Disable LDO 2.5V after read/write action
-		tempval = RTL_R8(EFUSE_TEST+3);
-		RTL_W8(EFUSE_TEST+3, (tempval & 0x7F));
+		if (bWrite == TRUE) {
+			// Disable LDO 2.5V after read/write action
+			tempval = RTL_R8(EFUSE_TEST+3);
+			RTL_W8(EFUSE_TEST+3, (tempval & 0x7F));
+		}
 	}
 }	/* efuse_PowerSwitch */
 
-
 static void ReadEFuseByte(struct rtl8192cd_priv *priv, unsigned short _offset, unsigned char *pbuf)
 {
 	unsigned int   	value32;
@@ -11228,6 +11233,14 @@ static void ReadEFuseByte(struct rtl8192cd_priv *priv, unsigned short _offset, u
 		value32 = RTL_R32(EFUSE_CTRL);
 		retry++;
 	}
+
+	// 20100205 Joseph: Add delay suggested by SD1 Victor.
+	// This fix the problem that Efuse read error in high temperature condition.
+	// Designer says that there shall be some delay after ready bit is set, or the
+	// result will always stay on last data we read.
+	delay_us(50);
+	value32 = RTL_R32(EFUSE_CTRL);
+	
 	*pbuf = (unsigned char)(value32 & 0xff);
 }	/* ReadEFuseByte */
 
@@ -11397,9 +11410,9 @@ static void efuse_ReadAllMap(struct rtl8192cd_priv *priv, unsigned char *Efuse)
 	//
 	// We must enable clock and LDO 2.5V otherwise, read all map will be fail!!!!
 	//
-	efuse_PowerSwitch(priv, TRUE);
+	efuse_PowerSwitch(priv, FALSE, TRUE);
 	ReadEFuse(priv, 0, EFUSE_MAP_LEN, Efuse);
-	efuse_PowerSwitch(priv, FALSE);
+	efuse_PowerSwitch(priv, FALSE, FALSE);
 }
 
 
@@ -11441,7 +11454,7 @@ static int isPGValueValid(struct rtl8192cd_priv *priv, unsigned char *hwinfo)
 {
 	int j;
 #ifdef CONFIG_RTL_92C_SUPPORT
-	if (GET_CHIP_VER(priv) != VERSION_8192D) {
+	if ((GET_CHIP_VER(priv) == VERSION_8188C) || (GET_CHIP_VER(priv) == VERSION_8192C)) {
 		for (j=EEPROM_TxPowerCCK; j<EEPROM_TxPowerCCK+3; j++) {
 			if (hwinfo[j] > 63)
 				return 0;
@@ -11491,7 +11504,7 @@ void ReadTxPowerInfoFromHWPG(struct rtl8192cd_priv *priv)
 	if (/*priv->AutoloadFailFlag==FALSE &&*/ priv->pmib->efuseEntry.enable_efuse==1) {
 		u8 TxPwrCCK=0, TxPwrHT40_1S=0, TxPwrHT40_2SDiff=0, TxPwrHT20Diff=0, TxPwrOFDMDiff=0;
 #ifdef CONFIG_RTL_92C_SUPPORT
-		if (GET_CHIP_VER(priv)!=VERSION_8192D){
+		if ((GET_CHIP_VER(priv) == VERSION_8188C) || (GET_CHIP_VER(priv) == VERSION_8192C)) {
 			TxPwrCCK = EEPROM_TxPowerCCK;
 			TxPwrHT40_1S = EEPROM_TxPowerHT40_1S;
 			TxPwrHT40_2SDiff = EEPROM_TxPowerHT40_2SDiff;
@@ -11653,7 +11666,7 @@ static void ReadMacAddressFromEfuse(struct rtl8192cd_priv *priv)
 #endif
 
 #ifdef CONFIG_RTL_92C_SUPPORT
-	if (GET_CHIP_VER(priv) != VERSION_8192D) {
+	if ((GET_CHIP_VER(priv) == VERSION_8188C) || (GET_CHIP_VER(priv) == VERSION_8192C)) {
 		efuse_MAC = EEPROM_MACADDRESS;
 	}
 #endif
@@ -11714,7 +11727,7 @@ void ReadThermalMeterFromEfuse(struct rtl8192cd_priv *priv)
 		return;
 
 #ifdef CONFIG_RTL_92C_SUPPORT
-	if (GET_CHIP_VER(priv) != VERSION_8192D) {
+	if ((GET_CHIP_VER(priv) == VERSION_8188C) || (GET_CHIP_VER(priv) == VERSION_8192C)) {
 		efuse_Ther = EEPROM_THERMAL_METER;
 	}
 #endif
@@ -11816,9 +11829,9 @@ int ReadAdapterInfo8192CE(struct rtl8192cd_priv *priv)
 	ReadMacAddressFromEfuse(priv);
 #ifdef CONFIG_RTL_92D_SUPPORT
 	if (GET_CHIP_VER(priv)==VERSION_8192D){
-	ReadCrystalCalibrationFromEfuse(priv);
-	ReadDeltaValFromEfuse(priv);
-	ReadTRSWPAPEFromEfuse(priv);
+		ReadCrystalCalibrationFromEfuse(priv);
+		ReadDeltaValFromEfuse(priv);
+		ReadTRSWPAPEFromEfuse(priv);
 	}
 #endif
 
@@ -11859,7 +11872,7 @@ static int getEEPROMOffset(struct rtl8192cd_priv *priv, int type)
 	int offset=0;
 
 #ifdef CONFIG_RTL_92C_SUPPORT
-	if (GET_CHIP_VER(priv) != VERSION_8192D) {
+	if ((GET_CHIP_VER(priv) == VERSION_8188C) || (GET_CHIP_VER(priv) == VERSION_8192C)) {
 		switch(type) {
 		case 0:	offset = EEPROM_TxPowerCCK;
 				break;
@@ -12171,22 +12184,16 @@ static INT32 WriteEFuseByte(struct rtl8192cd_priv *priv, UINT16 addr, UINT8 data
 {
 	UINT8 tmpidx = 0;
 	INT32 bResult;
-	UINT8 val8;
 
 //	DEBUG_INFO("Addr = %x Data=%x\n", addr, data);
 
 	// -----------------e-fuse reg ctrl ---------------------------------
 	//address
 	RTL_W8( EFUSE_CTRL+1, (UINT8)(addr&0xff));
-	val8 = RTL_R8( EFUSE_CTRL+1);
 	RTL_W8( EFUSE_CTRL+2, 	(RTL_R8(EFUSE_CTRL+2)&0xFC )|(UINT8)((addr>>8)&0x03));
 	RTL_W8( EFUSE_CTRL, data);//data
-#if 1
+
 	RTL_W8( EFUSE_CTRL+3, 0xF2	);//write cmd
-#else
-	// use default program time 5000 ns
-	PlatformEFIOWrite4Byte(pAdapter,  REG_EFUSE_CTRL, (PlatformEFIORead4Byte(pAdapter,REG_EFUSE_CTRL)|( EF_FLAG)));//write cmd
-#endif
 
 	while((0x80 &  RTL_R8(EFUSE_CTRL+3)) && (tmpidx<100) ){
 		tmpidx++;
@@ -12740,7 +12747,7 @@ static int EFUSE_ShadowUpdate(struct rtl8192cd_priv *priv)
 		return FALSE;
 	}
 	// For Efuse write action, we must enable LDO2.5V and 40MHZ clk.
-	efuse_PowerSwitch(priv,TRUE);
+	efuse_PowerSwitch(priv,TRUE,TRUE);
 
 	//
 	// Efuse support 16 write are with PG header packet!!!!
@@ -12780,7 +12787,7 @@ static int EFUSE_ShadowUpdate(struct rtl8192cd_priv *priv)
 	}
 
 	// For warm reboot, we must resume Efuse clock to 500K.
-	efuse_PowerSwitch(priv, FALSE);
+	efuse_PowerSwitch(priv,TRUE, FALSE);
 
 	//
 	// <Roger_Notes> We update both init shadow map again and modified map
@@ -12802,7 +12809,7 @@ static void shadowMapWrite(struct rtl8192cd_priv *priv, int type, char *value, u
 		return;
 
 #ifdef CONFIG_RTL_92C_SUPPORT
-	if (GET_CHIP_VER(priv) != VERSION_8192D) {
+	if ((GET_CHIP_VER(priv) == VERSION_8188C) || (GET_CHIP_VER(priv) == VERSION_8192C)) {
 		if (offset == EEPROM_MACADDRESS) {
 			for (i=0; i<MACADDRLEN; i++) {
 				get_array_val(hwinfo+offset+i, value+i*2, 2);
@@ -12912,7 +12919,7 @@ static int converToFlashFormat(struct rtl8192cd_priv *priv, unsigned char *out,
 	len += 1 + strlen(FLASH_NAME_PARAM[type]);
 
 #ifdef CONFIG_RTL_92C_SUPPORT
-	if (GET_CHIP_VER(priv) != VERSION_8192D) {
+	if ((GET_CHIP_VER(priv) == VERSION_8188C) || (GET_CHIP_VER(priv) == VERSION_8192C)) {
 		if (offset == EEPROM_MACADDRESS) {
 			for (i=0; i<MACADDRLEN; i++) {
 				sprintf(out+len, "%02x", hwinfo[offset+i]);
@@ -13235,7 +13242,7 @@ int efuse_get(struct rtl8192cd_priv *priv, unsigned char *data)
 	int j, len, para_num=0;
 
 #ifdef CONFIG_RTL_92C_SUPPORT
-	if (GET_CHIP_VER(priv) != VERSION_8192D)
+	if ((GET_CHIP_VER(priv) == VERSION_8188C) || (GET_CHIP_VER(priv) == VERSION_8192C))
 		para_num = EFUSECMD_NUM_92C;
 #endif
 #ifdef CONFIG_RTL_92D_SUPPORT
@@ -13258,10 +13265,9 @@ int efuse_set(struct rtl8192cd_priv *priv, unsigned char *data)
 {
 	char *val;
 	int j, para_num=0;
-	extern char *get_value_by_token(char *data, char *token);
 
 #ifdef CONFIG_RTL_92C_SUPPORT
-	if (GET_CHIP_VER(priv) != VERSION_8192D)
+	if ((GET_CHIP_VER(priv) == VERSION_8188C) || (GET_CHIP_VER(priv) == VERSION_8192C))
 		para_num = EFUSECMD_NUM_92C;
 #endif
 #ifdef CONFIG_RTL_92D_SUPPORT
@@ -13288,633 +13294,19 @@ int efuse_sync(struct rtl8192cd_priv *priv, unsigned char *data)
 }
 #endif // EN_EFUSE
 
-
-
-#ifdef SW_ANT_SWITCH
-
-//
-// 20100514 Luke/Joseph:
-// Add new function to reset antenna diversity state after link.
-//
-
-void resetSwAntDivVariable(struct rtl8192cd_priv *priv)
-{
-	priv->pshare->RSSI_sum_R = 0;
-	priv->pshare->RSSI_cnt_R = 0;
-	priv->pshare->RSSI_sum_L = 0;
-	priv->pshare->RSSI_cnt_L = 0;
-	priv->pshare->TXByteCnt_R = 0;
-	priv->pshare->TXByteCnt_L = 0;
-	priv->pshare->RXByteCnt_R = 0;
-	priv->pshare->RXByteCnt_L = 0;
-
-}
-void SwAntDivRestAfterLink(struct rtl8192cd_priv *priv)
-{
-	priv->pshare->RSSI_test = FALSE;
-	priv->pshare->DM_SWAT_Table.try_flag = SWAW_STEP_RESET;
-	memset(priv->pshare->DM_SWAT_Table.SelectAntennaMap, 0, sizeof(priv->pshare->DM_SWAT_Table.SelectAntennaMap));
-	priv->pshare->DM_SWAT_Table.mapIndex = 0;
-	priv->pshare->lastTxOkCnt = priv->net_stats.tx_bytes;
-	priv->pshare->lastRxOkCnt = priv->net_stats.rx_bytes;
-	resetSwAntDivVariable(priv);
-}
-
-
-void dm_SW_AntennaSwitchInit(struct rtl8192cd_priv *priv)
-{
-	if (GET_CHIP_VER(priv) == VERSION_8188C)
-		priv->pshare->rf_ft_var.antSw_select = 0;
-
-	//RT_TRACE(COMP_SWAS, DBG_LOUD, ("SWAS:Init SW Antenna Switch\n"));
-	resetSwAntDivVariable(priv);
-	priv->pshare->DM_SWAT_Table.CurAntenna = Antenna_L;
-	priv->pshare->DM_SWAT_Table.try_flag = SWAW_STEP_RESET;
-	memset(priv->pshare->DM_SWAT_Table.SelectAntennaMap, 0, sizeof(priv->pshare->DM_SWAT_Table.SelectAntennaMap));
-	priv->pshare->DM_SWAT_Table.mapIndex = 0;
-
-
-	RTL_W32(LEDCFG, RTL_R32(LEDCFG) | BIT(23) );	//enable LED[1:0] pin as ANTSEL
-
-	if ( !priv->pshare->rf_ft_var.antSw_select)	{
-		RTL_W32(rFPGA0_XAB_RFParameter, RTL_R32(rFPGA0_XAB_RFParameter) | BIT(13) );	 //select ANTESEL from path A
-		RTL_W32(rFPGA0_XAB_RFInterfaceSW, RTL_R32(rFPGA0_XAB_RFInterfaceSW) | BIT(8)| BIT(9) );  // enable ANTSEL  A as SW control
-		RTL_W32(rFPGA0_XA_RFInterfaceOE, (RTL_R32(rFPGA0_XA_RFInterfaceOE) & ~(BIT(8)|BIT(9)))| 0x01<<8 );	// 0x01: left antenna, 0x02: right antenna
-	} else 	{
-		RTL_W32(rFPGA0_XAB_RFParameter, RTL_R32(rFPGA0_XAB_RFParameter) & ~ BIT(13) );	 //select ANTESEL from path B
-		RTL_W32(rFPGA0_XAB_RFInterfaceSW, RTL_R32(rFPGA0_XAB_RFInterfaceSW) | BIT(24)| BIT(25) );  // enable ANTSEL B as SW control
-		RTL_W32(rFPGA0_XB_RFInterfaceOE, (RTL_R32(rFPGA0_XB_RFInterfaceOE) & ~(BIT(8)|BIT(9)))| 0x01<<8 );	// 0x01: left antenna, 0x02: right antenna
-	}
-	RTL_W16(rFPGA0_TxInfo, (RTL_R16(rFPGA0_TxInfo)&0xf0ff) | BIT(8) );	// b11-b8=0001
-
-	// Move the timer initialization to InitializeVariables function.
-	//PlatformInitializeTimer(Adapter, &pMgntInfo->SwAntennaSwitchTimer, (RT_TIMER_CALL_BACK)dm_SW_AntennaSwitchCallback, NULL, "SwAntennaSwitchTimer");
-}
-//
-// 20100514 Luke/Joseph:
-// Add new function for antenna diversity after link.
-// This is the main function of antenna diversity after link.
-// This function is called in HalDmWatchDog() and dm_SW_AntennaSwitchCallback().
-// HalDmWatchDog() calls this function with SWAW_STEP_PEAK to initialize the antenna test.
-// In SWAW_STEP_PEAK, another antenna and a 500ms timer will be set for testing.
-// After 500ms, dm_SW_AntennaSwitchCallback() calls this function to compare the signal just
-// listened on the air with the RSSI of original antenna.
-// It chooses the antenna with better RSSI.
-// There is also a aged policy for error trying. Each error trying will cost more 5 seconds waiting
-// penalty to get next try.
-//
-void dm_SW_AntennaSwitch(struct rtl8192cd_priv *priv, char Step)
-{
-	unsigned int	curTxOkCnt, curRxOkCnt;
-	unsigned int	CurByteCnt, PreByteCnt;
-	int 			Score_R=0, Score_L=0;
-	int				RSSI_R, RSSI_L;
-	char 			nextAntenna=priv->pshare->DM_SWAT_Table.CurAntenna;
-	int				i;
-
-//1 1. Determine which condition should turn off Antenna Diversity
-
-#ifdef MP_TEST
-	if ((OPMODE & WIFI_MP_STATE) || priv->pshare->rf_ft_var.mp_specific)
-		return;
-#endif
-
-//	if(!(GET_CHIP_VER(priv) == VERSION_8188C) || !priv->pshare->rf_ft_var.antSw_enable)
-//		return;
-
-	if((!priv->assoc_num)
-#ifdef PCIE_POWER_SAVING
-	|| (priv->pwr_state == L2) || (priv->pwr_state == L1)
-#endif
-	){
-		SwAntDivRestAfterLink(priv);
-		return;
-	}
-
-	// Handling step mismatch condition.
-	// Peak step is not finished at last time. Recover the variable and check again.
-	if( Step != priv->pshare->DM_SWAT_Table.try_flag)
-	{
-		SwAntDivRestAfterLink(priv);
-	}
-
-//1 2. Initialization: Select a assocaiated AP or STA as RSSI target
-	if(priv->pshare->DM_SWAT_Table.try_flag == SWAW_STEP_RESET) {
-#ifdef CLIENT_MODE
-		if((OPMODE & (WIFI_STATION_STATE | WIFI_ASOC_STATE)) == (WIFI_STATION_STATE | WIFI_ASOC_STATE)) {
-			// Target: Infrastructure mode AP.
-			priv->pshare->RSSI_target = NULL;
-		}
-#endif
-		resetSwAntDivVariable(priv);
-		priv->pshare->DM_SWAT_Table.try_flag = SWAW_STEP_PEAK;
-		return;
-	}
-	else  {
-
-//1 3. Antenna Diversity
-
-		//2 Calculate TX and RX OK bytes
-
-		curTxOkCnt = priv->net_stats.tx_bytes - priv->pshare->lastTxOkCnt;
-		curRxOkCnt = priv->net_stats.rx_bytes - priv->pshare->lastRxOkCnt;
-		priv->pshare->lastTxOkCnt = priv->net_stats.tx_bytes;
-		priv->pshare->lastRxOkCnt = priv->net_stats.rx_bytes;
-
-		//2 Try State
-		if(priv->pshare->DM_SWAT_Table.try_flag == SWAW_STEP_DETERMINE)	{
-			//3 1. Seperately caculate TX and RX OK byte counter for ant A and B
-			if(priv->pshare->DM_SWAT_Table.CurAntenna == Antenna_R) {
-				priv->pshare->TXByteCnt_R += curTxOkCnt;
-				priv->pshare->RXByteCnt_R += curRxOkCnt;
-			} else 	{
-				priv->pshare->TXByteCnt_L += curTxOkCnt;
-				priv->pshare->RXByteCnt_L += curRxOkCnt;
-			}
-
-			//3 2. Change anntena for testing
-			if(priv->pshare->DM_SWAT_Table.RSSI_Trying != 0) {
-				nextAntenna = (priv->pshare->DM_SWAT_Table.CurAntenna ) ^ Antenna_MAX;
-				priv->pshare->DM_SWAT_Table.RSSI_Trying--;
-			}
-
-			//2 Try State End: Determine the best antenna
-
-			if(priv->pshare->DM_SWAT_Table.RSSI_Trying==0) {
-				nextAntenna = priv->pshare->DM_SWAT_Table.CurAntenna;
-				priv->pshare->DM_SWAT_Table.mapIndex = (priv->pshare->DM_SWAT_Table.mapIndex+1)%SELANT_MAP_SIZE;
-
-				//3 TP Mode: Determine the best antenna by throuhgput
-				if(priv->pshare->DM_SWAT_Table.TestMode == TP_MODE)  {
-
-
-
-					//3 (1) Saperately caculate total byte count for two antennas
-					if(priv->pshare->DM_SWAT_Table.CurAntenna == Antenna_R) {
-						CurByteCnt = (priv->pshare->TXByteCnt_R + (priv->pshare->RXByteCnt_R<<1));
-						PreByteCnt = (priv->pshare->TXByteCnt_L + (priv->pshare->RXByteCnt_L<<1));
-					} else {
-						CurByteCnt = (priv->pshare->TXByteCnt_L + (priv->pshare->RXByteCnt_L<<1));
-						PreByteCnt = (priv->pshare->TXByteCnt_R + (priv->pshare->RXByteCnt_R<<1));
-					}
-
-					//3 (2) Throughput Normalization
-					if(priv->pshare->TrafficLoad == TRAFFIC_HIGH)
-						CurByteCnt >>=3;
-					else if(priv->pshare->TrafficLoad == TRAFFIC_LOW)
-						CurByteCnt >>=1;
-
-					if(priv->pshare->DM_SWAT_Table.CurAntenna == Antenna_R) {
-						priv->pshare->DM_SWAT_Table.SelectAntennaMap[0][priv->pshare->DM_SWAT_Table.mapIndex] = PreByteCnt;
-						priv->pshare->DM_SWAT_Table.SelectAntennaMap[1][priv->pshare->DM_SWAT_Table.mapIndex] = CurByteCnt;
-					} else {
-						priv->pshare->DM_SWAT_Table.SelectAntennaMap[0][priv->pshare->DM_SWAT_Table.mapIndex] = CurByteCnt;
-						priv->pshare->DM_SWAT_Table.SelectAntennaMap[1][priv->pshare->DM_SWAT_Table.mapIndex] = PreByteCnt;
-					}
-
-					Score_R = Score_L=0;
-					for (i= 0; i<SELANT_MAP_SIZE; i++) {
-						Score_L += priv->pshare->DM_SWAT_Table.SelectAntennaMap[0][i];
-						Score_R += priv->pshare->DM_SWAT_Table.SelectAntennaMap[1][i];
-					}
-
-					nextAntenna = (Score_L > Score_R) ? Antenna_L : Antenna_R;
-
-					if(priv->pshare->rf_ft_var.ant_dump&8)
-						panic_printk("Mode TP, select Ant%d, [Score1=%d,Score2=%d]\n", nextAntenna, Score_L, Score_R);
-
-				}
-
-				//3 RSSI Mode: Determine the best anntena by RSSI
-				else if(priv->pshare->DM_SWAT_Table.TestMode == RSSI_MODE) {
-
-					//2 Saperately caculate average RSSI for two antennas
-					RSSI_L = RSSI_R = 0;
-
-					if(priv->pshare->RSSI_cnt_R > 0)
-						RSSI_R = priv->pshare->RSSI_sum_R/priv->pshare->RSSI_cnt_R;
-					if(priv->pshare->RSSI_cnt_L > 0)
-						RSSI_L = priv->pshare->RSSI_sum_L/priv->pshare->RSSI_cnt_L;
-
-					if(RSSI_L && RSSI_R )
-						nextAntenna =  (RSSI_L > RSSI_R) ? Antenna_L : Antenna_R;
-
-					if(priv->pshare->rf_ft_var.ant_dump&8)
-						panic_printk("Mode RSSI, RSSI_R=%d(%d), RSSI_L=%d(%d), Ant=%d\n",
-						RSSI_R, priv->pshare->RSSI_cnt_R, RSSI_L,  priv->pshare->RSSI_cnt_L, nextAntenna);
-
-				}
-
-				//3 Reset state
-				resetSwAntDivVariable(priv);
-				priv->pshare->DM_SWAT_Table.try_flag = SWAW_STEP_PEAK;
-				priv->pshare->RSSI_test = FALSE;
-			}
-		}
-
-		//1 Normal State
-		else if(priv->pshare->DM_SWAT_Table.try_flag == SWAW_STEP_PEAK)	{
-
-			//3 Determine TP/RSSI mode by TRX OK count
-			if((curRxOkCnt+curTxOkCnt) > TP_MODE_THD) {
-				//2 Determine current traffic is high or low
-				if((curTxOkCnt+curRxOkCnt) > TRAFFIC_THRESHOLD)
-					priv->pshare->TrafficLoad = TRAFFIC_HIGH;
-				else
-					priv->pshare->TrafficLoad = TRAFFIC_LOW;
-
-				priv->pshare->DM_SWAT_Table.RSSI_Trying = 10;
-				priv->pshare->DM_SWAT_Table.TestMode = TP_MODE;
-			} else	{
-
-				int idx = 0;
-				struct stat_info* pEntry = findNextSTA(priv, &idx);
-				priv->pshare->RSSI_target = NULL;
-				while(pEntry) {
-					if(pEntry && pEntry->expire_to) {
-						if(!priv->pshare->RSSI_target)
-							priv->pshare->RSSI_target = pEntry;
-						else if( pEntry->rssi < priv->pshare->RSSI_target->rssi )
-							priv->pshare->RSSI_target = pEntry;
-					}
-					pEntry = findNextSTA(priv, &idx);
-				};
-
-				priv->pshare->DM_SWAT_Table.RSSI_Trying = 6;
-				priv->pshare->DM_SWAT_Table.TestMode = RSSI_MODE;
-
-				if(priv->pshare->RSSI_target == NULL)	{
-					SwAntDivRestAfterLink(priv);
-					return;
-				}
-
-				//3 reset state
-				memset(priv->pshare->DM_SWAT_Table.SelectAntennaMap, 0, sizeof(priv->pshare->DM_SWAT_Table.SelectAntennaMap));
-			}
-
-			//3 Begin  to enter Try State
-			nextAntenna = (priv->pshare->DM_SWAT_Table.CurAntenna ) ^ Antenna_MAX;
-			priv->pshare->DM_SWAT_Table.try_flag = SWAW_STEP_DETERMINE;
-			priv->pshare->RSSI_test = TRUE;
-
-			//3 Reset variables
-			resetSwAntDivVariable(priv);
-		}
-	}
-
-//1 4.Change TRX antenna
-	if(nextAntenna != priv->pshare->DM_SWAT_Table.CurAntenna) {
-		if (!priv->pshare->rf_ft_var.antSw_select)
-			PHY_SetBBReg(priv, rFPGA0_XA_RFInterfaceOE, 0x300, nextAntenna);
-		else
-			PHY_SetBBReg(priv, rFPGA0_XB_RFInterfaceOE, 0x300, nextAntenna);
-	}
-
-//1 5.Reset Statistics
-	priv->pshare->DM_SWAT_Table.CurAntenna = nextAntenna;
-
-//1 6.Set next timer
-
-	if(priv->pshare->DM_SWAT_Table.RSSI_Trying == 0) {
-		return;
-	}
-
-	if(priv->pshare->DM_SWAT_Table.TestMode == RSSI_MODE)	{
-		mod_timer(&priv->pshare->swAntennaSwitchTimer, jiffies +40);		// 400 ms
-	} else if(priv->pshare->DM_SWAT_Table.TestMode == TP_MODE)	{
-
-		if(priv->pshare->TrafficLoad == TRAFFIC_HIGH)	{
-			if(priv->pshare->DM_SWAT_Table.RSSI_Trying%2 == 0)
-				mod_timer(&priv->pshare->swAntennaSwitchTimer, jiffies + 1);	// 10 ms
-			else
-				mod_timer(&priv->pshare->swAntennaSwitchTimer, jiffies + 8);	// 80 ms
-
-		} else if(priv->pshare->TrafficLoad == TRAFFIC_LOW) {
-			if(priv->pshare->DM_SWAT_Table.RSSI_Trying%2 == 0)
-				mod_timer(&priv->pshare->swAntennaSwitchTimer, jiffies + 4);	// 40 ms
-			else
-				mod_timer(&priv->pshare->swAntennaSwitchTimer, jiffies + 8);	// 80 ms
-		}
-	}
-
-}
-
-
-void dm_SW_AntennaSwitchCallback(unsigned long task_priv)
-{
-	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv*)task_priv;
-	unsigned long flags;
-	SAVE_INT_AND_CLI(flags);
-	dm_SW_AntennaSwitch(priv, SWAW_STEP_DETERMINE);
-	RESTORE_INT(flags);
-}
-
-//
-// 20100514 Luke/Joseph:
-// This function is used to gather the RSSI information for antenna testing.
-// It selects the RSSI of the peer STA that we want to know.
-//
-void dm_SWAW_RSSI_Check(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinfo)
-{
-	struct stat_info* pEntry = NULL;
-	pEntry = get_stainfo(priv, GetAddr2Ptr(get_pframe(pfrinfo)));
-
-	if((priv->pshare->RSSI_target==NULL)||(priv->pshare->RSSI_target==pEntry)) {
-		//1 RSSI for SW Antenna Switch
-		if(priv->pshare->DM_SWAT_Table.CurAntenna == Antenna_R)
-		{
-			priv->pshare->RSSI_sum_R += pfrinfo->rssi;
-			priv->pshare->RSSI_cnt_R++;
-		} else {
-			priv->pshare->RSSI_sum_L += pfrinfo->rssi;
-			priv->pshare->RSSI_cnt_L++;
-		}
-	}
-}
-
-#ifndef HW_ANT_SWITCH
-
-int diversity_antenna_select(struct rtl8192cd_priv *priv, unsigned char *data)
-{
-	int ant = _atoi(data, 16);
-//	if(GET_CHIP_VER(priv) != VERSION_8188C)
-//		return 0;
-
-#ifdef PCIE_POWER_SAVING
-		PCIeWakeUp(priv, POWER_DOWN_T0);
-#endif
-	if(ant==Antenna_L || ant==Antenna_R) {
-		if (!priv->pshare->rf_ft_var.antSw_select)
-			PHY_SetBBReg(priv, rFPGA0_XA_RFInterfaceOE, 0x300, ant);
-		else
-			PHY_SetBBReg(priv, rFPGA0_XB_RFInterfaceOE, 0x300, ant);
-		priv->pshare->DM_SWAT_Table.CurAntenna = ant;
-		priv->pshare->rf_ft_var.antSw_enable = 0;
-		SwAntDivRestAfterLink(priv);
-		memset(priv->pshare->DM_SWAT_Table.SelectAntennaMap, 0, sizeof(priv->pshare->DM_SWAT_Table.SelectAntennaMap));
-		return 1;
-	} else {
-		priv->pshare->rf_ft_var.antSw_enable = 1;
-		priv->pshare->lastTxOkCnt = priv->net_stats.tx_bytes;
-		priv->pshare->lastRxOkCnt = priv->net_stats.rx_bytes;
-
-		return 0;
-	}
-}
-#endif
-#endif
-#if defined(HW_ANT_SWITCH)
-
-void dm_HW_AntennaSwitchInit(struct rtl8192cd_priv *priv)
-{
-#ifdef SW_ANT_SWITCH
-	priv->pshare->rf_ft_var.antSw_enable =0;
-#endif
-
-	if (GET_CHIP_VER(priv) == VERSION_8188C)
-		priv->pshare->rf_ft_var.antSw_select = 0;
-	if ( !priv->pshare->rf_ft_var.antSw_select)	{
-		RTL_W32(rFPGA0_XAB_RFParameter, RTL_R32(rFPGA0_XAB_RFParameter) | BIT(13) );	 //select ANTESEL from path A
-		RTL_W32(rFPGA0_XAB_RFInterfaceSW, RTL_R32(rFPGA0_XAB_RFInterfaceSW) & ~(BIT(8)| BIT(9)) ); // ANTSEL as HW control
-		RTL_W32(rFPGA0_XA_RFInterfaceOE, (RTL_R32(rFPGA0_XA_RFInterfaceOE) & ~(BIT(8)|BIT(9)))| 0x01<<8 );	// 0x01: left antenna, 0x02: right antenna
-		RTL_W8(0xc50, RTL_R8(0xc50) | BIT(7));	// Enable Hardware antenna switch
-		RTL_W32(0xc54, RTL_R32(0xc54) | BIT(23) );	// Decide final antenna by comparing 2 antennas' pwdb
-	} else 	{
-		RTL_W32(rFPGA0_XAB_RFParameter, RTL_R32(rFPGA0_XAB_RFParameter) & ~ BIT(13) );	 //select ANTESEL from path B
-		RTL_W32(rFPGA0_XAB_RFInterfaceSW, RTL_R32(rFPGA0_XAB_RFInterfaceSW) & ~(BIT(24)| BIT(25)) ); // ANTSEL as HW control
-		RTL_W32(rFPGA0_XB_RFInterfaceOE, (RTL_R32(rFPGA0_XB_RFInterfaceOE) & ~(BIT(8)|BIT(9)))| 0x01<<8 );	// 0x01: left antenna, 0x02: right antenna
-		RTL_W8(0xc58, RTL_R8(0xc58) | BIT(7));	// Enable Hardware antenna switch
-		RTL_W32(0xc5C, RTL_R32(0xc5c) | BIT(23) );	// Decide final antenna by comparing 2 antennas' pwdb
-	}
-
-	priv->pshare->rf_ft_var.CurAntenna = 0;
-
-	RTL_W32(LEDCFG, RTL_R32(LEDCFG) | BIT(23) );	//enable LED[1:0] pin as ANTSEL
-	RTL_W16(0xca4, (RTL_R16(0xca4) & ~(0xfff))|0x0c0); 	// Pwdb threshold=12dB
-	RTL_W32(0x874, RTL_R32(0x874) & ~ BIT(23) );	// No update ANTSEL during GNT_BT=1
-	RTL_W16(rFPGA0_TxInfo, (RTL_R16(rFPGA0_TxInfo)&0xf0ff) | BIT(8) );	// b11-b8=0001
-	RTL_W32(0x80c, RTL_R32(0x80c) | BIT(21) );		// assign antenna by tx desc
-
-	// CCK setting
-	RTL_W8(0xa01, RTL_R8(0xa01) | BIT(7));			// enable hw ant diversity
-	RTL_W8(0xa0c, (RTL_R8(0xa0c) & 0xe0) | 0x0f );	// b4=0, b3:0 = 1111	32 sample
-	RTL_W8(0xa11, RTL_R8(0xa11) | BIT(5));			// do not change default optional antenna
-	RTL_W8(0xa14, (RTL_R8(0xa14) & 0xe0) | 0x08 );	// default : optional = 1:1
-
-}
-
-void setRxIdleAnt(struct rtl8192cd_priv *priv, char Ant)
+#ifdef TX_EARLY_MODE
+void enable_em(struct rtl8192cd_priv *priv)
 {
-	if(priv->pshare->rf_ft_var.CurAntenna != Ant) {
-		if(Ant) {
-			RTL_W32(0x858, 0x65a965a9);
-//			RTL_W8(0x6d8, RTL_R8(0x6d8) | BIT(6) );
-		}
-		else {
-			RTL_W32(0x858, 0x569a569a);
-//			RTL_W8(0x6d8, RTL_R8(0x6d8) & (~ BIT(6)));
-		}
-		priv->pshare->rf_ft_var.CurAntenna = Ant;
-	}
-}
-
-
-void dm_STA_Ant_Select(struct rtl8192cd_priv *priv, struct stat_info *pstat)
-{
-	int ScoreA=0, ScoreB=0, i, nextAnt= pstat->CurAntenna, idleAnt=priv->pshare->rf_ft_var.CurAntenna;
-
-	if((priv->pshare->rf_ft_var.CurAntenna & 0x80)
-		|| ((pstat->hwRxAntSel[0] + pstat->hwRxAntSel[1])==0 && (pstat->cckPktCount[0] + pstat->cckPktCount[1])<10)	)
-		return;
-
-	for(i=0; i<2; i++) {
-		if(pstat->cckPktCount[i]==0 && pstat->hwRxAntSel[i]==0)
-			pstat->AntRSSI[i] = 0;
-	}
-
-	if(pstat->hwRxAntSel[0] || pstat->hwRxAntSel[1]) {
-		ScoreA = pstat->hwRxAntSel[0];
-		ScoreB = pstat->hwRxAntSel[1];
-
-		if(ScoreA != ScoreB) {
-			if(ScoreA > ScoreB)
-				nextAnt = 0;
-			else
-				nextAnt = 1;
-		}
-	} else {
-		ScoreA = pstat->cckPktCount[0];
-		ScoreB = pstat->cckPktCount[1];
-
-		if(ScoreA > 5*ScoreB)
-			nextAnt = 0;
-		else if(ScoreB > 5*ScoreA)
-			nextAnt = 1;
-		else if(ScoreA > ScoreB)
-			nextAnt = 1;
-		else if(ScoreB > ScoreA)
-			nextAnt = 0;
-	}
-
-	pstat->CurAntenna = nextAnt;
-
-	if(priv->pshare->rf_ft_var.ant_dump&2) {
-		panic_printk("id=%d, OFDM/CCK: (%d, %d/%d, %d), RSSI:(%d, %d), ant=%d, RxIdle=%d\n",
-			pstat->aid,
-			pstat->hwRxAntSel[1],
-			pstat->hwRxAntSel[0],
-			pstat->cckPktCount[1],
-			pstat->cckPktCount[0],
-			pstat->AntRSSI[1],
-			pstat->AntRSSI[0],
-			(pstat->CurAntenna==0 ? 2: 1)
-			 ,((priv->pshare->rf_ft_var.CurAntenna&1)==0 ? 2 : 1)
-			 );
-	}
-
-	if(pstat->AntRSSI[idleAnt]==0)
-		pstat->AntRSSI[idleAnt] = pstat->AntRSSI[idleAnt^1];
-
-// reset variables
-	pstat->hwRxAntSel[1] = pstat->hwRxAntSel[0] =0;
-	pstat->cckPktCount[1]= pstat->cckPktCount[0] =0;
-
-
+	RTL_W32(EARLY_MODE_CTRL, RTL_R32(EARLY_MODE_CTRL) |0x8000000f); // enable signel AMPDU, early mode for vi/vo/be/bk queue
+	RTL_W16(TCR, RTL_R16(TCR) | WMAC_TCR_ERRSTEN2);		
 }
 
-void dm_HW_IdleAntennaSelect(struct rtl8192cd_priv *priv)
+void disable_em(struct rtl8192cd_priv *priv)
 {
-	struct stat_info	*pstat, *pstat_min=NULL;
-	struct list_head	*phead, *plist;
-	int rssi_min= 0xff, i;
-
-	if(priv->pshare->rf_ft_var.CurAntenna & 0x80)
-		return;
-
-	phead = &priv->asoc_list;
-	plist = phead->next;
-
-	while(plist != phead)	{
-		pstat = list_entry(plist, struct stat_info, asoc_list);
-		if((pstat->expire_to) && (pstat->AntRSSI[0] || pstat->AntRSSI[1])) {
-			int rssi = (pstat->AntRSSI[0] < pstat->AntRSSI[1]) ? pstat->AntRSSI[0] : pstat->AntRSSI[1];
-			if((!pstat_min) || ( rssi < rssi_min) ) {
-				pstat_min = pstat;
-				rssi_min = rssi;
-			}
-		}
-		if (plist == plist->next)
-			break;
-		plist = plist->next;
-	};
-
-	if(pstat_min)
-		setRxIdleAnt(priv, pstat_min->CurAntenna);
-
-
-#ifdef TX_SHORTCUT
-	if (!priv->pmib->dot11OperationEntry.disable_txsc) {
-		plist = phead->next;
-		while(plist != phead)	{
-			pstat = list_entry(plist, struct stat_info, asoc_list);
-			if(pstat->expire_to) {
-				for (i=0; i<TX_SC_ENTRY_NUM; i++) {
-					struct tx_desc *pdesc= &(pstat->tx_sc_ent[i].hwdesc1);	
-					pdesc->Dword2 &= set_desc(~ (BIT(24)|BIT(25)));
-					if((pstat->CurAntenna^priv->pshare->rf_ft_var.CurAntenna)&1)
-						pdesc->Dword2 |= set_desc(BIT(24)|BIT(25));
-					pdesc= &(pstat->tx_sc_ent[i].hwdesc2);	
-					pdesc->Dword2 &= set_desc(~ (BIT(24)|BIT(25)));
-					if((pstat->CurAntenna^priv->pshare->rf_ft_var.CurAntenna)&1)
-						pdesc->Dword2 |= set_desc(BIT(24)|BIT(25));					
-				}
-			}		
-
-			if (plist == plist->next)
-				break;
-			plist = plist->next;
-		};
-	}
-#endif	
-
+	RTL_W32(EARLY_MODE_CTRL, RTL_R32(EARLY_MODE_CTRL) & ~0x8000000f); // disable signel AMPDU, early mode for vi/vo/be/bk queue
+	RTL_W16(TCR, RTL_R16(TCR) & ~WMAC_TCR_ERRSTEN2 );
 }
-
-
-
-int diversity_antenna_select(struct rtl8192cd_priv *priv, unsigned char *data)
-{
-	int ant = _atoi(data, 16);
-
-#ifdef PCIE_POWER_SAVING
-		PCIeWakeUp(priv, POWER_DOWN_T0);
-#endif
-
-		if (ant==Antenna_L || ant==Antenna_R) {
-		if ( !priv->pshare->rf_ft_var.antSw_select) {
-			RTL_W32(rFPGA0_XAB_RFInterfaceSW, RTL_R32(rFPGA0_XAB_RFInterfaceSW) | BIT(8)| BIT(9) );  //  ANTSEL A as SW control
-			RTL_W8(0xc50, RTL_R8(0xc50) & (~ BIT(7)));	// rx OFDM SW control
-			PHY_SetBBReg(priv, rFPGA0_XA_RFInterfaceOE, 0x300, ant);
-		} else {
-			RTL_W32(rFPGA0_XAB_RFInterfaceSW, RTL_R32(rFPGA0_XAB_RFInterfaceSW) | BIT(24)| BIT(25) ); // ANTSEL B as HW control
-			PHY_SetBBReg(priv, rFPGA0_XB_RFInterfaceOE, 0x300, ant);
-			RTL_W8(0xc58, RTL_R8(0xc58) & (~ BIT(7)));		// rx OFDM SW control
-		}
-		RTL_W8(0xa01, RTL_R8(0xa01) & (~ BIT(7)));	// rx CCK SW control
-		RTL_W32(0x80c, RTL_R32(0x80c) & (~ BIT(21))); // select ant by tx desc
-		RTL_W32(0x858, 0x569a569a);
-
-		priv->pshare->rf_ft_var.antHw_enable = 0;
-		priv->pshare->rf_ft_var.CurAntenna  = (ant%2);
-
-#ifdef SW_ANT_SWITCH
-		priv->pshare->rf_ft_var.antSw_enable = 0;
-		priv->pshare->DM_SWAT_Table.CurAntenna = ant;
-		priv->pshare->RSSI_test =0;
-#endif
-	}
-	else if(ant==0){
-		if ( !priv->pshare->rf_ft_var.antSw_select)  {
-			RTL_W32(rFPGA0_XAB_RFInterfaceSW, RTL_R32(rFPGA0_XAB_RFInterfaceSW) & ~(BIT(8)| BIT(9)) );
-			RTL_W8(0xc50, RTL_R8(0xc50) | BIT(7));	// OFDM HW control
-		} else {
-			RTL_W32(rFPGA0_XAB_RFInterfaceSW, RTL_R32(rFPGA0_XAB_RFInterfaceSW) & ~(BIT(24)| BIT(25)) );
-			RTL_W8(0xc58, RTL_R8(0xc58) | BIT(7));	// OFDM HW control
-		}
-
-		RTL_W8(0xa01, RTL_R8(0xa01) | BIT(7));	// CCK HW control
-		RTL_W32(0x80c, RTL_R32(0x80c) | BIT(21) ); // by tx desc
-		priv->pshare->rf_ft_var.CurAntenna = 0;
-		RTL_W32(0x858, 0x569a569a);
-		priv->pshare->rf_ft_var.antHw_enable = 1;
-#ifdef SW_ANT_SWITCH
-		priv->pshare->rf_ft_var.antSw_enable = 0;
-		priv->pshare->RSSI_test =0;
-#endif
-	}
-#ifdef SW_ANT_SWITCH
-	else if(ant==3) {
-		if(!priv->pshare->rf_ft_var.antSw_enable) {
-			dm_SW_AntennaSwitchInit(priv);
-			RTL_W32(0x858, 0x569a569a);
-			priv->pshare->lastTxOkCnt = priv->net_stats.tx_bytes;
-			priv->pshare->lastRxOkCnt = priv->net_stats.rx_bytes;
-		}
-		if ( !priv->pshare->rf_ft_var.antSw_select)
-			RTL_W8(0xc50, RTL_R8(0xc50) & (~ BIT(7)));	// rx OFDM SW control
-		else
-			RTL_W8(0xc58, RTL_R8(0xc58) & (~ BIT(7)));	// rx OFDM SW control
-
-		RTL_W8(0xa01, RTL_R8(0xa01) & (~ BIT(7)));		// rx CCK SW control
-		RTL_W32(0x80c, RTL_R32(0x80c) & (~ BIT(21))); 	// select ant by tx desc
-		priv->pshare->rf_ft_var.antHw_enable = 0;
-		priv->pshare->rf_ft_var.antSw_enable = 1;
-
-	}
 #endif
 
-	return 1;
-}
-
-#endif
 
 
diff --git a/drivers/net/wireless/rtl8192cd/8192cd_hw.h b/drivers/net/wireless/rtl8192cd/8192cd_hw.h
index 333fff4..bf40de5 100644
--- a/drivers/net/wireless/rtl8192cd/8192cd_hw.h
+++ b/drivers/net/wireless/rtl8192cd/8192cd_hw.h
@@ -27,6 +27,9 @@
 #ifdef CONFIG_RTL_92D_SUPPORT
 #include "./8192d_reg.h"
 #endif
+#ifdef CONFIG_RTL_88E_SUPPORT
+#include "./8188e_reg.h"
+#endif
 #include "./8192cd_cfg.h"
 
 #ifndef __KERNEL__
@@ -58,6 +61,7 @@ enum _CHIP_VERSION_ {
 	VERSION_8188C = 0x1000,
 	VERSION_8192C = 0x1001,
 	VERSION_8192D = 0x1002,
+	VERSION_8188E = 0x1003,
 };
 
 #if 0
@@ -474,8 +478,22 @@ enum _ARFR_TABLE_SET_
 	ARFR_BMC = 6,
 };
 
+#if defined(CONFIG_RTL_88E_SUPPORT) && defined(TXREPORT)
+typedef enum _RATR_TABLE_MODE{
+	RATR_INX_WIRELESS_NGB = 0,		// BGN 40 Mhz 2SS 1SS
+	RATR_INX_WIRELESS_NG = 1,		// GN or N
+	RATR_INX_WIRELESS_NB = 2,		// BGN 20 Mhz 2SS 1SS  or BN
+	RATR_INX_WIRELESS_N = 3,
+	RATR_INX_WIRELESS_GB = 4,
+	RATR_INX_WIRELESS_G = 5,
+	RATR_INX_WIRELESS_B = 6,
+	RATR_INX_WIRELESS_MC = 7,
+	RATR_INX_WIRELESS_AC_N = 8,
+}RATR_TABLE_MODE, *PRATR_TABLE_MODE;
+#endif
+
 //#define	HP_UPPER			0x4B //SS = 75%
-#define	HP_LOWER			0x46 //SS = 70%
+#define	HP_LOWER			0x3F //0x46 //SS = 70%
 #define RSSI_DIFF_PA		10
 #define RSSI_DIFF_LNA		8
 
@@ -820,6 +838,10 @@ struct rtl8192cd_hw {
 // switch BE to VI
 	unsigned int	VO_pkt_count;
 	unsigned int	VI_pkt_count;
+	unsigned int	VI_rx_pkt_count;
+#ifdef WMM_VIBE_PRI
+	unsigned int	BE_pkt_count;
+#endif
 	unsigned int	BK_pkt_count;
 #endif
 
@@ -899,8 +921,8 @@ struct rtl8192cd_hw {
 
 	//_TXPWR_REDEFINE ?? int or char ??
 #if 0
-	int				CCKTxAgc_A[4];
-	int				CCKTxAgc_B[4];	
+	int					CCKTxAgc_A[4];
+	int					CCKTxAgc_B[4];
 #endif
 	char				CCKTxAgc_A[4];
 	char				CCKTxAgc_B[4];
@@ -915,6 +937,11 @@ struct rtl8192cd_hw {
 	// for DIG checking
 	unsigned char				signal_strength;	// 1=low and dig off, 2=normal and dig on, 3=high power and dig on
 
+#ifdef INTERFERENCE_CONTROL
+	// for NBI filter checking
+	unsigned char				nbi_filter_on;
+#endif
+
 	// dynamic CCK Tx power by rssi
 	unsigned char				CCKTxAgc_enhanced;
 
@@ -956,8 +983,12 @@ struct rtl8192cd_hw {
 
 	unsigned char				check_reg824;
 	unsigned int				reg824_bit9;
+
 	unsigned char				InternalPA5G[2];
 	unsigned char				bNewTxGainTable;
+
+	unsigned char				RTSInitRate;
+	unsigned char				RTSInitRate_Candidate;
 };
 
 //1-------------------------------------------------------------------
@@ -1060,6 +1091,10 @@ enum _RTL8192CD_TX_DESC_ {
 	TX_AggEn			= BIT(5),
 	TX_MacIdSHIFT		= 0,
 	TX_MacIdMask		= 0x01F,
+#ifdef CONFIG_RTL_88E_SUPPORT
+	TXdesc_88E_MacIdSHIFT       = 0,
+	TXdesc_88E_MacIdMask        = 0x03F,
+#endif
 
 //	TX_MoreData			= BIT(5),
 //	TX_MoreFrag			= BIT(6),
@@ -1084,13 +1119,23 @@ enum _RTL8192CD_TX_DESC_ {
 	TX_TxAntCckMask	= 0x03,
 	TX_AntSelB			= BIT(25),
 	TX_AntSelA			= BIT(24),
+#ifdef CONFIG_RTL_88E_SUPPORT
+	TXdesc_88E_BtInt    = BIT(23),
+#endif
 	TX_AmpduDstySHIFT	= 20,
 	TX_AmpduDstyMask	= 0x07,
 	TX_CCX				= BIT(19),
 	TX_RAW				= BIT(18),
 	TX_MoreFrag		= BIT(17),
+#ifdef CONFIG_RTL_88E_SUPPORT
+	TXdesc_88E_BK       = BIT(16),
+#endif
 	TX_BarRtyThSHIFT	= 14,
 	TX_BarRtyThMask	= 0x03,
+#ifdef CONFIG_RTL_88E_SUPPORT
+	TXdesc_88E_RdEn		= BIT(13),
+	TXdesc_88E_AggEn    = BIT(12),
+#endif
 	TX_DataRcSHIFT		= 6,
 	TX_DataRcMask		= 0x03F,
 	TX_RtsRcSHIFT		= 0,
@@ -1112,6 +1157,12 @@ enum _RTL8192CD_TX_DESC_ {
 
 
 	//DWORD3
+#ifdef CONFIG_RTL_88E_SUPPORT
+	TXdesc_88E_EnHwSeq  = BIT(31),
+	TXdesc_88E_TriggerInt   = BIT(30),
+	TXdesc_88E_Tagi     = BIT(29),
+	TXdesc_88E_CpuHandle    = BIT(28),
+#endif
 	TX_PktIdSHIFT			= 28,
 	TX_PktIdMask			= 0x0F,
 	TX_SeqSHIFT			= 16,
@@ -1140,6 +1191,11 @@ enum _RTL8192CD_TX_DESC_ {
 	TX_DataScMask		= 0x03,
 	TX_CTS2AP			= BIT(19),
 	TX_WaitDCTS		= BIT(18),
+#ifdef CONFIG_RTL_88E_SUPPORT
+	TXdesc_88E_PwrStatusSHIFT       = 15,
+	TXdesc_88E_PwrStatusMask        = 0x07,
+	TXdesc_88E_PortId	= BIT(14), 
+#endif
 	TX_HwRtsEn			= BIT(13),
 	TX_RtsEn			= BIT(12),
 	TX_CTS2Self			= BIT(11),
@@ -1148,6 +1204,10 @@ enum _RTL8192CD_TX_DESC_ {
 	TX_UseRate			= BIT(8),
 	TX_HwSeqEn			= BIT(7),
 	TX_QOS				= BIT(6),
+#ifdef CONFIG_RTL_88E_SUPPORT
+	TXdesc_88E_HwSeqSelSHIFT       = 6,
+	TXdesc_88E_HwSeqSelMask        = 0x03,
+#endif
 	TX_ApDCFE			= BIT(5),
 	TX_RtsRateSHIFT	= 0,
 	TX_RtsRateMask		= 0x01F,
@@ -1174,6 +1234,9 @@ enum _RTL8192CD_TX_DESC_ {
 	TX_DataRateFBLmtSHIFT	= 8,
 	TX_DataRateFBLmtMask	= 0x01F,
 	TX_CcxTag				= BIT(7),
+#ifdef CONFIG_RTL_88E_SUPPORT
+	TXdesc_88E_TryRate		= BIT(7), 
+#endif
 	TX_SGI					= BIT(6),
 	TX_DataRateSHIFT		= 0,
 	TX_DataRateMask		= 0x03F,
@@ -1209,6 +1272,17 @@ enum _RTL8192CD_TX_DESC_ {
 
 
 	// DWORD 7
+#ifdef CONFIG_RTL_88E_SUPPORT
+	TXdesc_88E_Null1		= BIT(31), 
+	TXdesc_88E_Null0		= BIT(30), 
+	TXdesc_88E_AntSelC		= BIT(29), 
+	TXdesc_88E_SwOffset31SHIFT	= 27,
+	TXdesc_88E_SwOffset31Mask		= 0x0F,
+	TXdesc_88E_SwOffset30SHIFT	= 23,
+	TXdesc_88E_SwOffset30Mask		= 0x0F,
+	TXdesc_88E_SwOffset29SHIFT	= 19,
+	TXdesc_88E_SwOffset29Mask		= 0x0F,
+#endif
 	TX_MCS15SgiMaxSHIFT	= 28,
 	TX_MCS15SgiMaxMask	= 0x0F,
 	TX_MCS6gMaxSHIFT		= 24,
@@ -1268,15 +1342,24 @@ enum _RTL8192CD_RX_DESC_ {
 	RX_AMSDU			= BIT(13),
 	RX_HwRsvdSHIFT	= 9,
 	RX_HwRsvdMask		= 0x0F,
+#ifdef CONFIG_RTL_88E_SUPPORT
+	RXdesc_88E_TidSHIFT	= 8,
+#endif
 	RX_TidSHIFT			= 5,
 	RX_TidMask			= 0x0F,
 	RX_MacIdSHIFT		= 0,
 	RX_MacIdMask		= 0x01F,
+#ifdef CONFIG_RTL_88E_SUPPORT
+	RXdesc_88E_MacIdMask	= 0x03F,
+#endif
 
 
 	// DWORD 2
 	RX_NextInd				= BIT(30),
 	RX_NextPktLenSHIFT		= 16,
+#ifdef CONFIG_RTL_88E_SUPPORT
+	RXdesc_88E_NextPktLenMask       = 0x0FF,
+#endif
 	RX_NextPktLenMask		= 0x03FFF,
 	RX_FragSHIFT			= 12,
 	RX_FragMask			= 0x0F,
@@ -1285,8 +1368,17 @@ enum _RTL8192CD_RX_DESC_ {
 
 
 	//DWORD3
+#ifdef CONFIG_RTL_88E_SUPPORT
+	RXdesc_88E_MagicWake	= BIT(31),
+	RXdesc_88E_UCwake		= BIT(30),
+	RXdesc_88E_PtnMatch	= BIT(29),
+#endif
 	RX_IV0SHIFT		= 16,
 	RX_IV0Mask			= 0x0FFFF,
+#ifdef CONFIG_RTL_88E_SUPPORT
+	RXdesc_88E_RptSelSHIFT		= 14,
+	RXdesc_88E_RptSelMask		= 0x03,
+#endif
 	RX_HwPCInd			= BIT(15),
 	RX_HwPCErr			= BIT(14),
 	RX_TCPChkValid		= BIT(13),
@@ -1451,7 +1543,7 @@ enum REG_FILE_FORMAT {
 	THREE_COLUMN
 };
 
-#ifdef CONFIG_RTL_92D_SUPPORT
+#if defined(CONFIG_RTL_92D_SUPPORT) || defined(CONFIG_RTL_88E_SUPPORT)
 typedef enum _PHYREG_PG_TBL_IDX_ {
 	BGN_2040_ALL = 0,
 	BGN_20_CH1_3 = 1,
@@ -1477,7 +1569,6 @@ typedef enum _TXPWR_LMT_TBL_IDX_ {
 	FCC_40M1S = 5,
 	FCC_40M2S = 6,
 }TXPWR_LMT_TBL_IDX;
-
 #endif
 
 typedef enum _MIMO_TR_STATUS {
@@ -1728,11 +1819,66 @@ enum _8190_CPU_RESET_BITFIELD_ {
 
 #define	OFDM_TABLE_SIZE_92D 	43
 #define index_mapping_NUM		13
-#define CCK_TABLE_SIZE_92D 33
+#define index_mapping_DPK_NUM	15
 #define Rx_index_mapping_NUM	15
+#define CCK_TABLE_SIZE_92D 33
 
 #endif
 
+#ifdef _TRACKING_TABLE_FILE
+#define index_mapping_NUM_MAX	20
+
+#define TXPWR_TRACKING_NAME_NUM 20
+static char TXPWR_TRACKING_NAME[][32] = {
+	"2GCCKA_P",
+	"2GCCKA_N",
+	"2GCCKB_P",
+	"2GCCKB_N",
+	"2GA_P",
+	"2GA_N",
+	"2GB_P",
+	"2GB_N",
+	"5GLA_P",
+	"5GLA_N",
+	"5GLB_P",
+	"5GLB_N",
+	"5GMA_P",
+	"5GMA_N",
+	"5GMB_P",
+	"5GMB_N",
+	"5GHA_P",
+	"5GHA_N",
+	"5GHB_P",
+	"5GHB_N",
+};
+
+enum txpwr_tracking_offset {
+	CCKA_P, //"2GCCKA_P"
+	CCKA_N, //"2GCCKA_N"
+	CCKB_P, //"2GCCKB_P"
+	CCKB_N, //"2GCCKB_N"
+	A_P,	//"2GA_P"
+	A_N,	//"2GA_N"
+	B_P,	//"2GB_P"
+	B_N,	//"2GB_N"
+	LA_P,	//"5GLA_P"
+	LA_N,	//"5GLA_N"
+	LB_P,	//"5GLB_P"
+	LB_N,	//"5GLB_N"
+	MA_P,	//"5GMA_P"
+	MA_N,	//"5GMA_N"
+	MB_P,	//"5GMB_P"
+	MB_N,	//"5GMB_N"
+	HA_P,	//"5GHA_P"
+	HA_N,	//"5GHA_N"
+	HB_P,	//"5GHB_P"
+	HB_N,	//"5GHB_N"
+};
+
+
+#endif
+
+
 #define RTL_ABS(a,b) ((a>b) ? (a-b) : (b-a))
 
 
diff --git a/drivers/net/wireless/rtl8192cd/8192cd_ioctl.c b/drivers/net/wireless/rtl8192cd/8192cd_ioctl.c
index 83a7655..89f468a 100644
--- a/drivers/net/wireless/rtl8192cd/8192cd_ioctl.c
+++ b/drivers/net/wireless/rtl8192cd/8192cd_ioctl.c
@@ -43,7 +43,7 @@
 #endif
 #ifdef CONFIG_RTK_MESH
 // for commu with  802.11s path selection deamon;plus note
-#include "./mesh_ext/mesh_route.h"
+#include "../mesh_ext/mesh_route.h"
 #endif
 
 #ifdef WIFI_HAPD
@@ -56,10 +56,6 @@
 #define HAPD_IOCTL_SETCONFIG	SIOCIWLASTPRIV //0x8BFF
 #endif
 
-#if defined(CLIENT_MODE) && !defined(WIFI_WPAS)
-static int check_bss_encrypt(struct rtl8192cd_priv *priv);
-#endif
-
 #ifdef WIFI_WPAS
 #define WPAS_IOCTL_CUSTOM		SIOCIWLASTPRIV //0x8BFF
 #endif
@@ -212,6 +208,18 @@ int g_port_mapping=FALSE;
 #define SIOCEFUSE_SYNC 		0x8b9c
 #endif
 
+#ifdef P2P_SUPPORT
+#define SIOCP2PCMD			0x8BD1  // command for p2p 
+#define SIOCP2PSCANREQ		0x8BD2	// issue p2p discovery request
+#define SIOCP2PGETRESULT	0x8BD3	// get p2p discovery result
+#define SIOCP2PPROVREQ		0x8BD4	// issue provision discovery request
+#define SIOCP2WSCMETHODCONF	0x8BD5	// report event and state
+#define SIOCP2PPGETEVNIND	0x8BD6	// get event and state
+
+#define SIOCP2P_WSC_REPORT_STATE			0x8BD7
+#define SIOCP2P_REPORT_CLIENT_STATE			0x8BD8	// report client connect state
+#endif
+
 #ifdef BR_SHORTCUT
 #define SIOCLEARBRSC		0x8B91
 #endif
@@ -230,7 +238,8 @@ int g_port_mapping=FALSE;
 #define RTL8192CD_IOCTL_ADD_ACL_TABLE		0x8B96
 #define RTL8192CD_IOCTL_REMOVE_ACL_TABLE	0x8B97
 #define RTL8192CD_IOCTL_GET_ACL_TABLE		0x8B98
-
+#define ACL_allow 1
+#define ACL_deny 2
 #endif//tsananiu//
 
 #define SIOCQPATHTABLE  0x8BA0  // query pathselection table
@@ -278,6 +287,13 @@ int g_port_mapping=FALSE;
 #ifdef NON_INTR_ANTDIV
 #define SIOC92DATNDIV	0x8BC6 // set hwaddr by band
 #endif
+#ifdef DPK_92D
+#define SIOC92DDPK	0x8BC7 // dpk
+#endif
+#endif
+
+#ifdef MP_PSD_SUPPORT
+#define MP_QUERY_PSD  		0x8BC8
 #endif
 #define _OFFSET(field)	((int)(long *)&(((struct wifi_mib *)0)->field))
 #define _SIZE(field)	sizeof(((struct wifi_mib *)0)->field)
@@ -326,6 +342,8 @@ typedef enum {BYTE_T, INT_T, SSID_STRING_T, BYTE_ARRAY_T, ACL_T, IDX_BYTE_ARRAY_
 #ifdef CONFIG_RTL_COMAPI_CFGFILE
 	SSID2SCAN_STRING_T,
 #endif
+	RFFT_ACL_T,
+
 } TYPE_T;
 
 
@@ -385,6 +403,7 @@ struct iw_priv_args privtab[] = {
 	{ MP_QUERY_STATS, IW_PRIV_TYPE_CHAR | 40, IW_PRIV_TYPE_CHAR | 128, "mp_query" },
 	{ MP_TXPWR_TRACK, IW_PRIV_TYPE_CHAR | 40, 0, "mp_pwrtrk" },
 	{ MP_QUERY_TSSI, IW_PRIV_TYPE_CHAR | 40, IW_PRIV_TYPE_CHAR | 128, "mp_tssi" },
+	
 	{ MP_QUERY_THER, IW_PRIV_TYPE_CHAR | 40, IW_PRIV_TYPE_CHAR | 128, "mp_ther" },
 #ifdef CONFIG_RTL_92D_SUPPORT
 	{ MP_SET_BAND, IW_PRIV_TYPE_CHAR | 40, IW_PRIV_TYPE_CHAR | 128, "mp_phyband" },
@@ -437,7 +456,9 @@ struct iw_priv_args privtab[] = {
 	{ SIOCEFUSE_SET, IW_PRIV_TYPE_CHAR | 512, IW_PRIV_TYPE_CHAR | 128, "efuse_set" },
 	{ SIOCEFUSE_SYNC, IW_PRIV_TYPE_CHAR | 128, IW_PRIV_TYPE_CHAR |  128, "efuse_sync" },
 #endif
-
+	#ifdef MP_PSD_SUPPORT
+	{ MP_QUERY_PSD, IW_PRIV_TYPE_CHAR | 40, IW_PRIV_TYPE_CHAR | 128, "mp_psd" }, 
+	#endif
 	{ SIOC92DAUTOCH, IW_PRIV_TYPE_CHAR | 128, 0, "autoch" },
 
 
@@ -625,25 +646,6 @@ struct iwpriv_arg {
 	int Default;	/* mib default value */
 };
 
-/* station info, reported to web server */
-typedef struct _sta_info_2_web {
-	unsigned short	aid;
-	unsigned char	addr[6];
-	unsigned long	tx_packets;
-	unsigned long	rx_packets;
-	unsigned long	expired_time;	// 10 msec unit
-	unsigned short	flags;
-	unsigned char	TxOperaRate;
-	unsigned char	rssi;
-	unsigned long	link_time;		// 1 sec unit
-	unsigned long	tx_fail;
-	unsigned long	tx_bytes;
-	unsigned long	rx_bytes;
-	unsigned char	network;
-	unsigned char	ht_info;		// bit0: 0=20M mode, 1=40M mode; bit1: 0=longGI, 1=shortGI
-	unsigned char 	resv[6];
-} sta_info_2_web;
-
 /* Bit mask value for flags, compatiable with old driver */
 #define STA_INFO_FLAG_AUTH_OPEN     	0x01
 #define STA_INFO_FLAG_AUTH_WEP      	0x02
@@ -731,6 +733,7 @@ static struct iwpriv_arg mib_table[] = {
 #endif
 	{"trsw_pape_C9",		BYTE_T,	_OFFSET(dot11RFEntry.trsw_pape_C9), _SIZE(dot11RFEntry.trsw_pape_C9), 0x0},
 	{"trsw_pape_CC",		BYTE_T,	_OFFSET(dot11RFEntry.trsw_pape_CC), _SIZE(dot11RFEntry.trsw_pape_CC), 0xFF},
+	{"tx2path",				INT_T,	_OFFSET(dot11RFEntry.tx2path), _SIZE(dot11RFEntry.tx2path), 0},
 	{"txbf",				INT_T,	_OFFSET(dot11RFEntry.txbf), _SIZE(dot11RFEntry.txbf), 0},
 	{"target_pwr",			INT_T,	_OFFSET(dot11RFEntry.target_pwr), _SIZE(dot11RFEntry.target_pwr), 0},
 
@@ -752,6 +755,7 @@ static struct iwpriv_arg mib_table[] = {
 	{"swTkipMic",	INT_T,		_OFFSET(dot11StationConfigEntry.swTkipMic), _SIZE(dot11StationConfigEntry.swTkipMic), 1},
 	{"disable_protection", INT_T,	_OFFSET(dot11StationConfigEntry.protectionDisabled), _SIZE(dot11StationConfigEntry.protectionDisabled), 0},
 	{"disable_olbc", INT_T,		_OFFSET(dot11StationConfigEntry.olbcDetectDisabled), _SIZE(dot11StationConfigEntry.olbcDetectDisabled), 0},
+	{"disable_nmlsc", INT_T,		_OFFSET(dot11StationConfigEntry.nmlscDetectDisabled), _SIZE(dot11StationConfigEntry.nmlscDetectDisabled), 0},
 	{"deny_legacy",	INT_T,		_OFFSET(dot11StationConfigEntry.legacySTADeny), _SIZE(dot11StationConfigEntry.legacySTADeny), 0},
 #ifdef CLIENT_MODE
 	{"fast_roaming", INT_T,		_OFFSET(dot11StationConfigEntry.fastRoaming), _SIZE(dot11StationConfigEntry.fastRoaming), 0},
@@ -817,6 +821,9 @@ static struct iwpriv_arg mib_table[] = {
 	// struct Dot118021xAuthEntry
 	{"802_1x",		INT_T,		_OFFSET(dot118021xAuthEntry.dot118021xAlgrthm), _SIZE(dot118021xAuthEntry.dot118021xAlgrthm), 0},
 	{"default_port",INT_T,		_OFFSET(dot118021xAuthEntry.dot118021xDefaultPort), _SIZE(dot118021xAuthEntry.dot118021xDefaultPort), 0},
+	{"acct_enabled",INT_T,		_OFFSET(dot118021xAuthEntry.acct_enabled), _SIZE(dot118021xAuthEntry.acct_enabled), 0},
+	{"acct_timeout_INT",INT_T,_OFFSET(dot118021xAuthEntry.acct_timeout_period), _SIZE(dot118021xAuthEntry.acct_timeout_period), 0},
+	{"acct_timeout_TP",INT_T,_OFFSET(dot118021xAuthEntry.acct_timeout_throughput), _SIZE(dot118021xAuthEntry.acct_timeout_throughput), 0},
 
 	// struct Dot11DefaultKeysTable
 	{"wepkey1",		BYTE_ARRAY_T,	_OFFSET(dot11DefaultKeysTable.keytype[0]), _SIZE(dot11DefaultKeysTable.keytype[0]), 0},
@@ -840,7 +847,7 @@ static struct iwpriv_arg mib_table[] = {
 	{"block_relay",	INT_T,		_OFFSET(dot11OperationEntry.block_relay), _SIZE(dot11OperationEntry.block_relay), 0},
 	{"deny_any",	INT_T,		_OFFSET(dot11OperationEntry.deny_any), _SIZE(dot11OperationEntry.deny_any), 0},
 	{"crc_log",		INT_T,		_OFFSET(dot11OperationEntry.crc_log), _SIZE(dot11OperationEntry.crc_log), 0},
-	{"wifi_specific",INT_T,		_OFFSET(dot11OperationEntry.wifi_specific), _SIZE(dot11OperationEntry.wifi_specific), 0},
+	{"wifi_specific",INT_T,		_OFFSET(dot11OperationEntry.wifi_specific), _SIZE(dot11OperationEntry.wifi_specific), 2},
 #ifdef TX_SHORTCUT
 	{"disable_txsc",INT_T,		_OFFSET(dot11OperationEntry.disable_txsc), _SIZE(dot11OperationEntry.disable_txsc), 0},
 #endif
@@ -911,6 +918,9 @@ static struct iwpriv_arg mib_table[] = {
 #if defined(RESERVE_TXDESC_FOR_EACH_IF) && (defined(UNIVERSAL_REPEATER) || defined(MBSSID))
 	{"rsv_txdesc",		INT_T,		_OFFSET(miscEntry.rsv_txdesc), _SIZE(miscEntry.rsv_txdesc), 1},
 #endif
+#ifdef USE_TXQUEUE
+	{"use_txq",		INT_T,		_OFFSET(miscEntry.use_txq), _SIZE(miscEntry.use_txq), 1},
+#endif
 	{"func_off",	INT_T,		_OFFSET(miscEntry.func_off), _SIZE(miscEntry.func_off), 0},
 
 	//struct Dot11QosEntry
@@ -918,6 +928,12 @@ static struct iwpriv_arg mib_table[] = {
 	{"qos_enable",	INT_T,		_OFFSET(dot11QosEntry.dot11QosEnable), _SIZE(dot11QosEntry.dot11QosEnable), 0},
 #ifdef WMM_APSD
 	{"apsd_enable",	INT_T,		_OFFSET(dot11QosEntry.dot11QosAPSD), _SIZE(dot11QosEntry.dot11QosAPSD), 0},
+#ifdef CLIENT_MODE
+	{"apsd_sta_be",	INT_T,		_OFFSET(dot11QosEntry.UAPSD_AC_BE), _SIZE(dot11QosEntry.UAPSD_AC_BE), 0},
+	{"apsd_sta_bk",	INT_T,		_OFFSET(dot11QosEntry.UAPSD_AC_BK), _SIZE(dot11QosEntry.UAPSD_AC_BK), 0},
+	{"apsd_sta_vi",	INT_T,		_OFFSET(dot11QosEntry.UAPSD_AC_VI), _SIZE(dot11QosEntry.UAPSD_AC_VI), 0},
+	{"apsd_sta_vo",	INT_T,		_OFFSET(dot11QosEntry.UAPSD_AC_VO), _SIZE(dot11QosEntry.UAPSD_AC_VO), 0},
+#endif
 #endif
 
 #ifdef RTL_MANUAL_EDCA
@@ -1044,6 +1060,7 @@ static struct iwpriv_arg mib_table[] = {
 #ifdef WIFI_11N_2040_COEXIST
 	{"coexist",		INT_T,		_OFFSET(dot11nConfigEntry.dot11nCoexist), _SIZE(dot11nConfigEntry.dot11nCoexist), 0},
 #endif
+	{"txnoack",		INT_T,		_OFFSET(dot11nConfigEntry.dot11nTxNoAck), _SIZE(dot11nConfigEntry.dot11nTxNoAck), 0},
 
 	// struct ReorderControlEntry
 	{"rc_enable",	INT_T,		_OFFSET(reorderCtrlEntry.ReorderCtrlEnable), _SIZE(reorderCtrlEntry.ReorderCtrlEnable), 1},
@@ -1103,13 +1120,20 @@ static struct iwpriv_arg mib_table[] = {
 	{"raGoUp20MLower",	RFFT_T,	_OFFSET_RFFT(raGoUp20MLower), _SIZE_RFFT(raGoUp20MLower), 23},
 	{"raGoUp40MLower",	RFFT_T,	_OFFSET_RFFT(raGoUp40MLower), _SIZE_RFFT(raGoUp40MLower), 20},
 	{"dig_enable",		RFFT_T,	_OFFSET_RFFT(dig_enable), _SIZE_RFFT(dig_enable), 1},
+#ifdef INTERFERENCE_CONTROL
+	{"digGoLowerLevel", RFFT_T, _OFFSET_RFFT(digGoLowerLevel), _SIZE_RFFT(digGoLowerLevel), 30},
+    {"digGoUpperLevel", RFFT_T, _OFFSET_RFFT(digGoUpperLevel), _SIZE_RFFT(digGoUpperLevel), 35},
+	{"nbi_filter_enable",	RFFT_T,	_OFFSET_RFFT(nbi_filter_enable), _SIZE_RFFT(nbi_filter_enable), 0},
+#else
 	{"digGoLowerLevel",	RFFT_T,	_OFFSET_RFFT(digGoLowerLevel), _SIZE_RFFT(digGoLowerLevel), 35},
 	{"digGoUpperLevel",	RFFT_T,	_OFFSET_RFFT(digGoUpperLevel), _SIZE_RFFT(digGoUpperLevel), 40},
+#endif
 	{"dcThUpper",		RFFT_T,	_OFFSET_RFFT(dcThUpper), _SIZE_RFFT(dcThUpper), 30},
 	{"dcThLower",		RFFT_T,	_OFFSET_RFFT(dcThLower), _SIZE_RFFT(dcThLower), 25},
 	{"rssiTx20MUpper",	RFFT_T,	_OFFSET_RFFT(rssiTx20MUpper), _SIZE_RFFT(rssiTx20MUpper), 20},
 	{"rssiTx20MLower",	RFFT_T,	_OFFSET_RFFT(rssiTx20MLower), _SIZE_RFFT(rssiTx20MLower), 15},
 	{"rssi_expire_to",	RFFT_T,	_OFFSET_RFFT(rssi_expire_to), _SIZE_RFFT(rssi_expire_to), 60},
+	{"rts_init_rate",	RFFT_T,	_OFFSET_RFFT(rts_init_rate), _SIZE_RFFT(rts_init_rate), 0},
 
 	{"cck_pwr_max",		RFFT_T,	_OFFSET_RFFT(cck_pwr_max), _SIZE_RFFT(cck_pwr_max), 0},
 	{"cck_tx_pathB",	RFFT_T,	_OFFSET_RFFT(cck_tx_pathB), _SIZE_RFFT(cck_tx_pathB), 0},
@@ -1126,6 +1150,15 @@ static struct iwpriv_arg mib_table[] = {
 	{"txop_enlarge_upper",		RFFT_T,	_OFFSET_RFFT(txop_enlarge_upper), _SIZE_RFFT(txop_enlarge_upper), 20},
 	{"txop_enlarge_lower",		RFFT_T,	_OFFSET_RFFT(txop_enlarge_lower), _SIZE_RFFT(txop_enlarge_lower), 15},
 
+#ifdef LOW_TP_TXOP
+	{"low_tp_txop",				RFFT_T,	_OFFSET_RFFT(low_tp_txop),	_SIZE_RFFT(low_tp_txop), 1},
+	{"low_tp_txop_thd_n",		RFFT_T,	_OFFSET_RFFT(low_tp_txop_thd_n),	_SIZE_RFFT(low_tp_txop_thd_n), 22},
+	{"low_tp_txop_thd_g",		RFFT_T,	_OFFSET_RFFT(low_tp_txop_thd_g),	_SIZE_RFFT(low_tp_txop_thd_g), 17},
+	{"low_tp_txop_thd_low",		RFFT_T,	_OFFSET_RFFT(low_tp_txop_thd_low),	_SIZE_RFFT(low_tp_txop_thd_low), 0},
+	{"low_tp_txop_delay",		RFFT_T,	_OFFSET_RFFT(low_tp_txop_delay),	_SIZE_RFFT(low_tp_txop_delay), 1},
+	{"cwmax_enhance_thd",		RFFT_T,	_OFFSET_RFFT(cwmax_enhance_thd), _SIZE_RFFT(cwmax_enhance_thd), 2000},
+#endif
+
 	// 2.3G support
 	{"frq_2_3G",		RFFT_T,	_OFFSET_RFFT(use_frq_2_3G), _SIZE_RFFT(use_frq_2_3G), 0},
 
@@ -1140,6 +1173,10 @@ static struct iwpriv_arg mib_table[] = {
 	//Support IP multicast->unicast
 #ifdef SUPPORT_TX_MCAST2UNI
 	{"mc2u_disable",	RFFT_T,	_OFFSET_RFFT(mc2u_disable), _SIZE_RFFT(mc2u_disable), 0},
+	{"mc2u_drop_unknown",	RFFT_T,	_OFFSET_RFFT(mc2u_drop_unknown), _SIZE_RFFT(mc2u_drop_unknown), 0},
+	{"mc2u_flood_ctrl",	RFFT_T,	_OFFSET_RFFT(mc2u_flood_ctrl), _SIZE_RFFT(mc2u_flood_ctrl), 0},
+	{"mc2u_flood_mac_num",	RFFT_T,		_OFFSET_RFFT(mc2u_flood_mac_num), _SIZE_RFFT(mc2u_flood_mac_num), 0},
+	{"mc2u_flood_mac",		RFFT_ACL_T,		_OFFSET_RFFT(mc2u_flood_mac), _SIZE_RFFT(mc2u_flood_mac), 0},
 #endif
 
 #ifdef HIGH_POWER_EXT_PA
@@ -1251,10 +1288,34 @@ static struct iwpriv_arg mib_table[] = {
 #ifdef TXPWR_LMT
 	{"disable_txpwrlmt",	RFFT_T, _OFFSET_RFFT(disable_txpwrlmt), _SIZE_RFFT(disable_txpwrlmt), 1},
 #endif
-
 #ifdef CONFIG_RTL_92D_DMDP
 	{"peerReinit",	RFFT_T, _OFFSET_RFFT(peerReinit), _SIZE_RFFT(peerReinit), 0},
 #endif
+#ifdef WIFI_WMM
+	{"wifi_beq_iot",	RFFT_T, _OFFSET_RFFT(wifi_beq_iot), _SIZE_RFFT(wifi_beq_iot), 0},
+#endif
+	{"bcast_to_dzq",	RFFT_T, _OFFSET_RFFT(bcast_to_dzq), _SIZE_RFFT(bcast_to_dzq), 0},
+#ifdef TLN_STATS
+	{"stats_time_interval",        RFFT_T, _OFFSET_RFFT(stats_time_interval), _SIZE_RFFT(stats_time_interval), 86400},
+#endif
+#ifdef TX_EARLY_MODE
+	{"em_enable",	RFFT_T, _OFFSET_RFFT(em_enable), _SIZE_RFFT(em_enable), 1},
+#endif
+#ifdef CLIENT_MODE
+	{"sta_mode_ps",	RFFT_T, _OFFSET_RFFT(sta_mode_ps), _SIZE_RFFT(sta_mode_ps), 0},
+#endif
+#ifdef CONFIG_RTL_WLAN_DOS_FILTER
+	{"dos_block_time",	RFFT_T, _OFFSET_RFFT(dos_block_time), _SIZE_RFFT(dos_block_time), 20},
+#endif
+
+	{"intel_tp",	RFFT_T, _OFFSET_RFFT(intel_rtylmt_tp_margin), _SIZE_RFFT(intel_rtylmt_tp_margin), 125*1024}, /* unit: byte */
+
+#ifdef CONFIG_RTL_88E_SUPPORT
+	{"disable_pkt_pause",	RFFT_T, _OFFSET_RFFT(disable_pkt_pause), _SIZE_RFFT(disable_pkt_pause), 0},
+	{"disable_pkt_nolink",	RFFT_T, _OFFSET_RFFT(disable_pkt_nolink), _SIZE_RFFT(disable_pkt_nolink), 0},
+        {"maxpktfail",  RFFT_T, _OFFSET_RFFT(max_pkt_fail), _SIZE_RFFT(max_pkt_fail), 50},
+	{"minpktfail",  RFFT_T, _OFFSET_RFFT(min_pkt_fail), _SIZE_RFFT(min_pkt_fail), 30},
+#endif
 };
 
 #ifdef _DEBUG_RTL8192CD_
@@ -1476,7 +1537,7 @@ int set_mib(struct rtl8192cd_priv *priv, unsigned char *data)
 				}
 				break;
 			}
-#ifdef CLIENT_MODE	/* WPS2DOTX   */
+#ifdef CLIENT_MODE
 			if ((priv->pmib->wscEntry.wsc_enable == 1) && (int_val == 0)) { 
 				/*handle for WPS client mode fail or timeout*/ 
 
@@ -1516,6 +1577,10 @@ int set_mib(struct rtl8192cd_priv *priv, unsigned char *data)
 				if((OPMODE&(WIFI_STATION_STATE | WIFI_AUTH_SUCCESS | WIFI_ASOC_STATE))
 						==(WIFI_STATION_STATE | WIFI_AUTH_SUCCESS | WIFI_ASOC_STATE))
 				{
+					/*if client mode is associated set recover_join_req;
+					then when wsc immediately be cancelled client will recover orig assoc*/ 
+					priv->recover_join_req = 1;	
+					
 					issue_disassoc(priv, BSSID, _RSON_DEAUTH_STA_LEAVING_);					
 					OPMODE &= ~(WIFI_AUTH_SUCCESS | WIFI_ASOC_STATE);					
 				} 
@@ -1523,7 +1588,7 @@ int set_mib(struct rtl8192cd_priv *priv, unsigned char *data)
 
 				
 			}
-/* WPS2DOTX   */
+
 #endif
 		}
 #endif
@@ -1676,6 +1741,7 @@ int set_mib(struct rtl8192cd_priv *priv, unsigned char *data)
 					PHY_SetBBReg(priv, 0x83c, bMaskDWord, 0x30303030);
 				}
 				PHY_SetBBReg(priv, 0xc7c, BIT(28), 0); // ynlin dbg
+				PHY_SetBBReg(priv, 0xcdc, BIT(8)|BIT(9), 1);
 			}
 #endif
 		} else if (entry->len == 4) {
@@ -1684,6 +1750,23 @@ int set_mib(struct rtl8192cd_priv *priv, unsigned char *data)
 		}
 		break;
 
+	case RFFT_ACL_T:
+			arg_val = get_arg(arg_val, tmpbuf);
+			if (arg_val == NULL) {
+				DEBUG_ERR("invalid RFFT_ACL_T addr [%s] !\n", entry->name);
+				return -1;
+			}
+			if (strlen(tmpbuf)!=12) {
+				DEBUG_ERR("invalid len of RFFT_ACL_T mib [%s] !\n", entry->name);
+				return -1;
+			}
+			
+			int_ptr = (int *)(((unsigned char *)&priv->pshare->rf_ft_var)+entry->offset+entry->len);
+			int_idx = *int_ptr;
+			get_array_val(((unsigned char *)&priv->pshare->rf_ft_var)+entry->offset+int_idx*6, tmpbuf, 12);
+			*int_ptr = *int_ptr + 1;
+			break;
+
 	case VARLEN_BYTE_T:
 		len = strlen(arg_val);
 		if (len/2 > entry->len) {
@@ -1743,7 +1826,7 @@ int set_mib(struct rtl8192cd_priv *priv, unsigned char *data)
 		}
 		break;
 	case WSC_SEPC_MAC_CONN_IND_T:
-		if (strlen(arg_val) == 12) {
+		if (strlen(arg_val) > entry->len) {
 			DOT11_WSC_PIN_IND wsc_ind;
 			wsc_ind.EventId = DOT11_EVENT_WSC_SPEC_MAC_IND;
 			wsc_ind.IsMoreEvent = 0;
@@ -2081,6 +2164,19 @@ int get_mib(struct rtl8192cd_priv *priv, unsigned char *data)
 		memcpy(data, ((unsigned char *)&priv->pshare->rf_ft_var)+entry->offset, sizeof(int));
 		PRINT_INFO("int data: %d\n", *((int *)data));
 		break;
+	case RFFT_ACL_T:
+		int_ptr = (int *)(((unsigned char *)&priv->pshare->rf_ft_var)+entry->offset+entry->len);
+		copy_len = 0;
+		for (i=0; i<*int_ptr; i++) 
+		{
+			memcpy(data, ((unsigned char *)&priv->pshare->rf_ft_var)+entry->offset+i*6, 6);
+			PRINT_INFO("mac-addr: %02x-%02x-%02x-%02x-%02x-%02x\n",
+				data[0],data[1],data[2],data[3],data[4],data[5]);
+			data += 6;
+			copy_len += 6;
+		}
+		DEBUG_INFO("\n");
+		break;
 
 	case VARLEN_BYTE_T:
 		copy_len = *(unsigned int *)(((unsigned char *)priv->pmib)+entry->offset+entry->len);
@@ -2554,6 +2650,9 @@ int set_guestmacinvalid(struct rtl8192cd_priv *priv, char *buf)
 #endif
 #endif
 
+
+#ifdef _DEBUG_RTL8192CD_
+
 //_TXPWR_REDEFINE
 
 #define POWER_MIN_CHECK(a,b)            (((a) > (b)) ? (b) : (a))
@@ -2582,6 +2681,153 @@ static int ch2idx(int ch)
 	return val;
 }
 
+
+
+#ifdef ADD_TX_POWER_BY_CMD
+static void check_txpwr_by_cmd(struct rtl8192cd_priv *priv, 
+	char *MCSTxAgcOffset_A, char *MCSTxAgcOffset_B,
+	char *OFDMTxAgcOffset_A, char *OFDMTxAgcOffset_B,
+	char *CCKTxAgc_A, char *CCKTxAgc_B)
+{
+	char is_by_cmd = 0;	
+
+	if( (priv->pshare->rf_ft_var.txPowerPlus_cck_11 != 0x7f)
+		|| (priv->pshare->rf_ft_var.txPowerPlus_cck_5 != 0x7f)
+		|| (priv->pshare->rf_ft_var.txPowerPlus_cck_2 != 0x7f)
+		|| (priv->pshare->rf_ft_var.txPowerPlus_cck_1 != 0x7f))
+	{		
+		ASSIGN_TX_POWER_OFFSET(CCKTxAgc_A[0], priv->pshare->rf_ft_var.txPowerPlus_cck_11);
+		ASSIGN_TX_POWER_OFFSET(CCKTxAgc_A[1], priv->pshare->rf_ft_var.txPowerPlus_cck_5);
+		ASSIGN_TX_POWER_OFFSET(CCKTxAgc_A[2], priv->pshare->rf_ft_var.txPowerPlus_cck_2);
+		ASSIGN_TX_POWER_OFFSET(CCKTxAgc_A[3], priv->pshare->rf_ft_var.txPowerPlus_cck_1);
+		ASSIGN_TX_POWER_OFFSET(CCKTxAgc_B[0], priv->pshare->rf_ft_var.txPowerPlus_cck_11);
+		ASSIGN_TX_POWER_OFFSET(CCKTxAgc_B[1], priv->pshare->rf_ft_var.txPowerPlus_cck_5);
+		ASSIGN_TX_POWER_OFFSET(CCKTxAgc_B[2], priv->pshare->rf_ft_var.txPowerPlus_cck_2);
+		ASSIGN_TX_POWER_OFFSET(CCKTxAgc_B[3], priv->pshare->rf_ft_var.txPowerPlus_cck_1);
+
+		printk("TXPWR_BY_CMD: CCK = %02x %02x %02x %02x \n", 
+			priv->pshare->rf_ft_var.txPowerPlus_cck_11,
+			priv->pshare->rf_ft_var.txPowerPlus_cck_5,
+			priv->pshare->rf_ft_var.txPowerPlus_cck_2,
+			priv->pshare->rf_ft_var.txPowerPlus_cck_1);
+	}
+
+
+	if( (priv->pshare->rf_ft_var.txPowerPlus_ofdm_18 != 0x7f)
+		|| (priv->pshare->rf_ft_var.txPowerPlus_ofdm_12!= 0x7f)
+		|| (priv->pshare->rf_ft_var.txPowerPlus_ofdm_9 != 0x7f)
+		|| (priv->pshare->rf_ft_var.txPowerPlus_ofdm_6 != 0x7f)
+		|| (priv->pshare->rf_ft_var.txPowerPlus_ofdm_54 != 0x7f)
+		|| (priv->pshare->rf_ft_var.txPowerPlus_ofdm_48 != 0x7f)
+		|| (priv->pshare->rf_ft_var.txPowerPlus_ofdm_36 != 0x7f)
+		|| (priv->pshare->rf_ft_var.txPowerPlus_ofdm_24 != 0x7f))
+	{
+		ASSIGN_TX_POWER_OFFSET(OFDMTxAgcOffset_A[0], priv->pshare->rf_ft_var.txPowerPlus_ofdm_18);
+		ASSIGN_TX_POWER_OFFSET(OFDMTxAgcOffset_A[1], priv->pshare->rf_ft_var.txPowerPlus_ofdm_12);
+		ASSIGN_TX_POWER_OFFSET(OFDMTxAgcOffset_A[2], priv->pshare->rf_ft_var.txPowerPlus_ofdm_9);
+		ASSIGN_TX_POWER_OFFSET(OFDMTxAgcOffset_A[3], priv->pshare->rf_ft_var.txPowerPlus_ofdm_6);
+		ASSIGN_TX_POWER_OFFSET(OFDMTxAgcOffset_B[0], priv->pshare->rf_ft_var.txPowerPlus_ofdm_18);
+		ASSIGN_TX_POWER_OFFSET(OFDMTxAgcOffset_B[1], priv->pshare->rf_ft_var.txPowerPlus_ofdm_12);
+		ASSIGN_TX_POWER_OFFSET(OFDMTxAgcOffset_B[2], priv->pshare->rf_ft_var.txPowerPlus_ofdm_9);
+		ASSIGN_TX_POWER_OFFSET(OFDMTxAgcOffset_B[3], priv->pshare->rf_ft_var.txPowerPlus_ofdm_6);
+
+		ASSIGN_TX_POWER_OFFSET(OFDMTxAgcOffset_A[4], priv->pshare->rf_ft_var.txPowerPlus_ofdm_54);
+		ASSIGN_TX_POWER_OFFSET(OFDMTxAgcOffset_A[5], priv->pshare->rf_ft_var.txPowerPlus_ofdm_48);
+		ASSIGN_TX_POWER_OFFSET(OFDMTxAgcOffset_A[6], priv->pshare->rf_ft_var.txPowerPlus_ofdm_36);
+		ASSIGN_TX_POWER_OFFSET(OFDMTxAgcOffset_A[7], priv->pshare->rf_ft_var.txPowerPlus_ofdm_24);
+		ASSIGN_TX_POWER_OFFSET(OFDMTxAgcOffset_B[4], priv->pshare->rf_ft_var.txPowerPlus_ofdm_54);
+		ASSIGN_TX_POWER_OFFSET(OFDMTxAgcOffset_B[5], priv->pshare->rf_ft_var.txPowerPlus_ofdm_48);
+		ASSIGN_TX_POWER_OFFSET(OFDMTxAgcOffset_B[6], priv->pshare->rf_ft_var.txPowerPlus_ofdm_36);
+		ASSIGN_TX_POWER_OFFSET(OFDMTxAgcOffset_B[7], priv->pshare->rf_ft_var.txPowerPlus_ofdm_24);
+
+		printk("TXPWR_BY_CMD: OFDM = %02x %02x %02x %02x %02x %02x %02x %02x \n", 
+			priv->pshare->rf_ft_var.txPowerPlus_ofdm_18,
+			priv->pshare->rf_ft_var.txPowerPlus_ofdm_12,
+			priv->pshare->rf_ft_var.txPowerPlus_ofdm_9,
+			priv->pshare->rf_ft_var.txPowerPlus_ofdm_6, 
+			priv->pshare->rf_ft_var.txPowerPlus_ofdm_54,
+			priv->pshare->rf_ft_var.txPowerPlus_ofdm_48,
+			priv->pshare->rf_ft_var.txPowerPlus_ofdm_36,
+			priv->pshare->rf_ft_var.txPowerPlus_ofdm_24);
+	}
+
+
+	if( (priv->pshare->rf_ft_var.txPowerPlus_mcs_3 != 0x7f)
+		|| (priv->pshare->rf_ft_var.txPowerPlus_mcs_2 != 0x7f)
+		|| (priv->pshare->rf_ft_var.txPowerPlus_mcs_1 != 0x7f)
+		|| (priv->pshare->rf_ft_var.txPowerPlus_mcs_0 != 0x7f)
+		|| (priv->pshare->rf_ft_var.txPowerPlus_mcs_7 != 0x7f)
+		|| (priv->pshare->rf_ft_var.txPowerPlus_mcs_6 != 0x7f)
+		|| (priv->pshare->rf_ft_var.txPowerPlus_mcs_5 != 0x7f)
+		|| (priv->pshare->rf_ft_var.txPowerPlus_mcs_4 != 0x7f)
+		|| (priv->pshare->rf_ft_var.txPowerPlus_mcs_11 != 0x7f)
+		|| (priv->pshare->rf_ft_var.txPowerPlus_mcs_10 != 0x7f)
+		|| (priv->pshare->rf_ft_var.txPowerPlus_mcs_9 != 0x7f)
+		|| (priv->pshare->rf_ft_var.txPowerPlus_mcs_8 != 0x7f)
+		|| (priv->pshare->rf_ft_var.txPowerPlus_mcs_15 != 0x7f)
+		|| (priv->pshare->rf_ft_var.txPowerPlus_mcs_14 != 0x7f)
+		|| (priv->pshare->rf_ft_var.txPowerPlus_mcs_13 != 0x7f)
+		|| (priv->pshare->rf_ft_var.txPowerPlus_mcs_12 != 0x7f))
+	{
+		ASSIGN_TX_POWER_OFFSET(MCSTxAgcOffset_A[0], priv->pshare->rf_ft_var.txPowerPlus_mcs_3);
+		ASSIGN_TX_POWER_OFFSET(MCSTxAgcOffset_A[1], priv->pshare->rf_ft_var.txPowerPlus_mcs_2);
+		ASSIGN_TX_POWER_OFFSET(MCSTxAgcOffset_A[2], priv->pshare->rf_ft_var.txPowerPlus_mcs_1);
+		ASSIGN_TX_POWER_OFFSET(MCSTxAgcOffset_A[3], priv->pshare->rf_ft_var.txPowerPlus_mcs_0);
+		ASSIGN_TX_POWER_OFFSET(MCSTxAgcOffset_B[0], priv->pshare->rf_ft_var.txPowerPlus_mcs_3);
+		ASSIGN_TX_POWER_OFFSET(MCSTxAgcOffset_B[1], priv->pshare->rf_ft_var.txPowerPlus_mcs_2);
+		ASSIGN_TX_POWER_OFFSET(MCSTxAgcOffset_B[2], priv->pshare->rf_ft_var.txPowerPlus_mcs_1);
+		ASSIGN_TX_POWER_OFFSET(MCSTxAgcOffset_B[3], priv->pshare->rf_ft_var.txPowerPlus_mcs_0);
+
+		ASSIGN_TX_POWER_OFFSET(MCSTxAgcOffset_A[4], priv->pshare->rf_ft_var.txPowerPlus_mcs_7);
+		ASSIGN_TX_POWER_OFFSET(MCSTxAgcOffset_A[5], priv->pshare->rf_ft_var.txPowerPlus_mcs_6);
+		ASSIGN_TX_POWER_OFFSET(MCSTxAgcOffset_A[6], priv->pshare->rf_ft_var.txPowerPlus_mcs_5);
+		ASSIGN_TX_POWER_OFFSET(MCSTxAgcOffset_A[7], priv->pshare->rf_ft_var.txPowerPlus_mcs_4);
+		ASSIGN_TX_POWER_OFFSET(MCSTxAgcOffset_B[4], priv->pshare->rf_ft_var.txPowerPlus_mcs_7);
+		ASSIGN_TX_POWER_OFFSET(MCSTxAgcOffset_B[5], priv->pshare->rf_ft_var.txPowerPlus_mcs_6);
+		ASSIGN_TX_POWER_OFFSET(MCSTxAgcOffset_B[6], priv->pshare->rf_ft_var.txPowerPlus_mcs_5);
+		ASSIGN_TX_POWER_OFFSET(MCSTxAgcOffset_B[7], priv->pshare->rf_ft_var.txPowerPlus_mcs_4);
+
+		ASSIGN_TX_POWER_OFFSET(MCSTxAgcOffset_A[8], priv->pshare->rf_ft_var.txPowerPlus_mcs_11);
+		ASSIGN_TX_POWER_OFFSET(MCSTxAgcOffset_A[9], priv->pshare->rf_ft_var.txPowerPlus_mcs_10);
+		ASSIGN_TX_POWER_OFFSET(MCSTxAgcOffset_A[10], priv->pshare->rf_ft_var.txPowerPlus_mcs_9);
+		ASSIGN_TX_POWER_OFFSET(MCSTxAgcOffset_A[11], priv->pshare->rf_ft_var.txPowerPlus_mcs_8);
+		ASSIGN_TX_POWER_OFFSET(MCSTxAgcOffset_B[8], priv->pshare->rf_ft_var.txPowerPlus_mcs_11);
+		ASSIGN_TX_POWER_OFFSET(MCSTxAgcOffset_B[9], priv->pshare->rf_ft_var.txPowerPlus_mcs_10);
+		ASSIGN_TX_POWER_OFFSET(MCSTxAgcOffset_B[10], priv->pshare->rf_ft_var.txPowerPlus_mcs_9);
+		ASSIGN_TX_POWER_OFFSET(MCSTxAgcOffset_B[11], priv->pshare->rf_ft_var.txPowerPlus_mcs_8);
+
+		ASSIGN_TX_POWER_OFFSET(MCSTxAgcOffset_A[12], priv->pshare->rf_ft_var.txPowerPlus_mcs_15);
+		ASSIGN_TX_POWER_OFFSET(MCSTxAgcOffset_A[13], priv->pshare->rf_ft_var.txPowerPlus_mcs_14);
+		ASSIGN_TX_POWER_OFFSET(MCSTxAgcOffset_A[14], priv->pshare->rf_ft_var.txPowerPlus_mcs_13);
+		ASSIGN_TX_POWER_OFFSET(MCSTxAgcOffset_A[15], priv->pshare->rf_ft_var.txPowerPlus_mcs_12);
+		ASSIGN_TX_POWER_OFFSET(MCSTxAgcOffset_B[12], priv->pshare->rf_ft_var.txPowerPlus_mcs_15);
+		ASSIGN_TX_POWER_OFFSET(MCSTxAgcOffset_B[13], priv->pshare->rf_ft_var.txPowerPlus_mcs_14);
+		ASSIGN_TX_POWER_OFFSET(MCSTxAgcOffset_B[14], priv->pshare->rf_ft_var.txPowerPlus_mcs_13);
+		ASSIGN_TX_POWER_OFFSET(MCSTxAgcOffset_B[15], priv->pshare->rf_ft_var.txPowerPlus_mcs_12);
+
+		printk("TXPWR_BY_CMD: OFDM = %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x \n", 
+			priv->pshare->rf_ft_var.txPowerPlus_mcs_3,
+			priv->pshare->rf_ft_var.txPowerPlus_mcs_2,
+			priv->pshare->rf_ft_var.txPowerPlus_mcs_1,
+			priv->pshare->rf_ft_var.txPowerPlus_mcs_0, 
+			priv->pshare->rf_ft_var.txPowerPlus_mcs_7,
+			priv->pshare->rf_ft_var.txPowerPlus_mcs_6,
+			priv->pshare->rf_ft_var.txPowerPlus_mcs_5,
+			priv->pshare->rf_ft_var.txPowerPlus_mcs_4, 
+			priv->pshare->rf_ft_var.txPowerPlus_mcs_11,
+			priv->pshare->rf_ft_var.txPowerPlus_mcs_10,
+			priv->pshare->rf_ft_var.txPowerPlus_mcs_9,
+			priv->pshare->rf_ft_var.txPowerPlus_mcs_8, 
+			priv->pshare->rf_ft_var.txPowerPlus_mcs_15,
+			priv->pshare->rf_ft_var.txPowerPlus_mcs_14,
+			priv->pshare->rf_ft_var.txPowerPlus_mcs_13,
+			priv->pshare->rf_ft_var.txPowerPlus_mcs_12);
+	}
+	
+}
+#endif
+
+
 static void dump_cck(struct rtl8192cd_priv *priv, 
 	unsigned char pwrlevelCCK_A, unsigned char pwrlevelCCK_B, 
 	char *CCKTxAgc_A, char *CCKTxAgc_B
@@ -3047,11 +3293,10 @@ static void txpwr_dump(struct rtl8192cd_priv *priv, int start, int end)
 	else
 		phyBandSelect = PHY_BAND_5G;
 
-
+	
 #ifdef CONFIG_RTL_92D_SUPPORT
-			if (GET_CHIP_VER(priv)==VERSION_8192D) 
-			{
-#ifdef CONFIG_RTL_8198
+			if (GET_CHIP_VER(priv)==VERSION_8192D) {
+#if defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 				if (phyBandSelect & PHY_BAND_5G)
 					defValue=0x28;
 				else
@@ -3087,7 +3332,7 @@ static void txpwr_dump(struct rtl8192cd_priv *priv, int start, int end)
 			pwrdiffHT40_2S = priv->pmib->dot11RFEntry.pwrdiffHT40_2S[channel-1];
 			pwrdiffHT20 = priv->pmib->dot11RFEntry.pwrdiffHT20[channel-1];
 			pwrdiffOFDM = priv->pmib->dot11RFEntry.pwrdiffOFDM[channel-1];
-
+			
 #ifdef USB_POWER_SUPPORT
 			printk(">>FLASH - 13dBm<<\n");
 #endif
@@ -3113,15 +3358,11 @@ static void txpwr_dump(struct rtl8192cd_priv *priv, int start, int end)
 
 
 #if defined(CONFIG_RTL_92D_SUPPORT) && defined(CONFIG_RTL_92D_DMDP)
-			if (GET_CHIP_VER(priv)==VERSION_8192D) 
-			{
-				if (priv->pmib->dot11RFEntry.macPhyMode==DUALMAC_DUALPHY && priv->pshare->wlandev_idx == 1)
-				{
+			if (GET_CHIP_VER(priv)==VERSION_8192D) {
+				if (priv->pmib->dot11RFEntry.macPhyMode==DUALMAC_DUALPHY && priv->pshare->wlandev_idx == 1) {
 					printk("92D-DMDP WLAN1 , Set pwrlevelCCK_A = pwrlevelCCK_B\n");
-					if (phyBandSelect & PHY_BAND_2G)  
-					{
+					if (phyBandSelect & PHY_BAND_2G)
 						pwrlevelCCK_A = priv->pmib->dot11RFEntry.pwrlevelCCK_B[channel-1];
-					}
 				}
 			}
 #endif
@@ -3158,19 +3399,15 @@ static void txpwr_dump(struct rtl8192cd_priv *priv, int start, int end)
 			pg_tbl_idx = 0;
 
 #ifdef CONFIG_RTL_92D_SUPPORT
-			if (GET_CHIP_VER(priv) == VERSION_8192D)
-			{
-				if (priv->pshare->is_40m_bw == 0)
-				{
+			if (GET_CHIP_VER(priv) == VERSION_8192D) {
+				if (priv->pshare->is_40m_bw == 0) {
 					if (channel<=3)
 						pg_tbl_idx = BGN_20_CH1_3;
 					else if (channel<=9)
 						pg_tbl_idx = BGN_20_CH4_9;
 					else
 						pg_tbl_idx = BGN_20_CH10_14;
-				}
-				else
-				{			
+				} else {
 					if (channel<=3)
 						pg_tbl_idx = BGN_40_CH1_3;
 					else if (channel<=9)
@@ -3222,6 +3459,11 @@ static void txpwr_dump(struct rtl8192cd_priv *priv, int start, int end)
 				printk("%02x ", CCKTxAgc_B[tmp]);
 			printk("\n");
 
+#ifdef ADD_TX_POWER_BY_CMD
+			check_txpwr_by_cmd(priv, MCSTxAgcOffset_A, *MCSTxAgcOffset_B, 
+			 	OFDMTxAgcOffset_A, OFDMTxAgcOffset_B, CCKTxAgc_A, CCKTxAgc_B);
+#endif
+
 
 			//===Count FLASH + POWER BY RATE===
 
@@ -3304,7 +3546,7 @@ static void txpwr_dump(struct rtl8192cd_priv *priv, int start, int end)
 				OFDMTxAgcOffset_A[i] = POWER_MIN_CHECK(OFDMTxAgcOffset_A[i], max_idx);
 				OFDMTxAgcOffset_B[i] = POWER_MIN_CHECK(OFDMTxAgcOffset_B[i], max_idx);
 			}
-
+	
 			if (!txpwr_lmt_HT1S || !tgpwr_HT1S){
 				max_idx = 255;
 			}else{
@@ -3355,7 +3597,7 @@ static void txpwr_dump(struct rtl8192cd_priv *priv, int start, int end)
 				channel = 140;
 			else if(channel > 165)
 				channel = 165;
-		
+
 			//===GET FROM FLASH===
 			
 			pwrlevelHT40_1S_A = priv->pmib->dot11RFEntry.pwrlevel5GHT40_1S_A[channel-1];
@@ -3363,7 +3605,7 @@ static void txpwr_dump(struct rtl8192cd_priv *priv, int start, int end)
 			pwrdiffHT40_2S = priv->pmib->dot11RFEntry.pwrdiff5GHT40_2S[channel-1];
 			pwrdiffHT20 = priv->pmib->dot11RFEntry.pwrdiff5GHT20[channel-1];
 			pwrdiffOFDM = priv->pmib->dot11RFEntry.pwrdiff5GOFDM[channel-1];
-
+		
 #ifdef USB_POWER_SUPPORT
 			printk(">>Flash - 13dBm<<\n");
 #endif
@@ -3380,7 +3622,7 @@ static void txpwr_dump(struct rtl8192cd_priv *priv, int start, int end)
 			pwrlevelHT40_1S_B_6dB = priv->pmib->dot11RFEntry.pwrlevel5GHT40_1S_B[channel];
 			pwrdiffHT40_2S_6dB = priv->pmib->dot11RFEntry.pwrdiff5GHT40_2S[channel];
 			pwrdiffHT20_6dB = priv->pmib->dot11RFEntry.pwrdiff5GHT20[channel];
-			
+
 			printk("pwrlevelHT40_1S_A = %d, pwrlevelHT40_1S_B = %d\n", pwrlevelHT40_1S_A_6dB, pwrlevelHT40_1S_B_6dB);
 			printk("pwrdiffHT40_2S = %d(0x%02x), pwrdiffHT20 = %d(0x%02x)\n", 
 						pwrdiffHT40_2S_6dB, pwrdiffHT40_2S_6dB,
@@ -3421,19 +3663,15 @@ static void txpwr_dump(struct rtl8192cd_priv *priv, int start, int end)
 			pg_tbl_idx = 0;
 
 #ifdef CONFIG_RTL_92D_SUPPORT
-			if (GET_CHIP_VER(priv) == VERSION_8192D)
-			{
-				if (priv->pshare->is_40m_bw == 0)
-				{
+			if (GET_CHIP_VER(priv) == VERSION_8192D) {
+				if (priv->pshare->is_40m_bw == 0) {
 					if (channel<=99)
 						pg_tbl_idx = AN_20_CH_36_64;
 					else if (channel<=148)
 						pg_tbl_idx = AN_20_CH_100_140;
 					else
 						pg_tbl_idx = AN_20_CH_149_165;
-				}
-				else
-				{
+				} else {
 					if (channel<=99)
 						pg_tbl_idx = AN_40_CH_36_64;
 					else if (channel<=148)
@@ -3485,6 +3723,10 @@ static void txpwr_dump(struct rtl8192cd_priv *priv, int start, int end)
 				printk("%02x ", CCKTxAgc_B[tmp]);
 			printk("\n");
 
+#ifdef ADD_TX_POWER_BY_CMD
+			check_txpwr_by_cmd(priv, MCSTxAgcOffset_A, *MCSTxAgcOffset_B, 
+			 	OFDMTxAgcOffset_A, OFDMTxAgcOffset_B, CCKTxAgc_A, CCKTxAgc_B);
+#endif
 
 			//===Count FLASH + POWER BY RATE===
 
@@ -3569,7 +3811,7 @@ static void txpwr_dump(struct rtl8192cd_priv *priv, int start, int end)
 			}else{
 				max_idx = (txpwr_lmt_HT2S - tgpwr_HT2S);
 			}
-			
+
 			for (i=8; i<=15; i++) {
 				MCSTxAgcOffset_A[i] = POWER_MIN_CHECK(MCSTxAgcOffset_A[i], max_idx);
 				MCSTxAgcOffset_B[i] = POWER_MIN_CHECK(MCSTxAgcOffset_B[i], max_idx);
@@ -3582,13 +3824,13 @@ static void txpwr_dump(struct rtl8192cd_priv *priv, int start, int end)
 				MCSTxAgcOffset_A, MCSTxAgcOffset_B, OFDMTxAgcOffset_A, OFDMTxAgcOffset_B, phyBandSelect);
 
 #endif
-	
+			
 		}
 	}
 
 }
 
-
+#endif
 
 static void reg_dump(struct rtl8192cd_priv *priv, char *str)
 {
@@ -3599,24 +3841,25 @@ static void reg_dump(struct rtl8192cd_priv *priv, char *str)
 //_TXPWR_REDEFINE ?? Dump Too much will cause hang up ??
 	printk("[Channel-%03d]", priv->pmib->dot11RFEntry.dot11channel);
 
-	if (priv->pshare->is_40m_bw == 0)
-	{
-		printk(" - 20M BW");
-	}
-	else
-	{
-		printk(" - 40M BW ");
-			
-		if (priv->pshare->offset_2nd_chan == 1)
-			printk("BELOW");
-		else if (priv->pshare->offset_2nd_chan == 2)
-			printk("ABOVE");
-		else if (priv->pshare->offset_2nd_chan == 0)
-			printk("DONT CARE");
-	}
-	
-	printk("\n");
+			if (priv->pshare->is_40m_bw == 0)
+			{
+				printk(" - 20M BW");
+			}
+			else
+			{
+				printk(" - 40M BW ");
+				
+				if (priv->pshare->offset_2nd_chan == 1)
+					printk("BELOW");
+				else if (priv->pshare->offset_2nd_chan == 2)
+					printk("ABOVE");
+				else if (priv->pshare->offset_2nd_chan == 0)
+					printk("DONT CARE");
+			}
 
+			printk("\n");
+
+#ifdef _DEBUG_RTL8192CD_
 
 	if (strcmp(str, "tx") == 0)
 	{
@@ -3629,8 +3872,7 @@ static void reg_dump(struct rtl8192cd_priv *priv, char *str)
 
 
 #ifdef CONFIG_RTL_92D_SUPPORT
-		if (GET_CHIP_VER(priv)==VERSION_8192D)
-		{	
+		if (GET_CHIP_VER(priv)==VERSION_8192D) {
 			printk("\n==5G G1_L 36-45==\n");
 			txpwr_dump(priv, 36, 36);
 			printk("\n==5G G1_M 46-55==\n");
@@ -3641,7 +3883,7 @@ static void reg_dump(struct rtl8192cd_priv *priv, char *str)
 			txpwr_dump(priv, 100, 100);
 			printk("\n==5G G2_M 114-127==\n");
 			txpwr_dump(priv, 114, 114);
-			printk("\n==5G G2_H  128-148==\n");
+			printk("\n==5G G2_H 128-148==\n");
 			txpwr_dump(priv, 128, 128);
 			printk("\n==5G G3_L 149-154==\n");
 			txpwr_dump(priv, 149, 149);
@@ -3658,12 +3900,12 @@ static void reg_dump(struct rtl8192cd_priv *priv, char *str)
 
 	if (strcmp(str, "tx-2g") == 0)
 	{
-		printk("\n==2G L LIST==\n");
-		txpwr_dump(priv, 1, 3);
-		printk("\n==2G M LIST==\n");
-		txpwr_dump(priv, 4, 9);
-		printk("\n==2G H LIST==\n");
-		txpwr_dump(priv, 10, 14);
+			printk("\n==2G L LIST==\n");
+			txpwr_dump(priv, 1, 3);
+			printk("\n==2G M LIST==\n");
+			txpwr_dump(priv, 4, 9);
+			printk("\n==2G H LIST==\n");
+			txpwr_dump(priv, 10, 14);
 
 		return;
 	}
@@ -3671,16 +3913,14 @@ static void reg_dump(struct rtl8192cd_priv *priv, char *str)
 	if (strcmp(str, "tx-5gl") == 0)
 	{
 #ifdef CONFIG_RTL_92D_SUPPORT
-		if (GET_CHIP_VER(priv)==VERSION_8192D)
-		{	
+		if (GET_CHIP_VER(priv)==VERSION_8192D) {	
 			printk("\n==5G G1_L LIST==\n");
 			txpwr_dump(priv, 36, 45);
 			printk("\n==5G G1_M LIST==\n");
 			txpwr_dump(priv, 46, 55);
 			printk("\n==5G G1_H LIST==\n");
 			txpwr_dump(priv, 56, 66); //99 > 66, Because dump too much will cause reboot
-		}
-		else
+		} else
 #endif
 		{
 			printk("NOT 92D, NOT support 5G\n");
@@ -3692,16 +3932,14 @@ static void reg_dump(struct rtl8192cd_priv *priv, char *str)
 	if (strcmp(str, "tx-5gm") == 0)
 	{
 #ifdef CONFIG_RTL_92D_SUPPORT
-		if (GET_CHIP_VER(priv)==VERSION_8192D)
-		{	
+		if (GET_CHIP_VER(priv)==VERSION_8192D) {
 			printk("\n==5G G2_L LIST==\n");
 			txpwr_dump(priv, 100, 113);
 			printk("\n==5G G2_M LIST==\n");
 			txpwr_dump(priv, 114, 127);
 			printk("\n==5G G2_H LIST==\n");
 			txpwr_dump(priv, 128, 148);
-		}
-		else
+		} else
 #endif
 		{
 			printk("NOT 92D, NOT support 5G\n");
@@ -3714,28 +3952,40 @@ static void reg_dump(struct rtl8192cd_priv *priv, char *str)
 	{
 
 #ifdef CONFIG_RTL_92D_SUPPORT
-		if (GET_CHIP_VER(priv)==VERSION_8192D)
-		{	
+		if (GET_CHIP_VER(priv)==VERSION_8192D) {
 			printk("\n==5G G3_L LIST==\n");
 			txpwr_dump(priv, 149, 154);
 			printk("\n==5G G3_M LIST==\n");
 			txpwr_dump(priv, 155, 160);
 			printk("\n==5G G3_H LIST==\n");
 			txpwr_dump(priv, 161, 165);
-		}
-		else
+		} else
 #endif
 		{
 			printk("NOT 92D, NOT support 5G\n");
 		}
-
+			
 		return;
 	}
+#endif
 
 	if (strcmp(str, "all") != 0) {
 		panic_printk("Initial Gain, Sensitivity:\n");
 		panic_printk(" 0xC50: 0x%02x\n", RTL_R8(0xc50));
-		panic_printk(" 0xC58: 0x%02x\n", RTL_R8(0xc58));
+#if defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT)
+		if (
+#ifdef CONFIG_RTL_92C_SUPPORT
+			(GET_CHIP_VER(priv)==VERSION_8192C) || (GET_CHIP_VER(priv)==VERSION_8188C)
+#endif
+#ifdef CONFIG_RTL_92D_SUPPORT
+#ifdef CONFIG_RTL_92C_SUPPORT
+			|| 
+#endif
+			(GET_CHIP_VER(priv)==VERSION_8192D)
+#endif
+			)
+			panic_printk(" 0xC58: 0x%02x\n", RTL_R8(0xc58));
+#endif
 		panic_printk(" 0xC30: 0x%02x\n", RTL_R8(0xc30));
 		panic_printk(" 0xC87: 0x%02x\n", RTL_R8(0xc87));
 		panic_printk(" 0xA0A: 0x%02x\n", RTL_R8(0xa0a));
@@ -3885,7 +4135,10 @@ int del_sta(struct rtl8192cd_priv *priv, unsigned char *data)
 		{
 			SAVE_INT_AND_CLI(flags);
 			cnt_assoc_num(priv, pstat, DECREASE, (char *)__FUNCTION__);
-			check_sta_characteristic(priv, pstat, DECREASE);
+#ifdef CONFIG_RTL_88E_SUPPORT
+			if (GET_CHIP_VER(priv)!=VERSION_8188E) 
+#endif
+				check_sta_characteristic(priv, pstat, DECREASE);
 			RESTORE_INT(flags);
 
 			LOG_MSG("A STA is deleted by application program - %02X:%02X:%02X:%02X:%02X:%02X\n",
@@ -3979,7 +4232,10 @@ int del_sta_enc(struct rtl8192cd_priv *priv, unsigned char *data,int iStatusCode
 			printk("A STA is deleted by application program - %02X:%02X:%02X:%02X:%02X:%02X\n",macaddr[0], macaddr[1], macaddr[2], macaddr[3], macaddr[4], macaddr[5]);
 			SAVE_INT_AND_CLI(flags);
 			cnt_assoc_num(priv, pstat, DECREASE, (char *)__FUNCTION__);
-			check_sta_characteristic(priv, pstat, DECREASE);
+#ifdef CONFIG_RTL_88E_SUPPORT
+			if (GET_CHIP_VER(priv)!=VERSION_8188E) 
+#endif
+				check_sta_characteristic(priv, pstat, DECREASE);
 			RESTORE_INT(flags);
 
 			LOG_MSG("A STA is deleted by application program - %02X:%02X:%02X:%02X:%02X:%02X\n",
@@ -4058,6 +4314,28 @@ static void get_sta_info(struct rtl8192cd_priv *priv, sta_info_2_web *pInfo, int
 			if (!list_empty(&pstat->sleep_list))
 				pInfo->flags |= STA_INFO_FLAG_ASLEEP;
 			pInfo->TxOperaRate = pstat->current_tx_rate;
+#ifdef TLN_STATS
+			pInfo->RxOperaRate = pstat->rx_rate;
+			pInfo->enc_type = pstat->dot11KeyMapping.dot11Privacy;
+
+			if (priv->pmib->dot1180211AuthEntry.dot11EnablePSK) {
+				if (pstat->wpa_sta_info->RSNEnabled & PSK_WPA2)
+					pInfo->auth_type = STATS_PSK_WPA2;
+				else 
+					pInfo->auth_type = STATS_PSK_WPA;
+			} else if (IEEE8021X_FUN && ((pstat->dot11KeyMapping.dot11Privacy != _WEP_40_PRIVACY_) && 
+				(pstat->dot11KeyMapping.dot11Privacy != _WEP_104_PRIVACY_))) {
+				if (pstat->enterpise_wpa_info == STATS_ETP_WPA2)
+					pInfo->auth_type = STATS_ETP_WPA2;
+				else 
+					pInfo->auth_type = STATS_ETP_WPA;
+			} else {
+				 if (pstat->AuthAlgrthm)
+				 	pInfo->auth_type = STATS_AUTH_SHARE;
+				 else
+				 	pInfo->auth_type = STATS_AUTH_OPEN;
+			}
+#endif
 			pInfo->rssi = pstat->rssi;
 			pInfo->link_time = pstat->link_time;
 			pInfo->tx_fail = pstat->tx_fail;
@@ -4865,6 +5143,11 @@ static void rtl8192cd_SSReq_AutoTest(struct rtl8192cd_priv *priv)
 
 
 #ifdef CLIENT_MODE
+
+#ifndef WIFI_WPAS
+			static int check_bss_encrypt(struct rtl8192cd_priv *priv);
+#endif
+
 static int rtl8192cd_join_AutoTest(struct rtl8192cd_priv *priv, unsigned char *data)
 {
 	INT8 ret = 0;
@@ -5078,7 +5361,203 @@ static int rtl8192cd_get_ss_status(struct rtl8192cd_priv *priv, unsigned char *d
 
 	return 0;
 }
+#ifdef P2P_SUPPORT
+
+int p2p_get_p2pconnect_state(struct rtl8192cd_priv *priv, unsigned char *data)
+{
+	struct p2p_state_event	p2p_state_event_t;
+	memset(&p2p_state_event_t , 0 ,sizeof(struct p2p_state_event));	
+	
+	if(priv->p2pPtr==NULL)
+			return -1;	
+		
+	p2p_state_event_t.p2p_status = P2P_STATE;
+
+	if(P2P_STATE == P2P_S_CLIENT_CONNECTED_DHCPC){
+
+		P2P_DEBUG("Wlan driver report client is connected\n");
+		P2P_DEBUG("Indicate web server to start udhcpc \n\n");		
+		
+		P2P_STATE = P2P_S_CLIENT_CONNECTED_DHCPC_done ;	// after web rdy get this state ; change it
+		
+	}else if(P2P_STATE == P2P_S_preGO2GO_DHCPD){
+
+		P2P_DEBUG("now is GO mode\n");
+		P2P_DEBUG("Indicate web server to start udhcpd ...\n\n");		
+		P2P_STATE = P2P_S_preGO2GO_DHCPD_done ;	// after web rdy get this state ; change it
+		
+	}else if(P2P_STATE == P2P_S_back2dev){
+		// indicate web server to reset to p2p device mode
+		P2P_DEBUG("reinit by web server\n");
+		P2P_STATE = P2P_S_IDLE;
+
+	}	
+	
+	if (copy_to_user((void *)(data), (void *)&p2p_state_event_t, sizeof(struct p2p_state_event)))
+		return -1;	
+
+	return 0;
+
+}
+
+int p2p_get_event_state(struct rtl8192cd_priv *priv, unsigned char *data)
+{
+	int MethodCase=0;
+	struct p2p_state_event	p2p_state_event_t;
+	memset(&p2p_state_event_t , 0 ,sizeof(struct p2p_state_event));
+	
+	if(priv->p2pPtr==NULL)
+			return -1;	
+		
+	if(P2P_STATE>=P2P_S_PROVI_TX_REQ && P2P_STATE<=P2P_S_NEGO_WAIT_CONF )
+		p2p_state_event_t.p2p_status = 4;
+	else if(P2P_STATE ==P2P_S_CLIENT_CONNECTED_DHCPC ||  P2P_STATE ==P2P_S_CLIENT_CONNECTED_DHCPC_done)
+		p2p_state_event_t.p2p_status = 5;
+	else if(P2P_STATE == P2P_S_preGO2GO_DHCPD ||  P2P_STATE ==P2P_S_preGO2GO_DHCPD_done)
+		p2p_state_event_t.p2p_status = 6;	
+	else if(P2P_STATE == P2P_S_back2dev )
+		p2p_state_event_t.p2p_status = 7;
+	else
+		p2p_state_event_t.p2p_status = P2P_STATE;
 
+	
+	p2p_state_event_t.p2p_role = P2PMODE;	
+
+	if(P2P_EVENT_INDICATE){
+		
+		p2p_state_event_t.p2p_event = P2P_EVENT_INDICATE;	
+		
+		if(P2P_EVENT_INDICATE == P2P_EVENT_RX_PROVI_REQ)
+		{
+			MethodCase = priv->p2pPtr->wsc_method_from_target_dev;
+
+			switch(MethodCase){
+				case CONFIG_METHOD_PIN:
+				case CONFIG_METHOD_DISPLAY:  
+					p2p_state_event_t.p2p_wsc_method = CONFIG_METHOD_DISPLAY;
+					break;
+	 	 	    case CONFIG_METHOD_PBC:
+					p2p_state_event_t.p2p_wsc_method = CONFIG_METHOD_PBC;
+					break;
+			    case CONFIG_METHOD_KEYPAD:
+					p2p_state_event_t.p2p_wsc_method = CONFIG_METHOD_KEYPAD;
+					break;
+			}
+			
+		}
+		P2P_EVENT_INDICATE = 0 ;		
+	}
+
+	if (copy_to_user((void *)(data), (void *)&p2p_state_event_t, sizeof(struct p2p_state_event)))
+		return -1;	
+
+	return 0;
+}
+
+
+int p2p_wps_indicate_state(struct rtl8192cd_priv *priv, unsigned char *data)
+{
+
+	unsigned char flags;
+
+
+	printk("(%s %d)\n\n\n",__FUNCTION__,__LINE__);	
+
+	
+  	if (copy_from_user((void *)&flags, (void *)(data), 1)){
+		return -1;
+  	}
+
+	P2P_DEBUG("Report from wscd , WPS is %s\n\n\n", (flags==1?"success":"fail"));
+
+	if(flags == GO_WPS_SUCCESS){
+		if(P2PMODE == P2P_PRE_GO)
+		{
+			P2P_DEBUG("pre-GO mdoe ;rx Report from wscd ; WPS is done \n\n");	
+			// mode change
+			P2PMODE = P2P_TMP_GO ;
+
+			// state change
+			P2P_STATE = P2P_S_preGO2GO_DHCPD;
+
+			/*build beacon P2P IE  ; 
+			 when from (Pre go) switch to GO only need change beacon P2P IE*/ 			
+			if(P2PMODE == P2P_TMP_GO || P2PMODE == P2P_PRE_GO )
+				priv->p2pPtr->p2p_beacon_ie_len = 
+					p2p_build_beacon_ie(priv,priv->p2pPtr->p2p_beacon_ie);
+	
+		}else if(P2PMODE == P2P_PRE_CLIENT){
+			P2P_DEBUG("Pre-Client mdoe ;Report from wscd ; WPS is  done \n\n");			
+			P2PMODE = P2P_CLIENT ;
+		}
+	}
+	return 0;
+	
+}
+
+int rtl8192cd_p2p_ss_req(struct rtl8192cd_priv *priv, unsigned char *data, int len)
+{
+	INT8 ret = 0;
+	if (!netif_running(priv->dev)  || P2P_DISCOVERY	)
+		ret = -1;
+	else
+		ret = 0;
+
+	if (!ret)	// now, let's start site survey
+	{
+		printk("\n\n trigger P2P_discovery from UI\n");	
+			
+		P2P_DISCOVERY = 1;
+		priv->site_survey.count = 0;	
+		P2P_scan(priv,NULL);	
+	}
+
+	if (copy_to_user((void *)data, (void *)&ret, 1))
+		return -1;
+
+	return 0;
+}
+
+
+
+static int rtl8192cd_p2p_get_ss_status(struct rtl8192cd_priv *priv, unsigned char *data)
+{
+	UINT8 flags;
+	INT8 ret = 0;
+	//int idx ;
+	if (copy_from_user((void *)&flags, (void *)(data), 1))
+		return -1;
+
+	if (!netif_running(priv->dev) || P2P_DISCOVERY)
+	{
+		ret = -1;
+		if (copy_to_user((void *)(data), (void *)&ret, 1))
+			return -1;
+	}
+	else if (flags == 1)
+	{
+		ret = priv->site_survey.count_backup;
+		if (copy_to_user((void *)(data), (void *)&ret, 1))
+			return -1;
+	}
+	else if (flags == 0)
+	{
+		ret = priv->site_survey.count_backup;
+		if (copy_to_user((void *)data, (void *)&ret, 1))
+			return -1;
+		// now we should report data base.
+				
+		if (copy_to_user((void *)(data+4), priv->site_survey.bss_backup,
+				sizeof(struct bss_desc)*priv->site_survey.count_backup))
+			return -1;
+	}
+
+
+	return 0;
+}
+
+
+#endif
 
 #ifdef CLIENT_MODE
 #ifdef WIFI_WPAS
@@ -5606,6 +6085,7 @@ int rtl8192cd_net80211_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 }
 #endif
 
+
 int rtl8192cd_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 {
 #ifdef NETDEV_NO_PRIV
@@ -5868,6 +6348,9 @@ int rtl8192cd_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 				{ MP_QUERY_STATS, IW_PRIV_TYPE_CHAR | 40, IW_PRIV_TYPE_CHAR | 128, "mp_query" },
 				{ MP_TXPWR_TRACK, IW_PRIV_TYPE_CHAR | 40, 0, "mp_pwrtrk" },
 				{ MP_QUERY_TSSI, IW_PRIV_TYPE_CHAR | 40, IW_PRIV_TYPE_CHAR | 128, "mp_tssi" },
+				#ifdef MP_PSD_SUPPORT
+				{ MP_QUERY_PSD, IW_PRIV_TYPE_CHAR | 40, IW_PRIV_TYPE_CHAR | 128, "mp_psd" }, 
+				#endif
 				{ MP_QUERY_THER, IW_PRIV_TYPE_CHAR | 40, IW_PRIV_TYPE_CHAR | 128, "mp_ther" },
 #ifdef CONFIG_RTL_92D_SUPPORT
 				{ MP_SET_BAND, IW_PRIV_TYPE_CHAR | 40, IW_PRIV_TYPE_CHAR | 128, "mp_phyband" },
@@ -5924,6 +6407,9 @@ int rtl8192cd_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 				{ SIOCEFUSE_SET, IW_PRIV_TYPE_CHAR | 512, IW_PRIV_TYPE_CHAR | 128, "efuse_set" },
 				{ SIOCEFUSE_SYNC, IW_PRIV_TYPE_CHAR | 128, IW_PRIV_TYPE_CHAR | 128, "efuse_sync" },
 #endif
+#ifdef 	P2P_SUPPORT
+				{ SIOCP2PCMD, IW_PRIV_TYPE_CHAR | 128, IW_PRIV_TYPE_CHAR | 128, "p2pcmd" },
+#endif
 #ifdef CONFIG_RTL_92D_SUPPORT
 				{ SIOC92DIQK, IW_PRIV_TYPE_CHAR | 128, 0, "iqk" },
 				{ SIOC92DTEMPMP, IW_PRIV_TYPE_CHAR | 128, 0, "mprt" },
@@ -5936,7 +6422,10 @@ int rtl8192cd_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 #ifdef NON_INTR_ANTDIV
 				{ SIOC92DATNDIV, IW_PRIV_TYPE_CHAR | 128, 0 | 128, "antdiv" },
 #endif
+#ifdef DPK_92D
+				{ SIOC92DDPK, IW_PRIV_TYPE_CHAR | 128, 0 | 128, "dpk" },
 #endif
+#endif // CONFIG_RTL_92D_SUPPORT
 				{ SIOC92DAUTOCH, IW_PRIV_TYPE_CHAR | 128, 0, "autoch" }
 			};
 #endif
@@ -6309,6 +6798,9 @@ int rtl8192cd_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 
 
 	case RTL8192CD_IOCTL_USER_DAEMON_REQUEST:
+#ifdef PCIE_POWER_SAVING
+		PCIeWakeUp(priv, POWER_DOWN_T0);
+#endif
 		ret = rtl8192cd_ioctl_priv_daemonreq(dev, &wrq->u.data);
 		break;
 
@@ -6433,6 +6925,85 @@ int rtl8192cd_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 		ret	= rtl8192cd_get_ss_status(priv, (unsigned char *)(wrq->u.data.pointer));
 		break;
 
+/*--------------P2P related ioctl----------------------------------start*/
+#ifdef P2P_SUPPORT
+	/*P2P UI request do p2p discovery */
+	case SIOCP2PSCANREQ:		
+		if(!(OPMODE&WIFI_P2P_SUPPORT))
+			return -1;
+
+		if((P2PMODE  != P2P_DEVICE) && (P2PMODE  != P2P_CLIENT))
+			return -1;		
+
+
+#ifdef PCIE_POWER_SAVING
+		PCIeWakeUp(priv, POWER_DOWN_T0);
+#endif
+		ret = rtl8192cd_p2p_ss_req(priv, (unsigned char *)(wrq->u.data.pointer), wrq->u.data.length);
+		break;
+	/*P2P UI get P2P SS Status and Result*/
+	case SIOCP2PGETRESULT:	
+
+		if(!(OPMODE&WIFI_P2P_SUPPORT))
+			return -1;
+		if((P2PMODE  != P2P_DEVICE) && (P2PMODE  != P2P_CLIENT))
+			return -1;
+		
+#ifdef UNIVERSAL_REPEATER
+		if (IS_VXD_INTERFACE(priv)) {
+			DEBUG_ERR("can't get site-survey status for vxd!\n");
+			break;
+		}
+#endif
+#ifdef MBSSID
+		if (
+			GET_ROOT(priv)->pmib->miscEntry.vap_enable &&
+			IS_VAP_INTERFACE(priv)) {
+			DEBUG_ERR("can't get site-survey status for vap!\n");
+			break;
+		}
+#endif
+		ret	= rtl8192cd_p2p_get_ss_status(priv, (unsigned char *)(wrq->u.data.pointer));
+		break;
+
+	//-- issue provision discovery request , need device address from P2P UI --//
+	case SIOCP2PPROVREQ:	
+
+		#ifdef PCIE_POWER_SAVING
+		PCIeWakeUp(priv, POWER_DOWN_T0);
+		#endif
+		ret	= req_p2p_provision_req(priv, (unsigned char *)(wrq->u.data.pointer));
+		break;
+
+	/*P2P UI confirm wsc method,pincode,Target device to wlan driver, 
+	  if we active send provision req  before ,then will send nego req here */
+	case SIOCP2WSCMETHODCONF:	
+
+		#ifdef PCIE_POWER_SAVING
+		PCIeWakeUp(priv, POWER_DOWN_T0);
+		#endif
+		ret	= req_p2p_wsc_confirm(priv, (unsigned char *)(wrq->u.data.pointer));
+		break;
+
+	//-- report event and state to P2P UI--//		
+	case SIOCP2PPGETEVNIND:	
+		ret	= p2p_get_event_state(priv, (unsigned char *)(wrq->u.data.pointer));
+		break;
+
+	//-- wscd(GO mode) report WPS success or fail --//
+	case SIOCP2P_WSC_REPORT_STATE:	
+		ret	= p2p_wps_indicate_state(priv, (unsigned char *)(wrq->u.data.pointer));
+		break;
+
+	/*Report 1.p2p client connect state to web server ; for process start udhcpc
+			 2.p2p pre-GO change to GO (WPS is done and success) indicate web server need start udhcpd*/		
+	case SIOCP2P_REPORT_CLIENT_STATE:	
+		ret	= p2p_get_p2pconnect_state(priv, (unsigned char *)(wrq->u.data.pointer));
+		break;
+	
+#endif	// end of P2P_SUPPORT
+/*--------------P2P related ioctl----------------------------------end*/
+
 #ifdef AUTO_TEST_SUPPORT
 	case SIOCSSREQ:
 		rtl8192cd_SSReq_AutoTest(priv);
@@ -6676,6 +7247,22 @@ int rtl8192cd_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 			ret = 0;
 		}
 		break;
+	#ifdef MP_PSD_SUPPORT
+	case MP_QUERY_PSD:	
+		if (copy_from_user(tmpbuf, (void *)wrq->u.data.pointer, wrq->u.data.length))
+			break;		
+		RESTORE_INT(flags);
+		i = mp_query_psd(priv, tmpbuf);
+		SAVE_INT_AND_CLI(flags);
+		if (i > 0 ) {
+			if (copy_to_user((void *)wrq->u.data.pointer, tmpbuf, i )) 
+				break;
+			wrq->u.data.length = i;
+			ret = 0;
+			//printk("The address of DA is 0x%p\n",(void *)wrq->u.data.pointer);
+		}
+		break;
+	#endif
 	case MP_GET_TXPOWER:
 		if(copy_from_user(tmpbuf, (void *)wrq->u.data.pointer, wrq->u.data.length))
 			break;
@@ -6782,6 +7369,26 @@ int rtl8192cd_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 
 #endif
 
+
+#ifdef P2P_SUPPORT
+	case SIOCP2PCMD:
+
+		if(copy_from_user(tmpbuf, (void *)wrq->u.data.pointer, wrq->u.data.length))
+			break;
+		
+		//printk("ioctl-->process_p2p_cmd\n");
+		
+		i = process_p2p_cmd(priv, tmpbuf);
+		if (i > 0) {
+			if (copy_to_user((void *)wrq->u.data.pointer, tmpbuf, i))
+				break;
+		}
+		wrq->u.data.length = i;
+		ret = 0;
+		break;
+		
+#endif
+
 #ifdef MBSSID
 	case SIOCSICOPYMIB:
 		memcpy(priv->pmib, GET_ROOT_PRIV(priv)->pmib, sizeof(struct wifi_mib));
@@ -7392,6 +7999,53 @@ case SIOC_SET_ROUTING_INFO:
 		break;
 	}
 #endif // EN_EFUSE
+#ifdef DPK_92D
+	case SIOC92DDPK:
+	{
+		if (priv->pmib->dot11RFEntry.phyBandSelect==PHY_BAND_5G){
+			if (priv->pshare->rf_ft_var.dpk_on){
+				int ch = PHY_QueryRFReg(priv,RF92CD_PATH_A,0x18,0xff,1);
+				unsigned int curMaxRFPath, eRFPath;
+				if (priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY)
+					curMaxRFPath = RF92CD_PATH_B;
+				else
+					curMaxRFPath = RF92CD_PATH_MAX;
+
+				for(eRFPath = RF92CD_PATH_A; eRFPath < curMaxRFPath; eRFPath++){
+					if (eRFPath == RF92CD_PATH_A)
+						PHY_SetBBReg(priv, 0xb68, bMaskDWord, 0x28080000);
+					else
+						PHY_SetBBReg(priv, 0xb6c, bMaskDWord, 0x28080000);
+						
+					if (ch<=64){
+						PHY_SetRFReg(priv,eRFPath,0x03,bMask20Bits,0x94a12);
+						PHY_SetRFReg(priv,eRFPath,0x04,bMask20Bits,0x94a12);
+						PHY_SetRFReg(priv,eRFPath,0x0e,bMask20Bits,0x94a12);
+					}else if (ch<=140){
+						PHY_SetRFReg(priv,eRFPath,0x03,bMask20Bits,0x94a52);
+						PHY_SetRFReg(priv,eRFPath,0x04,bMask20Bits,0x94a52);
+						PHY_SetRFReg(priv,eRFPath,0x0e,bMask20Bits,0x94a52);
+					}else{
+						PHY_SetRFReg(priv,eRFPath,0x03,bMask20Bits,0x94a12);
+						PHY_SetRFReg(priv,eRFPath,0x04,bMask20Bits,0x94a12);
+						PHY_SetRFReg(priv,eRFPath,0x0e,bMask20Bits,0x94a12);
+					}
+				}
+				priv->pshare->rf_ft_var.dpk_on = 0;
+				panic_printk("DPK OFF!\n");
+			}else{
+				priv->pshare->rf_ft_var.dpk_on = 1;
+				panic_printk("DPK ON!\n");
+				//PHY_DPCalibrate(priv);
+			}
+			ret = 0;
+		}else {
+			panic_printk("NO DPK for 2G!\n");
+			ret = -1;
+		}
+		break;
+	}
+#endif
 #endif // CONFIG_RTL_92D_SUPPORT
 	}
 
diff --git a/drivers/net/wireless/rtl8192cd/8192cd_mp.c b/drivers/net/wireless/rtl8192cd/8192cd_mp.c
index 2d531af..fcc5b96 100644
--- a/drivers/net/wireless/rtl8192cd/8192cd_mp.c
+++ b/drivers/net/wireless/rtl8192cd/8192cd_mp.c
@@ -123,7 +123,11 @@ extern unsigned char TxPwrTrk_CCK_SwingTbl_CH14[TxPwrTrk_CCK_SwingTbl_Len][8];
 
 #ifdef USE_RTL8186_SDK
 #ifdef CONFIG_RTL8672
-	#include <platform.h>
+	#ifdef USE_RLX_BSP
+		#include <bspchip.h>
+	#else
+		#include <platform.h>
+	#endif
 #else
 #if defined(__LINUX_2_6__)
 #ifdef NOT_RTK_BSP
@@ -136,18 +140,32 @@ extern unsigned char TxPwrTrk_CCK_SwingTbl_CH14[TxPwrTrk_CCK_SwingTbl_Len][8];
 #endif
 #endif
 
+#ifdef CONFIG_RTL8672
+#ifdef USE_RLX_BSP
+#define _GIMR_				BSP_GIMR
+#define _ICU_UART0_MSK_		BSP_UART0_IE
+#define _UART0_RBR_			BSP_UART0_RBR
+#define _UART0_LSR_			BSP_UART0_LSR
+#else
+#define _GIMR_				GIMR
+#define _ICU_UART0_MSK_		UART0_IE
+#define _UART0_RBR_			UART0_RBR
+#define _UART0_LSR_			UART0_LSR
+#endif
+#else
 #if defined(__LINUX_2_6__)
 #define _GIMR_				BSP_GIMR
-#define _ICU_UART0_MSK_	BSP_UART0_IE
+#define _ICU_UART0_MSK_		BSP_UART0_IE
 #define _UART0_RBR_			BSP_UART0_RBR
 #define _UART0_LSR_			BSP_UART0_LSR
 #else
 #define _GIMR_				GIMR
-#define _ICU_UART0_MSK_	UART0_IE
+#define _ICU_UART0_MSK_		UART0_IE
 #define _UART0_RBR_			UART0_RBR
 #define _UART0_LSR_			UART0_LSR
 #endif
 #endif
+#endif
 
 #ifdef B2B_TEST
 #define MP_PACKET_HEADER		("wlan-tx-test")
@@ -233,9 +251,6 @@ static inline int IS_KEYBRD_HIT(void)
 /*
  *  find a token in a string. If succes, return pointer of token next. If fail, return null
  */
-#ifndef EN_EFUSE
-static
-#endif
 char *get_value_by_token(char *data, char *token)
 {
 		int idx=0, src_len=strlen(data), token_len=strlen(token);
@@ -320,7 +335,27 @@ static __inline__ int isLegalRate(unsigned int rate)
 	return res;
 }
 
+#ifdef MP_PSD_SUPPORT
+int GetPSDData(struct rtl8192cd_priv *priv,unsigned int point)
+{
+	int psd_val;
+
+	psd_val = RTL_R32(0x808);
+	psd_val &= 0xFFBFFC00;
+	psd_val |= point;
+
+	RTL_W32(0x808, psd_val);
+	delay_ms(1);
+	psd_val |= 0x00400000;
+
+	RTL_W32(0x808, psd_val);
+	delay_ms(1);
+	psd_val = RTL_R32(0x8B4);
 
+	psd_val &= 0x0000FFFF;
+	return psd_val;
+}
+#endif
 #if 0
 static void mp_RL5975e_Txsetting(struct rtl8192cd_priv *priv)
 {
@@ -489,15 +524,24 @@ static void mp_RF_RxLPFsetting(struct rtl8192cd_priv *priv)
 static void mp_8192CD_tx_setting(struct rtl8192cd_priv *priv)
 {
 	unsigned int odd_pwr = 0;
-	extern int get_CCK_swing_index(struct rtl8192cd_priv*);
+//	extern int get_CCK_swing_index(struct rtl8192cd_priv*);
 //#ifndef CONFIG_RTL_92D_SUPPORT
 #if 1//!defined(CONFIG_RTL_92D_SUPPORT) || defined(CONFIG_RTL_DUAL_PCIESLOT_BIWLAN_D)
 	extern void set_CCK_swing_index(struct rtl8192cd_priv*, short );
 #endif
 
-	if (is_CCK_rate(priv->pshare->mp_datarate) && ((!IS_TEST_CHIP(priv) && 
-		(GET_CHIP_VER(priv) == VERSION_8192C)) 
-		|| (GET_CHIP_VER(priv) == VERSION_8192D)
+#if defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT)
+	if (is_CCK_rate(priv->pshare->mp_datarate) 
+		&& (
+#ifdef CONFIG_RTL_92C_SUPPORT
+		(!IS_TEST_CHIP(priv) && (GET_CHIP_VER(priv) == VERSION_8192C)) 
+#endif
+#ifdef CONFIG_RTL_92D_SUPPORT
+#ifdef CONFIG_RTL_92C_SUPPORT
+		|| 
+#endif
+		(GET_CHIP_VER(priv) == VERSION_8192D)
+#endif
 		)) {
 		if (RTL_R8(0xa07) & 0x80) {
 			if (priv->pshare->mp_txpwr_patha % 2)
@@ -521,6 +565,7 @@ static void mp_8192CD_tx_setting(struct rtl8192cd_priv *priv)
 		}
 		priv->pshare->mp_cck_txpwr_odd = odd_pwr;
 	}
+#endif
 }
 
 
@@ -560,8 +605,17 @@ static void mpt_StartCckContTx(struct rtl8192cd_priv *priv)
 	PHY_SetBBReg(priv, rCCK0_System, bCCKBBMode, 0x2);    //transmit mode
 	PHY_SetBBReg(priv, rCCK0_System, bCCKScramble, 0x1);  //turn on scramble setting
 
+#if 1//def CONFIG_RTL8672
+	// Commented out for background mode, sync with SD7, 2010-07-08 by Annie ---
+	// We will set 0x820 and 0x828 under Tx mode in mp_ctx(), 2010-09-17 by Family.
+	//	PHY_SetBBReg(priv, 0x820, 0x400, 0x1);
+	//	PHY_SetBBReg(priv, 0x828, 0x400, 0x1);
+	//---
+#else //CONFIG_RTL8672
 	PHY_SetBBReg(priv, 0x820, 0x400, 0x1);
 	PHY_SetBBReg(priv, 0x828, 0x400, 0x1);
+#endif //CONFIG_RTL8672
+
 }
 
 
@@ -608,8 +662,18 @@ static void mpt_StartOfdmContTx(struct rtl8192cd_priv *priv)
 	PHY_SetBBReg(priv, rOFDM1_LSTF, bOFDMSingleCarrier, bDisable);
 	PHY_SetBBReg(priv, rOFDM1_LSTF, bOFDMSingleTone, bDisable);
 
+
+#if 1//def CONFIG_RTL8672
+	// Commented out for background mode, sync with SD7, 2010-07-08 by Annie ---
+	// We will set 0x820 and 0x828 under Tx mode in mp_ctx(), 2010-09-17 by Family.
+	//	PHY_SetBBReg(priv, 0x820, 0x400, 0x1);
+	//	PHY_SetBBReg(priv, 0x828, 0x400, 0x1);
+	//---
+#else //CONFIG_RTL8672
 	PHY_SetBBReg(priv, 0x820, 0x400, 0x1);
 	PHY_SetBBReg(priv, 0x828, 0x400, 0x1);
+#endif //CONFIG_RTL8672
+
 }
 
 
@@ -676,6 +740,11 @@ void mp_start_test(struct rtl8192cd_priv *priv)
 		return;
 	}
 
+#ifdef MP_SWITCH_LNA
+	priv->pshare->rx_packet_ss_a = 0;
+	priv->pshare->rx_packet_ss_b = 0;
+#endif
+
 #ifdef TEMP_MP_92D
 	RTL_W32(CR, (RTL_R32(CR) & ~(NETYPE_Mask << NETYPE_SHIFT)) | ((NETYPE_NOLINK & NETYPE_Mask) << NETYPE_SHIFT));
 
@@ -795,18 +864,31 @@ void mp_start_test(struct rtl8192cd_priv *priv)
 	set_DIG_state(priv, 0);
 	delay_ms(1);
 
-#ifdef HIGH_POWER_EXT_PA
+#if defined( HIGH_POWER_EXT_PA) && defined(CONFIG_RTL_92C_SUPPORT)
 
 //_TXPWR_REDEFINE ?? shall also apply to Normal Driver ??
-	if ((priv->pshare->rf_ft_var.use_ext_pa) && (GET_CHIP_VER(priv)!=VERSION_8192D)) {
+	if ((priv->pshare->rf_ft_var.use_ext_pa) && 
+		((GET_CHIP_VER(priv)==VERSION_8192C)  || (GET_CHIP_VER(priv)==VERSION_8188E))) {
 		RTL_W8(0xc50, 0x2e);
 		RTL_W8(0xc58, 0x2e);
-	}
-	else
+	} else
 #endif
 	if (priv->pshare->rf_ft_var.use_ext_lna) {
 		RTL_W8(0xc50, 0x2a);
-		RTL_W8(0xc58, 0x2a);
+#if defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT)
+		if (
+#ifdef CONFIG_RTL_92C_SUPPORT
+			(GET_CHIP_VER(priv)==VERSION_8192C) || (GET_CHIP_VER(priv)==VERSION_8188C) 
+#endif
+#ifdef CONFIG_RTL_92D_SUPPORT
+#ifdef CONFIG_RTL_92C_SUPPORT
+			|| 
+#endif
+			(GET_CHIP_VER(priv)==VERSION_8192D)
+#endif
+			)
+			RTL_W8(0xc58, 0x2a);
+#endif
 	}
 #ifdef CONFIG_RTL_92D_SUPPORT
 	else if (GET_CHIP_VER(priv)==VERSION_8192D) {
@@ -858,6 +940,9 @@ void mp_start_test(struct rtl8192cd_priv *priv)
 	printk("        - if \"stone\", send packet in single-tone.\n");
 	printk("        - default: tx infinitely (no background).\n");
 	printk("  iwpriv wlanx mp_query\n");
+#ifdef MP_PSD_SUPPORT
+	printk("  iwpriv wlanx mp_psd\n"); 
+#endif
 	printk("  iwpriv wlanx mp_ther\n");
 	printk("  iwpriv wlanx mp_pwrtrk [ther={7-29}, stop]\n");
 #ifdef CONFIG_RTL_92D_SUPPORT
@@ -906,6 +991,14 @@ void mp_stop_test(struct rtl8192cd_priv *priv)
 		return;
 	}
 
+#if 1//def CONFIG_RTL8672
+	// make sure mp_ctx action stop, otherwise it will cause memory leak(skb_pool_ptr) for linux SDK
+	//	 ,or crash dump for OSK because free skb_pool using rtl_kfree_skb()
+	if (OPMODE & WIFI_MP_CTX_BACKGROUND) {
+		mp_ctx(priv, "stop");
+	}
+#endif
+
 	// enable beacon
 	RTL_W8(TXPAUSE, RTL_R8(TXPAUSE) & ~STOP_BCN);
 	OPMODE &= ~WIFI_MP_STATE;
@@ -1135,6 +1228,10 @@ void mp_set_channel(struct rtl8192cd_priv *priv, unsigned char *data)
 		Update92DRFbyChannel(priv, channel);
 		
 		PHY_IQCalibrate(priv);
+#ifdef DPK_92D		
+		if (priv->pmib->dot11RFEntry.phyBandSelect==PHY_BAND_5G && priv->pshare->rf_ft_var.dpk_on)
+			PHY_DPCalibrate(priv);
+#endif
 	}
 #endif
 
@@ -1146,14 +1243,21 @@ void mp_set_channel(struct rtl8192cd_priv *priv, unsigned char *data)
 //#endif
 
 	priv->pshare->working_channel = channel;
+
+	//CCK Shaping Filter
+	if(priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_2G)
+		set_CCK_swing_index(priv, 12);
+	
 //	mp_8192CD_tx_setting(priv);
 
+#ifdef CONFIG_RTL_92C_SUPPORT
 	if(IS_UMC_B_CUT_88C(priv)) {
 		if(channel==6)
 			RTL_W8(0xc50, 0x22);
 		else
 			RTL_W8(0xc50, 0x20);
 	}
+#endif
 
 #ifdef TXPWR_LMT
 	if (!priv->pshare->rf_ft_var.disable_txpwrlmt){
@@ -1192,7 +1296,7 @@ void mp_set_channel(struct rtl8192cd_priv *priv, unsigned char *data)
 			//printk("priv->pshare->phw->MCSTxAgcOffset_A[%d]=%x\n",i, priv->pshare->phw->MCSTxAgcOffset_A[i]);
 			//printk("priv->pshare->phw->MCSTxAgcOffset_B[%d]=%x\n",i, priv->pshare->phw->MCSTxAgcOffset_B[i]);
 		}
-
+		
 		if (!priv->pshare->txpwr_lmt_HT2S || !priv->pshare->tgpwr_HT2S){
 			DEBUG_INFO("No limit for HT2S TxPower\n");
 			max_idx=255;
@@ -1564,6 +1668,53 @@ void mp_set_tx_power(struct rtl8192cd_priv *priv, unsigned char *data)
 			priv->pshare->mp_txpwr_patha, priv->pshare->mp_txpwr_pathb);
 		printk(tmpbuf);
 	}
+
+
+#ifdef CONFIG_RTL_92D_SUPPORT
+#ifdef DPK_92D
+	if ((GET_CHIP_VER(priv) == VERSION_8192D) && (priv->pmib->dot11RFEntry.phyBandSelect & PHY_BAND_5G) ) {
+
+		unsigned int tmp_txpwr_dpk_0 = 0, tmp_txpwr_dpk_1 = 0;
+
+		tmp_txpwr_dpk_0 += (priv->pshare->TxPowerLevelDPK[0]);
+		tmp_txpwr_dpk_0 += (priv->pshare->TxPowerLevelDPK[0]<<8);
+		tmp_txpwr_dpk_0 += (priv->pshare->TxPowerLevelDPK[0]<<16);
+		tmp_txpwr_dpk_0 += (priv->pshare->TxPowerLevelDPK[0]<<24);
+
+		tmp_txpwr_dpk_1 += (priv->pshare->TxPowerLevelDPK[1]);
+		tmp_txpwr_dpk_1 += (priv->pshare->TxPowerLevelDPK[1]<<8);
+		tmp_txpwr_dpk_1 += (priv->pshare->TxPowerLevelDPK[1]<<16);
+		tmp_txpwr_dpk_1 += (priv->pshare->TxPowerLevelDPK[1]<<24);
+		
+		priv->pshare->phw->power_backup[0x00] = RTL_R32(rTxAGC_A_Rate18_06);
+		priv->pshare->phw->power_backup[0x01] = RTL_R32(rTxAGC_A_Rate54_24);
+		priv->pshare->phw->power_backup[0x02] = RTL_R32(rTxAGC_B_Rate18_06);
+		priv->pshare->phw->power_backup[0x03] = RTL_R32(rTxAGC_B_Rate54_24);
+		priv->pshare->phw->power_backup[0x04] = RTL_R32(rTxAGC_A_Mcs03_Mcs00);
+		priv->pshare->phw->power_backup[0x05] = RTL_R32(rTxAGC_A_Mcs07_Mcs04);
+		priv->pshare->phw->power_backup[0x06] = RTL_R32(rTxAGC_A_Mcs11_Mcs08);
+		priv->pshare->phw->power_backup[0x07] = RTL_R32(rTxAGC_A_Mcs15_Mcs12);
+		priv->pshare->phw->power_backup[0x08] = RTL_R32(rTxAGC_B_Mcs03_Mcs00);
+		priv->pshare->phw->power_backup[0x09] = RTL_R32(rTxAGC_B_Mcs07_Mcs04);
+		priv->pshare->phw->power_backup[0x0a] = RTL_R32(rTxAGC_B_Mcs11_Mcs08);
+		priv->pshare->phw->power_backup[0x0b] = RTL_R32(rTxAGC_B_Mcs15_Mcs12);
+
+		RTL_W32(rTxAGC_A_Rate18_06, priv->pshare->phw->power_backup[0x00]	 +tmp_txpwr_dpk_0);
+		RTL_W32(rTxAGC_A_Rate54_24, priv->pshare->phw->power_backup[0x01]	 +tmp_txpwr_dpk_0);
+		RTL_W32(rTxAGC_B_Rate18_06, priv->pshare->phw->power_backup[0x02]	 +tmp_txpwr_dpk_1);
+		RTL_W32(rTxAGC_B_Rate54_24, priv->pshare->phw->power_backup[0x03]	 +tmp_txpwr_dpk_1);
+		RTL_W32(rTxAGC_A_Mcs03_Mcs00, priv->pshare->phw->power_backup[0x04]  +tmp_txpwr_dpk_0);
+		RTL_W32(rTxAGC_A_Mcs07_Mcs04, priv->pshare->phw->power_backup[0x05]  +tmp_txpwr_dpk_0);
+		RTL_W32(rTxAGC_A_Mcs11_Mcs08, priv->pshare->phw->power_backup[0x06]  +tmp_txpwr_dpk_0);
+		RTL_W32(rTxAGC_A_Mcs15_Mcs12, priv->pshare->phw->power_backup[0x07]  +tmp_txpwr_dpk_0);
+		RTL_W32(rTxAGC_B_Mcs03_Mcs00, priv->pshare->phw->power_backup[0x08]  +tmp_txpwr_dpk_1);
+		RTL_W32(rTxAGC_B_Mcs07_Mcs04, priv->pshare->phw->power_backup[0x09]  +tmp_txpwr_dpk_1);
+		RTL_W32(rTxAGC_B_Mcs11_Mcs08, priv->pshare->phw->power_backup[0x0a]  +tmp_txpwr_dpk_1);
+		RTL_W32(rTxAGC_B_Mcs15_Mcs12, priv->pshare->phw->power_backup[0x0b]  +tmp_txpwr_dpk_1);
+	}
+#endif
+#endif
+
 }
 
 
@@ -1587,6 +1738,9 @@ void mp_ctx(struct rtl8192cd_priv *priv, unsigned char *data)
 	int len, i=0, q_num;
 	unsigned char pattern;
 	char *val;
+#if 1//def CONFIG_RTL8672
+	unsigned long flags2=0;
+#endif
 	unsigned long end_time=0;
 	unsigned long flags=0;
 	int tx_from_isr=0, background=0;
@@ -1672,6 +1826,9 @@ void mp_ctx(struct rtl8192cd_priv *priv, unsigned char *data)
 	val = get_value_by_token((char *)data, "stop");
 	if (val) {
 		unsigned long flags;
+#if 1//def CONFIG_RTL8672
+		unsigned long cnt;
+#endif
 
 		if (!(OPMODE & WIFI_MP_CTX_BACKGROUND)) {
 			printk("Error! Continuous-Tx is not on-going.\n");
@@ -1679,11 +1836,32 @@ void mp_ctx(struct rtl8192cd_priv *priv, unsigned char *data)
 		}
 		printk("Stop continuous TX\n");
 
+
+#if 1//def CONFIG_RTL8672
+		SAVE_INT_AND_CLI(flags);
+		OPMODE |= WIFI_MP_CTX_BACKGROUND_STOPPING;
+		OPMODE &= ~WIFI_MP_CTX_BACKGROUND_PENDING;
+		RESTORE_INT(flags);
+
+		cnt = 0;
+		while ((priv->pshare->skb_head != priv->pshare->skb_tail) && (cnt < 200000)) {
+			rtl8192cd_tx_dsr(priv);
+			delay_us(50);
+			++cnt;
+		}
+
+		SAVE_INT_AND_CLI(flags);
+		OPMODE &= ~(WIFI_MP_CTX_BACKGROUND | WIFI_MP_CTX_BACKGROUND_PENDING | WIFI_MP_CTX_PACKET |
+				WIFI_MP_CTX_ST | WIFI_MP_CTX_CCK_CS |WIFI_MP_CTX_OFDM_HW |
+				WIFI_MP_CTX_BACKGROUND_STOPPING);
+		RESTORE_INT(flags);
+#else //CONFIG_RTL8672
 		SAVE_INT_AND_CLI(flags);
 		OPMODE &= ~(WIFI_MP_CTX_BACKGROUND | WIFI_MP_CTX_BACKGROUND_PENDING);
 		RESTORE_INT(flags);
 
 		delay_ms(1000);
+#endif //CONFIG_RTL8672
 		for (i=0; i<NUM_MP_SKB; i++)
 			kfree(priv->pshare->skb_pool[i]->head);
 		kfree(priv->pshare->skb_pool_ptr);
@@ -1696,8 +1874,15 @@ void mp_ctx(struct rtl8192cd_priv *priv, unsigned char *data)
 	val = get_value_by_token((char *)data, "tx-isr");
 	if (val) {
 		if (OPMODE & WIFI_MP_CTX_BACKGROUND) {
+
+#if 1//def CONFIG_RTL8672
+			if ((OPMODE & WIFI_MP_CTX_ST) || (!(OPMODE & (WIFI_MP_CTX_PACKET|WIFI_MP_CTX_CCK_CS)) &&
+					(priv->net_stats.tx_packets > 0)) )
+				return;
+#else //CONFIG_RTL8672
 			if (OPMODE & WIFI_MP_CTX_OFDM_HW)
 				return;
+#endif //CONFIG_RTL8672
 
 			tx_from_isr = 1;
 			time = -1;
@@ -1810,11 +1995,21 @@ void mp_ctx(struct rtl8192cd_priv *priv, unsigned char *data)
         if (is_CCK_rate(priv->pshare->mp_datarate)) {
                 PHY_SetRFReg(priv, 0, 0x26, bMask20Bits, 0x0f400);
         } else {
-                if( IS_UMC_A_CUT_88C(priv) || GET_CHIP_VER(priv) == VERSION_8192C )
-                        PHY_SetRFReg(priv, 0, 0x26, bMask20Bits, 0x4f000);
-                else
-                        PHY_SetRFReg(priv, 0, 0x26, bMask20Bits, 0x4f200);
-        }
+#ifdef CONFIG_RTL_92C_SUPPORT
+		if( IS_UMC_A_CUT_88C(priv) || GET_CHIP_VER(priv) == VERSION_8192C) {
+			PHY_SetRFReg(priv, 0, 0x26, bMask20Bits, 0x4f000);
+		} else
+#endif
+		{
+#ifdef CONFIG_RTL_92C_SUPPORT
+			if( (IS_UMC_B_CUT_88C(priv) || GET_CHIP_VER(priv) == VERSION_8192C) 
+				&& ((priv->pmib->dot11RFEntry.dot11channel == 4)||(priv->pmib->dot11RFEntry.dot11channel == 12)))
+				PHY_SetRFReg(priv, 0, 0x26, bMask20Bits, 0x4f000);
+			else
+#endif
+				PHY_SetRFReg(priv, 0, 0x26, bMask20Bits, 0x4f200);
+		}
+	}
 
 
 	i = 0;
@@ -1895,7 +2090,11 @@ void mp_ctx(struct rtl8192cd_priv *priv, unsigned char *data)
 				PHY_SetRFReg(priv, RF92CD_PATH_A, 0x21, bMask20Bits, 0xd4000);
 			}
 			delay_us(100);
+#ifdef HIGH_POWER_EXT_PA
+				PHY_SetRFReg(priv, eRFPath, 0x00, bMask20Bits, 0x20000); //From suggestion of BS (RF Team)
+#else
 				PHY_SetRFReg(priv, eRFPath, 0x00, bMask20Bits, 0x20010);
+#endif
 			delay_us(100);
 
 #ifdef HIGH_POWER_EXT_PA
@@ -1988,8 +2187,12 @@ void mp_ctx(struct rtl8192cd_priv *priv, unsigned char *data)
 			SetFrDs(txinsn.phdr);
 			SetFrameType(txinsn.phdr, WIFI_DATA);
 
-			if(rtl8192cd_firetx(priv, &txinsn) == CONGESTED) {
+			if(rtl8192cd_firetx(priv, &txinsn) == CONGESTED) 
+			{
 				//printk("Congested\n");
+#if 1//def CONFIG_RTL8672 
+
+#else //CONFIG_RTL8672
 				if (tx_from_isr) {
 					head = get_txhead(phw, BE_QUEUE);
 					tail = get_txtail(phw, BE_QUEUE);
@@ -1997,6 +2200,7 @@ void mp_ctx(struct rtl8192cd_priv *priv, unsigned char *data)
 						OPMODE |= (WIFI_MP_CTX_BACKGROUND | WIFI_MP_CTX_BACKGROUND_PENDING);
 					return;
 				}
+#endif //CONFIG_RTL8672
 				i--;
 				priv->pshare->mp_ctx_pkt--;
 				if (txinsn.phdr)
@@ -2010,6 +2214,21 @@ void mp_ctx(struct rtl8192cd_priv *priv, unsigned char *data)
 					rtl_kfree_skb(priv, skb, _SKB_TX_);
 				}
 
+
+#if 1//def CONFIG_RTL8672
+				if (tx_from_isr) {
+					head = get_txhead(phw, BE_QUEUE);
+					tail = get_txtail(phw, BE_QUEUE);
+					if (head == tail) // if Q empty,invoke 1s-timer to send
+						OPMODE |= (WIFI_MP_CTX_BACKGROUND | WIFI_MP_CTX_BACKGROUND_PENDING);
+					return;
+				} else {
+					SAVE_INT_AND_CLI(flags2);
+					rtl8192cd_tx_dsr((unsigned long)priv);
+					RESTORE_INT(flags2);
+				}
+
+#else //CONFIG_RTL8672
 				if (!tx_from_isr) {
 					SAVE_INT_AND_CLI(flags);
 #ifdef SMP_SYNC
@@ -2022,8 +2241,52 @@ void mp_ctx(struct rtl8192cd_priv *priv, unsigned char *data)
 #endif
 					RESTORE_INT(flags);
 				}
+#endif //CONFIG_RTL8672
 			}
-		} else {
+#if 1//def CONFIG_RTL8672
+			else if ((1 == priv->net_stats.tx_packets) &&
+				((OPMODE & (WIFI_MP_CTX_PACKET| WIFI_MP_CTX_BACKGROUND| WIFI_MP_CTX_ST|
+				WIFI_MP_CTX_CCK_CS))==WIFI_MP_CTX_BACKGROUND) )
+			{
+				#define CHECK_TX_MODE_CNT	40
+				int check_cnt;
+				
+				// must sure RF is in TX mode before enabling TXAGC function.
+				if ( priv->pshare->mp_antenna_tx & ANTENNA_A ) {
+					check_cnt = 0;
+					while ( (PHY_QueryRFReg(priv, RF92CD_PATH_A, 0x00, 0x70000, 1) != 0x02) && (check_cnt < CHECK_TX_MODE_CNT) ) {
+						delay_ms(1); ++check_cnt;
+					}
+					printk("RF(A) # of check tx mode = %d (%d)\n", check_cnt, tx_from_isr);
+					PHY_SetBBReg(priv, 0x820, 0x400, 0x1);
+				}
+				
+				if ( priv->pshare->mp_antenna_tx & ANTENNA_B ) {
+					check_cnt = 0;
+					while ( (PHY_QueryRFReg(priv, RF92CD_PATH_B, 0x00, 0x70000, 1) != 0x02) && (check_cnt < CHECK_TX_MODE_CNT) ) {
+						delay_ms(1); ++check_cnt;
+			}
+					printk("RF(B) # of check tx mode = %d\n", check_cnt);
+					PHY_SetBBReg(priv, 0x828, 0x400, 0x1);
+				}
+
+				if ( background ) {
+					RESTORE_INT(flags);
+				} else if (tx_from_isr) {
+					OPMODE &= ~WIFI_MP_CTX_BACKGROUND_PENDING;
+				}
+				return;
+
+				#undef CHECK_TX_MODE_CNT
+			}
+#endif
+		}
+		else 
+		{
+#ifdef CONFIG_RTL8672
+			i--;
+			priv->pshare->mp_ctx_pkt--;
+#endif
 			//printk("Can't allocate sk_buff\n");
 			if (tx_from_isr) {
 				head = get_txhead(phw, BE_QUEUE);
@@ -2032,10 +2295,17 @@ void mp_ctx(struct rtl8192cd_priv *priv, unsigned char *data)
 					OPMODE |= (WIFI_MP_CTX_BACKGROUND | WIFI_MP_CTX_BACKGROUND_PENDING);
 				return;
 			}
+#if 1//def CONFIG_RTL8672	
+			delay_ms(1);
+			SAVE_INT_AND_CLI(flags2);
+			rtl8192cd_tx_dsr((unsigned long)priv);
+			RESTORE_INT(flags2);
+#else //CONFIG_RTL8672
 			i--;
 			priv->pshare->mp_ctx_pkt--;
 			delay_ms(1);
 			SAVE_INT_AND_CLI(flags);
+#endif //CONFIG_RTL8672
 #ifdef SMP_SYNC
 			if (!priv->pshare->has_triggered_tx_tasklet) {
 				tasklet_schedule(&priv->pshare->tx_tasklet);
@@ -2047,7 +2317,7 @@ void mp_ctx(struct rtl8192cd_priv *priv, unsigned char *data)
 			RESTORE_INT(flags);
 		}
 
-		if ((background || tx_from_isr) && (i == NUM_TX_DESC/4)) {
+		if ((background || tx_from_isr) && (i == CURRENT_NUM_TX_DESC/4)) {
 			OPMODE &= ~WIFI_MP_CTX_BACKGROUND_PENDING;
 			if (background)
 				RESTORE_INT(flags);
@@ -2351,6 +2621,75 @@ int mp_query_ther(struct rtl8192cd_priv *priv, unsigned char *data)
 	return strlen(data)+1;
 }
 
+#ifdef MP_PSD_SUPPORT
+int mp_query_psd(struct rtl8192cd_priv *priv, unsigned char * data)
+{
+	char *val;
+	unsigned int i, psd_pts=0, psd_start=0, psd_stop=0;
+	int psd_data=0;
+
+	if (!netif_running(priv->dev)) {
+		printk("\nFail: interface not opened\n");
+		return 0;
+	}
+
+	if (!(OPMODE & WIFI_MP_STATE)) {
+		printk("Fail: not in MP mode\n");
+		return 0;
+	}
+
+	if (strlen(data) == 0) { //default value
+		psd_pts = 128;
+		psd_start = 64;
+		psd_stop = 128;   
+		
+	}
+	else
+	{
+		val = get_value_by_token((char *)data, "pts=");
+		if (val) {
+			psd_pts = _atoi(val,10);
+		}else {
+			psd_pts = 128;
+		}
+
+		val = get_value_by_token((char *)data, "start=");
+		if (val) {
+			psd_start=_atoi(val,10);
+		}else {
+			psd_start = 64;
+		}
+
+		val = get_value_by_token((char *)data, "stop=");
+		if (val) {
+			psd_stop=_atoi(val,10);
+		}else {
+			psd_stop = psd_pts;   
+		}
+	}
+
+	memset(data,'\0',sizeof(data));
+
+	i = psd_start;
+	while( i < psd_stop) {
+		
+		if( i>= psd_pts) {
+			psd_data = GetPSDData(priv,(i-psd_pts));
+		}
+		else {
+			psd_data = GetPSDData(priv,i);
+		}
+		sprintf(data, "%s%x ",data, psd_data);
+		i++;
+	}
+
+	//panic_printk("read psd = %s\n", data);
+	//printk("Length is %d\n",strlen(data));
+	delay_ms(100);
+
+	return strlen(data)+1;
+}
+#endif
 
 int mp_get_txpwr(struct rtl8192cd_priv *priv, unsigned char *data)
 {
@@ -2662,7 +3001,16 @@ int mp_tx(struct rtl8192cd_priv *priv, unsigned char *data)
 	printk("\n");
 #endif
 
-	RTL_W32(HIMR, RTL_R32(HIMR) | HIMR_BEDOK);
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv)==VERSION_8188E) {
+		priv->pshare->InterruptMask |= HIMR_88E_BEDOK;
+		RTL_W32(REG_88E_HIMR, priv->pshare->InterruptMask);
+	} else
+#endif
+	{
+		RTL_W32(HIMR, RTL_R32(HIMR) | HIMR_BEDOK);
+	}
+
 //	RTL_W32(_RCR_, _NO_ERLYRX_);
 	RTL_W32(RCR, RTL_R32(RCR) & ~(RCR_AB | RCR_AM | RCR_APM | RCR_AAP));
 
@@ -3258,16 +3606,24 @@ int mp_arx(struct rtl8192cd_priv *priv, unsigned char *data)
 
 	if (!strcmp(data, "start")) {
 		OPMODE |= WIFI_MP_RX;
+#ifdef MP_SWITCH_LNA
+		priv->pshare->rx_packet_ss_a = 0;
+		priv->pshare->rx_packet_ss_b = 0;
+		PHY_SetBBReg(priv, 0xd00, BIT(27)|BIT(26), 0x3);
+		RTL_W32(RCR, RCR_APWRMGT | RCR_AMF | RCR_ADF |RCR_ACRC32 |RCR_AB | RCR_AM | RCR_APM | RCR_AAP | RCR_APP_PHYSTS);
+#else
 		RTL_W32(RCR, RCR_APWRMGT | RCR_AMF | RCR_ADF |RCR_ACRC32 |RCR_AB | RCR_AM | RCR_APM | RCR_AAP);
+#endif
 		if (priv->pshare->rf_ft_var.use_frq_2_3G)
 			PHY_SetBBReg(priv, rCCK0_System, bCCKEqualizer, 0x0);
 
 		memset(&priv->net_stats, 0,  sizeof(struct net_device_stats));
 		memset(&priv->ext_stats, 0,  sizeof(struct extra_stats));
 
+#ifdef CONFIG_RTL_92C_SUPPORT
                if( IS_UMC_B_CUT_88C(priv) )
                         PHY_SetRFReg(priv, 0, 0x26, bMask20Bits, 0x4f200);
-
+#endif
 	} else if (!strcmp(data, "stop")) {
 		OPMODE &= ~WIFI_MP_RX;
 		RTL_W32(RCR, RTL_R32(RCR) & ~(RCR_AB | RCR_AM | RCR_APM | RCR_AAP));
diff --git a/drivers/net/wireless/rtl8192cd/8192cd_net80211.c b/drivers/net/wireless/rtl8192cd/8192cd_net80211.c
index 552e481..9122a9f 100644
--- a/drivers/net/wireless/rtl8192cd/8192cd_net80211.c
+++ b/drivers/net/wireless/rtl8192cd/8192cd_net80211.c
@@ -1,1928 +1,1937 @@
-/*
- *   API-compatible handling routines
- *
- *
- *
- *  Copyright (c) 2009 Realtek Semiconductor Corp.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
- */
-
-#ifdef __KERNEL__
-#include <linux/module.h>
-#include <linux/init.h>
-#include <asm/uaccess.h>
-#include <linux/unistd.h>
-#include <linux/file.h>
-#include <linux/fs.h>
-#include <linux/delay.h>
-#endif
-
-#include "./8192cd_cfg.h"
-
-#ifdef WIFI_HAPD
-
-#ifdef __LINUX_2_6__
-#include <linux/initrd.h>
-#include <linux/syscalls.h>
-#endif
-
-#include "./8192cd_debug.h"
-#include "./8192cd_net80211.h"
-#include "./8192cd_headers.h"
-
-#include <linux/if_arp.h>
-#include <linux/wireless.h>
-#include <net/iw_handler.h>
-#include <net80211/ieee80211.h>
-#include <net80211/ieee80211_crypto.h>
-#include <net80211/ieee80211_ioctl.h>
-
-//#define HAPD_DEBUG
-
-void void_printk(const char *fmt, ...)
-{
-	;
-}
-
-#ifdef HAPD_DEBUG
-#define HAPD_MSG	printk
-#else
-#define HAPD_MSG	void_printk
-#endif
-
-
-
-const char* ether_sprintf(const u_int8_t *mac)
-{
-	static char etherbuf[18]; 	/* XXX */
-	snprintf(etherbuf, sizeof(etherbuf), "%02x:%02x:%02x:%02x:%02x:%02x",
-		mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
-	return etherbuf;
-}
-
-static __inline__ void set_ttkeylen(struct Dot11EncryptKey *pEncryptKey, UINT8 len)
-{
-	pEncryptKey->dot11TTKeyLen = len;
-}
-
-
-static __inline__ void set_tmickeylen(struct Dot11EncryptKey *pEncryptKey, UINT8 len)
-{
-	pEncryptKey->dot11TMicKeyLen = len;
-}
-
-
-static __inline__ void set_tkip_key(struct Dot11EncryptKey *pEncryptKey, UINT8 *src)
-{
-	memcpy(pEncryptKey->dot11TTKey.skey, src, pEncryptKey->dot11TTKeyLen);
-
-	memcpy(pEncryptKey->dot11TMicKey1.skey, src + 16, pEncryptKey->dot11TMicKeyLen);
-
-	memcpy(pEncryptKey->dot11TMicKey2.skey, src + 24, pEncryptKey->dot11TMicKeyLen);
-
-	pEncryptKey->dot11TXPN48.val48 = 0;
-}
-
-
-static __inline__ void set_aes_key(struct Dot11EncryptKey *pEncryptKey, UINT8 *src)
-{
-	memcpy(pEncryptKey->dot11TTKey.skey, src, pEncryptKey->dot11TTKeyLen);
-
-	memcpy(pEncryptKey->dot11TMicKey1.skey, src, pEncryptKey->dot11TMicKeyLen);
-}
-
-
-static __inline__ void set_wep40_key(struct Dot11EncryptKey *pEncryptKey, UINT8 *src)
-{
-	memcpy(pEncryptKey->dot11TTKey.skey, src, pEncryptKey->dot11TTKeyLen);
-}
-
-
-static __inline__ void set_wep104_key(struct Dot11EncryptKey *pEncryptKey, UINT8 *src)
-{
-	memcpy(pEncryptKey->dot11TTKey.skey, src, pEncryptKey->dot11TTKeyLen);
-}
-
-
-static int HAPD_Process_Set_Port(struct net_device *dev, unsigned char *MACAddr, int PortStatus)
-{
-	struct stat_info	*pstat;
-#ifdef NETDEV_NO_PRIV
-	struct rtl8192cd_priv *priv = ((struct rtl8192cd_priv *)netdev_priv(dev))->wlan_priv;
-#else
-	struct rtl8192cd_priv	*priv = (struct rtl8192cd_priv *)dev->priv;
-#endif
-	struct wifi_mib		*pmib = priv->pmib;
-
-	HAPD_MSG("HAPD_Process_Set_Port +++ sta: %02X%02X%02X%02X%02X%02X Status %X\n",
-		MACAddr[0],MACAddr[1],MACAddr[2],
-		MACAddr[3],MACAddr[4],MACAddr[5],
-		PortStatus);
-
-	// if driver is not opened, return immediately, david
-	if (!netif_running(priv->dev))
-		return (-1);
-
-	pstat = get_stainfo(priv, MACAddr);
-
-	if ((pstat == NULL) || (!(pstat->state & WIFI_ASOC_STATE)))
-		return (-1);
-
-	if (PortStatus)
-		pstat->ieee8021x_ctrlport = PortStatus;
-	else
-		pstat->ieee8021x_ctrlport = pmib->dot118021xAuthEntry.dot118021xDefaultPort;
-
-	HAPD_MSG("HAPD_Process_Set_Port ---\n");
-
-	return 0;
-}
-
-#ifdef WIFI_WPAS
-
-static int	rtl_wpas_join(struct rtl8192cd_priv *priv, int bss_num)
-{
-	char tmpbuf[33];
-
-	if (!netif_running(priv->dev))
-		{
-			printk("WiFi driver is NOT open!!\n");
-			return -1;
-		}
-	else if (priv->ss_req_ongoing)
-		{
-			printk("Site Survey is not finished yet!!\n");
-			return -1;
-		}
-
-	memcpy((void *)&(priv->pmib->dot11Bss) ,
-		(void *)&priv->site_survey.bss_backup[bss_num] , sizeof(struct bss_desc));
-
-#ifdef WIFI_SIMPLE_CONFIG
-	//_Eric if (priv->pmib->wscEntry.wsc_enable && (priv->pmib->dot11Bss.bsstype&WIFI_WPS)) 
-	if (priv->pmib->wscEntry.wsc_enable)
-	{
-		//priv->pmib->dot11Bss.bsstype &= ~WIFI_WPS;
-		priv->wps_issue_join_req = 1;
-	}
-	else
-#endif
-	{
-		if (check_bss_encrypt(priv) == FAIL)
-		{
-			printk("Encryption mismatch!\n");
-			return -1;
-		}
-	}
-
-	if ((priv->pmib->dot11Bss.ssidlen == 0) || (priv->pmib->dot11Bss.ssid[0] == '\0')) 
-	{
-		printk("Error !! Join to a hidden AP!\n");
-		return -1;
-	}
-
-#ifdef UNIVERSAL_REPEATER
-	disable_vxd_ap(GET_VXD_PRIV(priv));
-#endif
-
-	memcpy(tmpbuf, priv->pmib->dot11Bss.ssid, priv->pmib->dot11Bss.ssidlen);
-	tmpbuf[priv->pmib->dot11Bss.ssidlen] = '\0';
-	printk("going to join bss: %s\n", tmpbuf);
-
-	memcpy(SSID2SCAN, priv->pmib->dot11Bss.ssid, priv->pmib->dot11Bss.ssidlen);
-	SSID2SCAN_LEN = priv->pmib->dot11Bss.ssidlen;
-
-	SSID_LEN = SSID2SCAN_LEN;
-	memcpy(SSID, SSID2SCAN, SSID_LEN);
-	memset(BSSID, 0, MACADDRLEN);
-
-#ifdef INCLUDE_WPA_PSK //_Eric ??
-	//if (priv->pmib->dot1180211AuthEntry.dot11EnablePSK)
-		//derivePSK(priv);
-#endif
-	priv->join_req_ongoing = 1;
-	priv->authModeRetry = 0;
-
-	//mod_timer(&priv->WPAS_timer, jiffies + 300);
-	start_clnt_join(priv);
-
-	return 0;
-}
-
-#endif
-
-
-void rtl_net80311_authmode(struct net_device *dev, int authtype, int encmode, 
-									int pskenable, int dot11802_1x)
-{
-#ifdef NETDEV_NO_PRIV
-	struct rtl8192cd_priv *priv = ((struct rtl8192cd_priv *)netdev_priv(dev))->wlan_priv;
-#else
-	struct rtl8192cd_priv	*priv = (struct rtl8192cd_priv *)dev->priv;
-#endif
-
-	HAPD_MSG("rtl_net80311_authmode +++\n");
-	HAPD_MSG("authtype=%d, encmode=%d, pskenable=%d, dot11802_1x=%d \n", authtype, encmode, pskenable, dot11802_1x);
-
-	priv->pmib->dot1180211AuthEntry.dot11AuthAlgrthm = authtype;
-	priv->pmib->dot1180211AuthEntry.dot11PrivacyAlgrthm = encmode;
-	priv->pmib->dot1180211AuthEntry.dot11EnablePSK = pskenable;
-	priv->pmib->dot118021xAuthEntry.dot118021xAlgrthm = dot11802_1x;	
-}
-
-int rtl_net80211_setparam(struct net_device *dev, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)
-{
-#ifdef NETDEV_NO_PRIV
-	struct rtl8192cd_priv *priv = ((struct rtl8192cd_priv *)netdev_priv(dev))->wlan_priv;
-#else
-	struct rtl8192cd_priv	*priv = (struct rtl8192cd_priv *)dev->priv;
-#endif
-
-	int *i = (int *) extra;
-	int param = wrqu->mode;		/* parameter id is 1st */
-	int value = 0;		/* NB: most values are TYPE_INT */
-	int ret = 0;
-
-	memcpy(&value, wrqu->name+sizeof(value), sizeof(value));
-
-	int authtype = priv->pmib->dot1180211AuthEntry.dot11AuthAlgrthm; 
-	int encmode = priv->pmib->dot1180211AuthEntry.dot11PrivacyAlgrthm;
-	int pskenable = priv->pmib->dot1180211AuthEntry.dot11EnablePSK;
-	int dot11802_1x = priv->pmib->dot118021xAuthEntry.dot118021xAlgrthm;
-
-	HAPD_MSG("rtl_net80211_setparam +++\n");
-	HAPD_MSG("rtl8192cd_net80211_ioctl, param = %d, value =%d\n", param, value);
-
-
-	switch (param) {
-		case IEEE80211_PARAM_TURBO:			/* turbo mode */
-			break;
-		case IEEE80211_PARAM_MODE:			/* phy mode (11a, 11b, etc.) */
-			break;
-		case IEEE80211_PARAM_AUTHMODE:		/* authentication mode */
-			switch (value) {
-			case IEEE80211_AUTH_NONE:
-				{//Disable
-					authtype = 0;
-					encmode = 0;
-					pskenable = 0;
-					dot11802_1x = 0;
-					rtl_net80311_authmode(dev, authtype, encmode, pskenable, dot11802_1x);
-					break;
-				}
-			case IEEE80211_AUTH_OPEN:
-				{//WEP Open
-					authtype = 0;
-					//WEP encmode depends on key length
-					//encmode = 1;
-					pskenable = 0;
-					dot11802_1x = 0;
-					rtl_net80311_authmode(dev, authtype, encmode, pskenable, dot11802_1x);
-					break;
-				}
-			case IEEE80211_AUTH_SHARED:
-				{//WEP Shared
-					authtype = 1;
-					//WEP encmode depends on key length
-					//encmode = 1;
-					pskenable = 0;
-					dot11802_1x = 0;
-					rtl_net80311_authmode(dev, authtype, encmode, pskenable, dot11802_1x);
-					break;
-				}
-			case IEEE80211_AUTH_AUTO:
-				{//WEP Auto
-					authtype = 2;
-					//WEP encmode depends on key length
-					//encmode = 1;
-					pskenable = 0;
-					dot11802_1x = 0;
-					rtl_net80311_authmode(dev, authtype, encmode, pskenable, dot11802_1x);
-					break;
-				}
-			case IEEE80211_AUTH_WPA:
-				{//WPA-PSK-AES
-				 //_Eric ?? if there is no valid passphrase ??
-				 	authtype = 2;
-					encmode = 2;
-					//_Eric pskmode (WPA 0,1,2) will be set by IEEE80211_PARAM_WPA
-					//pskenable = 1;
-					dot11802_1x = 1;
-					rtl_net80311_authmode(dev, authtype, encmode, pskenable, dot11802_1x);
-					break;
-				}
-			case IEEE80211_AUTH_8021X:
-				{
-					//8021x encmode depends on key length
-					if((encmode == _WEP_40_PRIVACY_) || (encmode == _WEP_104_PRIVACY_))
-						authtype = 2;
-					else
-						authtype = 0;
-
-					pskenable = 0;
-					dot11802_1x = 1;
-					rtl_net80311_authmode(dev, authtype, encmode, pskenable, dot11802_1x);
-					break;
-				}
-			default:
-					return -EINVAL;
-			}
-		case IEEE80211_PARAM_PROTMODE:		/* 802.11g protection */
-			break;
-		case IEEE80211_PARAM_MCASTCIPHER:		/* multicast/default cipher */
-			break;
-		case IEEE80211_PARAM_MCASTKEYLEN:		/* multicast key length */
-			break;
-		case IEEE80211_PARAM_UCASTCIPHERS:		/* unicast cipher suites */
-			/*	1. Only support AES & TKIP for WPA1&WPA2
-			  	2. Set both wpa_cipher and wpa2_cipher, because IEEE80211_PARAM_WPA will clear unused cipher mode		*/
-			HAPD_MSG("IEEE80211_PARAM_UCASTCIPHERS\n");
-
-			if(value & (1<<IEEE80211_CIPHER_WEP))
-				return -EINVAL;
-			if(value & (1<<IEEE80211_CIPHER_AES_OCB))
-				return -EINVAL;
-			if(value & (1<<IEEE80211_CIPHER_CKIP))
-				return -EINVAL;
-			if(value & (1<<IEEE80211_CIPHER_NONE))
-				return -EINVAL;
-
-			if(value & (1<<IEEE80211_CIPHER_TKIP))
-				{
-					if((!(priv->pmib->dot11BssType.net_work_type & WIRELESS_11N)) || (OPMODE & WIFI_STATION_STATE))
-						{
-							priv->pmib->dot1180211AuthEntry.dot11WPACipher |= BIT(1);
-							priv->pmib->dot1180211AuthEntry.dot11WPA2Cipher |= BIT(1);
-						}
-					else
-						return -EINVAL;
-				}
-			else
-				{
-					priv->pmib->dot1180211AuthEntry.dot11WPACipher &= ~(BIT(1));
-					priv->pmib->dot1180211AuthEntry.dot11WPA2Cipher &= ~(BIT(1));
-				}
-			
-
-			if(value & (1<<IEEE80211_CIPHER_AES_CCM))
-				{
-					priv->pmib->dot1180211AuthEntry.dot11WPACipher |= BIT(3);
-					priv->pmib->dot1180211AuthEntry.dot11WPA2Cipher |= BIT(3);			
-				}
-			else
-				{
-					priv->pmib->dot1180211AuthEntry.dot11WPACipher &= ~(BIT(3));
-					priv->pmib->dot1180211AuthEntry.dot11WPA2Cipher &= ~(BIT(3));	
-				}
-
-			priv->pmib->dot118021xAuthEntry.dot118021xAlgrthm = 1;
-			
-			return 0; //_Eric if value > BIT(8) ?
-				
-		case IEEE80211_PARAM_UCASTCIPHER:		/* unicast cipher */
-			break;
-		case IEEE80211_PARAM_UCASTKEYLEN:		/* unicast key length */
-			if(value == 5)
-				priv->pmib->dot1180211AuthEntry.dot11PrivacyAlgrthm = _WEP_40_PRIVACY_;
-			else if(value == 13)
-				priv->pmib->dot1180211AuthEntry.dot11PrivacyAlgrthm = _WEP_104_PRIVACY_;
-			else 
-				priv->pmib->dot1180211AuthEntry.dot11PrivacyAlgrthm = _NO_PRIVACY_;
-			break;
-		case IEEE80211_PARAM_WPA:			/* WPA mode (0,1,2) */
-			HAPD_MSG("IEEE80211_PARAM_WPA\n");
-			if((value & BIT(0)) && (value & BIT(1)))
-				return 0;
-			else if((value & BIT(0)))
-				{//only WPA1, so clear mib of wpa2_cipher & wpa2_psk
-					priv->pmib->dot1180211AuthEntry.dot11WPA2Cipher = 0;
-					priv->pmib->dot1180211AuthEntry.dot11EnablePSK & ~(BIT(1));
-					return 0;
-				}
-			else if((value & BIT(1)))
-				{//only WPA2, so clear mib of wpa_cipher & wps2_psk
-					priv->pmib->dot1180211AuthEntry.dot11WPACipher = 0;
-					priv->pmib->dot1180211AuthEntry.dot11EnablePSK & ~(BIT(0));
-					return 0;
-				}
-			
-		case IEEE80211_PARAM_ROAMING:			/* roaming mode */
-#ifdef WIFI_WPAS
-			if(value == IEEE80211_ROAMING_DEVICE)
-				priv->pmib->dot11StationConfigEntry.fastRoaming = 1;
-			else if(value == IEEE80211_ROAMING_MANUAL)
-				priv->pmib->dot11StationConfigEntry.fastRoaming = 0;
-			else
-				return EINVAL;
-#endif
-			break;
-		case IEEE80211_PARAM_PRIVACY:			/* privacy invoked */
-			ret =0;	//It seems useless, just return status OK for hostapd.
-			break; 
-		case IEEE80211_PARAM_COUNTERMEASURES:		/* WPA/TKIP countermeasures */
-			//_Eric ?? realtek do not have to support ??
-			break;
-		case IEEE80211_PARAM_DROPUNENCRYPTED:		/* discard unencrypted frames */
-			break;
-		case IEEE80211_PARAM_DRIVER_CAPS:		/* driver capabilities */
-			break;
-		case IEEE80211_PARAM_MACCMD:			/* MAC ACL operation */
-			break;
-		case IEEE80211_PARAM_WMM:			/* WMM mode (on, off) */
-			break;
-		case IEEE80211_PARAM_HIDESSID:		/* hide SSID mode (on, off) */
-			break;
-		case IEEE80211_PARAM_APBRIDGE:   	   	/* AP inter-sta bridging */
-			break;
-		case IEEE80211_PARAM_KEYMGTALGS:		/* key management algorithms */
-			HAPD_MSG("IEEE80211_PARAM_KEYMGTALGS\n");
-			if((0<=value) && (value<=3))
-				{
-					priv->pmib->dot1180211AuthEntry.dot11EnablePSK = value;
-					break;
-				}
-			else
-				return EINVAL;
-		case IEEE80211_PARAM_RSNCAPS:			/* RSN capabilities */
-			break;
-		case IEEE80211_PARAM_INACT:			/* station inactivity timeout */
-			break;
-		case IEEE80211_PARAM_INACT_AUTH:		/* station auth inact timeout */
-			break;
-		case IEEE80211_PARAM_INACT_INIT:		/* station init inact timeout */
-			break;
-		case IEEE80211_PARAM_ABOLT:			/* Atheros Adv. Capabilities */
-			break;
-		case IEEE80211_PARAM_DTIM_PERIOD:		/* DTIM period (beacons) */
-			break;
-		case IEEE80211_PARAM_BEACON_INTERVAL:		/* beacon interval (ms) */
-			break;
-		case IEEE80211_PARAM_DOTH:			/* 11.h is on/off */
-			break;
-		case IEEE80211_PARAM_PWRTARGET:		/* Current Channel Pwr Constraint */
-			break;
-		case IEEE80211_PARAM_GENREASSOC:		/* Generate a reassociation request */
-			break;
-		case IEEE80211_PARAM_COMPRESSION:		/* compression */
-			break;
-		case IEEE80211_PARAM_FF:			/* fast frames support  */
-			break;
-		case IEEE80211_PARAM_XR:			/* XR support */
-			break;
-		case IEEE80211_PARAM_BURST:			/* burst mode */
-			break;
-		case IEEE80211_PARAM_PUREG:			/* pure 11g (no 11b stations) */
-			break;
-		case IEEE80211_PARAM_AR:			/* AR support */
-			break;
-		case IEEE80211_PARAM_WDS:			/* Enable 4 address processing */
-			break;
-		case IEEE80211_PARAM_BGSCAN:			/* bg scanning (on, off) */
-			break;
-		case IEEE80211_PARAM_BGSCAN_IDLE:		/* bg scan idle threshold */
-			break;
-		case IEEE80211_PARAM_BGSCAN_INTERVAL:		/* bg scan interval */
-			break;
-		case IEEE80211_PARAM_MCAST_RATE:		/* Multicast Tx Rate */
-			break;
-		case IEEE80211_PARAM_COVERAGE_CLASS:		/* coverage class */
-			break;
-		case IEEE80211_PARAM_COUNTRY_IE:		/* enable country IE */
-			break;
-		case IEEE80211_PARAM_SCANVALID:		/* scan cache valid threshold */
-			break;
-		case IEEE80211_PARAM_ROAM_RSSI_11A:		/* rssi threshold in 11a */
-			break;
-		case IEEE80211_PARAM_ROAM_RSSI_11B:		/* rssi threshold in 11b */
-			break;
-		case IEEE80211_PARAM_ROAM_RSSI_11G:		/* rssi threshold in 11g */
-			break;
-		case IEEE80211_PARAM_ROAM_RATE_11A:		/* tx rate threshold in 11a */
-			break;
-		case IEEE80211_PARAM_ROAM_RATE_11B:		/* tx rate threshold in 11b */
-			break;
-		case IEEE80211_PARAM_ROAM_RATE_11G:		/* tx rate threshold in 11g */
-			break;
-		case IEEE80211_PARAM_UAPSDINFO:		/* value for qos info field */
-			break;
-		case IEEE80211_PARAM_SLEEP:			/* force sleep/wake */
-			break;
-		case IEEE80211_PARAM_QOSNULL:			/* force sleep/wake */
-			break;
-		case IEEE80211_PARAM_PSPOLL:			/* force ps-poll generation (sta only) */
-			break;
-		case IEEE80211_PARAM_EOSPDROP:		/* force uapsd EOSP drop (ap only) */
-			break;
-		case IEEE80211_PARAM_MARKDFS:			/* mark a dfs interference channel when found */
-			break;
-		case IEEE80211_PARAM_REGCLASS:		/* enable regclass ids in country IE */
-			break;
-		case IEEE80211_PARAM_DROPUNENC_EAPOL:		/* drop unencrypted eapol frames */
-			break;
-	 	case IEEE80211_PARAM_SHPREAMBLE:		/* Short Preamble */
-			break;
-			
-	}
-
-	HAPD_MSG("rtl_net80211_setparam ---\n");
-	return ret;
-
-}
-
-/*
-Management frame type to which application IE is added 
-enum {
-	IEEE80211_APPIE_FRAME_BEACON		= 0,
-	IEEE80211_APPIE_FRAME_PROBE_REQ		= 1,
-	IEEE80211_APPIE_FRAME_PROBE_RESP	= 2,
-	IEEE80211_APPIE_FRAME_ASSOC_REQ		= 3,
-	IEEE80211_APPIE_FRAME_ASSOC_RESP	= 4,
-	IEEE80211_APPIE_NUM_OF_FRAME		= 5
-};
-*/
-
-int rtl_net80211_setappiebuf(struct net_device *dev, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)
-{
-#ifdef NETDEV_NO_PRIV
-	struct rtl8192cd_priv *priv = ((struct rtl8192cd_priv *)netdev_priv(dev))->wlan_priv;
-#else
-	struct rtl8192cd_priv	*priv = (struct rtl8192cd_priv *)dev->priv;
-#endif
-	struct ieee80211req_getset_appiebuf * ie = (struct ieee80211req_getset_appiebuf *)wrqu->data.pointer;
-	int ret = 0;
-
-	HAPD_MSG("rtl_net80211_setappiebuf +++\n");
-	HAPD_MSG("frametype =%d, iebuflen=%d \n", ie->app_frmtype, ie->app_buflen);
-
-	//_Eric ???? hostapd has no interface to set wsc_enable.
-
-	if((ie->app_buflen == 0) && (ie->app_frmtype != IEEE80211_APPIE_FRAME_ASSOC_RESP))
-		priv->pmib->wscEntry.wsc_enable = 0;
-	else if(ie->app_buflen <= 256)
-		priv->pmib->wscEntry.wsc_enable = 2; //Work as AP
-	else 
-		return -EINVAL;
-
-	if (ie->app_frmtype == IEEE80211_APPIE_FRAME_BEACON) {
-		HAPD_MSG("WSC: set beacon IE\n");
-		priv->pmib->wscEntry.beacon_ielen = ie->app_buflen;
-		memcpy((void *)priv->pmib->wscEntry.beacon_ie, ie->app_buf, ie->app_buflen);
-	}
-	else if (ie->app_frmtype == IEEE80211_APPIE_FRAME_PROBE_RESP) {
-		HAPD_MSG("WSC: set probe response IE\n");
-		priv->pmib->wscEntry.probe_rsp_ielen = ie->app_buflen;
-		memcpy((void *)priv->pmib->wscEntry.probe_rsp_ie, ie->app_buf, ie->app_buflen);
-	}
-	else if (ie->app_frmtype == IEEE80211_APPIE_FRAME_ASSOC_RESP) {
-		HAPD_MSG("WSC: set association response IE\n");
-		priv->pmib->wscEntry.assoc_ielen = ie->app_buflen;
-		memcpy((void *)priv->pmib->wscEntry.assoc_ie, ie->app_buf, ie->app_buflen);
-	}
-#ifdef WIFI_WPAS
-	else if (ie->app_frmtype == IEEE80211_APPIE_FRAME_PROBE_REQ) {
-		HAPD_MSG("WSC: set probe request IE\n");
-		priv->pmib->wscEntry.probe_req_ielen = ie->app_buflen;
-		memcpy((void *)priv->pmib->wscEntry.probe_req_ie, ie->app_buf, ie->app_buflen);
-	}
-#endif
-	else
-		return -EINVAL;
-
-
-	HAPD_MSG("rtl_net80211_setappiebuf ---\n");
-	return ret;
-
-}
-
-
-#ifdef WIFI_WPAS
-
-int rtl_net80211_setoptie(struct net_device *dev, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)
-{
-#ifdef NETDEV_NO_PRIV
-	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *)netdev_priv(dev);
-#else
-	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *)dev->priv;
-#endif
-	WPAS_ASSOCIATION_INFO Assoc_Info;
-
-//Check if WPS IE
-	UINT8 WSC_IE_OUI[4] = {0x00, 0x50, 0xf2, 0x04};
-	int x;
-	unsigned char *ie = (unsigned char *)wrqu->data.pointer;
-
-	if( ie[0] == _WPS_IE_)
-		if (!memcmp(ie+2, WSC_IE_OUI, 4)) 
-			{
-				priv->pmib->wscEntry.assoc_ielen = wrqu->data.length;
-				memcpy((void *)priv->pmib->wscEntry.assoc_ie, wrqu->data.pointer, wrqu->data.length);
-				priv->pmib->wscEntry.wsc_enable = 1;
-
-				return 0;
-			}
-
-	priv->pmib->wscEntry.wsc_enable = 0;
-
-	memset(priv->pmib->dot11RsnIE.rsnie, 0x0, 128);
-	memcpy(priv->pmib->dot11RsnIE.rsnie, wrqu->data.pointer, wrqu->data.length);
-	priv->pmib->dot11RsnIE.rsnielen = wrqu->data.length;
-	
-	memset((void *)&Assoc_Info, 0, sizeof(struct _WPAS_ASSOCIATION_INFO));
-	Assoc_Info.ReqIELen = priv->pmib->dot11RsnIE.rsnie[1]+ 2;
-	memcpy(Assoc_Info.ReqIE, priv->pmib->dot11RsnIE.rsnie, Assoc_Info.ReqIELen);
-	//event_indicate_wpas(priv, NULL, WPAS_ASSOC_INFO, (UINT8 *)&Assoc_Info);
-
-	return 0;
-	
-}
-
-#endif
-
-int rtl_net80211_setmlme(struct net_device *dev, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)
-{
-#ifdef NETDEV_NO_PRIV
-	struct rtl8192cd_priv *priv = ((struct rtl8192cd_priv *)netdev_priv(dev))->wlan_priv;
-#else
-	struct rtl8192cd_priv	*priv = (struct rtl8192cd_priv *)dev->priv;
-#endif
-	struct ieee80211req_mlme *mlme = (struct ieee80211req_key *)wrqu->data.pointer;
-	struct stat_info *pstat = get_stainfo(priv, mlme->im_macaddr);
-			
-	int ret = 0;
-
-	HAPD_MSG("rtl_net80211_setmlme +++\n");
-	HAPD_MSG("auth_state =%d, mac = 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n"
-			, mlme->im_op, mlme->im_macaddr[0], mlme->im_macaddr[1], mlme->im_macaddr[2], 
-				mlme->im_macaddr[3], mlme->im_macaddr[4], mlme->im_macaddr[5]);
-
-	//_Eric ????
-
-	if(mlme->im_op == IEEE80211_MLME_AUTHORIZE)
-		{
-				
-			if (pstat == NULL){
-				pstat = alloc_stainfo(priv, mlme->im_macaddr, -1);
-				if (pstat == NULL) {
-					printk("Exceed the upper limit of supported clients...\n");
-					return -1;
-				}
-				init_stainfo(priv, pstat);
-				pstat->state |= (WIFI_AUTH_SUCCESS | WIFI_ASOC_STATE);
-			pstat->expire_to = priv->assoc_to;
-				list_add_tail(&(pstat->asoc_list), &(priv->asoc_list));	
-			}
-
-			HAPD_Process_Set_Port(dev, mlme->im_macaddr ,DOT11_PortStatus_Authorized);
-
-		}
-	else if(mlme->im_op == IEEE80211_MLME_UNAUTHORIZE)
-		{	
-			if (pstat == NULL)
-			return -EINVAL;
-
-			//pstat->state |= WIFI_AUTH_NULL;
-
-			HAPD_Process_Set_Port(dev, mlme->im_macaddr ,DOT11_PortStatus_Authorized);
-
-		}
-	else if(mlme->im_op == IEEE80211_MLME_DISASSOC)
-		{	
-			if (pstat == NULL)
-			return -EINVAL;
-
-#ifdef WIFI_WPAS
-						
-			if(OPMODE & WIFI_STATION_STATE)
-			{
-				HAPD_MSG("An AP is disconnected by WPAS \n");
-				issue_disassoc(priv, mlme->im_macaddr, _RSON_UNSPECIFIED_);
-			
-				if (pstat->expire_to > 0)
-				{
-					cnt_assoc_num(priv, pstat, DECREASE, (char *)__FUNCTION__);
-					check_sta_characteristic(priv, pstat, DECREASE);
-				}
-			
-				free_stainfo(priv, pstat);
-				memset(&priv->pmib->dot11Bss, 0, sizeof(struct bss_desc));
-				memset(priv->pmib->dot11StationConfigEntry.dot11Bssid, 0, MACADDRLEN);
-				memset(priv->pmib->dot11StationConfigEntry.dot11DesiredSSID, 0, sizeof(priv->pmib->dot11StationConfigEntry.dot11DesiredSSID));
-				priv->pmib->dot11StationConfigEntry.dot11DesiredSSIDLen = 0;
-				memset(priv->pmib->dot11StationConfigEntry.dot11DefaultSSID, 0, sizeof(priv->pmib->dot11StationConfigEntry.dot11DesiredSSID));
-				priv->pmib->dot11StationConfigEntry.dot11DefaultSSIDLen = 0;
-				memset(priv->pmib->dot11StationConfigEntry.dot11SSIDtoScan, 0, sizeof(priv->pmib->dot11StationConfigEntry.dot11SSIDtoScan));
-				priv->pmib->dot11StationConfigEntry.dot11SSIDtoScanLen = 0;
-				memset(priv->pmib->dot11StationConfigEntry.dot11DesiredBssid, 0, 6);
-
-				priv->wpas_manual_assoc = 1; //_Eric ??  when to let driver auto-connect ??
-
-				priv->join_res = STATE_Sta_No_Bss;
-				pstat->state &= (~WIFI_ASOC_STATE);
-				return ret; 
-			}
-					
-#endif
-
-
-			if (!list_empty(&pstat->asoc_list))
-			{
-				list_del_init(&pstat->asoc_list);
-				if (pstat->expire_to > 0)
-				{
-					cnt_assoc_num(priv, pstat, DECREASE, (char *)__FUNCTION__);
-					check_sta_characteristic(priv, pstat, DECREASE);
-				}
-			}
-
-			// Need change state back to autehnticated
-			release_stainfo(priv, pstat);
-			init_stainfo(priv, pstat);
-			pstat->state |= WIFI_AUTH_SUCCESS;
-			pstat->expire_to = priv->assoc_to;
-			list_add_tail(&(pstat->auth_list), &(priv->auth_list));
-
-		}
-	else if(mlme->im_op == IEEE80211_MLME_DEAUTH)
-		{
-			unsigned char	MULTICAST_ADD[6]={0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
-
-			if(!memcmp(mlme->im_macaddr, MULTICAST_ADD, 6)) //_Eric ??How to free all stainfo??
-				return 0;
-			
-			if (pstat == NULL)
-			return -EINVAL;
-			
-			if (!list_empty(&pstat->asoc_list))
-			{
-				list_del_init(&pstat->asoc_list);
-				if (pstat->expire_to > 0)
-				{
-					cnt_assoc_num(priv, pstat, DECREASE, (char *)__FUNCTION__);
-					check_sta_characteristic(priv, pstat, DECREASE);
-				}
-			}
-			
-			release_stainfo(priv, pstat);
-
-		}
-#ifdef WIFI_WPAS
-	else if(mlme->im_op == IEEE80211_MLME_ASSOC)
-		{
-			int ix = 0, found = 0;
-
-			if((OPMODE & WIFI_STATION_STATE) == 0)
-				{
-					HAPD_MSG("NOT in Client Mode, can NOT Associate !!!\n");
-					return -1;
-				}
-			
-			for(ix = 0 ; ix < priv->site_survey.count_backup ; ix++) //_Eric ?? will bss_backup be cleaned?? -> Not found in  codes
-			{	
-				if(!memcmp(priv->site_survey.bss_backup[ix].bssid , mlme->im_macaddr, 6))
-				{
-					found = 1;
-					break;
-				}
-			}
-
-			if(found == 0)
-			{	
-				printk("BSSID NOT Found !!\n");
-				return -EINVAL;
-			}
-			else
-				ret = rtl_wpas_join(priv, ix);
-
-			if(ret != 0)
-				printk("rtl_wpas_join Failed !!\n");
-		
-		}
-#endif
-	else
-		{
-			HAPD_MSG("unknown auth_state !!!\n");
-			return -EINVAL;
-		}
-		
-	HAPD_MSG("rtl_net80211_setmlme ---\n");
-	return ret;
-
-
-}
-
-
-int rtl_net80211_setkey(struct net_device *dev, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)
-{
-#ifdef NETDEV_NO_PRIV
-	struct rtl8192cd_priv *priv = ((struct rtl8192cd_priv *)netdev_priv(dev))->wlan_priv;
-#else
-	struct rtl8192cd_priv	*priv = (struct rtl8192cd_priv *)dev->priv;
-#endif
-	struct ieee80211req_key *wk = (struct ieee80211req_key *)wrqu->data.pointer;
-	struct wifi_mib	*pmib = priv->pmib;
-	struct Dot11EncryptKey	*pEncryptKey = NULL;
-	struct stat_info	*pstat = NULL;
-	unsigned char	MULTICAST_ADD[6]={0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
-#ifdef WIFI_WPAS
-	unsigned char	GROUP_ADD[6]={0x0,0x0,0x0,0x0,0x0,0x0};
-#endif
-	int cipher =0;
-	int retVal = 0;
-	int group_key = 0;
-
-	HAPD_MSG("rtl_net80211_setkey +++\n");
-
-
-	HAPD_MSG("keyid = %d, mac = 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n"
-			, wk->ik_keyix, wk->ik_macaddr[0], wk->ik_macaddr[1], wk->ik_macaddr[2], 
-				wk->ik_macaddr[3], wk->ik_macaddr[4], wk->ik_macaddr[5]);
-	HAPD_MSG("type = 0x%x, flags = 0x%x, keylen = 0x%x \n"
-			, wk->ik_type, wk->ik_flags, wk->ik_keylen);
-
-
-	//check if the interface is down
-	if (!netif_running(priv->dev))
-	{	
-		if(wk->ik_type == IEEE80211_CIPHER_WEP)
-		{
-			HAPD_MSG("set WEP Key in driver DOWN\n");
-			memcpy(&priv->pmib->dot11DefaultKeysTable.keytype[wk->ik_keyix].skey[0], wk->ik_keydata, wk->ik_keylen);
-			return 0;
-		}
-
-		HAPD_MSG("\nFail: interface not opened\n");
-		return 0;
-	}
-
-	if(!memcmp(wk->ik_macaddr, MULTICAST_ADD, 6))
-		group_key = 1;
-
-#ifdef WIFI_WPAS //_Eric ?? if oxff not group addr in wpas ??
-	if(OPMODE & WIFI_STATION_STATE)
-		if(!memcmp(wk->ik_macaddr, GROUP_ADD, 6))
-			group_key = 1;
-#endif
-
-	if(wk->ik_type == IEEE80211_CIPHER_WEP)
-		{
-
-#ifdef WIFI_WPAS
-		   if(OPMODE & WIFI_STATION_STATE)
-		   	if(priv->pmib->dot118021xAuthEntry.dot118021xAlgrthm == 0)
-		   	{
-		   		memcpy(&priv->pmib->dot11DefaultKeysTable.keytype[wk->ik_keyix].skey[0], wk->ik_keydata, wk->ik_keylen);
-				return 0;
-		   	}
-#endif
-		   if(priv->pmib->dot1180211AuthEntry.dot11PrivacyAlgrthm == _WEP_40_PRIVACY_)
-		   	cipher = (DOT11_ENC_WEP40);
-		   else if(priv->pmib->dot1180211AuthEntry.dot11PrivacyAlgrthm == _WEP_104_PRIVACY_)
-		   	cipher = (DOT11_ENC_WEP104);
-		   else
-		   	return -EINVAL;
-		}
-	else if(wk->ik_type == IEEE80211_CIPHER_TKIP)
-		cipher = (DOT11_ENC_TKIP);
-	else if(wk->ik_type == IEEE80211_CIPHER_AES_CCM)
-		cipher = (DOT11_ENC_CCMP);
-	else
-		{
-			HAPD_MSG("unknown encAlg !!!\n");
-			return -EINVAL;
-		}
-
-	//_Eric ?? if call DOT11_Process_Set_Key
-	//CamAddOneEntry(priv, wk->ik_macaddr, wk->ik_keyix, cipher, 0, wk->ik_keydata);
-
-	if(group_key)
-	{
-		int set_gkey_to_cam = 1;
-		HAPD_MSG("set group key !!\n");
-
-#ifdef UNIVERSAL_REPEATER
-		if (IS_VXD_INTERFACE(priv))
-			set_gkey_to_cam = 0;
-		else {
-			if (IS_ROOT_INTERFACE(priv)) {
-				if (IS_DRV_OPEN(GET_VXD_PRIV(priv)))
-					set_gkey_to_cam = 0;
-			}
-		}
-#endif
-
-#ifdef MBSSID
-		if (GET_ROOT(priv)->pmib->miscEntry.vap_enable)
-		{
-			// No matter root or vap, don't set key to cam if vap is enabled.
-			set_gkey_to_cam = 0;
-		}
-#endif
-
-#ifdef CONFIG_RTK_MESH
-		//modify by Joule for SECURITY
-		if (dev == priv->mesh_dev)
-		{
-			pmib->dot11sKeysTable.dot11Privacy = cipher;
-			pEncryptKey = &pmib->dot11sKeysTable.dot11EncryptKey;
-			pmib->dot11sKeysTable.keyid = (UINT)wk->ik_keyix;
-		}
-		else
-#endif
-		{
-			pmib->dot11GroupKeysTable.dot11Privacy = cipher;
-			pEncryptKey = &pmib->dot11GroupKeysTable.dot11EncryptKey;
-			pmib->dot11GroupKeysTable.keyid = (UINT)wk->ik_keyix;
-		}
-
-		switch(cipher)
-		{
-		case DOT11_ENC_TKIP:
-			set_ttkeylen(pEncryptKey, 16);
-			set_tmickeylen(pEncryptKey, 8);
-			set_tkip_key(pEncryptKey, wk->ik_keydata);
-
-			HAPD_MSG("going to set TKIP group key! id %X\n", (UINT)wk->ik_keyix);
-			if (!SWCRYPTO) {
-				if (set_gkey_to_cam)
-				{
-					retVal = CamDeleteOneEntry(priv, MULTICAST_ADD, wk->ik_keyix, 0);
-					if (retVal) {
-						priv->pshare->CamEntryOccupied--;
-						pmib->dot11GroupKeysTable.keyInCam = FALSE;
-					}
-					retVal = CamAddOneEntry(priv, MULTICAST_ADD, wk->ik_keyix, DOT11_ENC_TKIP<<2, 0, wk->ik_keydata);
-					if (retVal) {
-						priv->pshare->CamEntryOccupied++;
-						pmib->dot11GroupKeysTable.keyInCam = TRUE;
-					}
-				}
-			}
-			break;
-
-		case DOT11_ENC_WEP40:
-			set_ttkeylen(pEncryptKey, 5);
-			set_tmickeylen(pEncryptKey, 0);
-			set_wep40_key(pEncryptKey, wk->ik_keydata);
-
-			HAPD_MSG("going to set WEP40 group key!\n");
-			if (!SWCRYPTO) {
-				if (set_gkey_to_cam)
-				{
-					retVal = CamDeleteOneEntry(priv, MULTICAST_ADD, wk->ik_keyix, 0);
-					if (retVal) {
-						priv->pshare->CamEntryOccupied--;
-						pmib->dot11GroupKeysTable.keyInCam = FALSE;
-					}
-					retVal = CamAddOneEntry(priv, MULTICAST_ADD, wk->ik_keyix, DOT11_ENC_WEP40<<2, 0, wk->ik_keydata);
-					if (retVal) {
-						priv->pshare->CamEntryOccupied++;
-						pmib->dot11GroupKeysTable.keyInCam = TRUE;
-					}
-				}
-			}
-			break;
-
-		case DOT11_ENC_WEP104:
-			set_ttkeylen(pEncryptKey, 13);
-			set_tmickeylen(pEncryptKey, 0);
-			set_wep104_key(pEncryptKey, wk->ik_keydata);
-
-			HAPD_MSG("going to set WEP104 group key!\n");
-			if (!SWCRYPTO) {
-				if (set_gkey_to_cam)
-				{
-					retVal = CamDeleteOneEntry(priv, MULTICAST_ADD, wk->ik_keyix, 0);
-					if (retVal) {
-						priv->pshare->CamEntryOccupied--;
-						pmib->dot11GroupKeysTable.keyInCam = FALSE;
-					}
-					retVal = CamAddOneEntry(priv, MULTICAST_ADD, wk->ik_keyix, DOT11_ENC_WEP104<<2, 0, wk->ik_keydata);
-					if (retVal) {
-						priv->pshare->CamEntryOccupied++;
-						pmib->dot11GroupKeysTable.keyInCam = TRUE;
-					}
-				}
-			}
-			break;
-
-		case DOT11_ENC_CCMP:
-			set_ttkeylen(pEncryptKey, 16);
-			set_tmickeylen(pEncryptKey, 16);
-			set_aes_key(pEncryptKey, wk->ik_keydata);
-
-			HAPD_MSG("going to set CCMP-AES group key!\n");
-#ifdef CONFIG_RTK_MESH
-			if (dev == priv->mesh_dev)
-				pmib->dot11sKeysTable.keyInCam = TRUE;		// keyInCam means key in driver
-			else
-#endif
-			if (!SWCRYPTO) {
-				if (set_gkey_to_cam)
-				{
-					retVal = CamDeleteOneEntry(priv, MULTICAST_ADD, wk->ik_keyix, 0);
-					if (retVal) {
-						priv->pshare->CamEntryOccupied--;
-						pmib->dot11GroupKeysTable.keyInCam = FALSE;
-					}
-					retVal = CamAddOneEntry(priv, MULTICAST_ADD, wk->ik_keyix, DOT11_ENC_CCMP<<2, 0, wk->ik_keydata);
-					if (retVal) {
-						priv->pshare->CamEntryOccupied++;
-						pmib->dot11GroupKeysTable.keyInCam = TRUE;
-					}
-				}
-			}
-			break;
-
-		case DOT11_ENC_NONE:
-		default:
-			HAPD_MSG("No group encryption key is set!\n");
-			set_ttkeylen(pEncryptKey, 0);
-			set_tmickeylen(pEncryptKey, 0);
-			break;
-		}
-	}
-	else
-	{
-		pstat = get_stainfo(priv, wk->ik_macaddr);
-		if (pstat == NULL) {
-			DEBUG_ERR("Set key failed, invalid mac address: %02x%02x%02x%02x%02x%02x\n",
-				wk->ik_macaddr[0], wk->ik_macaddr[1], wk->ik_macaddr[2], wk->ik_macaddr[3],
-				wk->ik_macaddr[4], wk->ik_macaddr[5]);
-			return (-1);
-		}
-
-		pstat->dot11KeyMapping.dot11Privacy = cipher;
-		pEncryptKey = &pstat->dot11KeyMapping.dot11EncryptKey;
-		pstat->keyid = wk->ik_keyix;
-
-#if defined(__DRAYTEK_OS__) && defined(WDS)
-		if (pstat->state & WIFI_WDS)
-			priv->pmib->dot11WdsInfo.wdsPrivacy = cipher;
-#endif
-
-		switch(cipher)
-		{
-		case DOT11_ENC_TKIP:
-			set_ttkeylen(pEncryptKey, 16);
-			set_tmickeylen(pEncryptKey, 8);
-			set_tkip_key(pEncryptKey, wk->ik_keydata);
-
-			HAPD_MSG("going to set TKIP Unicast key for sta %02X%02X%02X%02X%02X%02X, id=%d\n",
-				wk->ik_macaddr[0], wk->ik_macaddr[1], wk->ik_macaddr[2],
-				wk->ik_macaddr[3], wk->ik_macaddr[4], wk->ik_macaddr[5], pstat->keyid);
-			if (!SWCRYPTO) {
-				retVal = CamDeleteOneEntry(priv, wk->ik_macaddr, wk->ik_keyix, 0);
-				if (retVal) {
-					priv->pshare->CamEntryOccupied--;
-					if (pstat)	pstat->dot11KeyMapping.keyInCam = FALSE;
-				}
-				retVal = CamAddOneEntry(priv, wk->ik_macaddr, wk->ik_keyix, DOT11_ENC_TKIP<<2, 0, wk->ik_keydata);
-				if (retVal) {
-					priv->pshare->CamEntryOccupied++;
-					if (pstat)	pstat->dot11KeyMapping.keyInCam = TRUE;
-				}
-				else {
-					if (pstat->aggre_mthd != AGGRE_MTHD_NONE)
-						pstat->aggre_mthd = AGGRE_MTHD_NONE;
-				}
-			}
-			break;
-
-		case DOT11_ENC_WEP40:
-			set_ttkeylen(pEncryptKey, 5);
-			set_tmickeylen(pEncryptKey, 0);
-			set_wep40_key(pEncryptKey, wk->ik_keydata);
-
-			HAPD_MSG("going to set WEP40 unicast key for sta %02X%02X%02X%02X%02X%02X, id=%d\n",
-				wk->ik_macaddr[0], wk->ik_macaddr[1], wk->ik_macaddr[2],
-				wk->ik_macaddr[3], wk->ik_macaddr[4], wk->ik_macaddr[5], pstat->keyid);
-			if (!SWCRYPTO) {
-				retVal = CamDeleteOneEntry(priv, wk->ik_macaddr, wk->ik_keyix, 0);
-				if (retVal) {
-					priv->pshare->CamEntryOccupied--;
-					if (pstat)	pstat->dot11KeyMapping.keyInCam = FALSE;
-				}
-				retVal = CamAddOneEntry(priv, wk->ik_macaddr, wk->ik_keyix, DOT11_ENC_WEP40<<2, 0, wk->ik_keydata);
-				if (retVal) {
-					priv->pshare->CamEntryOccupied++;
-					if (pstat)	pstat->dot11KeyMapping.keyInCam = TRUE;
-				}
-				else {
-					if (pstat->aggre_mthd != AGGRE_MTHD_NONE)
-						pstat->aggre_mthd = AGGRE_MTHD_NONE;
-				}
-			}
-			break;
-
-		case DOT11_ENC_WEP104:
-			set_ttkeylen(pEncryptKey, 13);
-			set_tmickeylen(pEncryptKey, 0);
-			set_wep104_key(pEncryptKey, wk->ik_keydata);
-
-			HAPD_MSG("going to set WEP104 unicast key for sta %02X%02X%02X%02X%02X%02X, id=%d\n",
-				wk->ik_macaddr[0], wk->ik_macaddr[1], wk->ik_macaddr[2],
-				wk->ik_macaddr[3], wk->ik_macaddr[4], wk->ik_macaddr[5], pstat->keyid);
-			if (!SWCRYPTO) {
-				retVal = CamDeleteOneEntry(priv, wk->ik_macaddr, wk->ik_keyix, 0);
-				if (retVal) {
-					priv->pshare->CamEntryOccupied--;
-					if (pstat)	pstat->dot11KeyMapping.keyInCam = FALSE;
-				}
-				retVal = CamAddOneEntry(priv, wk->ik_macaddr, wk->ik_keyix, DOT11_ENC_WEP104<<2, 0, wk->ik_keydata);
-				if (retVal) {
-					priv->pshare->CamEntryOccupied++;
-					if (pstat)	pstat->dot11KeyMapping.keyInCam = TRUE;
-				}
-				else {
-					if (pstat->aggre_mthd != AGGRE_MTHD_NONE)
-						pstat->aggre_mthd = AGGRE_MTHD_NONE;
-				}
-			}
-			break;
-
-		case DOT11_ENC_CCMP:
-			set_ttkeylen(pEncryptKey, 16);
-			set_tmickeylen(pEncryptKey, 16);
-			set_aes_key(pEncryptKey, wk->ik_keydata);
-
-			HAPD_MSG("going to set CCMP-AES unicast key for sta %02X%02X%02X%02X%02X%02X, id=%d\n",
-				wk->ik_macaddr[0], wk->ik_macaddr[1], wk->ik_macaddr[2],
-				wk->ik_macaddr[3], wk->ik_macaddr[4], wk->ik_macaddr[5], pstat->keyid);
-			if (!SWCRYPTO) {
-				retVal = CamDeleteOneEntry(priv, wk->ik_macaddr, wk->ik_keyix, 0);
-				if (retVal) {
-					priv->pshare->CamEntryOccupied--;
-					if (pstat)	pstat->dot11KeyMapping.keyInCam = FALSE;
-				}
-				retVal = CamAddOneEntry(priv, wk->ik_macaddr, wk->ik_keyix, DOT11_ENC_CCMP<<2, 0, wk->ik_keydata);
-				if (retVal) {
-					HAPD_MSG("CamAddOneEntry of CCMP OK\n");
-					priv->pshare->CamEntryOccupied++;
-					if (pstat)	pstat->dot11KeyMapping.keyInCam = TRUE;
-					assign_aggre_mthod(priv, pstat);
-				}
-				else {
-					HAPD_MSG("CamAddOneEntry of CCMP FAIL\n");
-					if (pstat->aggre_mthd != AGGRE_MTHD_NONE)
-						pstat->aggre_mthd = AGGRE_MTHD_NONE;
-				}
-			}
-			break;
-
-		case DOT11_ENC_NONE:
-		default:
-			DEBUG_ERR("No pairewise encryption key is set!\n");
-			set_ttkeylen(pEncryptKey, 0);
-			set_tmickeylen(pEncryptKey, 0);
-			break;
-		}
-	}
-
-
-	HAPD_MSG("rtl_net80211_setkey ---\n");
-	
-	return 0;
-
-
-
-}
-
-int rtl_net80211_delkey(struct net_device *dev, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)
-{
-#ifdef NETDEV_NO_PRIV
-	struct rtl8192cd_priv *priv = ((struct rtl8192cd_priv *)netdev_priv(dev))->wlan_priv;
-#else
-	struct rtl8192cd_priv	*priv = (struct rtl8192cd_priv *)dev->priv;
-#endif
-	struct ieee80211req_del_key *wk = (struct ieee80211req_del_key *)wrqu->name;
-	struct stat_info	*pstat = NULL;
-	struct wifi_mib 	*pmib = priv->pmib;
-
-	unsigned char MULTICAST_ADD[6]={0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
-	int ret = 0;
-
-	//check if the interface is down
-	if (!netif_running(priv->dev))
-	{
-		HAPD_MSG("\nFail: interface not opened\n");
-		return 0;
-	}
-
-	HAPD_MSG("rtl_net80211_delkey +++ \n");
-	HAPD_MSG("keyid = %d, mac = 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n"
-			, wk->idk_keyix, wk->idk_macaddr[0], wk->idk_macaddr[1], wk->idk_macaddr[2], 
-				wk->idk_macaddr[3], wk->idk_macaddr[4], wk->idk_macaddr[5]);
-
-	if(!memcmp(wk->idk_macaddr, "\x00\x00\x00\x00\x00\x00", 6))
-		{
-			HAPD_MSG("reset ALL key !!!!!\n");
-			CamResetAllEntry(priv);
-		}
-
-	if (!memcmp(wk->idk_macaddr, MULTICAST_ADD, 6))
-	{
-		pmib->dot11GroupKeysTable.dot11EncryptKey.dot11TTKeyLen = 0;
-		pmib->dot11GroupKeysTable.dot11EncryptKey.dot11TMicKeyLen = 0;
-
-		HAPD_MSG("Delete Group Key\n");
-		if (CamDeleteOneEntry(priv, MULTICAST_ADD, 1, 0))
-			priv->pshare->CamEntryOccupied--;
-		#if defined(CONFIG_RTL_HW_WAPI_SUPPORT)
-		if (CamDeleteOneEntry(priv, MULTICAST_ADD, 1, 0))
-			priv->pshare->CamEntryOccupied--;
-		#endif
-
-	}
-	else
-	{
-		pstat = get_stainfo(priv, (UINT8 *)wk->idk_macaddr);
-		if (pstat == NULL)
-			return (-1);
-
-		pstat->dot11KeyMapping.dot11EncryptKey.dot11TTKeyLen = 0;
-		pstat->dot11KeyMapping.dot11EncryptKey.dot11TMicKeyLen = 0;
-
-		HAPD_MSG("Delete Unicast Key\n");
-		if (pstat->dot11KeyMapping.keyInCam == TRUE) {
-			if (CamDeleteOneEntry(priv, (unsigned char *)wk->idk_macaddr, 0, 0)) {
-				priv->pshare->CamEntryOccupied--;
-				if (pstat)	pstat->dot11KeyMapping.keyInCam = FALSE;
-			}
-			#if defined(CONFIG_RTL_HW_WAPI_SUPPORT)
-			if (CamDeleteOneEntry(priv, (unsigned char *)wk->idk_macaddr, 0, 0)) {
-				priv->pshare->CamEntryOccupied--;
-				if (pstat)	pstat->dot11KeyMapping.keyInCam = FALSE;
-			}
-			#endif
-		}
-	}
-
-	HAPD_MSG("rtl_net80211_delkey --- \n");
-
-	return ret;
-
-
-}
-
-int rtl_net80211_getwpaie(struct net_device *dev, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)
-{
-#ifdef NETDEV_NO_PRIV
-	struct rtl8192cd_priv *priv = ((struct rtl8192cd_priv *)netdev_priv(dev))->wlan_priv;
-#else
-	struct rtl8192cd_priv	*priv = (struct rtl8192cd_priv *)dev->priv;
-#endif
-	struct ieee80211req_wpaie *ie = (struct ieee80211req_wpaie *)wrqu->data.pointer;
-	struct stat_info *pstat = get_stainfo(priv, ie->wpa_macaddr);
-	int ret = 0;
-	HAPD_MSG("rtl_net80211_getwpaie +++ \n");
-	HAPD_MSG("mac =  0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n",
-			ie->wpa_macaddr[0], ie->wpa_macaddr[1], ie->wpa_macaddr[2],
-			ie->wpa_macaddr[3], ie->wpa_macaddr[4], ie->wpa_macaddr[5]);	
-
-	if(pstat == NULL)
-		return -EINVAL;
-	
-#ifndef HAPD_DRV_PSK_WPS
-	HAPD_MSG("RSNEnabled = %d\n"
-			"wpa_ie = 0x%02x 0x%02x 0x%02x \n"
-			"wps_ie = 0x%02x 0x%02x 0x%02x \n" 
-			,pstat->wpa_sta_info->RSNEnabled,
-			pstat->wpa_ie[0], pstat->wpa_ie[1], pstat->wpa_ie[2], 
-			pstat->wps_ie[0], pstat->wps_ie[1], pstat->wps_ie[2]
-			);
-#else
-	HAPD_MSG("RSNEnabled = %d\n"
-			"wpa_ie = 0x%02x 0x%02x 0x%02x \n"
-			,pstat->wpa_sta_info->RSNEnabled,
-			pstat->wpa_ie[0], pstat->wpa_ie[1], pstat->wpa_ie[2]
-			);
-#endif
-
-	if(pstat->wpa_sta_info->RSNEnabled & BIT(0))
-		memcpy(ie->wpa_ie, pstat->wpa_ie, pstat->wpa_ie[1]+2);
-	else if(pstat->wpa_sta_info->RSNEnabled & BIT(1))
-		memcpy(ie->rsn_ie, pstat->wpa_ie, pstat->wpa_ie[1]+2);
-
-#ifndef HAPD_DRV_PSK_WPS
-	if((priv->pmib->wscEntry.wsc_enable & 2) && (pstat->wps_ie[1]))
-		memcpy(ie->wps_ie, pstat->wps_ie, pstat->wps_ie[1]+2);
-#endif
-
-	HAPD_MSG("rtl_net80211_getwpaie --- \n");
-	return ret;
-	
-}
-
-
-#if	(defined(WIFI_HAPD) && defined(WDS)) && !defined(HAPD_DRV_PSK_WPS)
-int rtl_net80211_wdsaddmac(struct net_device *dev, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)
-{
-#ifdef NETDEV_NO_PRIV
-	struct rtl8192cd_priv *priv = ((struct rtl8192cd_priv *)netdev_priv(dev))->wlan_priv;
-#else
-	struct rtl8192cd_priv	*priv = (struct rtl8192cd_priv *)dev->priv;
-#endif
-	struct rtk_wds_config *wds = (struct hapd_wds_info *)wrqu->data.pointer;
-	int ret = 0;
-	int num = 0;
-	
-	HAPD_MSG("rtl_net80211_wdsaddmac +++ \n");	
-
-	if(wds->wdsEnabled == 0)
-		goto bad;
-	if(wds->wdsNum > NUM_WDS)
-		goto bad;
-	if( (wds->wdsPrivacy != _NO_PRIVACY_) && (wds->wdsPrivacy != _WEP_40_PRIVACY_) &&
-		(wds->wdsPrivacy != _TKIP_PRIVACY_) && (wds->wdsPrivacy != _CCMP_PRIVACY_) &&
-		(wds->wdsPrivacy != _WEP_104_PRIVACY_))
-		goto bad;
-	
-	if((wds->wdsPrivacy == _WEP_40_PRIVACY_) && (wds->wdsWepKeyLen != 5))
-		goto bad;
-	if((wds->wdsPrivacy == _WEP_104_PRIVACY_) && (wds->wdsWepKeyLen != 13))
-		goto bad;
-	
-	priv->pmib->dot11WdsInfo.wdsEnabled = 1;
-	priv->pmib->dot11WdsInfo.wdsNum = wds->wdsNum;
-		
-	for(num=0 ; num < wds->wdsNum; num++)
-		memcpy(priv->pmib->dot11WdsInfo.entry[num].macAddr, wds->macAddr[num], MACADDRLEN);
-
-	priv->pmib->dot11WdsInfo.wdsPrivacy = wds->wdsPrivacy;
-
-	if((wds->wdsPrivacy == _WEP_40_PRIVACY_)||(wds->wdsPrivacy == _WEP_104_PRIVACY_))
-			memcpy(priv->pmib->dot11WdsInfo.wdsWepKey, wds->wdsWepKey, wds->wdsWepKeyLen);
-	else if((wds->wdsPrivacy == _TKIP_PRIVACY_)||(wds->wdsPrivacy == _CCMP_PRIVACY_))
-		hapd_set_wdskey(dev, wds->wdsPskPassPhrase, wds->ssid, wds->wdsNum);
-	
-	
-	HAPD_MSG("rtl_net80211_wdsaddmac --- \n");
-	return 0;
-
-bad:
-	priv->pmib->dot11WdsInfo.wdsEnabled = 0;
-	return -EINVAL;
-	
-
-}
-
-int rtl_net80211_wdsdelmac(struct net_device *dev, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)
-{
-#ifdef NETDEV_NO_PRIV
-	struct rtl8192cd_priv *priv = ((struct rtl8192cd_priv *)netdev_priv(dev))->wlan_priv;
-#else
-	struct rtl8192cd_priv	*priv = (struct rtl8192cd_priv *)dev->priv;
-#endif
-	struct rtk_wds_config *wds = (struct rtk_wds_config *)wrqu->data.pointer;
-	HAPD_MSG("rtl_net80211_wdsdelmac +++ \n");
-
-	priv->pmib->dot11WdsInfo.wdsEnabled = 0;
-	priv->pmib->dot11WdsInfo.wdsNum = 0;
-
-	HAPD_MSG("rtl_net80211_wdsdelmac --- \n");
-	return 0;
-}
-#endif
-
-
-int rtl_hapd_config(struct net_device *dev, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)
-{
-#ifdef NETDEV_NO_PRIV
-	struct rtl8192cd_priv *priv = ((struct rtl8192cd_priv *)netdev_priv(dev))->wlan_priv;
-#else
-	struct rtl8192cd_priv	*priv = (struct rtl8192cd_priv *)dev->priv;
-#endif
-	struct rtk_hapd_config *config = (struct rtk_hapd_config *)wrqu->data.pointer;
-	int size = 0;
-
-	HAPD_MSG("rtl_hapd_config +++\n");
-
-	priv->pmib->dot11BssType.net_work_type    					= config->band;
-	priv->pmib->dot11RFEntry.dot11channel	  					= config->channel;
-	priv->pmib->dot11StationConfigEntry.dot11BeaconPeriod	  	= config->bcnint; 		  
-	priv->pmib->dot11StationConfigEntry.dot11DTIMPeriod 	  	= config->dtimperiod; 
-
-	if(config->stanum <= NUM_STAT)
-	priv->pmib->dot11StationConfigEntry.supportedStaNum 	  	= config->stanum; 
-	else
-	{
-		HAPD_MSG("Invalid Station Number!!!\n");
-		return -1;
-	}
-	
-	priv->pmib->dot11OperationEntry.dot11RTSThreshold		  	= config->rtsthres;		  
-	priv->pmib->dot11OperationEntry.dot11FragmentationThreshold = config->fragthres;	
-	priv->pmib->dot11StationConfigEntry.dot11SupportedRates   	= config->oprates;		  
-	priv->pmib->dot11StationConfigEntry.dot11BasicRates 	  	= config->basicrates; 
-	priv->pmib->dot11RFEntry.shortpreamble	  					= config->preamble;	
-	priv->pmib->dot11StationConfigEntry.dot11AclMode	 		= config->aclmode;		  
-	priv->pmib->dot11StationConfigEntry.dot11AclNum 	  		= config->aclnum;
-	
-	size = sizeof(priv->pmib->dot11StationConfigEntry.dot11AclAddr);
-	memcpy(priv->pmib->dot11StationConfigEntry.dot11AclAddr, config->acladdr, size);
-	
-	priv->pmib->dot11OperationEntry.hiddenAP			  		= config->hiddenAP;	
-#ifdef WIFI_WMM
-	priv->pmib->dot11QosEntry.dot11QosEnable			  		= config->qos_enable;
-#endif
-	priv->pmib->dot11OperationEntry.expiretime					= config->expired_time * 100;	// 10ms unit vs 1s unit
-	priv->pmib->dot11OperationEntry.block_relay					= config->block_relay;
-	priv->pmib->dot11nConfigEntry.dot11nShortGIfor20M 			= config->shortGI20M; 		  
-	priv->pmib->dot11nConfigEntry.dot11nShortGIfor40M 			= config->shortGI40M; 
-
-
-//Above are for Hostapd owned configurations
-//=====================================================
-//Below are for RTK private configurations
-
-	size = sizeof(priv->pmib->dot11RFEntry.pwrlevelCCK_A);
-	memcpy(priv->pmib->dot11RFEntry.pwrlevelCCK_A, config->pwrlevelCCK_A, size);
-
-	size = sizeof(priv->pmib->dot11RFEntry.pwrlevelCCK_B);
-	memcpy(priv->pmib->dot11RFEntry.pwrlevelCCK_B, config->pwrlevelCCK_B, size);
-
-	size = sizeof(priv->pmib->dot11RFEntry.pwrlevelHT40_1S_A);
-	memcpy(priv->pmib->dot11RFEntry.pwrlevelHT40_1S_A, config->pwrlevelHT40_1S_A, size);
-
-	size = sizeof(priv->pmib->dot11RFEntry.pwrlevelHT40_1S_B);
-	memcpy(priv->pmib->dot11RFEntry.pwrlevelHT40_1S_B, config->pwrlevelHT40_1S_A, size);
-
-	size = sizeof(priv->pmib->dot11RFEntry.pwrdiffHT40_2S);
-	memcpy(priv->pmib->dot11RFEntry.pwrdiffHT40_2S, config->pwrdiffHT40_2S, size);
-
-	size = sizeof(priv->pmib->dot11RFEntry.pwrdiffHT20);
-	memcpy(priv->pmib->dot11RFEntry.pwrdiffHT20, config->pwrdiffHT20, size);
-
-	size = sizeof(priv->pmib->dot11RFEntry.pwrdiffOFDM);
-	memcpy(priv->pmib->dot11RFEntry.pwrdiffOFDM, config->pwrdiffOFDM, size);
-		  
-	priv->pmib->dot11RFEntry.ther		  		= config->ther;	
-	
-#ifdef CONFIG_RTL_92D_SUPPORT           
-	priv->pmib->dot11RFEntry.phyBandSelect	  	= config->phyBandSelect;		  
-#endif   
-
-	priv->pmib->dot11StationConfigEntry.dot11swcrypto	  	= config->swcrypto;		      
-	priv->pmib->dot11StationConfigEntry.dot11RegDomain		= config->regdomain;		  
-	priv->pmib->dot11StationConfigEntry.autoRate		   	= config->autorate;	  
-	priv->pmib->dot11StationConfigEntry.fixedTxRate			= config->fixrate;
-	priv->pmib->dot11StationConfigEntry.protectionDisabled	= config->disable_protection; 	  
-	priv->pmib->dot11StationConfigEntry.olbcDetectDisabled	= config->disable_olbc;		  
-	priv->pmib->dot11StationConfigEntry.legacySTADeny	  	= config->deny_legacy;		  	     
-	priv->pmib->dot11OperationEntry.opmode				  	= config->opmode; 		  	  																			  		 		  																																																		                  																			 
-	priv->pmib->dot11nConfigEntry.dot11nUse40M		  		= config->use40M; 		  
-	priv->pmib->dot11nConfigEntry.dot11n2ndChOffset   		= config->_2ndchoffset;		    
-	priv->pmib->dot11nConfigEntry.dot11nAMPDU	  			= config->ampdu;			                             
-	priv->pmib->dot11OperationEntry.guest_access			= config->guest_access;
-																							
-	priv->pmib->dot11RFEntry.macPhyMode 					= config->macPhyMode;
-																							
-#ifdef WIFI_11N_2040_COEXIST            
-	priv->pmib->dot11nConfigEntry.dot11nCoexist = config->coexist;		  
-#endif    
-	 
-#ifdef MBSSID                           
-	priv->pmib->miscEntry.vap_enable 			= config->vap_enable;		  
-#endif                            
-																							
-	priv->pshare->rf_ft_var.rssi_dump	  		= config->rssi_dump;			  
-																										  
-#ifdef MP_TEST                          
-	priv->pshare->rf_ft_var.mp_specific  		= config->mp_specific;		  
-#endif                                  
-																							
-#ifdef HIGH_POWER_EXT_PA                
-	priv->pshare->rf_ft_var.use_ext_pa 			= config->use_ext_pa; 		  
-#endif    
-
-	HAPD_MSG("rtl_hapd_config ---\n");
-	return 0;
-}
-
-
-
-#ifdef WIFI_WPAS
-
-int rtl_wpas_config_2G(struct rtl8192cd_priv *priv)
-{
-	HAPD_MSG("wpas config wlan 2.4G\n");
-	
-	priv->pmib->dot11BssType.net_work_type					= 1 + 2 + 8;
-	priv->pmib->dot11RFEntry.dot11channel					= 11;
-	priv->pmib->dot11nConfigEntry.dot11nShortGIfor20M		= 1;		  
-	priv->pmib->dot11nConfigEntry.dot11nShortGIfor40M		= 1;
-	priv->pmib->dot11StationConfigEntry.autoRate			= 1;																																																																																																						 
-	priv->pmib->dot11nConfigEntry.dot11nUse40M				= 1;				
-	priv->pmib->dot11nConfigEntry.dot11nAMPDU				= 1;
-	//priv->pmib->dot11RFEntry.macPhyMode 					= DUALMAC_DUALPHY;
-	priv->pmib->dot11nConfigEntry.dot11n2ndChOffset 		= HT_2NDCH_OFFSET_BELOW;
-	priv->pmib->dot11StationConfigEntry.dot11SupportedRates = 0xfff;		  
-	priv->pmib->dot11StationConfigEntry.dot11BasicRates 	= 0xf; 
-	priv->pmib->dot11OperationEntry.wifi_specific			= 2; //_Eric ??
-
-	priv->pmib->dot11OperationEntry.dot11FragmentationThreshold = 2346;
-	
-#ifdef CONFIG_RTL_92D_SUPPORT           
-	priv->pmib->dot11RFEntry.phyBandSelect					= PHY_BAND_2G;		  
-#endif   
-	
-#ifdef WIFI_WMM
-	priv->pmib->dot11QosEntry.dot11QosEnable				= 1;
-#endif
-
-}
-
-int rtl_wpas_config_5G(struct rtl8192cd_priv *priv)
-{
-	printk("wpas config wlan 5G\n");
-				
-	priv->pmib->dot11BssType.net_work_type					= 4 + 8;
-	priv->pmib->dot11RFEntry.dot11channel					= 44;
-	priv->pmib->dot11nConfigEntry.dot11nShortGIfor20M		= 1;		  
-	priv->pmib->dot11nConfigEntry.dot11nShortGIfor40M		= 1;
-	priv->pmib->dot11StationConfigEntry.autoRate			= 1;																																																																																																						 
-	priv->pmib->dot11nConfigEntry.dot11nUse40M				= 1;				
-	priv->pmib->dot11nConfigEntry.dot11nAMPDU				= 1;
-	//priv->pmib->dot11RFEntry.macPhyMode 					= DUALMAC_DUALPHY; //_Eric ?? How to judge ??
-	priv->pmib->dot11nConfigEntry.dot11n2ndChOffset 		= HT_2NDCH_OFFSET_ABOVE;
-	priv->pmib->dot11StationConfigEntry.dot11SupportedRates = 0xff0;		  
-	priv->pmib->dot11StationConfigEntry.dot11BasicRates 	= 0xff0; 
-	priv->pmib->dot11OperationEntry.wifi_specific			= 2;
-
-	priv->pmib->dot11OperationEntry.dot11FragmentationThreshold = 2346;
-	
-#ifdef CONFIG_RTL_92D_SUPPORT           
-	priv->pmib->dot11RFEntry.phyBandSelect					= PHY_BAND_5G;		  
-#endif   
-	
-#ifdef WIFI_WMM
-	priv->pmib->dot11QosEntry.dot11QosEnable				= 1;
-#endif
-
-}
-
-
-int rtl_wpas_config(struct rtl8192cd_priv *priv, unsigned char bandmode, unsigned char phymode)
-{
-	HAPD_MSG("wpas config interface: %s\n", priv->dev->name);
-
-	priv->pmib->dot11OperationEntry.opmode = WIFI_STATION_STATE;
-
-	if(bandmode == SINGLEMAC_SINGLEPHY)
-		{
-			priv->pmib->dot11RFEntry.macPhyMode = SINGLEMAC_SINGLEPHY;
-
-			if(phymode == PHY_BAND_5G)
-				rtl_wpas_config_5G(priv);
-			else if(phymode == PHY_BAND_2G)
-				rtl_wpas_config_2G(priv);
-			else
-				return -1;
-			
-		}
-	else if(!strcmp(priv->dev->name, "wlan0"))
-		{
-			priv->pmib->dot11RFEntry.macPhyMode = DUALMAC_DUALPHY;
-			rtl_wpas_config_5G(priv);
-		}
-	else if(!strcmp(priv->dev->name, "wlan1"))
-		{
-			priv->pmib->dot11RFEntry.macPhyMode = DUALMAC_DUALPHY;
-			rtl_wpas_config_2G(priv);
-		}
-	else
-		return -1;
-
-	return 0;
-
-
-}
-
-
-int rtl_wpas_custom(struct net_device *dev, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)
-{
-#ifdef NETDEV_NO_PRIV
-	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *)netdev_priv(dev);
-#else
-	struct rtl8192cd_priv	*priv = (struct rtl8192cd_priv *)dev->priv;
-#endif
-	struct rtk_wpas_config *config = (struct rtk_wpas_config *)wrqu->data.pointer;
-
-	int ret = 0;
-
-	switch (config->type) {
-	case WPAS_CONFIG_MIB:
-		HAPD_MSG("bandmode %d phymode %d \n", config->bandmode, config->phymode);
-		if((config->bandmode == SINGLEMAC_SINGLEPHY) || (config->bandmode == DUALMAC_DUALPHY))
-			ret = rtl_wpas_config(priv, config->bandmode, config->phymode);
-		else
-			return -EINVAL;
-		break;
-	case WPAS_CONFIG_WEPKEY: 
-		HAPD_MSG("WPAS_CONFIG_WEPKEY !!! \n");
-		memcpy(&priv->pmib->dot11DefaultKeysTable.keytype[config->wep_keyidx].skey[0], config->wep_key, config->wep_keylen);
-		break;
-
-	}
-
-	return ret;
-
-}
-#endif
-
-static void Construct_RSNIE(struct rtl8192cd_priv *priv, unsigned char *pucOut, int *usOutLen)
-{
-	DOT11_RSN_IE_HEADER dot11RSNIEHeader = { 0 };
-	DOT11_RSN_IE_SUITE dot11RSNGroupSuite;
-	DOT11_RSN_IE_COUNT_SUITE *pDot11RSNPairwiseSuite = NULL;
-	DOT11_RSN_IE_COUNT_SUITE *pDot11RSNAuthSuite = NULL;
-	unsigned short usSuitCount;
-	unsigned long ulIELength = 0;
-	unsigned long ulIndex = 0;
-	unsigned long ulPairwiseLength = 0;
-	unsigned long ulAuthLength = 0;
-	unsigned char *pucBlob;
-	DOT11_RSN_IE_COUNT_SUITE countSuite, authCountSuite;
-#ifdef RTL_WPA2
-	DOT11_RSN_CAPABILITY dot11RSNCapability = { 0 };
-	unsigned long uCipherAlgo = 0;
-	int bCipherAlgoEnabled = FALSE;
-	unsigned long uAuthAlgo = 0;
-	int bAuthAlgoEnabled = FALSE;
-	unsigned long ulRSNCapabilityLength = 0;
-#endif
-
-	*usOutLen = 0;
-	if ( priv->pmib->dot1180211AuthEntry.dot11WPACipher != 0 ) {
-		//
-		// Construct Information Header
-		//
-		dot11RSNIEHeader.ElementID = RSN_ELEMENT_ID;
-		dot11RSNIEHeader.OUI[0] = 0x00;
-		dot11RSNIEHeader.OUI[1] = 0x50;
-		dot11RSNIEHeader.OUI[2] = 0xf2;
-		dot11RSNIEHeader.OUI[3] = 0x01;
-		dot11RSNIEHeader.Version = cpu_to_le16(RSN_VER1);
-		ulIELength += sizeof(DOT11_RSN_IE_HEADER);
-
-		// Construct Cipher Suite:
-		// - Multicast Suite:
-		memset(&dot11RSNGroupSuite, 0, sizeof dot11RSNGroupSuite);
-		dot11RSNGroupSuite.OUI[0] = 0x00;
-		dot11RSNGroupSuite.OUI[1] = 0x50;
-		dot11RSNGroupSuite.OUI[2] = 0xF2;
-		dot11RSNGroupSuite.Type = priv->wpa_global_info->MulticastCipher;
-		ulIELength += sizeof(DOT11_RSN_IE_SUITE);
-
-    	// - UnicastSuite
-        pDot11RSNPairwiseSuite = &countSuite;
-        memset(pDot11RSNPairwiseSuite, 0, sizeof(DOT11_RSN_IE_COUNT_SUITE));
-		usSuitCount = 0;
-        for (ulIndex=0; ulIndex<priv->wpa_global_info->NumOfUnicastCipher; ulIndex++)
-        {
-			pDot11RSNPairwiseSuite->dot11RSNIESuite[usSuitCount].OUI[0] = 0x00;
-			pDot11RSNPairwiseSuite->dot11RSNIESuite[usSuitCount].OUI[1] = 0x50;
-			pDot11RSNPairwiseSuite->dot11RSNIESuite[usSuitCount].OUI[2] = 0xF2;
-			pDot11RSNPairwiseSuite->dot11RSNIESuite[usSuitCount].Type = priv->wpa_global_info->UnicastCipher[ulIndex];
-			usSuitCount++;
-        }
-		pDot11RSNPairwiseSuite->SuiteCount = cpu_to_le16(usSuitCount);
-        ulPairwiseLength = sizeof(pDot11RSNPairwiseSuite->SuiteCount) + usSuitCount*sizeof(DOT11_RSN_IE_SUITE);
-        ulIELength += ulPairwiseLength;
-
-		//
-		// Construction of Auth Algo List
-		//
-        pDot11RSNAuthSuite = &authCountSuite;
-        memset(pDot11RSNAuthSuite, 0, sizeof(DOT11_RSN_IE_COUNT_SUITE));
-		usSuitCount = 0;
-		pDot11RSNAuthSuite->dot11RSNIESuite[usSuitCount].OUI[0] = 0x00;
-		pDot11RSNAuthSuite->dot11RSNIESuite[usSuitCount].OUI[1] = 0x50;
-		pDot11RSNAuthSuite->dot11RSNIESuite[usSuitCount].OUI[2] = 0xF2;
-		pDot11RSNAuthSuite->dot11RSNIESuite[usSuitCount].Type = DOT11_AuthKeyType_RSN;
-	    usSuitCount++;
-
-		pDot11RSNAuthSuite->SuiteCount = cpu_to_le16(usSuitCount);
-        ulAuthLength = sizeof(pDot11RSNAuthSuite->SuiteCount) + usSuitCount*sizeof(DOT11_RSN_IE_SUITE);
-        ulIELength += ulAuthLength;
-
-		pucBlob = pucOut;
-		pucBlob += sizeof(DOT11_RSN_IE_HEADER);
-		memcpy(pucBlob, &dot11RSNGroupSuite, sizeof(DOT11_RSN_IE_SUITE));
-		pucBlob += sizeof(DOT11_RSN_IE_SUITE);
-		memcpy(pucBlob, pDot11RSNPairwiseSuite, ulPairwiseLength);
-		pucBlob += ulPairwiseLength;
-		memcpy(pucBlob, pDot11RSNAuthSuite, ulAuthLength);
-		pucBlob += ulAuthLength;
-
-		*usOutLen = (int)ulIELength;
-		pucBlob = pucOut;
-		dot11RSNIEHeader.Length = (unsigned char)ulIELength - 2; //This -2 is to minus elementID and Length in OUI header
-		memcpy(pucBlob, &dot11RSNIEHeader, sizeof(DOT11_RSN_IE_HEADER));
-	}
-
-#ifdef RTL_WPA2
-	if ( priv->pmib->dot1180211AuthEntry.dot11WPA2Cipher != 0 ) {
-       	DOT11_WPA2_IE_HEADER dot11WPA2IEHeader = { 0 };
-		ulIELength = 0;
-		ulIndex = 0;
-		ulPairwiseLength = 0;
-		uCipherAlgo = 0;
-		bCipherAlgoEnabled = FALSE;
-		ulAuthLength = 0;
-		uAuthAlgo = 0;
-		bAuthAlgoEnabled = FALSE;
-		ulRSNCapabilityLength = 0;
-
-		//
-		// Construct Information Header
-		//
-		dot11WPA2IEHeader.ElementID = WPA2_ELEMENT_ID;
-		dot11WPA2IEHeader.Version = cpu_to_le16(RSN_VER1);
-		ulIELength += sizeof(DOT11_WPA2_IE_HEADER);
-
-		// Construct Cipher Suite:
-		//      - Multicast Suite:
-		//
-		memset(&dot11RSNGroupSuite, 0, sizeof(dot11RSNGroupSuite));
-		dot11RSNGroupSuite.OUI[0] = 0x00;
-		dot11RSNGroupSuite.OUI[1] = 0x0F;
-		dot11RSNGroupSuite.OUI[2] = 0xAC;
-		dot11RSNGroupSuite.Type = priv->wpa_global_info->MulticastCipher;;
-		ulIELength += sizeof(DOT11_RSN_IE_SUITE);
-
-		//      - UnicastSuite
-        pDot11RSNPairwiseSuite = &countSuite;
-        memset(pDot11RSNPairwiseSuite, 0, sizeof(DOT11_RSN_IE_COUNT_SUITE));
-		usSuitCount = 0;
-		for (ulIndex=0; ulIndex<priv->wpa_global_info->NumOfUnicastCipherWPA2; ulIndex++)
-        {
-			pDot11RSNPairwiseSuite->dot11RSNIESuite[usSuitCount].OUI[0] = 0x00;
-			pDot11RSNPairwiseSuite->dot11RSNIESuite[usSuitCount].OUI[1] = 0x0F;
-			pDot11RSNPairwiseSuite->dot11RSNIESuite[usSuitCount].OUI[2] = 0xAC;
-			pDot11RSNPairwiseSuite->dot11RSNIESuite[usSuitCount].Type = priv->wpa_global_info->UnicastCipherWPA2[ulIndex];
-			usSuitCount++;
-        }
-		pDot11RSNPairwiseSuite->SuiteCount = cpu_to_le16(usSuitCount);
-        ulPairwiseLength = sizeof(pDot11RSNPairwiseSuite->SuiteCount) + usSuitCount*sizeof(DOT11_RSN_IE_SUITE);
-        ulIELength += ulPairwiseLength;
-
-		//
-		// Construction of Auth Algo List
-		//
-        pDot11RSNAuthSuite = &authCountSuite;
-        memset(pDot11RSNAuthSuite, 0, sizeof(DOT11_RSN_IE_COUNT_SUITE));
-		usSuitCount = 0;
-		pDot11RSNAuthSuite->dot11RSNIESuite[usSuitCount].OUI[0] = 0x00;
-		pDot11RSNAuthSuite->dot11RSNIESuite[usSuitCount].OUI[1] = 0x0F;
-		pDot11RSNAuthSuite->dot11RSNIESuite[usSuitCount].OUI[2] = 0xAC;
-		pDot11RSNAuthSuite->dot11RSNIESuite[usSuitCount].Type = DOT11_AuthKeyType_RSN;
-	    usSuitCount++;
-
-		pDot11RSNAuthSuite->SuiteCount = cpu_to_le16(usSuitCount);
-        ulAuthLength = sizeof(pDot11RSNAuthSuite->SuiteCount) + usSuitCount*sizeof(DOT11_RSN_IE_SUITE);
-        ulIELength += ulAuthLength;
-
-		//---------------------------------------------------------------------------------------------
-		// Do not encapsulate capability field to solve TI WPA issue
-		//---------------------------------------------------------------------------------------------
-
-		dot11RSNCapability.field.PreAuthentication = 0;
-
-		ulRSNCapabilityLength = sizeof(DOT11_RSN_CAPABILITY);
-		ulIELength += ulRSNCapabilityLength;
-
-		pucBlob = pucOut + *usOutLen;
-		pucBlob += sizeof(DOT11_WPA2_IE_HEADER);
-		memcpy(pucBlob, &dot11RSNGroupSuite, sizeof(DOT11_RSN_IE_SUITE));
-		pucBlob += sizeof(DOT11_RSN_IE_SUITE);
-		memcpy(pucBlob, pDot11RSNPairwiseSuite, ulPairwiseLength);
-		pucBlob += ulPairwiseLength;
-		memcpy(pucBlob, pDot11RSNAuthSuite, ulAuthLength);
-		pucBlob += ulAuthLength;
-		memcpy(pucBlob, &dot11RSNCapability, ulRSNCapabilityLength);
-
-		pucBlob = pucOut + *usOutLen;
-		dot11WPA2IEHeader.Length = (unsigned char)ulIELength - 2; //This -2 is to minus elementID and Length in OUI header
-		memcpy(pucBlob, &dot11WPA2IEHeader, sizeof(DOT11_WPA2_IE_HEADER));
-		*usOutLen = *usOutLen + (int)ulIELength;
-   	}
-#endif // RTL_WPA2
-
-}
-
-
-static void ToDrv_SetRSNIE(struct rtl8192cd_priv *priv)
-{
-	struct iw_point wrq;
-	DOT11_SET_RSNIE Set_Rsnie;
-
-
-	debug_out("RSN: Set RSNIE", priv->wpa_global_info->AuthInfoElement.Octet,
-								priv->wpa_global_info->AuthInfoElement.Length);
-
-
-	wrq.pointer = (caddr_t)&Set_Rsnie;
-	wrq.length = sizeof(DOT11_SET_RSNIE);
-	Set_Rsnie.EventId = DOT11_EVENT_SET_RSNIE;
-	Set_Rsnie.IsMoreEvent = FALSE;
-	Set_Rsnie.Flag = DOT11_Ioctl_Set;
-	Set_Rsnie.RSNIELen = priv->wpa_global_info->AuthInfoElement.Length;
-	memcpy(&Set_Rsnie.RSNIE,
-			priv->wpa_global_info->AuthInfoElement.Octet,
-			priv->wpa_global_info->AuthInfoElement.Length);
-
-	rtl8192cd_ioctl_priv_daemonreq(priv->dev, &wrq);
-}
-
-
-void rsn_init(struct rtl8192cd_priv *priv)
-{
-	WPA_GLOBAL_INFO *pGblInfo=priv->wpa_global_info;
-	int i, j, low_cipher=0;
-
-	DEBUG_TRACE;
-
-	HAPD_MSG("rsn_init\n");
-
-	memset((char *)pGblInfo, '\0', sizeof(WPA_GLOBAL_INFO));
-
-	if (priv->pmib->dot1180211AuthEntry.dot11WPACipher) {
-		for (i=0, j=0; i<_WEP_104_PRIVACY_; i++) {
-			if (priv->pmib->dot1180211AuthEntry.dot11WPACipher & (1<<i)) {
-				pGblInfo->UnicastCipher[j] = i+1;
-				if (low_cipher == 0)
-					low_cipher = pGblInfo->UnicastCipher[j];
-				else {
-					if (low_cipher == _WEP_104_PRIVACY_ &&
-							pGblInfo->UnicastCipher[j] == _WEP_40_PRIVACY_)
-						low_cipher = pGblInfo->UnicastCipher[j];
-					else if (low_cipher == _TKIP_PRIVACY_ &&
-							(pGblInfo->UnicastCipher[j] == _WEP_40_PRIVACY_ ||
-								pGblInfo->UnicastCipher[j] == _WEP_104_PRIVACY_))
-							low_cipher = pGblInfo->UnicastCipher[j];
-					else if (low_cipher == _CCMP_PRIVACY_)
-							low_cipher = pGblInfo->UnicastCipher[j];
-				}
-				if (++j >= MAX_UNICAST_CIPHER)
-					break;
-			}
-		}
-		pGblInfo->NumOfUnicastCipher = j;
-	}
-
-#ifdef RTL_WPA2
-	if (priv->pmib->dot1180211AuthEntry.dot11WPA2Cipher) {
-		for (i=0, j=0; i<_WEP_104_PRIVACY_; i++) {
-			if (priv->pmib->dot1180211AuthEntry.dot11WPA2Cipher & (1<<i)) {
-				pGblInfo->UnicastCipherWPA2[j] = i+1;
-				if (low_cipher == 0)
-					low_cipher = pGblInfo->UnicastCipherWPA2[j];
-				else {
-					if (low_cipher == _WEP_104_PRIVACY_ &&
-							pGblInfo->UnicastCipherWPA2[j] == _WEP_40_PRIVACY_)
-						low_cipher = pGblInfo->UnicastCipherWPA2[j];
-					else if (low_cipher == _TKIP_PRIVACY_ &&
-							(pGblInfo->UnicastCipherWPA2[j] == _WEP_40_PRIVACY_ ||
-								pGblInfo->UnicastCipherWPA2[j] == _WEP_104_PRIVACY_))
-							low_cipher = pGblInfo->UnicastCipherWPA2[j];
-					else if (low_cipher == _CCMP_PRIVACY_)
-							low_cipher = pGblInfo->UnicastCipherWPA2[j];
-				}
-				if (++j >= MAX_UNICAST_CIPHER)
-					break;
-			}
-		}
-		pGblInfo->NumOfUnicastCipherWPA2= j;
-	}
-#endif
-
-	pGblInfo->MulticastCipher = low_cipher;
-
-	HAPD_MSG("RSN: WPA unicast cipher= ");
-	for (i=0; i<pGblInfo->NumOfUnicastCipher; i++)
-		HAPD_MSG("%x ", pGblInfo->UnicastCipher[i]);
-	HAPD_MSG("\n");
-
-#ifdef RTL_WPA2
-	HAPD_MSG("RSN: WPA2 unicast cipher= ");
-	for (i=0; i<pGblInfo->NumOfUnicastCipherWPA2; i++)
-		HAPD_MSG("%x ", pGblInfo->UnicastCipherWPA2[i]);
-	HAPD_MSG("\n");
-#endif
-
-	HAPD_MSG("RSN: multicast cipher= %x\n", pGblInfo->MulticastCipher);
-
-
-	pGblInfo->AuthInfoElement.Octet = pGblInfo->AuthInfoBuf;
-
-	Construct_RSNIE(priv, pGblInfo->AuthInfoElement.Octet,
-					 &pGblInfo->AuthInfoElement.Length);
-
-	ToDrv_SetRSNIE(priv);
-}
-
-#endif //WIFI_HAPD
+/*
+ *   API-compatible handling routines
+ *
+ *
+ *
+ *  Copyright (c) 2009 Realtek Semiconductor Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#ifdef __KERNEL__
+#include <linux/module.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+#include <linux/unistd.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#endif
+
+#include "./8192cd_cfg.h"
+
+#ifdef WIFI_HAPD
+
+#ifdef __LINUX_2_6__
+#include <linux/initrd.h>
+#include <linux/syscalls.h>
+#endif
+
+#include "./8192cd_debug.h"
+#include "./8192cd_net80211.h"
+#include "./8192cd_headers.h"
+
+#include <linux/if_arp.h>
+#include <linux/wireless.h>
+#include <net/iw_handler.h>
+#include <net80211/ieee80211.h>
+#include <net80211/ieee80211_crypto.h>
+#include <net80211/ieee80211_ioctl.h>
+
+//#define HAPD_DEBUG
+
+void void_printk(const char *fmt, ...)
+{
+	;
+}
+
+#ifdef HAPD_DEBUG
+#define HAPD_MSG	printk
+#else
+#define HAPD_MSG	void_printk
+#endif
+
+
+
+const char* ether_sprintf(const u_int8_t *mac)
+{
+	static char etherbuf[18]; 	/* XXX */
+	snprintf(etherbuf, sizeof(etherbuf), "%02x:%02x:%02x:%02x:%02x:%02x",
+		mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+	return etherbuf;
+}
+
+static __inline__ void set_ttkeylen(struct Dot11EncryptKey *pEncryptKey, UINT8 len)
+{
+	pEncryptKey->dot11TTKeyLen = len;
+}
+
+
+static __inline__ void set_tmickeylen(struct Dot11EncryptKey *pEncryptKey, UINT8 len)
+{
+	pEncryptKey->dot11TMicKeyLen = len;
+}
+
+
+static __inline__ void set_tkip_key(struct Dot11EncryptKey *pEncryptKey, UINT8 *src)
+{
+	memcpy(pEncryptKey->dot11TTKey.skey, src, pEncryptKey->dot11TTKeyLen);
+
+	memcpy(pEncryptKey->dot11TMicKey1.skey, src + 16, pEncryptKey->dot11TMicKeyLen);
+
+	memcpy(pEncryptKey->dot11TMicKey2.skey, src + 24, pEncryptKey->dot11TMicKeyLen);
+
+	pEncryptKey->dot11TXPN48.val48 = 0;
+}
+
+
+static __inline__ void set_aes_key(struct Dot11EncryptKey *pEncryptKey, UINT8 *src)
+{
+	memcpy(pEncryptKey->dot11TTKey.skey, src, pEncryptKey->dot11TTKeyLen);
+
+	memcpy(pEncryptKey->dot11TMicKey1.skey, src, pEncryptKey->dot11TMicKeyLen);
+}
+
+
+static __inline__ void set_wep40_key(struct Dot11EncryptKey *pEncryptKey, UINT8 *src)
+{
+	memcpy(pEncryptKey->dot11TTKey.skey, src, pEncryptKey->dot11TTKeyLen);
+}
+
+
+static __inline__ void set_wep104_key(struct Dot11EncryptKey *pEncryptKey, UINT8 *src)
+{
+	memcpy(pEncryptKey->dot11TTKey.skey, src, pEncryptKey->dot11TTKeyLen);
+}
+
+
+static int HAPD_Process_Set_Port(struct net_device *dev, unsigned char *MACAddr, int PortStatus)
+{
+	struct stat_info	*pstat;
+#ifdef NETDEV_NO_PRIV
+	struct rtl8192cd_priv *priv = ((struct rtl8192cd_priv *)netdev_priv(dev))->wlan_priv;
+#else
+	struct rtl8192cd_priv	*priv = (struct rtl8192cd_priv *)dev->priv;
+#endif
+	struct wifi_mib		*pmib = priv->pmib;
+
+	HAPD_MSG("HAPD_Process_Set_Port +++ sta: %02X%02X%02X%02X%02X%02X Status %X\n",
+		MACAddr[0],MACAddr[1],MACAddr[2],
+		MACAddr[3],MACAddr[4],MACAddr[5],
+		PortStatus);
+
+	// if driver is not opened, return immediately, david
+	if (!netif_running(priv->dev))
+		return (-1);
+
+	pstat = get_stainfo(priv, MACAddr);
+
+	if ((pstat == NULL) || (!(pstat->state & WIFI_ASOC_STATE)))
+		return (-1);
+
+	if (PortStatus)
+		pstat->ieee8021x_ctrlport = PortStatus;
+	else
+		pstat->ieee8021x_ctrlport = pmib->dot118021xAuthEntry.dot118021xDefaultPort;
+
+	HAPD_MSG("HAPD_Process_Set_Port ---\n");
+
+	return 0;
+}
+
+#ifdef WIFI_WPAS
+
+static int	rtl_wpas_join(struct rtl8192cd_priv *priv, int bss_num)
+{
+	char tmpbuf[33];
+
+	if (!netif_running(priv->dev))
+		{
+			printk("WiFi driver is NOT open!!\n");
+			return -1;
+		}
+	else if (priv->ss_req_ongoing)
+		{
+			printk("Site Survey is not finished yet!!\n");
+			return -1;
+		}
+
+	memcpy((void *)&(priv->pmib->dot11Bss) ,
+		(void *)&priv->site_survey.bss_backup[bss_num] , sizeof(struct bss_desc));
+
+#ifdef WIFI_SIMPLE_CONFIG
+	//_Eric if (priv->pmib->wscEntry.wsc_enable && (priv->pmib->dot11Bss.bsstype&WIFI_WPS)) 
+	if (priv->pmib->wscEntry.wsc_enable)
+	{
+		//priv->pmib->dot11Bss.bsstype &= ~WIFI_WPS;
+		priv->wps_issue_join_req = 1;
+	}
+	else
+#endif
+	{
+		if (check_bss_encrypt(priv) == FAIL)
+		{
+			printk("Encryption mismatch!\n");
+			return -1;
+		}
+	}
+
+	if ((priv->pmib->dot11Bss.ssidlen == 0) || (priv->pmib->dot11Bss.ssid[0] == '\0')) 
+	{
+		printk("Error !! Join to a hidden AP!\n");
+		return -1;
+	}
+
+#ifdef UNIVERSAL_REPEATER
+	disable_vxd_ap(GET_VXD_PRIV(priv));
+#endif
+
+	memcpy(tmpbuf, priv->pmib->dot11Bss.ssid, priv->pmib->dot11Bss.ssidlen);
+	tmpbuf[priv->pmib->dot11Bss.ssidlen] = '\0';
+	printk("going to join bss: %s\n", tmpbuf);
+
+	memcpy(SSID2SCAN, priv->pmib->dot11Bss.ssid, priv->pmib->dot11Bss.ssidlen);
+	SSID2SCAN_LEN = priv->pmib->dot11Bss.ssidlen;
+
+	SSID_LEN = SSID2SCAN_LEN;
+	memcpy(SSID, SSID2SCAN, SSID_LEN);
+	memset(BSSID, 0, MACADDRLEN);
+
+#ifdef INCLUDE_WPA_PSK //_Eric ??
+	//if (priv->pmib->dot1180211AuthEntry.dot11EnablePSK)
+		//derivePSK(priv);
+#endif
+	priv->join_req_ongoing = 1;
+	priv->authModeRetry = 0;
+
+	//mod_timer(&priv->WPAS_timer, jiffies + 300);
+	start_clnt_join(priv);
+
+	return 0;
+}
+
+#endif
+
+
+void rtl_net80311_authmode(struct net_device *dev, int authtype, int encmode, 
+									int pskenable, int dot11802_1x)
+{
+#ifdef NETDEV_NO_PRIV
+	struct rtl8192cd_priv *priv = ((struct rtl8192cd_priv *)netdev_priv(dev))->wlan_priv;
+#else
+	struct rtl8192cd_priv	*priv = (struct rtl8192cd_priv *)dev->priv;
+#endif
+
+	HAPD_MSG("rtl_net80311_authmode +++\n");
+	HAPD_MSG("authtype=%d, encmode=%d, pskenable=%d, dot11802_1x=%d \n", authtype, encmode, pskenable, dot11802_1x);
+
+	priv->pmib->dot1180211AuthEntry.dot11AuthAlgrthm = authtype;
+	priv->pmib->dot1180211AuthEntry.dot11PrivacyAlgrthm = encmode;
+	priv->pmib->dot1180211AuthEntry.dot11EnablePSK = pskenable;
+	priv->pmib->dot118021xAuthEntry.dot118021xAlgrthm = dot11802_1x;	
+}
+
+int rtl_net80211_setparam(struct net_device *dev, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)
+{
+#ifdef NETDEV_NO_PRIV
+	struct rtl8192cd_priv *priv = ((struct rtl8192cd_priv *)netdev_priv(dev))->wlan_priv;
+#else
+	struct rtl8192cd_priv	*priv = (struct rtl8192cd_priv *)dev->priv;
+#endif
+
+	int *i = (int *) extra;
+	int param = wrqu->mode;		/* parameter id is 1st */
+	int value = 0;		/* NB: most values are TYPE_INT */
+	int ret = 0;
+
+	memcpy(&value, wrqu->name+sizeof(value), sizeof(value));
+
+	int authtype = priv->pmib->dot1180211AuthEntry.dot11AuthAlgrthm; 
+	int encmode = priv->pmib->dot1180211AuthEntry.dot11PrivacyAlgrthm;
+	int pskenable = priv->pmib->dot1180211AuthEntry.dot11EnablePSK;
+	int dot11802_1x = priv->pmib->dot118021xAuthEntry.dot118021xAlgrthm;
+
+	HAPD_MSG("rtl_net80211_setparam +++\n");
+	HAPD_MSG("rtl8192cd_net80211_ioctl, param = %d, value =%d\n", param, value);
+
+
+	switch (param) {
+		case IEEE80211_PARAM_TURBO:			/* turbo mode */
+			break;
+		case IEEE80211_PARAM_MODE:			/* phy mode (11a, 11b, etc.) */
+			break;
+		case IEEE80211_PARAM_AUTHMODE:		/* authentication mode */
+			switch (value) {
+			case IEEE80211_AUTH_NONE:
+				{//Disable
+					authtype = 0;
+					encmode = 0;
+					pskenable = 0;
+					dot11802_1x = 0;
+					rtl_net80311_authmode(dev, authtype, encmode, pskenable, dot11802_1x);
+					break;
+				}
+			case IEEE80211_AUTH_OPEN:
+				{//WEP Open
+					authtype = 0;
+					//WEP encmode depends on key length
+					//encmode = 1;
+					pskenable = 0;
+					dot11802_1x = 0;
+					rtl_net80311_authmode(dev, authtype, encmode, pskenable, dot11802_1x);
+					break;
+				}
+			case IEEE80211_AUTH_SHARED:
+				{//WEP Shared
+					authtype = 1;
+					//WEP encmode depends on key length
+					//encmode = 1;
+					pskenable = 0;
+					dot11802_1x = 0;
+					rtl_net80311_authmode(dev, authtype, encmode, pskenable, dot11802_1x);
+					break;
+				}
+			case IEEE80211_AUTH_AUTO:
+				{//WEP Auto
+					authtype = 2;
+					//WEP encmode depends on key length
+					//encmode = 1;
+					pskenable = 0;
+					dot11802_1x = 0;
+					rtl_net80311_authmode(dev, authtype, encmode, pskenable, dot11802_1x);
+					break;
+				}
+			case IEEE80211_AUTH_WPA:
+				{//WPA-PSK-AES
+				 //_Eric ?? if there is no valid passphrase ??
+				 	authtype = 2;
+					encmode = 2;
+					//_Eric pskmode (WPA 0,1,2) will be set by IEEE80211_PARAM_WPA
+					//pskenable = 1;
+					dot11802_1x = 1;
+					rtl_net80311_authmode(dev, authtype, encmode, pskenable, dot11802_1x);
+					break;
+				}
+			case IEEE80211_AUTH_8021X:
+				{
+					//8021x encmode depends on key length
+					if((encmode == _WEP_40_PRIVACY_) || (encmode == _WEP_104_PRIVACY_))
+						authtype = 2;
+					else
+						authtype = 0;
+
+					pskenable = 0;
+					dot11802_1x = 1;
+					rtl_net80311_authmode(dev, authtype, encmode, pskenable, dot11802_1x);
+					break;
+				}
+			default:
+					return -EINVAL;
+			}
+		case IEEE80211_PARAM_PROTMODE:		/* 802.11g protection */
+			break;
+		case IEEE80211_PARAM_MCASTCIPHER:		/* multicast/default cipher */
+			break;
+		case IEEE80211_PARAM_MCASTKEYLEN:		/* multicast key length */
+			break;
+		case IEEE80211_PARAM_UCASTCIPHERS:		/* unicast cipher suites */
+			/*	1. Only support AES & TKIP for WPA1&WPA2
+			  	2. Set both wpa_cipher and wpa2_cipher, because IEEE80211_PARAM_WPA will clear unused cipher mode		*/
+			HAPD_MSG("IEEE80211_PARAM_UCASTCIPHERS\n");
+
+			if(value & (1<<IEEE80211_CIPHER_WEP))
+				return -EINVAL;
+			if(value & (1<<IEEE80211_CIPHER_AES_OCB))
+				return -EINVAL;
+			if(value & (1<<IEEE80211_CIPHER_CKIP))
+				return -EINVAL;
+			if(value & (1<<IEEE80211_CIPHER_NONE))
+				return -EINVAL;
+
+			if(value & (1<<IEEE80211_CIPHER_TKIP))
+				{
+					if((!(priv->pmib->dot11BssType.net_work_type & WIRELESS_11N)) || (OPMODE & WIFI_STATION_STATE))
+						{
+							priv->pmib->dot1180211AuthEntry.dot11WPACipher |= BIT(1);
+							priv->pmib->dot1180211AuthEntry.dot11WPA2Cipher |= BIT(1);
+						}
+					else
+						return -EINVAL;
+				}
+			else
+				{
+					priv->pmib->dot1180211AuthEntry.dot11WPACipher &= ~(BIT(1));
+					priv->pmib->dot1180211AuthEntry.dot11WPA2Cipher &= ~(BIT(1));
+				}
+			
+
+			if(value & (1<<IEEE80211_CIPHER_AES_CCM))
+				{
+					priv->pmib->dot1180211AuthEntry.dot11WPACipher |= BIT(3);
+					priv->pmib->dot1180211AuthEntry.dot11WPA2Cipher |= BIT(3);			
+				}
+			else
+				{
+					priv->pmib->dot1180211AuthEntry.dot11WPACipher &= ~(BIT(3));
+					priv->pmib->dot1180211AuthEntry.dot11WPA2Cipher &= ~(BIT(3));	
+				}
+
+			priv->pmib->dot118021xAuthEntry.dot118021xAlgrthm = 1;
+			
+			return 0; //_Eric if value > BIT(8) ?
+				
+		case IEEE80211_PARAM_UCASTCIPHER:		/* unicast cipher */
+			break;
+		case IEEE80211_PARAM_UCASTKEYLEN:		/* unicast key length */
+			if(value == 5)
+				priv->pmib->dot1180211AuthEntry.dot11PrivacyAlgrthm = _WEP_40_PRIVACY_;
+			else if(value == 13)
+				priv->pmib->dot1180211AuthEntry.dot11PrivacyAlgrthm = _WEP_104_PRIVACY_;
+			else 
+				priv->pmib->dot1180211AuthEntry.dot11PrivacyAlgrthm = _NO_PRIVACY_;
+			break;
+		case IEEE80211_PARAM_WPA:			/* WPA mode (0,1,2) */
+			HAPD_MSG("IEEE80211_PARAM_WPA\n");
+			if((value & BIT(0)) && (value & BIT(1)))
+				return 0;
+			else if((value & BIT(0)))
+				{//only WPA1, so clear mib of wpa2_cipher & wpa2_psk
+					priv->pmib->dot1180211AuthEntry.dot11WPA2Cipher = 0;
+					priv->pmib->dot1180211AuthEntry.dot11EnablePSK & ~(BIT(1));
+					return 0;
+				}
+			else if((value & BIT(1)))
+				{//only WPA2, so clear mib of wpa_cipher & wps2_psk
+					priv->pmib->dot1180211AuthEntry.dot11WPACipher = 0;
+					priv->pmib->dot1180211AuthEntry.dot11EnablePSK & ~(BIT(0));
+					return 0;
+				}
+			
+		case IEEE80211_PARAM_ROAMING:			/* roaming mode */
+#ifdef WIFI_WPAS
+			if(value == IEEE80211_ROAMING_DEVICE)
+				priv->pmib->dot11StationConfigEntry.fastRoaming = 1;
+			else if(value == IEEE80211_ROAMING_MANUAL)
+				priv->pmib->dot11StationConfigEntry.fastRoaming = 0;
+			else
+				return EINVAL;
+#endif
+			break;
+		case IEEE80211_PARAM_PRIVACY:			/* privacy invoked */
+			ret =0;	//It seems useless, just return status OK for hostapd.
+			break; 
+		case IEEE80211_PARAM_COUNTERMEASURES:		/* WPA/TKIP countermeasures */
+			//_Eric ?? realtek do not have to support ??
+			break;
+		case IEEE80211_PARAM_DROPUNENCRYPTED:		/* discard unencrypted frames */
+			break;
+		case IEEE80211_PARAM_DRIVER_CAPS:		/* driver capabilities */
+			break;
+		case IEEE80211_PARAM_MACCMD:			/* MAC ACL operation */
+			break;
+		case IEEE80211_PARAM_WMM:			/* WMM mode (on, off) */
+			break;
+		case IEEE80211_PARAM_HIDESSID:		/* hide SSID mode (on, off) */
+			break;
+		case IEEE80211_PARAM_APBRIDGE:   	   	/* AP inter-sta bridging */
+			break;
+		case IEEE80211_PARAM_KEYMGTALGS:		/* key management algorithms */
+			HAPD_MSG("IEEE80211_PARAM_KEYMGTALGS\n");
+			if((0<=value) && (value<=3))
+				{
+					priv->pmib->dot1180211AuthEntry.dot11EnablePSK = value;
+					break;
+				}
+			else
+				return EINVAL;
+		case IEEE80211_PARAM_RSNCAPS:			/* RSN capabilities */
+			break;
+		case IEEE80211_PARAM_INACT:			/* station inactivity timeout */
+			break;
+		case IEEE80211_PARAM_INACT_AUTH:		/* station auth inact timeout */
+			break;
+		case IEEE80211_PARAM_INACT_INIT:		/* station init inact timeout */
+			break;
+		case IEEE80211_PARAM_ABOLT:			/* Atheros Adv. Capabilities */
+			break;
+		case IEEE80211_PARAM_DTIM_PERIOD:		/* DTIM period (beacons) */
+			break;
+		case IEEE80211_PARAM_BEACON_INTERVAL:		/* beacon interval (ms) */
+			break;
+		case IEEE80211_PARAM_DOTH:			/* 11.h is on/off */
+			break;
+		case IEEE80211_PARAM_PWRTARGET:		/* Current Channel Pwr Constraint */
+			break;
+		case IEEE80211_PARAM_GENREASSOC:		/* Generate a reassociation request */
+			break;
+		case IEEE80211_PARAM_COMPRESSION:		/* compression */
+			break;
+		case IEEE80211_PARAM_FF:			/* fast frames support  */
+			break;
+		case IEEE80211_PARAM_XR:			/* XR support */
+			break;
+		case IEEE80211_PARAM_BURST:			/* burst mode */
+			break;
+		case IEEE80211_PARAM_PUREG:			/* pure 11g (no 11b stations) */
+			break;
+		case IEEE80211_PARAM_AR:			/* AR support */
+			break;
+		case IEEE80211_PARAM_WDS:			/* Enable 4 address processing */
+			break;
+		case IEEE80211_PARAM_BGSCAN:			/* bg scanning (on, off) */
+			break;
+		case IEEE80211_PARAM_BGSCAN_IDLE:		/* bg scan idle threshold */
+			break;
+		case IEEE80211_PARAM_BGSCAN_INTERVAL:		/* bg scan interval */
+			break;
+		case IEEE80211_PARAM_MCAST_RATE:		/* Multicast Tx Rate */
+			break;
+		case IEEE80211_PARAM_COVERAGE_CLASS:		/* coverage class */
+			break;
+		case IEEE80211_PARAM_COUNTRY_IE:		/* enable country IE */
+			break;
+		case IEEE80211_PARAM_SCANVALID:		/* scan cache valid threshold */
+			break;
+		case IEEE80211_PARAM_ROAM_RSSI_11A:		/* rssi threshold in 11a */
+			break;
+		case IEEE80211_PARAM_ROAM_RSSI_11B:		/* rssi threshold in 11b */
+			break;
+		case IEEE80211_PARAM_ROAM_RSSI_11G:		/* rssi threshold in 11g */
+			break;
+		case IEEE80211_PARAM_ROAM_RATE_11A:		/* tx rate threshold in 11a */
+			break;
+		case IEEE80211_PARAM_ROAM_RATE_11B:		/* tx rate threshold in 11b */
+			break;
+		case IEEE80211_PARAM_ROAM_RATE_11G:		/* tx rate threshold in 11g */
+			break;
+		case IEEE80211_PARAM_UAPSDINFO:		/* value for qos info field */
+			break;
+		case IEEE80211_PARAM_SLEEP:			/* force sleep/wake */
+			break;
+		case IEEE80211_PARAM_QOSNULL:			/* force sleep/wake */
+			break;
+		case IEEE80211_PARAM_PSPOLL:			/* force ps-poll generation (sta only) */
+			break;
+		case IEEE80211_PARAM_EOSPDROP:		/* force uapsd EOSP drop (ap only) */
+			break;
+		case IEEE80211_PARAM_MARKDFS:			/* mark a dfs interference channel when found */
+			break;
+		case IEEE80211_PARAM_REGCLASS:		/* enable regclass ids in country IE */
+			break;
+		case IEEE80211_PARAM_DROPUNENC_EAPOL:		/* drop unencrypted eapol frames */
+			break;
+	 	case IEEE80211_PARAM_SHPREAMBLE:		/* Short Preamble */
+			break;
+			
+	}
+
+	HAPD_MSG("rtl_net80211_setparam ---\n");
+	return ret;
+
+}
+
+/*
+Management frame type to which application IE is added 
+enum {
+	IEEE80211_APPIE_FRAME_BEACON		= 0,
+	IEEE80211_APPIE_FRAME_PROBE_REQ		= 1,
+	IEEE80211_APPIE_FRAME_PROBE_RESP	= 2,
+	IEEE80211_APPIE_FRAME_ASSOC_REQ		= 3,
+	IEEE80211_APPIE_FRAME_ASSOC_RESP	= 4,
+	IEEE80211_APPIE_NUM_OF_FRAME		= 5
+};
+*/
+
+int rtl_net80211_setappiebuf(struct net_device *dev, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)
+{
+#ifdef NETDEV_NO_PRIV
+	struct rtl8192cd_priv *priv = ((struct rtl8192cd_priv *)netdev_priv(dev))->wlan_priv;
+#else
+	struct rtl8192cd_priv	*priv = (struct rtl8192cd_priv *)dev->priv;
+#endif
+	struct ieee80211req_getset_appiebuf * ie = (struct ieee80211req_getset_appiebuf *)wrqu->data.pointer;
+	int ret = 0;
+
+	HAPD_MSG("rtl_net80211_setappiebuf +++\n");
+	HAPD_MSG("frametype =%d, iebuflen=%d \n", ie->app_frmtype, ie->app_buflen);
+
+	//_Eric ???? hostapd has no interface to set wsc_enable.
+
+	if((ie->app_buflen == 0) && (ie->app_frmtype != IEEE80211_APPIE_FRAME_ASSOC_RESP))
+		priv->pmib->wscEntry.wsc_enable = 0;
+	else if(ie->app_buflen <= 256)
+		priv->pmib->wscEntry.wsc_enable = 2; //Work as AP
+	else 
+		return -EINVAL;
+
+	if (ie->app_frmtype == IEEE80211_APPIE_FRAME_BEACON) {
+		HAPD_MSG("WSC: set beacon IE\n");
+		priv->pmib->wscEntry.beacon_ielen = ie->app_buflen;
+		memcpy((void *)priv->pmib->wscEntry.beacon_ie, ie->app_buf, ie->app_buflen);
+	}
+	else if (ie->app_frmtype == IEEE80211_APPIE_FRAME_PROBE_RESP) {
+		HAPD_MSG("WSC: set probe response IE\n");
+		priv->pmib->wscEntry.probe_rsp_ielen = ie->app_buflen;
+		memcpy((void *)priv->pmib->wscEntry.probe_rsp_ie, ie->app_buf, ie->app_buflen);
+	}
+	else if (ie->app_frmtype == IEEE80211_APPIE_FRAME_ASSOC_RESP) {
+		HAPD_MSG("WSC: set association response IE\n");
+		priv->pmib->wscEntry.assoc_ielen = ie->app_buflen;
+		memcpy((void *)priv->pmib->wscEntry.assoc_ie, ie->app_buf, ie->app_buflen);
+	}
+#ifdef WIFI_WPAS
+	else if (ie->app_frmtype == IEEE80211_APPIE_FRAME_PROBE_REQ) {
+		HAPD_MSG("WSC: set probe request IE\n");
+		priv->pmib->wscEntry.probe_req_ielen = ie->app_buflen;
+		memcpy((void *)priv->pmib->wscEntry.probe_req_ie, ie->app_buf, ie->app_buflen);
+	}
+#endif
+	else
+		return -EINVAL;
+
+
+	HAPD_MSG("rtl_net80211_setappiebuf ---\n");
+	return ret;
+
+}
+
+
+#ifdef WIFI_WPAS
+
+int rtl_net80211_setoptie(struct net_device *dev, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)
+{
+#ifdef NETDEV_NO_PRIV
+	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *)netdev_priv(dev);
+#else
+	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *)dev->priv;
+#endif
+	WPAS_ASSOCIATION_INFO Assoc_Info;
+
+//Check if WPS IE
+	UINT8 WSC_IE_OUI[4] = {0x00, 0x50, 0xf2, 0x04};
+	int x;
+	unsigned char *ie = (unsigned char *)wrqu->data.pointer;
+
+	if( ie[0] == _WPS_IE_)
+		if (!memcmp(ie+2, WSC_IE_OUI, 4)) 
+			{
+				priv->pmib->wscEntry.assoc_ielen = wrqu->data.length;
+				memcpy((void *)priv->pmib->wscEntry.assoc_ie, wrqu->data.pointer, wrqu->data.length);
+				priv->pmib->wscEntry.wsc_enable = 1;
+
+				return 0;
+			}
+
+	priv->pmib->wscEntry.wsc_enable = 0;
+
+	memset(priv->pmib->dot11RsnIE.rsnie, 0x0, 128);
+	memcpy(priv->pmib->dot11RsnIE.rsnie, wrqu->data.pointer, wrqu->data.length);
+	priv->pmib->dot11RsnIE.rsnielen = wrqu->data.length;
+	
+	memset((void *)&Assoc_Info, 0, sizeof(struct _WPAS_ASSOCIATION_INFO));
+	Assoc_Info.ReqIELen = priv->pmib->dot11RsnIE.rsnie[1]+ 2;
+	memcpy(Assoc_Info.ReqIE, priv->pmib->dot11RsnIE.rsnie, Assoc_Info.ReqIELen);
+	//event_indicate_wpas(priv, NULL, WPAS_ASSOC_INFO, (UINT8 *)&Assoc_Info);
+
+	return 0;
+	
+}
+
+#endif
+
+int rtl_net80211_setmlme(struct net_device *dev, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)
+{
+#ifdef NETDEV_NO_PRIV
+	struct rtl8192cd_priv *priv = ((struct rtl8192cd_priv *)netdev_priv(dev))->wlan_priv;
+#else
+	struct rtl8192cd_priv	*priv = (struct rtl8192cd_priv *)dev->priv;
+#endif
+	struct ieee80211req_mlme *mlme = (struct ieee80211req_key *)wrqu->data.pointer;
+	struct stat_info *pstat = get_stainfo(priv, mlme->im_macaddr);
+			
+	int ret = 0;
+
+	HAPD_MSG("rtl_net80211_setmlme +++\n");
+	HAPD_MSG("auth_state =%d, mac = 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n"
+			, mlme->im_op, mlme->im_macaddr[0], mlme->im_macaddr[1], mlme->im_macaddr[2], 
+				mlme->im_macaddr[3], mlme->im_macaddr[4], mlme->im_macaddr[5]);
+
+	//_Eric ????
+
+	if(mlme->im_op == IEEE80211_MLME_AUTHORIZE)
+		{
+				
+			if (pstat == NULL){
+				pstat = alloc_stainfo(priv, mlme->im_macaddr, -1);
+				if (pstat == NULL) {
+					printk("Exceed the upper limit of supported clients...\n");
+					return -1;
+				}
+				init_stainfo(priv, pstat);
+				pstat->state |= (WIFI_AUTH_SUCCESS | WIFI_ASOC_STATE);
+			pstat->expire_to = priv->assoc_to;
+				list_add_tail(&(pstat->asoc_list), &(priv->asoc_list));	
+			}
+
+			HAPD_Process_Set_Port(dev, mlme->im_macaddr ,DOT11_PortStatus_Authorized);
+
+		}
+	else if(mlme->im_op == IEEE80211_MLME_UNAUTHORIZE)
+		{	
+			if (pstat == NULL)
+			return -EINVAL;
+
+			//pstat->state |= WIFI_AUTH_NULL;
+
+			HAPD_Process_Set_Port(dev, mlme->im_macaddr ,DOT11_PortStatus_Authorized);
+
+		}
+	else if(mlme->im_op == IEEE80211_MLME_DISASSOC)
+		{	
+			if (pstat == NULL)
+			return -EINVAL;
+
+#ifdef WIFI_WPAS
+						
+			if(OPMODE & WIFI_STATION_STATE)
+			{
+				HAPD_MSG("An AP is disconnected by WPAS \n");
+				issue_disassoc(priv, mlme->im_macaddr, _RSON_UNSPECIFIED_);
+			
+				if (pstat->expire_to > 0)
+				{
+					cnt_assoc_num(priv, pstat, DECREASE, (char *)__FUNCTION__);
+#ifdef CONFIG_RTL_88E_SUPPORT
+					if (GET_CHIP_VER(priv)!=VERSION_8188E) 
+#endif
+						check_sta_characteristic(priv, pstat, DECREASE);
+				}
+			
+				free_stainfo(priv, pstat);
+				memset(&priv->pmib->dot11Bss, 0, sizeof(struct bss_desc));
+				memset(priv->pmib->dot11StationConfigEntry.dot11Bssid, 0, MACADDRLEN);
+				memset(priv->pmib->dot11StationConfigEntry.dot11DesiredSSID, 0, sizeof(priv->pmib->dot11StationConfigEntry.dot11DesiredSSID));
+				priv->pmib->dot11StationConfigEntry.dot11DesiredSSIDLen = 0;
+				memset(priv->pmib->dot11StationConfigEntry.dot11DefaultSSID, 0, sizeof(priv->pmib->dot11StationConfigEntry.dot11DesiredSSID));
+				priv->pmib->dot11StationConfigEntry.dot11DefaultSSIDLen = 0;
+				memset(priv->pmib->dot11StationConfigEntry.dot11SSIDtoScan, 0, sizeof(priv->pmib->dot11StationConfigEntry.dot11SSIDtoScan));
+				priv->pmib->dot11StationConfigEntry.dot11SSIDtoScanLen = 0;
+				memset(priv->pmib->dot11StationConfigEntry.dot11DesiredBssid, 0, 6);
+
+				priv->wpas_manual_assoc = 1; //_Eric ??  when to let driver auto-connect ??
+
+				priv->join_res = STATE_Sta_No_Bss;
+				pstat->state &= (~WIFI_ASOC_STATE);
+				return ret; 
+			}
+					
+#endif
+
+
+			if (!list_empty(&pstat->asoc_list))
+			{
+				list_del_init(&pstat->asoc_list);
+				if (pstat->expire_to > 0)
+				{
+					cnt_assoc_num(priv, pstat, DECREASE, (char *)__FUNCTION__);
+#ifdef CONFIG_RTL_88E_SUPPORT
+					if (GET_CHIP_VER(priv)!=VERSION_8188E) 
+#endif
+						check_sta_characteristic(priv, pstat, DECREASE);
+				}
+			}
+
+			// Need change state back to autehnticated
+			release_stainfo(priv, pstat);
+			init_stainfo(priv, pstat);
+			pstat->state |= WIFI_AUTH_SUCCESS;
+			pstat->expire_to = priv->assoc_to;
+			list_add_tail(&(pstat->auth_list), &(priv->auth_list));
+
+		}
+	else if(mlme->im_op == IEEE80211_MLME_DEAUTH)
+		{
+			unsigned char	MULTICAST_ADD[6]={0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
+
+			if(!memcmp(mlme->im_macaddr, MULTICAST_ADD, 6)) //_Eric ??How to free all stainfo??
+				return 0;
+			
+			if (pstat == NULL)
+			return -EINVAL;
+			
+			if (!list_empty(&pstat->asoc_list))
+			{
+				list_del_init(&pstat->asoc_list);
+				if (pstat->expire_to > 0)
+				{
+					cnt_assoc_num(priv, pstat, DECREASE, (char *)__FUNCTION__);
+#ifdef CONFIG_RTL_88E_SUPPORT
+					if (GET_CHIP_VER(priv)!=VERSION_8188E) 
+#endif
+						check_sta_characteristic(priv, pstat, DECREASE);
+				}
+			}
+			
+			release_stainfo(priv, pstat);
+
+		}
+#ifdef WIFI_WPAS
+	else if(mlme->im_op == IEEE80211_MLME_ASSOC)
+		{
+			int ix = 0, found = 0;
+
+			if((OPMODE & WIFI_STATION_STATE) == 0)
+				{
+					HAPD_MSG("NOT in Client Mode, can NOT Associate !!!\n");
+					return -1;
+				}
+			
+			for(ix = 0 ; ix < priv->site_survey.count_backup ; ix++) //_Eric ?? will bss_backup be cleaned?? -> Not found in  codes
+			{	
+				if(!memcmp(priv->site_survey.bss_backup[ix].bssid , mlme->im_macaddr, 6))
+				{
+					found = 1;
+					break;
+				}
+			}
+
+			if(found == 0)
+			{	
+				printk("BSSID NOT Found !!\n");
+				return -EINVAL;
+			}
+			else
+				ret = rtl_wpas_join(priv, ix);
+
+			if(ret != 0)
+				printk("rtl_wpas_join Failed !!\n");
+		
+		}
+#endif
+	else
+		{
+			HAPD_MSG("unknown auth_state !!!\n");
+			return -EINVAL;
+		}
+		
+	HAPD_MSG("rtl_net80211_setmlme ---\n");
+	return ret;
+
+
+}
+
+
+int rtl_net80211_setkey(struct net_device *dev, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)
+{
+#ifdef NETDEV_NO_PRIV
+	struct rtl8192cd_priv *priv = ((struct rtl8192cd_priv *)netdev_priv(dev))->wlan_priv;
+#else
+	struct rtl8192cd_priv	*priv = (struct rtl8192cd_priv *)dev->priv;
+#endif
+	struct ieee80211req_key *wk = (struct ieee80211req_key *)wrqu->data.pointer;
+	struct wifi_mib	*pmib = priv->pmib;
+	struct Dot11EncryptKey	*pEncryptKey = NULL;
+	struct stat_info	*pstat = NULL;
+	unsigned char	MULTICAST_ADD[6]={0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
+#ifdef WIFI_WPAS
+	unsigned char	GROUP_ADD[6]={0x0,0x0,0x0,0x0,0x0,0x0};
+#endif
+	int cipher =0;
+	int retVal = 0;
+	int group_key = 0;
+
+	HAPD_MSG("rtl_net80211_setkey +++\n");
+
+
+	HAPD_MSG("keyid = %d, mac = 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n"
+			, wk->ik_keyix, wk->ik_macaddr[0], wk->ik_macaddr[1], wk->ik_macaddr[2], 
+				wk->ik_macaddr[3], wk->ik_macaddr[4], wk->ik_macaddr[5]);
+	HAPD_MSG("type = 0x%x, flags = 0x%x, keylen = 0x%x \n"
+			, wk->ik_type, wk->ik_flags, wk->ik_keylen);
+
+
+	//check if the interface is down
+	if (!netif_running(priv->dev))
+	{	
+		if(wk->ik_type == IEEE80211_CIPHER_WEP)
+		{
+			HAPD_MSG("set WEP Key in driver DOWN\n");
+			memcpy(&priv->pmib->dot11DefaultKeysTable.keytype[wk->ik_keyix].skey[0], wk->ik_keydata, wk->ik_keylen);
+			return 0;
+		}
+
+		HAPD_MSG("\nFail: interface not opened\n");
+		return 0;
+	}
+
+	if(!memcmp(wk->ik_macaddr, MULTICAST_ADD, 6))
+		group_key = 1;
+
+#ifdef WIFI_WPAS //_Eric ?? if oxff not group addr in wpas ??
+	if(OPMODE & WIFI_STATION_STATE)
+		if(!memcmp(wk->ik_macaddr, GROUP_ADD, 6))
+			group_key = 1;
+#endif
+
+	if(wk->ik_type == IEEE80211_CIPHER_WEP)
+		{
+
+#ifdef WIFI_WPAS
+		   if(OPMODE & WIFI_STATION_STATE)
+		   	if(priv->pmib->dot118021xAuthEntry.dot118021xAlgrthm == 0)
+		   	{
+		   		memcpy(&priv->pmib->dot11DefaultKeysTable.keytype[wk->ik_keyix].skey[0], wk->ik_keydata, wk->ik_keylen);
+				return 0;
+		   	}
+#endif
+		   if(priv->pmib->dot1180211AuthEntry.dot11PrivacyAlgrthm == _WEP_40_PRIVACY_)
+		   	cipher = (DOT11_ENC_WEP40);
+		   else if(priv->pmib->dot1180211AuthEntry.dot11PrivacyAlgrthm == _WEP_104_PRIVACY_)
+		   	cipher = (DOT11_ENC_WEP104);
+		   else
+		   	return -EINVAL;
+		}
+	else if(wk->ik_type == IEEE80211_CIPHER_TKIP)
+		cipher = (DOT11_ENC_TKIP);
+	else if(wk->ik_type == IEEE80211_CIPHER_AES_CCM)
+		cipher = (DOT11_ENC_CCMP);
+	else
+		{
+			HAPD_MSG("unknown encAlg !!!\n");
+			return -EINVAL;
+		}
+
+	//_Eric ?? if call DOT11_Process_Set_Key
+	//CamAddOneEntry(priv, wk->ik_macaddr, wk->ik_keyix, cipher, 0, wk->ik_keydata);
+
+	if(group_key)
+	{
+		int set_gkey_to_cam = 1;
+		HAPD_MSG("set group key !!\n");
+
+#ifdef UNIVERSAL_REPEATER
+		if (IS_VXD_INTERFACE(priv))
+			set_gkey_to_cam = 0;
+		else {
+			if (IS_ROOT_INTERFACE(priv)) {
+				if (IS_DRV_OPEN(GET_VXD_PRIV(priv)))
+					set_gkey_to_cam = 0;
+			}
+		}
+#endif
+
+#ifdef MBSSID
+		if (GET_ROOT(priv)->pmib->miscEntry.vap_enable)
+		{
+			// No matter root or vap, don't set key to cam if vap is enabled.
+			set_gkey_to_cam = 0;
+		}
+#endif
+
+#ifdef CONFIG_RTK_MESH
+		//modify by Joule for SECURITY
+		if (dev == priv->mesh_dev)
+		{
+			pmib->dot11sKeysTable.dot11Privacy = cipher;
+			pEncryptKey = &pmib->dot11sKeysTable.dot11EncryptKey;
+			pmib->dot11sKeysTable.keyid = (UINT)wk->ik_keyix;
+		}
+		else
+#endif
+		{
+			pmib->dot11GroupKeysTable.dot11Privacy = cipher;
+			pEncryptKey = &pmib->dot11GroupKeysTable.dot11EncryptKey;
+			pmib->dot11GroupKeysTable.keyid = (UINT)wk->ik_keyix;
+		}
+
+		switch(cipher)
+		{
+		case DOT11_ENC_TKIP:
+			set_ttkeylen(pEncryptKey, 16);
+			set_tmickeylen(pEncryptKey, 8);
+			set_tkip_key(pEncryptKey, wk->ik_keydata);
+
+			HAPD_MSG("going to set TKIP group key! id %X\n", (UINT)wk->ik_keyix);
+			if (!SWCRYPTO) {
+				if (set_gkey_to_cam)
+				{
+					retVal = CamDeleteOneEntry(priv, MULTICAST_ADD, wk->ik_keyix, 0);
+					if (retVal) {
+						priv->pshare->CamEntryOccupied--;
+						pmib->dot11GroupKeysTable.keyInCam = FALSE;
+					}
+					retVal = CamAddOneEntry(priv, MULTICAST_ADD, wk->ik_keyix, DOT11_ENC_TKIP<<2, 0, wk->ik_keydata);
+					if (retVal) {
+						priv->pshare->CamEntryOccupied++;
+						pmib->dot11GroupKeysTable.keyInCam = TRUE;
+					}
+				}
+			}
+			break;
+
+		case DOT11_ENC_WEP40:
+			set_ttkeylen(pEncryptKey, 5);
+			set_tmickeylen(pEncryptKey, 0);
+			set_wep40_key(pEncryptKey, wk->ik_keydata);
+
+			HAPD_MSG("going to set WEP40 group key!\n");
+			if (!SWCRYPTO) {
+				if (set_gkey_to_cam)
+				{
+					retVal = CamDeleteOneEntry(priv, MULTICAST_ADD, wk->ik_keyix, 0);
+					if (retVal) {
+						priv->pshare->CamEntryOccupied--;
+						pmib->dot11GroupKeysTable.keyInCam = FALSE;
+					}
+					retVal = CamAddOneEntry(priv, MULTICAST_ADD, wk->ik_keyix, DOT11_ENC_WEP40<<2, 0, wk->ik_keydata);
+					if (retVal) {
+						priv->pshare->CamEntryOccupied++;
+						pmib->dot11GroupKeysTable.keyInCam = TRUE;
+					}
+				}
+			}
+			break;
+
+		case DOT11_ENC_WEP104:
+			set_ttkeylen(pEncryptKey, 13);
+			set_tmickeylen(pEncryptKey, 0);
+			set_wep104_key(pEncryptKey, wk->ik_keydata);
+
+			HAPD_MSG("going to set WEP104 group key!\n");
+			if (!SWCRYPTO) {
+				if (set_gkey_to_cam)
+				{
+					retVal = CamDeleteOneEntry(priv, MULTICAST_ADD, wk->ik_keyix, 0);
+					if (retVal) {
+						priv->pshare->CamEntryOccupied--;
+						pmib->dot11GroupKeysTable.keyInCam = FALSE;
+					}
+					retVal = CamAddOneEntry(priv, MULTICAST_ADD, wk->ik_keyix, DOT11_ENC_WEP104<<2, 0, wk->ik_keydata);
+					if (retVal) {
+						priv->pshare->CamEntryOccupied++;
+						pmib->dot11GroupKeysTable.keyInCam = TRUE;
+					}
+				}
+			}
+			break;
+
+		case DOT11_ENC_CCMP:
+			set_ttkeylen(pEncryptKey, 16);
+			set_tmickeylen(pEncryptKey, 16);
+			set_aes_key(pEncryptKey, wk->ik_keydata);
+
+			HAPD_MSG("going to set CCMP-AES group key!\n");
+#ifdef CONFIG_RTK_MESH
+			if (dev == priv->mesh_dev)
+				pmib->dot11sKeysTable.keyInCam = TRUE;		// keyInCam means key in driver
+			else
+#endif
+			if (!SWCRYPTO) {
+				if (set_gkey_to_cam)
+				{
+					retVal = CamDeleteOneEntry(priv, MULTICAST_ADD, wk->ik_keyix, 0);
+					if (retVal) {
+						priv->pshare->CamEntryOccupied--;
+						pmib->dot11GroupKeysTable.keyInCam = FALSE;
+					}
+					retVal = CamAddOneEntry(priv, MULTICAST_ADD, wk->ik_keyix, DOT11_ENC_CCMP<<2, 0, wk->ik_keydata);
+					if (retVal) {
+						priv->pshare->CamEntryOccupied++;
+						pmib->dot11GroupKeysTable.keyInCam = TRUE;
+					}
+				}
+			}
+			break;
+
+		case DOT11_ENC_NONE:
+		default:
+			HAPD_MSG("No group encryption key is set!\n");
+			set_ttkeylen(pEncryptKey, 0);
+			set_tmickeylen(pEncryptKey, 0);
+			break;
+		}
+	}
+	else
+	{
+		pstat = get_stainfo(priv, wk->ik_macaddr);
+		if (pstat == NULL) {
+			DEBUG_ERR("Set key failed, invalid mac address: %02x%02x%02x%02x%02x%02x\n",
+				wk->ik_macaddr[0], wk->ik_macaddr[1], wk->ik_macaddr[2], wk->ik_macaddr[3],
+				wk->ik_macaddr[4], wk->ik_macaddr[5]);
+			return (-1);
+		}
+
+		pstat->dot11KeyMapping.dot11Privacy = cipher;
+		pEncryptKey = &pstat->dot11KeyMapping.dot11EncryptKey;
+		pstat->keyid = wk->ik_keyix;
+
+#if defined(__DRAYTEK_OS__) && defined(WDS)
+		if (pstat->state & WIFI_WDS)
+			priv->pmib->dot11WdsInfo.wdsPrivacy = cipher;
+#endif
+
+		switch(cipher)
+		{
+		case DOT11_ENC_TKIP:
+			set_ttkeylen(pEncryptKey, 16);
+			set_tmickeylen(pEncryptKey, 8);
+			set_tkip_key(pEncryptKey, wk->ik_keydata);
+
+			HAPD_MSG("going to set TKIP Unicast key for sta %02X%02X%02X%02X%02X%02X, id=%d\n",
+				wk->ik_macaddr[0], wk->ik_macaddr[1], wk->ik_macaddr[2],
+				wk->ik_macaddr[3], wk->ik_macaddr[4], wk->ik_macaddr[5], pstat->keyid);
+			if (!SWCRYPTO) {
+				retVal = CamDeleteOneEntry(priv, wk->ik_macaddr, wk->ik_keyix, 0);
+				if (retVal) {
+					priv->pshare->CamEntryOccupied--;
+					if (pstat)	pstat->dot11KeyMapping.keyInCam = FALSE;
+				}
+				retVal = CamAddOneEntry(priv, wk->ik_macaddr, wk->ik_keyix, DOT11_ENC_TKIP<<2, 0, wk->ik_keydata);
+				if (retVal) {
+					priv->pshare->CamEntryOccupied++;
+					if (pstat)	pstat->dot11KeyMapping.keyInCam = TRUE;
+				}
+				else {
+					if (pstat->aggre_mthd != AGGRE_MTHD_NONE)
+						pstat->aggre_mthd = AGGRE_MTHD_NONE;
+				}
+			}
+			break;
+
+		case DOT11_ENC_WEP40:
+			set_ttkeylen(pEncryptKey, 5);
+			set_tmickeylen(pEncryptKey, 0);
+			set_wep40_key(pEncryptKey, wk->ik_keydata);
+
+			HAPD_MSG("going to set WEP40 unicast key for sta %02X%02X%02X%02X%02X%02X, id=%d\n",
+				wk->ik_macaddr[0], wk->ik_macaddr[1], wk->ik_macaddr[2],
+				wk->ik_macaddr[3], wk->ik_macaddr[4], wk->ik_macaddr[5], pstat->keyid);
+			if (!SWCRYPTO) {
+				retVal = CamDeleteOneEntry(priv, wk->ik_macaddr, wk->ik_keyix, 0);
+				if (retVal) {
+					priv->pshare->CamEntryOccupied--;
+					if (pstat)	pstat->dot11KeyMapping.keyInCam = FALSE;
+				}
+				retVal = CamAddOneEntry(priv, wk->ik_macaddr, wk->ik_keyix, DOT11_ENC_WEP40<<2, 0, wk->ik_keydata);
+				if (retVal) {
+					priv->pshare->CamEntryOccupied++;
+					if (pstat)	pstat->dot11KeyMapping.keyInCam = TRUE;
+				}
+				else {
+					if (pstat->aggre_mthd != AGGRE_MTHD_NONE)
+						pstat->aggre_mthd = AGGRE_MTHD_NONE;
+				}
+			}
+			break;
+
+		case DOT11_ENC_WEP104:
+			set_ttkeylen(pEncryptKey, 13);
+			set_tmickeylen(pEncryptKey, 0);
+			set_wep104_key(pEncryptKey, wk->ik_keydata);
+
+			HAPD_MSG("going to set WEP104 unicast key for sta %02X%02X%02X%02X%02X%02X, id=%d\n",
+				wk->ik_macaddr[0], wk->ik_macaddr[1], wk->ik_macaddr[2],
+				wk->ik_macaddr[3], wk->ik_macaddr[4], wk->ik_macaddr[5], pstat->keyid);
+			if (!SWCRYPTO) {
+				retVal = CamDeleteOneEntry(priv, wk->ik_macaddr, wk->ik_keyix, 0);
+				if (retVal) {
+					priv->pshare->CamEntryOccupied--;
+					if (pstat)	pstat->dot11KeyMapping.keyInCam = FALSE;
+				}
+				retVal = CamAddOneEntry(priv, wk->ik_macaddr, wk->ik_keyix, DOT11_ENC_WEP104<<2, 0, wk->ik_keydata);
+				if (retVal) {
+					priv->pshare->CamEntryOccupied++;
+					if (pstat)	pstat->dot11KeyMapping.keyInCam = TRUE;
+				}
+				else {
+					if (pstat->aggre_mthd != AGGRE_MTHD_NONE)
+						pstat->aggre_mthd = AGGRE_MTHD_NONE;
+				}
+			}
+			break;
+
+		case DOT11_ENC_CCMP:
+			set_ttkeylen(pEncryptKey, 16);
+			set_tmickeylen(pEncryptKey, 16);
+			set_aes_key(pEncryptKey, wk->ik_keydata);
+
+			HAPD_MSG("going to set CCMP-AES unicast key for sta %02X%02X%02X%02X%02X%02X, id=%d\n",
+				wk->ik_macaddr[0], wk->ik_macaddr[1], wk->ik_macaddr[2],
+				wk->ik_macaddr[3], wk->ik_macaddr[4], wk->ik_macaddr[5], pstat->keyid);
+			if (!SWCRYPTO) {
+				retVal = CamDeleteOneEntry(priv, wk->ik_macaddr, wk->ik_keyix, 0);
+				if (retVal) {
+					priv->pshare->CamEntryOccupied--;
+					if (pstat)	pstat->dot11KeyMapping.keyInCam = FALSE;
+				}
+				retVal = CamAddOneEntry(priv, wk->ik_macaddr, wk->ik_keyix, DOT11_ENC_CCMP<<2, 0, wk->ik_keydata);
+				if (retVal) {
+					HAPD_MSG("CamAddOneEntry of CCMP OK\n");
+					priv->pshare->CamEntryOccupied++;
+					if (pstat)	pstat->dot11KeyMapping.keyInCam = TRUE;
+					assign_aggre_mthod(priv, pstat);
+				}
+				else {
+					HAPD_MSG("CamAddOneEntry of CCMP FAIL\n");
+					if (pstat->aggre_mthd != AGGRE_MTHD_NONE)
+						pstat->aggre_mthd = AGGRE_MTHD_NONE;
+				}
+			}
+			break;
+
+		case DOT11_ENC_NONE:
+		default:
+			DEBUG_ERR("No pairewise encryption key is set!\n");
+			set_ttkeylen(pEncryptKey, 0);
+			set_tmickeylen(pEncryptKey, 0);
+			break;
+		}
+	}
+
+
+	HAPD_MSG("rtl_net80211_setkey ---\n");
+	
+	return 0;
+
+
+
+}
+
+int rtl_net80211_delkey(struct net_device *dev, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)
+{
+#ifdef NETDEV_NO_PRIV
+	struct rtl8192cd_priv *priv = ((struct rtl8192cd_priv *)netdev_priv(dev))->wlan_priv;
+#else
+	struct rtl8192cd_priv	*priv = (struct rtl8192cd_priv *)dev->priv;
+#endif
+	struct ieee80211req_del_key *wk = (struct ieee80211req_del_key *)wrqu->name;
+	struct stat_info	*pstat = NULL;
+	struct wifi_mib 	*pmib = priv->pmib;
+
+	unsigned char MULTICAST_ADD[6]={0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
+	int ret = 0;
+
+	//check if the interface is down
+	if (!netif_running(priv->dev))
+	{
+		HAPD_MSG("\nFail: interface not opened\n");
+		return 0;
+	}
+
+	HAPD_MSG("rtl_net80211_delkey +++ \n");
+	HAPD_MSG("keyid = %d, mac = 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n"
+			, wk->idk_keyix, wk->idk_macaddr[0], wk->idk_macaddr[1], wk->idk_macaddr[2], 
+				wk->idk_macaddr[3], wk->idk_macaddr[4], wk->idk_macaddr[5]);
+
+	if(!memcmp(wk->idk_macaddr, "\x00\x00\x00\x00\x00\x00", 6))
+		{
+			HAPD_MSG("reset ALL key !!!!!\n");
+			CamResetAllEntry(priv);
+		}
+
+	if (!memcmp(wk->idk_macaddr, MULTICAST_ADD, 6))
+	{
+		pmib->dot11GroupKeysTable.dot11EncryptKey.dot11TTKeyLen = 0;
+		pmib->dot11GroupKeysTable.dot11EncryptKey.dot11TMicKeyLen = 0;
+
+		HAPD_MSG("Delete Group Key\n");
+		if (CamDeleteOneEntry(priv, MULTICAST_ADD, 1, 0))
+			priv->pshare->CamEntryOccupied--;
+		#if defined(CONFIG_RTL_HW_WAPI_SUPPORT)
+		if (CamDeleteOneEntry(priv, MULTICAST_ADD, 1, 0))
+			priv->pshare->CamEntryOccupied--;
+		#endif
+
+	}
+	else
+	{
+		pstat = get_stainfo(priv, (UINT8 *)wk->idk_macaddr);
+		if (pstat == NULL)
+			return (-1);
+
+		pstat->dot11KeyMapping.dot11EncryptKey.dot11TTKeyLen = 0;
+		pstat->dot11KeyMapping.dot11EncryptKey.dot11TMicKeyLen = 0;
+
+		HAPD_MSG("Delete Unicast Key\n");
+		if (pstat->dot11KeyMapping.keyInCam == TRUE) {
+			if (CamDeleteOneEntry(priv, (unsigned char *)wk->idk_macaddr, 0, 0)) {
+				priv->pshare->CamEntryOccupied--;
+				if (pstat)	pstat->dot11KeyMapping.keyInCam = FALSE;
+			}
+			#if defined(CONFIG_RTL_HW_WAPI_SUPPORT)
+			if (CamDeleteOneEntry(priv, (unsigned char *)wk->idk_macaddr, 0, 0)) {
+				priv->pshare->CamEntryOccupied--;
+				if (pstat)	pstat->dot11KeyMapping.keyInCam = FALSE;
+			}
+			#endif
+		}
+	}
+
+	HAPD_MSG("rtl_net80211_delkey --- \n");
+
+	return ret;
+
+
+}
+
+int rtl_net80211_getwpaie(struct net_device *dev, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)
+{
+#ifdef NETDEV_NO_PRIV
+	struct rtl8192cd_priv *priv = ((struct rtl8192cd_priv *)netdev_priv(dev))->wlan_priv;
+#else
+	struct rtl8192cd_priv	*priv = (struct rtl8192cd_priv *)dev->priv;
+#endif
+	struct ieee80211req_wpaie *ie = (struct ieee80211req_wpaie *)wrqu->data.pointer;
+	struct stat_info *pstat = get_stainfo(priv, ie->wpa_macaddr);
+	int ret = 0;
+	HAPD_MSG("rtl_net80211_getwpaie +++ \n");
+	HAPD_MSG("mac =  0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n",
+			ie->wpa_macaddr[0], ie->wpa_macaddr[1], ie->wpa_macaddr[2],
+			ie->wpa_macaddr[3], ie->wpa_macaddr[4], ie->wpa_macaddr[5]);	
+
+	if(pstat == NULL)
+		return -EINVAL;
+	
+#ifndef HAPD_DRV_PSK_WPS
+	HAPD_MSG("RSNEnabled = %d\n"
+			"wpa_ie = 0x%02x 0x%02x 0x%02x \n"
+			"wps_ie = 0x%02x 0x%02x 0x%02x \n" 
+			,pstat->wpa_sta_info->RSNEnabled,
+			pstat->wpa_ie[0], pstat->wpa_ie[1], pstat->wpa_ie[2], 
+			pstat->wps_ie[0], pstat->wps_ie[1], pstat->wps_ie[2]
+			);
+#else
+	HAPD_MSG("RSNEnabled = %d\n"
+			"wpa_ie = 0x%02x 0x%02x 0x%02x \n"
+			,pstat->wpa_sta_info->RSNEnabled,
+			pstat->wpa_ie[0], pstat->wpa_ie[1], pstat->wpa_ie[2]
+			);
+#endif
+
+	if(pstat->wpa_sta_info->RSNEnabled & BIT(0))
+		memcpy(ie->wpa_ie, pstat->wpa_ie, pstat->wpa_ie[1]+2);
+	else if(pstat->wpa_sta_info->RSNEnabled & BIT(1))
+		memcpy(ie->rsn_ie, pstat->wpa_ie, pstat->wpa_ie[1]+2);
+
+#ifndef HAPD_DRV_PSK_WPS
+	if((priv->pmib->wscEntry.wsc_enable & 2) && (pstat->wps_ie[1]))
+		memcpy(ie->wps_ie, pstat->wps_ie, pstat->wps_ie[1]+2);
+#endif
+
+	HAPD_MSG("rtl_net80211_getwpaie --- \n");
+	return ret;
+	
+}
+
+
+#if	(defined(WIFI_HAPD) && defined(WDS)) && !defined(HAPD_DRV_PSK_WPS)
+int rtl_net80211_wdsaddmac(struct net_device *dev, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)
+{
+#ifdef NETDEV_NO_PRIV
+	struct rtl8192cd_priv *priv = ((struct rtl8192cd_priv *)netdev_priv(dev))->wlan_priv;
+#else
+	struct rtl8192cd_priv	*priv = (struct rtl8192cd_priv *)dev->priv;
+#endif
+	struct rtk_wds_config *wds = (struct hapd_wds_info *)wrqu->data.pointer;
+	int ret = 0;
+	int num = 0;
+	
+	HAPD_MSG("rtl_net80211_wdsaddmac +++ \n");	
+
+	if(wds->wdsEnabled == 0)
+		goto bad;
+	if(wds->wdsNum > NUM_WDS)
+		goto bad;
+	if( (wds->wdsPrivacy != _NO_PRIVACY_) && (wds->wdsPrivacy != _WEP_40_PRIVACY_) &&
+		(wds->wdsPrivacy != _TKIP_PRIVACY_) && (wds->wdsPrivacy != _CCMP_PRIVACY_) &&
+		(wds->wdsPrivacy != _WEP_104_PRIVACY_))
+		goto bad;
+	
+	if((wds->wdsPrivacy == _WEP_40_PRIVACY_) && (wds->wdsWepKeyLen != 5))
+		goto bad;
+	if((wds->wdsPrivacy == _WEP_104_PRIVACY_) && (wds->wdsWepKeyLen != 13))
+		goto bad;
+	
+	priv->pmib->dot11WdsInfo.wdsEnabled = 1;
+	priv->pmib->dot11WdsInfo.wdsNum = wds->wdsNum;
+		
+	for(num=0 ; num < wds->wdsNum; num++)
+		memcpy(priv->pmib->dot11WdsInfo.entry[num].macAddr, wds->macAddr[num], MACADDRLEN);
+
+	priv->pmib->dot11WdsInfo.wdsPrivacy = wds->wdsPrivacy;
+
+	if((wds->wdsPrivacy == _WEP_40_PRIVACY_)||(wds->wdsPrivacy == _WEP_104_PRIVACY_))
+			memcpy(priv->pmib->dot11WdsInfo.wdsWepKey, wds->wdsWepKey, wds->wdsWepKeyLen);
+	else if((wds->wdsPrivacy == _TKIP_PRIVACY_)||(wds->wdsPrivacy == _CCMP_PRIVACY_))
+		hapd_set_wdskey(dev, wds->wdsPskPassPhrase, wds->ssid, wds->wdsNum);
+	
+	
+	HAPD_MSG("rtl_net80211_wdsaddmac --- \n");
+	return 0;
+
+bad:
+	priv->pmib->dot11WdsInfo.wdsEnabled = 0;
+	return -EINVAL;
+	
+
+}
+
+int rtl_net80211_wdsdelmac(struct net_device *dev, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)
+{
+#ifdef NETDEV_NO_PRIV
+	struct rtl8192cd_priv *priv = ((struct rtl8192cd_priv *)netdev_priv(dev))->wlan_priv;
+#else
+	struct rtl8192cd_priv	*priv = (struct rtl8192cd_priv *)dev->priv;
+#endif
+	struct rtk_wds_config *wds = (struct rtk_wds_config *)wrqu->data.pointer;
+	HAPD_MSG("rtl_net80211_wdsdelmac +++ \n");
+
+	priv->pmib->dot11WdsInfo.wdsEnabled = 0;
+	priv->pmib->dot11WdsInfo.wdsNum = 0;
+
+	HAPD_MSG("rtl_net80211_wdsdelmac --- \n");
+	return 0;
+}
+#endif
+
+
+int rtl_hapd_config(struct net_device *dev, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)
+{
+#ifdef NETDEV_NO_PRIV
+	struct rtl8192cd_priv *priv = ((struct rtl8192cd_priv *)netdev_priv(dev))->wlan_priv;
+#else
+	struct rtl8192cd_priv	*priv = (struct rtl8192cd_priv *)dev->priv;
+#endif
+	struct rtk_hapd_config *config = (struct rtk_hapd_config *)wrqu->data.pointer;
+	int size = 0;
+
+	HAPD_MSG("rtl_hapd_config +++\n");
+
+	priv->pmib->dot11BssType.net_work_type    					= config->band;
+	priv->pmib->dot11RFEntry.dot11channel	  					= config->channel;
+	priv->pmib->dot11StationConfigEntry.dot11BeaconPeriod	  	= config->bcnint; 		  
+	priv->pmib->dot11StationConfigEntry.dot11DTIMPeriod 	  	= config->dtimperiod; 
+
+	if(config->stanum <= NUM_STAT)
+	priv->pmib->dot11StationConfigEntry.supportedStaNum 	  	= config->stanum; 
+	else
+	{
+		HAPD_MSG("Invalid Station Number!!!\n");
+		return -1;
+	}
+	
+	priv->pmib->dot11OperationEntry.dot11RTSThreshold		  	= config->rtsthres;		  
+	priv->pmib->dot11OperationEntry.dot11FragmentationThreshold = config->fragthres;	
+	priv->pmib->dot11StationConfigEntry.dot11SupportedRates   	= config->oprates;		  
+	priv->pmib->dot11StationConfigEntry.dot11BasicRates 	  	= config->basicrates; 
+	priv->pmib->dot11RFEntry.shortpreamble	  					= config->preamble;	
+	priv->pmib->dot11StationConfigEntry.dot11AclMode	 		= config->aclmode;		  
+	priv->pmib->dot11StationConfigEntry.dot11AclNum 	  		= config->aclnum;
+	
+	size = sizeof(priv->pmib->dot11StationConfigEntry.dot11AclAddr);
+	memcpy(priv->pmib->dot11StationConfigEntry.dot11AclAddr, config->acladdr, size);
+	
+	priv->pmib->dot11OperationEntry.hiddenAP			  		= config->hiddenAP;	
+#ifdef WIFI_WMM
+	priv->pmib->dot11QosEntry.dot11QosEnable			  		= config->qos_enable;
+#endif
+	priv->pmib->dot11OperationEntry.expiretime					= config->expired_time * 100;	// 10ms unit vs 1s unit
+	priv->pmib->dot11OperationEntry.block_relay					= config->block_relay;
+	priv->pmib->dot11nConfigEntry.dot11nShortGIfor20M 			= config->shortGI20M; 		  
+	priv->pmib->dot11nConfigEntry.dot11nShortGIfor40M 			= config->shortGI40M; 
+
+
+//Above are for Hostapd owned configurations
+//=====================================================
+//Below are for RTK private configurations
+
+	size = sizeof(priv->pmib->dot11RFEntry.pwrlevelCCK_A);
+	memcpy(priv->pmib->dot11RFEntry.pwrlevelCCK_A, config->pwrlevelCCK_A, size);
+
+	size = sizeof(priv->pmib->dot11RFEntry.pwrlevelCCK_B);
+	memcpy(priv->pmib->dot11RFEntry.pwrlevelCCK_B, config->pwrlevelCCK_B, size);
+
+	size = sizeof(priv->pmib->dot11RFEntry.pwrlevelHT40_1S_A);
+	memcpy(priv->pmib->dot11RFEntry.pwrlevelHT40_1S_A, config->pwrlevelHT40_1S_A, size);
+
+	size = sizeof(priv->pmib->dot11RFEntry.pwrlevelHT40_1S_B);
+	memcpy(priv->pmib->dot11RFEntry.pwrlevelHT40_1S_B, config->pwrlevelHT40_1S_A, size);
+
+	size = sizeof(priv->pmib->dot11RFEntry.pwrdiffHT40_2S);
+	memcpy(priv->pmib->dot11RFEntry.pwrdiffHT40_2S, config->pwrdiffHT40_2S, size);
+
+	size = sizeof(priv->pmib->dot11RFEntry.pwrdiffHT20);
+	memcpy(priv->pmib->dot11RFEntry.pwrdiffHT20, config->pwrdiffHT20, size);
+
+	size = sizeof(priv->pmib->dot11RFEntry.pwrdiffOFDM);
+	memcpy(priv->pmib->dot11RFEntry.pwrdiffOFDM, config->pwrdiffOFDM, size);
+		  
+	priv->pmib->dot11RFEntry.ther		  		= config->ther;	
+	
+#ifdef CONFIG_RTL_92D_SUPPORT           
+	priv->pmib->dot11RFEntry.phyBandSelect	  	= config->phyBandSelect;		  
+#endif   
+
+	priv->pmib->dot11StationConfigEntry.dot11swcrypto	  	= config->swcrypto;		      
+	priv->pmib->dot11StationConfigEntry.dot11RegDomain		= config->regdomain;		  
+	priv->pmib->dot11StationConfigEntry.autoRate		   	= config->autorate;	  
+	priv->pmib->dot11StationConfigEntry.fixedTxRate			= config->fixrate;
+	priv->pmib->dot11StationConfigEntry.protectionDisabled	= config->disable_protection; 	  
+	priv->pmib->dot11StationConfigEntry.olbcDetectDisabled	= config->disable_olbc;		  
+	priv->pmib->dot11StationConfigEntry.legacySTADeny	  	= config->deny_legacy;		  	     
+	priv->pmib->dot11OperationEntry.opmode				  	= config->opmode; 		  	  																			  		 		  																																																		                  																			 
+	priv->pmib->dot11nConfigEntry.dot11nUse40M		  		= config->use40M; 		  
+	priv->pmib->dot11nConfigEntry.dot11n2ndChOffset   		= config->_2ndchoffset;		    
+	priv->pmib->dot11nConfigEntry.dot11nAMPDU	  			= config->ampdu;			                             
+	priv->pmib->dot11OperationEntry.guest_access			= config->guest_access;
+																							
+	priv->pmib->dot11RFEntry.macPhyMode 					= config->macPhyMode;
+																							
+#ifdef WIFI_11N_2040_COEXIST            
+	priv->pmib->dot11nConfigEntry.dot11nCoexist = config->coexist;		  
+#endif    
+	 
+#ifdef MBSSID                           
+	priv->pmib->miscEntry.vap_enable 			= config->vap_enable;		  
+#endif                            
+																							
+	priv->pshare->rf_ft_var.rssi_dump	  		= config->rssi_dump;			  
+																										  
+#ifdef MP_TEST                          
+	priv->pshare->rf_ft_var.mp_specific  		= config->mp_specific;		  
+#endif                                  
+																							
+#ifdef HIGH_POWER_EXT_PA                
+	priv->pshare->rf_ft_var.use_ext_pa 			= config->use_ext_pa; 		  
+#endif    
+
+	HAPD_MSG("rtl_hapd_config ---\n");
+	return 0;
+}
+
+
+
+#ifdef WIFI_WPAS
+
+int rtl_wpas_config_2G(struct rtl8192cd_priv *priv)
+{
+	HAPD_MSG("wpas config wlan 2.4G\n");
+	
+	priv->pmib->dot11BssType.net_work_type					= 1 + 2 + 8;
+	priv->pmib->dot11RFEntry.dot11channel					= 11;
+	priv->pmib->dot11nConfigEntry.dot11nShortGIfor20M		= 1;		  
+	priv->pmib->dot11nConfigEntry.dot11nShortGIfor40M		= 1;
+	priv->pmib->dot11StationConfigEntry.autoRate			= 1;																																																																																																						 
+	priv->pmib->dot11nConfigEntry.dot11nUse40M				= 1;				
+	priv->pmib->dot11nConfigEntry.dot11nAMPDU				= 1;
+	//priv->pmib->dot11RFEntry.macPhyMode 					= DUALMAC_DUALPHY;
+	priv->pmib->dot11nConfigEntry.dot11n2ndChOffset 		= HT_2NDCH_OFFSET_BELOW;
+	priv->pmib->dot11StationConfigEntry.dot11SupportedRates = 0xfff;		  
+	priv->pmib->dot11StationConfigEntry.dot11BasicRates 	= 0xf; 
+	priv->pmib->dot11OperationEntry.wifi_specific			= 2; //_Eric ??
+
+	priv->pmib->dot11OperationEntry.dot11FragmentationThreshold = 2346;
+	
+#ifdef CONFIG_RTL_92D_SUPPORT           
+	priv->pmib->dot11RFEntry.phyBandSelect					= PHY_BAND_2G;		  
+#endif   
+	
+#ifdef WIFI_WMM
+	priv->pmib->dot11QosEntry.dot11QosEnable				= 1;
+#endif
+
+}
+
+int rtl_wpas_config_5G(struct rtl8192cd_priv *priv)
+{
+	printk("wpas config wlan 5G\n");
+				
+	priv->pmib->dot11BssType.net_work_type					= 4 + 8;
+	priv->pmib->dot11RFEntry.dot11channel					= 44;
+	priv->pmib->dot11nConfigEntry.dot11nShortGIfor20M		= 1;		  
+	priv->pmib->dot11nConfigEntry.dot11nShortGIfor40M		= 1;
+	priv->pmib->dot11StationConfigEntry.autoRate			= 1;																																																																																																						 
+	priv->pmib->dot11nConfigEntry.dot11nUse40M				= 1;				
+	priv->pmib->dot11nConfigEntry.dot11nAMPDU				= 1;
+	//priv->pmib->dot11RFEntry.macPhyMode 					= DUALMAC_DUALPHY; //_Eric ?? How to judge ??
+	priv->pmib->dot11nConfigEntry.dot11n2ndChOffset 		= HT_2NDCH_OFFSET_ABOVE;
+	priv->pmib->dot11StationConfigEntry.dot11SupportedRates = 0xff0;		  
+	priv->pmib->dot11StationConfigEntry.dot11BasicRates 	= 0xff0; 
+	priv->pmib->dot11OperationEntry.wifi_specific			= 2;
+
+	priv->pmib->dot11OperationEntry.dot11FragmentationThreshold = 2346;
+	
+#ifdef CONFIG_RTL_92D_SUPPORT           
+	priv->pmib->dot11RFEntry.phyBandSelect					= PHY_BAND_5G;		  
+#endif   
+	
+#ifdef WIFI_WMM
+	priv->pmib->dot11QosEntry.dot11QosEnable				= 1;
+#endif
+
+}
+
+
+int rtl_wpas_config(struct rtl8192cd_priv *priv, unsigned char bandmode, unsigned char phymode)
+{
+	HAPD_MSG("wpas config interface: %s\n", priv->dev->name);
+
+	priv->pmib->dot11OperationEntry.opmode = WIFI_STATION_STATE;
+
+	if(bandmode == SINGLEMAC_SINGLEPHY)
+		{
+			priv->pmib->dot11RFEntry.macPhyMode = SINGLEMAC_SINGLEPHY;
+
+			if(phymode == PHY_BAND_5G)
+				rtl_wpas_config_5G(priv);
+			else if(phymode == PHY_BAND_2G)
+				rtl_wpas_config_2G(priv);
+			else
+				return -1;
+			
+		}
+	else if(!strcmp(priv->dev->name, "wlan0"))
+		{
+			priv->pmib->dot11RFEntry.macPhyMode = DUALMAC_DUALPHY;
+			rtl_wpas_config_5G(priv);
+		}
+	else if(!strcmp(priv->dev->name, "wlan1"))
+		{
+			priv->pmib->dot11RFEntry.macPhyMode = DUALMAC_DUALPHY;
+			rtl_wpas_config_2G(priv);
+		}
+	else
+		return -1;
+
+	return 0;
+
+
+}
+
+
+int rtl_wpas_custom(struct net_device *dev, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)
+{
+#ifdef NETDEV_NO_PRIV
+	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *)netdev_priv(dev);
+#else
+	struct rtl8192cd_priv	*priv = (struct rtl8192cd_priv *)dev->priv;
+#endif
+	struct rtk_wpas_config *config = (struct rtk_wpas_config *)wrqu->data.pointer;
+
+	int ret = 0;
+
+	switch (config->type) {
+	case WPAS_CONFIG_MIB:
+		HAPD_MSG("bandmode %d phymode %d \n", config->bandmode, config->phymode);
+		if((config->bandmode == SINGLEMAC_SINGLEPHY) || (config->bandmode == DUALMAC_DUALPHY))
+			ret = rtl_wpas_config(priv, config->bandmode, config->phymode);
+		else
+			return -EINVAL;
+		break;
+	case WPAS_CONFIG_WEPKEY: 
+		HAPD_MSG("WPAS_CONFIG_WEPKEY !!! \n");
+		memcpy(&priv->pmib->dot11DefaultKeysTable.keytype[config->wep_keyidx].skey[0], config->wep_key, config->wep_keylen);
+		break;
+
+	}
+
+	return ret;
+
+}
+#endif
+
+static void Construct_RSNIE(struct rtl8192cd_priv *priv, unsigned char *pucOut, int *usOutLen)
+{
+	DOT11_RSN_IE_HEADER dot11RSNIEHeader = { 0 };
+	DOT11_RSN_IE_SUITE dot11RSNGroupSuite;
+	DOT11_RSN_IE_COUNT_SUITE *pDot11RSNPairwiseSuite = NULL;
+	DOT11_RSN_IE_COUNT_SUITE *pDot11RSNAuthSuite = NULL;
+	unsigned short usSuitCount;
+	unsigned long ulIELength = 0;
+	unsigned long ulIndex = 0;
+	unsigned long ulPairwiseLength = 0;
+	unsigned long ulAuthLength = 0;
+	unsigned char *pucBlob;
+	DOT11_RSN_IE_COUNT_SUITE countSuite, authCountSuite;
+#ifdef RTL_WPA2
+	DOT11_RSN_CAPABILITY dot11RSNCapability = { 0 };
+	unsigned long uCipherAlgo = 0;
+	int bCipherAlgoEnabled = FALSE;
+	unsigned long uAuthAlgo = 0;
+	int bAuthAlgoEnabled = FALSE;
+	unsigned long ulRSNCapabilityLength = 0;
+#endif
+
+	*usOutLen = 0;
+	if ( priv->pmib->dot1180211AuthEntry.dot11WPACipher != 0 ) {
+		//
+		// Construct Information Header
+		//
+		dot11RSNIEHeader.ElementID = RSN_ELEMENT_ID;
+		dot11RSNIEHeader.OUI[0] = 0x00;
+		dot11RSNIEHeader.OUI[1] = 0x50;
+		dot11RSNIEHeader.OUI[2] = 0xf2;
+		dot11RSNIEHeader.OUI[3] = 0x01;
+		dot11RSNIEHeader.Version = cpu_to_le16(RSN_VER1);
+		ulIELength += sizeof(DOT11_RSN_IE_HEADER);
+
+		// Construct Cipher Suite:
+		// - Multicast Suite:
+		memset(&dot11RSNGroupSuite, 0, sizeof dot11RSNGroupSuite);
+		dot11RSNGroupSuite.OUI[0] = 0x00;
+		dot11RSNGroupSuite.OUI[1] = 0x50;
+		dot11RSNGroupSuite.OUI[2] = 0xF2;
+		dot11RSNGroupSuite.Type = priv->wpa_global_info->MulticastCipher;
+		ulIELength += sizeof(DOT11_RSN_IE_SUITE);
+
+    	// - UnicastSuite
+        pDot11RSNPairwiseSuite = &countSuite;
+        memset(pDot11RSNPairwiseSuite, 0, sizeof(DOT11_RSN_IE_COUNT_SUITE));
+		usSuitCount = 0;
+        for (ulIndex=0; ulIndex<priv->wpa_global_info->NumOfUnicastCipher; ulIndex++)
+        {
+			pDot11RSNPairwiseSuite->dot11RSNIESuite[usSuitCount].OUI[0] = 0x00;
+			pDot11RSNPairwiseSuite->dot11RSNIESuite[usSuitCount].OUI[1] = 0x50;
+			pDot11RSNPairwiseSuite->dot11RSNIESuite[usSuitCount].OUI[2] = 0xF2;
+			pDot11RSNPairwiseSuite->dot11RSNIESuite[usSuitCount].Type = priv->wpa_global_info->UnicastCipher[ulIndex];
+			usSuitCount++;
+        }
+		pDot11RSNPairwiseSuite->SuiteCount = cpu_to_le16(usSuitCount);
+        ulPairwiseLength = sizeof(pDot11RSNPairwiseSuite->SuiteCount) + usSuitCount*sizeof(DOT11_RSN_IE_SUITE);
+        ulIELength += ulPairwiseLength;
+
+		//
+		// Construction of Auth Algo List
+		//
+        pDot11RSNAuthSuite = &authCountSuite;
+        memset(pDot11RSNAuthSuite, 0, sizeof(DOT11_RSN_IE_COUNT_SUITE));
+		usSuitCount = 0;
+		pDot11RSNAuthSuite->dot11RSNIESuite[usSuitCount].OUI[0] = 0x00;
+		pDot11RSNAuthSuite->dot11RSNIESuite[usSuitCount].OUI[1] = 0x50;
+		pDot11RSNAuthSuite->dot11RSNIESuite[usSuitCount].OUI[2] = 0xF2;
+		pDot11RSNAuthSuite->dot11RSNIESuite[usSuitCount].Type = DOT11_AuthKeyType_RSN;
+	    usSuitCount++;
+
+		pDot11RSNAuthSuite->SuiteCount = cpu_to_le16(usSuitCount);
+        ulAuthLength = sizeof(pDot11RSNAuthSuite->SuiteCount) + usSuitCount*sizeof(DOT11_RSN_IE_SUITE);
+        ulIELength += ulAuthLength;
+
+		pucBlob = pucOut;
+		pucBlob += sizeof(DOT11_RSN_IE_HEADER);
+		memcpy(pucBlob, &dot11RSNGroupSuite, sizeof(DOT11_RSN_IE_SUITE));
+		pucBlob += sizeof(DOT11_RSN_IE_SUITE);
+		memcpy(pucBlob, pDot11RSNPairwiseSuite, ulPairwiseLength);
+		pucBlob += ulPairwiseLength;
+		memcpy(pucBlob, pDot11RSNAuthSuite, ulAuthLength);
+		pucBlob += ulAuthLength;
+
+		*usOutLen = (int)ulIELength;
+		pucBlob = pucOut;
+		dot11RSNIEHeader.Length = (unsigned char)ulIELength - 2; //This -2 is to minus elementID and Length in OUI header
+		memcpy(pucBlob, &dot11RSNIEHeader, sizeof(DOT11_RSN_IE_HEADER));
+	}
+
+#ifdef RTL_WPA2
+	if ( priv->pmib->dot1180211AuthEntry.dot11WPA2Cipher != 0 ) {
+       	DOT11_WPA2_IE_HEADER dot11WPA2IEHeader = { 0 };
+		ulIELength = 0;
+		ulIndex = 0;
+		ulPairwiseLength = 0;
+		uCipherAlgo = 0;
+		bCipherAlgoEnabled = FALSE;
+		ulAuthLength = 0;
+		uAuthAlgo = 0;
+		bAuthAlgoEnabled = FALSE;
+		ulRSNCapabilityLength = 0;
+
+		//
+		// Construct Information Header
+		//
+		dot11WPA2IEHeader.ElementID = WPA2_ELEMENT_ID;
+		dot11WPA2IEHeader.Version = cpu_to_le16(RSN_VER1);
+		ulIELength += sizeof(DOT11_WPA2_IE_HEADER);
+
+		// Construct Cipher Suite:
+		//      - Multicast Suite:
+		//
+		memset(&dot11RSNGroupSuite, 0, sizeof(dot11RSNGroupSuite));
+		dot11RSNGroupSuite.OUI[0] = 0x00;
+		dot11RSNGroupSuite.OUI[1] = 0x0F;
+		dot11RSNGroupSuite.OUI[2] = 0xAC;
+		dot11RSNGroupSuite.Type = priv->wpa_global_info->MulticastCipher;;
+		ulIELength += sizeof(DOT11_RSN_IE_SUITE);
+
+		//      - UnicastSuite
+        pDot11RSNPairwiseSuite = &countSuite;
+        memset(pDot11RSNPairwiseSuite, 0, sizeof(DOT11_RSN_IE_COUNT_SUITE));
+		usSuitCount = 0;
+		for (ulIndex=0; ulIndex<priv->wpa_global_info->NumOfUnicastCipherWPA2; ulIndex++)
+        {
+			pDot11RSNPairwiseSuite->dot11RSNIESuite[usSuitCount].OUI[0] = 0x00;
+			pDot11RSNPairwiseSuite->dot11RSNIESuite[usSuitCount].OUI[1] = 0x0F;
+			pDot11RSNPairwiseSuite->dot11RSNIESuite[usSuitCount].OUI[2] = 0xAC;
+			pDot11RSNPairwiseSuite->dot11RSNIESuite[usSuitCount].Type = priv->wpa_global_info->UnicastCipherWPA2[ulIndex];
+			usSuitCount++;
+        }
+		pDot11RSNPairwiseSuite->SuiteCount = cpu_to_le16(usSuitCount);
+        ulPairwiseLength = sizeof(pDot11RSNPairwiseSuite->SuiteCount) + usSuitCount*sizeof(DOT11_RSN_IE_SUITE);
+        ulIELength += ulPairwiseLength;
+
+		//
+		// Construction of Auth Algo List
+		//
+        pDot11RSNAuthSuite = &authCountSuite;
+        memset(pDot11RSNAuthSuite, 0, sizeof(DOT11_RSN_IE_COUNT_SUITE));
+		usSuitCount = 0;
+		pDot11RSNAuthSuite->dot11RSNIESuite[usSuitCount].OUI[0] = 0x00;
+		pDot11RSNAuthSuite->dot11RSNIESuite[usSuitCount].OUI[1] = 0x0F;
+		pDot11RSNAuthSuite->dot11RSNIESuite[usSuitCount].OUI[2] = 0xAC;
+		pDot11RSNAuthSuite->dot11RSNIESuite[usSuitCount].Type = DOT11_AuthKeyType_RSN;
+	    usSuitCount++;
+
+		pDot11RSNAuthSuite->SuiteCount = cpu_to_le16(usSuitCount);
+        ulAuthLength = sizeof(pDot11RSNAuthSuite->SuiteCount) + usSuitCount*sizeof(DOT11_RSN_IE_SUITE);
+        ulIELength += ulAuthLength;
+
+		//---------------------------------------------------------------------------------------------
+		// Do not encapsulate capability field to solve TI WPA issue
+		//---------------------------------------------------------------------------------------------
+
+		dot11RSNCapability.field.PreAuthentication = 0;
+
+		ulRSNCapabilityLength = sizeof(DOT11_RSN_CAPABILITY);
+		ulIELength += ulRSNCapabilityLength;
+
+		pucBlob = pucOut + *usOutLen;
+		pucBlob += sizeof(DOT11_WPA2_IE_HEADER);
+		memcpy(pucBlob, &dot11RSNGroupSuite, sizeof(DOT11_RSN_IE_SUITE));
+		pucBlob += sizeof(DOT11_RSN_IE_SUITE);
+		memcpy(pucBlob, pDot11RSNPairwiseSuite, ulPairwiseLength);
+		pucBlob += ulPairwiseLength;
+		memcpy(pucBlob, pDot11RSNAuthSuite, ulAuthLength);
+		pucBlob += ulAuthLength;
+		memcpy(pucBlob, &dot11RSNCapability, ulRSNCapabilityLength);
+
+		pucBlob = pucOut + *usOutLen;
+		dot11WPA2IEHeader.Length = (unsigned char)ulIELength - 2; //This -2 is to minus elementID and Length in OUI header
+		memcpy(pucBlob, &dot11WPA2IEHeader, sizeof(DOT11_WPA2_IE_HEADER));
+		*usOutLen = *usOutLen + (int)ulIELength;
+   	}
+#endif // RTL_WPA2
+
+}
+
+
+static void ToDrv_SetRSNIE(struct rtl8192cd_priv *priv)
+{
+	struct iw_point wrq;
+	DOT11_SET_RSNIE Set_Rsnie;
+
+
+	debug_out("RSN: Set RSNIE", priv->wpa_global_info->AuthInfoElement.Octet,
+								priv->wpa_global_info->AuthInfoElement.Length);
+
+
+	wrq.pointer = (caddr_t)&Set_Rsnie;
+	wrq.length = sizeof(DOT11_SET_RSNIE);
+	Set_Rsnie.EventId = DOT11_EVENT_SET_RSNIE;
+	Set_Rsnie.IsMoreEvent = FALSE;
+	Set_Rsnie.Flag = DOT11_Ioctl_Set;
+	Set_Rsnie.RSNIELen = priv->wpa_global_info->AuthInfoElement.Length;
+	memcpy(&Set_Rsnie.RSNIE,
+			priv->wpa_global_info->AuthInfoElement.Octet,
+			priv->wpa_global_info->AuthInfoElement.Length);
+
+	rtl8192cd_ioctl_priv_daemonreq(priv->dev, &wrq);
+}
+
+
+void rsn_init(struct rtl8192cd_priv *priv)
+{
+	WPA_GLOBAL_INFO *pGblInfo=priv->wpa_global_info;
+	int i, j, low_cipher=0;
+
+	DEBUG_TRACE;
+
+	HAPD_MSG("rsn_init\n");
+
+	memset((char *)pGblInfo, '\0', sizeof(WPA_GLOBAL_INFO));
+
+	if (priv->pmib->dot1180211AuthEntry.dot11WPACipher) {
+		for (i=0, j=0; i<_WEP_104_PRIVACY_; i++) {
+			if (priv->pmib->dot1180211AuthEntry.dot11WPACipher & (1<<i)) {
+				pGblInfo->UnicastCipher[j] = i+1;
+				if (low_cipher == 0)
+					low_cipher = pGblInfo->UnicastCipher[j];
+				else {
+					if (low_cipher == _WEP_104_PRIVACY_ &&
+							pGblInfo->UnicastCipher[j] == _WEP_40_PRIVACY_)
+						low_cipher = pGblInfo->UnicastCipher[j];
+					else if (low_cipher == _TKIP_PRIVACY_ &&
+							(pGblInfo->UnicastCipher[j] == _WEP_40_PRIVACY_ ||
+								pGblInfo->UnicastCipher[j] == _WEP_104_PRIVACY_))
+							low_cipher = pGblInfo->UnicastCipher[j];
+					else if (low_cipher == _CCMP_PRIVACY_)
+							low_cipher = pGblInfo->UnicastCipher[j];
+				}
+				if (++j >= MAX_UNICAST_CIPHER)
+					break;
+			}
+		}
+		pGblInfo->NumOfUnicastCipher = j;
+	}
+
+#ifdef RTL_WPA2
+	if (priv->pmib->dot1180211AuthEntry.dot11WPA2Cipher) {
+		for (i=0, j=0; i<_WEP_104_PRIVACY_; i++) {
+			if (priv->pmib->dot1180211AuthEntry.dot11WPA2Cipher & (1<<i)) {
+				pGblInfo->UnicastCipherWPA2[j] = i+1;
+				if (low_cipher == 0)
+					low_cipher = pGblInfo->UnicastCipherWPA2[j];
+				else {
+					if (low_cipher == _WEP_104_PRIVACY_ &&
+							pGblInfo->UnicastCipherWPA2[j] == _WEP_40_PRIVACY_)
+						low_cipher = pGblInfo->UnicastCipherWPA2[j];
+					else if (low_cipher == _TKIP_PRIVACY_ &&
+							(pGblInfo->UnicastCipherWPA2[j] == _WEP_40_PRIVACY_ ||
+								pGblInfo->UnicastCipherWPA2[j] == _WEP_104_PRIVACY_))
+							low_cipher = pGblInfo->UnicastCipherWPA2[j];
+					else if (low_cipher == _CCMP_PRIVACY_)
+							low_cipher = pGblInfo->UnicastCipherWPA2[j];
+				}
+				if (++j >= MAX_UNICAST_CIPHER)
+					break;
+			}
+		}
+		pGblInfo->NumOfUnicastCipherWPA2= j;
+	}
+#endif
+
+	pGblInfo->MulticastCipher = low_cipher;
+
+	HAPD_MSG("RSN: WPA unicast cipher= ");
+	for (i=0; i<pGblInfo->NumOfUnicastCipher; i++)
+		HAPD_MSG("%x ", pGblInfo->UnicastCipher[i]);
+	HAPD_MSG("\n");
+
+#ifdef RTL_WPA2
+	HAPD_MSG("RSN: WPA2 unicast cipher= ");
+	for (i=0; i<pGblInfo->NumOfUnicastCipherWPA2; i++)
+		HAPD_MSG("%x ", pGblInfo->UnicastCipherWPA2[i]);
+	HAPD_MSG("\n");
+#endif
+
+	HAPD_MSG("RSN: multicast cipher= %x\n", pGblInfo->MulticastCipher);
+
+
+	pGblInfo->AuthInfoElement.Octet = pGblInfo->AuthInfoBuf;
+
+	Construct_RSNIE(priv, pGblInfo->AuthInfoElement.Octet,
+					 &pGblInfo->AuthInfoElement.Length);
+
+	ToDrv_SetRSNIE(priv);
+}
+
+#endif //WIFI_HAPD
diff --git a/drivers/net/wireless/rtl8192cd/8192cd_osdep.c b/drivers/net/wireless/rtl8192cd/8192cd_osdep.c
index a85745b..99682e4 100644
--- a/drivers/net/wireless/rtl8192cd/8192cd_osdep.c
+++ b/drivers/net/wireless/rtl8192cd/8192cd_osdep.c
@@ -77,8 +77,8 @@ u32 if_priv[NUM_WLAN_IFACE];
 #endif
 
 #ifdef	CONFIG_RTK_MESH
-#include "./mesh_ext/mesh_route.h"	// Note : Not include in  #ifdef CONFIG_RTK_MESH, Because use in wlan_device[]
-#include "./mesh_ext/mesh_util.h"
+#include "../mesh_ext/mesh_route.h"	// Note : Not include in  #ifdef CONFIG_RTK_MESH, Because use in wlan_device[]
+#include "../mesh_ext/mesh_util.h"
 #endif	// CONFIG_RTK_MESH
 
 #ifdef CONFIG_RTL_KERNEL_MIPS16_WLAN
@@ -101,7 +101,11 @@ u32 if_priv[NUM_WLAN_IFACE];
 #endif
 
 #ifdef CONFIG_RTL8672
+#ifdef USE_RLX_BSP
+#include <bspchip.h>
+#else
 #include <platform.h>
+#endif
 #else
 #if !defined(CONFIG_NET_PCI) && defined(CONFIG_RTL8196B)
 #include <asm/rtl865x/platform.h>
@@ -112,7 +116,7 @@ u32 if_priv[NUM_WLAN_IFACE];
 #endif
 #endif
 
-#if !defined(CONFIG_NET_PCI) && defined(CONFIG_RTL_819X) && defined(__LINUX_2_6__)
+#if defined(CONFIG_RTL_819X) && defined(__LINUX_2_6__)
 #if !defined(USE_RLX_BSP)
 #include <platform.h>
 #else
@@ -143,6 +147,15 @@ extern void (*wirelessnet_hook_free_priv_buf)(unsigned char *head);
 #endif
 #endif // CONFIG_WIRELESS_LAN_MODULE
 
+#ifdef CONFIG_RTL8672
+//#define BSP_PCIE0_D_CFG0      PCIE0_D_CFG0
+//#define BSP_PCIE0_D_MEM       PCIE0_D_MEM
+//#define BSP_PCIE_IRQ          PCIE_IRQ
+//#define BSP_PCIE0_H_CFG               PCIE0_H_CFG
+//#define BSP_PCIE1_D_CFG0	PCIE1_D_MEM
+#define mdelay(x) delay_ms(x)
+#endif
+
 struct _device_info_ wlan_device[] =
 {
 #if defined(USE_RTL8186_SDK)
@@ -176,10 +189,14 @@ struct _device_info_ wlan_device[] =
 				#error "define pcie error"
          #endif
 	#else
+#ifdef CONFIG_RTL_88E_SUPPORT
+	{(MESH_NUM_CFG<<MESH_SHIFT) |(WDS_NUM_CFG<<WDS_SHIFT) | (TYPE_PCI_DIRECT<<TYPE_SHIFT) | ACCESS_SWAP_MEM, BSP_PCIE0_D_CFG0, BSP_PCIE0_D_MEM, BSP_PCIE_IRQ, NULL},
+#else
 				{(MESH_NUM_CFG<<MESH_SHIFT) |(WDS_NUM_CFG<<WDS_SHIFT) | (TYPE_PCI_DIRECT<<TYPE_SHIFT) | ACCESS_SWAP_MEM, BSP_PCIE0_D_CFG0, BSP_PCIE0_D_MEM, BSP_PCIE_IRQ, NULL},
 		 #if defined(CONFIG_RTL_DUAL_PCIESLOT_BIWLAN)
 				{(MESH_NUM_CFG<<MESH_SHIFT) |(WDS_NUM_CFG<<WDS_SHIFT) | (TYPE_PCI_DIRECT<<TYPE_SHIFT) | ACCESS_SWAP_MEM, BSP_PCIE1_D_CFG0, BSP_PCIE1_D_MEM, BSP_PCIE2_IRQ, NULL}
 		 #endif
+#endif
 	#endif
 #else
 				{(MESH_NUM_CFG<<MESH_SHIFT) |(WDS_NUM_CFG<<WDS_SHIFT) | (TYPE_PCI_DIRECT<<TYPE_SHIFT) | ACCESS_SWAP_MEM, PCIE0_D_CFG0, PCIE0_D_MEM, PCIE_IRQ, NULL},
@@ -403,7 +420,7 @@ static int rtl8196b_pci_reset(unsigned long conf_addr)
 #endif
 
 
-#if defined(CONFIG_RTL_8198) || defined(CONFIG_RTL8196C) || defined(CONFIG_RTL_8196C)
+#if defined(CONFIG_RTL_8198) || defined(CONFIG_RTL8196C) || defined(CONFIG_RTL_8196C) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 #define MAX_PAYLOAD_SIZE_128B    0x00
 
 #define CLK_MANAGE     0xb8000010
@@ -417,7 +434,7 @@ static int rtl8196b_pci_reset(unsigned long conf_addr)
 #define PCIE_MDIO_DATA_MASK (0xffff <<PCIE_MDIO_DATA_OFFSET)
 #define PCIE_MDIO_REG_OFFSET (8)
 #define PCIE_MDIO_RDWR_OFFSET (0)
-#if !defined(CONFIG_NET_PCI) &&  defined(CONFIG_RTL_8198)
+#if !defined(CONFIG_NET_PCI) &&  (defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E))
 #define PHY_EAT_40MHZ 1
 #endif
 
@@ -539,10 +556,13 @@ static void iNIC_PCIE_Device_PERST(void)
 }
 #endif
 
-#if defined(CONFIG_RTL_8198)
+#if defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 static int at2_mode=0;
 static void PCIE_Device_PERST(int portnum)
 {
+#if defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+	REG32(0xb8000010)|= (1<<12)|(1<<13)|(1<<19)|(1<<20)|(1<<18)|(1<<16);
+#endif
 	if (portnum==0)
 	{
 		REG32(CLK_MANAGE) &= ~(1<<26);    //perst=0 off.    
@@ -560,11 +580,49 @@ static void PCIE_Device_PERST(int portnum)
 #if defined(CONFIG_RTL_8197B)
                 GPIO6_PCIE_Device_PERST();
 #else
+#if defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+
+		REG32(0xb8000040) = (REG32(0xb8000040) & ~(7)) |(6);
+							
+                REG32(0xb8003500)=REG32(0xb8003500)&(~(1<<2));
+
+                 REG32(0xb8003508)= REG32(0xb8003508)|(1<<2);
+
+
+
+
+                REG32(0xb800350C) &= ~(1<<2);    //perst=0 off.
+                mdelay(300);   //PCIE standadrd: poweron: 100us, after poweron: 100ms
+                mdelay(300);
+
+                REG32(0xb800350C) |=  (1<<2);   //PERST=1
+
+
+
+		
+#if QA_BOARD
+		REG32(0xb8000040)=REG32(0xb8000040)|0x30000000;
+
+		REG32(0xb8003500)=REG32(0xb8003500)&(~0x200000);
+ 
+		 REG32(0xb8003508)= REG32(0xb8003508)|0x200000;
+
+
+
+
+		REG32(0xb800350C) &= ~(0x200000);    //perst=0 off.  
+		mdelay(300);   //PCIE standadrd: poweron: 100us, after poweron: 100ms
+		mdelay(300); 
+
+		REG32(0xb800350C) |=  (0x200000);   //PERST=1
+#endif
+#else
 		REG32(PEFGHDAT_REG) &= ~(0x1000);    //perst=0 off.  
 		mdelay(300);   //PCIE standadrd: poweron: 100us, after poweron: 100ms
 		mdelay(300); 
 		REG32(PEFGHDAT_REG) |=  (0x1000);   //PERST=1
 #endif
+#endif
 #elif defined(CONFIG_RTL_92D_SUPPORT)
 		REG32(CLK_MANAGE) &= ~(1<<26);    //perst=0 off.    
 		mdelay(500);   //PCIE standadrd: poweron: 100us, after poweron: 100ms
@@ -713,37 +771,69 @@ int PCIE_reset_procedure(int portnum, int Use_External_PCIE_CLK, int mdio_reset,
 	if(mdio_reset)
 	{
 		//fix 8198 test chip pcie tx problem.	
-		#ifdef CONFIG_RTL8198_REVISION_B
-		if (REG32(BSP_REVR) >= BSP_RTL8198_REVISION_B) 
+		#if defined(CONFIG_RTL8198_REVISION_B) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+
+		#if defined(CONFIG_RTL_8196E)
+		if ((REG32(BSP_REVR) & 0xFFFFF000) == BSP_RTL8196E)
+		#else		
+		if ((REG32(BSP_REVR) >= BSP_RTL8198_REVISION_B) || ((REG32(BSP_REVR) & 0xFFFFF000) == BSP_RTL8197D)) 
+		#endif
 		{
 			HostPCIe_SetPhyMdioWrite(portnum, 0, 0xD087);  //bokai tell, and fix
 
 			HostPCIe_SetPhyMdioWrite(portnum, 1, 0x0003);
 			HostPCIe_SetPhyMdioWrite(portnum, 2, 0x4d18);
+			#if defined(CONFIG_AUTO_PCIE_PHY_SCAN) && defined(CONFIG_RTL_8196E)
+				if ((REG32(0xb8000008)&0x2000000)==0x2000000)  //40MHz
+				{
+					HostPCIe_SetPhyMdioWrite(portnum, 5, 0x0BCB);   //40M
+					HostPCIe_SetPhyMdioWrite(portnum, 6, 0x0148);   //40M
+				}
+				else //25MHz
+				{
+					printk("98 - 25MHz Clock Source\n");
+					HostPCIe_SetPhyMdioWrite(portnum, 6, 0xf848);  //25M
+				}
+			
+			#else
 			#if  CONFIG_PHY_EAT_40MHZ
 			HostPCIe_SetPhyMdioWrite(portnum, 5, 0x0BCB);   //40M
 			#endif
 
 			#if  CONFIG_PHY_EAT_40MHZ
 			printk("98 - 40MHz Clock Source\n");
+#if defined(CONFIG_RTL_8196E)
+			HostPCIe_SetPhyMdioWrite(portnum, 6, 0x0148);  //40M
+#else
 			HostPCIe_SetPhyMdioWrite(portnum, 6, 0xF148);  //40M
+#endif
 			#else
 			printk("98 - 25MHz Clock Source\n");
 			HostPCIe_SetPhyMdioWrite(portnum, 6, 0xf848);  //25M
 			#endif
+			#endif
 
 			HostPCIe_SetPhyMdioWrite(portnum, 7, 0x31ff);
+#if defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+			HostPCIe_SetPhyMdioWrite(portnum, 8, 0x18d6);  //peisi tune  //@@@@@@-->7 jasonwang 0902
+#else
 			HostPCIe_SetPhyMdioWrite(portnum, 8, 0x18d7);  //peisi tune
-
+#endif
 			//saving more power, 8196c pe-si tune
 			HostPCIe_SetPhyMdioWrite(portnum, 0x09, 0x539c); 	
 			HostPCIe_SetPhyMdioWrite(portnum, 0x0a, 0x20eb); 	
 			HostPCIe_SetPhyMdioWrite(portnum, 0x0d, 0x1766); 			
-
+#if defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+			HostPCIe_SetPhyMdioWrite(portnum, 0x0b, 0x0711);   //for sloving low performance
+#else
 			HostPCIe_SetPhyMdioWrite(portnum, 0x0b, 0x0511);   //for sloving low performance
+#endif
 
-
-			HostPCIe_SetPhyMdioWrite(portnum, 0xf, 0x0a00);	
+#if defined(CONFIG_RTL_8196E)
+			HostPCIe_SetPhyMdioWrite(portnum, 0xf, 0x0f0f);
+#else
+			HostPCIe_SetPhyMdioWrite(portnum, 0xf, 0x0a00);
+#endif
 			HostPCIe_SetPhyMdioWrite(portnum, 0x19, 0xFCE0);
 
 			HostPCIe_SetPhyMdioWrite(portnum, 0x1a, 0x7e40);   //formal chip, reg 0x1a.4=0
@@ -775,6 +865,14 @@ int PCIE_reset_procedure(int portnum, int Use_External_PCIE_CLK, int mdio_reset,
 	//---------------------------------------
 	PCIE_Device_PERST(portnum);
 	PCIE_PHY_Reset(portnum);
+
+#ifdef CONFIG_RTL_ULINKER
+	{
+		extern void eth_led_recover(void);
+		eth_led_recover();
+	}
+#endif
+
 	mdelay(500);
 	mdelay(500);
 	status=PCIE_Check_Link(portnum); 
@@ -838,19 +936,43 @@ SET_BAR:
 }
 #elif defined(CONFIG_RTL8196C) || defined(CONFIG_RTL_8196C)
 
+static int pcie_reset_done = 0;
 #ifdef CONFIG_RTL8672
-int PCIE_reset_procedure(int PCIE_Port0and1_8196B_208pin, int Use_External_PCIE_CLK, int mdio_reset,unsigned long conf_addr)
+#ifdef USE_RLX_BSP
+#define PCI_MISC		BSP_PCI_MISC
+#define MISC_IP_SEL		BSP_IP_SEL
+	#define EN_PCIE			BSP_EN_PCIE
+#define PCI_MISC		BSP_PCI_MISC
+#define PCIE0_H_PWRCR	BSP_PCIE0_H_PWRCR
+#define MISC_PINSR		BSP_MISC_PINSR
+	#define CLKSEL			BSP_CLKSEL
+#define PCIE0_H_CFG		BSP_PCIE0_H_CFG
+#endif //USE_RLX_BSP
+
+extern void gpioSet(int gpio_num);
+extern void gpioClear(int gpio_num);
+static int PCIE_reset_procedure(int PCIE_Port0and1_8196B_208pin, int Use_External_PCIE_CLK, int mdio_reset,unsigned long conf_addr)
 {
-	#define SYS_PCIE_PHY0   0xb8003400
-	#define Module_Enable   0xb800330c
+	//#define SYS_PCIE_PHY0	(0xb8000000 +0x50)
+	#define SYS_PCIE_PHY0	0xb8003400
+	#define Module_Enable	0xb800330c
 	//PCIE Register
-	#define CLK_MANAGE  0xb800350c
-	#define PCIE_PHY0_REG  0xb8b01000
-	//#define PCIE_PHY1_REG  0xb8b21000
-	#define PCIE_PHY0  0xb8b01008
-	// #define PCIE_PHY1  0xb8b21008
-	#define PCIE_gpio_RST 5
+	#define CLK_MANAGE		0xb800350c
+	#define PCIE_PHY0_REG	0xb8b01000
+	//#define PCIE_PHY1_REG	0xb8b21000
+	#define PCIE_PHY0		0xb8b01008
+	//#define PCIE_PHY1		0xb8b21008
+#if defined(CONFIG_6166_IAD_SILAB3217X) || defined(CONFIG_6166_IAD_ZARLINK) || defined(CONFIG_BOARD_006)
+	#define PCIE_gpio_RST	24  /* GPD0 */
+#else
+	#define PCIE_gpio_RST	5
+#endif
 
+	// Assert PCIE Device Reset
+	gpioClear(PCIE_gpio_RST);
+	REG32(0xb8003508) |= (1<<PCIE_gpio_RST);	// Configure output pin
+	delay_ms(10);
+	
 	//1. PCIE phy mdio reset
 	REG32(SYS_PCIE_PHY0) = 0x1d400000;
 	REG32(SYS_PCIE_PHY0) = 0x1d500000;
@@ -859,52 +981,108 @@ int PCIE_reset_procedure(int PCIE_Port0and1_8196B_208pin, int Use_External_PCIE_
 	REG32(Module_Enable) &= ~(1<<9);
 	REG32(Module_Enable) |= (1<<9);
 
-	//3.Active LX & PCIE Clock
-	gpioSet(PCIE_gpio_RST);
-	delay_ms(100);
-
-	//4. GPIO output
-	REG32(0xb8003508) |= (1<<5);
-	delay_ms(100);
-
+#if 1
 	if(mdio_reset)
 	{
 		//printk("Do MDIO_RESET\n");
-		// 5.MDIO Reset	
+		// 5.MDIO Reset
 		REG32(SYS_PCIE_PHY0) = 0x1d500000;
 	}
 	//6. PCIE PHY Reset
 	REG32(PCIE_PHY0) = 0x1; //bit7 PHY reset=0   bit0 Enable LTSSM=1
 	REG32(PCIE_PHY0) = 0x81;   //bit7 PHY reset=1   bit0 Enable LTSSM=1
 	delay_ms(100);
+#endif
 
 	delay_ms(100);
 
 	//----------------------------------------
 	if(mdio_reset)
 	{
+#if 1
 		int port=0;
-		HostPCIe_SetPhyMdioWrite(port, 0, 0x5027);
-		HostPCIe_SetPhyMdioWrite(port, 2, 0x6d18);
-		//HostPCIe_SetPhyMdioWrite(port, 6, 0x8028);
+
+		//Updata PCIE parameters
+		HostPCIe_SetPhyMdioWrite(port, 1, 0x0003);
+		HostPCIe_SetPhyMdioWrite(port, 2, 0x2d18);
+		HostPCIe_SetPhyMdioWrite(port, 3, 0x6d09);
+		HostPCIe_SetPhyMdioWrite(port, 4, 0x5000);
 		if( (IS_RLE0315 ||IS_6166) && (REG32(MISC_PINSR)&(0x200000))){
-			HostPCIe_SetPhyMdioWrite(port, 6, 0x20c8); //35.328 clock source
+			HostPCIe_SetPhyMdioWrite(port, 0, 0x1046);
+			HostPCIe_SetPhyMdioWrite(port, 6, 0x0068); //35.328 clock source
 			HostPCIe_SetPhyMdioWrite(port, 5, 0x0bcb);
 			printk("Clock source is 35.328MHz\n");
 		}else if( (IS_RLE0315 ||IS_6166) && ~(REG32(MISC_PINSR)&(0x200000))){
+			HostPCIe_SetPhyMdioWrite(port, 0, 0x1047);
 			HostPCIe_SetPhyMdioWrite(port, 6, 0xf848);  //25M clock source
 			HostPCIe_SetPhyMdioWrite(port, 5, 0x08ab);
 			printk("Clock source is 25MHz\n");
 		}
 		HostPCIe_SetPhyMdioWrite(port, 7, 0x30ff);
-		//HostPCIe_SetPhyMdioWrite(port, 8, 0x18dd);
 		HostPCIe_SetPhyMdioWrite(port, 8, 0x18d7);
-		HostPCIe_SetPhyMdioWrite(port, 0xa, 0xe9);
+		HostPCIe_SetPhyMdioWrite(port, 9, 0x530c);
+		HostPCIe_SetPhyMdioWrite(port, 0xa, 0x00e8);
 		HostPCIe_SetPhyMdioWrite(port, 0xb, 0x0511);
-		//HostPCIe_SetPhyMdioWrite(port, 0xd, 0x15b6);
-		HostPCIe_SetPhyMdioWrite(port, 0xd, 0x15a6);
+		HostPCIe_SetPhyMdioWrite(port, 0xc, 0x0828);
+		HostPCIe_SetPhyMdioWrite(port, 0xd, 0x17a6);
+		HostPCIe_SetPhyMdioWrite(port, 0xe, 0x98c5);
 		HostPCIe_SetPhyMdioWrite(port, 0xf, 0x0f0f);
-		//HostPCIe_SetPhyMdioWrite(port,  0x9, 0xe950); //czyao adds to leave L0 mode
+		HostPCIe_SetPhyMdioWrite(port, 0x10, 0x000c);
+		HostPCIe_SetPhyMdioWrite(port, 0x11, 0x3c00);
+		HostPCIe_SetPhyMdioWrite(port, 0x12, 0xfc00);
+		HostPCIe_SetPhyMdioWrite(port, 0x13, 0x0c81);
+		HostPCIe_SetPhyMdioWrite(port, 0x14, 0xde01);
+		HostPCIe_SetPhyMdioWrite(port, 0x19, 0xfc20);
+		HostPCIe_SetPhyMdioWrite(port, 0x1a, 0xfc00);
+		HostPCIe_SetPhyMdioWrite(port, 0x1b, 0xfc00);
+		HostPCIe_SetPhyMdioWrite(port, 0x1c, 0xfc00);
+		HostPCIe_SetPhyMdioWrite(port, 0x1d, 0xa0eb);
+		HostPCIe_SetPhyMdioWrite(port, 0x1e, 0xc280);
+		HostPCIe_SetPhyMdioWrite(port, 0x1f, 0x05e0);
+
+#if 0 // PHY_EAT_40MHZ
+		HostPCIe_SetPhyMdioWrite(port, 5, 0xbcb);    //[9:3]=1111001 (binary)   121 (10)
+		HostPCIe_SetPhyMdioWrite(port, 6, 0x8128);  //[11]=0   [9:8]=01
+#endif
+		/*
+		emdiow 0 5027
+		emdiow 2 6d18
+		emdiow 6 8828
+		emdiow 7 30ff
+		emdiow 8 18dd
+		emdiow a e9
+		emdiow b 0511
+		emdiow d 15b6
+		emdiow f 0f0f
+		*/
+#else  // #if 0
+
+		HostPCIe_SetPhyMdioWrite(port, 0, 0xD187);
+		HostPCIe_SetPhyMdioWrite(port, 1, 0x0003);
+		HostPCIe_SetPhyMdioWrite(port, 2, 0x4d18);
+#if  1//PHY_EAT_40MHZ
+		HostPCIe_SetPhyMdioWrite(port, 5, 0x0BCB);   //40M
+#endif
+
+#if  1//PHY_EAT_40MHZ
+		HostPCIe_SetPhyMdioWrite(port, 6, 0xF148);  //40M
+#else
+		HostPCIe_SetPhyMdioWrite(port, 6, 0xf048);  //25M
+#endif
+
+		HostPCIe_SetPhyMdioWrite(port, 7, 0x31ff);
+		HostPCIe_SetPhyMdioWrite(port, 9, 0x531c);
+		HostPCIe_SetPhyMdioWrite(port, 0xd, 0x1766);
+		HostPCIe_SetPhyMdioWrite(port, 0xf, 0x0a00);
+
+#if HAVING_FIB
+		HostPCIe_SetPhyMdioWrite(port,8, 0x18dd);
+		HostPCIe_SetPhyMdioWrite(port, 0xd, 0x1776);
+#endif
+
+		HostPCIe_SetPhyMdioWrite(port, 0x19, 0xFCE0);
+		HostPCIe_SetPhyMdioWrite(port, 0x1e, 0xC280);
+#endif
 	}
 
 	//---------------------------------------
@@ -954,7 +1132,6 @@ int PCIE_reset_procedure(int PCIE_Port0and1_8196B_208pin, int Use_External_PCIE_
 	return SUCCESS;
 }
 #else	/*	defined(CONFIG_RTL8672)	*/
-static int pcie_reset_done = 0;
 int PCIE_reset_procedure(int PCIE_Port0and1_8196B_208pin, int Use_External_PCIE_CLK, int mdio_reset,unsigned long conf_addr)
 {
 	
@@ -1039,6 +1216,7 @@ int PCIE_reset_procedure(int PCIE_Port0and1_8196B_208pin, int Use_External_PCIE_
 		HostPCIe_SetPhyMdioWrite(port, 6, 0xF148);  //40M
 
 #else
+
 		printk("96C - 25MHz Clock Source\n");
 		HostPCIe_SetPhyMdioWrite(port, 6, 0xf848);  //25M
 #endif
@@ -1177,12 +1355,85 @@ void HostPCIe_Close(void)
 #endif	/*	!defined(CONFIG_NET_PCI)	*/
 #endif
 static void rtl8192cd_bcnProc(struct rtl8192cd_priv *priv, unsigned int bcnInt,
-				unsigned int bcnDmaOk, unsigned int bcnOk, unsigned int bcnErr, unsigned int status)
+				unsigned int bcnOk, unsigned int bcnErr, unsigned int status
+#ifdef CONFIG_RTL_88E_SUPPORT
+				, unsigned int status_ext
+#endif
+				)
 {
 #ifdef MBSSID
 	int i;
 #endif
 
+
+	/* ================================================================
+			Process Beacon OK/ERROR interrupt
+		================================================================ */
+	if ( bcnOk || bcnErr)
+	{
+
+#ifdef UNIVERSAL_REPEATER
+		struct rtl8192cd_priv *priv_root=NULL;
+		if ((OPMODE & WIFI_STATION_STATE) && GET_VXD_PRIV(priv) &&
+						(GET_VXD_PRIV(priv)->drv_state & DRV_STATE_VXD_AP_STARTED)) {
+			priv_root = priv;
+			priv = GET_VXD_PRIV(priv);
+		}
+#endif
+
+		//
+		// Statistics and LED counting
+		//
+		if (bcnOk) {
+			// for SW LED
+			if (((LED_TYPE >= LEDTYPE_SW_LINK_TXRX) && (LED_TYPE <= LEDTYPE_SW_LINKTXRX)) ||
+				(LED_TYPE == LEDTYPE_SW_LED2_GPIO8_LINKTXRX)||(LED_TYPE == LEDTYPE_SW_LED2_GPIO10_LINKTXRX)||
+				(LED_TYPE == LEDTYPE_SW_LED1_GPIO10_LINKTXRX))
+				priv->pshare->LED_tx_cnt++;
+#ifdef MBSSID
+			if (priv->pshare->bcnDOk_priv)
+				priv->pshare->bcnDOk_priv->ext_stats.beacon_ok++;
+#else
+			priv->ext_stats.beacon_ok++;
+#endif
+			SNMP_MIB_INC(dot11TransmittedFragmentCount, 1);
+
+			// disable high queue limitation
+			if ((OPMODE & WIFI_AP_STATE) && (priv->pshare->bcnDOk_priv)) {
+				if (*((unsigned char *)priv->pshare->bcnDOk_priv->beaconbuf + priv->pshare->bcnDOk_priv->timoffset + 4) & 0x01)  {
+					RTL_W16(RD_CTRL, RTL_R16(RD_CTRL) | HIQ_NO_LMT_EN);
+				}
+			}
+
+		} else if (bcnErr) {
+#ifdef MBSSID
+			if (priv->pshare->bcnDOk_priv)
+				priv->pshare->bcnDOk_priv->ext_stats.beacon_er++;
+#else
+			priv->ext_stats.beacon_er++;
+#endif
+		}
+
+#ifdef UNIVERSAL_REPEATER
+		if (priv_root != NULL)
+			priv = priv_root;
+#endif
+	}
+
+
+#ifdef PCIE_POWER_SAVING
+		if ((OPMODE & WIFI_AP_STATE) && (status & HIMR_BCNDOK0)) {
+			if ((priv->offload_ctrl & 1) && (priv->offload_ctrl >> 7) && priv->pshare->rf_ft_var.power_save) {
+				priv->offload_ctrl &= (~1);
+					update_beacon(priv);
+				delay_us(100);
+				RTL_W16(CR , RTL_R16(CR) & ~ENSWBCN);
+				return;
+			}
+		}
+#endif	
+	
+
 	/* ================================================================
 			Process Beacon interrupt
 	    ================================================================ */
@@ -1191,7 +1442,11 @@ static void rtl8192cd_bcnProc(struct rtl8192cd_priv *priv, unsigned int bcnInt,
 	//
 	if (bcnInt) {
 		unsigned char val8;
-		if (status & HIMR_BCNDMA0) {
+		if (
+#ifdef CONFIG_RTL_88E_SUPPORT
+			(GET_CHIP_VER(priv)==VERSION_8188E)?(status & HIMR_88E_BcnInt):
+#endif
+			(status & HIMR_BCNDMA0)) {
 #ifdef UNIVERSAL_REPEATER
 		if ((OPMODE & WIFI_STATION_STATE) && GET_VXD_PRIV(priv) &&
 						(GET_VXD_PRIV(priv)->drv_state & DRV_STATE_VXD_AP_STARTED)) {
@@ -1238,8 +1493,12 @@ static void rtl8192cd_bcnProc(struct rtl8192cd_priv *priv, unsigned int bcnInt,
 			if (GET_ROOT(priv)->pmib->miscEntry.vap_enable) {
 				for (i=0; i<RTL8192CD_NUM_VWLAN; i++) {
 					if ((priv->pvap_priv[i]->vap_init_seq > 0) && IS_DRV_OPEN(priv->pvap_priv[i])
-						&& (status & (HIMR_BCNDMA1 << (priv->pvap_priv[i]->vap_init_seq-1))))
-					{
+						&& (
+#ifdef CONFIG_RTL_88E_SUPPORT
+						(GET_CHIP_VER(priv)==VERSION_8188E)?(status_ext & (HIMRE_88E_BCNDMAINT1 <<
+						(priv->pvap_priv[i]->vap_init_seq-1))):
+#endif
+						(status & (HIMR_BCNDMA1 << (priv->pvap_priv[i]->vap_init_seq-1))))) {
 						if (priv->pvap_priv[i]->timoffset) {
 							update_beacon(priv->pvap_priv[i]);
 						}
@@ -1262,8 +1521,11 @@ static void rtl8192cd_bcnProc(struct rtl8192cd_priv *priv, unsigned int bcnInt,
 #endif
 
 		if ((OPMODE & WIFI_AP_STATE)) {
-
-			if (status & HIMR_BCNDMA0) {
+			if (
+#ifdef CONFIG_RTL_88E_SUPPORT
+				(GET_CHIP_VER(priv)==VERSION_8188E)?(status & HIMR_88E_BcnInt):
+#endif
+				(status & HIMR_BCNDMA0)) {
 				val8 = *((unsigned char *)priv->beaconbuf + priv->timoffset + 4);
 			if (val8 & 0x01) {
 				if(RTL_R8(BCN_CTRL) & DIS_ATIM)
@@ -1274,15 +1536,20 @@ static void rtl8192cd_bcnProc(struct rtl8192cd_priv *priv, unsigned int bcnInt,
 				if(!(RTL_R8(BCN_CTRL) & DIS_ATIM))
 					RTL_W8(BCN_CTRL, (RTL_R8(BCN_CTRL) | DIS_ATIM));				
 			}	
-#ifdef MBSSID
+//#ifdef MBSSID
 				priv->pshare->bcnDOk_priv = priv;
-#endif
+//#endif
 			}
 #ifdef MBSSID
 			else if (GET_ROOT(priv)->pmib->miscEntry.vap_enable) {
 				for (i=0; i<RTL8192CD_NUM_VWLAN; i++) {
 					if ((priv->pvap_priv[i]->vap_init_seq > 0) && IS_DRV_OPEN(priv->pvap_priv[i])
-						&& (status & (HIMR_BCNDMA1 << (priv->pvap_priv[i]->vap_init_seq-1)))) {
+						&& (
+#ifdef CONFIG_RTL_88E_SUPPORT
+						(GET_CHIP_VER(priv)==VERSION_8188E)?(status_ext & (HIMRE_88E_BCNDMAINT1 <<
+						(priv->pvap_priv[i]->vap_init_seq-1))):
+#endif
+						(status & (HIMR_BCNDMA1 << (priv->pvap_priv[i]->vap_init_seq-1))))) {
 						val8 = *((unsigned char *)priv->pvap_priv[i]->beaconbuf + priv->pvap_priv[i]->timoffset + 4);
 						if (val8 & 0x01) {
 							if(RTL_R8(BCN_CTRL) & DIS_ATIM)
@@ -1293,7 +1560,7 @@ static void rtl8192cd_bcnProc(struct rtl8192cd_priv *priv, unsigned int bcnInt,
 							if(!(RTL_R8(BCN_CTRL) & DIS_ATIM))
 								RTL_W8(BCN_CTRL, (RTL_R8(BCN_CTRL) | DIS_ATIM));
 						}
-						
+
 						priv->pshare->bcnDOk_priv = priv->pvap_priv[i];
 					}
 				}
@@ -1302,7 +1569,8 @@ static void rtl8192cd_bcnProc(struct rtl8192cd_priv *priv, unsigned int bcnInt,
 
 		}
 
-		if (priv->pshare->pkt_in_hiQ) {
+//		if (priv->pshare->pkt_in_hiQ) {
+		if (priv->pshare->bcnDOk_priv && priv->pshare->bcnDOk_priv->pkt_in_hiQ) {
 			int pre_head = get_txhead(priv->pshare->phw, MCAST_QNUM);
 			do {
 				txdesc_rollback(&pre_head);
@@ -1315,76 +1583,18 @@ static void rtl8192cd_bcnProc(struct rtl8192cd_priv *priv, unsigned int bcnInt,
 				ClearMData(phdr);
 			}
 			tx_poll(priv, MCAST_QNUM);
-			priv->pshare->pkt_in_hiQ = 0;
-		}			
-		
-#ifdef UNIVERSAL_REPEATER
-		if (priv_root != NULL)
-			priv = priv_root;
-#endif
-	}
-
-	/* ================================================================
-			Process Beacon OK/ERROR interrupt
-	    ================================================================ */
-	if (bcnDmaOk || bcnOk || bcnErr)
-	{
-
-#ifdef UNIVERSAL_REPEATER
-		struct rtl8192cd_priv *priv_root=NULL;
-		if ((OPMODE & WIFI_STATION_STATE) && GET_VXD_PRIV(priv) &&
-						(GET_VXD_PRIV(priv)->drv_state & DRV_STATE_VXD_AP_STARTED)) {
-			priv_root = priv;
-			priv = GET_VXD_PRIV(priv);
+//				priv->pshare->pkt_in_hiQ = 0;
 		}
-#endif
 
-		//
-		// Polling highQ as there is multicast waiting for tx...
-		//
-		if ((OPMODE & WIFI_AP_STATE) && bcnDmaOk) {
-#ifdef PCIE_POWER_SAVING
-			if ((priv->offload_ctrl & 1) && (priv->offload_ctrl >> 7) && priv->pshare->rf_ft_var.power_save) {
-				priv->offload_ctrl &= (~1);
-					update_beacon(priv);
-				RTL_W16(0x100 , RTL_R16(0x100) & ~BIT(8));		// disable sw beacon
-				return;
-			}
-#endif	
-		
-		}
-
-		//
-		// Statistics and LED counting
-		//
-		if (bcnOk) {
-			// for SW LED
-			if (((LED_TYPE >= LEDTYPE_SW_LINK_TXRX) && (LED_TYPE <= LEDTYPE_SW_LINKTXRX)) ||
-				(LED_TYPE == LEDTYPE_SW_LED2_GPIO8_LINKTXRX)||(LED_TYPE == LEDTYPE_SW_LED2_GPIO10_LINKTXRX)||
-				(LED_TYPE == LEDTYPE_SW_LED1_GPIO10_LINKTXRX))
-				priv->pshare->LED_tx_cnt++;
-#ifdef MBSSID
-			if (priv->pshare->bcnDOk_priv)
-				priv->pshare->bcnDOk_priv->ext_stats.beacon_ok++;
-#else
-			priv->ext_stats.beacon_ok++;
-#endif
-			SNMP_MIB_INC(dot11TransmittedFragmentCount, 1);
-		} else if (bcnErr) {
-#ifdef MBSSID
-			if (priv->pshare->bcnDOk_priv)
-				priv->pshare->bcnDOk_priv->ext_stats.beacon_er++;
-#else
-			priv->ext_stats.beacon_er++;
-#endif
-		}
 
 #ifdef UNIVERSAL_REPEATER
 		if (priv_root != NULL)
 			priv = priv_root;
 #endif
+
 	}
 
+	
 #ifdef CLIENT_MODE
 	//
 	// Ad-hoc beacon status
@@ -1403,9 +1613,25 @@ void check_dma_error(struct rtl8192cd_priv *priv, unsigned int status, unsigned
 {
 	unsigned char reg_rxdma;
 	unsigned int reg_txdma;
-	int clear_isr=0;
+	int clear_isr=0, check_tx_dma, check_rx_dma;
+
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv)==VERSION_8188E) {
+		if ((status_ext & HIMRE_88E_RXFOVW) | (status_ext & HIMRE_88E_RXERR))
+			check_rx_dma++;
+		if ((status_ext & HIMRE_88E_TXFOVW) | (status_ext & HIMRE_88E_TXERR))
+			check_tx_dma++;
+	} else
+#endif
+	{
+		if ((status & HIMR_RXFOVW) | (status_ext & HIMRE_RXERR))
+			check_rx_dma++;
 
-	if ((status & HIMR_RXFOVW) | (status_ext & HIMRE_RXERR)) {
+		if ((status & HIMR_TXFOVW) | (status_ext & HIMRE_TXERR))
+			check_tx_dma++;
+	}
+
+	if (check_rx_dma) {
 		reg_rxdma = RTL_R8(RXDMA_STATUS);
 		if (reg_rxdma) {
 			RTL_W8(RXDMA_STATUS, reg_rxdma);
@@ -1414,7 +1640,7 @@ void check_dma_error(struct rtl8192cd_priv *priv, unsigned int status, unsigned
 		}
 	}
 
-	if ((status & HIMR_TXFOVW) | (status_ext & HIMRE_TXERR)) {
+	if (check_tx_dma) {
 		reg_txdma = RTL_R32(TXDMA_STATUS);
 		if (reg_txdma) {
 			RTL_W32(TXDMA_STATUS, reg_txdma);
@@ -1424,14 +1650,24 @@ void check_dma_error(struct rtl8192cd_priv *priv, unsigned int status, unsigned
 	}
 
 	if (clear_isr) {
-		RTL_W32(HISR, status);
-		RTL_W32(HISRE, status_ext);
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv)==VERSION_8188E) {
+			RTL_W32(REG_88E_HISR, status);
+			RTL_W32(REG_88E_HISRE, status_ext);
+		} else
+#endif
+		{
+			RTL_W32(HISR, status);
+			RTL_W32(HISRE, status_ext);
+		}
 	}
 }
 
 #define	RTL_WLAN_INT_RETRY_MAX	(32)
 __MIPS16
+#ifndef CONFIG_ETHWAN
 __IRAM_IN_865X
+#endif
 __inline__ static int __rtl8192cd_interrupt(void *dev_instance)
 {
 	struct net_device *dev;
@@ -1439,12 +1675,13 @@ __inline__ static int __rtl8192cd_interrupt(void *dev_instance)
 	struct rtl8192cd_hw *phw;
 
 	unsigned int status, status_ext, retry_cnt;
-	unsigned int caseBcnInt, caseBcnDmaOK, caseBcnStatusOK, caseBcnStatusER;
+	unsigned int caseBcnInt, caseBcnStatusOK, caseBcnStatusER;
 	unsigned int caseRxStatus, caseRxRDU;
 	#if 0 //TESTCHIP_SUPPORT || defined(SMART_CONCURRENT_92D) // --fwdebug
 	unsigned int caseTimer1;
 	#endif
-	#ifdef SUPPORT_TX_AMSDU
+	
+	#if	defined(SUPPORT_TX_AMSDU) || defined(P2P_SUPPORT)
 	unsigned int caseTimer2;
 	#endif
 #if defined (SUPPORT_TX_AMSDU) || defined (SMART_CONCURRENT_92D)
@@ -1485,10 +1722,24 @@ __inline__ static int __rtl8192cd_interrupt(void *dev_instance)
 	}
 #endif
 
-	status = RTL_R32(HISR);
-	RTL_W32(HISR, status);
-	status_ext = RTL_R32(HISRE);
-	RTL_W32(HISRE, status_ext);
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv)==VERSION_8188E) {
+		status = RTL_R32(REG_88E_HISR);
+		RTL_W32(REG_88E_HISR, status);
+		if (status & HIMR_88E_HISR1_IND_INT) {
+			status_ext = RTL_R32(REG_88E_HISRE);
+			RTL_W32(REG_88E_HISRE, status_ext);
+		} else {
+			status_ext = 0;
+		}
+	} else
+#endif
+	{
+		status = RTL_R32(HISR);
+		RTL_W32(HISR, status);
+		status_ext = RTL_R32(HISRE);
+		RTL_W32(HISRE, status_ext);
+	}
 	if (status == 0 && status_ext == 0) {
 		goto int_exit;
 	}
@@ -1496,47 +1747,88 @@ __inline__ static int __rtl8192cd_interrupt(void *dev_instance)
 	retry_cnt = 0;
 retry_process:
 	
-	caseBcnInt = caseBcnDmaOK = caseBcnStatusOK = caseBcnStatusER = 0;
+	caseBcnInt = caseBcnStatusOK = caseBcnStatusER = 0;
 	caseRxStatus = caseRxRDU = 0;
 	#if 0 //TESTCHIP_SUPPORT || defined(SMART_CONCURRENT_92D) // --fwdebug
 	caseTimer1 = 0;
 	#endif
-	#ifdef SUPPORT_TX_AMSDU
-	caseTimer2 = 0
+	
+	#if	defined(SUPPORT_TX_AMSDU) || defined(P2P_SUPPORT)
+	caseTimer2 = 0;
 	#endif
 	
-#ifdef TXREPORT
-	if(status_ext & BIT(9) ) {
-		C2H_isr(priv);
+#if defined(TXREPORT) && (defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT))
+	if (
+#ifdef CONFIG_RTL_92C_SUPPORT
+		(GET_CHIP_VER(priv)==VERSION_8192C) || (GET_CHIP_VER(priv)==VERSION_8188C)
+#endif
+#ifdef CONFIG_RTL_92D_SUPPORT
+#ifdef CONFIG_RTL_92C_SUPPORT
+		|| 
+#endif
+		(GET_CHIP_VER(priv)==VERSION_8192D)
+#endif
+		) {
+		if(status_ext & BIT(9))
+			C2H_isr(priv);
 	}
 #endif
 
 	check_dma_error(priv, status, status_ext);
 
-	if (status & (HIMR_BCNDMA0 | HIMR_BCNDMA1 | HIMR_BCNDMA2 | HIMR_BCNDMA3 | HIMR_BCNDMA4 | HIMR_BCNDMA5 | HIMR_BCNDMA6 | HIMR_BCNDMA7))
-		caseBcnInt = 1;
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv)==VERSION_8188E) {
+		if ((status & HIMR_88E_BcnInt) || (status_ext & (HIMRE_88E_BCNDMAINT1 | HIMRE_88E_BCNDMAINT2
+			| HIMRE_88E_BCNDMAINT3 | HIMRE_88E_BCNDMAINT4 | HIMRE_88E_BCNDMAINT5
+			| HIMRE_88E_BCNDMAINT6 | HIMRE_88E_BCNDMAINT7))) {
+			caseBcnInt = 1;
+		}
 
-	if (status & (HIMR_BCNDOK0 | HIMR_BCNDOK1 | HIMR_BCNDOK2 | HIMR_BCNDOK3 | HIMR_BCNDOK4 | HIMR_BCNDOK5 | HIMR_BCNDOK6 | HIMR_BCNDOK7))
-		caseBcnDmaOK = 1;
+		if (status & HIMR_88E_TBDOK)
+			caseBcnStatusOK = 1;
 
-	if (status & HIMR_TXBCNOK)
-		caseBcnStatusOK = 1;
+		if (status & HIMR_88E_TBDER)
+			caseBcnStatusER = 1;
 
-	if (status & HIMR_TXBCNERR)
-		caseBcnStatusER = 1;
+		if (status & (HIMR_88E_ROK | HIMR_88E_RDU)) {
+			caseRxStatus = 1;
 
-	if (status & (HIMR_ROK | HIMR_RDU))
-		caseRxStatus = 1;
+			if (status & HIMR_88E_RDU) {
+				priv->ext_stats.rx_rdu++;
+				caseRxRDU = 1;
+				priv->pshare->skip_mic_chk = SKIP_MIC_NUM;
+			}
+		}
 
-	if (status & HIMR_RDU) {
-		priv->ext_stats.rx_rdu++;
-		caseRxRDU = 1;
-		priv->pshare->skip_mic_chk = SKIP_MIC_NUM;
-	}
+		if (status_ext & HIMRE_88E_RXFOVW) {
+			priv->ext_stats.rx_fifoO++;
+			priv->pshare->skip_mic_chk = SKIP_MIC_NUM;
+		}
+	} else
+#endif
+	{
+		if (status & (HIMR_BCNDMA0 | HIMR_BCNDMA1 | HIMR_BCNDMA2 | HIMR_BCNDMA3 | HIMR_BCNDMA4 | HIMR_BCNDMA5 | HIMR_BCNDMA6 | HIMR_BCNDMA7))
+			caseBcnInt = 1;
+
+		if (status & HIMR_TXBCNOK)
+			caseBcnStatusOK = 1;
 
-	if (status & HIMR_RXFOVW) {
-		priv->ext_stats.rx_fifoO++;
-		priv->pshare->skip_mic_chk = SKIP_MIC_NUM;
+		if (status & HIMR_TXBCNERR)
+			caseBcnStatusER = 1;
+
+		if (status & (HIMR_ROK | HIMR_RDU))
+			caseRxStatus = 1;
+
+		if (status & HIMR_RDU) {
+			priv->ext_stats.rx_rdu++;
+			caseRxRDU = 1;
+			priv->pshare->skip_mic_chk = SKIP_MIC_NUM;
+		}
+
+		if (status & HIMR_RXFOVW) {
+			priv->ext_stats.rx_fifoO++;
+			priv->pshare->skip_mic_chk = SKIP_MIC_NUM;
+		}
 	}
 
 	#if 0 //TESTCHIP_SUPPORT || defined(SMART_CONCURRENT_92D) // --fwdebug
@@ -1544,13 +1836,17 @@ retry_process:
 		caseTimer1 = 1;
 	#endif
 
-	#ifdef SUPPORT_TX_AMSDU
+	#if	defined(SUPPORT_TX_AMSDU) || defined(P2P_SUPPORT)
 	if (status & HIMR_TIMEOUT2)
 		caseTimer2 = 1;
 	#endif
 
-	if (caseBcnInt || caseBcnDmaOK || caseBcnStatusOK || caseBcnStatusER){
-                rtl8192cd_bcnProc(priv, caseBcnInt, caseBcnDmaOK, caseBcnStatusOK, caseBcnStatusER, status);
+	if (caseBcnInt || caseBcnStatusOK || caseBcnStatusER){
+                rtl8192cd_bcnProc(priv, caseBcnInt, caseBcnStatusOK, caseBcnStatusER, status
+#ifdef CONFIG_RTL_88E_SUPPORT
+			, status_ext
+#endif
+			);
         }
 
 	//
@@ -1564,8 +1860,16 @@ retry_process:
 #if defined(RX_TASKLET)
 		if (!priv->pshare->has_triggered_rx_tasklet) {
 			priv->pshare->has_triggered_rx_tasklet = 1;
-			//RTL_W32(HIMR, priv->pshare->InterruptMask & ~(HIMR_RXFOVW | HIMR_RDU | HIMR_ROK));
-			RTL_W32(HIMR, priv->pshare->InterruptMask & ~(HIMR_RXFOVW | HIMR_ROK));
+#ifdef CONFIG_RTL_88E_SUPPORT
+			if (GET_CHIP_VER(priv)==VERSION_8188E) {
+				RTL_W32(REG_88E_HIMR, priv->pshare->InterruptMask & ~HIMR_88E_ROK);
+				RTL_W32(REG_88E_HIMRE, priv->pshare->InterruptMaskExt & ~HIMRE_88E_RXFOVW);
+			} else
+#endif
+			{
+				//RTL_W32(HIMR, priv->pshare->InterruptMask & ~(HIMR_RXFOVW | HIMR_RDU | HIMR_ROK));
+				RTL_W32(HIMR, priv->pshare->InterruptMask & ~(HIMR_RXFOVW | HIMR_ROK));
+			}
 			tasklet_hi_schedule(&priv->pshare->rx_tasklet);
 		}
 #else
@@ -1608,12 +1912,12 @@ retry_process:
 #endif
 	else
 #endif
-	if ((CIRC_CNT_RTK(phw->txhead0, phw->txtail0, NUM_TX_DESC) > 10) ||
-		(CIRC_CNT_RTK(phw->txhead1, phw->txtail1, NUM_TX_DESC) > 10) ||
-		(CIRC_CNT_RTK(phw->txhead2, phw->txtail2, NUM_TX_DESC) > 10) ||
-		(CIRC_CNT_RTK(phw->txhead3, phw->txtail3, NUM_TX_DESC) > 10) ||
-		(CIRC_CNT_RTK(phw->txhead4, phw->txtail4, NUM_TX_DESC) > 10) ||
-		(CIRC_CNT_RTK(phw->txhead5, phw->txtail5, NUM_TX_DESC) > 10)
+	if ((CIRC_CNT_RTK(phw->txhead0, phw->txtail0, CURRENT_NUM_TX_DESC) > 10) ||
+		(CIRC_CNT_RTK(phw->txhead1, phw->txtail1, CURRENT_NUM_TX_DESC) > 10) ||
+		(CIRC_CNT_RTK(phw->txhead2, phw->txtail2, CURRENT_NUM_TX_DESC) > 10) ||
+		(CIRC_CNT_RTK(phw->txhead3, phw->txtail3, CURRENT_NUM_TX_DESC) > 10) ||
+		(CIRC_CNT_RTK(phw->txhead4, phw->txtail4, CURRENT_NUM_TX_DESC) > 10) ||
+		(CIRC_CNT_RTK(phw->txhead5, phw->txtail5, CURRENT_NUM_TX_DESC) > 10)
 	) {
 #ifdef __KERNEL__
 		if (!priv->pshare->has_triggered_tx_tasklet) {
@@ -1676,16 +1980,45 @@ retry_process:
 	}
 #endif
 
-	status = RTL_R32(HISR);
-	status_ext = RTL_R32(HISRE);
+
+#ifdef P2P_SUPPORT
+	if( OPMODE&WIFI_P2P_SUPPORT &&	(P2PMODE==P2P_CLIENT)) {
+		if (caseTimer2) {
+			RTL_W32(HIMR, RTL_R32(HIMR) & ~HIMR_TIMEOUT2);
+			p2p_noa_timer(priv);
+		}
+	}
+#endif
+
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv)==VERSION_8188E) {
+		status = RTL_R32(REG_88E_HISR);
+		if (status & HIMR_88E_HISR1_IND_INT)
+			status_ext = RTL_R32(REG_88E_HISRE);
+		else
+			status_ext = 0;
+	} else
+#endif
+	{
+		status = RTL_R32(HISR);
+		status_ext = RTL_R32(HISRE);
+	}
 
 	if ((status!=0||status_ext!=0) && ((retry_cnt++)<RTL_WLAN_INT_RETRY_MAX)) {
 		#if defined(CONFIG_RTL865X_WTDOG) || defined(CONFIG_RTL_WTDOG)
 		REG32(BSP_WDTCNR) |=  1 << 23;
 		#endif
-		RTL_W32(HISR, status);
-		RTL_W32(HISRE, status_ext);
-		
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv)==VERSION_8188E) {
+			RTL_W32(REG_88E_HISR, status);
+			RTL_W32(REG_88E_HISRE, status_ext);
+		} else
+#endif
+		{
+			RTL_W32(HISR, status);
+			RTL_W32(HISRE, status_ext);
+		}
+
 		goto retry_process;
 	}
 
@@ -1899,18 +2232,23 @@ static int rtl8192cd_init_sw(struct rtl8192cd_priv *priv)
 			if (!priv->reset_hangup)
 #endif
 			{
+#ifdef SMART_REPEATER_MODE
+				if (!priv->pshare->switch_chan_rp)
+#endif
+				{
 #ifdef PCIE_POWER_SAVING
-				tasklet_init(&priv->pshare->ps_tasklet, PCIe_power_save_tasklet, (unsigned long)priv);
+					tasklet_init(&priv->pshare->ps_tasklet, PCIe_power_save_tasklet, (unsigned long)priv);
 #endif
 #if !(defined(RTL8190_ISR_RX) && defined(RTL8190_DIRECT_RX))
-				tasklet_init(&priv->pshare->rx_tasklet, rtl8192cd_rx_dsr, (unsigned long)priv);
+					tasklet_init(&priv->pshare->rx_tasklet, rtl8192cd_rx_dsr, (unsigned long)priv);
 #else
 #ifdef RX_TASKLET
-				tasklet_init(&priv->pshare->rx_tasklet, rtl8192cd_rx_tkl_isr, (unsigned long)priv);
+					tasklet_init(&priv->pshare->rx_tasklet, rtl8192cd_rx_tkl_isr, (unsigned long)priv);
 #endif
 #endif
-				tasklet_init(&priv->pshare->tx_tasklet, rtl8192cd_tx_dsr, (unsigned long)priv);
-				tasklet_init(&priv->pshare->oneSec_tasklet, rtl8192cd_expire_timer, (unsigned long)priv);
+					tasklet_init(&priv->pshare->tx_tasklet, rtl8192cd_tx_dsr, (unsigned long)priv);
+					tasklet_init(&priv->pshare->oneSec_tasklet, rtl8192cd_expire_timer, (unsigned long)priv);
+				}
 			}
 		}
 #endif // __KERNEL__
@@ -1975,7 +2313,13 @@ static int rtl8192cd_init_sw(struct rtl8192cd_priv *priv)
 	if (!priv->reset_hangup)
 #endif
 	{
-		priv->up_time = 0;
+#ifdef SMART_REPEATER_MODE
+		if (!priv->pshare->switch_chan_rp)
+#endif
+		{
+		
+			priv->up_time = 0;
+		}
 	}
 
 #if defined(CLIENT_MODE) && defined(CHECK_HANGUP)
@@ -2169,11 +2513,11 @@ static int rtl8192cd_init_sw(struct rtl8192cd_priv *priv)
 				struct tx_desc *tx_desc_ptr = tx_desc_array[txDescRingIdx];
 
 #if defined(NOT_RTK_BSP)
-				for (i=0; i<NUM_TX_DESC; i++) {
+				for (i=0; i<CURRENT_NUM_TX_DESC; i++) {
 					tx_desc_dma_ptr[i]= tx_dma_start + txDescRingIdx*NUM_TX_DESC * sizeof(struct tx_desc) + i*sizeof(struct tx_desc);
 				}
 #else
-				for (i=0; i<NUM_TX_DESC; i++) {
+				for (i=0; i<CURRENT_NUM_TX_DESC; i++) {
 					tx_desc_dma_ptr[i] = get_physical_addr(priv, (void *)(&(tx_desc_ptr[i])),
 						sizeof(struct tx_desc), PCI_DMA_TODEVICE);
 				}
@@ -2222,7 +2566,7 @@ static int rtl8192cd_init_sw(struct rtl8192cd_priv *priv)
 		}
 
 		// Nothing to do for Tx desc...
-		for(i=0; i<NUM_TX_DESC; i++)
+		for(i=0; i<CURRENT_NUM_TX_DESC; i++)
 		{
 			init_txdesc(priv, phw->tx_desc0, phw->tx_ring0_addr, i);
 			init_txdesc(priv, phw->tx_desc1, phw->tx_ring1_addr, i);
@@ -2250,6 +2594,12 @@ static int rtl8192cd_init_sw(struct rtl8192cd_priv *priv)
 		for(i=0; i<=HIGH_QUEUE; ++i) {
 			priv->use_txdesc_cnt[i] = 0;
 		}
+
+#ifdef USE_TXQUEUE
+		for(i=0; i<=HIGH_QUEUE; i++) {
+			priv->use_txq_cnt[i] = 0;
+		}
+#endif
 		
 #ifdef MBSSID
 		if (priv->pmib->miscEntry.vap_enable){
@@ -2258,6 +2608,11 @@ static int rtl8192cd_init_sw(struct rtl8192cd_priv *priv)
 				for (j=0; j<=HIGH_QUEUE; ++j){
 					priv->pvap_priv[i]->use_txdesc_cnt[j] = 0;
 				}
+#ifdef USE_TXQUEUE
+				for (j=0; j<=HIGH_QUEUE; j++) {
+					priv->pvap_priv[i]->use_txq_cnt[j] = 0;
+				}
+#endif
 			}
 		}
 #endif	// #ifdef MBSSID
@@ -2266,6 +2621,11 @@ static int rtl8192cd_init_sw(struct rtl8192cd_priv *priv)
 			for(i=0; i<=HIGH_QUEUE; ++i) {
 				GET_VXD_PRIV(priv)->use_txdesc_cnt[i] = 0;
 			}
+#ifdef USE_TXQUEUE
+			for(i=0; i<=HIGH_QUEUE; ++i) {
+				GET_VXD_PRIV(priv)->use_txq_cnt[i] = 0;
+			}
+#endif
 		}
 #endif	// #ifdef UNIVERSAL_REPEATER
 #endif	// #ifdef RESERVE_TXDESC_FOR_EACH_IF
@@ -2280,7 +2640,41 @@ static int rtl8192cd_init_sw(struct rtl8192cd_priv *priv)
 
 #ifdef RX_BUFFER_GATHER
 		INIT_LIST_HEAD(&priv->pshare->gather_list);
-#endif		
+#endif	
+
+#ifdef USE_TXQUEUE
+		if (init_txq_pool(&priv->pshare->txq_pool, &priv->pshare->txq_pool_addr)) {
+			printk("Can not init tx queue pool.\n");
+			return 1;
+		}
+		for (i=0; i<7; i++)
+			init_txq_head(&(priv->pshare->txq_list[i]));
+		priv->pshare->txq_isr = 0;
+		priv->pshare->txq_stop = 0;
+		priv->pshare->txq_check = 0;
+#endif	
+
+		if (priv->pmib->dot11RFEntry.tx2path) {
+			if (priv->pmib->dot11RFEntry.txbf) {
+				priv->pmib->dot11RFEntry.txbf = 0;
+				DEBUG_INFO("Disable txbf due to tx2path\n");
+			}
+			if (priv->pmib->dot11nConfigEntry.dot11nSTBC) {
+				priv->pmib->dot11nConfigEntry.dot11nSTBC = 0;
+				DEBUG_INFO("Disable stbc due to tx2path\n");
+			}
+		}
+		else if (priv->pmib->dot11RFEntry.txbf) {
+			if (priv->pmib->dot11nConfigEntry.dot11nSTBC) {
+				priv->pmib->dot11nConfigEntry.dot11nSTBC = 0;
+				DEBUG_INFO("Disable stbc due to txbf\n");
+			}
+		}
+#ifdef TX_EARLY_MODE
+		if ((GET_CHIP_VER(priv) == VERSION_8192C || GET_CHIP_VER(priv) == VERSION_8188C)
+				&& GET_TX_EARLY_MODE)
+			GET_TX_EARLY_MODE = 0;			
+#endif
 	}
 
 	INIT_LIST_HEAD(&priv->wlan_acl_list);
@@ -2568,6 +2962,7 @@ static int rtl8192cd_init_sw(struct rtl8192cd_priv *priv)
 #endif
 			) {
 			GET_EDCA_PARA_UPDATE = 0;
+/*			
 			//BK
 			GET_STA_AC_BK_PARA.AIFSN = 7;
 			GET_STA_AC_BK_PARA.TXOPlimit = 0;
@@ -2600,14 +2995,24 @@ static int rtl8192cd_init_sw(struct rtl8192cd_priv *priv)
 			GET_STA_AC_VO_PARA.ACM = 0;
 			GET_STA_AC_VO_PARA.ECWmin = 2;
 			GET_STA_AC_VO_PARA.ECWmax = 3;
+*/
+			default_WMM_para(priv);
 
 			//init WMM Para ie in beacon
 			init_WMM_Para_Element(priv, priv->pmib->dot11QosEntry.WMM_PARA_IE);
 		}
 #ifdef CLIENT_MODE
-		else if (OPMODE & WIFI_STATION_STATE)
+		else if (OPMODE & WIFI_STATION_STATE) {
 			init_WMM_Para_Element(priv, priv->pmib->dot11QosEntry.WMM_IE);  //  WMM STA
+		}
 #endif
+
+		if (AMSDU_ENABLE || AMPDU_ENABLE) {
+			if (priv->pmib->dot11nConfigEntry.dot11nTxNoAck) {
+				priv->pmib->dot11nConfigEntry.dot11nTxNoAck = 0;
+				PRINT_INFO("Tx No Ack is off because aggregation is enabled.\n");
+			}
+		}
 	}
 #endif
 
@@ -2826,7 +3231,12 @@ static int rtl8192cd_init_sw(struct rtl8192cd_priv *priv)
 #endif
 
 #ifdef STA_EXT
-	priv->pshare->fw_free_space = FW_NUM_STAT - 2; // One for MAGANEMENT_AID, one for other STAs
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv)==VERSION_8188E)
+		priv->pshare->fw_free_space = RTL8188E_NUM_STAT - 2;
+	else
+#endif
+		priv->pshare->fw_free_space = FW_NUM_STAT - 2; // One for MAGANEMENT_AID, one for other STAs
 #endif
 
 #ifdef CONFIG_RTK_VLAN_SUPPORT
@@ -2864,47 +3274,47 @@ static int rtl8192cd_init_sw(struct rtl8192cd_priv *priv)
 #ifdef MBSSID
 	// if vap enabled, set beacon int to 100 at minimun when guest ssid num <= 4
     // if vap enabled, set beacon int to 200 at minimun when guest ssid num > 4
-    {
-        int ssid_num = 1, minbcn_period;
-        priv->bcn_period_bak = priv->pmib->dot11StationConfigEntry.dot11BeaconPeriod;
-
-        if ((OPMODE & WIFI_AP_STATE) && GET_ROOT(priv)->pmib->miscEntry.vap_enable)
-        {
-            for (i=0; i<RTL8192CD_NUM_VWLAN; i++)
-            {
-                if (GET_ROOT(priv)->pvap_priv[i] && IS_DRV_OPEN(GET_ROOT(priv)->pvap_priv[i]))
-                {
-                    ssid_num++;
-                }
-            }
-        }
+	{
+		int ssid_num = 1, minbcn_period;
+		priv->bcn_period_bak = priv->pmib->dot11StationConfigEntry.dot11BeaconPeriod;
 
-        if (ssid_num >= 5)
-            minbcn_period = 200;
-        else
-            minbcn_period = 100;
+		if ((OPMODE & WIFI_AP_STATE) && GET_ROOT(priv)->pmib->miscEntry.vap_enable)
+		{
+			for (i=0; i<RTL8192CD_NUM_VWLAN; i++)
+	        {
+		        if (GET_ROOT(priv)->pvap_priv[i] && IS_DRV_OPEN(GET_ROOT(priv)->pvap_priv[i]))
+			    {
+				    ssid_num++;
+	            }
+		    }
+	    }
+		
+		if (ssid_num >= 5)
+			minbcn_period = 200;
+		else
+			minbcn_period = 100;
 
 		// if vap enabled, set beacon int to 100 at minimun
-        if ((OPMODE & WIFI_AP_STATE) && GET_ROOT(priv)->pmib->miscEntry.vap_enable
-            && priv->pmib->dot11StationConfigEntry.dot11BeaconPeriod < minbcn_period)
-            priv->pmib->dot11StationConfigEntry.dot11BeaconPeriod = minbcn_period;
+		if ((OPMODE & WIFI_AP_STATE) && GET_ROOT(priv)->pmib->miscEntry.vap_enable
+			&& priv->pmib->dot11StationConfigEntry.dot11BeaconPeriod < minbcn_period)
+			priv->pmib->dot11StationConfigEntry.dot11BeaconPeriod = minbcn_period;
 
-        if ((OPMODE & WIFI_AP_STATE) && GET_ROOT(priv)->pmib->miscEntry.vap_enable)
+		if ((OPMODE & WIFI_AP_STATE) && GET_ROOT(priv)->pmib->miscEntry.vap_enable)
         {
             for (i=0; i<RTL8192CD_NUM_VWLAN; i++)
             {
                 if (GET_ROOT(priv)->pvap_priv[i])
                 {
                         GET_ROOT(priv)->pvap_priv[i]->pmib->dot11StationConfigEntry.dot11BeaconPeriod = priv->pmib->dot11StationConfigEntry.dot11BeaconPeriod;
-                        GET_ROOT(priv)->pvap_priv[i]->update_bcn_period = 1;
+						GET_ROOT(priv)->pvap_priv[i]->update_bcn_period = 1;
                 }
             }
 
             GET_ROOT(priv)->pmib->dot11StationConfigEntry.dot11BeaconPeriod = priv->pmib->dot11StationConfigEntry.dot11BeaconPeriod;
-            GET_ROOT(priv)->update_bcn_period = 1;
+			GET_ROOT(priv)->update_bcn_period = 1;
 
         }
-    }
+	}
 #endif
 
 #ifdef DOT11D
@@ -2952,11 +3362,23 @@ static int rtl8192cd_init_sw(struct rtl8192cd_priv *priv)
 	}
 #endif
 
-#ifdef TXREPORT
-	priv->pshare->sta_query_idx=-1;
+#if defined(TXREPORT) && (defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT))
+	if (
+#ifdef CONFIG_RTL_92C_SUPPORT
+		(GET_CHIP_VER(priv)==VERSION_8192C) || (GET_CHIP_VER(priv)==VERSION_8188C)
+#endif
+#ifdef CONFIG_RTL_92D_SUPPORT
+#ifdef CONFIG_RTL_92C_SUPPORT
+		|| 
+#endif
+		(GET_CHIP_VER(priv)==VERSION_8192D)
+#endif
+		) {
+		priv->pshare->sta_query_idx=-1;
 
-	// Init StaDetectInfo to detect disappearing STA. Added by Annie, 2010-08-10.
-	priv->pmib->staDetectInfo.txRprDetectPeriod = 1;
+		// Init StaDetectInfo to detect disappearing STA. Added by Annie, 2010-08-10.
+		priv->pmib->staDetectInfo.txRprDetectPeriod = 1;
+	}
 #endif
 
 #ifdef	INCLUDE_WPS
@@ -2965,6 +3387,62 @@ static int rtl8192cd_init_sw(struct rtl8192cd_priv *priv)
 #endif
 			wps_init(priv);
 #endif
+#ifdef P2P_SUPPORT
+	if(OPMODE & WIFI_P2P_SUPPORT ){
+		p2p_init(priv);
+		P2P_DEBUG("%s under P2P mode now\n",priv->dev->name);		
+	}
+#endif
+
+#ifdef CONFIG_RTK_MESH
+		/*
+		 * CAUTION !! These statement meshX(virtual interface) ONLY, Maybe modify....
+		 * These statment is initial information, (If "ZERO" no need set it, because all cleared to ZERO)
+		 */
+		if(init_mesh(priv) <0)
+			return 1;
+#endif
+
+#ifdef TLN_STATS
+	if (priv->pshare->rf_ft_var.stats_time_interval)
+		priv->stats_time_countdown = priv->pshare->rf_ft_var.stats_time_interval;
+#endif
+	
+#if defined (SUPPORT_TX_MCAST2UNI)
+		/*ipv4 mdns*/
+		priv->pshare->rf_ft_var.mc2u_flood_mac[0].macAddr[0]=0x01;
+		priv->pshare->rf_ft_var.mc2u_flood_mac[0].macAddr[1]=0x00;
+		priv->pshare->rf_ft_var.mc2u_flood_mac[0].macAddr[2]=0x5e;
+		priv->pshare->rf_ft_var.mc2u_flood_mac[0].macAddr[3]=0x00;
+		priv->pshare->rf_ft_var.mc2u_flood_mac[0].macAddr[4]=0x00;
+		priv->pshare->rf_ft_var.mc2u_flood_mac[0].macAddr[5]=0xfb;
+	
+		/*ipv4 upnp&m-search*/
+		priv->pshare->rf_ft_var.mc2u_flood_mac[1].macAddr[0]=0x01;
+		priv->pshare->rf_ft_var.mc2u_flood_mac[1].macAddr[1]=0x00;
+		priv->pshare->rf_ft_var.mc2u_flood_mac[1].macAddr[2]=0x5e;
+		priv->pshare->rf_ft_var.mc2u_flood_mac[1].macAddr[3]=0x7f;
+		priv->pshare->rf_ft_var.mc2u_flood_mac[1].macAddr[4]=0xff;
+		priv->pshare->rf_ft_var.mc2u_flood_mac[1].macAddr[5]=0xfa;
+	
+		/*ipv6 mdns*/
+		priv->pshare->rf_ft_var.mc2u_flood_mac[2].macAddr[0]=0x33;
+		priv->pshare->rf_ft_var.mc2u_flood_mac[2].macAddr[1]=0x33;
+		priv->pshare->rf_ft_var.mc2u_flood_mac[2].macAddr[2]=0x00;
+		priv->pshare->rf_ft_var.mc2u_flood_mac[2].macAddr[3]=0x00;
+		priv->pshare->rf_ft_var.mc2u_flood_mac[2].macAddr[4]=0x00;
+		priv->pshare->rf_ft_var.mc2u_flood_mac[2].macAddr[5]=0xfb;
+	
+		/*ipv6 upnp&m-search*/
+		priv->pshare->rf_ft_var.mc2u_flood_mac[3].macAddr[0]=0x33;
+		priv->pshare->rf_ft_var.mc2u_flood_mac[3].macAddr[1]=0x33;
+		priv->pshare->rf_ft_var.mc2u_flood_mac[3].macAddr[2]=0x7f;
+		priv->pshare->rf_ft_var.mc2u_flood_mac[3].macAddr[3]=0xff;
+		priv->pshare->rf_ft_var.mc2u_flood_mac[3].macAddr[4]=0xff;
+		priv->pshare->rf_ft_var.mc2u_flood_mac[3].macAddr[5]=0xfa;
+		
+		priv->pshare->rf_ft_var.mc2u_flood_mac_num=4;
+#endif
 
 	return 0;
 }
@@ -3013,6 +3491,9 @@ static int rtl8192cd_stop_sw(struct rtl8192cd_priv *priv)
 #ifdef CHECK_HANGUP
 		&&(!priv->reset_hangup)
 #endif
+#ifdef SMART_REPEATER_MODE
+		&&(!priv->pshare->switch_chan_rp)
+#endif
 		)
 		{
 			wapiExit(priv);
@@ -3037,7 +3518,8 @@ static int rtl8192cd_stop_sw(struct rtl8192cd_priv *priv)
 #ifdef PCIE_POWER_SAVING
 	if (timer_pending(&priv->ps_timer))
 		del_timer_sync(&priv->ps_timer);
-#endif
+#endif		
+
 #ifdef CONFIG_RTK_MESH
 		/*
 		 * CAUTION !! These statement meshX(virtual interface) ONLY, Maybe modify....
@@ -3050,6 +3532,18 @@ static int rtl8192cd_stop_sw(struct rtl8192cd_priv *priv)
 			del_timer_sync(&priv->mesh_auth_timer);
 #endif
 #endif
+
+#if defined(CONFIG_RTL_92D_SUPPORT) && defined(DPK_92D)
+		if (GET_CHIP_VER(priv) == VERSION_8192D){
+			if (timer_pending(&priv->pshare->DPKTimer))
+				del_timer_sync(&priv->pshare->DPKTimer);
+		}
+#endif
+
+#ifdef SMART_REPEATER_MODE
+		if (timer_pending(&priv->pshare->check_vxd_ap))			
+			del_timer_sync(&priv->pshare->check_vxd_ap);
+#endif
 	}
 	if (timer_pending(&priv->ss_timer))
 		del_timer_sync(&priv->ss_timer);
@@ -3113,6 +3607,40 @@ static int rtl8192cd_stop_sw(struct rtl8192cd_priv *priv)
 		del_timer_sync(&priv->wpa_global_info->GKRekeyTimer);
 #endif
 
+#ifdef USE_TXQUEUE
+	for (i=0; i<7; i++) {
+		struct txq_node *pnode, *phead, *pnext;
+
+		phead = (struct txq_node *)&(priv->pshare->txq_list[i].list);
+		pnode = phead->list.next;
+		pnext = pnode;
+		while (pnext != phead)
+		{
+			pnode = pnext;
+			pnext = pnext->list.next;
+			if (pnode->skb && pnode->dev && pnode->dev->priv == priv) {
+				unlink_txq(&(priv->pshare->txq_list[i]), pnode);
+				rtl_kfree_skb(priv, pnode->skb, _SKB_TX_);
+				pnode->skb = pnode->dev = NULL;
+				list_add_tail(&pnode->list, &priv->pshare->txq_pool);
+			}
+		}
+	}
+
+#if defined(UNIVERSAL_REPEATER) || defined(MBSSID)
+#if defined(RESERVE_TXDESC_FOR_EACH_IF)
+	for (i=0; i<7; i++) {
+		priv->use_txq_cnt[i] = 0;
+	}
+#endif
+
+	if (IS_ROOT_INTERFACE(priv))
+#endif
+	{
+		free_txq_pool(&priv->pshare->txq_pool,priv->pshare->txq_pool_addr);
+	}
+#endif
+
 #if defined(UNIVERSAL_REPEATER) || defined(MBSSID)
 	if (IS_ROOT_INTERFACE(priv))
 #endif
@@ -3124,6 +3652,9 @@ static int rtl8192cd_stop_sw(struct rtl8192cd_priv *priv)
 		if (timer_pending(&priv->ch_avail_chk_timer))
 			del_timer_sync(&priv->ch_avail_chk_timer);
 
+		if (timer_pending(&priv->dfs_chk_timer))
+			del_timer_sync(&priv->dfs_chk_timer);
+
 		/*
 		 *	when we disable the DFS function dynamically, we also remove the channel
 		 *	from NOP_chnl while the driver is rebooting
@@ -3251,9 +3782,23 @@ static int rtl8192cd_stop_sw(struct rtl8192cd_priv *priv)
 			if (!priv->reset_hangup)
 #endif
 			{
-				tasklet_kill(&priv->pshare->rx_tasklet);
-				tasklet_kill(&priv->pshare->tx_tasklet);
-				tasklet_kill(&priv->pshare->oneSec_tasklet);
+#ifdef P2P_SUPPORT
+				if((OPMODE&WIFI_P2P_SUPPORT))
+				{
+
+				}else
+#endif				
+				{
+#ifdef SMART_REPEATER_MODE
+					if (!priv->pshare->switch_chan_rp)
+#endif
+					{				
+						tasklet_kill(&priv->pshare->rx_tasklet);
+						tasklet_kill(&priv->pshare->tx_tasklet);				
+						tasklet_kill(&priv->pshare->oneSec_tasklet);
+					}
+				}
+
 			}
 		}
 #endif // __KERNEL__
@@ -3283,7 +3828,7 @@ static int rtl8192cd_stop_sw(struct rtl8192cd_priv *priv)
 		DEBUG_INFO("free tx Q4 head %d tail %d\n", phw->txhead4, phw->txtail4);
 		DEBUG_INFO("free tx Q5 head %d tail %d\n", phw->txhead5, phw->txtail5);
 
-		for (i=0; i<NUM_TX_DESC; i++)
+		for (i=0; i<CURRENT_NUM_TX_DESC; i++)
 		{
 			// free tx queue skb
 			struct tx_desc_info *tx_info;
@@ -3294,7 +3839,7 @@ static int rtl8192cd_stop_sw(struct rtl8192cd_priv *priv)
 				head = get_txhead(phw, j);
 				tail = get_txtail(phw, j);
 //				if (i <tail || i >= head)
-				if( (tail < head) ? (i <tail || i >= head) :(i <tail && i >= head))
+				if( (tail <= head) ? (i <tail || i >= head) :(i <tail && i >= head))
 					continue;
 
 				tx_info = get_txdesc_info(priv->pshare->pdesc_info, j);
@@ -3310,12 +3855,43 @@ static int rtl8192cd_stop_sw(struct rtl8192cd_priv *priv)
 					if (IS_PCIBIOS_TYPE)
 						pci_unmap_single(priv->pshare->pdev, tx_info[i].paddr, (tx_info[i].len), PCI_DMA_TODEVICE);
 #endif
+
+
+#if 1//def CONFIG_RTL8672
+#ifdef MP_TEST
+					if ((OPMODE & (WIFI_MP_STATE|WIFI_MP_CTX_BACKGROUND))==(WIFI_MP_STATE|WIFI_MP_CTX_BACKGROUND)) {
+						priv->pshare->skb_tail = (priv->pshare->skb_tail + 1) & (NUM_MP_SKB - 1);
+					}
+					else
+#endif
+					{
+						rtl_kfree_skb(priv, tx_info[i].pframe, _SKB_TX_);
+						DEBUG_INFO("free skb in queue %d\n", j);
+					}
+#else //CONFIG_RTL8672
 					rtl_kfree_skb(priv, tx_info[i].pframe, _SKB_TX_);
 					DEBUG_INFO("free skb in queue %d\n", j);
+#endif //CONFIG_RTL8672
 				}
 			}
 		} // TX descriptor Free
 
+
+#if 1//def CONFIG_RTL8672
+#ifdef MP_TEST
+		if ((OPMODE & (WIFI_MP_STATE|WIFI_MP_CTX_BACKGROUND))==(WIFI_MP_STATE|WIFI_MP_CTX_BACKGROUND)) {
+			OPMODE &= ~WIFI_MP_CTX_BACKGROUND;
+			
+			for (i=0; i<NUM_MP_SKB; i++)
+				kfree(priv->pshare->skb_pool[i]->head);
+			kfree(priv->pshare->skb_pool_ptr);
+			
+			DEBUG_INFO("[%s %d] skb_head/skb_tail=%d/%d\n",
+					__FUNCTION__, __LINE__, priv->pshare->skb_head, priv->pshare->skb_tail);
+		}
+#endif
+#endif
+
 #ifdef CONFIG_NET_PCI
 		// unmap  beacon buffer
 		if (IS_PCIBIOS_TYPE) {
@@ -3478,11 +4054,6 @@ static int rtl8192cd_stop_sw(struct rtl8192cd_priv *priv)
 		priv->dz_queue.tail = 0;
 	}
 
-#ifdef MP_TEST
-	if (!priv->pshare->rf_ft_var.mp_specific)
-#endif
-	priv->pshare->ThermalValue = 0;
-
 	RESTORE_INT(flags);
 	return 0;
 }
@@ -3594,9 +4165,11 @@ static void rtl8192cd_init_mbssid(struct rtl8192cd_priv *priv)
 		RTL_W8(BCN_CTRL, 0);
 		RTL_W8(0x553, 1);
 
+#ifdef CONFIG_RTL_92C_SUPPORT
 		if (IS_TEST_CHIP(priv))
 			RTL_W8(BCN_CTRL, EN_BCN_FUNCTION |EN_MBSSID| DIS_SUB_STATE | DIS_TSF_UPDATE|EN_TXBCN_RPT);
 		else
+#endif
 			RTL_W8(BCN_CTRL, EN_BCN_FUNCTION | DIS_SUB_STATE_N | DIS_TSF_UPDATE_N|EN_TXBCN_RPT);
 
 		RTL_W32(RCR, RTL_R32(RCR) | RCR_MBID_EN);	// MBSSID enable
@@ -3623,18 +4196,34 @@ static void rtl8192cd_init_mbssid(struct rtl8192cd_priv *priv)
 			RTL_W32((MBIDCAMCFG+4)-4*j, camData[j]);
 		}
 //		RTL_W8(_MBIDCAMCFG_, BIT(7) | BIT(6) | ((unsigned char)priv->vap_init_seq & 0x1f));
-		RTL_W32(MBSSID_BCN_SPACE,
-			((priv->pmib->dot11StationConfigEntry.dot11BeaconPeriod-
-			((priv->pmib->dot11StationConfigEntry.dot11BeaconPeriod/(priv->vap_init_seq+1))*priv->vap_init_seq))
-			& BCN_SPACE2_Mask)<<BCN_SPACE2_SHIFT
-			|((priv->pmib->dot11StationConfigEntry.dot11BeaconPeriod/(priv->vap_init_seq+1)) & BCN_SPACE1_Mask)
-			<<BCN_SPACE1_SHIFT);
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv)==VERSION_8188E) {
+			unsigned int vap_bcn_offset = (priv->pmib->dot11StationConfigEntry.dot11BeaconPeriod-
+				((priv->pmib->dot11StationConfigEntry.dot11BeaconPeriod/(priv->vap_init_seq+1))*priv->vap_init_seq)-1)
+				& BCN_SPACE2_Mask;
+
+			if (vap_bcn_offset > 200)
+				vap_bcn_offset = 200;
+			RTL_W32(MBSSID_BCN_SPACE, (vap_bcn_offset & BCN_SPACE2_Mask)<<BCN_SPACE2_SHIFT
+				|(priv->pmib->dot11StationConfigEntry.dot11BeaconPeriod & BCN_SPACE1_Mask)<<BCN_SPACE1_SHIFT);
+		} else
+#endif
+		{
+			RTL_W32(MBSSID_BCN_SPACE,
+				((priv->pmib->dot11StationConfigEntry.dot11BeaconPeriod-
+				((priv->pmib->dot11StationConfigEntry.dot11BeaconPeriod/(priv->vap_init_seq+1))*priv->vap_init_seq))
+				& BCN_SPACE2_Mask)<<BCN_SPACE2_SHIFT
+				|((priv->pmib->dot11StationConfigEntry.dot11BeaconPeriod/(priv->vap_init_seq+1)) & BCN_SPACE1_Mask)
+				<<BCN_SPACE1_SHIFT);
+		}
 		RTL_W8(BCN_CTRL, 0);
 		RTL_W8(0x553, 1);
 
+#ifdef CONFIG_RTL_92C_SUPPORT
 		if (IS_TEST_CHIP(priv))
 			RTL_W8(BCN_CTRL, EN_BCN_FUNCTION |EN_MBSSID| DIS_SUB_STATE | DIS_TSF_UPDATE|EN_TXBCN_RPT);
 		else
+#endif
 			RTL_W8(BCN_CTRL, EN_BCN_FUNCTION | DIS_SUB_STATE_N | DIS_TSF_UPDATE_N|EN_TXBCN_RPT);
 
 
@@ -3669,9 +4258,11 @@ static void rtl8192cd_stop_mbssid(struct rtl8192cd_priv *priv)
 
 		RTL_W8(BCN_CTRL, 0);
 		RTL_W8(0x553, 1);
+#ifdef CONFIG_RTL_92C_SUPPORT
 		if (IS_TEST_CHIP(priv))
 			RTL_W8(BCN_CTRL, EN_BCN_FUNCTION | DIS_SUB_STATE | DIS_TSF_UPDATE| EN_TXBCN_RPT);
 		else
+#endif
 			RTL_W8(BCN_CTRL, EN_BCN_FUNCTION | DIS_SUB_STATE_N | DIS_TSF_UPDATE_N| EN_TXBCN_RPT);
 
 	}
@@ -3687,17 +4278,34 @@ static void rtl8192cd_stop_mbssid(struct rtl8192cd_priv *priv)
 
 		if (RTL_R8(MBID_NUM) & MBID_BCN_NUM_Mask) {
 			RTL_W8(MBID_NUM, (RTL_R8(MBID_NUM)-1) & MBID_BCN_NUM_Mask);
-			RTL_W32(MBSSID_BCN_SPACE,
-			((priv->pmib->dot11StationConfigEntry.dot11BeaconPeriod-
-			((priv->pmib->dot11StationConfigEntry.dot11BeaconPeriod/(RTL_R8(MBID_NUM)+1))*RTL_R8(MBID_NUM)))
-			& BCN_SPACE2_Mask)<<BCN_SPACE2_SHIFT
-			|((priv->pmib->dot11StationConfigEntry.dot11BeaconPeriod/(RTL_R8(MBID_NUM)+1)) & BCN_SPACE1_Mask)
-			<<BCN_SPACE1_SHIFT);
+#ifdef CONFIG_RTL_88E_SUPPORT
+			if (GET_CHIP_VER(priv)==VERSION_8188E) {
+				unsigned int vap_bcn_offset = (priv->pmib->dot11StationConfigEntry.dot11BeaconPeriod-
+					((priv->pmib->dot11StationConfigEntry.dot11BeaconPeriod/(RTL_R8(MBID_NUM)+1))
+					*RTL_R8(MBID_NUM))-1) & BCN_SPACE2_Mask;
+
+				if (vap_bcn_offset > 200)
+					vap_bcn_offset = 200;
+				RTL_W32(MBSSID_BCN_SPACE, (vap_bcn_offset & BCN_SPACE2_Mask)<<BCN_SPACE2_SHIFT|
+					(priv->pmib->dot11StationConfigEntry.dot11BeaconPeriod & BCN_SPACE1_Mask)<<BCN_SPACE1_SHIFT);
+			} else
+#endif
+			{
+				RTL_W32(MBSSID_BCN_SPACE,
+				((priv->pmib->dot11StationConfigEntry.dot11BeaconPeriod-
+				((priv->pmib->dot11StationConfigEntry.dot11BeaconPeriod/(RTL_R8(MBID_NUM)+1))*RTL_R8(MBID_NUM)))
+				& BCN_SPACE2_Mask)<<BCN_SPACE2_SHIFT
+				|((priv->pmib->dot11StationConfigEntry.dot11BeaconPeriod/(RTL_R8(MBID_NUM)+1)) & BCN_SPACE1_Mask)
+				<<BCN_SPACE1_SHIFT);
+			}
+
 			RTL_W8(BCN_CTRL, 0);
 			RTL_W8(0x553, 1);
+#ifdef CONFIG_RTL_92C_SUPPORT
 			if (IS_TEST_CHIP(priv))
 				RTL_W8(BCN_CTRL, EN_BCN_FUNCTION | DIS_SUB_STATE | DIS_TSF_UPDATE| EN_TXBCN_RPT);
 			else
+#endif
 				RTL_W8(BCN_CTRL, EN_BCN_FUNCTION | DIS_SUB_STATE_N | DIS_TSF_UPDATE_N| EN_TXBCN_RPT);
 
 		}
@@ -3806,7 +4414,16 @@ struct stat_info *add_wds_entry(struct rtl8192cd_priv *priv, int idx, unsigned c
 		DOT11_Process_Set_Key(priv->dev, NULL, &Set_Key, priv->pmib->dot11WdsInfo.wdsMapingKey[idx]);
 			}
 
-			add_update_RATid(priv, pstat);
+#ifdef CONFIG_RTL_88E_SUPPORT
+			if (GET_CHIP_VER(priv)==VERSION_8188E) {
+#ifdef TXREPORT
+				add_RATid(priv, pstat);
+#endif
+			} else
+#endif
+			{
+				add_update_RATid(priv, pstat);
+			}
 	pstat->wds_idx = idx;
 			assign_tx_rate(priv, pstat, NULL);
 			assign_aggre_mthod(priv, pstat);
@@ -3897,21 +4514,38 @@ void recalc_txdesc_limit(struct rtl8192cd_priv *priv)
 #endif
 
 	if (total_if <= 1) {
-		root_priv->pshare->num_txdesc_cnt = NUM_TX_DESC - 2;  // 2 for space...
-		root_priv->pshare->num_txdesc_upper_limit = NUM_TX_DESC - 2;
+		root_priv->pshare->num_txdesc_cnt = CURRENT_NUM_TX_DESC - 2;  // 2 for space...
+		root_priv->pshare->num_txdesc_upper_limit = CURRENT_NUM_TX_DESC - 2;
 		root_priv->pshare->num_txdesc_lower_limit = 0;
+#ifdef USE_TXQUEUE
+		root_priv->pshare->num_txq_cnt = TXQUEUE_SIZE;
+		root_priv->pshare->num_txq_upper_limit = TXQUEUE_SIZE;
+		root_priv->pshare->num_txq_lower_limit = 0;
+#endif
 		return;
 	}
 	
-	num = (NUM_TX_DESC * IF_TXDESC_UPPER_LIMIT) / 100;
+	num = (CURRENT_NUM_TX_DESC * IF_TXDESC_UPPER_LIMIT) / 100;
 	root_priv->pshare->num_txdesc_upper_limit = num;
 	
-	num = ((NUM_TX_DESC - 2) - num) / (total_if - 1);
+	num = ((CURRENT_NUM_TX_DESC - 2) - num) / (total_if - 1);
 	root_priv->pshare->num_txdesc_lower_limit = num;
 
 	num = root_priv->pshare->num_txdesc_upper_limit + 
 			root_priv->pshare->num_txdesc_lower_limit * (total_if - 1);
 	root_priv->pshare->num_txdesc_cnt = num;
+
+#ifdef USE_TXQUEUE
+	num = (TXQUEUE_SIZE * IF_TXQ_UPPER_LIMIT) / 100;
+	root_priv->pshare->num_txq_upper_limit = num;
+
+	num = (TXQUEUE_SIZE - num) / (total_if - 1);
+	root_priv->pshare->num_txq_lower_limit = num;
+
+	num = root_priv->pshare->num_txq_upper_limit +
+			root_priv->pshare->num_txq_lower_limit * (total_if - 1);
+	root_priv->pshare->num_txq_cnt = num;
+#endif
 }
 #endif
 
@@ -4027,7 +4661,7 @@ int rtl8192cd_open(struct net_device *dev)
 	if (IS_ROOT_INTERFACE(priv))
 #endif
 	{			
-		if ( CheckNoResetHwExceptionCase(priv) ) {
+		if ( check_MAC_IO_Enable(priv) ) {
 			rtl8192cd_stop_hw(priv);
 		}
 	}
@@ -4122,29 +4756,44 @@ int rtl8192cd_open(struct net_device *dev)
 	if (!is_reset)
 #endif
 	{
-		if (OPMODE & WIFI_AP_STATE)
+#ifdef P2P_SUPPORT
+		int p2p_support_mode=0;
+		if (OPMODE & WIFI_P2P_SUPPORT)
+			p2p_support_mode=1;	
+#endif
+		if (OPMODE & WIFI_AP_STATE) {
 			OPMODE = WIFI_AP_STATE;
+		}
 #ifdef CLIENT_MODE
 		else if (OPMODE & WIFI_STATION_STATE) {
 			OPMODE = WIFI_STATION_STATE;
-#if defined(WIFI_WMM) && defined(WMM_APSD)
-			APSD_ENABLE = 0;
-#endif
-		}
-		else if (OPMODE & WIFI_ADHOC_STATE) {
+		} else if (OPMODE & WIFI_ADHOC_STATE) {
 			OPMODE = WIFI_ADHOC_STATE;
-#ifdef WIFI_WMM
-#ifdef WMM_APSD
+#if defined(WIFI_WMM) && defined(WMM_APSD)
 			APSD_ENABLE = 0;
 #endif
-#endif
 		}
 #endif
 		else {
 			printk("Undefined state... using AP mode as default\n");
 			OPMODE = WIFI_AP_STATE;
 		}
+
+#ifdef P2P_SUPPORT
+		if(p2p_support_mode)
+			OPMODE |= WIFI_P2P_SUPPORT;
+#endif		
+	}
+
+#if defined(UNIVERSAL_REPEATER) && defined(CLIENT_MODE)
+	if (IS_VXD_INTERFACE(priv) &&
+		((GET_MIB(GET_ROOT_PRIV(priv)))->dot11OperationEntry.opmode & WIFI_STATION_STATE)) {
+		if (!chklink_wkstaQ(GET_ROOT_PRIV(priv))) {
+			printk("Root interface does not link yet!\n");
+			return 0;
+		}
 	}
+#endif
 
 #ifdef MBSSID
 	if (GET_ROOT(priv)->pmib->miscEntry.vap_enable)
@@ -4160,12 +4809,57 @@ int rtl8192cd_open(struct net_device *dev)
 				return -1;
 			}
 			else {
+#ifdef CONFIG_RTL8672
+				do {
+					if (GET_ROOT_PRIV(priv)->pmib->dot11OperationEntry.opmode & WIFI_WAIT_FOR_CHANNEL_SELECT) {
+						DEBUG_INFO("wait for root interface ss_timer!!\n");
+						delay_ms(1);
+					}
+					else {
+						DEBUG_INFO("channel=%x\n", GET_ROOT_PRIV(priv)->pmib->dot11RFEntry.dot11channel);
+						break;
+					}
+				}while(1);
+#endif
 				rtl8192cd_init_vap_mib(priv);
 			}
 		}
 	}
 #endif
 
+// check phyband and channel match or not
+
+	if(priv->pshare->rf_ft_var.mp_specific) //For MP nfjrom to open WLAN0 successfully
+	{
+		if ((priv->pmib->dot11RFEntry.dot11channel <= 14) && (priv->pmib->dot11RFEntry.phyBandSelect != PHY_BAND_2G))
+		{
+			priv->pmib->dot11BssType.net_work_type = WIRELESS_11A | WIRELESS_11N;
+			priv->pmib->dot11RFEntry.phyBandSelect != PHY_BAND_5G;
+			priv->pmib->dot11RFEntry.dot11channel = 36;
+		}
+		else if((priv->pmib->dot11RFEntry.dot11channel > 14) && (priv->pmib->dot11RFEntry.phyBandSelect != PHY_BAND_5G))
+		{
+			priv->pmib->dot11BssType.net_work_type = WIRELESS_11B | WIRELESS_11G | WIRELESS_11N;
+			priv->pmib->dot11RFEntry.phyBandSelect != PHY_BAND_2G;
+			priv->pmib->dot11RFEntry.dot11channel = 1;
+		}
+
+		if((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C))
+		{
+			priv->pmib->dot11BssType.net_work_type = WIRELESS_11B | WIRELESS_11G | WIRELESS_11N;
+			priv->pmib->dot11RFEntry.phyBandSelect != PHY_BAND_2G;
+			priv->pmib->dot11RFEntry.dot11channel = 1;
+		}
+	}
+	else if(priv->pmib->dot11RFEntry.dot11channel != 0)
+	{
+		if (((priv->pmib->dot11RFEntry.dot11channel <= 14) && (priv->pmib->dot11RFEntry.phyBandSelect != PHY_BAND_2G))||((priv->pmib->dot11RFEntry.dot11channel > 14) && (priv->pmib->dot11RFEntry.phyBandSelect != PHY_BAND_5G)))
+		{
+			panic_printk("wlan phyband select error, wlan close!!! (phyband=%d, channel=%d)\n", priv->pmib->dot11RFEntry.phyBandSelect, priv->pmib->dot11RFEntry.dot11channel);
+			return -1;
+		}
+	}
+
 #if defined(BR_SHORTCUT)
 #if defined(UNIVERSAL_REPEATER) || defined(MBSSID)
 	if(IS_ROOT_INTERFACE(priv))
@@ -4173,6 +4867,20 @@ int rtl8192cd_open(struct net_device *dev)
 		clear_shortcut_cache();
 #endif
 
+#if defined(UNIVERSAL_REPEATER) || defined(MBSSID)
+	if (IS_ROOT_INTERFACE(priv))
+#endif
+	{
+		priv->pshare->current_num_tx_desc = NUM_TX_DESC;
+
+#if defined (CONFIG_RTL_92D_SUPPORT) && defined(CONFIG_RTL_92D_DMDP)
+		if ((GET_CHIP_VER(priv) == VERSION_8192D) && 
+			(priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY)) 
+			priv->pshare->current_num_tx_desc = (NUM_TX_DESC>MAX_NUM_TX_DESC_DMDP)?
+				(MAX_NUM_TX_DESC_DMDP):(NUM_TX_DESC);
+#endif
+	}
+
 	rc = rtl8192cd_init_sw(priv);
     if (rc)
         return rc;
@@ -4262,6 +4970,31 @@ do_hw_init:
 			}
 		}
 #endif
+
+
+#if defined(CONFIG_AUTO_PCIE_PHY_SCAN) && defined(CONFIG_RTL_8196E)
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if(GET_CHIP_VER(priv)==VERSION_8188E)
+		{
+		if ((REG32(0xb8000008)&0x2000000)==0x2000000)  //40MHz
+		{
+			printk("\n\n 88E 40M TEST 0x11=0x5b \n\n");
+			
+			//RTL_W8(0x11, 0x5b);
+			//RTL_W8(0x2c, ((RTL_R8(0x2c) & 0xf0) | 0x1));
+		}
+		else //25MHz
+		{
+			printk("\n\n 88E 25M TEST 0x11=0x5b, 0x2c[0:3]=0x1 \n\n");
+			
+			//RTL_W8(0x11, 0x5b);
+			RTL_W8(0x2c, ((RTL_R8(0x2c) & 0xf0) | 0x1));
+		}
+		}
+#endif
+#endif
+
+
 		rc = rtl8192cd_init_hw_PCI(priv);
 		//delay_ms(200);		// TODO: need refinement, for 98 watchdog time out
 
@@ -4275,8 +5008,10 @@ do_hw_init:
 //			RTL_W32(IDR4, (cpu_to_le32(reg)));
 			RTL_W16(MACID+4, (cpu_to_le16(reg)));
 #ifdef CONFIG_RTL_92D_SUPPORT
-			RTL_W32(MACID1 , RTL_R32(MACID));
-			RTL_W16(MACID1+4, RTL_R16(MACID+4));
+			if (GET_CHIP_VER(priv) == VERSION_8192D) {
+				RTL_W32(MACID1 , RTL_R32(MACID));
+				RTL_W16(MACID1+4, RTL_R16(MACID+4));
+			}
 #endif
 		}
 
@@ -4343,9 +5078,16 @@ if (GET_CHIP_VER(priv)==VERSION_8192D) {
 
 		if (IS_VAP_INTERFACE(priv)) {
 			// set BcnDmaInt & BcnOk of different VAP in IMR
-				priv->pshare->InterruptMask |= (HIMR_BCNDOK1 << (priv->vap_init_seq-1)) |
-					(HIMR_BCNDMA1 << (priv->vap_init_seq-1));
+#ifdef CONFIG_RTL_88E_SUPPORT
+			if (GET_CHIP_VER(priv) == VERSION_8188E) {
+				priv->pshare->InterruptMaskExt |= (HIMRE_88E_BCNDMAINT1 << (priv->vap_init_seq-1));
+				RTL_W32(REG_88E_HIMRE, priv->pshare->InterruptMaskExt);
+			} else
+#endif
+			{
+				priv->pshare->InterruptMask |= (HIMR_BCNDMA1 << (priv->vap_init_seq-1));
 				RTL_W32(HIMR, priv->pshare->InterruptMask);
+			}
 
 			if (GET_ROOT_PRIV(priv)->auto_channel == 0) {
 				priv->pmib->dot11RFEntry.dot11channel = GET_ROOT_PRIV(priv)->pmib->dot11RFEntry.dot11channel;
@@ -4375,6 +5117,15 @@ if (GET_CHIP_VER(priv)==VERSION_8192D) {
 	priv->ss_timer.data = (unsigned long) priv;
 	priv->ss_timer.function = rtl8192cd_ss_timer;
 
+
+#ifdef P2P_SUPPORT
+	init_timer(&priv->p2p_listen_timer_t);
+	init_timer(&priv->p2p_search_timer_t);		
+	priv->p2p_search_timer_t.data = (unsigned long) priv;
+	priv->p2p_search_timer_t.function = p2p_search_timer;	
+	priv->p2p_listen_timer_t.data = (unsigned long) priv;
+	priv->p2p_listen_timer_t.function = P2P_listen_timer;
+#endif
 #ifdef CONFIG_RTL_COMAPI_WLTOOLS
 	init_waitqueue_head(&priv->ss_wait);
 #endif
@@ -4405,7 +5156,7 @@ if (GET_CHIP_VER(priv)==VERSION_8192D) {
 	priv->frag_to_filter.function = rtl8192cd_frag_timer;
 	mod_timer(&priv->frag_to_filter, jiffies + FRAG_TO);
 
-#ifdef DETECT_STA_EXISTANCE
+#if defined(DETECT_STA_EXISTANCE) && (defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT))
 	// Added by Annie for Retry Limit Recovery Timer, 2010-08-10.
 	init_timer(&priv->pshare->rl_recover_timer);
 	priv->pshare->rl_recover_timer.data = (unsigned long) priv;
@@ -4454,7 +5205,26 @@ if (GET_CHIP_VER(priv)==VERSION_8192D) {
 		priv->pshare->phw->tpt_timer.data = (unsigned long)priv;
 		priv->pshare->phw->tpt_timer.function = rtl8192cd_tpt_timer;
 #endif
+#if defined(CONFIG_RTL_92D_SUPPORT) && defined(DPK_92D)
+		if (GET_CHIP_VER(priv) == VERSION_8192D){
+			init_timer(&priv->pshare->DPKTimer);
+			priv->pshare->DPKTimer.data = (unsigned long) priv;
+			priv->pshare->DPKTimer.function = rtl8192cd_DPK_timer;
+		}
+#endif
+
+	}
+
+#ifdef SMART_REPEATER_MODE
+	if (IS_ROOT_INTERFACE(priv)) {
+		init_timer(&priv->pshare->check_vxd_ap);
+		priv->pshare->check_vxd_ap.expires = jiffies + CHECK_VXD_AP_TIMEOUT;
+		priv->pshare->check_vxd_ap.data = (unsigned long) priv;
+		priv->pshare->check_vxd_ap.function = check_vxd_ap_timer;
+		if (OPMODE == WIFI_AP_STATE)		
+			mod_timer(&priv->pshare->check_vxd_ap, jiffies + CHECK_VXD_AP_TIMEOUT);
 	}
+#endif
 
 	// for MIC check
 	init_timer(&priv->MIC_check_timer);
@@ -4503,58 +5273,6 @@ if (GET_CHIP_VER(priv)==VERSION_8192D) {
 
 #endif
 
-#ifdef CONFIG_RTK_MESH
-	/*
-	 * CAUTION !! These statement meshX(virtual interface) ONLY, Maybe modify....
-	 * These statment is initial information, (If "ZERO" no need set it, because all cleared to ZERO)
-	 */
-	init_timer(&priv->mesh_peer_link_timer);
-	priv->mesh_peer_link_timer.data = (unsigned long) priv;
-	priv->mesh_peer_link_timer.function = mesh_peer_link_timer;
-
-#ifdef MESH_BOOTSEQ_AUTH
-	init_timer(&priv->mesh_auth_timer);
-	priv->mesh_auth_timer.data = (unsigned long) priv;
-	priv->mesh_auth_timer.function = mesh_auth_timer;
-#endif
-
-	priv->mesh_Version = 1;
-#ifdef	MESH_ESTABLISH_RSSI_THRESHOLD
-	priv->mesh_fake_mib.establish_rssi_threshold = DEFAULT_ESTABLISH_RSSI_THRESHOLD;
-#endif
-
-#ifdef MESH_USE_METRICOP
-	// in next version, the fake_mib related values will be actually recorded in MIB
-	priv->mesh_fake_mib.metricID = 1; // 0: very old version,  1: version before 2009/3/10,  2: 11s
-	priv->mesh_fake_mib.isPure11s = 0;
-	priv->mesh_fake_mib.intervalMetricAuto = RTL_SECONDS_TO_JIFFIES(60); // 1 Mins
-	priv->mesh_fake_mib.spec11kv.defPktTO = RTL_SECONDS_TO_JIFFIES(2); // 2 * 100 = 2 secs
-	priv->mesh_fake_mib.spec11kv.defPktLen = 1024; // bt=8196 bits
-	priv->mesh_fake_mib.spec11kv.defPktCnt = 2;
-	priv->mesh_fake_mib.spec11kv.defPktPri = 5;
-
-	// once driver starts up, toMeshMetricAuto will be updated
-	// (I think it might be put in "init one" to match our original concept...)
-	priv->toMeshMetricAuto = jiffies + priv->mesh_fake_mib.intervalMetricAuto;
-#endif // MESH_USE_METRICOP
-
-	mesh_set_PeerLink_CAP(priv, GET_MIB(priv)->dot1180211sInfo.mesh_max_neightbor);
-
-	priv->mesh_PeerCAP_flags = 0x80;		// Bit15(Operation as MP) shall be "1"
-	priv->mesh_HeaderFlags = 0;				// NO Address Extension
-
-	// The following info can be saved by FLASH in the future
-	priv->mesh_profile[0].used = TRUE;
-	priv->mesh_profile[0].PathSelectMetricID.value = 0;
-	priv->mesh_profile[0].PathSelectMetricID.OUI[0] = 0x00;
-	priv->mesh_profile[0].PathSelectMetricID.OUI[1] = 0x0f;
-	priv->mesh_profile[0].PathSelectMetricID.OUI[2] = 0xac;
-	priv->mesh_profile[0].PathSelectProtocolID.value = 0;
-	priv->mesh_profile[0].PathSelectProtocolID.OUI[0] = 0x00;
-	priv->mesh_profile[0].PathSelectProtocolID.OUI[1] = 0x0f;
-	priv->mesh_profile[0].PathSelectProtocolID.OUI[2] = 0xac;
-#endif
-
 
 #if defined(UNIVERSAL_REPEATER) || defined(MBSSID)
 	if (IS_ROOT_INTERFACE(priv))
@@ -4565,6 +5283,14 @@ if (GET_CHIP_VER(priv)==VERSION_8192D) {
 			enable_hw_LED(priv, LED_TYPE);
 		else if ((LED_TYPE >= LEDTYPE_SW_LINK_TXRX) && (LED_TYPE < LEDTYPE_SW_MAX))
 			enable_sw_LED(priv, 1);
+
+#ifdef CONFIG_RTL_ULINKER
+		{
+			extern void enable_sys_LED(struct rtl8192cd_priv *priv);
+			enable_sys_LED(priv);
+		}
+#endif
+
 #ifdef SW_ANT_SWITCH
 		dm_SW_AntennaSwitchInit(priv);	// SW Ant Switch use LED pin to control TRX Antenna
 #endif
@@ -4645,6 +5371,9 @@ if (GET_CHIP_VER(priv)==VERSION_8192D) {
 			 (priv->pmib->dot11RsnIE.rsnielen > 0)) {
 			priv->ss_ssidlen = 0;
 			DEBUG_INFO("start_clnt_ss, trigger by %s, ss_ssidlen=0\n", (char *)__FUNCTION__);
+#ifdef CONFIG_RTL8672
+			OPMODE |= WIFI_WAIT_FOR_CHANNEL_SELECT;
+#endif
 			start_clnt_ss(priv);
 		}
 	}
@@ -4713,7 +5442,7 @@ if (GET_CHIP_VER(priv)==VERSION_8192D) {
 	if (IS_ROOT_INTERFACE(priv))
 #endif
 	{
-#ifdef CONFIG_RTL_8198
+#if defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 		if (1)
 #else
 		if (REG32(REVR) == RTL8196C_REVISION_B)
@@ -4725,6 +5454,7 @@ if (GET_CHIP_VER(priv)==VERSION_8192D) {
 #endif
 
 	DBFEXIT;
+
 	return 0;
 }
 
@@ -4789,15 +5519,18 @@ int  rtl8192cd_set_hwaddr(struct net_device *dev, void *addr)
 		memcpy(GET_ROOT_PRIV(priv)->pmib->dot11OperationEntry.hwaddr, p, 6);
 	}
 #endif
+	if (check_MAC_IO_Enable(priv)) {
 	reg = *(unsigned long *)(dev->dev_addr);
 	RTL_W32(MACID, (cpu_to_le32(reg)));
 	reg = *(unsigned short *)((unsigned long)dev->dev_addr + 4);
 	RTL_W16(MACID+4, (cpu_to_le16(reg)));
 #ifdef CONFIG_RTL_92D_SUPPORT
-	RTL_W32(MACID1 , RTL_R32(MACID));
-	RTL_W16(MACID1+4, RTL_R16(MACID+4));
+	if (GET_CHIP_VER(priv) == VERSION_8192D) {
+		RTL_W32(MACID1 , RTL_R32(MACID));
+		RTL_W16(MACID1+4, RTL_R16(MACID+4));
+	}
 #endif
-
+	}
 #ifdef MBSSID
 	if (GET_ROOT(priv)->pmib->miscEntry.vap_enable)
 	{
@@ -4854,6 +5587,8 @@ int rtl8192cd_close(struct net_device *dev)
 		priv->drv_state &= ~DRV_STATE_OPEN;     // set driver as has been closed, david
 
 #ifdef PCIE_POWER_SAVING
+	if (timer_pending(&priv->ps_timer))
+		del_timer_sync(&priv->ps_timer);
 	if((priv->pwr_state == L1) || (priv->pwr_state == L2)) {
 		PCIeWakeUp(priv, (POWER_DOWN_T0<<3));
 	}
@@ -4927,10 +5662,12 @@ int rtl8192cd_close(struct net_device *dev)
 	}
 #ifdef CLIENT_MODE	/* WPS2DOTX   */
 	else if((OPMODE & (WIFI_STATION_STATE|WIFI_AUTH_SUCCESS|WIFI_ASOC_STATE))==(WIFI_STATION_STATE|WIFI_AUTH_SUCCESS|WIFI_ASOC_STATE)){
-		//printMac(BSSID);
-		issue_disassoc(priv,BSSID,_RSON_DEAUTH_STA_LEAVING_);
-		delay_ms(30);//make sure before issue_disassoc then TX be close		
-		OPMODE &= ~(WIFI_AUTH_SUCCESS|WIFI_ASOC_STATE) ;
+			//issue_disassoc(priv,BSSID,_RSON_DEAUTH_STA_LEAVING_);
+			//OS_DEBUG("issue_deauth to AP\n");
+			//printMac(BSSID);
+			issue_deauth(priv,BSSID,_RSON_DEAUTH_STA_LEAVING_);			
+			delay_ms(50);//make sure before issue_disassoc then TX be close		
+			OPMODE &= ~(WIFI_AUTH_SUCCESS|WIFI_ASOC_STATE) ;
 	}
 #endif    /* WPS2DOTX   */
 
@@ -4969,7 +5706,7 @@ int rtl8192cd_close(struct net_device *dev)
 			free_irq(dev->irq, dev);
 #ifdef PCIE_POWER_SAVING
 #ifdef GPIO_WAKEPIN			
-#ifdef CONFIG_RTL_8198
+#if defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 			REG32(0xb8003000) &= ~ BIT(16);		// GIMR
 #else
 			if (REG32(REVR) == RTL8196C_REVISION_B) 	
@@ -4982,6 +5719,7 @@ int rtl8192cd_close(struct net_device *dev)
 #endif	
 #endif
 #endif
+
 		}			
 #endif
 
@@ -5137,6 +5875,13 @@ static void MDL_DEVINIT set_mib_default(struct rtl8192cd_priv *priv)
 #endif
 		}
 	}
+
+#ifdef CONFIG_RTL_92D_SUPPORT
+	if (priv->pshare->version_id == VERSION_8192D) {
+		if (priv->pshare->rf_ft_var.use_ext_lna)
+			priv->pshare->rf_ft_var.use_ext_lna = 0;
+	}
+#endif
 }
 
 #if defined(__LINUX_2_6__) && !defined(CONFIG_COMPAT_NET_DEV_OPS)
@@ -5809,16 +6554,26 @@ static int MDL_DEVINIT rtl8192cd_init_one(struct pci_dev *pdev,
 					(vendor_deivce_id != ((unsigned long)((0x8171<<16)|PCI_VENDOR_ID_REALTEK))) &&
 					(vendor_deivce_id != ((unsigned long)((0x8178<<16)|PCI_VENDOR_ID_REALTEK))) &&
 					(vendor_deivce_id != ((unsigned long)((0x8174<<16)|PCI_VENDOR_ID_REALTEK))) &&
-					(vendor_deivce_id != ((unsigned long)((0x8176<<16)|PCI_VENDOR_ID_REALTEK))))
-				{
+					(vendor_deivce_id != ((unsigned long)((0x8176<<16)|PCI_VENDOR_ID_REALTEK)))
+#ifdef CONFIG_RTL_88E_SUPPORT
+					&& (vendor_deivce_id != ((unsigned long)((0x8179<<16)|PCI_VENDOR_ID_REALTEK)))
+#endif
+					) {
 					_DEBUG_ERR("vendor_deivce_id=%x not match\n", vendor_deivce_id);
 					rc = -EIO;
 					goto err_out_free;
 				}
+#if defined (CONFIG_RTL_92D_SUPPORT) || defined(CONFIG_RTL_88E_SUPPORT)
 #ifdef CONFIG_RTL_92D_SUPPORT
 				if (vendor_deivce_id == ((unsigned long)((0x8193<<16)|PCI_VENDOR_ID_REALTEK)))
 					priv->pshare->version_id = VERSION_8192D;
 				else
+#endif
+#ifdef CONFIG_RTL_88E_SUPPORT
+				if (vendor_deivce_id == ((unsigned long)((0x8179<<16)|PCI_VENDOR_ID_REALTEK)))
+					priv->pshare->version_id = VERSION_8188E;
+				else
+#endif
 					priv->pshare->version_id = 0;
 #endif
 			}
@@ -5833,51 +6588,65 @@ static int MDL_DEVINIT rtl8192cd_init_one(struct pci_dev *pdev,
 			for(i=0; i<1000000; i++);
 			//DEBUG_INFO("...latency = 0x%08lx\n", *((volatile unsigned long *)PCI_CONFIG_LATENCY));
 
+#ifdef CONFIG_RTL_88E_SUPPORT
+			if (GET_CHIP_VER(priv)!=VERSION_8188E)
+#endif
+			{
 #if defined(CONFIG_RTL8196C_REVISION_B) || defined(CONFIG_RTL_8196C)
-			#if defined(CONFIG_NET_PCI)
-				#define REVR                                    0xB8000000
-				#define RTL8196C_REVISION_A     0x80000001
-				#define RTL8196C_REVISION_B     0x80000002
-			#endif
-			if (REG32(REVR) == RTL8196C_REVISION_B) {
-				REG32(0xb9000354)=0xc940; //Card PCIE PHY initial  parameter for rtl8196c revision B
-            			REG32(0xb9000358)=0x24;
-				for(i=0; i<1000000; i++);
-                		REG32(0xb9000354)=0x4270;
-                		REG32(0xb9000358)=0x25;
-				for(i=0; i<1000000; i++);
-				REG32(0xb9000354)=0x019E; //Card PCIE PHY initial  parameter for rtl8196c revision B
-            			REG32(0xb9000358)=0x23;
-			}
+#if defined(CONFIG_NET_PCI)
+#define REVR                                    0xB8000000
+#define RTL8196C_REVISION_A     0x80000001
+#define RTL8196C_REVISION_B     0x80000002
+#endif
+				if (REG32(REVR) == RTL8196C_REVISION_B) {
+					REG32(0xb8b01000)=0x0f0f0f01; //Enhance for RTL8192c signal  
+					for(i=0; i<1000000; i++);
+					i=REG32(0xb8b01000);
+					REG32(0xb9000354)=0xc940; //Card PCIE PHY initial  parameter for rtl8196c revision B
+					REG32(0xb9000358)=0x24;
+					for(i=0; i<1000000; i++);
+					REG32(0xb9000354)=0x4270;
+					REG32(0xb9000358)=0x25;
+					for(i=0; i<1000000; i++);
+					REG32(0xb9000354)=0x019E; //Card PCIE PHY initial  parameter for rtl8196c revision B
+					REG32(0xb9000358)=0x23;
+				}
 #endif
-#if defined(CONFIG_RTL8198_REVISION_B) || defined(CONFIG_RTL_8198)
+#if defined(CONFIG_RTL8198_REVISION_B) || defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 #if !defined(CONFIG_RTL_92D_SUPPORT)
-			#if defined(CONFIG_NET_PCI)
-				#define BSP_REVR        0xB8000000
-				#define BSP_RTL8198_REVISION_A	0xC0000000
-				#define BSP_RTL8198_REVISION_B	0xC0000001 
-			#endif
-			#if !defined(CONFIG_RTL_DUAL_PCIESLOT_BIWLAN)
-			if (REG32(BSP_REVR) >= BSP_RTL8198_REVISION_B) {
-				REG32(0xb9000354)=0xc940; //Card PCIE PHY initial  parameter for rtl8196c revision B
-            			REG32(0xb9000358)=0x24;
-				for(i=0; i<1000000; i++);
-                		REG32(0xb9000354)=0x4270;
-                		REG32(0xb9000358)=0x25;
-				for(i=0; i<1000000; i++);
-				REG32(0xb9000354)=0x019E; //Card PCIE PHY initial  parameter for rtl8196c revision B
-            			REG32(0xb9000358)=0x23;
-			}
-			#endif
+#if defined(CONFIG_NET_PCI)
+#define BSP_REVR        0xB8000000
+#define BSP_RTL8198_REVISION_A	0xC0000000
+#define BSP_RTL8198_REVISION_B	0xC0000001 
+#endif
+#if !defined(CONFIG_RTL_DUAL_PCIESLOT_BIWLAN)
+
+#if defined(CONFIG_RTL_8196E)
+				if ((REG32(BSP_REVR) & 0xFFFFF000) == BSP_RTL8196E)
+#else
+				if ((REG32(BSP_REVR) >= BSP_RTL8198_REVISION_B) || ((REG32(BSP_REVR) & 0xFFFFF000) == BSP_RTL8197D)) 
+#endif
+				{
+					REG32(0xb9000354)=0xc940; //Card PCIE PHY initial  parameter for rtl8196c revision B
+					REG32(0xb9000358)=0x24;
+					for(i=0; i<1000000; i++);
+					REG32(0xb9000354)=0x4270;
+					REG32(0xb9000358)=0x25;
+					for(i=0; i<1000000; i++);
+					REG32(0xb9000354)=0x019E; //Card PCIE PHY initial  parameter for rtl8196c revision B
+					REG32(0xb9000358)=0x23;
+				}
+#endif
 #endif
 #endif
+			}
 
 #ifndef NOT_RTK_BSP
 			REG32(0xB800311C) |=  1 << 23;
 #endif
 			check_chipID_MIMO(priv);
 			//Exception Case
-			if ( CheckNoResetHwExceptionCase(priv) ) {
+			if ( check_MAC_IO_Enable(priv) ) {
 				rtl8192cd_stop_hw(priv);
 			}
 		}
@@ -5889,7 +6658,6 @@ static int MDL_DEVINIT rtl8192cd_init_one(struct pci_dev *pdev,
 		rtl8192cd_ePhyInit(priv);
 */
 
-
 #ifdef CONFIG_NET_PCI
 	if (((wdev->type >> TYPE_SHIFT) & TYPE_MASK) == TYPE_PCI_BIOS) {
 		dev->irq = pdev->irq;
@@ -5958,6 +6726,24 @@ register_driver:
 #endif
 	{
 #ifdef CONFIG_NET_PCI
+
+#if defined(CONFIG_RTL8196C_REVISION_B) || defined(CONFIG_RTL_8196C)
+			#if defined(CONFIG_NET_PCI)
+				#define REVR                                    0xB8000000
+				#define RTL8196C_REVISION_A     0x80000001
+				#define RTL8196C_REVISION_B     0x80000002
+			#endif
+					if (REG32(REVR) == RTL8196C_REVISION_B) {
+						REG32(0xb9000354)=0xc940; //Card PCIE PHY initial  parameter for rtl8196c revision B
+								REG32(0xb9000358)=0x24;
+						for(i=0; i<1000000; i++);
+								REG32(0xb9000354)=0x4270;
+								REG32(0xb9000358)=0x25;
+						for(i=0; i<1000000; i++);
+						REG32(0xb9000354)=0x019E; //Card PCIE PHY initial  parameter for rtl8196c revision B
+								REG32(0xb9000358)=0x23;
+					}
+#endif
 		if (((wdev->type >> TYPE_SHIFT) & TYPE_MASK) == TYPE_PCI_BIOS) {
 			if (cache_size != SMP_CACHE_BYTES) {
 //	        	printk(KERN_INFO "%s: PCI cache line size set incorrectly "
@@ -6250,7 +7036,7 @@ register_driver:
 #ifdef __DRAYTEK_OS__
 		page_ptr = rtl8185_malloc(DESC_DMA_PAGE_SIZE, 1);	// allocate non-cache buffer
 #else
-		page_ptr = kmalloc(DESC_DMA_PAGE_SIZE, GFP_ATOMIC);
+		page_ptr = kmalloc(DESC_DMA_PAGE_SIZE, GFP_KERNEL);
 #endif
 		}
 
@@ -6291,6 +7077,23 @@ register_driver:
 #ifdef CONFIG_RTL_92D_DMDP
 		if_priv[priv->pshare->wlandev_idx] = (u32)priv;
 #endif
+#ifdef CONFIG_RTL8672
+#if 0
+		// switch XTAL_BSEL to NAND only for ADSL platform because external 40M crystal only used for wifi chip
+		if (RTL_R8(AFE_XTAL_CTRL) & BIT(1))
+		{	
+			unsigned long	flags;
+
+			SAVE_INT_AND_CLI(flags);
+			
+			rtl8192cd_open(priv->dev);
+			rtl8192cd_close(priv->dev);
+			
+			RESTORE_INT(flags);
+		}
+#endif
+#endif
+
 	}
 
 	INIT_LIST_HEAD(&priv->asoc_list); // init assoc_list first because webs may get sta_num even it is not open,
@@ -6300,6 +7103,17 @@ register_driver:
 		ReadAdapterInfo8192CE(priv);
 #endif	
 	printk("=====>>EXIT rtl8192cd_init_one <<=====\n");
+
+#if defined(CONFIG_RTL_8196D) || defined(CONFIG_RTL_8196E)
+	if(priv && RTL_R32(GPIO_PIN_CTRL))
+	{
+		printk("<%s>LZQ: GPIO_PIN_CTRL[0x%x] \n",__FUNCTION__, GPIO_PIN_CTRL);
+		printk("<%s>LZQ: before read tmpReg[0x%x] \n",__FUNCTION__, RTL_R32(GPIO_PIN_CTRL));
+		RTL_W32(GPIO_PIN_CTRL,RTL_R32(GPIO_PIN_CTRL)&(0x0));
+		printk("<%s>LZQ: after read tmpReg[0x%x] \n",__FUNCTION__, RTL_R32(GPIO_PIN_CTRL));
+	}
+#endif
+	
 	return 0;
 
 err_out_dev:
@@ -6377,6 +7191,12 @@ err_out_free:
 		kfree(receiver_queue);
 #endif
 #endif	// CONFIG_RTK_MESH
+
+#ifdef P2P_SUPPORT
+	if(priv->p2pPtr)
+		kfree(priv->p2pPtr);
+#endif
+
 	if (pevent_queue)
 		kfree(pevent_queue);
 #ifdef CONFIG_RTL_WAPI_SUPPORT
@@ -6763,6 +7583,11 @@ static struct pci_device_id MDL_DEVINITDATA rtl8192cd_pci_tbl[] =
 	{ PCI_VENDOR_ID_REALTEK, 0x8174,
 	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
 
+#ifdef CONFIG_RTL_88E_SUPPORT
+    { PCI_VENDOR_ID_REALTEK, 0x8179,
+      PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+#endif
+
 	{ },
 };
 
@@ -6796,6 +7621,27 @@ int GetCpuCanSuspend(void)
 int no_ddr_patch;
 #endif
 
+#if defined(CONFIG_RTL_8196D) || defined(CONFIG_RTL_8196E)
+unsigned int get_8192cd_gpio0_7()
+{
+	int i;
+	struct rtl8192cd_priv *priv;
+	struct net_device *dev;
+	unsigned int reg = 0; 
+	dev = NULL;
+	for (i=0; (i<sizeof(wlan_device)/sizeof(struct _device_info_)) && (dev==NULL); i++) 
+	{
+		if (wlan_device[i].priv && netif_running(wlan_device[i].priv->dev)) 
+		{
+			priv = wlan_device[i].priv;
+			reg = RTL_R32(GPIO_PIN_CTRL);
+			printk("<%s>LZQ: read 8192cd gpio reg [0x%x]!\n", __FUNCTION__, reg);			
+			return reg;
+		}
+	}	
+	printk("<%s>LZQ: read 8192cd gpio reg ERROR!\n", __FUNCTION__);
+}
+#endif
 
 int MDL_INIT __rtl8192cd_init(unsigned long base_addr)
 {
@@ -6870,7 +7716,6 @@ int MDL_INIT __rtl8192cd_init(unsigned long base_addr)
 #endif
 			rc = rtl8192cd_init_one(NULL, NULL, &wlan_device[wlan_index], -1);
 
-			// victoryman debug
 			if (rc)
 				printk("init_one fail!!!   rc=%d\n",rc);
 
@@ -6979,6 +7824,14 @@ int rtl8192cd_init(unsigned long base_addr)
 #else // not __DRAYTEK_OS__
 int MDL_INIT rtl8192cd_init(void)
 {
+#if defined(CONFIG_RTL_ULINKER_WLAN_DELAY_INIT)
+	static char initated = 0;
+	if (initated == 0)
+		initated = 1;
+	else
+		return 0;
+#endif
+
 #ifdef CONFIG_RTL8671
 	gpioConfig(10,2);
 	gpioClear(10);
@@ -6992,7 +7845,10 @@ int MDL_INIT rtl8192cd_init(void)
 
 
 #ifdef __KERNEL__
-static void MDL_EXIT rtl8192cd_exit (void)
+#if !defined(CONFIG_RTL_ULINKER_WLAN_DELAY_INIT)
+static
+#endif
+void MDL_EXIT rtl8192cd_exit (void)
 {
 	struct net_device *dev;
 	struct rtl8192cd_priv *priv;
@@ -7172,6 +8028,11 @@ static void MDL_EXIT rtl8192cd_exit (void)
 
 #endif
 
+#ifdef P2P_SUPPORT
+	if(priv->p2pPtr)
+		kfree(priv->p2pPtr);
+#endif
+
 #ifdef CONFIG_RTK_MESH
 		kfree(priv->pathsel_queue);
 #ifdef _11s_TEST_MODE_
@@ -7413,7 +8274,57 @@ void wpa2_preauth_packet(struct sk_buff	*pskb)
 #endif // __KERNEL__
 
 #if defined(CONFIG_RTL_ETH_PRIV_SKB_DEBUG)
-extern int is_rtl865x_eth_priv_buf(unsigned char *head);
+__MIPS16 __IRAM_FWD  extern int is_rtl865x_eth_priv_buf(unsigned char *head);
+extern dump_sta_dz_queue_num(struct rtl8192cd_priv *priv, struct stat_info *pstat);
+
+int dump_wlan_dz_queue_num(const char *name)
+{
+	int i,j,txCnt;
+	int queueCnt,idx;
+	struct rtl8192cd_priv *priv;
+	struct tx_desc_info *pdescinfoH,*pdescinfo;
+	struct tx_desc	*pdescH, *pdesc;
+	struct sk_buff *skb = NULL;
+	struct rtl8192cd_hw	*phw;
+	int 			hd, tl;
+					
+	for (j=0; (j<sizeof(wlan_device)/sizeof(struct _device_info_)); j++)
+	{
+		//if(counted)
+			//break;
+		
+		if (wlan_device[j].priv && netif_running(wlan_device[j].priv->dev) && strcmp(wlan_device[j].priv->dev->name,name)==0)
+		{
+			priv = wlan_device[j].priv;
+			if (OPMODE & WIFI_AP_STATE) 
+			{
+				hd = priv->dz_queue.head;
+				tl = priv->dz_queue.tail;
+				printk("priv->dz_queue:%d\n",CIRC_CNT(hd, tl, NUM_TXPKT_QUEUE));
+
+				for (i=0; i<NUM_STAT; i++)
+				{
+					if (priv->pshare->aidarray[i]) {
+#if defined(UNIVERSAL_REPEATER) || defined(MBSSID)
+						if (priv != priv->pshare->aidarray[i]->priv)
+							continue;
+						else
+#endif
+						{
+							if (priv->pshare->aidarray[i]->used == TRUE)
+							{
+								dump_sta_dz_queue_num(priv, &(priv->pshare->aidarray[i]->station));
+							}
+
+						}
+					}
+				}
+			}
+		}
+	}
+
+	return txCnt;
+}
 int get_nic_buf_in_wireless_tx(const char *name)
 {
 	int i,txCnt;
@@ -7440,7 +8351,7 @@ int get_nic_buf_in_wireless_tx(const char *name)
 					phw=GET_HW(priv);
 					pdescH		= get_txdesc(phw, queueCnt);					
 					pdescinfoH = get_txdesc_info(priv->pshare->pdesc_info,queueCnt);
-					for(idx = 0; idx < NUM_TX_DESC; idx++)
+					for(idx = 0; idx < CURRENT_NUM_TX_DESC; idx++)
 					{
 						pdesc = pdescH + idx;
 						pdescinfo = pdescinfoH + idx;
@@ -7499,11 +8410,12 @@ struct net_device *get_shortcut_dev(unsigned char *da)
 {
 	int i,j;
 	struct rtl8192cd_priv *priv;
+	struct rtl8192cd_priv *vxd_priv;
 	struct stat_info *pstat;
 	struct net_device *dev;
 
 #if defined(BR_SHORTCUT)
-	#ifdef  CONFIG_RTK_MESH	//11 mesh no support shortcut now
+	#ifdef CONFIG_RTK_MESH	//11 mesh no support shortcut now
 	{
 		extern unsigned char cached_mesh_mac[MACADDRLEN];
 		extern struct net_device *cached_mesh_dev;
@@ -7530,7 +8442,7 @@ struct net_device *get_shortcut_dev(unsigned char *da)
 	}
 	#endif
 
-	#if	defined(RTL_CACHED_BR_STA)
+	#if defined(RTL_CACHED_BR_STA)
 	{
 		extern unsigned char cached_br_sta_mac[MACADDRLEN];
 		extern struct net_device *cached_br_sta_dev;
@@ -7571,7 +8483,7 @@ struct net_device *get_shortcut_dev(unsigned char *da)
 					}
 				}
 				#ifdef MBSSID
-				else if ((OPMODE & WIFI_AP_STATE) && priv->pmib->miscEntry.vap_enable) {
+			      if ((OPMODE & WIFI_AP_STATE) && priv->pmib->miscEntry.vap_enable) {
 					for (j=0; j<RTL8192CD_NUM_VWLAN; j++) {
 						if ((priv->pvap_priv[j]->assoc_num > 0) && IS_DRV_OPEN(priv->pvap_priv[j]) &&
 							!(priv->pvap_priv[j]->pmib->dot11OperationEntry.disable_brsc)) {
@@ -7584,12 +8496,25 @@ struct net_device *get_shortcut_dev(unsigned char *da)
 					}
 				}
 				#endif
+				#ifdef UNIVERSAL_REPEATER
+				vxd_priv = GET_VXD_PRIV(priv);
+				if((OPMODE & WIFI_STATION_STATE) && (vxd_priv->assoc_num > 0) && IS_DRV_OPEN(vxd_priv) &&
+					!vxd_priv->pmib->dot11OperationEntry.disable_brsc) {		
+					pstat = get_stainfo(vxd_priv, da);
+					if (pstat && pstat->tx_pkts > 10) {
+						dev = vxd_priv->dev;
+						break;
+					}	
+				}
+				#endif
 			}
 		}
 	}
 
 #if	defined(RTL_CACHED_BR_STA) && defined(BR_SHORTCUT)
 	if (dev!=NULL) {
+	extern unsigned char cached_br_sta_mac[MACADDRLEN];
+	extern struct net_device *cached_br_sta_dev;		
 	memcpy(cached_br_sta_mac, da, MACADDRLEN);
 	cached_br_sta_dev = dev;
 	}
@@ -7638,6 +8563,15 @@ void clear_shortcut_cache(void)
 	memset(cached_eth_addr,0,MACADDRLEN);
 #endif
 
+#ifdef BR_SHORTCUT_C2
+	{
+	extern 	 unsigned char cached_eth_addr2[MACADDRLEN];
+	extern struct net_device *cached_dev2;
+	cached_dev2 = NULL;
+	memset(cached_eth_addr2,0,MACADDRLEN);
+	}
+#endif
+
 #ifdef CONFIG_RTL8672	
 	extern void clear_cached_eth_mac_addr(void);
 	clear_cached_eth_mac_addr();
@@ -7703,6 +8637,14 @@ void update_fwtbl_asoclst(struct rtl8192cd_priv *priv, struct stat_info *pstat)
 		}
 	}
 #endif
+
+#ifdef CONFIG_RTL_819X
+	{
+	/* 02-17-2012: move the called function "update_hw_l2table" from Bridge module to here to avoid hacking the Linux kernel or the other kernel */	
+	extern void update_hw_l2table(const char *srcName,const unsigned char *addr);
+	update_hw_l2table("wlan", (const unsigned char *)pstat->hwaddr); /* RTL_WLAN_NAME */
+	}
+#endif
 }
 
 
@@ -7728,7 +8670,7 @@ void force_stop_wlan_hw(void)
 				setBaseAddressRegister();
 			}
 #endif
-			if ( CheckNoResetHwExceptionCase(priv) ) {
+			if ( check_MAC_IO_Enable(priv) ) {
 				rtl8192cd_stop_hw(priv);
 			}
 #if 0 // defined(CONFIG_RTL_92D_SUPPORT)
@@ -7893,7 +8835,11 @@ void r3k_enable_DRAM(void)
 #if defined(CONFIG_WIRELESS_LAN_MODULE)
 MODULE_LICENSE("GPL");
 #endif
+#if defined(CONFIG_RTL_ULINKER_WLAN_DELAY_INIT)
+	/* don't init wlan while kernel startup */
+#else
 module_init(rtl8192cd_init);
 module_exit(rtl8192cd_exit);
+#endif /* #if defined(CONFIG_RTL_ULINKER_WLAN_DELAY_INIT) */
 #endif
 
diff --git a/drivers/net/wireless/rtl8192cd/8192cd_phyreg.h b/drivers/net/wireless/rtl8192cd/8192cd_phyreg.h
index 2e3afdd..918ffc2 100644
--- a/drivers/net/wireless/rtl8192cd/8192cd_phyreg.h
+++ b/drivers/net/wireless/rtl8192cd/8192cd_phyreg.h
@@ -1,1001 +1,1002 @@
-/*
- *  Header file for 8190 Phy Register Definition
- *
- *  $Id: 8192cd_phyreg.h,v 1.2.2.3 2010/09/01 07:07:58 button Exp $
- *
- *  Copyright (c) 2009 Realtek Semiconductor Corp.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
- */
-
-#ifndef _8192CD_PHYREG_H_
-#define _8192CD_PHYREG_H_
-
-/*--------------------------Define Parameters-------------------------------*/
-
-//============================================================
-//       8192CD Register offset definition
-//============================================================
-
-//
-// BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF
-// 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
-// 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
-// 3. RF register 0x00-2E
-// 4. Bit Mask for BB/RF register
-// 5. Other defintion for BB/RF R/W
-//
-
-/*
-//
-// 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
-// 1. Page1(0x100)
-//
-#define		rPMAC_Reset					0x100
-#define		rPMAC_TxStart					0x104
-#define		rPMAC_TxLegacySIG				0x108
-#define		rPMAC_TxHTSIG1				0x10c
-#define		rPMAC_TxHTSIG2				0x110
-#define		rPMAC_PHYDebug				0x114
-#define		rPMAC_TxPacketNum				0x118
-#define		rPMAC_TxIdle					0x11c
-#define		rPMAC_TxMACHeader0			0x120
-#define		rPMAC_TxMACHeader1			0x124
-#define		rPMAC_TxMACHeader2			0x128
-#define		rPMAC_TxMACHeader3			0x12c
-#define		rPMAC_TxMACHeader4			0x130
-#define		rPMAC_TxMACHeader5			0x134
-#define		rPMAC_TxDataType				0x138
-#define		rPMAC_TxRandomSeed			0x13c
-#define		rPMAC_CCKPLCPPreamble			0x140
-#define		rPMAC_CCKPLCPHeader			0x144
-#define		rPMAC_CCKCRC16				0x148
-#define		rPMAC_OFDMRxCRC32OK			0x170
-#define		rPMAC_OFDMRxCRC32Er			0x174
-#define		rPMAC_OFDMRxParityEr			0x178
-#define		rPMAC_OFDMRxCRC8Er			0x17c
-#define		rPMAC_CCKCRxRC16Er			0x180
-#define		rPMAC_CCKCRxRC32Er			0x184
-#define		rPMAC_CCKCRxRC32OK			0x188
-#define		rPMAC_TxStatus					0x18c
-*/
-
-
-//
-// 2. BB Register Page8(0x800)
-//
-#define		rFPGA0_RFMOD					0x800	//RF mode & CCK TxSC // RF BW Setting??
-#define		rFPGA0_TxInfo					0x804	// Status report??
-#define		rFPGA0_PSDFunction				0x808
-#define		rFPGA0_TxGainStage				0x80c	// Set TX PWR init gain?
-#define		rFPGA0_RFTiming1				0x810	// Useless now
-#define		rFPGA0_RFTiming2				0x814
-/*
-#define rFPGA0_XC_RFTiming        		0x818
-#define rFPGA0_XD_RFTiming        		0x81c
-*/
-#define		rFPGA0_XA_HSSIParameter1		0x820	// RF 3 wire register
-#define		rFPGA0_XA_HSSIParameter2		0x824
-#define		rFPGA0_XB_HSSIParameter1		0x828
-#define		rFPGA0_XB_HSSIParameter2		0x82c
-#define		rTxAGC_B_Rate18_06			0x830
-#define		rTxAGC_B_Rate54_24			0x834
-#define		rTxAGC_B_CCK5_1_Mcs32		0x838
-#define		rTxAGC_B_Mcs03_Mcs00			0x83c
-#define		rFPGA0_XA_LSSIParameter		0x840
-#define		rFPGA0_XB_LSSIParameter		0x844
-#define		rTxAGC_B_Mcs07_Mcs04			0x848
-#define		rTxAGC_B_Mcs11_Mcs08			0x84c
-#define		rFPGA0_RFWakeUpParameter		0x850	// Useless now
-#define		rFPGA0_RFSleepUpParameter		0x854
-#define		rFPGA0_XAB_SwitchControl		0x858	// RF Channel switch
-//#define		rFPGA0_XCD_SwitchControl		0x85c
-#define		rFPGA0_XA_RFInterfaceOE		0x860	// RF Channel switch
-#define		rFPGA0_XB_RFInterfaceOE		0x864
-#define		rTxAGC_B_Mcs15_Mcs12			0x868
-#define		rTxAGC_A_CCK11_2_B_CCK11		0x86c
-#define		rFPGA0_XAB_RFInterfaceSW		0x870	// RF Interface Software Control
-//#define		rFPGA0_XCD_RFInterfaceSW		0x874
-#define		rFPGA0_XAB_RFParameter		0x878	// RF Parameter
-//#define		rFPGA0_XCD_RFParameter		0x87c
-#define		rFPGA0_AnalogParameter1		0x880	// Crystal cap setting RF-R/W protection for parameter4??
-#define		rFPGA0_AnalogParameter2		0x884
-#if defined(CONFIG_RTL_92D_SUPPORT)
-#define		rFPGA0_AdDaClockEn				0x888	// enable ad/da clock1 for dual-phy
-#else
-#define		rFPGA0_AnalogParameter3		0x888	// Useless now
-#endif
-#define		rFPGA0_AnalogParameter4		0x88c
-#define		rFPGA0_XA_LSSIReadBack		0x8a0	// Tranceiver LSSI Readback
-#define		rFPGA0_XB_LSSIReadBack		0x8a4
-/*
-#define		rFPGA0_XC_LSSIReadBack		0x8a8
-#define		rFPGA0_XD_LSSIReadBack		0x8ac
-*/
-#define		rFPGA0_PSDReport				0x8b4	// Useless now
-#define		TransceiverA_HSPI_Readback	0x8b8
-#define		TransceiverB_HSPI_Readback	0x8bc
-#define		rFPGA0_XAB_RFInterfaceRB		0x8e0	// Useless now // RF Interface Readback Value
-//#define		rFPGA0_XCD_RFInterfaceRB		0x8e4	// Useless now
-
-
-//
-// 3. BB Register Page9(0x900)
-//
-#define		rFPGA1_RFMOD				0x900	//RF mode & OFDM TxSC // RF BW Setting??
-#define		rFPGA1_TxBlock				0x904	// Useless now
-#define		rFPGA1_DebugSelect			0x908	// Useless now
-#define		rFPGA1_TxInfo				0x90c	// Useless now // Status report??
-
-
-//
-// 4. BB Register PageA(0xA00)
-//
-// Set Control channel to upper or lower. These settings are required only for 40MHz
-#define		rCCK0_System				0xa00
-#define		rCCK0_AFESetting			0xa04	// Disable init gain now // Select RX path by RSSI
-#define		rCCK0_CCA					0xa08	// Disable init gain now // Init gain
-#define		rCCK0_RxAGC1				0xa0c 	//AGC default value, saturation level // Antenna Diversity, RX AGC, LNA Threshold, RX LNA Threshold useless now. Not the same as 90 series
-#define		rCCK0_RxAGC2				0xa10 	//AGC & DAGC
-#define		rCCK0_RxHP					0xa14
-#define		rCCK0_DSPParameter1		0xa18	//Timing recovery & Channel estimation threshold
-#define		rCCK0_DSPParameter2		0xa1c	//SQ threshold
-#define		rCCK0_TxFilter1				0xa20
-#define		rCCK0_TxFilter2				0xa24
-#define		rCCK0_DebugPort			0xa28	//debug port and Tx filter3
-#define		rCCK0_FalseAlarmReport		0xa2c	//0xa2d	useless now 0xa30-a4f channel report
-#define		rCCK0_TRSSIReport         		0xa50
-#define		rCCK0_RxReport            		0xa54  //0xa57
-#define		rCCK0_FACounterLower      	0xa5c  //0xa5b
-#define		rCCK0_FACounterUpper      	0xa58  //0xa5c
-
-
-//
-// 5. BB Register PageC(0xC00)
-//
-#define		rOFDM0_LSTF				0xc00
-#define		rOFDM0_TRxPathEnable		0xc04
-#define		rOFDM0_TRMuxPar			0xc08
-#define		rOFDM0_TRSWIsolation		0xc0c
-#define		rOFDM0_XARxAFE			0xc10  //RxIQ DC offset, Rx digital filter, DC notch filter
-#define		rOFDM0_XARxIQImbalance    	0xc14  //RxIQ imblance matrix
-#define		rOFDM0_XBRxAFE            		0xc18
-#define		rOFDM0_XBRxIQImbalance    	0xc1c
-/*
-#define		rOFDM0_XCRxAFE            		0xc20
-#define		rOFDM0_XCRxIQImbalance    	0xc24
-#define		rOFDM0_XDRxAFE            		0xc28
-#define		rOFDM0_XDRxIQImbalance    	0xc2c
-*/
-#define		rOFDM0_RxDetector1			0xc30  //PD,BW & SBD	// DM tune init gain
-#define		rOFDM0_RxDetector2			0xc34  //SBD & Fame Sync.
-#define		rOFDM0_RxDetector3			0xc38  //Frame Sync.
-#define		rOFDM0_RxDetector4			0xc3c  //PD, SBD, Frame Sync & Short-GI
-#define		rOFDM0_RxDSP				0xc40  //Rx Sync Path
-#define		rOFDM0_CFOandDAGC		0xc44  //CFO & DAGC
-#define		rOFDM0_CCADropThreshold	0xc48 //CCA Drop threshold
-#define		rOFDM0_ECCAThreshold		0xc4c // energy CCA
-#define		rOFDM0_XAAGCCore1			0xc50	// DIG
-#define		rOFDM0_XAAGCCore2			0xc54
-#define		rOFDM0_XBAGCCore1			0xc58
-#define		rOFDM0_XBAGCCore2			0xc5c
-/*
-#define		rOFDM0_XCAGCCore1			0xc60
-#define		rOFDM0_XCAGCCore2			0xc64
-#define		rOFDM0_XDAGCCore1			0xc68
-#define		rOFDM0_XDAGCCore2			0xc6c
-*/
-#define		rOFDM0_AGCParameter1		0xc70
-#define		rOFDM0_AGCParameter2		0xc74
-#define		rOFDM0_AGCRSSITable		0xc78
-#define		rOFDM0_HTSTFAGC			0xc7c
-#define		rOFDM0_XATxIQImbalance	0xc80	// TX PWR TRACK and DIG
-#define		rOFDM0_XATxAFE			0xc84
-#define		rOFDM0_XBTxIQImbalance	0xc88
-#define		rOFDM0_XBTxAFE			0xc8c
-
-
-#define		rOFDM0_XCTxIQImbalance		0xc90
-#define		rOFDM0_XCTxAFE            			0xc94
-#define		rOFDM0_XDTxIQImbalance		0xc98
-#define		rOFDM0_XDTxAFE				0xc9c
-#define		rOFDM0_RxIQExtAnta			0xca0
-
-
-#define		rOFDM0_RxHPParameter		0xce0
-#define		rOFDM0_TxPseudoNoiseWgt	0xce4
-#define		rOFDM0_FrameSync			0xcf0
-#define		rOFDM0_DFSReport			0xcf4
-#define		rOFDM0_TxCoeff1			0xca4
-#define		rOFDM0_TxCoeff2			0xca8
-#define		rOFDM0_TxCoeff3			0xcac
-#define		rOFDM0_TxCoeff4			0xcb0
-#define		rOFDM0_TxCoeff5			0xcb4
-#define		rOFDM0_TxCoeff6			0xcb8
-
-
-//
-// 6. BB Register PageD(0xD00)
-//
-#define		rOFDM1_LSTF					0xd00
-#define		rOFDM1_TRxPathEnable			0xd04
-#define		rOFDM1_CFO						0xd08	// No setting now
-#define		rOFDM1_CSI1					0xd10
-#define		rOFDM1_SBD						0xd14
-#define		rOFDM1_CSI2					0xd18
-#define		rOFDM1_CFOTracking			0xd2c
-#define		rOFDM1_TRxMesaure1			0xd34
-#define		rOFDM1_IntfDet					0xd3c
-#define		rOFDM1_PseudoNoiseStateAB		0xd50
-#define		rOFDM1_PseudoNoiseStateCD		0xd54
-#define		rOFDM1_RxPseudoNoiseWgt		0xd58
-#define		rOFDM_PHYCounter1				0xda0  //cca, parity fail
-#define		rOFDM_PHYCounter2				0xda4  //rate illegal, crc8 fail
-#define		rOFDM_PHYCounter3				0xda8  //MCS not support
-#define		rOFDM_ShortCFOAB				0xdac	// No setting now
-#define		rOFDM_ShortCFOCD				0xdb0
-#define		rOFDM_LongCFOAB				0xdb4
-#define		rOFDM_LongCFOCD				0xdb8
-#define		rOFDM_TailCFOAB				0xdbc
-#define		rOFDM_TailCFOCD				0xdc0
-#define		rOFDM_PWMeasure1          		0xdc4
-#define		rOFDM_PWMeasure2          		0xdc8
-#define		rOFDM_BWReport				0xdcc
-#define		rOFDM_AGCReport				0xdd0
-#define		rOFDM_RxSNR					0xdd4
-#define		rOFDM_RxEVMCSI				0xdd8
-#define		rOFDM_SIGReport				0xddc
-
-
-//
-// 6. BB Register PageE(0xE00)
-//
-#define		rTxAGC_A_Rate18_06		0xe00
-#define		rTxAGC_A_Rate54_24		0xe04
-#define		rTxAGC_A_CCK1_Mcs32		0xe08
-#define		rTxAGC_A_Mcs03_Mcs00		0xe10
-#define		rTxAGC_A_Mcs07_Mcs04		0xe14
-#define		rTxAGC_A_Mcs11_Mcs08		0xe18
-#define		rTxAGC_A_Mcs15_Mcs12		0xe1c
-
-
-//
-// 7. RF Register 0x00-0x2E
-//
-//Zebra1
-#define		rZebra1_HSSIEnable			0x0	// Useless now
-#define		rZebra1_TRxEnable1			0x1
-#define		rZebra1_TRxEnable2			0x2
-#define		rZebra1_AGC				0x4
-#define		rZebra1_ChargePump		0x5
-#define		rZebra1_Channel			0x7	// RF channel switch
-#define		rZebra1_TxGain				0x8	// Useless now
-#define		rZebra1_TxLPF				0x9
-#define		rZebra1_RxLPF				0xb
-#define		rZebra1_RxHPFCorner		0xc
-#define		rRfChannel					0x18	// RF channel switch	For T65 RF 0222d
-
-//Zebra4
-#define		rGlobalCtrl					0	// Useless now
-#define		rRTL8256_TxLPF				19
-#define		rRTL8256_RxLPF				11
-
-//RTL8258
-#define		rRTL8258_RSSILPF			0xa
-#define		rRTL8258_TxLPF				0x11	// Useless now
-#define		rRTL8258_RxLPF				0x13
-
-
-#define		RF_RX_G1					0x1A	// 
-#define		RF_RX_G2					0x1B	// 
-
-
-//
-//Bit Mask
-//
-// 1. Page1(0x100)
-/*
-#define		bBBResetB					0x100	// Useless now?
-#define		bGlobalResetB				0x200
-#define		bOFDMTxStart				0x4
-#define		bCCKTxStart					0x8
-#define		bCRC32Debug				0x100
-#define		bPMACLoopback				0x10
-#define		bTxLSIG						0xffffff
-#define		bOFDMTxRate				0xf
-#define		bOFDMTxReserved			0x10
-#define		bOFDMTxLength				0x1ffe0
-#define		bOFDMTxParity				0x20000
-#define		bTxHTSIG1					0xffffff
-#define		bTxHTMCSRate				0x7f
-#define		bTxHTBW					0x80
-#define		bTxHTLength				0xffff00
-#define		bTxHTSIG2					0xffffff
-#define		bTxHTSmoothing				0x1
-#define		bTxHTSounding				0x2
-#define		bTxHTReserved				0x4
-#define		bTxHTAggreation			0x8
-#define		bTxHTSTBC					0x30
-#define		bTxHTAdvanceCoding		0x40
-#define		bTxHTShortGI				0x80
-#define		bTxHTNumberHT_LTF		0x300
-#define		bTxHTCRC8					0x3fc00
-#define		bCounterReset				0x10000
-#define		bNumOfOFDMTx				0xffff
-#define		bNumOfCCKTx				0xffff0000
-#define		bTxIdleInterval				0xffff
-#define		bOFDMService				0xffff0000
-#define		bTxMACHeader				0xffffffff
-#define		bTxDataInit					0xff
-#define		bTxHTMode					0x100
-#define		bTxDataType				0x30000
-#define		bTxRandomSeed				0xffffffff
-#define		bCCKTxPreamble				0x1
-#define		bCCKTxSFD					0xffff0000
-#define		bCCKTxSIG					0xff
-#define		bCCKTxService				0xff00
-#define		bCCKLengthExt				0x8000
-#define		bCCKTxLength				0xffff0000
-#define		bCCKTxCRC16				0xffff
-#define		bCCKTxStatus				0x1
-#define		bOFDMTxStatus				0x2
-*/
-
-
-//
-// 2. Page8(0x800)
-//
-#define		bRFMOD						0x1	// Reg 0x800 rFPGA0_RFMOD
-#define		bJapanMode					0x2
-#define		bCCKTxSC					0x30
-#define		bCCKEn						0x1000000
-#define		bOFDMEn					0x2000000
-
-#define		bOFDMRxADCPhase           	0x10000	// Useless now
-#define		bOFDMTxDACPhase           	0x40000
-
-#define		bXATxAGC                  			0x3f
-#define		bXBTxAGC                  			0xf00	// Reg 80c rFPGA0_TxGainStage
-/*
-#define		bXCTxAGC                  			0xf000
-#define		bXDTxAGC                  			0xf0000
-*/
-
-#define		bPAStart                  			0xf0000000	// Useless now
-#define		bTRStart                  			0x00f00000
-#define		bRFStart                  			0x0000f000
-#define		bBBStart                  			0x000000f0
-#define		bBBCCKStart               		0x0000000f
-#define		bPAEnd                    			0xf          //Reg0x814
-#define		bTREnd                    			0x0f000000
-#define		bRFEnd                    			0x000f0000
-#define		bCCAMask                  			0x000000f0   //T2R
-#define		bR2RCCAMask               		0x00000f00
-#define		bHSSI_R2TDelay            		0xf8000000
-#define		bHSSI_T2RDelay            		0xf80000
-#define		bContTxHSSI               		0x400     //chane gain at continue Tx
-#define		bIGFromCCK                		0x200
-#define		bAGCAddress               		0x3f
-#define		bRxHPTx                   			0x7000
-#define		bRxHPT2R                  			0x38000
-#define		bRxHPCCKIni               		0xc0000
-#define		bAGCTxCode                		0xc00000
-#define		bAGCRxCode                		0x300000
-
-#define		b3WireDataLength          		0x800	// Reg 0x820~84f rFPGA0_XA_HSSIParameter1
-#define		b3WireAddressLength       	0x400
-
-#define		b3WireRFPowerDown         	0x1	// Useless now
-//#define bHWSISelect               		0x8
-#define		b5GPAPEPolarity           		0x40000000
-#define		b2GPAPEPolarity           		0x80000000
-#define		bRFSW_TxDefaultAnt        	0x3
-#define		bRFSW_TxOptionAnt         	0x30
-#define		bRFSW_RxDefaultAnt        	0x300
-#define		bRFSW_RxOptionAnt         	0x3000
-#define		bRFSI_3WireData           		0x1
-#define		bRFSI_3WireClock          		0x2
-#define		bRFSI_3WireLoad           		0x4
-#define		bRFSI_3WireRW             		0x8
-#define		bRFSI_3Wire               		0xf
-
-#define		bRFSI_RFENV               		0x10	// Reg 0x870 rFPGA0_XAB_RFInterfaceSW
-
-#define		bRFSI_TRSW                		0x20	// Useless now
-#define		bRFSI_TRSWB               		0x40
-#define		bRFSI_ANTSW               		0x100
-#define		bRFSI_ANTSWB              		0x200
-#define		bRFSI_PAPE                		0x400
-#define		bRFSI_PAPE5G              		0x800
-#define		bBandSelect               		0x1
-#define		bHTSIG2_GI                		0x80
-#define		bHTSIG2_Smoothing         	0x01
-#define		bHTSIG2_Sounding          		0x02
-#define		bHTSIG2_Aggreaton         	0x08
-#define		bHTSIG2_STBC              		0x30
-#define		bHTSIG2_AdvCoding         	0x40
-#define		bHTSIG2_NumOfHTLTF        	0x300
-#define		bHTSIG2_CRC8              		0x3fc
-#define		bHTSIG1_MCS               		0x7f
-#define		bHTSIG1_BandWidth         	0x80
-#define		bHTSIG1_HTLength          		0xffff
-#define		bLSIG_Rate                			0xf
-#define		bLSIG_Reserved            		0x10
-#define		bLSIG_Length              		0x1fffe
-#define		bLSIG_Parity              		0x20
-#define		bCCKRxPhase               		0x4
-
-//#define		bLSSIReadAddress          		0x3f000000   //LSSI "Read" Address	// Reg 0x824 rFPGA0_XA_HSSIParameter2
-#define		bLSSIReadAddress          		0x7f800000   // T65 RF
-#define		bLSSIReadEdge             		0x80000000   //LSSI "Read" edge signal
-
-//#define		bLSSIReadBackData         		0xfff		// Reg 0x8a0 rFPGA0_XA_LSSIReadBack
-#define		bLSSIReadBackData         		0xfffff		// T65 RF
-
-#define		bLSSIReadOKFlag           		0x1000	// Useless now
-#define		bCCKSampleRate            		0x8       //0: 44MHz, 1:88MHz
-#define		bRegulator0Standby        		0x1
-#define		bRegulatorPLLStandby      	0x2
-#define		bRegulator1Standby        		0x4
-#define		bPLLPowerUp               		0x8
-#define		bDPLLPowerUp              		0x10
-#define		bDA10PowerUp              		0x20
-#define		bAD7PowerUp               		0x200
-#define		bDA6PowerUp               		0x2000
-#define		bXtalPowerUp              		0x4000
-#define		b40MDClkPowerUP           		0x8000
-#define		bDA6DebugMode             		0x20000
-#define		bDA6Swing                 		0x380000
-
-#define		bADClkPhase               		0x4000000	// Reg 0x880 rFPGA0_AnalogParameter1 20/40 CCK support switch 40/80 BB MHZ
-
-#define		b80MClkDelay              		0x18000000	// Useless
-#define		bAFEWatchDogEnable        	0x20000000
-
-#define		bXtalCap01                			0xc0000000	// Reg 0x884 rFPGA0_AnalogParameter2 Crystal cap
-#define		bXtalCap23                			0x3
-#define		bXtalCap92x					0x0f000000
-
-#define		bIntDifClkEnable          		0x400	// Useless
-#define		bExtSigClkEnable         	 	0x800
-#define		bBandgapMbiasPowerUp      	0x10000
-#define		bAD11SHGain               		0xc0000
-#define		bAD11InputRange           		0x700000
-#define		bAD11OPCurrent            		0x3800000
-#define		bIPathLoopback            		0x4000000
-#define		bQPathLoopback            		0x8000000
-#define		bAFELoopback              		0x10000000
-#define		bDA10Swing                		0x7e0
-#define		bDA10Reverse              		0x800
-#define		bDAClkSource              		0x1000
-#define		bAD7InputRange            		0x6000
-#define		bAD7Gain                  			0x38000
-#define		bAD7OutputCMMode          	0x40000
-#define		bAD7InputCMMode           		0x380000
-#define		bAD7Current               		0xc00000
-#define		bRegulatorAdjust          		0x7000000
-#define		bAD11PowerUpAtTx          	0x1
-#define		bDA10PSAtTx               		0x10
-#define		bAD11PowerUpAtRx          	0x100
-#define		bDA10PSAtRx               		0x1000
-#define		bCCKRxAGCFormat           		0x200
-#define		bPSDFFTSamplepPoint       	0xc000
-#define		bPSDAverageNum            		0x3000
-#define		bIQPathControl            		0xc00
-#define		bPSDFreq                  			0x3ff
-#define		bPSDAntennaPath           		0x30
-#define		bPSDIQSwitch              		0x40
-#define		bPSDRxTrigger             		0x400000
-#define		bPSDTxTrigger             		0x80000000
-#define		bPSDSineToneScale        		0x7f000000
-#define		bPSDReport                		0xffff
-
-
-//
-// 3. Page9(0x900)
-//
-#define		bOFDMTxSC                 		0x30000000	// Useless
-#define		bCCKTxOn                  			0x1
-#define		bOFDMTxOn                 		0x2
-#define		bDebugPage                		0xfff  //reset debug page and also HWord, LWord
-#define		bDebugItem                		0xff   //reset debug page and LWord
-#define		bAntL              	       		0x10
-#define		bAntNonHT           	    		0x100
-#define		bAntHT1               			0x1000
-#define		bAntHT2                   			0x10000
-#define		bAntHT1S1                 			0x100000
-#define		bAntNonHTS1               		0x1000000
-
-
-//
-// 4. PageA(0xA00)
-//
-#define		bCCKBBMode                		0x3	// Useless
-#define		bCCKTxPowerSaving        		0x80
-#define		bCCKRxPowerSaving         	0x40
-
-#define		bCCKSideBand              		0x10	// Reg 0xa00 rCCK0_System 20/40 switch
-
-#define		bCCKScramble              		0x8	// Useless
-#define		bCCKAntDiversity    		      	0x8000
-#define		bCCKCarrierRecovery   	    	0x4000
-#define		bCCKTxRate           		     	0x3000
-#define		bCCKDCCancel             	 	0x0800
-#define		bCCKISICancel             		0x0400
-#define		bCCKMatchFilter           		0x0200
-#define		bCCKEqualizer             		0x0100
-#define		bCCKPreambleDetect       	 	0x800000
-#define		bCCKFastFalseCCA          		0x400000
-#define		bCCKChEstStart            		0x300000
-#define		bCCKCCACount              		0x080000
-#define		bCCKcs_lim                			0x070000
-#define		bCCKBistMode              		0x80000000
-#define		bCCKCCAMask             	  	0x40000000
-#define		bCCKTxDACPhase         	   	0x4
-#define		bCCKRxADCPhase         	   	0x20000000   //r_rx_clk
-#define		bCCKr_cp_mode0         	   	0x0100
-#define		bCCKTxDCOffset           	 	0xf0
-#define		bCCKRxDCOffset           	 	0xf
-#define		bCCKCCAMode              	 	0xc000
-#define		bCCKFalseCS_lim           		0x3f00
-#define		bCCKCS_ratio              		0xc00000
-#define		bCCKCorgBit_sel           		0x300000
-#define		bCCKPD_lim                		0x0f0000
-#define		bCCKNewCCA                		0x80000000
-#define		bCCKRxHPofIG              		0x8000
-#define		bCCKRxIG                  			0x7f00
-#define		bCCKLNAPolarity           		0x800000
-#define		bCCKRx1stGain             		0x7f0000
-#define		bCCKRFExtend              		0x20000000 //CCK Rx Iinital gain polarity
-#define		bCCKRxAGCSatLevel        	 	0x1f000000
-#define		bCCKRxAGCSatCount       	  	0xe0
-#define		bCCKRxRFSettle            		0x1f       //AGCsamp_dly
-#define		bCCKFixedRxAGC           	 	0x8000
-//#define bCCKRxAGCFormat         	 	0x4000   //remove to HSSI register 0x824
-#define		bCCKAntennaPolarity      	 	0x2000
-#define		bCCKTxFilterType          		0x0c00
-#define		bCCKRxAGCReportType   	   	0x0300
-#define		bCCKRxDAGCEn              		0x80000000
-#define		bCCKRxDAGCPeriod        	  	0x20000000
-#define		bCCKRxDAGCSatLevel     	   	0x1f000000
-#define		bCCKTimingRecovery       	 	0x800000
-#define		bCCKTxC0                  			0x3f0000
-#define		bCCKTxC1                  			0x3f000000
-#define		bCCKTxC2                  			0x3f
-#define		bCCKTxC3                  			0x3f00
-#define		bCCKTxC4                  			0x3f0000
-#define		bCCKTxC5                  			0x3f000000
-#define		bCCKTxC6                  			0x3f
-#define		bCCKTxC7                  			0x3f00
-#define		bCCKDebugPort             		0xff0000
-#define		bCCKDACDebug              		0x0f000000
-#define		bCCKFalseAlarmEnable    		0x8000
-#define		bCCKFalseAlarmRead        	0x4000
-#define		bCCKTRSSI                 			0x7f
-#define		bCCKRxAGCReport           		0xfe
-#define		bCCKRxReport_AntSel       	0x80000000
-#define		bCCKRxReport_MFOff        	0x40000000
-#define		bCCKRxRxReport_SQLoss     	0x20000000
-#define		bCCKRxReport_Pktloss      	0x10000000
-#define		bCCKRxReport_Lockedbit    	0x08000000
-#define		bCCKRxReport_RateError    	0x04000000
-#define		bCCKRxReport_RxRate       	0x03000000
-#define		bCCKRxFACounterLower      	0xff
-#define		bCCKRxFACounterUpper      	0xff000000
-#define		bCCKRxHPAGCStart          		0xe000
-#define		bCCKRxHPAGCFinal          		0x1c00
-#define		bCCKRxFalseAlarmEnable    	0x8000
-#define		bCCKFACounterFreeze       	0x4000
-#define		bCCKTxPathSel             		0x10000000
-#define		bCCKDefaultRxPath         		0xc000000
-#define		bCCKOptionRxPath          		0x3000000
-
-
-//
-// 5. PageC(0xC00)
-//
-#define		bNumOfSTF                			0x3	// Useless
-#define		bShift_L                 			0xc0
-#define		bGI_TH                   			0xc
-#define		bRxPathA                 			0x1
-#define		bRxPathB                 			0x2
-#define		bRxPathC                 			0x4
-#define		bRxPathD                 			0x8
-#define		bTxPathA                 			0x1
-#define		bTxPathB                 			0x2
-#define		bTxPathC                 			0x4
-#define		bTxPathD                 			0x8
-#define		bTRSSIFreq               			0x200
-#define		bADCBackoff              			0x3000
-#define		bDFIRBackoff             		0xc000
-#define		bTRSSILatchPhase         		0x10000
-#define		bRxIDCOffset             			0xff
-#define		bRxQDCOffset             		0xff00
-#define		bRxDFIRMode              		0x1800000
-#define		bRxDCNFType              		0xe000000
-#define		bRXIQImb_A               		0x3ff
-#define		bRXIQImb_B               		0xfc00
-#define		bRXIQImb_C               		0x3f0000
-#define		bRXIQImb_D               		0xffc00000
-#define		bDC_dc_Notch             		0x60000
-#define		bRxNBINotch              		0x1f000000
-#define		bPD_TH                   			0xf
-#define		bPD_TH_Opt2              		0xc000
-#define		bPWED_TH                 			0x700
-#define		bIfMF_Win_L              		0x800
-#define		bPD_Option               			0x1000
-#define		bMF_Win_L                			0xe000
-#define		bBW_Search_L             		0x30000
-#define		bwin_enh_L               			0xc0000
-#define		bBW_TH                   			0x700000
-#define		bED_TH2                  			0x3800000
-#define		bBW_option               			0x4000000
-#define		bRatio_TH                			0x18000000
-#define		bWindow_L                			0xe0000000
-#define		bSBD_Option              			0x1
-#define		bFrame_TH                			0x1c
-#define		bFS_Option               			0x60
-#define		bDC_Slope_check          		0x80
-#define		bFGuard_Counter_DC_L     	0xe00
-#define		bFrame_Weight_Short      	0x7000
-#define		bSub_Tune                			0xe00000
-#define		bFrame_DC_Length         		0xe000000
-#define		bSBD_start_offset        		0x30000000
-#define		bFrame_TH_2              		0x7
-#define		bFrame_GI2_TH            		0x38
-#define		bGI2_Sync_en             		0x40
-#define		bSarch_Short_Early       		0x300
-#define		bSarch_Short_Late        		0xc00
-#define		bSarch_GI2_Late          		0x70000
-#define		bCFOAntSum               		0x1
-#define		bCFOAcc                  			0x2
-#define		bCFOStartOffset          		0xc
-#define		bCFOLookBack             		0x70
-#define		bCFOSumWeight            		0x80
-#define		bDAGCEnable              		0x10000
-#define		bTXIQImb_A               		0x3ff
-#define		bTXIQImb_B               		0xfc00
-#define		bTXIQImb_C               		0x3f0000
-#define		bTXIQImb_D               		0xffc00000
-#define		bTxIDCOffset             			0xff
-#define		bTxQDCOffset             		0xff00
-#define		bTxDFIRMode              		0x10000
-#define		bTxPesudoNoiseOn         		0x4000000
-#define		bTxPesudoNoise_A         		0xff
-#define		bTxPesudoNoise_B         		0xff00
-#define		bTxPesudoNoise_C         		0xff0000
-#define		bTxPesudoNoise_D         		0xff000000
-#define		bCCADropOption           		0x20000
-#define		bCCADropThres            		0xfff00000
-#define		bEDCCA_H                 			0xf
-#define		bEDCCA_L                 			0xf0
-#define		bLambda_ED         		      0x300
-#define		bRxInitialGain				0x7f
-#define		bRxAntDivEn					0x80
-#define		bRxAGCAddressForLNA		0x7f00
-#define		bRxHighPowerFlow			0x8000
-#define		bRxAGCFreezeThres			0xc0000
-#define		bRxFreezeStep_AGC1		0x300000
-#define		bRxFreezeStep_AGC2		0xc00000
-#define		bRxFreezeStep_AGC3		0x3000000
-#define		bRxFreezeStep_AGC0		0xc000000
-#define		bRxRssi_Cmp_En				0x10000000
-#define		bRxQuickAGCEn				0x20000000
-#define		bRxAGCFreezeThresMode		0x40000000
-#define		bRxOverFlowCheckType		0x80000000
-#define		bRxAGCShift					0x7f
-#define		bTRSW_Tri_Only				0x80
-#define		bPowerThres				0x300
-#define		bRxAGCEn					0x1
-#define		bRxAGCTogetherEn			0x2
-#define		bRxAGCMin					0x4
-#define		bRxHP_Ini					0x7
-#define		bRxHP_TRLNA				0x70
-#define		bRxHP_RSSI					0x700
-#define		bRxHP_BBP1					0x7000
-#define		bRxHP_BBP2					0x70000
-#define		bRxHP_BBP3					0x700000
-#define		bRSSI_H						0x7f0000     //the threshold for high power
-#define		bRSSI_Gen					0x7f000000   //the threshold for ant diversity
-#define		bRxSettle_TRSW				0x7
-#define		bRxSettle_LNA				0x38
-#define		bRxSettle_RSSI				0x1c0
-#define		bRxSettle_BBP				0xe00
-#define		bRxSettle_RxHP				0x7000
-#define		bRxSettle_AntSW_RSSI		0x38000
-#define		bRxSettle_AntSW			0xc0000
-#define		bRxProcessTime_DAGC		0x300000
-#define		bRxSettle_HSSI				0x400000
-#define		bRxProcessTime_BBPPW		0x800000
-#define		bRxAntennaPowerShift		0x3000000
-#define		bRSSITableSelect			0xc000000
-#define		bRxHP_Final					0x7000000
-#define		bRxHTSettle_BBP				0x7
-#define		bRxHTSettle_HSSI			0x8
-#define		bRxHTSettle_RxHP			0x70
-#define		bRxHTSettle_BBPPW			0x80
-#define		bRxHTSettle_Idle			0x300
-#define		bRxHTSettle_Reserved		0x1c00
-#define		bRxHTRxHPEn				0x8000
-#define		bRxHTAGCFreezeThres		0x30000
-#define		bRxHTAGCTogetherEn		0x40000
-#define		bRxHTAGCMin				0x80000
-#define		bRxHTAGCEn					0x100000
-#define		bRxHTDAGCEn				0x200000
-#define		bRxHTRxHP_BBP				0x1c00000
-#define		bRxHTRxHP_Final			0xe0000000
-#define		bRxPWRatioTH				0x3
-#define		bRxPWRatioEn				0x4
-#define		bRxMFHold					0x3800
-#define		bRxPD_Delay_TH1			0x38
-#define		bRxPD_Delay_TH2			0x1c0
-#define		bRxPD_DC_COUNT_MAX		0x600
-//#define bRxMF_Hold               0x3800
-#define		bRxPD_Delay_TH				0x8000
-#define		bRxProcess_Delay			0xf0000
-#define		bRxSearchrange_GI2_Early	0x700000
-#define		bRxFrame_Guard_Counter_L	0x3800000
-#define		bRxSGI_Guard_L				0xc000000
-#define		bRxSGI_Search_L			0x30000000
-#define		bRxSGI_TH					0xc0000000
-#define		bDFSCnt0					0xff
-#define		bDFSCnt1					0xff00
-#define		bDFSFlag					0xf0000
-#define		bMFWeightSum				0x300000
-#define		bMinIdxTH					0x7f000000
-#define		bDAFormat					0x40000
-#define		bTxChEmuEnable			0x01000000
-#define		bTRSWIsolation_A			0x7f
-#define		bTRSWIsolation_B			0x7f00
-/*
-#define		bTRSWIsolation_C			0x7f0000
-#define		bTRSWIsolation_D			0x7f000000
-*/
-#define		bExtLNAGain					0x7c00
-
-
-//
-// 6. PageE(0xE00)
-//
-#define		bSTBCEn                  			0x4	// Useless
-#define		bAntennaMapping			0x10
-#define		bNss						0x20
-#define		bCFOAntSumD				0x200
-#define		bOFDMDisPwsavTx				0x400000
-#define		bPHYCounterReset			0x8000000
-#define		bCFOReportGet				0x4000000
-#define		bOFDMContinueTx			0x10000000
-#define		bOFDMSingleCarrier			0x20000000
-#define		bOFDMSingleTone			0x40000000
-/*
-#define bRxPath1                 0x01
-#define bRxPath2                 0x02
-#define bRxPath3                 0x04
-#define bRxPath4                 0x08
-#define bTxPath1                 0x10
-#define bTxPath2                 0x20
-*/
-#define		bHTDetect					0x100
-#define		bCFOEn						0x10000
-#define		bCFOValue					0xfff00000
-#define		bSigTone_Re				0x3f
-#define		bSigTone_Im				0x7f00
-#define		bCounter_CCA				0xffff
-#define		bCounter_ParityFail			0xffff0000
-#define		bCounter_RateIllegal			0xffff
-#define		bCounter_CRC8Fail			0xffff0000
-#define		bCounter_MCSNoSupport		0xffff
-#define		bCounter_FastSync			0xffff
-#define		bShortCFO					0xfff
-#define		bShortCFOTLength			12   //total
-#define		bShortCFOFLength			11   //fraction
-#define		bLongCFO					0x7ff
-#define		bLongCFOTLength			11
-#define		bLongCFOFLength			11
-#define		bTailCFO					0x1fff
-#define		bTailCFOTLength				13
-#define		bTailCFOFLength				12
-#define		bmax_en_pwdB				0xffff
-#define		bCC_power_dB				0xffff0000
-#define		bnoise_pwdB				0xffff
-#define		bPowerMeasTLength			10
-#define		bPowerMeasFLength			3
-#define		bRx_HT_BW					0x1
-#define		bRxSC						0x6
-#define		bRx_HT						0x8
-#define		bNB_intf_det_on				0x1
-#define		bIntf_win_len_cfg			0x30
-#define		bNB_Intf_TH_cfg				0x1c0
-#define		bRFGain						0x3f
-#define		bTableSel					0x40
-#define		bTRSW						0x80
-#define		bRxSNR_A					0xff
-#define		bRxSNR_B					0xff00
-/*
-#define		bRxSNR_C					0xff0000
-#define		bRxSNR_D					0xff000000
-*/
-#define		bSNREVMTLength				8
-#define		bSNREVMFLength				1
-#define		bCSI1st						0xff
-#define		bCSI2nd						0xff00
-#define		bRxEVM1st					0xff0000
-#define		bRxEVM2nd					0xff000000
-#define		bSIGEVM					0xff
-#define		bPWDB						0xff00
-#define		bSGIEN						0x10000
-
-#define		bSFactorQAM1				0xf	// Useless
-#define		bSFactorQAM2				0xf0
-#define		bSFactorQAM3				0xf00
-#define		bSFactorQAM4				0xf000
-#define		bSFactorQAM5				0xf0000
-#define		bSFactorQAM6				0xf0000
-#define		bSFactorQAM7				0xf00000
-#define		bSFactorQAM8				0xf000000
-#define		bSFactorQAM9				0xf0000000
-#define		bCSIScheme					0x100000
-
-#define		bNoiseLvlTopSet				0x3	// Useless
-#define		bChSmooth					0x4
-#define		bChSmoothCfg1				0x38
-#define		bChSmoothCfg2				0x1c0
-#define		bChSmoothCfg3				0xe00
-#define		bChSmoothCfg4				0x7000
-#define		bMRCMode					0x800000
-#define		bTHEVMCfg					0x7000000
-
-#define		bLoopFitType				0x1	// Useless
-#define		bUpdCFO					0x40
-#define		bUpdCFOOffData				0x80
-#define		bAdvUpdCFO					0x100
-#define		bAdvTimeCtrl				0x800
-#define		bUpdClko					0x1000
-#define		bFC							0x6000
-#define		bTrackingMode				0x8000
-#define		bPhCmpEnable				0x10000
-#define		bUpdClkoLTF				0x20000
-#define		bComChCFO					0x40000
-#define		bCSIEstiMode				0x80000
-#define		bAdvUpdEqz					0x100000
-#define		bUChCfg						0x7000000
-#define		bUpdEqz					0x8000000
-
-#define		bTxAGCRate18_06			0x7f7f7f7f	// Useless
-#define		bTxAGCRate54_24			0x7f7f7f7f
-#define		bTxAGCRateMCS32			0x7f
-#define		bTxAGCRateCCK				0x7f00
-#define		bTxAGCRateMCS3_MCS0		0x7f7f7f7f
-#define		bTxAGCRateMCS7_MCS4		0x7f7f7f7f
-#define		bTxAGCRateMCS11_MCS8		0x7f7f7f7f
-#define		bTxAGCRateMCS15_MCS12	0x7f7f7f7f
-
-//Rx Pseduo noise
-#define		bRxPesudoNoiseOn			0x20000000	// Useless
-#define		bRxPesudoNoise_A			0xff
-#define		bRxPesudoNoise_B			0xff00
-/*
-#define		bRxPesudoNoise_C			0xff0000
-#define		bRxPesudoNoise_D			0xff000000
-*/
-#define		bPesudoNoiseState_A		0xffff
-#define		bPesudoNoiseState_B		0xffff0000
-/*
-#define		bPesudoNoiseState_C		0xffff
-#define		bPesudoNoiseState_D		0xffff0000
-*/
-
-
-//
-//7. RF Register
-//
-//Zebra1
-#define		bZebra1_HSSIEnable			0x8		// Useless
-#define		bZebra1_TRxControl			0xc00
-#define		bZebra1_TRxGainSetting		0x07f
-#define		bZebra1_RxCorner			0xc00
-#define		bZebra1_TxChargePump		0x38
-#define		bZebra1_RxChargePump		0x7
-#define		bZebra1_ChannelNum		0xf80
-#define		bZebra1_TxLPFBW			0x400
-#define		bZebra1_RxLPFBW			0x600
-
-//Zebra4
-#define		bRTL8256RegModeCtrl1		0x100	// Useless
-#define		bRTL8256RegModeCtrl0		0x40
-#define		bRTL8256_TxLPFBW			0x18
-#define		bRTL8256_RxLPFBW			0x600
-
-//RTL8258
-#define		bRTL8258_TxLPFBW			0xc	// Useless
-#define		bRTL8258_RxLPFBW			0xc00
-#define		bRTL8258_RSSILPFBW		0xc0
-
-
-//
-// Other Definition
-//
-//byte endable for sb_write
-#define		bByte0						0x1	// Useless
-#define		bByte1						0x2
-#define		bByte2						0x4
-#define		bByte3						0x8
-#define		bWord0						0x3
-#define		bWord1						0xc
-#define		bDWord						0xf
-
-//for PutRegsetting & GetRegSetting BitMask
-#define		bMaskByte0					0xff	// Reg 0xc50 rOFDM0_XAAGCCore~0xC6f
-#define		bMaskByte1					0xff00
-#define		bMaskByte2					0xff0000
-#define		bMaskByte3					0xff000000
-#define		bMaskHWord				0xffff0000
-#define		bMaskLWord					0x0000ffff
-#define		bMaskDWord				0xffffffff
-#define		bMaskH4Bits				  0xf0000000
-#define 	bMaskOFDM_D				  0xffc00000
-#define		bMaskCCK				  0x3f3f3f3f
-
-
-//for PutRFRegsetting & GetRFRegSetting BitMask
-#define		bMask12Bits					0xfff	// RF Reg mask bits
-#define		bMask20Bits					0xfffff	// RF Reg mask bits T65 RF
-
-#define		bEnable						0x1	// Useless
-#define		bDisable					0x0
-
-#define		LeftAntenna					0x0	// Useless
-#define		RightAntenna				0x1
-
-#define		tCheckTxStatus				500   //500ms // Useless
-#define		tUpdateRxCounter			100   //100ms
-
-#define		rateCCK						0	// Useless
-#define		rateOFDM					1
-#define		rateHT						2
-
-//define Register-End
-#define		bPMAC_End					0x1ff	// Useless
-#define		bFPGAPHY0_End				0x8ff
-#define		bFPGAPHY1_End				0x9ff
-#define		bCCKPHY0_End				0xaff
-#define		bOFDMPHY0_End				0xcff
-#define		bOFDMPHY1_End				0xdff
-/*
-//define max debug item in each debug page
-#define bMaxItem_FPGA_PHY0        0x9
-#define bMaxItem_FPGA_PHY1        0x3
-#define bMaxItem_PHY_11B          0x16
-#define bMaxItem_OFDM_PHY0        0x29
-#define bMaxItem_OFDM_PHY1        0x0
-*/
-#define		bPMACControl				0x0		// Useless
-#define		bWMACControl				0x1
-#define		bWNICControl				0x2
-
-#define		PathA						0x0	// Useless
-#define		PathB						0x1
-/*
-#define		PathC						0x2
-#define		PathD						0x3
-*/
-
-
-#define 	REG_SYS_FUNC_EN				0x2
-#define 	REG_AFE_PLL_CTRL				0x28
-#define 	REG_RF_CTRL					0x1f
-#define 	REG_LDOHCI12_CTRL				0x22
-#define 	REG_AFE_XTAL_CTRL				0x24
-#define		RF_T_METER					0x24	
-#define 	REG_MCUFWDL					0x80
-#define 	REG_HMETFR					0x01CC
-
-#define		RF_T_METER_92D					0x42
-
-/*--------------------------Define Parameters-------------------------------*/
-//#endif
-
-#endif // _8192CD_PHYREG_H_
-
+/*
+ *  Header file for 8190 Phy Register Definition
+ *
+ *  $Id: 8192cd_phyreg.h,v 1.2.2.3 2010/09/01 07:07:58 button Exp $
+ *
+ *  Copyright (c) 2009 Realtek Semiconductor Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef _8192CD_PHYREG_H_
+#define _8192CD_PHYREG_H_
+
+/*--------------------------Define Parameters-------------------------------*/
+
+//============================================================
+//       8192CD Register offset definition
+//============================================================
+
+//
+// BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF
+// 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+// 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
+// 3. RF register 0x00-2E
+// 4. Bit Mask for BB/RF register
+// 5. Other defintion for BB/RF R/W
+//
+
+/*
+//
+// 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+// 1. Page1(0x100)
+//
+#define		rPMAC_Reset					0x100
+#define		rPMAC_TxStart					0x104
+#define		rPMAC_TxLegacySIG				0x108
+#define		rPMAC_TxHTSIG1				0x10c
+#define		rPMAC_TxHTSIG2				0x110
+#define		rPMAC_PHYDebug				0x114
+#define		rPMAC_TxPacketNum				0x118
+#define		rPMAC_TxIdle					0x11c
+#define		rPMAC_TxMACHeader0			0x120
+#define		rPMAC_TxMACHeader1			0x124
+#define		rPMAC_TxMACHeader2			0x128
+#define		rPMAC_TxMACHeader3			0x12c
+#define		rPMAC_TxMACHeader4			0x130
+#define		rPMAC_TxMACHeader5			0x134
+#define		rPMAC_TxDataType				0x138
+#define		rPMAC_TxRandomSeed			0x13c
+#define		rPMAC_CCKPLCPPreamble			0x140
+#define		rPMAC_CCKPLCPHeader			0x144
+#define		rPMAC_CCKCRC16				0x148
+#define		rPMAC_OFDMRxCRC32OK			0x170
+#define		rPMAC_OFDMRxCRC32Er			0x174
+#define		rPMAC_OFDMRxParityEr			0x178
+#define		rPMAC_OFDMRxCRC8Er			0x17c
+#define		rPMAC_CCKCRxRC16Er			0x180
+#define		rPMAC_CCKCRxRC32Er			0x184
+#define		rPMAC_CCKCRxRC32OK			0x188
+#define		rPMAC_TxStatus					0x18c
+*/
+
+
+//
+// 2. BB Register Page8(0x800)
+//
+#define		rFPGA0_RFMOD					0x800	//RF mode & CCK TxSC // RF BW Setting??
+#define		rFPGA0_TxInfo					0x804	// Status report??
+#define		rFPGA0_PSDFunction				0x808
+#define		rFPGA0_TxGainStage				0x80c	// Set TX PWR init gain?
+#define		rFPGA0_RFTiming1				0x810	// Useless now
+#define		rFPGA0_RFTiming2				0x814
+/*
+#define rFPGA0_XC_RFTiming        		0x818
+#define rFPGA0_XD_RFTiming        		0x81c
+*/
+#define		rFPGA0_XA_HSSIParameter1		0x820	// RF 3 wire register
+#define		rFPGA0_XA_HSSIParameter2		0x824
+#define		rFPGA0_XB_HSSIParameter1		0x828
+#define		rFPGA0_XB_HSSIParameter2		0x82c
+#define		rTxAGC_B_Rate18_06			0x830
+#define		rTxAGC_B_Rate54_24			0x834
+#define		rTxAGC_B_CCK5_1_Mcs32		0x838
+#define		rTxAGC_B_Mcs03_Mcs00			0x83c
+#define		rFPGA0_XA_LSSIParameter		0x840
+#define		rFPGA0_XB_LSSIParameter		0x844
+#define		rTxAGC_B_Mcs07_Mcs04			0x848
+#define		rTxAGC_B_Mcs11_Mcs08			0x84c
+#define		rFPGA0_RFWakeUpParameter		0x850	// Useless now
+#define		rFPGA0_RFSleepUpParameter		0x854
+#define		rFPGA0_XAB_SwitchControl		0x858	// RF Channel switch
+#define		rFPGA0_XCD_SwitchControl		0x85c
+#define		rFPGA0_XA_RFInterfaceOE		0x860	// RF Channel switch
+#define		rFPGA0_XB_RFInterfaceOE		0x864
+#define		rTxAGC_B_Mcs15_Mcs12			0x868
+#define		rTxAGC_A_CCK11_2_B_CCK11		0x86c
+#define		rFPGA0_XAB_RFInterfaceSW		0x870	// RF Interface Software Control
+#define		rFPGA0_XCD_RFInterfaceSW		0x874
+#define		rFPGA0_XAB_RFParameter		0x878	// RF Parameter
+#define		rFPGA0_XCD_RFParameter		0x87c
+#define		rFPGA0_AnalogParameter1		0x880	// Crystal cap setting RF-R/W protection for parameter4??
+#define		rFPGA0_AnalogParameter2		0x884
+#if defined(CONFIG_RTL_92D_SUPPORT)
+#define		rFPGA0_AdDaClockEn				0x888	// enable ad/da clock1 for dual-phy
+#else
+#define		rFPGA0_AnalogParameter3		0x888	// Useless now
+#endif
+#define		rFPGA0_AnalogParameter4		0x88c
+#define		rFPGA0_XA_LSSIReadBack		0x8a0	// Tranceiver LSSI Readback
+#define		rFPGA0_XB_LSSIReadBack		0x8a4
+/*
+#define		rFPGA0_XC_LSSIReadBack		0x8a8
+#define		rFPGA0_XD_LSSIReadBack		0x8ac
+*/
+#define		rFPGA0_PSDReport				0x8b4	// Useless now
+#define		TransceiverA_HSPI_Readback	0x8b8
+#define		TransceiverB_HSPI_Readback	0x8bc
+#define		rFPGA0_XAB_RFInterfaceRB		0x8e0	// Useless now // RF Interface Readback Value
+//#define		rFPGA0_XCD_RFInterfaceRB		0x8e4	// Useless now
+
+
+//
+// 3. BB Register Page9(0x900)
+//
+#define		rFPGA1_RFMOD				0x900	//RF mode & OFDM TxSC // RF BW Setting??
+#define		rFPGA1_TxBlock				0x904	// Useless now
+#define		rFPGA1_DebugSelect			0x908	// Useless now
+#define		rFPGA1_TxInfo				0x90c	// Useless now // Status report??
+
+
+//
+// 4. BB Register PageA(0xA00)
+//
+// Set Control channel to upper or lower. These settings are required only for 40MHz
+#define		rCCK0_System				0xa00
+#define		rCCK0_AFESetting			0xa04	// Disable init gain now // Select RX path by RSSI
+#define		rCCK0_CCA					0xa08	// Disable init gain now // Init gain
+#define		rCCK0_RxAGC1				0xa0c 	//AGC default value, saturation level // Antenna Diversity, RX AGC, LNA Threshold, RX LNA Threshold useless now. Not the same as 90 series
+#define		rCCK0_RxAGC2				0xa10 	//AGC & DAGC
+#define		rCCK0_RxHP					0xa14
+#define		rCCK0_DSPParameter1		0xa18	//Timing recovery & Channel estimation threshold
+#define		rCCK0_DSPParameter2		0xa1c	//SQ threshold
+#define		rCCK0_TxFilter1				0xa20
+#define		rCCK0_TxFilter2				0xa24
+#define		rCCK0_DebugPort			0xa28	//debug port and Tx filter3
+#define		rCCK0_FalseAlarmReport		0xa2c	//0xa2d	useless now 0xa30-a4f channel report
+#define		rCCK0_TRSSIReport         		0xa50
+#define		rCCK0_RxReport            		0xa54  //0xa57
+#define		rCCK0_FACounterLower      	0xa5c  //0xa5b
+#define		rCCK0_FACounterUpper      	0xa58  //0xa5c
+
+
+//
+// 5. BB Register PageC(0xC00)
+//
+#define		rOFDM0_LSTF				0xc00
+#define		rOFDM0_TRxPathEnable		0xc04
+#define		rOFDM0_TRMuxPar			0xc08
+#define		rOFDM0_TRSWIsolation		0xc0c
+#define		rOFDM0_XARxAFE			0xc10  //RxIQ DC offset, Rx digital filter, DC notch filter
+#define		rOFDM0_XARxIQImbalance    	0xc14  //RxIQ imblance matrix
+#define		rOFDM0_XBRxAFE            		0xc18
+#define		rOFDM0_XBRxIQImbalance    	0xc1c
+/*
+#define		rOFDM0_XCRxAFE            		0xc20
+#define		rOFDM0_XCRxIQImbalance    	0xc24
+#define		rOFDM0_XDRxAFE            		0xc28
+#define		rOFDM0_XDRxIQImbalance    	0xc2c
+*/
+#define		rOFDM0_RxDetector1			0xc30  //PD,BW & SBD	// DM tune init gain
+#define		rOFDM0_RxDetector2			0xc34  //SBD & Fame Sync.
+#define		rOFDM0_RxDetector3			0xc38  //Frame Sync.
+#define		rOFDM0_RxDetector4			0xc3c  //PD, SBD, Frame Sync & Short-GI
+#define		rOFDM0_RxDSP				0xc40  //Rx Sync Path
+#define		rOFDM0_CFOandDAGC		0xc44  //CFO & DAGC
+#define		rOFDM0_CCADropThreshold	0xc48 //CCA Drop threshold
+#define		rOFDM0_ECCAThreshold		0xc4c // energy CCA
+#define		rOFDM0_XAAGCCore1			0xc50	// DIG
+#define		rOFDM0_XAAGCCore2			0xc54
+#define		rOFDM0_XBAGCCore1			0xc58
+#define		rOFDM0_XBAGCCore2			0xc5c
+/*
+#define		rOFDM0_XCAGCCore1			0xc60
+#define		rOFDM0_XCAGCCore2			0xc64
+#define		rOFDM0_XDAGCCore1			0xc68
+#define		rOFDM0_XDAGCCore2			0xc6c
+*/
+#define		rOFDM0_AGCParameter1		0xc70
+#define		rOFDM0_AGCParameter2		0xc74
+#define		rOFDM0_AGCRSSITable		0xc78
+#define		rOFDM0_HTSTFAGC			0xc7c
+#define		rOFDM0_XATxIQImbalance	0xc80	// TX PWR TRACK and DIG
+#define		rOFDM0_XATxAFE			0xc84
+#define		rOFDM0_XBTxIQImbalance	0xc88
+#define		rOFDM0_XBTxAFE			0xc8c
+
+
+#define		rOFDM0_XCTxIQImbalance		0xc90
+#define		rOFDM0_XCTxAFE            			0xc94
+#define		rOFDM0_XDTxIQImbalance		0xc98
+#define		rOFDM0_XDTxAFE				0xc9c
+#define		rOFDM0_RxIQExtAnta			0xca0
+
+
+#define		rOFDM0_RxHPParameter		0xce0
+#define		rOFDM0_TxPseudoNoiseWgt	0xce4
+#define		rOFDM0_FrameSync			0xcf0
+#define		rOFDM0_DFSReport			0xcf4
+#define		rOFDM0_TxCoeff1			0xca4
+#define		rOFDM0_TxCoeff2			0xca8
+#define		rOFDM0_TxCoeff3			0xcac
+#define		rOFDM0_TxCoeff4			0xcb0
+#define		rOFDM0_TxCoeff5			0xcb4
+#define		rOFDM0_TxCoeff6			0xcb8
+
+
+//
+// 6. BB Register PageD(0xD00)
+//
+#define		rOFDM1_LSTF					0xd00
+#define		rOFDM1_TRxPathEnable			0xd04
+#define		rOFDM1_CFO						0xd08	// No setting now
+#define		rOFDM1_CSI1					0xd10
+#define		rOFDM1_SBD						0xd14
+#define		rOFDM1_CSI2					0xd18
+#define		rOFDM1_CFOTracking			0xd2c
+#define		rOFDM1_TRxMesaure1			0xd34
+#define		rOFDM1_IntfDet					0xd3c
+#define		rOFDM1_PseudoNoiseStateAB		0xd50
+#define		rOFDM1_PseudoNoiseStateCD		0xd54
+#define		rOFDM1_RxPseudoNoiseWgt		0xd58
+#define		rOFDM_PHYCounter1				0xda0  //cca, parity fail
+#define		rOFDM_PHYCounter2				0xda4  //rate illegal, crc8 fail
+#define		rOFDM_PHYCounter3				0xda8  //MCS not support
+#define		rOFDM_ShortCFOAB				0xdac	// No setting now
+#define		rOFDM_ShortCFOCD				0xdb0
+#define		rOFDM_LongCFOAB				0xdb4
+#define		rOFDM_LongCFOCD				0xdb8
+#define		rOFDM_TailCFOAB				0xdbc
+#define		rOFDM_TailCFOCD				0xdc0
+#define		rOFDM_PWMeasure1          		0xdc4
+#define		rOFDM_PWMeasure2          		0xdc8
+#define		rOFDM_BWReport				0xdcc
+#define		rOFDM_AGCReport				0xdd0
+#define		rOFDM_RxSNR					0xdd4
+#define		rOFDM_RxEVMCSI				0xdd8
+#define		rOFDM_SIGReport				0xddc
+
+
+//
+// 6. BB Register PageE(0xE00)
+//
+#define		rTxAGC_A_Rate18_06		0xe00
+#define		rTxAGC_A_Rate54_24		0xe04
+#define		rTxAGC_A_CCK1_Mcs32		0xe08
+#define		rTxAGC_A_Mcs03_Mcs00		0xe10
+#define		rTxAGC_A_Mcs07_Mcs04		0xe14
+#define		rTxAGC_A_Mcs11_Mcs08		0xe18
+#define		rTxAGC_A_Mcs15_Mcs12		0xe1c
+
+
+//
+// 7. RF Register 0x00-0x2E
+//
+//Zebra1
+#define		rZebra1_HSSIEnable			0x0	// Useless now
+#define		rZebra1_TRxEnable1			0x1
+#define		rZebra1_TRxEnable2			0x2
+#define		rZebra1_AGC				0x4
+#define		rZebra1_ChargePump		0x5
+#define		rZebra1_Channel			0x7	// RF channel switch
+#define		rZebra1_TxGain				0x8	// Useless now
+#define		rZebra1_TxLPF				0x9
+#define		rZebra1_RxLPF				0xb
+#define		rZebra1_RxHPFCorner		0xc
+#define		rRfChannel					0x18	// RF channel switch	For T65 RF 0222d
+
+//Zebra4
+#define		rGlobalCtrl					0	// Useless now
+#define		rRTL8256_TxLPF				19
+#define		rRTL8256_RxLPF				11
+
+//RTL8258
+#define		rRTL8258_RSSILPF			0xa
+#define		rRTL8258_TxLPF				0x11	// Useless now
+#define		rRTL8258_RxLPF				0x13
+
+
+#define		RF_RX_G1					0x1A	// 
+#define		RF_RX_G2					0x1B	// 
+
+
+//
+//Bit Mask
+//
+// 1. Page1(0x100)
+/*
+#define		bBBResetB					0x100	// Useless now?
+#define		bGlobalResetB				0x200
+#define		bOFDMTxStart				0x4
+#define		bCCKTxStart					0x8
+#define		bCRC32Debug				0x100
+#define		bPMACLoopback				0x10
+#define		bTxLSIG						0xffffff
+#define		bOFDMTxRate				0xf
+#define		bOFDMTxReserved			0x10
+#define		bOFDMTxLength				0x1ffe0
+#define		bOFDMTxParity				0x20000
+#define		bTxHTSIG1					0xffffff
+#define		bTxHTMCSRate				0x7f
+#define		bTxHTBW					0x80
+#define		bTxHTLength				0xffff00
+#define		bTxHTSIG2					0xffffff
+#define		bTxHTSmoothing				0x1
+#define		bTxHTSounding				0x2
+#define		bTxHTReserved				0x4
+#define		bTxHTAggreation			0x8
+#define		bTxHTSTBC					0x30
+#define		bTxHTAdvanceCoding		0x40
+#define		bTxHTShortGI				0x80
+#define		bTxHTNumberHT_LTF		0x300
+#define		bTxHTCRC8					0x3fc00
+#define		bCounterReset				0x10000
+#define		bNumOfOFDMTx				0xffff
+#define		bNumOfCCKTx				0xffff0000
+#define		bTxIdleInterval				0xffff
+#define		bOFDMService				0xffff0000
+#define		bTxMACHeader				0xffffffff
+#define		bTxDataInit					0xff
+#define		bTxHTMode					0x100
+#define		bTxDataType				0x30000
+#define		bTxRandomSeed				0xffffffff
+#define		bCCKTxPreamble				0x1
+#define		bCCKTxSFD					0xffff0000
+#define		bCCKTxSIG					0xff
+#define		bCCKTxService				0xff00
+#define		bCCKLengthExt				0x8000
+#define		bCCKTxLength				0xffff0000
+#define		bCCKTxCRC16				0xffff
+#define		bCCKTxStatus				0x1
+#define		bOFDMTxStatus				0x2
+*/
+
+
+//
+// 2. Page8(0x800)
+//
+#define		bRFMOD						0x1	// Reg 0x800 rFPGA0_RFMOD
+#define		bJapanMode					0x2
+#define		bCCKTxSC					0x30
+#define		bCCKEn						0x1000000
+#define		bOFDMEn					0x2000000
+
+#define		bOFDMRxADCPhase           	0x10000	// Useless now
+#define		bOFDMTxDACPhase           	0x40000
+
+#define		bXATxAGC                  			0x3f
+#define		bXBTxAGC                  			0xf00	// Reg 80c rFPGA0_TxGainStage
+/*
+#define		bXCTxAGC                  			0xf000
+#define		bXDTxAGC                  			0xf0000
+*/
+
+#define		bPAStart                  			0xf0000000	// Useless now
+#define		bTRStart                  			0x00f00000
+#define		bRFStart                  			0x0000f000
+#define		bBBStart                  			0x000000f0
+#define		bBBCCKStart               		0x0000000f
+#define		bPAEnd                    			0xf          //Reg0x814
+#define		bTREnd                    			0x0f000000
+#define		bRFEnd                    			0x000f0000
+#define		bCCAMask                  			0x000000f0   //T2R
+#define		bR2RCCAMask               		0x00000f00
+#define		bHSSI_R2TDelay            		0xf8000000
+#define		bHSSI_T2RDelay            		0xf80000
+#define		bContTxHSSI               		0x400     //chane gain at continue Tx
+#define		bIGFromCCK                		0x200
+#define		bAGCAddress               		0x3f
+#define		bRxHPTx                   			0x7000
+#define		bRxHPT2R                  			0x38000
+#define		bRxHPCCKIni               		0xc0000
+#define		bAGCTxCode                		0xc00000
+#define		bAGCRxCode                		0x300000
+
+#define		b3WireDataLength          		0x800	// Reg 0x820~84f rFPGA0_XA_HSSIParameter1
+#define		b3WireAddressLength       	0x400
+
+#define		b3WireRFPowerDown         	0x1	// Useless now
+//#define bHWSISelect               		0x8
+#define		b5GPAPEPolarity           		0x40000000
+#define		b2GPAPEPolarity           		0x80000000
+#define		bRFSW_TxDefaultAnt        	0x3
+#define		bRFSW_TxOptionAnt         	0x30
+#define		bRFSW_RxDefaultAnt        	0x300
+#define		bRFSW_RxOptionAnt         	0x3000
+#define		bRFSI_3WireData           		0x1
+#define		bRFSI_3WireClock          		0x2
+#define		bRFSI_3WireLoad           		0x4
+#define		bRFSI_3WireRW             		0x8
+#define		bRFSI_3Wire               		0xf
+
+#define		bRFSI_RFENV               		0x10	// Reg 0x870 rFPGA0_XAB_RFInterfaceSW
+
+#define		bRFSI_TRSW                		0x20	// Useless now
+#define		bRFSI_TRSWB               		0x40
+#define		bRFSI_ANTSW               		0x100
+#define		bRFSI_ANTSWB              		0x200
+#define		bRFSI_PAPE                		0x400
+#define		bRFSI_PAPE5G              		0x800
+#define		bBandSelect               		0x1
+#define		bHTSIG2_GI                		0x80
+#define		bHTSIG2_Smoothing         	0x01
+#define		bHTSIG2_Sounding          		0x02
+#define		bHTSIG2_Aggreaton         	0x08
+#define		bHTSIG2_STBC              		0x30
+#define		bHTSIG2_AdvCoding         	0x40
+#define		bHTSIG2_NumOfHTLTF        	0x300
+#define		bHTSIG2_CRC8              		0x3fc
+#define		bHTSIG1_MCS               		0x7f
+#define		bHTSIG1_BandWidth         	0x80
+#define		bHTSIG1_HTLength          		0xffff
+#define		bLSIG_Rate                			0xf
+#define		bLSIG_Reserved            		0x10
+#define		bLSIG_Length              		0x1fffe
+#define		bLSIG_Parity              		0x20
+#define		bCCKRxPhase               		0x4
+
+//#define		bLSSIReadAddress          		0x3f000000   //LSSI "Read" Address	// Reg 0x824 rFPGA0_XA_HSSIParameter2
+#define		bLSSIReadAddress          		0x7f800000   // T65 RF
+#define		bLSSIReadEdge             		0x80000000   //LSSI "Read" edge signal
+
+//#define		bLSSIReadBackData         		0xfff		// Reg 0x8a0 rFPGA0_XA_LSSIReadBack
+#define		bLSSIReadBackData         		0xfffff		// T65 RF
+
+#define		bLSSIReadOKFlag           		0x1000	// Useless now
+#define		bCCKSampleRate            		0x8       //0: 44MHz, 1:88MHz
+#define		bRegulator0Standby        		0x1
+#define		bRegulatorPLLStandby      	0x2
+#define		bRegulator1Standby        		0x4
+#define		bPLLPowerUp               		0x8
+#define		bDPLLPowerUp              		0x10
+#define		bDA10PowerUp              		0x20
+#define		bAD7PowerUp               		0x200
+#define		bDA6PowerUp               		0x2000
+#define		bXtalPowerUp              		0x4000
+#define		b40MDClkPowerUP           		0x8000
+#define		bDA6DebugMode             		0x20000
+#define		bDA6Swing                 		0x380000
+
+#define		bADClkPhase               		0x4000000	// Reg 0x880 rFPGA0_AnalogParameter1 20/40 CCK support switch 40/80 BB MHZ
+
+#define		b80MClkDelay              		0x18000000	// Useless
+#define		bAFEWatchDogEnable        	0x20000000
+
+#define		bXtalCap01                			0xc0000000	// Reg 0x884 rFPGA0_AnalogParameter2 Crystal cap
+#define		bXtalCap23                			0x3
+#define		bXtalCap92x					0x0f000000
+
+#define		bIntDifClkEnable          		0x400	// Useless
+#define		bExtSigClkEnable         	 	0x800
+#define		bBandgapMbiasPowerUp      	0x10000
+#define		bAD11SHGain               		0xc0000
+#define		bAD11InputRange           		0x700000
+#define		bAD11OPCurrent            		0x3800000
+#define		bIPathLoopback            		0x4000000
+#define		bQPathLoopback            		0x8000000
+#define		bAFELoopback              		0x10000000
+#define		bDA10Swing                		0x7e0
+#define		bDA10Reverse              		0x800
+#define		bDAClkSource              		0x1000
+#define		bAD7InputRange            		0x6000
+#define		bAD7Gain                  			0x38000
+#define		bAD7OutputCMMode          	0x40000
+#define		bAD7InputCMMode           		0x380000
+#define		bAD7Current               		0xc00000
+#define		bRegulatorAdjust          		0x7000000
+#define		bAD11PowerUpAtTx          	0x1
+#define		bDA10PSAtTx               		0x10
+#define		bAD11PowerUpAtRx          	0x100
+#define		bDA10PSAtRx               		0x1000
+#define		bCCKRxAGCFormat           		0x200
+#define		bPSDFFTSamplepPoint       	0xc000
+#define		bPSDAverageNum            		0x3000
+#define		bIQPathControl            		0xc00
+#define		bPSDFreq                  			0x3ff
+#define		bPSDAntennaPath           		0x30
+#define		bPSDIQSwitch              		0x40
+#define		bPSDRxTrigger             		0x400000
+#define		bPSDTxTrigger             		0x80000000
+#define		bPSDSineToneScale        		0x7f000000
+#define		bPSDReport                		0xffff
+
+
+//
+// 3. Page9(0x900)
+//
+#define		bOFDMTxSC                 		0x30000000	// Useless
+#define		bCCKTxOn                  			0x1
+#define		bOFDMTxOn                 		0x2
+#define		bDebugPage                		0xfff  //reset debug page and also HWord, LWord
+#define		bDebugItem                		0xff   //reset debug page and LWord
+#define		bAntL              	       		0x10
+#define		bAntNonHT           	    		0x100
+#define		bAntHT1               			0x1000
+#define		bAntHT2                   			0x10000
+#define		bAntHT1S1                 			0x100000
+#define		bAntNonHTS1               		0x1000000
+
+
+//
+// 4. PageA(0xA00)
+//
+#define		bCCKBBMode                		0x3	// Useless
+#define		bCCKTxPowerSaving        		0x80
+#define		bCCKRxPowerSaving         	0x40
+
+#define		bCCKSideBand              		0x10	// Reg 0xa00 rCCK0_System 20/40 switch
+
+#define		bCCKScramble              		0x8	// Useless
+#define		bCCKAntDiversity    		      	0x8000
+#define		bCCKCarrierRecovery   	    	0x4000
+#define		bCCKTxRate           		     	0x3000
+#define		bCCKDCCancel             	 	0x0800
+#define		bCCKISICancel             		0x0400
+#define		bCCKMatchFilter           		0x0200
+#define		bCCKEqualizer             		0x0100
+#define		bCCKPreambleDetect       	 	0x800000
+#define		bCCKFastFalseCCA          		0x400000
+#define		bCCKChEstStart            		0x300000
+#define		bCCKCCACount              		0x080000
+#define		bCCKcs_lim                			0x070000
+#define		bCCKBistMode              		0x80000000
+#define		bCCKCCAMask             	  	0x40000000
+#define		bCCKTxDACPhase         	   	0x4
+#define		bCCKRxADCPhase         	   	0x20000000   //r_rx_clk
+#define		bCCKr_cp_mode0         	   	0x0100
+#define		bCCKTxDCOffset           	 	0xf0
+#define		bCCKRxDCOffset           	 	0xf
+#define		bCCKCCAMode              	 	0xc000
+#define		bCCKFalseCS_lim           		0x3f00
+#define		bCCKCS_ratio              		0xc00000
+#define		bCCKCorgBit_sel           		0x300000
+#define		bCCKPD_lim                		0x0f0000
+#define		bCCKNewCCA                		0x80000000
+#define		bCCKRxHPofIG              		0x8000
+#define		bCCKRxIG                  			0x7f00
+#define		bCCKLNAPolarity           		0x800000
+#define		bCCKRx1stGain             		0x7f0000
+#define		bCCKRFExtend              		0x20000000 //CCK Rx Iinital gain polarity
+#define		bCCKRxAGCSatLevel        	 	0x1f000000
+#define		bCCKRxAGCSatCount       	  	0xe0
+#define		bCCKRxRFSettle            		0x1f       //AGCsamp_dly
+#define		bCCKFixedRxAGC           	 	0x8000
+//#define bCCKRxAGCFormat         	 	0x4000   //remove to HSSI register 0x824
+#define		bCCKAntennaPolarity      	 	0x2000
+#define		bCCKTxFilterType          		0x0c00
+#define		bCCKRxAGCReportType   	   	0x0300
+#define		bCCKRxDAGCEn              		0x80000000
+#define		bCCKRxDAGCPeriod        	  	0x20000000
+#define		bCCKRxDAGCSatLevel     	   	0x1f000000
+#define		bCCKTimingRecovery       	 	0x800000
+#define		bCCKTxC0                  			0x3f0000
+#define		bCCKTxC1                  			0x3f000000
+#define		bCCKTxC2                  			0x3f
+#define		bCCKTxC3                  			0x3f00
+#define		bCCKTxC4                  			0x3f0000
+#define		bCCKTxC5                  			0x3f000000
+#define		bCCKTxC6                  			0x3f
+#define		bCCKTxC7                  			0x3f00
+#define		bCCKDebugPort             		0xff0000
+#define		bCCKDACDebug              		0x0f000000
+#define		bCCKFalseAlarmEnable    		0x8000
+#define		bCCKFalseAlarmRead        	0x4000
+#define		bCCKTRSSI                 			0x7f
+#define		bCCKRxAGCReport           		0xfe
+#define		bCCKRxReport_AntSel       	0x80000000
+#define		bCCKRxReport_MFOff        	0x40000000
+#define		bCCKRxRxReport_SQLoss     	0x20000000
+#define		bCCKRxReport_Pktloss      	0x10000000
+#define		bCCKRxReport_Lockedbit    	0x08000000
+#define		bCCKRxReport_RateError    	0x04000000
+#define		bCCKRxReport_RxRate       	0x03000000
+#define		bCCKRxFACounterLower      	0xff
+#define		bCCKRxFACounterUpper      	0xff000000
+#define		bCCKRxHPAGCStart          		0xe000
+#define		bCCKRxHPAGCFinal          		0x1c00
+#define		bCCKRxFalseAlarmEnable    	0x8000
+#define		bCCKFACounterFreeze       	0x4000
+#define		bCCKTxPathSel             		0x10000000
+#define		bCCKDefaultRxPath         		0xc000000
+#define		bCCKOptionRxPath          		0x3000000
+
+
+//
+// 5. PageC(0xC00)
+//
+#define		bNumOfSTF                			0x3	// Useless
+#define		bShift_L                 			0xc0
+#define		bGI_TH                   			0xc
+#define		bRxPathA                 			0x1
+#define		bRxPathB                 			0x2
+#define		bRxPathC                 			0x4
+#define		bRxPathD                 			0x8
+#define		bTxPathA                 			0x1
+#define		bTxPathB                 			0x2
+#define		bTxPathC                 			0x4
+#define		bTxPathD                 			0x8
+#define		bTRSSIFreq               			0x200
+#define		bADCBackoff              			0x3000
+#define		bDFIRBackoff             		0xc000
+#define		bTRSSILatchPhase         		0x10000
+#define		bRxIDCOffset             			0xff
+#define		bRxQDCOffset             		0xff00
+#define		bRxDFIRMode              		0x1800000
+#define		bRxDCNFType              		0xe000000
+#define		bRXIQImb_A               		0x3ff
+#define		bRXIQImb_B               		0xfc00
+#define		bRXIQImb_C               		0x3f0000
+#define		bRXIQImb_D               		0xffc00000
+#define		bDC_dc_Notch             		0x60000
+#define		bRxNBINotch              		0x1f000000
+#define		bPD_TH                   			0xf
+#define		bPD_TH_Opt2              		0xc000
+#define		bPWED_TH                 			0x700
+#define		bIfMF_Win_L              		0x800
+#define		bPD_Option               			0x1000
+#define		bMF_Win_L                			0xe000
+#define		bBW_Search_L             		0x30000
+#define		bwin_enh_L               			0xc0000
+#define		bBW_TH                   			0x700000
+#define		bED_TH2                  			0x3800000
+#define		bBW_option               			0x4000000
+#define		bRatio_TH                			0x18000000
+#define		bWindow_L                			0xe0000000
+#define		bSBD_Option              			0x1
+#define		bFrame_TH                			0x1c
+#define		bFS_Option               			0x60
+#define		bDC_Slope_check          		0x80
+#define		bFGuard_Counter_DC_L     	0xe00
+#define		bFrame_Weight_Short      	0x7000
+#define		bSub_Tune                			0xe00000
+#define		bFrame_DC_Length         		0xe000000
+#define		bSBD_start_offset        		0x30000000
+#define		bFrame_TH_2              		0x7
+#define		bFrame_GI2_TH            		0x38
+#define		bGI2_Sync_en             		0x40
+#define		bSarch_Short_Early       		0x300
+#define		bSarch_Short_Late        		0xc00
+#define		bSarch_GI2_Late          		0x70000
+#define		bCFOAntSum               		0x1
+#define		bCFOAcc                  			0x2
+#define		bCFOStartOffset          		0xc
+#define		bCFOLookBack             		0x70
+#define		bCFOSumWeight            		0x80
+#define		bDAGCEnable              		0x10000
+#define		bTXIQImb_A               		0x3ff
+#define		bTXIQImb_B               		0xfc00
+#define		bTXIQImb_C               		0x3f0000
+#define		bTXIQImb_D               		0xffc00000
+#define		bTxIDCOffset             			0xff
+#define		bTxQDCOffset             		0xff00
+#define		bTxDFIRMode              		0x10000
+#define		bTxPesudoNoiseOn         		0x4000000
+#define		bTxPesudoNoise_A         		0xff
+#define		bTxPesudoNoise_B         		0xff00
+#define		bTxPesudoNoise_C         		0xff0000
+#define		bTxPesudoNoise_D         		0xff000000
+#define		bCCADropOption           		0x20000
+#define		bCCADropThres            		0xfff00000
+#define		bEDCCA_H                 			0xf
+#define		bEDCCA_L                 			0xf0
+#define		bLambda_ED         		      0x300
+#define		bRxInitialGain				0x7f
+#define		bRxAntDivEn					0x80
+#define		bRxAGCAddressForLNA		0x7f00
+#define		bRxHighPowerFlow			0x8000
+#define		bRxAGCFreezeThres			0xc0000
+#define		bRxFreezeStep_AGC1		0x300000
+#define		bRxFreezeStep_AGC2		0xc00000
+#define		bRxFreezeStep_AGC3		0x3000000
+#define		bRxFreezeStep_AGC0		0xc000000
+#define		bRxRssi_Cmp_En				0x10000000
+#define		bRxQuickAGCEn				0x20000000
+#define		bRxAGCFreezeThresMode		0x40000000
+#define		bRxOverFlowCheckType		0x80000000
+#define		bRxAGCShift					0x7f
+#define		bTRSW_Tri_Only				0x80
+#define		bPowerThres				0x300
+#define		bRxAGCEn					0x1
+#define		bRxAGCTogetherEn			0x2
+#define		bRxAGCMin					0x4
+#define		bRxHP_Ini					0x7
+#define		bRxHP_TRLNA				0x70
+#define		bRxHP_RSSI					0x700
+#define		bRxHP_BBP1					0x7000
+#define		bRxHP_BBP2					0x70000
+#define		bRxHP_BBP3					0x700000
+#define		bRSSI_H						0x7f0000     //the threshold for high power
+#define		bRSSI_Gen					0x7f000000   //the threshold for ant diversity
+#define		bRxSettle_TRSW				0x7
+#define		bRxSettle_LNA				0x38
+#define		bRxSettle_RSSI				0x1c0
+#define		bRxSettle_BBP				0xe00
+#define		bRxSettle_RxHP				0x7000
+#define		bRxSettle_AntSW_RSSI		0x38000
+#define		bRxSettle_AntSW			0xc0000
+#define		bRxProcessTime_DAGC		0x300000
+#define		bRxSettle_HSSI				0x400000
+#define		bRxProcessTime_BBPPW		0x800000
+#define		bRxAntennaPowerShift		0x3000000
+#define		bRSSITableSelect			0xc000000
+#define		bRxHP_Final					0x7000000
+#define		bRxHTSettle_BBP				0x7
+#define		bRxHTSettle_HSSI			0x8
+#define		bRxHTSettle_RxHP			0x70
+#define		bRxHTSettle_BBPPW			0x80
+#define		bRxHTSettle_Idle			0x300
+#define		bRxHTSettle_Reserved		0x1c00
+#define		bRxHTRxHPEn				0x8000
+#define		bRxHTAGCFreezeThres		0x30000
+#define		bRxHTAGCTogetherEn		0x40000
+#define		bRxHTAGCMin				0x80000
+#define		bRxHTAGCEn					0x100000
+#define		bRxHTDAGCEn				0x200000
+#define		bRxHTRxHP_BBP				0x1c00000
+#define		bRxHTRxHP_Final			0xe0000000
+#define		bRxPWRatioTH				0x3
+#define		bRxPWRatioEn				0x4
+#define		bRxMFHold					0x3800
+#define		bRxPD_Delay_TH1			0x38
+#define		bRxPD_Delay_TH2			0x1c0
+#define		bRxPD_DC_COUNT_MAX		0x600
+//#define bRxMF_Hold               0x3800
+#define		bRxPD_Delay_TH				0x8000
+#define		bRxProcess_Delay			0xf0000
+#define		bRxSearchrange_GI2_Early	0x700000
+#define		bRxFrame_Guard_Counter_L	0x3800000
+#define		bRxSGI_Guard_L				0xc000000
+#define		bRxSGI_Search_L			0x30000000
+#define		bRxSGI_TH					0xc0000000
+#define		bDFSCnt0					0xff
+#define		bDFSCnt1					0xff00
+#define		bDFSFlag					0xf0000
+#define		bMFWeightSum				0x300000
+#define		bMinIdxTH					0x7f000000
+#define		bDAFormat					0x40000
+#define		bTxChEmuEnable			0x01000000
+#define		bTRSWIsolation_A			0x7f
+#define		bTRSWIsolation_B			0x7f00
+/*
+#define		bTRSWIsolation_C			0x7f0000
+#define		bTRSWIsolation_D			0x7f000000
+*/
+#define		bExtLNAGain					0x7c00
+
+
+//
+// 6. PageE(0xE00)
+//
+#define		bSTBCEn                  			0x4	// Useless
+#define		bAntennaMapping			0x10
+#define		bNss						0x20
+#define		bCFOAntSumD				0x200
+#define		bOFDMDisPwsavTx				0x400000
+#define		bPHYCounterReset			0x8000000
+#define		bCFOReportGet				0x4000000
+#define		bOFDMContinueTx			0x10000000
+#define		bOFDMSingleCarrier			0x20000000
+#define		bOFDMSingleTone			0x40000000
+/*
+#define bRxPath1                 0x01
+#define bRxPath2                 0x02
+#define bRxPath3                 0x04
+#define bRxPath4                 0x08
+#define bTxPath1                 0x10
+#define bTxPath2                 0x20
+*/
+#define		bHTDetect					0x100
+#define		bCFOEn						0x10000
+#define		bCFOValue					0xfff00000
+#define		bSigTone_Re				0x3f
+#define		bSigTone_Im				0x7f00
+#define		bCounter_CCA				0xffff
+#define		bCounter_ParityFail			0xffff0000
+#define		bCounter_RateIllegal			0xffff
+#define		bCounter_CRC8Fail			0xffff0000
+#define		bCounter_MCSNoSupport		0xffff
+#define		bCounter_FastSync			0xffff
+#define		bShortCFO					0xfff
+#define		bShortCFOTLength			12   //total
+#define		bShortCFOFLength			11   //fraction
+#define		bLongCFO					0x7ff
+#define		bLongCFOTLength			11
+#define		bLongCFOFLength			11
+#define		bTailCFO					0x1fff
+#define		bTailCFOTLength				13
+#define		bTailCFOFLength				12
+#define		bmax_en_pwdB				0xffff
+#define		bCC_power_dB				0xffff0000
+#define		bnoise_pwdB				0xffff
+#define		bPowerMeasTLength			10
+#define		bPowerMeasFLength			3
+#define		bRx_HT_BW					0x1
+#define		bRxSC						0x6
+#define		bRx_HT						0x8
+#define		bNB_intf_det_on				0x1
+#define		bIntf_win_len_cfg			0x30
+#define		bNB_Intf_TH_cfg				0x1c0
+#define		bRFGain						0x3f
+#define		bTableSel					0x40
+#define		bTRSW						0x80
+#define		bRxSNR_A					0xff
+#define		bRxSNR_B					0xff00
+/*
+#define		bRxSNR_C					0xff0000
+#define		bRxSNR_D					0xff000000
+*/
+#define		bSNREVMTLength				8
+#define		bSNREVMFLength				1
+#define		bCSI1st						0xff
+#define		bCSI2nd						0xff00
+#define		bRxEVM1st					0xff0000
+#define		bRxEVM2nd					0xff000000
+#define		bSIGEVM					0xff
+#define		bPWDB						0xff00
+#define		bSGIEN						0x10000
+
+#define		bSFactorQAM1				0xf	// Useless
+#define		bSFactorQAM2				0xf0
+#define		bSFactorQAM3				0xf00
+#define		bSFactorQAM4				0xf000
+#define		bSFactorQAM5				0xf0000
+#define		bSFactorQAM6				0xf0000
+#define		bSFactorQAM7				0xf00000
+#define		bSFactorQAM8				0xf000000
+#define		bSFactorQAM9				0xf0000000
+#define		bCSIScheme					0x100000
+
+#define		bNoiseLvlTopSet				0x3	// Useless
+#define		bChSmooth					0x4
+#define		bChSmoothCfg1				0x38
+#define		bChSmoothCfg2				0x1c0
+#define		bChSmoothCfg3				0xe00
+#define		bChSmoothCfg4				0x7000
+#define		bMRCMode					0x800000
+#define		bTHEVMCfg					0x7000000
+
+#define		bLoopFitType				0x1	// Useless
+#define		bUpdCFO					0x40
+#define		bUpdCFOOffData				0x80
+#define		bAdvUpdCFO					0x100
+#define		bAdvTimeCtrl				0x800
+#define		bUpdClko					0x1000
+#define		bFC							0x6000
+#define		bTrackingMode				0x8000
+#define		bPhCmpEnable				0x10000
+#define		bUpdClkoLTF				0x20000
+#define		bComChCFO					0x40000
+#define		bCSIEstiMode				0x80000
+#define		bAdvUpdEqz					0x100000
+#define		bUChCfg						0x7000000
+#define		bUpdEqz					0x8000000
+
+#define		bTxAGCRate18_06			0x7f7f7f7f	// Useless
+#define		bTxAGCRate54_24			0x7f7f7f7f
+#define		bTxAGCRateMCS32			0x7f
+#define		bTxAGCRateCCK				0x7f00
+#define		bTxAGCRateMCS3_MCS0		0x7f7f7f7f
+#define		bTxAGCRateMCS7_MCS4		0x7f7f7f7f
+#define		bTxAGCRateMCS11_MCS8		0x7f7f7f7f
+#define		bTxAGCRateMCS15_MCS12	0x7f7f7f7f
+
+//Rx Pseduo noise
+#define		bRxPesudoNoiseOn			0x20000000	// Useless
+#define		bRxPesudoNoise_A			0xff
+#define		bRxPesudoNoise_B			0xff00
+/*
+#define		bRxPesudoNoise_C			0xff0000
+#define		bRxPesudoNoise_D			0xff000000
+*/
+#define		bPesudoNoiseState_A		0xffff
+#define		bPesudoNoiseState_B		0xffff0000
+/*
+#define		bPesudoNoiseState_C		0xffff
+#define		bPesudoNoiseState_D		0xffff0000
+*/
+
+
+//
+//7. RF Register
+//
+//Zebra1
+#define		bZebra1_HSSIEnable			0x8		// Useless
+#define		bZebra1_TRxControl			0xc00
+#define		bZebra1_TRxGainSetting		0x07f
+#define		bZebra1_RxCorner			0xc00
+#define		bZebra1_TxChargePump		0x38
+#define		bZebra1_RxChargePump		0x7
+#define		bZebra1_ChannelNum		0xf80
+#define		bZebra1_TxLPFBW			0x400
+#define		bZebra1_RxLPFBW			0x600
+
+//Zebra4
+#define		bRTL8256RegModeCtrl1		0x100	// Useless
+#define		bRTL8256RegModeCtrl0		0x40
+#define		bRTL8256_TxLPFBW			0x18
+#define		bRTL8256_RxLPFBW			0x600
+
+//RTL8258
+#define		bRTL8258_TxLPFBW			0xc	// Useless
+#define		bRTL8258_RxLPFBW			0xc00
+#define		bRTL8258_RSSILPFBW		0xc0
+
+
+//
+// Other Definition
+//
+//byte endable for sb_write
+#define		bByte0						0x1	// Useless
+#define		bByte1						0x2
+#define		bByte2						0x4
+#define		bByte3						0x8
+#define		bWord0						0x3
+#define		bWord1						0xc
+#define		bDWord						0xf
+
+//for PutRegsetting & GetRegSetting BitMask
+#define		bMaskByte0					0xff	// Reg 0xc50 rOFDM0_XAAGCCore~0xC6f
+#define		bMaskByte1					0xff00
+#define		bMaskByte2					0xff0000
+#define		bMaskByte3					0xff000000
+#define		bMaskHWord				0xffff0000
+#define		bMaskLWord					0x0000ffff
+#define		bMaskDWord				0xffffffff
+#define		bMaskH4Bits				  0xf0000000
+#define		bMaskH3Bytes			  	0xffffff00	
+#define 	bMaskOFDM_D				  0xffc00000
+#define		bMaskCCK				  0x3f3f3f3f
+
+
+//for PutRFRegsetting & GetRFRegSetting BitMask
+#define		bMask12Bits					0xfff	// RF Reg mask bits
+#define		bMask20Bits					0xfffff	// RF Reg mask bits T65 RF
+
+#define		bEnable						0x1	// Useless
+#define		bDisable					0x0
+
+#define		LeftAntenna					0x0	// Useless
+#define		RightAntenna				0x1
+
+#define		tCheckTxStatus				500   //500ms // Useless
+#define		tUpdateRxCounter			100   //100ms
+
+#define		rateCCK						0	// Useless
+#define		rateOFDM					1
+#define		rateHT						2
+
+//define Register-End
+#define		bPMAC_End					0x1ff	// Useless
+#define		bFPGAPHY0_End				0x8ff
+#define		bFPGAPHY1_End				0x9ff
+#define		bCCKPHY0_End				0xaff
+#define		bOFDMPHY0_End				0xcff
+#define		bOFDMPHY1_End				0xdff
+/*
+//define max debug item in each debug page
+#define bMaxItem_FPGA_PHY0        0x9
+#define bMaxItem_FPGA_PHY1        0x3
+#define bMaxItem_PHY_11B          0x16
+#define bMaxItem_OFDM_PHY0        0x29
+#define bMaxItem_OFDM_PHY1        0x0
+*/
+#define		bPMACControl				0x0		// Useless
+#define		bWMACControl				0x1
+#define		bWNICControl				0x2
+
+#define		PathA						0x0	// Useless
+#define		PathB						0x1
+/*
+#define		PathC						0x2
+#define		PathD						0x3
+*/
+
+
+#define 	REG_SYS_FUNC_EN				0x2
+#define 	REG_AFE_PLL_CTRL				0x28
+#define 	REG_RF_CTRL					0x1f
+#define 	REG_LDOHCI12_CTRL				0x22
+#define 	REG_AFE_XTAL_CTRL				0x24
+#define		RF_T_METER					0x24	
+#define 	REG_MCUFWDL					0x80
+#define 	REG_HMETFR					0x01CC
+
+#define		RF_T_METER_92D					0x42
+
+/*--------------------------Define Parameters-------------------------------*/
+//#endif
+
+#endif // _8192CD_PHYREG_H_
+
diff --git a/drivers/net/wireless/rtl8192cd/8192cd_proc.c b/drivers/net/wireless/rtl8192cd/8192cd_proc.c
index 7f6b04b..e96dd9a 100644
--- a/drivers/net/wireless/rtl8192cd/8192cd_proc.c
+++ b/drivers/net/wireless/rtl8192cd/8192cd_proc.c
@@ -27,8 +27,8 @@
 #include "./8192cd_headers.h"
 
 #ifdef CONFIG_RTK_MESH
-#include "./mesh_ext/mesh_route.h"
-#include "./mesh_ext/mesh_util.h"
+#include "../mesh_ext/mesh_route.h"
+#include "../mesh_ext/mesh_util.h"
 #endif // CONFIG_RTK_MESH
 #ifdef _INCLUDE_PROC_FS_
 #include <asm/uaccess.h>
@@ -164,6 +164,8 @@ static int rtl8192cd_proc_mib_staconfig(char *buf, char **start, off_t offset,
 			priv->pmib->dot11StationConfigEntry.protectionDisabled, "%d");
 	PRINT_SINGL_ARG("    olbcDetectDisabled: ",
 			priv->pmib->dot11StationConfigEntry.olbcDetectDisabled, "%d");
+	PRINT_SINGL_ARG("    nmlscDetectDisabled: ",
+			priv->pmib->dot11StationConfigEntry.nmlscDetectDisabled, "%d");
 	PRINT_SINGL_ARG("    legacySTADeny: ",
 			priv->pmib->dot11StationConfigEntry.legacySTADeny, "%d");
 #ifdef CLIENT_MODE
@@ -223,6 +225,10 @@ static int rtl8192cd_proc_mib_auth(char *buf, char **start, off_t offset,
 			priv->pmib->dot118021xAuthEntry.dot118021xDefaultPort, "%d");
 	PRINT_SINGL_ARG("    dot118021xcontrolport: ",
 			priv->pmib->dot118021xAuthEntry.dot118021xcontrolport, "%d");
+	PRINT_ONE("  	RADIUS Accounting...", "%s", 1);
+	PRINT_SINGL_ARG("    	Enabled: ",priv->pmib->dot118021xAuthEntry.acct_enabled, "%d");	
+	PRINT_SINGL_ARG("    	Idle period to leave STA: ",priv->pmib->dot118021xAuthEntry.acct_timeout_period, "%d min(s)");
+	PRINT_SINGL_ARG("    	Idle throughput to leave STA: ", priv->pmib->dot118021xAuthEntry.acct_timeout_throughput, "%d Kbpm");
 
 	PRINT_ONE("  Dot11RsnIE...", "%s", 1);
 	PRINT_ARRAY_ARG("    rsnie: ",
@@ -300,7 +306,7 @@ static int rtl8192cd_proc_mib_gkeytbl(char *buf, char **start, off_t offset,
 	unsigned char *ptr;
 
 	PRINT_ONE("  Dot11GroupKeysTable...", "%s", 1);
-#ifdef CONFIG_RTL_WAPI_SUPPORT	
+#ifdef CONFIG_RTL_WAPI_SUPPORT
 	if (priv->pmib->wapiInfo.wapiType!=wapiDisable)
 	{
 		PRINT_SINGL_ARG("    dot11Privacy: ",
@@ -380,6 +386,15 @@ static int rtl8192cd_proc_mib_operation(char *buf, char **start, off_t offset,
 	PRINT_SINGL_ARG("    qos_enable: ", priv->pmib->dot11QosEntry.dot11QosEnable, "%d");
 #ifdef WMM_APSD
 	PRINT_SINGL_ARG("    apsd_enable: ", priv->pmib->dot11QosEntry.dot11QosAPSD, "%d");
+#ifdef CLIENT_MODE
+	if ((OPMODE & WIFI_STATION_STATE) && QOS_ENABLE && APSD_ENABLE) {
+		PRINT_SINGL_ARG("        uapsd_assoc: ", priv->uapsd_assoc, "%d");
+		PRINT_SINGL_ARG("        UAPSD_AC_VO: ", priv->pmib->dot11QosEntry.UAPSD_AC_VO, "%d");
+		PRINT_SINGL_ARG("        UAPSD_AC_VI: ", priv->pmib->dot11QosEntry.UAPSD_AC_VI, "%d");
+		PRINT_SINGL_ARG("        UAPSD_AC_BE: ", priv->pmib->dot11QosEntry.UAPSD_AC_BE, "%d");
+		PRINT_SINGL_ARG("        UAPSD_AC_BK: ", priv->pmib->dot11QosEntry.UAPSD_AC_BK, "%d");
+	}
+#endif
 #endif
 #endif
 
@@ -463,8 +478,8 @@ static int rtl8192cd_proc_mib_rf(char *buf, char **start, off_t offset,
 		PRINT_ARRAY_ARG("    pwrdiff5GOFDM: ", priv->pmib->dot11RFEntry.pwrdiff5GOFDM, "%02x", MAX_5G_CHANNEL_NUM);
 	}
 	//} else
-#endif		
-	{	
+#endif
+	{
 		PRINT_ARRAY_ARG("    pwrlevelCCK_A: ", priv->pmib->dot11RFEntry.pwrlevelCCK_A, "%02x", MAX_2G_CHANNEL_NUM);
 		PRINT_ARRAY_ARG("    pwrlevelCCK_B: ", priv->pmib->dot11RFEntry.pwrlevelCCK_B, "%02x", MAX_2G_CHANNEL_NUM);
 		PRINT_ARRAY_ARG("    pwrlevelHT40_1S_A: ", priv->pmib->dot11RFEntry.pwrlevelHT40_1S_A, "%02x", MAX_2G_CHANNEL_NUM);
@@ -523,51 +538,61 @@ static int rtl8192cd_proc_mib_rf(char *buf, char **start, off_t offset,
 		break;
 	}
 	PRINT_SINGL_ARG("    MIMO_TR_mode: ", tmpbuf, "%s");
-	
+
 #ifdef CONFIG_RTL_92D_SUPPORT
- if (GET_CHIP_VER(priv) == VERSION_8192D) {
-	PRINT_SINGL_ARG("    phyBandSelect: ", priv->pmib->dot11RFEntry.phyBandSelect, "%d");
+	 if (GET_CHIP_VER(priv) == VERSION_8192D) {
+		PRINT_SINGL_ARG("    phyBandSelect: ", priv->pmib->dot11RFEntry.phyBandSelect, "%d");
 
-	switch (priv->pmib->dot11RFEntry.macPhyMode) {
-	case SINGLEMAC_SINGLEPHY:
-		sprintf(tmpbuf, "SMSP");
-		break;
-	case DUALMAC_SINGLEPHY:
-		sprintf(tmpbuf, "DMSP");
-		break;
-	case DUALMAC_DUALPHY:
-		sprintf(tmpbuf, "DMDP");
-		break;
-	default:
-		sprintf(tmpbuf, "unknown");
-		break;
-	}
+		switch (priv->pmib->dot11RFEntry.macPhyMode) {
+		case SINGLEMAC_SINGLEPHY:
+			sprintf(tmpbuf, "SMSP");
+			break;
+		case DUALMAC_SINGLEPHY:
+			sprintf(tmpbuf, "DMSP");
+			break;
+		case DUALMAC_DUALPHY:
+			sprintf(tmpbuf, "DMDP");
+			break;
+		default:
+			sprintf(tmpbuf, "unknown");
+			break;
+		}
  	}
 	PRINT_SINGL_ARG("    macPhyMode: ", tmpbuf, "%s");
 #endif
 
+#ifdef CONFIG_RTL_92C_SUPPORT
 	if (GET_CHIP_VER(priv) == VERSION_8188C) {
 		if(IS_UMC_B_CUT_88C(priv))
 			sprintf(tmpbuf, "RTL6195B");
 		else if(IS_88RE(priv))
 			sprintf(tmpbuf, "RTL8188R");
 		else
-		sprintf(tmpbuf, "RTL8188C");
-//		PRINT_SINGL_ARG("    chipVersion: ", "RTL8188C", "%s");
+			sprintf(tmpbuf, "RTL8188C");
+	} else if (GET_CHIP_VER(priv) == VERSION_8192C){
+		sprintf(tmpbuf, "RTL8192C");
+	}
+
+	if ((GET_CHIP_VER(priv)==VERSION_8192C) || (GET_CHIP_VER(priv)==VERSION_8188C)) {
+		if (IS_TEST_CHIP(priv))
+			strcat(tmpbuf, "t");
+		else
+			strcat(tmpbuf, "n");
 	}
+#endif
 #ifdef CONFIG_RTL_92D_SUPPORT
-	else if (GET_CHIP_VER(priv) == VERSION_8192D) {
+	if (GET_CHIP_VER(priv) == VERSION_8192D)
 		sprintf(tmpbuf, "RTL8192D");
-	}
 #endif
-	else {
-		sprintf(tmpbuf, "RTL8192C");
-//		PRINT_SINGL_ARG("    chipVersion: ", "RTL8192C", "%s");
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv) == VERSION_8188E) {
+		sprintf(tmpbuf, "RTL8188E");
+#ifdef SUPPORT_RTL8188E_TC
+		if (IS_TEST_CHIP(priv))
+			strcat(tmpbuf, "t");
+#endif
 	}
-	if (IS_TEST_CHIP(priv))
-		strcat(tmpbuf, "t");
-	else
-		strcat(tmpbuf, "n");
+#endif
 
 	if(IS_UMC_A_CUT(priv))
 		strcat(tmpbuf, "u");
@@ -575,30 +600,31 @@ static int rtl8192cd_proc_mib_rf(char *buf, char **start, off_t offset,
 	PRINT_SINGL_ARG("    chipVersion: ", tmpbuf, "%s");
 
 #ifdef EN_EFUSE
-	if(priv->pmib->efuseEntry.enable_efuse)	{	
+	if(priv->pmib->efuseEntry.enable_efuse)	{
 		int k;
 		PRINT_SINGL_ARG("    autoload fail: ", priv->AutoloadFailFlag, "%d");
-		PRINT_SINGL_ARG("    efuse used bytes: ", priv->EfuseUsedBytes, "%d");		
-		
+		PRINT_SINGL_ARG("    efuse used bytes: ", priv->EfuseUsedBytes, "%d");
+
 		PRINT_ONE("efuse init map...", "%s", 1);
 		for(k=0; k<EFUSE_MAP_LEN; k+=16)
 			PRINT_ARRAY_ARG("    ", (priv->EfuseMap[EFUSE_INIT_MAP]+k), "%02x", 16);
-		PRINT_ONE("efuse modify map...", "%s", 1);		
+		PRINT_ONE("efuse modify map...", "%s", 1);
 		for(k=0; k<EFUSE_MAP_LEN; k+=16)
-			PRINT_ARRAY_ARG("    ", (priv->EfuseMap[EFUSE_MODIFY_MAP]+k), "%02x", 16);		
+			PRINT_ARRAY_ARG("    ", (priv->EfuseMap[EFUSE_MODIFY_MAP]+k), "%02x", 16);
 	}
 #endif
 
 #ifdef SW_ANT_SWITCH
-	PRINT_SINGL_ARG("    SW Ant switch enable: ", (priv->pshare->rf_ft_var.antSw_enable ? "enable" : "disable"), "%s");
+	PRINT_SINGL_ARG("    SW Ant switch enable: ", (SW_DIV_ENABLE ? "enable" : "disable"), "%s");
 	PRINT_SINGL_ARG("    SW Diversity Antenna : ", priv->pshare->DM_SWAT_Table.CurAntenna, "%d");
 #endif
 
 #ifdef HW_ANT_SWITCH
-	PRINT_SINGL_ARG("    HW Ant switch enable: ", (priv->pshare->rf_ft_var.antHw_enable ? "enable" : "disable"), "%s");
+	PRINT_SINGL_ARG("    HW Ant switch enable: ", (HW_DIV_ENABLE ? "enable" : "disable"), "%s");
 	PRINT_SINGL_ARG("    RxIdle Antenna : ", (priv->pshare->rf_ft_var.CurAntenna==0 ? 2 : 1), "%d");
 #endif
 
+	PRINT_SINGL_ARG("    tx2path: ", priv->pmib->dot11RFEntry.tx2path, "%d");
 	PRINT_SINGL_ARG("    txbf: ", priv->pmib->dot11RFEntry.txbf, "%d");
 
 #ifdef RTL8192D_INT_PA
@@ -652,6 +678,10 @@ static int rtl8192cd_proc_mib_bssdesc(char *buf, char **start, off_t offset,
 	PRINT_SINGL_ARG("    bsstype: ", priv->pmib->dot11Bss.bsstype, "%x");
 	PRINT_SINGL_ARG("    beacon_prd: ", priv->pmib->dot11Bss.beacon_prd, "%d");
 	PRINT_SINGL_ARG("    dtim_prd: ", priv->pmib->dot11Bss.dtim_prd, "%d");
+#ifdef CLIENT_MODE
+	if (OPMODE & WIFI_STATION_STATE)
+		PRINT_SINGL_ARG("    client mode aid: ", priv->aid, "%d");
+#endif
 	PRINT_ARRAY_ARG("    t_stamp(hex): ", priv->pmib->dot11Bss.t_stamp, "%08x", 2);
 	PRINT_SINGL_ARG("    ibss_par.atim_win: ", priv->pmib->dot11Bss.ibss_par.atim_win, "%d");
 	PRINT_SINGL_ARG("    capability(hex): ", priv->pmib->dot11Bss.capability, "%02x");
@@ -775,6 +805,7 @@ static int rtl8192cd_proc_mib_brext(char *buf, char **start, off_t offset,
 	PRINT_SINGL_ARG("    dhcp_bcst_disable: ", priv->pmib->ethBrExtInfo.dhcp_bcst_disable, "%d");
 	PRINT_SINGL_ARG("    addPPPoETag: ", priv->pmib->ethBrExtInfo.addPPPoETag, "%d");
 	PRINT_SINGL_ARG("    nat25sc_disable: ", priv->pmib->ethBrExtInfo.nat25sc_disable, "%d");
+	PRINT_ARRAY_ARG("    ukpro_mac: ", priv->ukpro_mac, "%02x", MACADDRLEN);
 
 	return pos;
 }
@@ -809,7 +840,7 @@ static int rtl8192cd_proc_txdesc_info(char *buf, char **start, off_t offset,
 		size = sprintf(buf+len, "  head/tail: %3d/%-3d  DW0      DW1      DW2      DW3      DW4      DW5\n",
 			get_txhead(phw, q_num), get_txtail(phw, q_num));
 		CHECK_LEN;
-		for (i=0; i<NUM_TX_DESC; i++) {
+		for (i=0; i<CURRENT_NUM_TX_DESC; i++) {
 			txdescptr = (unsigned long *)(get_txdesc(phw, q_num) + i);
 			size = sprintf(buf+len, "      txdesc%d[%3d]: %.8x %.8x %.8x %.8x %.8x  %.8x\n", q_num, i,
 					(UINT)get_desc(txdescptr[0]), (UINT)get_desc(txdescptr[1]),
@@ -927,7 +958,7 @@ static int rtl8192cd_proc_desc_info(char *buf, char **start, off_t offset,
 	PRINT_ONE((UINT)phw->rx_ring_addr, "0x%.8x", 1);
 	PRINT_ONE("      RDSAR: ", "%s", 0);
 	PRINT_ONE((UINT)RTL_R32(RX_DESA), "0x%.8x", 0);
-	
+
 #ifdef DELAY_REFILL_RX_BUF
 	PRINT_ONE("  cur_rx/cur_rx_refill: ", "%s", 0);
 	PRINT_ONE((UINT)phw->cur_rx, "%d/", 0);
@@ -936,7 +967,7 @@ static int rtl8192cd_proc_desc_info(char *buf, char **start, off_t offset,
 	PRINT_ONE("  cur_rx: ", "%s", 0);
 	PRINT_ONE((UINT)phw->cur_rx, "%d", 1);
 #endif
-	
+
 	PRINT_ONE("    queue 0:", "%s", 1);
 	PRINT_ONE("      tx_desc0/physical: ", "%s", 0);
 	PRINT_ONE((UINT)phw->tx_desc0, "0x%.8x/", 0);
@@ -1134,8 +1165,8 @@ static int rtl8192cd_proc_mib_11n(char *buf, char **start, off_t offset,
 #ifdef CLIENT_MODE
 		if (OPMODE & WIFI_STATION_STATE)
 			PRINT_SINGL_ARG("    coexist_connection: ", priv->coexist_connection, "%d");
-			
-		if ((OPMODE & WIFI_AP_STATE) || 
+
+		if ((OPMODE & WIFI_AP_STATE) ||
 			((OPMODE & WIFI_STATION_STATE) && priv->coexist_connection))
 #endif
 			PRINT_SINGL_ARG("    bg_ap_timeout: ", priv->bg_ap_timeout, "%d");
@@ -1149,10 +1180,18 @@ static int rtl8192cd_proc_mib_11n(char *buf, char **start, off_t offset,
 #endif
 		if (OPMODE & WIFI_AP_STATE) {
 			PRINT_SINGL_ARG("    force_20_sta: ", priv->force_20_sta, "0x%08x");
+#ifdef CONFIG_RTL_88E_SUPPORT
+			if (GET_CHIP_VER(priv) == VERSION_8188E)
+				PRINT_SINGL_ARG("    force_20_sta_88e_hw_ext: ", priv->force_20_sta_88e_hw_ext, "0x%08x");	
+#endif
 #ifdef STA_EXT
 			PRINT_SINGL_ARG("    force_20_sta_ext: ", priv->force_20_sta_ext, "0x%08x");
 #endif
 			PRINT_SINGL_ARG("    switch_20_sta: ", priv->switch_20_sta, "0x%08x");
+#ifdef CONFIG_RTL_88E_SUPPORT
+			if (GET_CHIP_VER(priv) == VERSION_8188E)
+				PRINT_SINGL_ARG("    switch_20_sta_88e_hw_ext: ", priv->switch_20_sta_88e_hw_ext, "0x%08x");	
+#endif
 #ifdef STA_EXT
 			PRINT_SINGL_ARG("    switch_20_sta_ext: ", priv->switch_20_sta_ext, "0x%08x");
 #endif
@@ -1160,6 +1199,8 @@ static int rtl8192cd_proc_mib_11n(char *buf, char **start, off_t offset,
 	}
 #endif
 
+	PRINT_SINGL_ARG("    txnoack: ", priv->pmib->dot11nConfigEntry.dot11nTxNoAck, "%d");
+
 	if (priv->ht_cap_len) {
 		unsigned char *pbuf = (unsigned char *)&priv->ht_cap_buf;
 		PRINT_ARRAY_ARG("    ht_cap: ", pbuf, "%02x", priv->ht_cap_len);
@@ -1175,7 +1216,8 @@ static int rtl8192cd_proc_mib_11n(char *buf, char **start, off_t offset,
 		PRINT_ONE("    ht_ie: none", "%s", 1);
 	}
 
-	PRINT_SINGL_ARG("    legacy_obss_to: ", priv->ht_legacy_obss_to, "%d");
+	PRINT_SINGL_ARG("    legacy_obss_to: ", priv->ht_legacy_obss_to, "%d");	
+	PRINT_SINGL_ARG("    nomember_legacy_sta_to: ", priv->ht_nomember_legacy_sta_to, "%d");
 	PRINT_SINGL_ARG("    legacy_sta_num: ", priv->ht_legacy_sta_num, "%d");
 	PRINT_SINGL_ARG("    11nProtection: ", priv->ht_protection, "%d");
 //	PRINT_SINGL_ARG("    has_2r_sta: ", priv->pshare->has_2r_sta, "0x%08x");
@@ -1330,7 +1372,7 @@ static int rtl8192cd_proc_phypara_file_write(struct file *file, const char *buff
 		else if (!strcmp(tmp, "PHY_REG_PG_hp.txt")) {
 			priv->phypara_file_start = data_PHY_REG_PG_hp_start;
 			priv->phypara_file_end = data_PHY_REG_PG_hp_end;
-		}		
+		}
 #endif
 		else {
 			panic_printk("No file of \"%s\"\n", tmp);
@@ -1390,38 +1432,38 @@ static int rtl8192cd_proc_SSR_read(char *buf, char **start, off_t offset,
 
 	//wait SiteSurvey completed
 	if(priv->ss_req_ongoing)	{
-		PRINT_ONE("waitting", "%s", 1);		
+		PRINT_ONE("waitting", "%s", 1);
 	}else{
 		PRINT_ONE(" SiteSurvey result : ", "%s", 1);
-		PRINT_ONE("    ====================", "%s", 1);		
+		PRINT_ONE("    ====================", "%s", 1);
 		if(priv->site_survey.count_backup==0){
-			PRINT_ONE("none", "%s", 1);	
+			PRINT_ONE("none", "%s", 1);
 		}else{
-			for(i1=0; i1<priv->site_survey.count_backup ;i1++){			
-			
-				memcpy(tmp,priv->site_survey.bss_backup[i1].bssid,MACADDRLEN);			
+			for(i1=0; i1<priv->site_survey.count_backup ;i1++){
+
+				memcpy(tmp,priv->site_survey.bss_backup[i1].bssid,MACADDRLEN);
 				/*
 				panic_printk("Mac=%02X%02X%02X:%02X%02X%02X ;Channel=%02d ;SSID:%s  \n",
-					tmp[0],tmp[1],tmp[2],tmp[3],tmp[4],tmp[5]				
-					,priv->site_survey.bss_backup[i1].channel				
-					,priv->site_survey.bss_backup[i1].ssid			
-					);				
+					tmp[0],tmp[1],tmp[2],tmp[3],tmp[4],tmp[5]
+					,priv->site_survey.bss_backup[i1].channel
+					,priv->site_survey.bss_backup[i1].ssid
+					);
 				*/
 				PRINT_ARRAY_ARG("    HwAddr: ",	tmp, "%02x", MACADDRLEN);
-				PRINT_SINGL_ARG("    Channel: ",	priv->site_survey.bss_backup[i1].channel, "%d");			
-				PRINT_SINGL_ARG("    SSID: ", priv->site_survey.bss_backup[i1].ssid, "%s");			
+				PRINT_SINGL_ARG("    Channel: ",	priv->site_survey.bss_backup[i1].channel, "%d");
+				PRINT_SINGL_ARG("    SSID: ", priv->site_survey.bss_backup[i1].ssid, "%s");
 				PRINT_SINGL_ARG("    Type: ", ((priv->site_survey.bss_backup[i1].bsstype == 16) ? "AP" : "Ad-Hoc"), "%s");
 				//PRINT_SINGL_ARG("    Type: ", priv->site_survey.bss_backup[i1].bsstype, "%d");
 				PRINT_ONE("    ====================", "%s", 1);
-			}	
+			}
 		}
-		
+
 
 	}
 
-	
+
 	return pos;
-	
+
 }
 #endif
 #ifdef CLIENT_MODE
@@ -1431,7 +1473,7 @@ static int rtl8192cd_proc_up_read(char *buf, char **start, off_t offset,
 	struct net_device *dev = (struct net_device *)data;
 	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *)dev->priv;
 	int len = 0;
-	len=sprintf(buf,"%d",priv->up_flag);	
+	len=sprintf(buf,"%d",priv->up_flag);
 	return len;
 }
 static int rtl8192cd_proc_up_write(struct file *file, const char *buffer,
@@ -1476,9 +1518,9 @@ static int rtl8192cd_proc_vlan_read(char *buf, char **start, off_t offset,
 			priv->pmib->vlan.vlan_pri, "%d");
 	PRINT_SINGL_ARG("    vlan_cfi: ",
 			priv->pmib->vlan.vlan_cfi, "%d");
-#if defined(CONFIG_RTK_VLAN_ROUTETYPE)
-	PRINT_SINGL_ARG("    vlan_forwarding: ",
-			priv->pmib->vlan.forwarding, "%d");
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+		PRINT_SINGL_ARG("	 vlan_forwarding_rule: ",
+				priv->pmib->vlan.forwarding_rule, "%d");
 #endif
 
 	return pos;
@@ -1503,21 +1545,21 @@ static int rtl8192cd_proc_vlan_write(struct file *file, const char *buffer,
 		return -EFAULT;
 
 	if (buffer && !copy_from_user(tmp, buffer, 128)) {
-#if defined(CONFIG_RTK_VLAN_ROUTETYPE)
-		int num = sscanf(tmp, "%d %d %d %d %d %d %d %d",
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+				int num = sscanf(tmp, "%d %d %d %d %d %d %d %d",
 #else
-		int num = sscanf(tmp, "%d %d %d %d %d %d %d",
+				int num = sscanf(tmp, "%d %d %d %d %d %d %d",
 #endif
 			&priv->pmib->vlan.global_vlan, &priv->pmib->vlan.is_lan,
 			&priv->pmib->vlan.vlan_enable, &priv->pmib->vlan.vlan_tag,
 			&priv->pmib->vlan.vlan_id, &priv->pmib->vlan.vlan_pri,
 			&priv->pmib->vlan.vlan_cfi
-#if defined(CONFIG_RTK_VLAN_ROUTETYPE)
-			,&priv->pmib->vlan.forwarding
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+				, &priv->pmib->vlan.forwarding_rule
 #endif
 			);
 
-#if defined(CONFIG_RTK_VLAN_ROUTETYPE)
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
 		if (num != 8) {
 #else
 		if (num !=  7) {
@@ -1525,9 +1567,11 @@ static int rtl8192cd_proc_vlan_write(struct file *file, const char *buffer,
 			panic_printk("invalid vlan parameter!\n");
 		}
 	}
-#if defined(CONFIG_RTK_VLAN_ROUTETYPE)
-	add_vlan_info(&priv->pmib->vlan,dev);
+
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+		rtl_add_vlan_info(&priv->pmib->vlan,dev);
 #endif
+
 	return count;
 }
 #endif // CONFIG_RTK_VLAN_SUPPORT
@@ -1552,10 +1596,10 @@ static int rtl8192cd_proc_mib_all(char *buf, char **start, off_t offset,
 	size = sprintf(buf, "  Make info: %s by %s, v%d.%d (%s)\n", UTS_VERSION, LINUX_COMPILE_BY,
 		DRV_VERSION_H, DRV_VERSION_L, DRV_RELDATE);
 	CHECK_LEN;
-#endif	
 #endif
-	size = sprintf(buf+len, "  RTL8192 firmware version: %d.%d,  built time: %02x-%02x %02x:%02x\n", priv->pshare->fw_version, 
-		priv->pshare->fw_sub_version, priv->pshare->fw_date_month, priv->pshare->fw_date_day, 
+#endif
+	size = sprintf(buf+len, "  RTL8192 firmware version: %d.%d,  built time: %02x-%02x %02x:%02x\n", priv->pshare->fw_version,
+		priv->pshare->fw_sub_version, priv->pshare->fw_date_month, priv->pshare->fw_date_day,
 		priv->pshare->fw_date_hour, priv->pshare->fw_date_minute);
 	CHECK_LEN;
 
@@ -1655,12 +1699,20 @@ static int dump_one_stainfo(int num, struct stat_info *pstat, char *buf,
 	CHECK_LEN_B;
 	PRINT_SINGL_ARG("    rx_bytes: ", pstat->rx_bytes, "%u");
 	CHECK_LEN_B;
+	PRINT_SINGL_ARG("    tx_bytes per minute: ", pstat->tx_bytes_1m, "%u");
+	CHECK_LEN_B;
+	PRINT_SINGL_ARG("    rx_bytes per minute: ", pstat->rx_bytes_1m, "%u");
+	CHECK_LEN_B;
 	PRINT_SINGL_ARG("    tx_pkts: ", pstat->tx_pkts, "%u");
 	CHECK_LEN_B;
 	PRINT_SINGL_ARG("    rx_pkts: ", pstat->rx_pkts, "%u");
 	CHECK_LEN_B;
 	PRINT_SINGL_ARG("    tx_fail: ", pstat->tx_fail, "%u");
 	CHECK_LEN_B;
+	PRINT_SINGL_ARG("    tx_avarage:    ", pstat->tx_avarage, "%lu");
+	CHECK_LEN_B;
+	PRINT_SINGL_ARG("    rx_avarage:    ", pstat->rx_avarage, "%lu");
+	CHECK_LEN_B;
 	PRINT_SINGL_ARG("    dz_queue_len: ", skb_queue_len(&pstat->dz_queue), "%u");
 	CHECK_LEN_B;
 #ifdef SW_TX_QUEUE
@@ -1715,7 +1767,7 @@ static int dump_one_stainfo(int num, struct stat_info *pstat, char *buf,
 	if (is_MCS_rate(pstat->current_tx_rate)) {
 		PRINT_ONE("    current_tx_rate: MCS", "%s", 0);
 //		PRINT_ONE(pstat->current_tx_rate&0x7f, "%d", 0);
-		PRINT_ONE(pstat->current_tx_rate&0xf, "%d", 0);		
+		PRINT_ONE(pstat->current_tx_rate&0xf, "%d", 0);
 //		rate = (unsigned char *)MCS_DATA_RATEStr[(pstat->ht_current_tx_info&BIT(0))?1:0][(pstat->ht_current_tx_info&BIT(1))?1:0][pstat->current_tx_rate&0x7f];
 		rate = (unsigned char *)MCS_DATA_RATEStr[(pstat->ht_current_tx_info&BIT(0))?1:0][(pstat->ht_current_tx_info&BIT(1))?1:0][pstat->current_tx_rate&0xf];
 		PRINT_ONE(rate, " %s", 1);
@@ -1948,9 +2000,9 @@ static int rtl8192cd_proc_stainfo(char *buf, char **start, off_t offset,
 
 	// do not waste time again
 	// I sent *eof=1 last time, I do not know why the kernel will call me again.
-	if (read_sta_info_down) {		
-		*eof = 1;		
-		return 0;		
+	if (read_sta_info_down) {
+		*eof = 1;
+		return 0;
 	}
 
 	SAVE_INT_AND_CLI(flags);
@@ -1961,7 +2013,7 @@ static int rtl8192cd_proc_stainfo(char *buf, char **start, off_t offset,
 
 	phead = &priv->asoc_list;
 	if (!netif_running(dev) || list_empty(phead)) {
-		*eof = 1;		
+		*eof = 1;
 		goto _ret;
 	}
 
@@ -1976,13 +2028,13 @@ static int rtl8192cd_proc_stainfo(char *buf, char **start, off_t offset,
 
 		rc = 0; // return code, assume error by default
 		//size = dump_one_stainfo(num++, pstat, buf+len, start, offset, length, eof, data);
-		size = dump_one_stainfo(num++, pstat, buf+len, offset, length, (length + offset - begin- len), &rc);	
+		size = dump_one_stainfo(num++, pstat, buf+len, offset, length, (length + offset - begin- len), &rc);
 		CHECK_LEN;
-		
+
 #ifdef CONFIG_RTK_MESH
 		if (rc == 0)
 			break;
-		
+
 		// 3 line for Throughput statistics (sounder)
 		size = dump_mesh_one_mpflow_sta(num, pstat, buf+len, start, offset, length,
 					eof, data);
@@ -2062,7 +2114,7 @@ static int rtl8192cd_proc_sta_keyinfo(char *buf, char **start, off_t offset,
 	struct list_head *phead, *plist;
 	struct stat_info *pstat;
 	unsigned long flags=0;
-	SAVE_INT_AND_CLI(flags);	
+	SAVE_INT_AND_CLI(flags);
 
 	strcpy(buf, "-- STA key info table --\n");
 	size = strlen(buf);
@@ -2113,7 +2165,7 @@ static int rtl8192cd_proc_stats(char *buf, char **start, off_t offset,
 	unsigned char *rate;
 	unsigned long flags=0;
 	SAVE_INT_AND_CLI(flags);
-	
+
 	PRINT_ONE("  Statistics...", "%s", 1);
 
 	m = priv->up_time / 86400;
@@ -2179,8 +2231,8 @@ static int rtl8192cd_proc_stats(char *buf, char **start, off_t offset,
 	}
 #endif
 
-		
-		
+
+
 #if defined(CONFIG_RTL_92D_SUPPORT) && defined(CONFIG_RTL_NOISE_CONTROL)
 	if (GET_CHIP_VER(priv) == VERSION_8192D){
 #ifdef _DEBUG_RTL8192CD_
@@ -2248,13 +2300,22 @@ static int rtl8192cd_proc_stats(char *buf, char **start, off_t offset,
 #endif
 
 #if defined(RESERVE_TXDESC_FOR_EACH_IF) && (defined(UNIVERSAL_REPEATER) || defined(MBSSID))
-	if (priv->pmib->miscEntry.rsv_txdesc) {
+	if (GET_ROOT(priv)->pmib->miscEntry.rsv_txdesc) {
 		PRINT_SINGL_ARG("    bkq_used_desc:   ", (UINT)priv->use_txdesc_cnt[BK_QUEUE], "%d");
 		PRINT_SINGL_ARG("    beq_used_desc:   ", (UINT)priv->use_txdesc_cnt[BE_QUEUE], "%d");
 		PRINT_SINGL_ARG("    viq_used_desc:   ", (UINT)priv->use_txdesc_cnt[VI_QUEUE], "%d");
 		PRINT_SINGL_ARG("    voq_used_desc:   ", (UINT)priv->use_txdesc_cnt[VO_QUEUE], "%d");
 	}
 #endif
+
+#ifdef USE_TXQUEUE
+	if (GET_ROOT(priv)->pmib->miscEntry.use_txq) {
+		PRINT_SINGL_ARG("    txq_bk_num:   ", (UINT)txq_len(&priv->pshare->txq_list[BK_QUEUE]), "%d");
+		PRINT_SINGL_ARG("    txq_be_num:   ", (UINT)txq_len(&priv->pshare->txq_list[BE_QUEUE]), "%d");
+		PRINT_SINGL_ARG("    txq_vi_num:   ", (UINT)txq_len(&priv->pshare->txq_list[VI_QUEUE]), "%d");
+		PRINT_SINGL_ARG("    txq_vo_num:   ", (UINT)txq_len(&priv->pshare->txq_list[VO_QUEUE]), "%d");		
+	}
+#endif
 	RESTORE_INT(flags);
 
 	return pos;
@@ -2314,10 +2375,15 @@ static int rtl8192cd_proc_mib_misc(char *buf, char **start, off_t offset,
 	PRINT_SINGL_ARG("    vap_enable: ", priv->pmib->miscEntry.vap_enable, "%d");
 //#endif
 #if defined(RESERVE_TXDESC_FOR_EACH_IF) && (defined(UNIVERSAL_REPEATER) || defined(MBSSID))
-	PRINT_SINGL_ARG("    rsv_txdesc: ", priv->pmib->miscEntry.rsv_txdesc, "%d");
+	PRINT_SINGL_ARG("    rsv_txdesc: ", GET_ROOT(priv)->pmib->miscEntry.rsv_txdesc, "%d");
+#endif
+#ifdef USE_TXQUEUE
+	PRINT_SINGL_ARG("    use_txq: ", GET_ROOT(priv)->pmib->miscEntry.use_txq, "%d");
 #endif
 	PRINT_SINGL_ARG("    func_off: ", priv->pmib->miscEntry.func_off, "%d");
-
+#ifdef TX_EARLY_MODE
+	PRINT_SINGL_ARG("    em_waitq_on: ", GET_ROOT(priv)->pshare->em_waitq_on, "%d");
+#endif
 	return pos;
 }
 
@@ -2365,6 +2431,10 @@ static int rtl8192cd_proc_rfft(char *buf, char **start, off_t offset,
 	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *)dev->priv;
 #endif
 	int pos = 0;
+#ifdef SUPPORT_TX_MCAST2UNI
+	int i;
+	int tmpbuf[64];
+#endif
 
 	PRINT_ONE("  RF fine tune variables...", "%s", 1);
 
@@ -2404,12 +2474,23 @@ static int rtl8192cd_proc_rfft(char *buf, char **start, off_t offset,
 	//Support IP multicast->unicast
 #ifdef SUPPORT_TX_MCAST2UNI
 	PRINT_SINGL_ARG("    mc2u_disable: ", priv->pshare->rf_ft_var.mc2u_disable, "%d");
+	PRINT_SINGL_ARG("    mc2u_drop_unknown: ", priv->pshare->rf_ft_var.mc2u_drop_unknown, "%d");
+	PRINT_SINGL_ARG("    mc2u_flood_ctrl: ", priv->pshare->rf_ft_var.mc2u_flood_ctrl, "%d");
+	if(priv->pshare->rf_ft_var.mc2u_flood_ctrl)
+	{
+		PRINT_SINGL_ARG("    mc2u_flood_mac_num: ", priv->pshare->rf_ft_var.mc2u_flood_mac_num, "%d");
+		for (i=0; i< priv->pshare->rf_ft_var.mc2u_flood_mac_num; i++) {
+			sprintf(tmpbuf, "    mc2u_flood_mac[%d]: ", i);
+			PRINT_ARRAY_ARG(tmpbuf,	priv->pshare->rf_ft_var.mc2u_flood_mac[i].macAddr, "%02x", 6);
+		}
+	}
 #endif
+
 #ifdef	HIGH_POWER_EXT_PA
 	PRINT_SINGL_ARG("    use_ext_pa: ", priv->pshare->rf_ft_var.use_ext_pa, "%d");
 #endif
 	PRINT_SINGL_ARG("    use_ext_lna: ", priv->pshare->rf_ft_var.use_ext_lna, "%d");
-	PRINT_SINGL_ARG("    NDSi_support: ", priv->pshare->rf_ft_var.NDSi_support, "%d");	
+	PRINT_SINGL_ARG("    NDSi_support: ", priv->pshare->rf_ft_var.NDSi_support, "%d");
 	PRINT_SINGL_ARG("    EDCCA threshold: ", priv->pshare->rf_ft_var.edcca_thd, "%d");
 	PRINT_SINGL_ARG("    1rcca: ", priv->pshare->rf_ft_var.one_path_cca, "%d");
 
@@ -2541,6 +2622,98 @@ static int rtl8192cd_proc_mib_edca(char *buf, char **start, off_t offset,
  #endif //RTL_MANUAL_EDCA
 
 
+#ifdef TLN_STATS
+static int proc_wifi_conn_stats(char *buf, char **start, off_t offset,
+			int length, int *eof, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *)dev->priv;
+	int pos = 0;
+
+	PRINT_ONE("  Wifi Connection Stats...", "%s", 1);
+
+	PRINT_SINGL_ARG("    Time Interval: ", priv->pshare->rf_ft_var.stats_time_interval, "%d");
+	PRINT_SINGL_ARG("    Connected Clients: ", priv->wifi_stats.connected_sta, "%d");
+	PRINT_SINGL_ARG("    MAX Clients: ", priv->wifi_stats.max_sta, "%d");
+	PRINT_SINGL_ARG("    MAX Clients Timestamp: ", priv->wifi_stats.max_sta_timestamp, "%d");
+	PRINT_SINGL_ARG("    Rejected clients: ", priv->wifi_stats.rejected_sta, "%d");
+
+	return pos;
+}
+
+
+static int proc_wifi_conn_stats_clear(struct file *file, const char *buffer,
+				unsigned long count, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *)dev->priv;
+
+	memset(&priv->wifi_stats, 0, sizeof(struct tln_wifi_stats));
+	return count;
+}
+
+
+static int proc_ext_wifi_conn_stats(char *buf, char **start, off_t offset,
+			int length, int *eof, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *)dev->priv;
+	int pos = 0;
+
+	PRINT_ONE("  Extended WiFi Connection Stats...", "%s", 1);
+
+	PRINT_ONE("  Reject Reason/Status: Reject Count", "%s", 1);
+	PRINT_ONE(" =====================================================", "%s", 1);
+	PRINT_SINGL_ARG("    Unspecified reason: ", priv->ext_wifi_stats.rson_UNSPECIFIED_1, "%d");
+	PRINT_SINGL_ARG("    Previous auth no longer valid: ", priv->ext_wifi_stats.rson_AUTH_INVALID_2, "%d");
+	PRINT_SINGL_ARG("    Deauth because of leaving (or has left): ", priv->ext_wifi_stats.rson_DEAUTH_STA_LEAVING_3, "%d");
+	PRINT_SINGL_ARG("    Disassoc due to inactivity: ", priv->ext_wifi_stats.rson_INACTIVITY_4, "%d");
+	PRINT_SINGL_ARG("    Disassoc because AP cannot handle: ", priv->ext_wifi_stats.rson_RESOURCE_INSUFFICIENT_5, "%d");
+	PRINT_SINGL_ARG("    Class 2 frame from non-auth STA: ", priv->ext_wifi_stats.rson_UNAUTH_CLS2FRAME_6, "%d");
+	PRINT_SINGL_ARG("    Class 3 frame from non-assoc STA: ", priv->ext_wifi_stats.rson_UNAUTH_CLS3FRAME_7, "%d");
+	PRINT_SINGL_ARG("    Disassoc because leaving (or has left): ", priv->ext_wifi_stats.rson_DISASSOC_STA_LEAVING_8, "%d");
+	PRINT_SINGL_ARG("    STA request (re)assoc did not auth: ", priv->ext_wifi_stats.rson_ASSOC_BEFORE_AUTH_9, "%d");
+	PRINT_SINGL_ARG("    Invalid IE: ", priv->ext_wifi_stats.rson_INVALID_IE_13, "%d");
+	PRINT_SINGL_ARG("    MIC failure: ", priv->ext_wifi_stats.rson_MIC_FAILURE_14, "%d");
+	PRINT_SINGL_ARG("    4-Way Handshake timeout: ", priv->ext_wifi_stats.rson_4WAY_TIMEOUT_15, "%d");
+	PRINT_SINGL_ARG("    Group Key Handshake timeout: ", priv->ext_wifi_stats.rson_GROUP_KEY_TIMEOUT_16, "%d");
+	PRINT_SINGL_ARG("    IE in 4-Way Handshake different: ", priv->ext_wifi_stats.rson_DIFF_IE_17, "%d");
+	PRINT_SINGL_ARG("    Invalid group cipher: ", priv->ext_wifi_stats.rson_MCAST_CIPHER_INVALID_18, "%d");
+	PRINT_SINGL_ARG("    Invalid pairwise cipher: ", priv->ext_wifi_stats.rson_UCAST_CIPHER_INVALID_19, "%d");
+	PRINT_SINGL_ARG("    Invalid AKMP: ", priv->ext_wifi_stats.rson_AKMP_INVALID_20, "%d");
+	PRINT_SINGL_ARG("    Unsupported RSNIE version: ", priv->ext_wifi_stats.rson_UNSUPPORT_RSNIE_VER_21, "%d");
+	PRINT_SINGL_ARG("    Invalid RSNIE capabilities: ", priv->ext_wifi_stats.rson_RSNIE_CAP_INVALID_22, "%d");
+	PRINT_SINGL_ARG("    IEEE 802.1X auth failed: ", priv->ext_wifi_stats.rson_802_1X_AUTH_FAIL_23, "%d");
+	PRINT_SINGL_ARG("    Reason out of scope of the device: ", priv->ext_wifi_stats.rson_OUT_OF_SCOPE, "%d");
+
+	PRINT_SINGL_ARG("    Unspecified failure: ", priv->ext_wifi_stats.status_FAILURE_1, "%d");
+	PRINT_SINGL_ARG("    Cannot support all capabilities: ", priv->ext_wifi_stats.status_CAP_FAIL_10, "%d");
+	PRINT_SINGL_ARG("    Reassoc denied due to cannot confirm assoc exists: ", priv->ext_wifi_stats.status_NO_ASSOC_11, "%d");
+	PRINT_SINGL_ARG("    Assoc denied due to reason beyond: ", priv->ext_wifi_stats.status_OTHER_12, "%d");
+	PRINT_SINGL_ARG("    Not support specified auth alg: ", priv->ext_wifi_stats.status_NOT_SUPPORT_ALG_13, "%d");
+	PRINT_SINGL_ARG("    Auth seq out of expected: ", priv->ext_wifi_stats.status_OUT_OF_AUTH_SEQ_14, "%d");
+	PRINT_SINGL_ARG("    Challenge failure: ", priv->ext_wifi_stats.status_CHALLENGE_FAIL_15, "%d");
+	PRINT_SINGL_ARG("    Auth timeout: ", priv->ext_wifi_stats.status_AUTH_TIMEOUT_16, "%d");
+	PRINT_SINGL_ARG("    Denied because AP cannot handle: ", priv->ext_wifi_stats.status_RESOURCE_INSUFFICIENT_17, "%d");
+	PRINT_SINGL_ARG("    Denied because STA not support all rates: ", priv->ext_wifi_stats.status_RATE_FAIL_18, "%d");
+	PRINT_SINGL_ARG("    Status out of scope of the device: ", priv->ext_wifi_stats.status_OUT_OF_SCOPE, "%d");
+
+	return pos;
+}
+
+
+static int proc_ext_wifi_conn_stats_clear(struct file *file, const char *buffer,
+				unsigned long count, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *)dev->priv;
+
+	memset(&priv->ext_wifi_stats, 0, sizeof(struct tln_ext_wifi_stats));
+	return count;
+}
+#endif
+
+
 #ifdef __KERNEL__
 void MDL_DEVINIT rtl8192cd_proc_init(struct net_device *dev)
 {
@@ -2690,6 +2863,22 @@ void MDL_DEVINIT rtl8192cd_proc_init(struct net_device *dev)
 	res->write_proc = rtl8192cd_proc_vlan_write;
 #endif
 
+#ifdef TLN_STATS
+	if ((res = create_proc_read_entry ("wifi_conn_stats", 0644, rtl8192cd_proc_root,
+			proc_wifi_conn_stats, (void *)dev)) == NULL ) {
+		printk("create proc wifi_conn_stats failed!\n");
+		return;
+	}
+	res->write_proc = proc_wifi_conn_stats_clear;
+
+	if ((res = create_proc_read_entry ("ext_wifi_conn_stats", 0644, rtl8192cd_proc_root,
+			proc_ext_wifi_conn_stats, (void *)dev)) == NULL ) {
+		printk("create proc ext_wifi_conn_stats failed!\n");
+		return;
+	}
+	res->write_proc = proc_ext_wifi_conn_stats_clear;
+#endif
+
 #if defined(UNIVERSAL_REPEATER) || defined(MBSSID)
 	if (GET_ROOT_PRIV(priv) == NULL)  // is root interface
 #endif
@@ -2700,7 +2889,7 @@ void MDL_DEVINIT rtl8192cd_proc_init(struct net_device *dev)
 			return;
 		}
 		res->write_proc = rtl8192cd_proc_txdesc_info_write;
-		
+
 #ifdef CLIENT_MODE
 		if ((res = create_proc_read_entry("up_flag", 0644, rtl8192cd_proc_root,
 				rtl8192cd_proc_up_read, (void *)dev)) == NULL ) {
@@ -2744,7 +2933,7 @@ void MDL_DEVINIT rtl8192cd_proc_init(struct net_device *dev)
 			return;
 		}
 #endif
-#ifdef CONFIG_RTL_92C_SUPPORT //#ifndef CONFIG_RTL_92D_SUPPORT
+#ifdef CONFIG_RTL_92C_SUPPORT
 if ((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)){
 #ifdef MERGE_FW
 		if ( (res = create_proc_read_entry ("phypara_file", 0644, rtl8192cd_proc_root,
@@ -2771,7 +2960,7 @@ if ((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)
 		res->write_proc = rtl8192cd_proc_led;
 		res->data = (void *)dev;
 }
-#endif //end of CONFIG_RTL_92D_SUPPORT
+#endif //CONFIG_RTL_92C_SUPPORT
 
 #ifdef AUTO_TEST_SUPPORT
 		if ( create_proc_read_entry("SS_Result", 0644, rtl8192cd_proc_root,
@@ -2786,57 +2975,57 @@ if ((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)
 #ifdef CONFIG_RTK_MESH
 #ifdef MESH_BOOTSEQ_AUTH
 	if ( create_proc_read_entry ("mesh_auth_mpinfo", 0644, rtl8192cd_proc_root,
-			rtl8190_mesh_auth_mpinfo, (void *)dev) == NULL ) {
+			mesh_auth_mpinfo, (void *)dev) == NULL ) {
 		printk("create proc mesh_auth_mpinfo failed!\n");
 		return;
 	}
 #endif
 
 	if ( create_proc_read_entry ("mesh_unestablish_mpinfo", 0644, rtl8192cd_proc_root,
-			rtl8190_mesh_unEstablish_mpinfo, (void *)dev) == NULL ) {
+			mesh_unEstablish_mpinfo, (void *)dev) == NULL ) {
 		printk("create proc mesh_unestablish_mpinfo failed!\n");
 		return;
 	}
 
 	if ( create_proc_read_entry ("mesh_assoc_mpinfo", 0644, rtl8192cd_proc_root,
-			rtl8190_mesh_assoc_mpinfo, (void *)dev) == NULL ) {
+			mesh_assoc_mpinfo, (void *)dev) == NULL ) {
 		printk("create proc mesh_assoc_mpinfo failed!\n");
 		return;
 	}
 
 	if ( create_proc_read_entry ("mesh_stats", 0644, rtl8192cd_proc_root,
-			rtl8190_proc_mesh_stats, (void *)dev) == NULL ) {
+			mesh_stats, (void *)dev) == NULL ) {
 		printk("create proc mesh_stats failed!\n");
 		return;
 	}
 
 	// 6 line for Throughput statistics (sounder)
 	if ( (res = create_proc_read_entry ("flow_stats", 0644, rtl8192cd_proc_root,
-			rtk8190_proc_flow_stats, (void *)dev)) == NULL ) {
+			mesh_proc_flow_stats, (void *)dev)) == NULL ) {
 		printk("create proc flow_stats failed!\n");
 		return;
 	}
-	res->write_proc = rtk8190_proc_flow_stats_write;
+	res->write_proc = mesh_proc_flow_stats_write;
 
 	if ( create_proc_read_entry ("mesh_pathsel_routetable", 0644, rtl8192cd_proc_root,
-			rtl8190_pathsel_routetable_info, (void *)dev) == NULL ) {
+			mesh_pathsel_routetable_info, (void *)dev) == NULL ) {
 		printk("create proc mesh_pathsel_routetable failed!\n");
 		return;
 	}
 	if ( create_proc_read_entry ("mesh_proxy_table", 0644, rtl8192cd_proc_root,
-			rtl8190_proxy_table_info, (void *)dev) == NULL ) {
+			mesh_proxy_table_info, (void *)dev) == NULL ) {
 		printk("create proc mesh_proxy_table failed!\n");
 		return;
 	}
 
 	if ( create_proc_read_entry ("mesh_portal_table", 0644, rtl8192cd_proc_root,
-			rtl8190_portal_table_info, (void *)dev) == NULL ) {
+			mesh_portal_table_info, (void *)dev) == NULL ) {
 		printk("create proc mesh_portal_table failed!\n");
 		return;
 	}
 
 	if ( create_proc_read_entry ("mesh_root_info", 0644, rtl8192cd_proc_root,
-			rtl8190_root_info, (void *)dev) == NULL ) {
+			mesh_root_info, (void *)dev) == NULL ) {
 		printk("create proc mesh_root_info failed!\n");
 		return;
 	}
@@ -2851,15 +3040,15 @@ if ((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)
 			printk("can't create proc: %s\r\n", "mesh_metric");
 			return;
 		}
-		proc_file1->write_proc = rtl8190_mesh_metric_w;
-		proc_file1->read_proc = rtl8190_mesh_metric_r;
+		proc_file1->write_proc = mesh_metric_w;
+		proc_file1->read_proc = mesh_metric_r;
 		proc_file1->data = (void *)dev;
 	}
 #endif
 
 #if DBG_NCTU_MESH
 	if ( create_proc_read_entry ("mesh_skb", 0644, rtl8192cd_proc_root,
-			showAllSkbs, (void *)dev) == NULL ) {
+			mesh_showAllSkbs, (void *)dev) == NULL ) {
 		printk("create proc mesh_skb failed!\n");
 		return;
 	}
@@ -2875,60 +3064,62 @@ if ((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)
 			printk("can't create proc: %s\r\n", "mesh_dbg");
 			return;
 		}
-		proc_file1->write_proc = rtl8190_setMeshDebugLevel;
+		proc_file1->write_proc = mesh_setDebugLevel;
 	}
 #endif
 #ifdef _MESH_DEBUG_
 	if ( create_proc_read_entry ("mesh_clearalltable", 0644, rtl8192cd_proc_root,
-			rtl8190_proc_mesh_clear_table, (void *)dev) == NULL ) {
+			mesh_proc_clear_table, (void *)dev) == NULL ) {
 		printk("create proc mesh_clearalltable failed!\n");
 		return;
 	}
 
 	if ( create_proc_read_entry ("mesh_issueauthreq", 0644, rtl8192cd_proc_root,
-			rtl8190_proc_mesh_issueAuthReq, (void *)dev) == NULL ) {
+			mesh_proc_issueAuthReq, (void *)dev) == NULL ) {
 		printk("create proc mesh_issueauthreq failed!\n");
 		return;
 	}
 
+#ifdef MESH_BOOTSEQ_AUTH
 	if ( create_proc_read_entry ("mesh_issueauthrsp", 0644, rtl8192cd_proc_root,
-			rtl8190_proc_mesh_issueAuthRsp, (void *)dev) == NULL ) {
+			mesh_proc_issueAuthRsp, (void *)dev) == NULL ) {
 		printk("create proc mesh_issueauthrsp failed!\n");
 		return;
 	}
 
 	if ( create_proc_read_entry ("mesh_issuedeauth", 0644, rtl8192cd_proc_root,
-			rtl8190_proc_mesh_issueDeAuth, (void *)dev) == NULL ) {
+			mesh_proc_issueDeAuth, (void *)dev) == NULL ) {
 		printk("create proc mesh_issuedeauth failed!\n");
 		return;
 	}
+#endif
 
 	if ( create_proc_read_entry ("mesh_openconnect", 0644, rtl8192cd_proc_root,
-			rtl8190_proc_mesh_openConnect, (void *)dev) == NULL ) {
+			mesh_proc_openConnect, (void *)dev) == NULL ) {
 		printk("create proc mesh_openconnect failed!\n");
 		return;
 	}
 
 	if ( create_proc_read_entry ("mesh_issueopen", 0644, rtl8192cd_proc_root,
-			rtl8190_proc_mesh_issueOpen, (void *)dev) == NULL ) {
+			mesh_proc_issueOpen, (void *)dev) == NULL ) {
 		printk("create proc mesh_issueopen failed!\n");
 		return;
 	}
 
 	if ( create_proc_read_entry ("mesh_issueconfirm", 0644, rtl8192cd_proc_root,
-			rtl8190_proc_mesh_issueConfirm, (void *)dev) == NULL ) {
+			mesh_proc_issueConfirm, (void *)dev) == NULL ) {
 		printk("create proc mesh_issueconfirm failed!\n");
 		return;
 	}
 
 	if ( create_proc_read_entry ("mesh_issueclose", 0644, rtl8192cd_proc_root,
-			rtl8190_proc_mesh_issueClose, (void *)dev) == NULL ) {
+			mesh_proc_issueClose, (void *)dev) == NULL ) {
 		printk("create proc mesh_issueclose failed!\n");
 		return;
 	}
 
 	if ( create_proc_read_entry ("mesh_closeconnect", 0644, rtl8192cd_proc_root,
-			rtl8190_proc_mesh_closeConnect, (void *)dev) == NULL ) {
+			mesh_proc_closeConnect, (void *)dev) == NULL ) {
 		printk("create proc mesh_closeconnect failed!\n");
 		return;
 	}
@@ -2945,7 +3136,7 @@ if ((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)
 		printk("can't create proc: %s\r\n", "mesh_setmacaddr");
 		return;
 	}
-	proc_file1->write_proc = rtl8190_mesh_setMACAddr;
+	proc_file1->write_proc = mesh_setMACAddr;
 	}
 
 
@@ -3042,6 +3233,10 @@ void __devexit rtl8192cd_proc_remove (struct net_device *dev)
 		remove_proc_entry( "mib_vlan", rtl8192cd_proc_root );
 #endif
 
+#ifdef TLN_STATS
+		remove_proc_entry( "wifi_conn_stats", rtl8192cd_proc_root );
+		remove_proc_entry( "ext_wifi_conn_stats", rtl8192cd_proc_root );
+#endif
 
 #if defined(UNIVERSAL_REPEATER) || defined(MBSSID)
 		if (GET_ROOT_PRIV(priv) == NULL)  // is root interface
@@ -3062,7 +3257,7 @@ void __devexit rtl8192cd_proc_remove (struct net_device *dev)
 			remove_proc_entry( "phypara_file", rtl8192cd_proc_root );
 #endif
 			remove_proc_entry( "led", rtl8192cd_proc_root );
-	
+
 #ifdef AUTO_TEST_SUPPORT
 			remove_proc_entry( "SS_Result", rtl8192cd_proc_root );
 #endif
@@ -3074,9 +3269,9 @@ void __devexit rtl8192cd_proc_remove (struct net_device *dev)
 		remove_proc_entry( "mesh_assoc_mpinfo", rtl8192cd_proc_root );
 		remove_proc_entry( "mesh_stats", rtl8192cd_proc_root );
 		remove_proc_entry( "mesh_pathsel_routetable", rtl8192cd_proc_root );
-		remove_proc_entry( "rtl8190_proxy_table_info", rtl8192cd_proc_root );
-		remove_proc_entry( "rtl8190_root_info", rtl8192cd_proc_root );
-		remove_proc_entry( "rtl8190_portal_table_info", rtl8192cd_proc_root );
+		remove_proc_entry( "mesh_proxy_table", rtl8192cd_proc_root );
+		remove_proc_entry( "mesh_root_info", rtl8192cd_proc_root );
+		remove_proc_entry( "mesh_portal_table", rtl8192cd_proc_root );
 
 #ifdef MESH_USE_METRICOP // remove proc file
                 remove_proc_entry( "mesh_metric", rtl8192cd_proc_root );
@@ -3152,14 +3347,19 @@ static struct _proc_table_ proc_table[] =
 #endif
 	{"mib_misc",			rtl8192cd_proc_mib_misc},
 
+#ifdef TLN_STATS
+	{"wifi_conn_stats",			proc_wifi_conn_stats},
+	{"ext_wifi_conn_stats",			proc_ext_wifi_conn_stats},
+#endif
+
 #ifdef AUTO_TEST_SUPPORT
 	{"SS_Result",			rtl8192cd_proc_SSR_read},
 #endif
 
 #ifdef _MESH_DEBUG_ // 802.11s output debug information
-	{"mesh_unestablish_mpinfo",	rtl8190_mesh_unEstablish_mpinfo},
-	{"mesh_assoc_mpinfo",		rtl8190_mesh_assoc_mpinfo},
-	{"mesh_stats",			rtl8190_proc_mesh_stats}
+	{"mesh_unestablish_mpinfo",	mesh_unEstablish_mpinfo},
+	{"mesh_assoc_mpinfo",		mesh_assoc_mpinfo},
+	{"mesh_stats",			mesh_stats}
 #endif	// _MESH_DEBUG_
 };
 
@@ -3187,7 +3387,7 @@ int rtl8192cd_show_wifi_debug(char *dev_name, char *cmd, char *str)
 	int i, j, eof, len;
 	char *tmpbuf, *start;
 	struct net_device *dev;
-	
+
 	printk("dev_name=%s, cmd=%s.\n", dev_name, cmd);
 
     dev = dev_get_by_name(dev_name);
@@ -3207,7 +3407,7 @@ int rtl8192cd_show_wifi_debug(char *dev_name, char *cmd, char *str)
 	}
 	else
 	    return 1;
-	    
+
 	return 0;
 }
 
diff --git a/drivers/net/wireless/rtl8192cd/8192cd_psk.c b/drivers/net/wireless/rtl8192cd/8192cd_psk.c
index bfa1054..c2b3489 100644
--- a/drivers/net/wireless/rtl8192cd/8192cd_psk.c
+++ b/drivers/net/wireless/rtl8192cd/8192cd_psk.c
@@ -2234,6 +2234,10 @@ void ClientSendEAPOL(struct rtl8192cd_priv *priv, struct stat_info *pstat, int r
 	{
 		EAPOLMsgSend.Length = pStaInfo->EAPOLMsgSend.Length;
 		EapolKeyMsgSend.Length = pStaInfo->EapolKeyMsgSend.Length;
+		if ( (pStaInfo->EAPOLMsgSend.Length==0) || (pStaInfo->EapolKeyMsgSend.Length==0) ) {
+			DEBUG_ERR("(%s):The length of EAPOLMsg or EapolKeyMsg is error! EAPOLMsg:%d,  EapolKeyMsg:%d\n", __FUNCTION__, pStaInfo->EAPOLMsgSend.Length,  pStaInfo->EapolKeyMsgSend.Length);
+			return;
+		}
 		//---goto send_packet
 	}
 	else
@@ -2329,7 +2333,7 @@ void ClientSendEAPOL(struct rtl8192cd_priv *priv, struct stat_info *pstat, int r
 				LOG_MSG( "Open and authenticated\n");
 				
 				pStaInfo->clientMICReportReplayCounter.field.HighPart = 0;
-                pStaInfo->clientMICReportReplayCounter.field.LowPart = 0;
+                		pStaInfo->clientMICReportReplayCounter.field.LowPart = 0;
 				//				printk("client mode 4-Way Message 4-4 done\n");
 			}
 		}
@@ -2414,6 +2418,9 @@ void ClientSendEAPOL(struct rtl8192cd_priv *priv, struct stat_info *pstat, int r
 		pStaInfo->EapolKeyMsgSend.Length = EapolKeyMsgSend.Length;						
 	}
 
+	//add by peteryu, for record EAPOLMSG length
+	pStaInfo->EAPOLMsgSend.Length = EAPOLMsgSend.Length;
+	pStaInfo->EapolKeyMsgSend.Length = EapolKeyMsgSend.Length;
 	//send_packet--------------------------------------------------------------
 
 	eth_hdr = (struct wlan_ethhdr_t *)EAPOLMsgSend.Octet;
@@ -3097,7 +3104,7 @@ cont_msg:
 				//---- Receive 3rd message ----
 				DEBUG_INFO("client mode 4-3\n");
 
-				pStaInfo->resendCnt = 0; //victoryman
+				pStaInfo->resendCnt = 0;
 
 				if (!pStaInfo->clientHndshkProcessing)
 				{
@@ -3227,7 +3234,7 @@ cont_msg:
 			//---- Receive 1st message of 2-way handshake ----
 			DEBUG_INFO("client mode receive 2-1\n");
 
-			pStaInfo->resendCnt = 0; //victoryman
+			pStaInfo->resendCnt = 0;
 
 			Message_ReplayCounter_OC2LI(pStaInfo->EapolKeyMsgRecvd, &recievedRC);
 
@@ -3290,6 +3297,8 @@ cont_msg:
 	void derivePSK(struct rtl8192cd_priv *priv)
 	{
 		WPA_GLOBAL_INFO *pGblInfo=priv->wpa_global_info;
+		int x;
+		SAVE_INT_AND_CLI(x);
 
 		if (strlen(priv->pmib->dot1180211AuthEntry.dot11PassPhrase) == 64) // hex
 			get_array_val(pGblInfo->PSK, priv->pmib->dot1180211AuthEntry.dot11PassPhrase, 64);
@@ -3304,6 +3313,8 @@ cont_msg:
 				PasswordHash(priv->pmib->dot1180211AuthEntry.dot11PassPhraseGuest, SSID, SSID_LEN,
 						pGblInfo->PSKGuest);
 		}
+
+		RESTORE_INT(x);
 	}
 
 	void psk_init(struct rtl8192cd_priv *priv)
diff --git a/drivers/net/wireless/rtl8192cd/8192cd_psk.h b/drivers/net/wireless/rtl8192cd/8192cd_psk.h
index 4fa1ac0..e9e9874 100644
--- a/drivers/net/wireless/rtl8192cd/8192cd_psk.h
+++ b/drivers/net/wireless/rtl8192cd/8192cd_psk.h
@@ -69,6 +69,13 @@ typedef enum	{ type_Group = 0, type_Pairwise = 1 } KeyType;
 typedef enum	{ key_desc_ver1 = 1, key_desc_ver2 = 2 } KeyDescVer;
 enum { PSK_WPA=1, PSK_WPA2=2};
 
+#ifdef TLN_STATS
+enum { STATS_AUTH_OPEN=0, STATS_AUTH_SHARE=1,
+		STATS_PSK_WPA=2, STATS_PSK_WPA2=3,
+		STATS_ETP_WPA=4, STATS_ETP_WPA2=5
+	};
+#endif
+
 enum {
 	PSK_STATE_IDLE,
 	PSK_STATE_PTKSTART,
diff --git a/drivers/net/wireless/rtl8192cd/8192cd_rx.c b/drivers/net/wireless/rtl8192cd/8192cd_rx.c
index 6ff4584..d7f6b63 100644
--- a/drivers/net/wireless/rtl8192cd/8192cd_rx.c
+++ b/drivers/net/wireless/rtl8192cd/8192cd_rx.c
@@ -17,7 +17,9 @@
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
 #include <net/ip.h>
+#ifndef CONFIG_RTL8672
 #include <net/rtl/rtl_types.h>
+#endif
 
 #include <linux/ipv6.h>
 #include <linux/icmpv6.h>
@@ -38,11 +40,14 @@
 #endif
 
 #ifdef CONFIG_RTK_MESH
-#include "./mesh_ext/mesh_route.h"
+#include "../mesh_ext/mesh_route.h"
 #endif
 #if defined(CONFIG_RTL_WAPI_SUPPORT)
 #include "wapiCrypto.h"
 #endif
+#if defined(CONFIG_RTL_FASTBRIDGE)
+#include <net/rtl/features/fast_bridge.h>
+#endif
 
 #ifdef BR_SHORTCUT
 #ifdef WDS
@@ -61,6 +66,7 @@ __DRAM_IN_865X struct net_device *cached_sta_dev = NULL;
 #if	defined(RTL_CACHED_BR_STA)
 __DRAM_IN_865X unsigned char cached_br_sta_mac[MACADDRLEN];
 __DRAM_IN_865X struct net_device *cached_br_sta_dev = NULL;
+extern struct net_device *get_shortcut_dev(unsigned char *da);
 #endif
 
 #endif
@@ -194,6 +200,107 @@ static unsigned char EVMdbToPercentage(signed char Value)
 }
 
 
+
+#ifdef MP_SWITCH_LNA
+
+#define ss_threshold_H 0x28
+#define ss_threshold_L 0x17
+
+static __inline__ void dynamic_switch_lna(struct rtl8192cd_priv *priv)
+{
+
+	unsigned int tmp_b30 = PHY_QueryBBReg(priv, 0xb30, bMaskDWord);
+
+
+	unsigned int tmp_dd0 = PHY_QueryBBReg(priv, 0xdd0, bMaskDWord);
+	unsigned int tmp_dd0_a = (tmp_dd0 & 0x3f);
+	unsigned int tmp_dd0_b = ((tmp_dd0 & 0x3f00) >> 8);
+
+	//======= PATH  A ============
+
+	if((tmp_dd0_a >= ss_threshold_H) && (!(tmp_b30 & BIT(21))))
+	{
+		if(priv->pshare->rx_packet_ss_a >= 10)
+			priv->pshare->rx_packet_ss_a = 0;
+		
+		priv->pshare->rx_packet_ss_a = (priv->pshare->rx_packet_ss_a+1); 
+		
+		if(priv->pshare->rx_packet_ss_a > 3)
+			priv->pshare->rx_packet_ss_a = 3; 
+
+		if( priv->pshare->rx_packet_ss_a == 3)
+		{
+			tmp_b30 = (tmp_b30 | BIT(21)) ; 
+			PHY_SetBBReg(priv, 0xb30, bMaskDWord, tmp_b30 );
+			printk("!!!! UP 3 PACKETS !!!! PATH A dd0[0x%x] > 0x%x, Change b30 = 0x%x!!!!\n\n", 
+					tmp_dd0_a , ss_threshold_H, tmp_b30 );
+		}
+			
+	}
+	else if((tmp_dd0_a <= ss_threshold_L) && (tmp_b30 & BIT(21)))
+	{
+		if(priv->pshare->rx_packet_ss_a < 10)
+			priv->pshare->rx_packet_ss_a = 10;
+		
+		priv->pshare->rx_packet_ss_a = (priv->pshare->rx_packet_ss_a+1) ;
+		
+		if(priv->pshare->rx_packet_ss_a > 13)
+			priv->pshare->rx_packet_ss_a = 13; 
+		
+		if(priv->pshare->rx_packet_ss_a == 13)
+		{
+			tmp_b30 = (tmp_b30 & ~(BIT(21))) ; 
+			PHY_SetBBReg(priv, 0xb30, bMaskDWord, tmp_b30 );
+			printk("!!!! UP 3 PACKETS !!!! PATH A dd0[0x%x] < 0x%x, Change b30 = 0x%x!!!!\n\n", 
+					tmp_dd0_a , ss_threshold_L, tmp_b30 );
+
+		}
+	}
+
+	//======= PATH  B ============
+
+	if((tmp_dd0_b >= ss_threshold_H) && (!(tmp_b30 & BIT(23))))
+	{
+		if(priv->pshare->rx_packet_ss_b >= 10)
+			priv->pshare->rx_packet_ss_b = 0;
+		
+		priv->pshare->rx_packet_ss_b = (priv->pshare->rx_packet_ss_b+1); 
+		
+		if(priv->pshare->rx_packet_ss_b > 3)
+			priv->pshare->rx_packet_ss_b = 3; 
+
+		if( priv->pshare->rx_packet_ss_b == 3)
+		{
+			tmp_b30 = (tmp_b30 | BIT(23)) ; 
+			PHY_SetBBReg(priv, 0xb30, bMaskDWord, tmp_b30 );
+			printk("!!!! UP 3 PACKETS !!!! PATH B dd0[0x%x] > 0x%x, Change b30 = 0x%x!!!!\n\n", 
+					tmp_dd0_b , ss_threshold_H, tmp_b30 );
+		}
+			
+	}
+	else if((tmp_dd0_b <= ss_threshold_L) && (tmp_b30 & BIT(23)))
+	{
+		if(priv->pshare->rx_packet_ss_b < 10)
+			priv->pshare->rx_packet_ss_b = 10;
+		
+		priv->pshare->rx_packet_ss_b = (priv->pshare->rx_packet_ss_b+1) ;
+		
+		if(priv->pshare->rx_packet_ss_b > 13)
+			priv->pshare->rx_packet_ss_b = 13; 
+		
+		if(priv->pshare->rx_packet_ss_b == 13)
+		{
+			tmp_b30 = (tmp_b30 & ~(BIT(23))) ; 
+			PHY_SetBBReg(priv, 0xb30, bMaskDWord, tmp_b30 );
+			printk("!!!! UP 3 PACKETS !!!! PATH B dd0[0x%x] < 0x%x, Change b30 = 0x%x!!!!\n\n", 
+					tmp_dd0_b , ss_threshold_L, tmp_b30 );
+		}
+	}
+
+}
+#endif
+
+
 static __inline__ void translate_rssi_sq(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinfo)
 {
 	typedef signed char		s1Byte;
@@ -251,115 +358,193 @@ static __inline__ void translate_rssi_sq(struct rtl8192cd_priv *priv, struct rx_
 		//
 		// (2)PWDB, Average PWDB cacluated by hardware (for rate adaptive)
 		//
-		if (!priv->pshare->phw->reg824_bit9) {
-			report = pCck_buf->cck_agc_rpt & 0xc0;
-			report = report>>6;
-
-			if ((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)) {
-				switch (report) {
-				case 0x3:
-					rx_pwr_all = -46 - (pCck_buf->cck_agc_rpt & 0x3e);
-					break;
-				case 0x2:
-					rx_pwr_all = -26 - (pCck_buf->cck_agc_rpt & 0x3e);
-					break;
-				case 0x1:
-					rx_pwr_all = -12 - (pCck_buf->cck_agc_rpt & 0x3e);
-					break;
-				case 0x0:
-					rx_pwr_all = 16 - (pCck_buf->cck_agc_rpt & 0x3e);
-					break;
+#if defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT)
+		if (
+#ifdef CONFIG_RTL_92C_SUPPORT
+			(GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C) 
+#endif
+#ifdef CONFIG_RTL_92D_SUPPORT
+#ifdef CONFIG_RTL_92C_SUPPORT
+			|| 
+#endif
+			(GET_CHIP_VER(priv) == VERSION_8192D)
+#endif
+			) {
+			if (!priv->pshare->phw->reg824_bit9) {
+				report = pCck_buf->cck_agc_rpt & 0xc0;
+				report = report>>6;
+
+#ifdef CONFIG_RTL_92C_SUPPORT
+				if ((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)) {
+					switch (report) {
+					case 0x3:
+						rx_pwr_all = -46 - (pCck_buf->cck_agc_rpt & 0x3e);
+						break;
+					case 0x2:
+						rx_pwr_all = -26 - (pCck_buf->cck_agc_rpt & 0x3e);
+						break;
+					case 0x1:
+						rx_pwr_all = -12 - (pCck_buf->cck_agc_rpt & 0x3e);
+						break;
+					case 0x0:
+						rx_pwr_all = 16 - (pCck_buf->cck_agc_rpt & 0x3e);
+						break;
+					}
+				} else 
+#endif
+				{
+					switch (report) {
+					//Fixed by Jacken from Bryant 2008-03-20
+					//Original value is -38 , -26 , -14 , -2
+					//Fixed value is -35 , -23 , -11 , 6
+					case 0x3:
+						rx_pwr_all = -35 - (pCck_buf->cck_agc_rpt & 0x3e);
+						break;
+					case 0x2:
+						rx_pwr_all = -23 - (pCck_buf->cck_agc_rpt & 0x3e);
+						break;
+					case 0x1:
+						rx_pwr_all = -11 - (pCck_buf->cck_agc_rpt & 0x3e);
+						break;
+					case 0x0:
+						rx_pwr_all = 8 - (pCck_buf->cck_agc_rpt & 0x3e);
+						break;
+					}
 				}
 			} else {
-				switch (report) {
-				//Fixed by Jacken from Bryant 2008-03-20
-				//Original value is -38 , -26 , -14 , -2
-				//Fixed value is -35 , -23 , -11 , 6
-				case 0x3:
-					rx_pwr_all = -35 - (pCck_buf->cck_agc_rpt & 0x3e);
-					break;
-				case 0x2:
-					rx_pwr_all = -23 - (pCck_buf->cck_agc_rpt & 0x3e);
-					break;
-				case 0x1:
-					rx_pwr_all = -11 - (pCck_buf->cck_agc_rpt & 0x3e);
-					break;
-				case 0x0:
-					rx_pwr_all = 8 - (pCck_buf->cck_agc_rpt & 0x3e);
-					break;
+				report = pCck_buf->cck_agc_rpt & 0x60;
+				report = report>>5;
+
+#ifdef CONFIG_RTL_92C_SUPPORT
+				if ((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)) {
+					switch (report) {
+					case 0x3:
+						rx_pwr_all = -46 - ((pCck_buf->cck_agc_rpt & 0x1f)<<1) ;
+						break;
+					case 0x2:
+						rx_pwr_all = -26 - ((pCck_buf->cck_agc_rpt & 0x1f)<<1);
+						break;
+					case 0x1:
+						rx_pwr_all = -12 - ((pCck_buf->cck_agc_rpt & 0x1f)<<1) ;
+						break;
+					case 0x0:
+						rx_pwr_all = 16 - ((pCck_buf->cck_agc_rpt & 0x1f)<<1) ;
+						break;
+					}
+				} else 
+#endif
+				{
+					switch (report) {
+					//Fixed by Jacken from Bryant 2008-03-20
+					case 0x3:
+						rx_pwr_all = -35 - ((pCck_buf->cck_agc_rpt & 0x1f)<<1);
+						break;
+					case 0x2:
+						rx_pwr_all = -23 - ((pCck_buf->cck_agc_rpt & 0x1f)<<1);
+						break;
+					case 0x1:
+						rx_pwr_all = -11 - ((pCck_buf->cck_agc_rpt & 0x1f)<<1);
+						break;
+					case 0x0:
+						rx_pwr_all = -8 - ((pCck_buf->cck_agc_rpt & 0x1f)<<1);
+						break;
+					}
 				}
 			}
-		} else {
-			report = pCck_buf->cck_agc_rpt & 0x60;
-			report = report>>5;
+			PWDB_ALL = QueryRxPwrPercentage(rx_pwr_all);
 
+#ifdef CONFIG_RTL_92C_SUPPORT
 			if ((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)) {
-				switch (report) {
-				case 0x3:
-					rx_pwr_all = -46 - ((pCck_buf->cck_agc_rpt & 0x1f)<<1) ;
-					break;
-				case 0x2:
-					rx_pwr_all = -26 - ((pCck_buf->cck_agc_rpt & 0x1f)<<1);
-					break;
-				case 0x1:
-					rx_pwr_all = -12 - ((pCck_buf->cck_agc_rpt & 0x1f)<<1) ;
-					break;
-				case 0x0:
-					rx_pwr_all = 16 - ((pCck_buf->cck_agc_rpt & 0x1f)<<1) ;
-					break;
-				}
-			} else {
-				switch (report) {
-				//Fixed by Jacken from Bryant 2008-03-20
-				case 0x3:
-					rx_pwr_all = -35 - ((pCck_buf->cck_agc_rpt & 0x1f)<<1);
-					break;
-				case 0x2:
-					rx_pwr_all = -23 - ((pCck_buf->cck_agc_rpt & 0x1f)<<1);
-					break;
-				case 0x1:
-					rx_pwr_all = -11 - ((pCck_buf->cck_agc_rpt & 0x1f)<<1);
-					break;
-				case 0x0:
-					rx_pwr_all = -8 - ((pCck_buf->cck_agc_rpt & 0x1f)<<1);
-					break;
+				if (priv->pshare->rf_ft_var.use_ext_lna) {
+					if (!(pCck_buf->cck_agc_rpt>>7))
+						PWDB_ALL = (PWDB_ALL>94)?100:(PWDB_ALL + 6);
+					else
+						PWDB_ALL = (PWDB_ALL<16)?0:(PWDB_ALL -16);
+
+					/* CCK Modification */
+					if (PWDB_ALL > 25 && PWDB_ALL <= 60)
+						PWDB_ALL += 6;
+	/*
+					else if (PWDB_ALL <= 25)
+						PWDB_ALL += 8;
+	*/
+				} else {
+					if (PWDB_ALL > 99)
+						PWDB_ALL -= 8;
+					else if (PWDB_ALL > 50 && PWDB_ALL <= 68)
+						PWDB_ALL += 4;
 				}
+
+				pfrinfo->rssi = PWDB_ALL;
+				if (priv->pshare->rf_ft_var.use_ext_lna)
+					pfrinfo->rssi+=10;
+			} else 
+#endif
+			{
+				pfrinfo->rssi = PWDB_ALL;
+				pfrinfo->rssi+=3;
 			}
-		}
 
-		PWDB_ALL = QueryRxPwrPercentage(rx_pwr_all);
+			if (pfrinfo->rssi > 100)
+				pfrinfo->rssi = 100;
+		}
+#endif
 
-		if ((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)) {
-			if (priv->pshare->rf_ft_var.use_ext_lna) {
-				if (!(pCck_buf->cck_agc_rpt>>7))
-					PWDB_ALL = (PWDB_ALL>94)?100:(PWDB_ALL + 6);
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv)==VERSION_8188E) {
+			unsigned int LNA_idx = ((pCck_buf->cck_agc_rpt & 0xE0) >>5);
+			unsigned int VGA_idx = (pCck_buf->cck_agc_rpt & 0x1F); 
+			switch(LNA_idx) {
+			case 7:
+				if(VGA_idx <= 27)
+					rx_pwr_all = -100 + 2*(27-VGA_idx); //VGA_idx = 27~2
 				else
-					PWDB_ALL = (PWDB_ALL<16)?0:(PWDB_ALL -16);
+					rx_pwr_all = -100;
+				break;
+			case 6:
+				rx_pwr_all = -48 + 2*(2-VGA_idx); //VGA_idx = 2~0
+				break;
+			case 5:
+				rx_pwr_all = -42 + 2*(7-VGA_idx); //VGA_idx = 7~5
+				break;
+			case 4:
+				rx_pwr_all = -36 + 2*(7-VGA_idx); //VGA_idx = 7~4
+				break;
+			case 3:
+				//rx_pwr_all = -28 + 2*(7-VGA_idx); //VGA_idx = 7~0
+				rx_pwr_all = -24 + 2*(7-VGA_idx); //VGA_idx = 7~0
+				break;
+			case 2:
+				if(priv->pshare->phw->reg824_bit9)
+					rx_pwr_all = -12 + 2*(5-VGA_idx); //VGA_idx = 5~0
+				else
+					rx_pwr_all = -6+ 2*(5-VGA_idx);
+				break;
+			case 1:
+				rx_pwr_all = 8-2*VGA_idx;
+				break;
+			case 0:
+				rx_pwr_all = 14-2*VGA_idx;
+				break;
+			default:
+				printk("%s %d, CCK Exception default\n", __FUNCTION__, __LINE__);
+				break;
+			}
+			rx_pwr_all += 6;
+			PWDB_ALL = QueryRxPwrPercentage(rx_pwr_all);
 
-				/* CCK Modification */
-				if (PWDB_ALL > 25 && PWDB_ALL <= 60)
-					PWDB_ALL += 6;
-/*
-				else if (PWDB_ALL <= 25)
-					PWDB_ALL += 8;
-*/
-			} else {
-				if (PWDB_ALL > 99)
-					PWDB_ALL -= 8;
-				else if (PWDB_ALL > 50 && PWDB_ALL <= 68)
-					PWDB_ALL += 4;
+			if(!priv->pshare->phw->reg824_bit9) {
+				if(PWDB_ALL >= 80)
+					PWDB_ALL = ((PWDB_ALL-80)<<1)+((PWDB_ALL-80)>>1)+80;
+				else if((PWDB_ALL <= 78) && (PWDB_ALL >= 20))
+					PWDB_ALL += 3;
+				if(PWDB_ALL>100)
+					PWDB_ALL = 100;
 			}
 
 			pfrinfo->rssi = PWDB_ALL;
-			if (priv->pshare->rf_ft_var.use_ext_lna)
-				pfrinfo->rssi+=10;
-		} else {
-			pfrinfo->rssi = PWDB_ALL;
-			pfrinfo->rssi+=3;
 		}
-
-		if (pfrinfo->rssi > 100)
-			pfrinfo->rssi = 100;
+#endif
 
 		//
 		// (3) Get Signal Quality (EVM)
@@ -388,9 +573,21 @@ static __inline__ void translate_rssi_sq(struct rtl8192cd_priv *priv, struct rx_
 		// (1)Get RSSI for HT rate
 		//
 		for (i=RF92CD_PATH_A; i<RF92CD_PATH_MAX; i++) {
-			if ((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C))
+#if defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_88E_SUPPORT)
+			if (
+#ifdef CONFIG_RTL_92C_SUPPORT
+				(GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)
+#endif
+#ifdef CONFIG_RTL_88E_SUPPORT
+#ifdef CONFIG_RTL_92C_SUPPORT
+				||
+#endif
+				(GET_CHIP_VER(priv) == VERSION_8188E)
+#endif
+				)
 				rx_pwr[i] = ((pOfdm_buf->trsw_gain_X[i]&0x3F)*2) - 110;
 			else
+#endif
 				rx_pwr[i] = ((pOfdm_buf->trsw_gain_X[i]&0x3F)*2) - 106;
 
 			//Get Rx snr value in DB
@@ -405,8 +602,18 @@ static __inline__ void translate_rssi_sq(struct rtl8192cd_priv *priv, struct rx_
 			RSSI = QueryRxPwrPercentage(rx_pwr[i]);
 			//total_rssi += RSSI;
 
-			if (((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)) 
-				&& (priv->pshare->rf_ft_var.use_ext_lna)) {
+#if defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_88E_SUPPORT)
+			if ((
+#ifdef CONFIG_RTL_92C_SUPPORT
+				(GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)
+#endif
+#ifdef CONFIG_RTL_88E_SUPPORT
+#ifdef CONFIG_RTL_92C_SUPPORT
+				||
+#endif
+				(GET_CHIP_VER(priv) == VERSION_8188E)
+#endif
+				) && (priv->pshare->rf_ft_var.use_ext_lna)) {
 				if ((pOfdm_buf->trsw_gain_X[i]>>7) == 1)
 					RSSI = (RSSI>94)?100:(RSSI + 6);
 				else
@@ -415,6 +622,7 @@ static __inline__ void translate_rssi_sq(struct rtl8192cd_priv *priv, struct rx_
 				if (RSSI <= 34 && RSSI >= 4)
 					RSSI -= 4;
 			}
+#endif
 
 			/* Record Signal Strength for next packet */
 			//if(bPacketMatchBSSID)
@@ -422,27 +630,52 @@ static __inline__ void translate_rssi_sq(struct rtl8192cd_priv *priv, struct rx_
 				pfrinfo->rf_info.mimorssi[i] = (u1Byte)RSSI;
 			}
 
-			if ((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)) {
+#if defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_88E_SUPPORT)
+			if (
+#ifdef CONFIG_RTL_92C_SUPPORT
+				(GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)
+#endif
+#ifdef CONFIG_RTL_88E_SUPPORT
+#ifdef CONFIG_RTL_92C_SUPPORT
+				||
+#endif
+				(GET_CHIP_VER(priv) == VERSION_8188E)
+#endif
+				) {
 				if (RSSI > ofdm_max_rssi)
 					ofdm_max_rssi = RSSI;
 				if (RSSI < ofdm_min_rssi)
 					ofdm_min_rssi = RSSI;
 			}
+#endif
 		}
 
 		//
 		// (2)PWDB, Average PWDB cacluated by hardware (for rate adaptive)
 		//
-		if ((GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)) {
+#if defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_88E_SUPPORT)
+		if (
+#ifdef CONFIG_RTL_92C_SUPPORT
+			(GET_CHIP_VER(priv) == VERSION_8192C)||(GET_CHIP_VER(priv) == VERSION_8188C)
+#endif
+#ifdef CONFIG_RTL_88E_SUPPORT
+#ifdef CONFIG_RTL_92C_SUPPORT
+			||
+#endif
+			(GET_CHIP_VER(priv) == VERSION_8188E)
+#endif
+			) {
 			if ((ofdm_max_rssi - ofdm_min_rssi) < 3)
 				PWDB_ALL = ofdm_max_rssi;
 			else if ((ofdm_max_rssi - ofdm_min_rssi) < 6)
 				PWDB_ALL = ofdm_max_rssi - 1;
 			else if ((ofdm_max_rssi - ofdm_min_rssi) < 10)
 				PWDB_ALL = ofdm_max_rssi - 2;
-			else 
+			else
 				PWDB_ALL = ofdm_max_rssi - 3;
-		} else {
+		} else 
+#endif
+		{
 			rx_pwr_all = (((pOfdm_buf->pwdb_all ) >> 1 )& 0x7f) -106;
 			PWDB_ALL = QueryRxPwrPercentage(rx_pwr_all);
 		}
@@ -500,23 +733,14 @@ int rtl865x_wlanIF_Init(struct net_device *dev)
 static unsigned int check_mcastL2L3Diff(struct sk_buff *skb)
 {
 	unsigned int DaIpAddr;
-#if defined(__LINUX_2_6__) && !defined(CONFIG_RTL8672)
-	struct iphdr* iph = (struct iphdr *)(skb_mac_header(skb) + ETH_HLEN);
-#else
-	struct iphdr* iph = (struct iphdr *)(skb->mac.raw + ETH_HLEN);
-#endif
+	struct iphdr* iph = SKB_IP_HEADER(skb);
 
 	DaIpAddr = iph->daddr;
 	//printk("ip:%d, %d ,%d ,%d\n",(DaIpAddr>>24) ,(DaIpAddr<<8)>>24,(DaIpAddr<<16)>>24,(DaIpAddr<<24)>>24);
 
 	if (((DaIpAddr & 0xFF000000) >= 0xE0000000) && ((DaIpAddr & 0xFF000000) <= 0xEF000000)) {
-#if defined(__LINUX_2_6__) && !defined(CONFIG_RTL8672)
-		if (!IP_MCAST_MAC(skb_mac_header(skb)))
+		if (!IP_MCAST_MAC(SKB_MAC_HEADER(skb)))
 			return DaIpAddr;
-#else
-		if (!IP_MCAST_MAC(skb->mac.raw))
-			return DaIpAddr;
-#endif
 	}
 	return 0;
 }
@@ -550,12 +774,8 @@ static void CheckUDPandU2M(struct sk_buff *pskb)
 		ConvertMCastIPtoMMac(MultiIP, mactmp);
 		//printk("%02x%02x%02x:%02x%02x%02x\n", mactmp[0],mactmp[1],mactmp[2],
 		//      mactmp[3],mactmp[4],mactmp[5]);
-#if defined(__LINUX_2_6__) && !defined(CONFIG_RTL8672)
-		memcpy(skb_mac_header(pskb), mactmp, 6);
-#else
-		memcpy(pskb->mac.raw, mactmp, 6);
-#endif
-#if defined(__LINUX_2_6__) 
+		memcpy(SKB_MAC_HEADER(pskb), mactmp, 6);
+#if defined(__LINUX_2_6__)
 		/*added by qinjunjie,warning:should not remove next line*/
 		pskb->pkt_type = PACKET_MULTICAST;
 #endif
@@ -564,26 +784,26 @@ static void CheckUDPandU2M(struct sk_buff *pskb)
 
 static void CheckV6UDPandU2M(struct sk_buff *pskb)
 {
-#if defined(__LINUX_2_6__) && !defined(CONFIG_RTL8672)
+#if defined(__LINUX_2_6__) //&& !defined(CONFIG_RTL8672)
 	struct ipv6hdr *iph = (struct ipv6hdr *)(skb_mac_header(pskb) + ETH_HLEN);
-	unsigned char *DDA=skb_mac_header(pskb);	
+	unsigned char *DDA=skb_mac_header(pskb);
 #else
 	struct ipv6hdr *iph = (struct ipv6hdr *)(pskb->mac.raw + ETH_HLEN);
-	unsigned char *DDA=pskb->mac.raw;	
+	unsigned char *DDA=pskb->mac.raw;
 #endif
 
 
-	/*ip(v6) format is  multicast ip*/ 
+	/*ip(v6) format is  multicast ip*/
 	if (iph->daddr.s6_addr[0] == 0xff){
 
-		/*mac is not ipv6 multicase mac*/ 
-		if(!ICMPV6_MCAST_MAC(DDA) ){	
-			/*change mac (DA) to (ipv6 multicase mac) format by (ipv6 multicast ip)*/ 
+		/*mac is not ipv6 multicase mac*/
+		if(!ICMPV6_MCAST_MAC(DDA) ){
+			/*change mac (DA) to (ipv6 multicase mac) format by (ipv6 multicast ip)*/
 			DDA[0] = 0x33;
-			DDA[1] = 0x33;			
-			memcpy(DDA+2, &iph->daddr.s6_addr[12], 4);			
+			DDA[1] = 0x33;
+			memcpy(DDA+2, &iph->daddr.s6_addr[12], 4);
 		}
-	}	
+	}
 }
 #endif
 
@@ -603,15 +823,15 @@ static void add_a4_client(struct rtl8192cd_priv *priv, struct stat_info *pstat)
 		sta = list_entry(plist, struct stat_info, a4_sta_list);
 		if (!memcmp(sta->hwaddr, pstat->hwaddr, WLAN_ADDR_LEN)) {
 			ASSERT(pstat == sta);
-			break;		
+			break;
 		}
 		plist = plist->next;
 	}
 
-	if (plist == phead)	
-		list_add_tail(&pstat->a4_sta_list, &priv->a4_sta_list);	
-	
-	pstat->state |= WIFI_A4_STA;	
+	if (plist == phead)
+		list_add_tail(&pstat->a4_sta_list, &priv->a4_sta_list);
+
+	pstat->state |= WIFI_A4_STA;
 }
 #endif
 
@@ -619,14 +839,23 @@ static void add_a4_client(struct rtl8192cd_priv *priv, struct stat_info *pstat)
 #ifdef CONFIG_RTL8672
 extern struct net_device *get_eth_cached_dev(unsigned char *da);
 #else
-#if defined(CONFIG_RTL_819X) && defined(__LINUX_2_6__)
+#ifdef CONFIG_RTL_819X
 __inline__ struct net_device *get_eth_cached_dev(unsigned char *da)
 {
 	extern unsigned char cached_eth_addr[MACADDRLEN];
 	extern struct net_device *cached_dev;
 
+#ifdef BR_SHORTCUT_C2
+	extern unsigned char cached_eth_addr2[MACADDRLEN];
+	extern struct net_device *cached_dev2;
+#endif
+
 	if (cached_dev && !memcmp(da, cached_eth_addr, MACADDRLEN))
 		return cached_dev;
+#ifdef BR_SHORTCUT_C2
+	else if (cached_dev2 && !memcmp(da, cached_eth_addr2, MACADDRLEN))
+		return cached_dev2;
+#endif
 	else
 		return NULL;
 }
@@ -646,17 +875,32 @@ __MIPS16
 __IRAM_IN_865X
 void rtl_netif_rx(struct rtl8192cd_priv *priv, struct sk_buff *pskb, struct stat_info *pstat)
 {
+#ifdef PREVENT_BROADCAST_STORM
+    if ((OPMODE & WIFI_AP_STATE) && ((unsigned char)pskb->data[0] == 0xff) && pstat) {
+        if (pstat->rx_pkts_bc > BROADCAST_STORM_THRESHOLD) {
+            priv->ext_stats.rx_data_drops++;
+            DEBUG_ERR("RX DROP: Broadcast storm happened!\n");
+            rtl_kfree_skb(priv, pskb, _SKB_RX_);
+            return;
+        }
+    }
+#endif
+
+#ifdef CONFIG_RTK_VLAN_WAN_TAG
+	extern int rtl865x_same_root(struct net_device *dev1,struct net_device *dev2);
+#endif
+
 #if defined(CONFIG_RTL_CUSTOM_PASSTHRU)
 	if (SUCCESS==rtl_isPassthruFrame(pskb->data)) {
 		#if defined(CONFIG_RTL_92D_SUPPORT)
 		unsigned int wispWlanIndex=(passThruStatusWlan&WISP_WLAN_IDX_MASK)>>WISP_WLAN_IDX_RIGHT_SHIFT;
 		if(	priv && (priv == wlan_device[wispWlanIndex].priv)&&
-			(((GET_MIB(priv))->dot11OperationEntry.opmode)& WIFI_STATION_STATE)) 
+			(((GET_MIB(priv))->dot11OperationEntry.opmode)& WIFI_STATION_STATE))
 		#endif
 		{
 			pskb->dev = wlan_device[passThruWanIdx].priv->pWlanDev;
 		}
-	
+
 	}
 #endif
 
@@ -664,12 +908,12 @@ void rtl_netif_rx(struct rtl8192cd_priv *priv, struct sk_buff *pskb, struct stat
 #ifdef SUPPORT_RX_UNI2MCAST
 	unsigned short L3_protocol;
 	unsigned char *DA_START;
-#endif	
+#endif
 #ifdef VIDEO_STREAMING_REFINE
 	// for video streaming refine
 	extern struct net_device *is_eth_streaming_only(struct sk_buff *skb);
 	struct net_device *dev;
-#endif	
+#endif
 #endif
 
 #ifdef CONFIG_RTL8672
@@ -766,6 +1010,41 @@ void rtl_netif_rx(struct rtl8192cd_priv *priv, struct sk_buff *pskb, struct stat
 	else
 #endif
 	{
+#ifdef CONFIG_RTK_VLAN_SUPPORT
+        if (rtk_vlan_support_enable && priv->pmib->vlan.global_vlan) {
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+                if (rx_vlan_process(priv->dev, &priv->pmib->vlan, pskb, NULL)){
+#else
+                if (rx_vlan_process(priv->dev, &priv->pmib->vlan, pskb)){
+#endif
+                        priv->ext_stats.rx_data_drops++;
+                        DEBUG_ERR("RX DROP: by vlan!\n");
+                        rtl_kfree_skb(priv, pskb, _SKB_RX_);
+                        return;
+                }
+
+#if defined(CONFIG_RTK_VLAN_FOR_CABLE_MODEM)
+                if(rtk_vlan_support_enable == 2 && pskb->tag.f.tpid ==  htons(ETH_P_8021Q))
+                {
+                        struct net_device *toDev;
+
+                        toDev = re865x_get_netdev_by_name("eth1");
+
+                        //printk("===%s(%d),vid(%d),from(%s),todev(%s),skb->tag.vid(%d)\n",__FUNCTION__,__LINE__,pskb->tag.f.pci & 0xfff, pskb->dev->name,
+                                //toDev?toDev->name:NULL,pskb->tag.f.pci & 0xfff);
+
+                        if(toDev)
+                        {
+                                pskb->dev = toDev;
+                                toDev->netdev_ops->ndo_start_xmit(pskb,toDev);
+                                return;
+                        }
+
+                }
+#endif
+        }
+#endif
+
 #if defined(BR_SHORTCUT)
 	{
 		struct net_device *cached_dev=NULL;
@@ -797,6 +1076,38 @@ void rtl_netif_rx(struct rtl8192cd_priv *priv, struct sk_buff *pskb, struct stat
 		if ((OPMODE & WIFI_STATION_STATE) && pskb->dev) {
 			memcpy(cached_sta_mac, &pskb->data[6], 6);
 			cached_sta_dev = pskb->dev;
+	
+			   if (!(pskb->data[0] & 0x01) &&
+				 !priv->pmib->dot11OperationEntry.disable_brsc &&
+				 (priv->dev->br_port)  &&
+				 ((cached_dev=get_shortcut_dev(pskb->data)) !=NULL) 
+				 && netif_running(cached_dev)){
+				 pskb->dev = cached_dev;
+#if !defined(__LINUX_2_6__) || defined(CONFIG_COMPAT_NET_DEV_OPS)
+				 cached_dev->hard_start_xmit(pskb, cached_dev);
+#else
+				 cached_dev->netdev_ops->ndo_start_xmit(pskb,cached_dev);
+#endif
+				 return;
+				 
+			   }
+		}
+		/*AP mode side -> Client mode side*/
+		if ((OPMODE & WIFI_AP_STATE) && pskb->dev) {
+			if (!(pskb->data[0] & 0x01) &&
+				 !priv->pmib->dot11OperationEntry.disable_brsc &&
+				 (priv->dev->br_port)  &&
+				 (!memcmp(cached_sta_mac,pskb->data,6)) &&
+				 (cached_sta_dev !=NULL) 
+				 && netif_running(cached_sta_dev)) {
+					 pskb->dev = cached_sta_dev;
+#if !defined(__LINUX_2_6__) || defined(CONFIG_COMPAT_NET_DEV_OPS)
+					 cached_sta_dev->hard_start_xmit(pskb, cached_sta_dev);
+#else
+					 cached_sta_dev->netdev_ops->ndo_start_xmit(pskb,cached_sta_dev);
+#endif
+					 return;
+				}
 		}
 #endif
 #ifdef WDS
@@ -804,19 +1115,22 @@ void rtl_netif_rx(struct rtl8192cd_priv *priv, struct sk_buff *pskb, struct stat
 #endif
 		if (!(pskb->data[0] & 0x01) &&
 				!priv->pmib->dot11OperationEntry.disable_brsc &&
-#if defined(CONFIG_DOMAIN_NAME_QUERY_SUPPORT)			
+#if defined(CONFIG_DOMAIN_NAME_QUERY_SUPPORT) || defined(CONFIG_RTL_ULINKER)
 				(pskb->data[37] != 68) && /*port 68 is dhcp dest port. In order to hack dns ip, so dhcp packa                                                            can't enter bridge short cut.*/
-#endif	
-#ifndef _SINUX_ // if sinux, no linux bridge, so should don't depend on br_port if use br_shortcut (John Qian 2010/6/24) 
+#endif
+#ifndef _SINUX_ // if sinux, no linux bridge, so should don't depend on br_port if use br_shortcut (John Qian 2010/6/24)
 				(priv->dev->br_port) &&
 #else
                 (g_sc_enable_brsc) &&
 #endif
-#if defined(CONFIG_RTL_819X) && defined(__LINUX_2_6__)		
+#ifdef CONFIG_RTL_819X
 				((cached_dev = get_eth_cached_dev(pskb->data)) != NULL)
 #else
 				cached_dev
 #endif
+#ifdef CONFIG_RTK_VLAN_WAN_TAG
+				&& rtl865x_same_root(pskb->dev,cached_dev)
+#endif
 				&&
 				netif_running(cached_dev)) {
 			pskb->dev = cached_dev;
@@ -829,6 +1143,12 @@ void rtl_netif_rx(struct rtl8192cd_priv *priv, struct sk_buff *pskb, struct stat
 		}
 	}
 #endif // BR_SHORTCUT
+	 #if defined(CONFIG_RTL_FASTBRIDGE)
+	 	if (priv->dev->br_port) {
+			if (RTL_FB_RETURN_SUCCESS==rtl_fb_process_in_nic(pskb, pskb->dev))
+				return;
+	 	}
+	#endif
 
 #ifdef MBSSID
 	if ((OPMODE & WIFI_AP_STATE) && pskb->dev && (pskb->dev->base_addr != 0)) {
@@ -837,37 +1157,6 @@ void rtl_netif_rx(struct rtl8192cd_priv *priv, struct sk_buff *pskb, struct stat
 	}
 #endif
 
-#ifdef CONFIG_RTK_VLAN_SUPPORT
-	if (rtk_vlan_support_enable && priv->pmib->vlan.global_vlan) {
-		if (rx_vlan_process(priv->dev, &priv->pmib->vlan, pskb)){
-			priv->ext_stats.rx_data_drops++;
-			DEBUG_ERR("RX DROP: by vlan!\n");
-			rtl_kfree_skb(priv, pskb, _SKB_RX_);
-			return;
-		}
-
-#if defined(CONFIG_RTK_VLAN_FOR_CABLE_MODEM)
-		if(rtk_vlan_support_enable == 2 && pskb->tag.f.tpid ==  htons(ETH_P_8021Q))
-		{
-			struct net_device *toDev;
-
-			toDev = re865x_get_netdev_by_name("eth1");
-			
-			//printk("===%s(%d),vid(%d),from(%s),todev(%s),skb->tag.vid(%d)\n",__FUNCTION__,__LINE__,pskb->tag.f.pci & 0xfff, pskb->dev->name,
-				//toDev?toDev->name:NULL,pskb->tag.f.pci & 0xfff);
-
-			if(toDev)
-			{
-				pskb->dev = toDev;
-				toDev->netdev_ops->ndo_start_xmit(pskb,toDev);
-				return;
-			}
-			
-		}
-#endif
-	}	
-#endif
-
 	if (pskb->dev)
 #ifdef __LINUX_2_6__
 		pskb->protocol = eth_type_trans(pskb, pskb->dev);
@@ -888,50 +1177,32 @@ void rtl_netif_rx(struct rtl8192cd_priv *priv, struct sk_buff *pskb, struct stat
 	/* under sta mode for check UDP type packet that L3 IP is multicast but L2 mac is not */
 	if (((OPMODE & WIFI_STATION_STATE) == WIFI_STATION_STATE))
 	{
-#if defined(__LINUX_2_6__) && !defined(CONFIG_RTL8672)
-		L3_protocol = *(unsigned short *)(skb_mac_header(pskb) + MACADDRLEN * 2);	
-		DA_START =skb_mac_header(pskb);			
+		L3_protocol = *(unsigned short *)(SKB_MAC_HEADER(pskb) + MACADDRLEN * 2);
+		DA_START = SKB_MAC_HEADER(pskb);
 		if( L3_protocol == __constant_htons(0x0800) )
 		//&&(*(unsigned char *)(skb_mac_header(pskb) + 23)) == 0x11) { /*added by qinjunjie,warning:unicast to multicast conversion should not only limited to udp*/
 		{
-		        CheckUDPandU2M(pskb);
+		    CheckUDPandU2M(pskb);
 		}else if(L3_protocol == __constant_htons(0x86dd) &&
-			*(unsigned char *)(skb_mac_header(pskb) + 20) == 0x11 )
+			*(unsigned char *)(SKB_MAC_HEADER(pskb) + 20) == 0x11 )
 		{
 			CheckV6UDPandU2M(pskb);
-	        }
-
-#else
-		L3_protocol = *(unsigned short *)(pskb->mac.raw + MACADDRLEN * 2);	
-		DA_START = pskb->mac.raw;
-
-		if( L3_protocol == __constant_htons(0x0800) 
-			&& (*(unsigned char *)(pskb->mac.raw + 23)) == 0x11 ) 
-		{
-		CheckUDPandU2M(pskb);
-		}else if(L3_protocol == __constant_htons(0x86dd) &&
-			*(unsigned char *)(pskb->mac.raw + 20) == 0x11 )
-		{
-			CheckV6UDPandU2M(pskb);
-	        }
-
-#endif
+	    }
 	}
 
-
 #ifdef BR_SHORTCUT
 #ifdef VIDEO_STREAMING_REFINE
 	// for video streaming refine
 	if ((OPMODE & WIFI_STATION_STATE) &&
 #if defined(__LINUX_2_6__) && !defined(CONFIG_RTL8672)
 		(*((unsigned char *)(skb_mac_header(pskb) + 0)) & 0x01) &&
-#else		
-		(*((unsigned char *)pskb->mac.raw) & 0x01) && 
+#else
+		(*((unsigned char *)pskb->mac.raw) & 0x01) &&
 #endif
 		!priv->pmib->dot11OperationEntry.disable_brsc &&
 		(priv->dev->br_port) &&
-		((dev = is_eth_streaming_only(pskb)) != NULL)) {			
-			skb_push(pskb, 14);			
+		((dev = is_eth_streaming_only(pskb)) != NULL)) {
+			skb_push(pskb, 14);
 #if !defined(__LINUX_2_6__) || defined(CONFIG_COMPAT_NET_DEV_OPS)
 			dev->hard_start_xmit(pskb, dev);
 #else
@@ -1006,7 +1277,9 @@ static int GBWC_forward_check(struct rtl8192cd_priv *priv, struct sk_buff *pskb,
 
 
 __MIPS16
+#ifndef CONFIG_ETHWAN
 __IRAM_IN_865X
+#endif
 static void reorder_ctrl_pktout(struct rtl8192cd_priv *priv, struct sk_buff *pskb, struct stat_info *pstat)
 {
 //Joule 2009.03.10
@@ -1022,7 +1295,7 @@ static void reorder_ctrl_pktout(struct rtl8192cd_priv *priv, struct sk_buff *psk
 		if (GET_MIB(priv)->dot1180211sInfo.mesh_enable && isMeshPoint(pstat) && isMeshPoint(dst_pstat)){
         	DECLARE_TXINSN(txinsn);
 			memcpy(txinsn.nhop_11s, dst_pstat->hwaddr, MACADDRLEN);
-			txinsn.is_11s = 8;
+			txinsn.is_11s = RELAY_11S;
 			fire_data_frame(pskb, priv->mesh_dev, &txinsn);
 		} else
 	#endif
@@ -1036,7 +1309,9 @@ static void reorder_ctrl_pktout(struct rtl8192cd_priv *priv, struct sk_buff *psk
 
 
 __MIPS16
+#ifndef CONFIG_ETHWAN
 __IRAM_IN_865X
+#endif
 static void reorder_ctrl_consumeQ(struct rtl8192cd_priv *priv, struct stat_info *pstat, unsigned char tid, int seg)
 {
 	int win_start, win_size;
@@ -1068,7 +1343,9 @@ static void reorder_ctrl_consumeQ(struct rtl8192cd_priv *priv, struct stat_info
 
 
 __MIPS16
+#ifndef CONFIG_ETHWAN
 __IRAM_IN_865X
+#endif
 static int reorder_ctrl_timer_add(struct rtl8192cd_priv *priv, struct stat_info *pstat, int tid, int from_timeout)
 {
 	unsigned int now, timeout, new_timer=0;
@@ -1134,8 +1411,9 @@ static int reorder_ctrl_timer_add(struct rtl8192cd_priv *priv, struct stat_info
 	return current_idx;
 }
 
-
+#ifndef CONFIG_ETHWAN
 __IRAM_IN_865X
+#endif
 void reorder_ctrl_timeout(unsigned long task_priv)
 {
 	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *)task_priv;
@@ -1262,7 +1540,9 @@ int check_win_seqment(unsigned short win_start, unsigned short win_end, unsigned
 
 
 __MIPS16
+#ifndef CONFIG_ETHWAN
 __IRAM_IN_865X
+#endif
 static int reorder_ctrl_check(struct rtl8192cd_priv *priv, struct stat_info *pstat, struct rx_frinfo *pfrinfo)
 {
 	unsigned short	seq;
@@ -1433,7 +1713,9 @@ unsigned char rfc1042_header[WLAN_LLC_HEADER_SIZE]={0xaa,0xaa,0x03,00,00,00};
 	-1:	can't do shortcut, data path should be continued
  ---------------------------------------------------------------*/
 __MIPS16
+#ifndef CONFIG_ETHWAN
 __IRAM_IN_865X
+#endif
 int rx_shortcut(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinfo)
 {
 //	unsigned long flags=0;
@@ -1489,25 +1771,24 @@ int rx_shortcut(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinfo)
 	if (pstat && (pstat->rx_payload_offset > 0) &&
 		(GetFragNum(pframe) == 0) && (GetMFrag(pframe) == 0))
 	{
-		privacy = GetPrivacy(pframe); 
-        memcpy(da, pfrinfo->da, MACADDRLEN); 
-    
-#ifdef CLIENT_MODE 
-        if (IS_MCAST(da)) 
-        { 
-			tpcache = GetTupleCache(pframe); 
-            if (tpcache == pstat->tpcache_mcast) 
-            { 
-				priv->ext_stats.rx_decache++; 
-                rtl_kfree_skb(priv, pfrinfo->pskb, _SKB_RX_); 
-                SNMP_MIB_INC(dot11FrameDuplicateCount, 1); 
-                return 0; 
-            } 
-        } 
-        else 
-#endif 
-        { 
+		privacy = GetPrivacy(pframe);
+        memcpy(da, pfrinfo->da, MACADDRLEN);
 
+#ifdef CLIENT_MODE
+        if (IS_MCAST(da))
+        {
+            tpcache = GetTupleCache(pframe);
+            if (tpcache == pstat->tpcache_mcast)
+            {
+                priv->ext_stats.rx_decache++;
+                rtl_kfree_skb(priv, pfrinfo->pskb, _SKB_RX_);
+                SNMP_MIB_INC(dot11FrameDuplicateCount, 1);
+                return 0;
+            }
+        }
+        else
+#endif
+		{
 			tpcache = GetTupleCache(pframe);
 			pos = GetSequence(pframe) & (TUPLE_WINDOW - 1);
 			if (tpcache == pstat->tpcache[pfrinfo->tid][pos]) {
@@ -1524,6 +1805,7 @@ int rx_shortcut(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinfo)
 		{
 
 #if defined(CONFIG_RTK_MESH) && defined(RX_RL_SHORTCUT)
+			extern void mesh_shortcut_update(DRV_PRIV *priv, struct rx_frinfo *pfrinfo);
 
 			if (pfrinfo->is_11s) {
 
@@ -1586,9 +1868,9 @@ int rx_shortcut(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinfo)
 #endif
 
 #ifdef A4_STA
-			if (pfrinfo->to_fr_ds == 3 && (pstat->state & WIFI_A4_STA)) {				
+			if (pfrinfo->to_fr_ds == 3 && (pstat->state & WIFI_A4_STA)) {
 				if (memcmp(GetAddr4Ptr(pframe), pstat->rx_wlanhdr.wlanhdr.addr4, 6))
-					return -1;				
+					return -1;
 				a4_sta_add(priv, pstat, GetAddr4Ptr(pframe));
 			}
 #endif
@@ -1668,6 +1950,12 @@ int rx_shortcut(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinfo)
 			update_sta_rssi(priv, pstat, pfrinfo);
 
 #ifdef DETECT_STA_EXISTANCE
+#ifdef CONFIG_RTL_88E_SUPPORT
+			if (GET_CHIP_VER(priv)==VERSION_8188E) {
+				if (pstat->leave!= 0)
+					RTL8188E_MACID_NOLINK(priv, 0, REMAP_AID(pstat));
+	        }
+#endif
 			pstat->leave = 0;
 #endif
 
@@ -1728,9 +2016,9 @@ int rx_shortcut(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinfo)
 				dst_pstat = get_stainfo(priv, da);
 
 #ifdef A4_STA
-				if (priv->pshare->rf_ft_var.a4_enable && (dst_pstat == NULL)) 
+				if (priv->pshare->rf_ft_var.a4_enable && (dst_pstat == NULL))
 					dst_pstat = a4_sta_lookup(priv, da);
-#endif				
+#endif
 
 #if defined(CONFIG_RTK_MESH) ||  defined(WDS)
 				if ((pfrinfo->to_fr_ds==3) ||
@@ -1747,7 +2035,7 @@ int rx_shortcut(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinfo)
 						DECLARE_TXINSN(txinsn);
 						memcpy(txinsn.nhop_11s, pEntry->nexthopMAC, MACADDRLEN);
 						(int)(*(meshHdrPtr+1))--;
-						txinsn.is_11s = 8;
+						txinsn.is_11s = RELAY_11S;
 						if ((priv->pmib->dot11BssType.net_work_type & WIRELESS_11N) &&
 						  priv->pmib->reorderCtrlEntry.ReorderCtrlEnable) {
 							*(unsigned int *)&(pfrinfo->pskb->cb[4]) = dst_pstat;
@@ -1816,11 +2104,32 @@ int rx_shortcut(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinfo)
 				return 0;
 			}
 #ifdef CLIENT_MODE
-			else if (OPMODE & (WIFI_STATION_STATE | WIFI_ADHOC_STATE))
-			{
+			else if (OPMODE & (WIFI_STATION_STATE | WIFI_ADHOC_STATE)) {
 				priv->rxDataNumInPeriod++;
-				if (IS_MCAST(pfrinfo->pskb->data))
+				if (IS_MCAST(pfrinfo->pskb->data)) {
 					priv->rxMlcstDataNumInPeriod++;
+				} else if ((OPMODE & WIFI_STATION_STATE) && (priv->ps_state)) {
+					if ((GetFrameSubType(pframe) == WIFI_DATA)
+#ifdef WIFI_WMM
+						||(QOS_ENABLE && pstat->QosEnabled && (GetFrameSubType(pframe) == WIFI_QOS_DATA))
+#endif
+						) {
+						if (GetMData(pframe)) {
+#if defined(WIFI_WMM) && defined(WMM_APSD)
+							if (QOS_ENABLE && APSD_ENABLE && priv->uapsd_assoc) {
+								if (!((priv->pmib->dot11QosEntry.UAPSD_AC_BE && ((pfrinfo->tid == 0) || (pfrinfo->tid == 3))) ||
+									(priv->pmib->dot11QosEntry.UAPSD_AC_BK && ((pfrinfo->tid == 1) || (pfrinfo->tid == 2))) ||
+									(priv->pmib->dot11QosEntry.UAPSD_AC_VI && ((pfrinfo->tid == 4) || (pfrinfo->tid == 5))) ||
+									(priv->pmib->dot11QosEntry.UAPSD_AC_VO && ((pfrinfo->tid == 6) || (pfrinfo->tid == 7)))))
+									issue_PsPoll(priv);
+							} else
+#endif
+							{
+								issue_PsPoll(priv);
+							}
+						}
+					}
+				}
 
 #ifdef RTK_BR_EXT
 				if (!priv->pmib->ethBrExtInfo.nat25sc_disable &&
@@ -1837,7 +2146,9 @@ int rx_shortcut(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinfo)
 				}
 #endif
 				if ((priv->pmib->dot11BssType.net_work_type & WIRELESS_11N) &&
-					priv->pmib->reorderCtrlEntry.ReorderCtrlEnable) {
+					priv->pmib->reorderCtrlEntry.ReorderCtrlEnable &&
+					!IS_MCAST(pfrinfo->pskb->data))
+				{
 					*(unsigned int *)&(pfrinfo->pskb->cb[4]) = 0;
 					if (reorder_ctrl_check(priv, pstat, pfrinfo))
 						rtl_netif_rx(priv, pfrinfo->pskb, pstat);
@@ -1982,6 +2293,12 @@ static int rtl8192cd_rx_procNullPkt(struct rtl8192cd_priv *priv, struct rx_frinf
 		update_sta_rssi(priv, pstat, pfrinfo);
 
 #ifdef DETECT_STA_EXISTANCE
+#ifdef CONFIG_RTL_88E_SUPPORT
+        if (GET_CHIP_VER(priv)==VERSION_8188E) {
+            if (pstat->leave!= 0)
+                RTL8188E_MACID_NOLINK(priv, 0, REMAP_AID(pstat));
+        }
+#endif
 		pstat->leave = 0;
 #endif
 
@@ -2052,7 +2369,7 @@ static void rtl8192cd_rx_handle_Spec_Null_Data(struct rtl8192cd_priv *priv, stru
 	if (pstat==NULL) {
 		goto out;
 	}
-	
+
 	pframe = get_pframe(pfrinfo);
 	if ((!GetPwrMgt(pframe)) && (GetTupleCache(pframe) == 0) // because this is special case for AR5007, so use GetTupleCache with Seq-Num and Frag-Num, GetSequenceis also ok
 		 && (OPMODE & WIFI_AP_STATE) && (IS_BSSID(priv, GetAddr1Ptr(pframe))))
@@ -2306,7 +2623,7 @@ put_in_que:
 		reuse = 1;
 
 out:
-	
+
 	/* update priv's point */
 	*priv_p = priv;
 	rx_sum_up(priv, NULL, pfrinfo->pktlen, retry);
@@ -2476,7 +2793,7 @@ static inline int rtl8192cd_rx_dispatch_toDs(struct rtl8192cd_priv **priv_p, 	st
 		reuse = 1;
 
 out:
-	
+
 	/* update priv's point */
 	*priv_p = priv;
 	rx_sum_up(priv, NULL, pfrinfo->pktlen,retry);
@@ -2515,24 +2832,24 @@ static int rtl8192cd_rx_dispatch_wds(struct rtl8192cd_priv *priv, struct rx_frin
 	if (dev==NULL) {
 #ifdef LAZY_WDS
 		if (priv->pmib->dot11WdsInfo.wdsEnabled == WDS_LAZY_ENABLE) {
-			if (add_wds_entry(priv, 0, GetAddr2Ptr(pframe))) {				
+			if (add_wds_entry(priv, 0, GetAddr2Ptr(pframe))) {
 				dev = getWdsDevByAddr(priv, GetAddr2Ptr(pframe));
 				if (dev == NULL) {
 					DEBUG_ERR("Rx a WDS packet but which TA is not valid, drop it!\n");
 					goto out;
 				}
-				LOG_MSG("Add a wds entry - %02X:%02X:%02X:%02X:%02X:%02X\n",			
+				LOG_MSG("Add a wds entry - %02X:%02X:%02X:%02X:%02X:%02X\n",
 					*GetAddr2Ptr(pframe), *(GetAddr2Ptr(pframe)+1), *(GetAddr2Ptr(pframe)+2), *(GetAddr2Ptr(pframe)+3),
-					*(GetAddr2Ptr(pframe)+4), *(GetAddr2Ptr(pframe)+5));				
+					*(GetAddr2Ptr(pframe)+4), *(GetAddr2Ptr(pframe)+5));
 			}
 			else {
 				DEBUG_ERR("Rx a WDS packet but wds table is full, drop it!\n");
-				goto out;				
+				goto out;
 			}
 		}
 		else
 #endif
-		{		
+		{
 					DEBUG_ERR("Rx a WDS packet but which TA is not valid, drop it!\n");
 					goto out;
 				}
@@ -2758,14 +3075,14 @@ int validate_mpdu(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinfo)
 #ifdef CONFIG_RTK_MESH
 			if( 1 == GET_MIB(priv)->dot1180211sInfo.mesh_enable)
 			{
-				reuse = rtl8190_rx_dispatch_mesh(priv, pfrinfo);
+				reuse = rx_dispatch_mesh(priv, pfrinfo);
 				break;
 			}
 #endif
 
 #ifdef A4_STA
 			if (priv->pshare->rf_ft_var.a4_enable) {
-	
+
 				reuse = rtl8192cd_rx_dispatch_toDs(&priv, pfrinfo
 #ifdef MBSSID
 											 ,vap_idx
@@ -2833,10 +3150,18 @@ void rtl8192cd_rx_tkl_isr(unsigned long task_priv)
 #else
 	SAVE_INT_AND_CLI(x);
 	SMP_LOCK(x);
-	//RTL_W32(HIMR, RTL_R32(HIMR) | (HIMR_RXFOVW| HIMR_RDU | HIMR_ROK));
-	RTL_W32(HIMR, RTL_R32(HIMR) | (HIMR_RXFOVW | HIMR_ROK));
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv)==VERSION_8188E) {
+		RTL_W32(REG_88E_HIMR, priv->pshare->InterruptMask);
+		RTL_W32(REG_88E_HIMRE, priv->pshare->InterruptMaskExt);
+	} else
 #endif
-	
+	{
+		//RTL_W32(HIMR, RTL_R32(HIMR) | (HIMR_RXFOVW| HIMR_RDU | HIMR_ROK));
+		RTL_W32(HIMR, RTL_R32(HIMR) | (HIMR_RXFOVW | HIMR_ROK));
+	}
+#endif
+
 #ifdef DELAY_REFILL_RX_BUF
 	priv->pshare->has_triggered_rx_tasklet = 2; // indicate as ISR in service
 #endif
@@ -2846,7 +3171,15 @@ void rtl8192cd_rx_tkl_isr(unsigned long task_priv)
 	priv->pshare->has_triggered_rx_tasklet = 0;
 
 #if defined(__LINUX_2_6__)
-	RTL_W32(HIMR, priv->pshare->InterruptMask);
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv)==VERSION_8188E) {
+		RTL_W32(REG_88E_HIMR, priv->pshare->InterruptMask);
+		RTL_W32(REG_88E_HIMRE, priv->pshare->InterruptMaskExt);
+	} else
+#endif
+	{
+		RTL_W32(HIMR, priv->pshare->InterruptMask);
+	}
 	SMP_UNLOCK(x);
 #else
 	RESTORE_INT(x);
@@ -2893,7 +3226,15 @@ int refill_rx_ring(struct rtl8192cd_priv *priv, struct sk_buff *skb, unsigned ch
 		init_rxdesc(new_skb, phw->cur_rx_refill, priv);
 		//phw->cur_rx_refill = (phw->cur_rx_refill + 1) % NUM_RX_DESC;
 		phw->cur_rx_refill = ((phw->cur_rx_refill+1)==NUM_RX_DESC)?0:phw->cur_rx_refill+1;
-		RTL_W32(HISR,(HIMR_RXFOVW | HIMR_RDU));
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv)==VERSION_8188E) {
+			RTL_W32(REG_88E_HISR, HIMR_88E_RDU);
+			RTL_W32(REG_88E_HISRE, HIMRE_88E_RXFOVW);
+		} else
+#endif
+		{
+			RTL_W32(HISR,(HIMR_RXFOVW | HIMR_RDU));
+		}
 #if defined(__LINUX_2_6__) && defined(RX_TASKLET)
 		RESTORE_INT(x);
 		SMP_UNLOCK_SKB(x);
@@ -2921,10 +3262,10 @@ void flush_rx_list(struct rtl8192cd_priv *priv)
 
 	phead = &priv->pshare->gather_list;
 	if (!phead) {
-		RESTORE_INT(flags);		
+		RESTORE_INT(flags);
 		return;
 	}
-	
+
 	plist = phead->next;
 	while (plist != phead) {
 		pfrinfo = list_entry(plist, struct rx_frinfo, rx_list);
@@ -2932,7 +3273,7 @@ void flush_rx_list(struct rtl8192cd_priv *priv)
 			rtl_kfree_skb(priv, pfrinfo->pskb, _SKB_RX_);
 		plist = plist->next;
 	}
-	INIT_LIST_HEAD(&priv->pshare->gather_list);	
+	INIT_LIST_HEAD(&priv->pshare->gather_list);
 
 	RESTORE_INT(flags);
 }
@@ -2953,11 +3294,11 @@ static int search_first_segment(struct rtl8192cd_priv *priv, struct rx_frinfo **
 		plist = phead->next;
 
 	while (phead && plist != phead) {
-		pfrinfo = list_entry(plist, struct rx_frinfo, rx_list);		
-		plist = plist->next;		
+		pfrinfo = list_entry(plist, struct rx_frinfo, rx_list);
+		plist = plist->next;
 
 		if (pfrinfo->gather_flag & look_for) {
-			len += pfrinfo->pktlen;			
+			len += pfrinfo->pktlen;
 			if (pfrinfo->gather_flag & GATHER_FIRST) {
 				first = pfrinfo;
 				list_del_init(&pfrinfo->rx_list);
@@ -2966,31 +3307,31 @@ static int search_first_segment(struct rtl8192cd_priv *priv, struct rx_frinfo **
 					pframe = get_pframe(pfrinfo);
 					memcpy(qosControl, GetQosControl(pframe), 2);
 					if (!is_qos_data(pframe)  || !(qosControl[0] & BIT(7)))  /* not AMSDU */
-						rtl_kfree_skb(priv, pfrinfo->pskb, _SKB_RX_);								
-					else				
+						rtl_kfree_skb(priv, pfrinfo->pskb, _SKB_RX_);
+					else
 						look_for = GATHER_MIDDLE | GATHER_LAST;
 				}
 			}
 			else if (pfrinfo->gather_flag & GATHER_LAST) {
- 				first->gather_len = len;								
-				*found = first;			 				
+ 				first->gather_len = len;
+				*found = first;
 				ok = 1;
 				break;
-			}			
+			}
 		}
-		else {			
-			list_del_init(&pfrinfo->rx_list);		
-			if (pfrinfo->pskb) 
-				rtl_kfree_skb(priv, pfrinfo->pskb, _SKB_RX_);			
+		else {
+			list_del_init(&pfrinfo->rx_list);
+			if (pfrinfo->pskb)
+				rtl_kfree_skb(priv, pfrinfo->pskb, _SKB_RX_);
 		}
 	}
 
 	if (first && !ok) {
 		if (first->pskb)
 			rtl_kfree_skb(priv, first->pskb, _SKB_RX_);
-	}	
+	}
 
-	RESTORE_INT(flags);	
+	RESTORE_INT(flags);
 	return ok;
 }
 
@@ -3004,6 +3345,9 @@ static int search_first_segment(struct rtl8192cd_priv *priv, struct rx_frinfo **
 #define	RTL_WLAN_RX_ATOMIC_PROTECT_EXIT
 #endif
 
+#ifdef CONFIG_RTK_VOIP_QOS
+extern int ( *check_voip_channel_loading )( void );
+#endif
 #ifndef __LINUX_2_6__
 __MIPS16
 #endif
@@ -3040,6 +3384,10 @@ void rtl8192cd_rx_isr(struct rtl8192cd_priv *priv)
 	int pfrinfo_update;
 	#endif
 
+#if defined (CONFIG_RTK_VOIP_QOS) && !defined (CONFIG_RTK_VOIP_ETHERNET_DSP_IS_HOST)
+        unsigned long start_time = jiffies;
+        int n = 0;
+#endif
 	if (!(priv->drv_state & DRV_STATE_OPEN))
 		return;
 
@@ -3059,6 +3407,12 @@ void rtl8192cd_rx_isr(struct rtl8192cd_priv *priv)
 
 	while (1)
 	{
+#if defined (CONFIG_RTK_VOIP_QOS) && !defined (CONFIG_RTK_VOIP_ETHERNET_DSP_IS_HOST)	
+		if ( (n++ > 100 || (jiffies - start_time) >= 1 )&& (check_voip_channel_loading && (check_voip_channel_loading() > 0)) )
+		{
+			break;		
+		}
+#endif		
 		#if defined(DELAY_REFILL_RX_BUF)
 		refill = 1;
 
@@ -3088,11 +3442,31 @@ void rtl8192cd_rx_isr(struct rtl8192cd_priv *priv)
 
 		pskb = (struct sk_buff *)(phw->rx_infoL[tail].pbuf);
 		pfrinfo = get_pfrinfo(pskb);
+
+#ifdef MP_SWITCH_LNA
+		if((GET_CHIP_VER(priv) == VERSION_8192D) && priv->pshare->rf_ft_var.mp_specific)
+			dynamic_switch_lna(priv);
+#endif
+
 		if (cmd & RX_CRC32) {
 			/*printk("CRC32 happens~!!\n");*/
 			rx_pkt_exception(priv, cmd);
 			goto rx_reuse;
 		}
+#if defined(CONFIG_RTL_88E_SUPPORT) && defined(TXREPORT)
+		else if ((GET_CHIP_VER(priv)==VERSION_8188E) && 
+			(((get_desc(pdesc->Dword3) >> RXdesc_88E_RptSelSHIFT) & RXdesc_88E_RptSelMask) == 2)) {
+			pfrinfo->pktlen = (cmd & RX_PktLenMask);
+			if (get_desc(pdesc->Dword4) || get_desc(pdesc->Dword5))
+				RTL8188E_TxReportHandler(priv, pskb, get_desc(pdesc->Dword4), get_desc(pdesc->Dword5), pdesc);
+			goto rx_reuse;
+		} else if ((GET_CHIP_VER(priv)==VERSION_8188E) && 
+			((get_desc(pdesc->Dword3) >> RXdesc_88E_RptSelSHIFT) & RXdesc_88E_RptSelMask)) {
+			printk("%s %d, Rx report select mismatch, val:%d\n", __FUNCTION__, __LINE__, 
+				((get_desc(pdesc->Dword3) >> RXdesc_88E_RptSelSHIFT) & RXdesc_88E_RptSelMask));
+			goto rx_reuse;
+		}
+#endif
 		#if !defined(RX_BUFFER_GATHER)
 		else if ((cmd & (RX_FirstSeg | RX_LastSeg)) != (RX_FirstSeg | RX_LastSeg)) {
 			// h/w use more than 1 rx descriptor to receive a packet
@@ -3100,7 +3474,7 @@ void rtl8192cd_rx_isr(struct rtl8192cd_priv *priv)
 			// drop such kind of packet
 			goto rx_reuse;
 		}
-		#endif		
+		#endif
 		else if (!IS_DRV_OPEN(priv)) {
 			goto rx_reuse;
 		} else {
@@ -3110,24 +3484,24 @@ void rtl8192cd_rx_isr(struct rtl8192cd_priv *priv)
 			#if defined(RX_BUFFER_GATHER)
 			if ((cmd & (RX_FirstSeg | RX_LastSeg)) != (RX_FirstSeg | RX_LastSeg)) {
 				if ((cmd & RX_FirstSeg) && priv->pshare->gather_state == GATHER_STATE_NO) {
-					priv->pshare->gather_state = GATHER_STATE_FIRST;	
-					priv->pshare->gather_len = pfrinfo->pktlen;		
+					priv->pshare->gather_state = GATHER_STATE_FIRST;
+					priv->pshare->gather_len = pfrinfo->pktlen;
 					pfrinfo->gather_flag = GATHER_FIRST;
-				} else if (!(cmd & (RX_FirstSeg | RX_LastSeg)) && 
+				} else if (!(cmd & (RX_FirstSeg | RX_LastSeg)) &&
 						(priv->pshare->gather_state == GATHER_STATE_FIRST || priv->pshare->gather_state == GATHER_STATE_MIDDLE)) {
 					priv->pshare->gather_state = GATHER_STATE_MIDDLE;
-					priv->pshare->gather_len += pfrinfo->pktlen;	
-					pfrinfo->gather_flag = GATHER_MIDDLE;					
-				} else if ((cmd & RX_LastSeg) &&	
+					priv->pshare->gather_len += pfrinfo->pktlen;
+					pfrinfo->gather_flag = GATHER_MIDDLE;
+				} else if ((cmd & RX_LastSeg) &&
 						(priv->pshare->gather_state == GATHER_STATE_FIRST || priv->pshare->gather_state == GATHER_STATE_MIDDLE)) {
 					priv->pshare->gather_state = GATHER_STATE_LAST;
-					pfrinfo->pktlen -= priv->pshare->gather_len;		
-					pfrinfo->gather_flag = GATHER_LAST;					
+					pfrinfo->pktlen -= priv->pshare->gather_len;
+					pfrinfo->gather_flag = GATHER_LAST;
 				} else {
 					if (priv->pshare->gather_state != GATHER_STATE_NO) {
 						DEBUG_ERR("Rx pkt not in sequence [%x, %x]!\n", (cmd & (RX_FirstSeg | RX_LastSeg)), priv->pshare->gather_state);
 						flush_rx_list(priv);
-						priv->pshare->gather_state = GATHER_STATE_NO;						
+						priv->pshare->gather_state = GATHER_STATE_NO;
 					}
 					goto rx_reuse;
 				}
@@ -3135,11 +3509,11 @@ void rtl8192cd_rx_isr(struct rtl8192cd_priv *priv)
 				if (priv->pshare->gather_state != GATHER_STATE_NO) {
 					DEBUG_ERR("Rx pkt not in valid gather state [%x]!\n", priv->pshare->gather_state);
 					flush_rx_list(priv);
-					priv->pshare->gather_state = GATHER_STATE_NO;					
+					priv->pshare->gather_state = GATHER_STATE_NO;
 				}
-			}			
+			}
 			if (pfrinfo->gather_flag && pfrinfo->gather_flag != GATHER_FIRST) {
-				pfrinfo->driver_info_size = 0;				
+				pfrinfo->driver_info_size = 0;
 				pfrinfo->rxbuf_shift = 0;
 			}
 			else
@@ -3151,17 +3525,17 @@ void rtl8192cd_rx_isr(struct rtl8192cd_priv *priv)
 
 			#if defined(RX_BUFFER_GATHER)
 			if (pfrinfo->gather_flag) {
-				pfrinfo->pktlen -= (pfrinfo->driver_info_size - 4);	
-				priv->pshare->gather_len -= (pfrinfo->driver_info_size - 4);	
-			}				
+				pfrinfo->pktlen -= (pfrinfo->driver_info_size - 4);
+				priv->pshare->gather_len -= (pfrinfo->driver_info_size - 4);
+			}
 			#endif
 			pfrinfo->sw_dec = (cmd & RX_SwDec) >> 27;
 			pfrinfo->pktlen -= pfrinfo->rxbuf_shift;
 			if ((pfrinfo->pktlen > 0x2000) || (pfrinfo->pktlen < 16)) {
 				#if defined(RX_BUFFER_GATHER)
 				if (!(pfrinfo->gather_flag && (pfrinfo->pktlen < 16)))
-				#endif		
-				{				
+				#endif
+				{
 					printk("pfrinfo->pktlen=%d, goto rx_reuse\n",pfrinfo->pktlen);
 					goto rx_reuse;
 				}
@@ -3245,7 +3619,7 @@ void rtl8192cd_rx_isr(struct rtl8192cd_priv *priv)
 			/*-----------------------------------------------------
 			 validate_mpdu will check if we still can reuse the skb
 			------------------------------------------------------*/
-			#if defined(CONFIG_RTL_QOS_PATCH)
+			#if defined(CONFIG_RTL_QOS_PATCH) || defined(CONFIG_RTK_VOIP_QOS) || defined(CONFIG_RTK_VLAN_WAN_TAG_SUPPORT)
 			pskb->srcPhyPort = QOS_PATCH_RX_FROM_WIRELESS;
 			#endif
 
@@ -3265,7 +3639,7 @@ void rtl8192cd_rx_isr(struct rtl8192cd_priv *priv)
 					{
 						//sa = 	get_sa(pframe);
 						if(memcmp(priv->pshare->mp_filter_SA,sa,MACADDRLEN))
-						{						
+						{
 							find_flag=0;
 						}
 					}
@@ -3275,7 +3649,7 @@ void rtl8192cd_rx_isr(struct rtl8192cd_priv *priv)
 						{
 							//da = 	get_da(pframe);
 							if(memcmp(priv->pshare->mp_filter_DA,da,MACADDRLEN))
-							{						
+							{
 								find_flag=0;
 							}
 						}
@@ -3286,12 +3660,12 @@ void rtl8192cd_rx_isr(struct rtl8192cd_priv *priv)
 						{
 							//bssid =get_bssid_mp(pframe);
 							if(memcmp(priv->pshare->mp_filter_BSSID,bssid,MACADDRLEN))
-							{						
+							{
 								find_flag=0;
 							}
 						}
 					}
-					#if 0					
+					#if 0
 					if(find_flag)
 					{
 						printk("flag: %x\nSA: %02x:%02x:%02x:%02x:%02x:%02x\nDA: %02x:%02x:%02x:%02x:%02x:%02x\nBSSID: %02x:%02x:%02x:%02x:%02x:%02x\n",priv->pshare->mp_filter_flag,
@@ -3312,9 +3686,9 @@ void rtl8192cd_rx_isr(struct rtl8192cd_priv *priv)
 															bssid[2],
 															bssid[3],
 															bssid[4],
-															bssid[5]);				
+															bssid[5]);
 					}
-					#endif				
+					#endif
 				}
 	//-------------------------------------------------------------------------------------------
 				if(find_flag)
@@ -3325,7 +3699,7 @@ void rtl8192cd_rx_isr(struct rtl8192cd_priv *priv)
 					rx_sum_up(priv, NULL, pfrinfo->pktlen, GetRetry(get_pframe(pfrinfo)));
 					if (priv->pshare->rf_ft_var.rssi_dump)
 						update_sta_rssi(priv, NULL, pfrinfo);
-				}				
+				}
 					pskb->data -= (pfrinfo->rxbuf_shift + pfrinfo->driver_info_size);
 					pskb->tail -= (pfrinfo->rxbuf_shift + pfrinfo->driver_info_size);
 			}
@@ -3337,7 +3711,7 @@ void rtl8192cd_rx_isr(struct rtl8192cd_priv *priv)
 				#else
 				#define	RTL_WLAN_DRV_RX_GATHER_GAP_THRESHOLD	64
 				#endif
-				
+
 				if (pfrinfo->rxbuf_shift + pfrinfo->driver_info_size + pfrinfo->pktlen + _CRCLNG_ <= (RX_BUF_LEN- sizeof(struct rx_frinfo)-RTL_WLAN_DRV_RX_GATHER_GAP_THRESHOLD) ) {
 					skb_reserve(pskb, (pfrinfo->rxbuf_shift + pfrinfo->driver_info_size));
 
@@ -3374,7 +3748,7 @@ void rtl8192cd_rx_isr(struct rtl8192cd_priv *priv)
 									privacy = get_sta_encrypt_algthm(priv, pstat);
 							}
 							#endif
-							
+
 							if (privacy != _CCMP_PRIVACY_)
 								rtl8192cd_ICV++;
 						}
@@ -3385,7 +3759,7 @@ void rtl8192cd_rx_isr(struct rtl8192cd_priv *priv)
 							pskb->tail -= (pfrinfo->rxbuf_shift + pfrinfo->driver_info_size);
 							#if !defined(DELAY_REFILL_RX_BUF) || !defined(CONFIG_RTL8190_PRIV_SKB) //we create this, but we do not free it!
 							if (new_skb != NULL)
-								rtl_kfree_skb(priv, new_skb, _SKB_RX_);				
+								rtl_kfree_skb(priv, new_skb, _SKB_RX_);
 							#endif
 							goto rx_reuse;
 						}
@@ -3396,22 +3770,22 @@ void rtl8192cd_rx_isr(struct rtl8192cd_priv *priv)
 					SNMP_MIB_INC(dot11ReceivedFragmentCount, 1);
 
 					#if defined(SW_ANT_SWITCH)
-					if(priv->pshare->rf_ft_var.antSw_enable) {				
+					if(priv->pshare->rf_ft_var.antSw_enable) {
 						dm_SWAW_RSSI_Check(priv, pfrinfo);
 					}
 					#endif
 
 					#if defined(RX_BUFFER_GATHER)
-					if (priv->pshare->gather_state != GATHER_STATE_NO) {		
+					if (priv->pshare->gather_state != GATHER_STATE_NO) {
 						list_add_tail(&pfrinfo->rx_list, &priv->pshare->gather_list);
 
-						if (priv->pshare->gather_state == GATHER_STATE_LAST) {								
-							if (!search_first_segment(priv, &pfrinfo)) 
+						if (priv->pshare->gather_state == GATHER_STATE_LAST) {
+							if (!search_first_segment(priv, &pfrinfo))
 								reuse = 0;
 							else {
 								pskb = pfrinfo->pskb;
 								pfrinfo_update = 1;
-							}							
+							}
 							priv->pshare->gather_state = GATHER_STATE_NO;
 						} else {
 							reuse = 0;
@@ -3424,6 +3798,15 @@ void rtl8192cd_rx_isr(struct rtl8192cd_priv *priv)
 					if (reuse) {
 						pskb->data -= (pfrinfo->rxbuf_shift + pfrinfo->driver_info_size);
 						pskb->tail -= (pfrinfo->rxbuf_shift + pfrinfo->driver_info_size);
+
+#ifdef RX_BUFFER_GATHER
+                        if (pfrinfo->gather_flag & GATHER_FIRST){
+                            //flush_rx_list(priv);
+                            rtl_kfree_skb(priv, pskb, _SKB_RX_);
+                            reuse = 0;
+                            DEBUG_WARN("Gather-First packet error, free skb\n");
+                        }
+#endif
 					}
 				}
 				#undef	RTL_WLAN_DRV_RX_GATHER_GAP_THRESHOLD
@@ -3542,7 +3925,7 @@ rx_done:
 		#endif
 		RTL_WLAN_RX_ATOMIC_PROTECT_EXIT;
 	}	/*	while(1)	*/
-	
+
 	if (!IS_DRV_OPEN(priv))
 		return;
 
@@ -3754,9 +4137,9 @@ static struct rx_frinfo *defrag_frame_main(struct rtl8192cd_priv *priv, struct r
 #ifdef A4_STA
 			if (pfrinfo->to_fr_ds == 3 &&  priv->pshare->rf_ft_var.a4_enable) {
 				pstat = get_stainfo(priv, GetAddr2Ptr(pframe));
-				if (pstat && !(pstat->state & WIFI_A4_STA)) 
+				if (pstat && !(pstat->state & WIFI_A4_STA))
 					add_a4_client(priv, pstat);
-				
+
 				a4_sta_add(priv, pstat, sa);
 			}
 			else
@@ -3832,19 +4215,19 @@ check_privacy:
 		}
 	}
 
-	if (IS_MCAST(da)) 
-    { 
-		if (GetTupleCache(pframe) == pstat->tpcache_mcast) 
-        { 
-			priv->ext_stats.rx_decache++; 
-            SNMP_MIB_INC(dot11FrameDuplicateCount, 1); 
-            goto free_skb_in_defrag; 
-        } 
-        else 
-            pstat->tpcache_mcast = GetTupleCache(pframe); 
-    } 
-    else 
-#endif 	
+	if (IS_MCAST(da))
+    {
+        if (GetTupleCache(pframe) == pstat->tpcache_mcast)
+        {
+            priv->ext_stats.rx_decache++;
+            SNMP_MIB_INC(dot11FrameDuplicateCount, 1);
+            goto free_skb_in_defrag;
+        }
+        else
+            pstat->tpcache_mcast = GetTupleCache(pframe);
+    }
+	else
+#endif
 	{
 		/*-------------------check retry-------------------*/
 		pos = GetSequence(pframe) & (TUPLE_WINDOW - 1);
@@ -4007,17 +4390,17 @@ check_privacy:
 #ifdef _SINUX_
 			printk("RX DROP: MIC error! Indicate to protection mechanism\n");
 			mic_error_report(0);
-#else			
+#else
 			DEBUG_ERR("RX DROP: MIC error! Indicate to protection mechanism\n");
-#endif			
+#endif
 			if (OPMODE & WIFI_AP_STATE) {
 #ifdef RTL_WPA2
 #ifdef _SINUX_
 				printk("%s: DOT11_Indicate_MIC_Failure %02X:%02X:%02X:%02X:%02X:%02X \n", (char *)__FUNCTION__,pstat->hwaddr[0],pstat->hwaddr[1],pstat->hwaddr[2],pstat->hwaddr[3],pstat->hwaddr[4],pstat->hwaddr[5]);
 #else
 				PRINT_INFO("%s: DOT11_Indicate_MIC_Failure %02X:%02X:%02X:%02X:%02X:%02X \n", (char *)__FUNCTION__,pstat->hwaddr[0],pstat->hwaddr[1],pstat->hwaddr[2],pstat->hwaddr[3],pstat->hwaddr[4],pstat->hwaddr[5]);
-#endif				
-					
+#endif
+
 #endif
 #ifdef WDS
 				if ((pfrinfo->to_fr_ds == 3) &&
@@ -4522,7 +4905,7 @@ int rtl8192cd_isIgmpV1V2Report(unsigned char *macFrame)
 	unsigned char *ptr;
 	struct iphdr *iph=NULL;
 	unsigned int payloadLen;
-	
+
 	if((macFrame[0]!=0x01) || (macFrame[1]!=0x00) || (macFrame[2]!=0x5e))
 	{
 		return FALSE;
@@ -4546,22 +4929,170 @@ int rtl8192cd_isIgmpV1V2Report(unsigned char *macFrame)
 	{
 		return FALSE;
 	}
-	
+
 	payloadLen=(iph->tot_len-((iph->ihl&0x0f)<<2));
 	if(payloadLen>8)
 	{
 		return FALSE;
 	}
-	
+
 	ptr=ptr+(((unsigned int)iph->ihl)<<2);
-	if((*ptr==0x11) ||(*ptr==0x16)) 
+	if((*ptr==0x11) ||(*ptr==0x16))
 	{
 		return TRUE;
 	}
 	return FALSE;
-	
+
+}
+#if defined (CONFIG_RTL_MLD_SNOOPING)
+#define IPV6_ROUTER_ALTER_OPTION 0x05020000
+#define  HOP_BY_HOP_OPTIONS_HEADER 0
+#define ROUTING_HEADER 43
+#define  FRAGMENT_HEADER 44
+#define DESTINATION_OPTION_HEADER 60
+
+#define ICMP_PROTOCOL 58
+
+#define MLD_QUERY 130
+#define MLDV1_REPORT 131
+#define MLDV1_DONE 132
+#define MLDV2_REPORT 143
+
+int rtl8192cd_isMldV1Report(unsigned char *macFrame)
+{
+	unsigned char *ptr;
+	struct ipv6hdr* ipv6h;
+	unsigned char *startPtr=NULL;
+	unsigned char *lastPtr=NULL;
+	unsigned char nextHeader=0;
+	unsigned short extensionHdrLen=0;
+
+	unsigned char  optionDataLen=0;
+	unsigned char  optionType=0;
+	unsigned int ipv6RAO=0;
+
+	if((macFrame[0]!=0x33) || (macFrame[1]!=0x33) )
+	{
+		return FALSE;
+	}
+
+	if(macFrame[2]==0xff)
+	{
+		return FALSE;
+	}
+
+	ptr=macFrame+12;
+	if(*(int16 *)(ptr)==(int16)htons(0x8100))
+	{
+		ptr=ptr+4;
+	}
+
+	/*it's not ipv6 packet*/
+	if(*(int16 *)(ptr)!=(int16)htons(0x86dd))
+	{
+		return FALSE;
+	}
+
+	ptr=(ptr+2);
+
+	ipv6h= (struct ipv6hdr *) ptr;
+	if(ipv6h->version!=6)
+	{
+		return FALSE;
+	}
+
+	startPtr= (unsigned char *)ptr;
+	lastPtr=startPtr+sizeof(struct ipv6hdr)+(ipv6h->payload_len);
+	nextHeader= ipv6h ->nexthdr;
+	ptr=startPtr+sizeof(struct ipv6hdr);
+
+	while(ptr<lastPtr)
+	{
+		switch(nextHeader)
+		{
+			case HOP_BY_HOP_OPTIONS_HEADER:
+				/*parse hop-by-hop option*/
+				nextHeader=ptr[0];
+				extensionHdrLen=((uint16)(ptr[1])+1)*8;
+				ptr=ptr+2;
+
+				while(ptr<(startPtr+extensionHdrLen+sizeof(struct ipv6hdr)))
+				{
+					optionType=ptr[0];
+					/*pad1 option*/
+					if(optionType==0)
+					{
+						ptr=ptr+1;
+						continue;
+					}
+
+					/*padN option*/
+					if(optionType==1)
+					{
+						optionDataLen=ptr[1];
+						ptr=ptr+optionDataLen+2;
+						continue;
+					}
+
+					/*router altert option*/
+					if(ntohl(*(uint32 *)(ptr))==IPV6_ROUTER_ALTER_OPTION)
+					{
+						ipv6RAO=IPV6_ROUTER_ALTER_OPTION;
+						ptr=ptr+4;
+						continue;
+					}
+
+					/*other TLV option*/
+					if((optionType!=0) && (optionType!=1))
+					{
+						optionDataLen=ptr[1];
+						ptr=ptr+optionDataLen+2;
+						continue;
+					}
+
+
+				}
+
+				break;
+
+			case ROUTING_HEADER:
+				nextHeader=ptr[0];
+				extensionHdrLen=((uint16)(ptr[1])+1)*8;
+                            	ptr=ptr+extensionHdrLen;
+				break;
+
+			case FRAGMENT_HEADER:
+				nextHeader=ptr[0];
+				ptr=ptr+8;
+				break;
+
+			case DESTINATION_OPTION_HEADER:
+				nextHeader=ptr[0];
+				extensionHdrLen=((uint16)(ptr[1])+1)*8;
+				ptr=ptr+extensionHdrLen;
+				break;
+
+			case ICMP_PROTOCOL:
+				if(ptr[0]==MLDV1_REPORT)
+				{
+					return TRUE;
+				}
+				else
+				{
+					return FALSE;
+				}
+				break;
+
+			default:
+				return FALSE;
+		}
+
+	}
+	return FALSE;
+
 }
 #endif
+#endif
 
 
 static int process_datafrme(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinfo)
@@ -4606,8 +5137,8 @@ static int process_datafrme(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrin
 		else
 #endif
 		{
-#ifdef A4_STA	
-			if (pfrinfo->to_fr_ds == 3 &&  priv->pshare->rf_ft_var.a4_enable) 
+#ifdef A4_STA
+			if (pfrinfo->to_fr_ds == 3 &&  priv->pshare->rf_ft_var.a4_enable)
 				pstat = get_stainfo(priv, GetAddr2Ptr(pframe));
 			else
 #endif
@@ -4636,6 +5167,12 @@ static int process_datafrme(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrin
 		update_sta_rssi(priv, pstat, pfrinfo);
 
 #ifdef DETECT_STA_EXISTANCE
+#ifdef CONFIG_RTL_88E_SUPPORT
+        if (GET_CHIP_VER(priv)==VERSION_8188E) {
+            if (pstat->leave!= 0)
+                RTL8188E_MACID_NOLINK(priv, 0, REMAP_AID(pstat));
+        }
+#endif
 		pstat->leave = 0;
 #endif
 
@@ -4645,7 +5182,11 @@ static int process_datafrme(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrin
 #endif
 
 #if defined(WIFI_WMM) && defined(WMM_APSD)
-		if((QOS_ENABLE) && (APSD_ENABLE) && (pstat->QosEnabled) && (pstat->apsd_bitmap & 0x0f) &&
+		if(
+#ifdef CLIENT_MODE
+			(OPMODE & WIFI_AP_STATE) &&
+#endif
+			(QOS_ENABLE) && (APSD_ENABLE) && (pstat->QosEnabled) && (pstat->apsd_bitmap & 0x0f) &&
 			((pstat->state & (WIFI_ASOC_STATE|WIFI_SLEEP_STATE)) == (WIFI_ASOC_STATE|WIFI_SLEEP_STATE)) &&
 			(GetFrameSubType(get_pframe(pfrinfo)) == (WIFI_QOS_DATA))) {
 			process_APSD_dz_queue(priv, pstat, pfrinfo->tid);
@@ -4665,6 +5206,11 @@ static int process_datafrme(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrin
 							priv->pshare->marvellMapBitExt |= BIT(pstat->aid - FW_NUM_STAT - 1);
 						else
 #endif
+#ifdef CONFIG_RTL_88E_SUPPORT
+						if ((GET_CHIP_VER(priv) == VERSION_8188E) && (pstat->aid > 32))
+							priv->pshare->marvellMapBit_88e_hw_ext |= BIT(pstat->aid - 32 - 1);
+						else
+#endif
 							priv->pshare->marvellMapBit |= BIT(pstat->aid - 1);
 					}
 				}
@@ -4673,8 +5219,8 @@ static int process_datafrme(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrin
 					priv->pshare->Reg_RRSR_2 = RTL_R8(RRSR+2);
 					priv->pshare->Reg_81b = RTL_R8(0x81b);
 					RTL_W8(RRSR+2, priv->pshare->Reg_RRSR_2 | 0x60);
-					RTL_W8(0x81b, priv->pshare->Reg_81b | 0x0E); 
-				} 
+					RTL_W8(0x81b, priv->pshare->Reg_81b | 0x0E);
+				}
 
 				process_amsdu(priv, pstat, pfrinfo);
 				return SUCCESS;
@@ -4682,18 +5228,20 @@ static int process_datafrme(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrin
 #ifdef RX_BUFFER_GATHER
 			else if (!list_empty(&priv->pshare->gather_list))
 				flush_rx_list(priv);
-#endif			
+#endif
 		}
 
 #ifdef PREVENT_BROADCAST_STORM
 //			if (get_free_memory() < FREE_MEM_LOWER_BOUND) {
 			if (da[0] == 0xff) {
 				pstat->rx_pkts_bc++;
+				#if 0
 				if (pstat->rx_pkts_bc > BROADCAST_STORM_THRESHOLD) {
 					priv->ext_stats.rx_data_drops++;
 					DEBUG_ERR("RX DROP: Broadcast storm happened!\n");
 					return FAIL;
 				}
+				#endif
 			}
 #endif
 
@@ -4744,7 +5292,13 @@ static int process_datafrme(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrin
 			 	//printk("%s:%d,receive igmpv1/v2 report\n",__FUNCTION__,__LINE__);
 				goto  mcast_netif_rx;
 			 }
-#endif	
+			#if defined (CONFIG_RTL_MLD_SNOOPING)
+			if(rtl8192cd_isMldV1Report(pskb->data))
+			{
+				goto  mcast_netif_rx;
+			}
+			#endif
+#endif
 
 			 if(IP_MCAST_MAC(pskb->data) && IS_IGMP_PROTO(pskb->data))
 			 {
@@ -4765,11 +5319,8 @@ static int process_datafrme(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrin
 					extern struct sk_buff *priv_skb_copy(struct sk_buff *skb);
 					pnewskb = priv_skb_copy(pskb);
 #else
-				if ((priv->pmib->dot1180211AuthEntry.dot11WPACipher&2)||(priv->pmib->dot1180211AuthEntry.dot11WPA2Cipher&2))
 					pnewskb = skb_copy(pskb, GFP_ATOMIC);
-				else
-					pnewskb = skb_clone(pskb, GFP_ATOMIC);
-#endif					
+#endif
 					if (pnewskb) {
 #ifdef GBWC
 						if (GBWC_forward_check(priv, pnewskb, pstat)) {
@@ -4779,12 +5330,28 @@ static int process_datafrme(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrin
 #endif
 						{
 							if(dontBcast2otherSta){
-								rtl_kfree_skb(priv, pnewskb, _SKB_TX_);								
+								rtl_kfree_skb(priv, pnewskb, _SKB_TX_);
 							}else{
-								if (rtl8192cd_start_xmit(pnewskb, priv->dev))
-									rtl_kfree_skb(priv, pnewskb, _SKB_TX_);
+#ifdef PREVENT_BROADCAST_STORM
+	                            if (da[0] == 0xff) {
+		                            if (pstat->rx_pkts_bc > BROADCAST_STORM_THRESHOLD) {
+			                            priv->ext_stats.rx_data_drops++;
+				                        DEBUG_ERR("RX DROP: Broadcast storm happened!\n");
+					                    rtl_kfree_skb(priv, pnewskb, _SKB_TX_);
+						            }
+							        else {
+								        if (rtl8192cd_start_xmit(pnewskb, priv->dev))
+									        rtl_kfree_skb(priv, pnewskb, _SKB_TX_);
+	                                }
+		                        }
+			                    else
+#endif
+								{
+									if (rtl8192cd_start_xmit(pnewskb, priv->dev))
+										rtl_kfree_skb(priv, pnewskb, _SKB_TX_);
+								}
 							}
-								
+
 						}
 					}
 				}
@@ -4817,8 +5384,8 @@ mcast_netif_rx:
 			dst_pstat = get_stainfo(priv, da);
 
 #ifdef A4_STA
-			if (priv->pshare->rf_ft_var.a4_enable && (dst_pstat == NULL)) 
-				dst_pstat = a4_sta_lookup(priv, da);			
+			if (priv->pshare->rf_ft_var.a4_enable && (dst_pstat == NULL))
+				dst_pstat = a4_sta_lookup(priv, da);
 #endif
 
 #ifdef WDS
@@ -4960,13 +5527,13 @@ mcast_netif_rx:
 						memcpy(&(priv->Eap_packet->packet[WLAN_ETHHDR_LEN]), pskb->data, pskb->len);
 #ifdef EAP_BY_QUEUE
 
-#ifdef INCLUDE_WPS						
+#ifdef INCLUDE_WPS
 
-						wps_NonQueue_indicate_evt(priv , 
+						wps_NonQueue_indicate_evt(priv ,
 							(char *)priv->Eap_packet, sizeof(DOT11_EAP_PACKET));
 #else
-						DOT11_EnQueue((unsigned long)priv, priv->pevent_queue, 
-							(unsigned char*)priv->Eap_packet,sizeof(DOT11_EAP_PACKET));					
+						DOT11_EnQueue((unsigned long)priv, priv->pevent_queue,
+							(unsigned char*)priv->Eap_packet,sizeof(DOT11_EAP_PACKET));
 
 						event_indicate(priv, NULL, -1);
 #endif
@@ -5047,8 +5614,7 @@ mcast_netif_rx:
 		}
 	}
 #ifdef CLIENT_MODE
-	else if (OPMODE & (WIFI_STATION_STATE | WIFI_ADHOC_STATE))
-	{
+	else if (OPMODE & (WIFI_STATION_STATE | WIFI_ADHOC_STATE)) {
 		// I am station, and just report every frame I received to protocol statck
 		if (OPMODE & WIFI_STATION_STATE)
 			pstat = get_stainfo(priv, BSSID);
@@ -5058,20 +5624,40 @@ mcast_netif_rx:
 		if (IS_MCAST(pfrinfo->da)) {
 			// iv, icv and mic are not be used below. Don't care them!
 			privacy = get_mcast_encrypt_algthm(priv);
-		}
-		else
+		} else {
 			privacy = get_sta_encrypt_algthm(priv, pstat);
+		}
 
 		rx_sum_up(NULL, pstat, pfrinfo->pktlen, 0);
 		update_sta_rssi(priv, pstat, pfrinfo);
 		priv->rxDataNumInPeriod++;
-		if (IS_MCAST(pfrinfo->da))
+		if (IS_MCAST(pfrinfo->da)) {
 			priv->rxMlcstDataNumInPeriod++;
-
 #ifdef SUPPORT_SNMP_MIB
-		if (IS_MCAST(pfrinfo->da))
 			SNMP_MIB_INC(dot11MulticastReceivedFrameCount, 1);
 #endif
+		} else if ((OPMODE & WIFI_STATION_STATE) && (priv->ps_state)) {
+			if ((GetFrameSubType(get_pframe(pfrinfo)) == WIFI_DATA)
+#ifdef WIFI_WMM
+				|| (QOS_ENABLE && pstat->QosEnabled && (GetFrameSubType(get_pframe(pfrinfo)) == WIFI_QOS_DATA))
+#endif
+			) {
+				if (GetMData(pframe)) {
+#if defined(WIFI_WMM) && defined(WMM_APSD)
+					if (QOS_ENABLE && APSD_ENABLE && priv->uapsd_assoc) {
+						if (!((priv->pmib->dot11QosEntry.UAPSD_AC_BE && ((pfrinfo->tid == 0) || (pfrinfo->tid == 3))) ||
+							(priv->pmib->dot11QosEntry.UAPSD_AC_BK && ((pfrinfo->tid == 1) || (pfrinfo->tid == 2))) ||
+							(priv->pmib->dot11QosEntry.UAPSD_AC_VI && ((pfrinfo->tid == 4) || (pfrinfo->tid == 5))) ||
+							(priv->pmib->dot11QosEntry.UAPSD_AC_VO && ((pfrinfo->tid == 6) || (pfrinfo->tid == 7)))))
+							issue_PsPoll(priv);
+					} else
+#endif
+					{
+						issue_PsPoll(priv);
+					}
+				}
+			}
+		}
 
 		#if defined(CONFIG_RTL_WAPI_SUPPORT)
 		if (privacy==_WAPI_SMS4_&&wapiHandleRecvPacket(pfrinfo, pstat)==SUCCESS)
@@ -5090,7 +5676,7 @@ mcast_netif_rx:
 #ifdef RX_BUFFER_GATHER
 			else if (!list_empty(&priv->pshare->gather_list))
 				flush_rx_list(priv);
-#endif				
+#endif
 		}
 
 		res = skb_p80211_to_ether(priv->dev, privacy, pfrinfo);
@@ -5133,11 +5719,11 @@ mcast_netif_rx:
 
 #ifdef INCLUDE_WPS
 
-			wps_NonQueue_indicate_evt(priv , 
+			wps_NonQueue_indicate_evt(priv ,
 				(char *)priv->Eap_packet, sizeof(DOT11_EAP_PACKET));
 #else
-			DOT11_EnQueue((unsigned long)priv, priv->pevent_queue, 
-				(unsigned char*)priv->Eap_packet, sizeof(DOT11_EAP_PACKET));			
+			DOT11_EnQueue((unsigned long)priv, priv->pevent_queue,
+				(unsigned char*)priv->Eap_packet, sizeof(DOT11_EAP_PACKET));
 			event_indicate(priv, NULL, -1);
 #endif
 #endif
@@ -5154,7 +5740,9 @@ mcast_netif_rx:
 
 		skb_push(pskb, WLAN_ETHHDR_LEN);	// push back due to be pulled by eth_type_trans()
 		if ((priv->pmib->dot11BssType.net_work_type & WIRELESS_11N) &&
-			priv->pmib->reorderCtrlEntry.ReorderCtrlEnable) {
+			priv->pmib->reorderCtrlEntry.ReorderCtrlEnable &&
+			!IS_MCAST(pfrinfo->da))
+		{
 			*(unsigned int *)&(pfrinfo->pskb->cb[4]) = 0;
 			if (reorder_ctrl_check(priv, pstat, pfrinfo))
 				rtl_netif_rx(priv, pskb, pstat);
@@ -5298,12 +5886,15 @@ __IRAM_IN_865X
 #ifdef WIFI_WMM
 	if (is_qos_data(pframe)) {
 		if ((OPMODE & WIFI_AP_STATE) && (QOS_ENABLE)) {
-			if ((pfrinfo->tid == 7) || (pfrinfo->tid == 6))
+			if ((pfrinfo->tid == 7) || (pfrinfo->tid == 6)) {
 				priv->pshare->phw->VO_pkt_count++;
-			else if ((pfrinfo->tid == 5) || (pfrinfo->tid == 4))
+			} else if ((pfrinfo->tid == 5) || (pfrinfo->tid == 4)) {
 				priv->pshare->phw->VI_pkt_count++;
-			else if ((pfrinfo->tid == 2) || (pfrinfo->tid == 1))
+				if (priv->pshare->rf_ft_var.wifi_beq_iot)
+					priv->pshare->phw->VI_rx_pkt_count++;
+			} else if ((pfrinfo->tid == 2) || (pfrinfo->tid == 1)) {
 				priv->pshare->phw->BK_pkt_count++;
+			}
 		}
 	}
 #endif
@@ -5323,6 +5914,13 @@ __IRAM_IN_865X
 #endif
 
 	/* ============== Start to process RX dataframe ============== */
+#if defined(CONFIG_RTK_VOIP_QOS)|| defined(CONFIG_RTK_VLAN_WAN_TAG_SUPPORT)
+#ifdef MBSSID
+        if(IS_VAP_INTERFACE(priv))
+                pfrinfo->pskb->srcPhyPort += (priv->vap_id+1);
+#endif
+#endif
+
 #if defined(DRVMAC_LB) && defined(WIFI_WMM)
 	if(priv->pmib->miscEntry.drvmac_lb /*&& priv->pmib->miscEntry.lb_tps*/) {
 		if ((QOS_ENABLE) && (GetFrameSubType(get_pframe(pfrinfo)) == (BIT(7)|WIFI_DATA_NULL)))
@@ -5348,7 +5946,11 @@ __IRAM_IN_865X
 #endif
 
 #if defined(WIFI_WMM) && defined(WMM_APSD)
-	if((QOS_ENABLE) && (APSD_ENABLE) && (GetFrameSubType(get_pframe(pfrinfo)) == (BIT(7)|WIFI_DATA_NULL))) {
+	if(
+#ifdef CLIENT_MODE
+		(OPMODE & WIFI_AP_STATE) &&
+#endif
+		(QOS_ENABLE) && (APSD_ENABLE) && (GetFrameSubType(get_pframe(pfrinfo)) == (BIT(7)|WIFI_DATA_NULL))) {
 		rtl8192cd_rx_handle_Spec_Null_Data(priv, pfrinfo); // for AR5007 IOT ISSUE
 		process_qos_null(priv, pfrinfo);
 		goto out;
@@ -5366,7 +5968,11 @@ __IRAM_IN_865X
 	if (!priv->pmib->dot11OperationEntry.disable_rxsc &&
 		!IS_MCAST(pfrinfo->da)
 #if defined(WIFI_WMM) && defined(WMM_APSD)
-		&& (!((APSD_ENABLE) && (GetFrameSubType(get_pframe(pfrinfo)) == (WIFI_QOS_DATA)) && (GetPwrMgt(get_pframe(pfrinfo)))))
+		&& (!(
+#ifdef CLIENT_MODE
+			(OPMODE & WIFI_AP_STATE) &&
+#endif
+			(APSD_ENABLE) && (GetFrameSubType(get_pframe(pfrinfo)) == (WIFI_QOS_DATA)) && (GetPwrMgt(get_pframe(pfrinfo)))))
 #endif
 		) {
 		if (rx_shortcut(priv, pfrinfo) >= 0)
@@ -5375,7 +5981,7 @@ __IRAM_IN_865X
 #endif
 
 	pfrinfo = defrag_frame(priv, pfrinfo);
-	
+
 	if (pfrinfo == NULL)
 		goto out;
 
@@ -5446,11 +6052,21 @@ void rtl8192cd_rx_dsr(unsigned long task_priv)
 #ifdef __KERNEL__
 	// disable rx interrupt in DSR
 	SAVE_INT_AND_CLI(flags);
-	mask = RTL_R32(HIMR);
-	//mask_rx = mask & (HIMR_RXFOVW | HIMR_RDU | HIMR_ROK);
-	mask_rx = mask & (HIMR_RXFOVW | HIMR_ROK);
-	RTL_W32(HIMR, mask & ~mask_rx);
-	//RTL_W32(HISR, mask_rx);
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv)==VERSION_8188E) {
+		if (priv->pshare->InterruptMask & HIMR_88E_ROK)
+			RTL_W32(REG_88E_HIMR, priv->pshare->InterruptMask & ~HIMR_88E_ROK);
+		if (priv->pshare->InterruptMaskExt & HIMRE_88E_RXFOVW)
+			RTL_W32(REG_88E_HIMRE, priv->pshare->InterruptMaskExt & ~HIMRE_88E_RXFOVW);
+	} else
+#endif
+	{
+		mask = RTL_R32(HIMR);
+		//mask_rx = mask & (HIMR_RXFOVW | HIMR_RDU | HIMR_ROK);
+		mask_rx = mask & (HIMR_RXFOVW | HIMR_ROK);
+		RTL_W32(HIMR, mask & ~mask_rx);
+		//RTL_W32(HISR, mask_rx);
+	}
 #endif
 
 	rtl8192cd_rx_isr(priv);
@@ -5476,8 +6092,18 @@ void rtl8192cd_rx_dsr(unsigned long task_priv)
 #endif
 
 #ifdef __KERNEL__
-	mask = RTL_R32(HIMR);
-	RTL_W32(HIMR, mask | mask_rx);
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv)==VERSION_8188E) {
+		if (priv->pshare->InterruptMask & HIMR_88E_ROK)
+			RTL_W32(REG_88E_HIMR, priv->pshare->InterruptMask);
+		if (priv->pshare->InterruptMaskExt & HIMRE_88E_RXFOVW)
+			RTL_W32(REG_88E_HIMRE, priv->pshare->InterruptMaskExt);
+	} else
+#endif
+	{
+		mask = RTL_R32(HIMR);
+		RTL_W32(HIMR, mask | mask_rx);
+	}
 #endif
 
 }
@@ -5553,7 +6179,7 @@ RESTORE_INT(flags);
 #ifdef A4_STA
 	if ((pstat->state & WIFI_A4_STA) && IS_MCAST(pskb->data)) {
 		txinsn.pstat = pstat;
-		SetToDs(txinsn.phdr);		
+		SetToDs(txinsn.phdr);
 	}
 #endif
 
@@ -5614,21 +6240,21 @@ static struct sk_buff *get_next_skb(struct rtl8192cd_priv *priv, int remove, int
 	plist = phead->next;
 
 	if (plist != phead) {
-		pfrinfo = list_entry(plist, struct rx_frinfo, rx_list);		
+		pfrinfo = list_entry(plist, struct rx_frinfo, rx_list);
 		pskb = get_pskb(pfrinfo);
 		if (pskb) {
 			pskb->tail = pskb->data + pfrinfo->pktlen;
 			pskb->len = pfrinfo->pktlen;
 			pskb->dev = priv->dev;
-			if (remove)	
-				list_del_init(plist);					
+			if (remove)
+				list_del_init(plist);
 		}
 	}
 
 	if (is_last && pskb && pfrinfo->gather_flag == GATHER_LAST)
 		*is_last = 1;
 
-	RESTORE_INT(flags);		
+	RESTORE_INT(flags);
 	return pskb;
 }
 
@@ -5638,16 +6264,16 @@ static struct sk_buff *shift_padding_len(struct rtl8192cd_priv *priv, struct sk_
 
 	if (skb->len < len) {
 		if (*is_last)
-			return NULL;		
+			return NULL;
 
 		nskb = get_next_skb(priv, 1, is_last);
-		if (nskb) 
-			skb_pull(nskb, len - skb->len);		
+		if (nskb)
+			skb_pull(nskb, len - skb->len);
 		else
-			DEBUG_ERR("Shift len error (%d, %d)!\n", skb->len, len);		
+			DEBUG_ERR("Shift len error (%d, %d)!\n", skb->len, len);
 	}
-	else	
-		skb_pull(nskb, len);		
+	else
+		skb_pull(nskb, len);
 
 	return nskb;
 }
@@ -5658,28 +6284,28 @@ static int get_subframe_len(struct rtl8192cd_priv *priv, struct sk_buff *skb, in
 	struct sk_buff *nskb;
 	int offset;
 	u16 u16_len;
-		
-	if (skb->len < WLAN_ETHHDR_LEN) {	
+
+	if (skb->len < WLAN_ETHHDR_LEN) {
 		if (is_last)
 			return 0;
-		
+
 		if (skb->len == WLAN_ETHHDR_LEN -1) {
 			sub_len[0] = skb->data[MACADDRLEN*2];
-			offset = 1;			
+			offset = 1;
 		}
-		else 
+		else
 			offset = WLAN_ETHHDR_LEN -2 - skb->len;
-		
+
 		nskb = get_next_skb(priv, 0, NULL);
 		if (nskb == NULL)
 			return -1;
 
-		if (offset == 1) 
+		if (offset == 1)
 			sub_len[1] = nskb->data[0];
-		else 
-			memcpy(sub_len, nskb->data + offset, 2);		
+		else
+			memcpy(sub_len, nskb->data + offset, 2);
 	}
-	else 
+	else
 		memcpy(sub_len, &skb->data[MACADDRLEN*2], 2);
 
 	u16_len = ntohs(*((u16 *)sub_len));
@@ -5690,41 +6316,41 @@ static struct sk_buff *get_subframe(struct rtl8192cd_priv *priv, struct sk_buff
 {
 	struct sk_buff *nextskb=NULL, *joinskb;
 	int offset, copy_len;
-		
+
 	if (skb->len < len+WLAN_ETHHDR_LEN) {
 		int rest_len = len + WLAN_ETHHDR_LEN - skb->len;
 
 		if (*is_last)
 			return NULL;
-			
+
 		joinskb = dev_alloc_skb(len + WLAN_ETHHDR_LEN);
 		if (joinskb == NULL) {
-			DEBUG_ERR("dev_alloc_skb() failed!\n");	
+			DEBUG_ERR("dev_alloc_skb() failed!\n");
 			return NULL;
-		}		
+		}
 		memcpy(joinskb->data, skb->data, skb->len);
 		offset = skb->len;
 
-		do {		
+		do {
 			if (nextskb)
-				rtl_kfree_skb(priv, nextskb, _SKB_RX_);				
-			
+				rtl_kfree_skb(priv, nextskb, _SKB_RX_);
+
 			nextskb = get_next_skb(priv, 1, is_last);
 			if (nextskb == NULL) {
-				dev_kfree_skb_any(joinskb);			
+				dev_kfree_skb_any(joinskb);
 				return NULL;
 			}
 
-			if (nextskb->len < rest_len && *is_last) {				
-				dev_kfree_skb_any(joinskb);			
-				rtl_kfree_skb(priv, nextskb, _SKB_RX_);	
-				return NULL;			
+			if (nextskb->len < rest_len && *is_last) {
+				dev_kfree_skb_any(joinskb);
+				rtl_kfree_skb(priv, nextskb, _SKB_RX_);
+				return NULL;
 			}
 			if (nextskb->len < rest_len)
-				copy_len = rest_len - nextskb->len;
+				copy_len = nextskb->len;
 			else
 				copy_len = rest_len;
-			
+
 			memcpy(joinskb->data+offset, nextskb->data, copy_len);
 			rest_len -= copy_len;
 			offset += copy_len;
@@ -5732,7 +6358,7 @@ static struct sk_buff *get_subframe(struct rtl8192cd_priv *priv, struct sk_buff
 		}while (rest_len > 0);
 		rtl_kfree_skb(priv, *orgskb, _SKB_RX_);
 		*orgskb = nextskb;
-		skb = joinskb;	
+		skb = joinskb;
 	}
 	else
 		skb_pull(*orgskb, len+WLAN_ETHHDR_LEN);
@@ -5767,11 +6393,11 @@ static void process_amsdu(struct rtl8192cd_priv *priv, struct stat_info *pstat,
 
 #ifdef RX_BUFFER_GATHER
 	if (pfrinfo->gather_flag == GATHER_FIRST) {
-		skb_pull(pskb, pfrinfo->hdr_len);	
+		skb_pull(pskb, pfrinfo->hdr_len);
 		rest = pfrinfo->gather_len - pfrinfo->hdr_len;
 		rx_gather = 1;
 	}
-#endif	
+#endif
 
 	if (GetPrivacy(pframe)) {
 #ifdef WDS
@@ -5804,26 +6430,26 @@ static void process_amsdu(struct rtl8192cd_priv *priv, struct stat_info *pstat,
 		pnewskb = skb_clone(pskb, GFP_ATOMIC);
 		if (pnewskb) {
 			pnewskb->data = next_head;
-#ifdef RX_BUFFER_GATHER				
+#ifdef RX_BUFFER_GATHER
 			if (rx_gather) {
 				subfr_len = get_subframe_len(priv, pnewskb, is_last);
 				if (subfr_len <= 0) {
-					DEBUG_ERR("invalid subfr_len=%d, discard AMSDU!\n", subfr_len);					
-					dev_kfree_skb_any(pnewskb);					
+					DEBUG_ERR("invalid subfr_len=%d, discard AMSDU!\n", subfr_len);
+					dev_kfree_skb_any(pnewskb);
 					break;
 				}
 				nskb = get_subframe(priv, pnewskb, &pskb, subfr_len, &is_last);
-				if (nskb == NULL) {					
+				if (nskb == NULL) {
 					DEBUG_ERR("get_subframe() failed, discard AMSDU!\n");
 					dev_kfree_skb_any(pnewskb);
 					priv->ext_stats.rx_data_drops++;
-					break;					
-				}				
+					break;
+				}
 				if (nskb != pnewskb) {
-					nskb->dev = pnewskb->dev;					
-					dev_kfree_skb_any(pnewskb);			
+					nskb->dev = pnewskb->dev;
+					dev_kfree_skb_any(pnewskb);
 					pnewskb = nskb;
-				}				
+				}
 			}
 			else
 #endif
@@ -5831,14 +6457,14 @@ static void process_amsdu(struct rtl8192cd_priv *priv, struct stat_info *pstat,
 
 			pnewskb->len = WLAN_ETHHDR_LEN + subfr_len;
 			pnewskb->tail = pnewskb->data + pnewskb->len;
-			
+
 			if(pnewskb->tail > pnewskb->end) {
 				rtl_kfree_skb(priv, pnewskb, _SKB_RX_);
 				priv->ext_stats.rx_data_drops++;
-				DEBUG_ERR("RX DROP: sub-frame length too large!\n");				
-				break;				
+				DEBUG_ERR("RX DROP: sub-frame length too large!\n");
+				break;
 			}
-			
+
 			if (!memcmp(rfc1042_ip_header, pnewskb->data+WLAN_ETHHDR_LEN, 8)) {
 				for (i=0; i<MACADDRLEN*2; i++)
 					pnewskb->data[19-i] = pnewskb->data[11-i];
@@ -5910,9 +6536,9 @@ static void process_amsdu(struct rtl8192cd_priv *priv, struct stat_info *pstat,
 
 #ifdef RX_BUFFER_GATHER
 			if (rx_gather) {
-				if ((rest <= WLAN_ETHHDR_LEN) && is_last)  
-					break;					
-				
+				if ((rest <= WLAN_ETHHDR_LEN) && is_last)
+					break;
+
 				nskb = shift_padding_len(priv, pskb, padding, &is_last);
 				if (nskb == NULL) {
 					DEBUG_ERR("shift AMSDU padding len error!\n");
@@ -5920,12 +6546,12 @@ static void process_amsdu(struct rtl8192cd_priv *priv, struct stat_info *pstat,
 				}
 				if (nskb != pskb) {
 					rtl_kfree_skb(priv, pskb, _SKB_RX_);
-					pskb = nskb;	
-				}				
-				next_head = pskb->data;	
+					pskb = nskb;
+				}
+				next_head = pskb->data;
 			}
 			else
-#endif			
+#endif
 			next_head += (WLAN_ETHHDR_LEN + subfr_len + padding);
 		}
 		else {
diff --git a/drivers/net/wireless/rtl8192cd/8192cd_security.c b/drivers/net/wireless/rtl8192cd/8192cd_security.c
index 182ba09..bd4d5a2 100644
--- a/drivers/net/wireless/rtl8192cd/8192cd_security.c
+++ b/drivers/net/wireless/rtl8192cd/8192cd_security.c
@@ -279,7 +279,10 @@ static int DOT11_Process_Association_Rsp(struct net_device *dev, struct iw_point
 			if (pstat->expire_to > 0)
 			{
 				cnt_assoc_num(priv, pstat, DECREASE, (char *)__FUNCTION__);
-				check_sta_characteristic(priv, pstat, DECREASE);
+#ifdef CONFIG_RTL_88E_SUPPORT
+				if (GET_CHIP_VER(priv)!=VERSION_8188E) 
+#endif
+					check_sta_characteristic(priv, pstat, DECREASE);
 
 				LOG_MSG("A STA is rejected by 802.1x daemon - %02X:%02X:%02X:%02X:%02X:%02X\n",
 						pstat->hwaddr[0],pstat->hwaddr[1],pstat->hwaddr[2],pstat->hwaddr[3],pstat->hwaddr[4],pstat->hwaddr[5]);
@@ -330,6 +333,7 @@ static int DOT11_Process_Disconnect_Req(struct net_device *dev, struct iw_point
 		{
 			issue_disassoc(priv, BSSID, _RSON_DEAUTH_STA_LEAVING_);					
 			OPMODE &= ~(WIFI_AUTH_SUCCESS | WIFI_ASOC_STATE);
+			start_clnt_lookup(priv, 1);
 			//SME_DEBUG("!!issue disconnect at wlan!!\n");
 		}else{
 			return (-1);
@@ -348,7 +352,10 @@ static int DOT11_Process_Disconnect_Req(struct net_device *dev, struct iw_point
 		if (pstat->expire_to > 0)
 		{
 			cnt_assoc_num(priv, pstat, DECREASE, (char *)__FUNCTION__);
-			check_sta_characteristic(priv, pstat, DECREASE);
+#ifdef CONFIG_RTL_88E_SUPPORT
+			if (GET_CHIP_VER(priv)!=VERSION_8188E) 
+#endif
+				check_sta_characteristic(priv, pstat, DECREASE);
 
 			LOG_MSG("A STA is rejected by 802.1x daemon - %02X:%02X:%02X:%02X:%02X:%02X\n",
 					pstat->hwaddr[0],pstat->hwaddr[1],pstat->hwaddr[2],pstat->hwaddr[3],pstat->hwaddr[4],pstat->hwaddr[5]);
@@ -558,6 +565,10 @@ int DOT11_Process_Set_Key(struct net_device *dev, struct iw_point *data,
 	if(Set_Key.KeyType == DOT11_KeyType_Group)
 	{
 		int set_gkey_to_cam = 0;
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv) == VERSION_8188E)
+			set_gkey_to_cam = 1;
+#endif
 
 #ifdef UNIVERSAL_REPEATER
 		if (IS_VXD_INTERFACE(priv))
@@ -928,6 +939,18 @@ static int DOT11_Process_Set_Port(struct net_device *dev, struct iw_point *data)
 	else
 		pstat->ieee8021x_ctrlport = pmib->dot118021xAuthEntry.dot118021xDefaultPort;
 
+#ifdef P2P_SUPPORT
+	if((OPMODE&WIFI_P2P_SUPPORT)&&( P2PMODE ==P2P_CLIENT)){
+
+		/*to indicate web server that data path is connected done(can start issue udhcpc daemon)*/
+		P2P_STATE = P2P_S_CLIENT_CONNECTED_DHCPC;
+		priv->p2pPtr->clientmode_try_connect = 0;
+		P2P_DEBUG("Set_Port Sta[%02X%02X%02X%02X%02X%02X],Status=%X\n\n\n",
+			Set_Port->MACAddr[0],Set_Port->MACAddr[1],Set_Port->MACAddr[2],
+			Set_Port->MACAddr[3],Set_Port->MACAddr[4],Set_Port->MACAddr[5],
+			Set_Port->PortStatus);
+	}
+#endif	
 	return 0;
 }
 
@@ -1182,11 +1205,11 @@ void DOT11_Indicate_MIC_Failure_Clnt(struct rtl8192cd_priv *priv, unsigned char
 	memcpy(&Mic_Failure.MACAddr, sa, MACADDRLEN);
 	DOT11_EnQueue((unsigned long)priv, priv->pevent_queue, (UINT8 *)&Mic_Failure, sizeof(DOT11_MIC_FAILURE));
 #endif
+	event_indicate(priv, sa, 5);
 #if defined(CLIENT_MODE) && defined(INCLUDE_WPA_PSK)
 	if (OPMODE & (WIFI_STATION_STATE | WIFI_ASOC_STATE))
 		psk_indicate_evt(priv, DOT11_EVENT_MIC_FAILURE, BSSID, NULL, 0);
 #endif
-	event_indicate(priv, sa, 5);
 #ifdef WIFI_WPAS
 	event_indicate_wpas(priv, sa, WPAS_MIC_FAILURE, NULL);
 #endif
@@ -1248,24 +1271,26 @@ void DOT11_Indicate_MIC_Failure_Clnt(struct rtl8192cd_priv *priv, unsigned char
 }
 
 
-#if 0
+#ifdef RADIUS_ACCOUNTING
 void DOT11_Process_Acc_SetExpiredTime(struct net_device *dev, struct iw_point *data)
 {
-	struct rtl8180_priv	*priv = (struct rtl8180_priv *) dev->priv;
-	WLAN_CTX        	*wCtx = (WLAN_CTX *) ( priv->pwlanCtx );
+	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *) dev->priv;
+	//WLAN_CTX        	*wCtx = (WLAN_CTX *) ( priv->pwlanCtx );
 	DOT11_SET_EXPIREDTIME	*Set_ExpireTime = (DOT11_SET_EXPIREDTIME *)data->pointer;
-	int	sta_tbl_idx;
-
-	Set_ExpireTime->EventId = DOT11_EVENT_ACC_SET_EXPIREDTIME;
-	Set_ExpireTime->IsMoreEvent = 0;
+	struct stat_info *pstat=NULL;
 
 	if( Set_ExpireTime != NULL ){
-		if( wlan_sta_tbl_lookup(wCtx, Set_ExpireTime->MACAddr, &sta_tbl_idx) == TRUE ){
-			wCtx->wlan_sta_tbl[sta_tbl_idx].def_expired_time = Set_ExpireTime->ExpireTime;
-			DEBUG_INFO("%s: Set wlan_sta_tbl[%d].def_expired_time = %ld!\n", (char *)__FUNCTION__, sta_tbl_idx, Set_ExpireTime->ExpireTime);
+		Set_ExpireTime->EventId = DOT11_EVENT_ACC_SET_EXPIREDTIME;
+		Set_ExpireTime->IsMoreEvent = 0;
+		
+		if( (pstat = get_stainfo(priv, Set_ExpireTime->MACAddr)) ){
+			pstat->def_expired_time = Set_ExpireTime->ExpireTime;
+			DEBUG_INFO("%s: Set %02x:%02x:%02x:%02x:%02x:%02x def_expired_time = %ld!\n", (char *)__FUNCTION__,
+				pstat->hwaddr[0],pstat->hwaddr[1],pstat->hwaddr[2],pstat->hwaddr[3],pstat->hwaddr[4],pstat->hwaddr[5],
+				Set_ExpireTime->ExpireTime);
 		}
 		else{
-			DEBUG_ERR("%s: ERROR wlan_sta_tbl_lookup!\n", (char *)__FUNCTION__);
+			DEBUG_ERR("%s: ERRO, CAN NOT GET STA INFO!\n", (char *)__FUNCTION__);
 		}
 	}
 	else{
@@ -1276,27 +1301,28 @@ void DOT11_Process_Acc_SetExpiredTime(struct net_device *dev, struct iw_point *d
 
 void DOT11_Process_Acc_QueryStats(struct net_device *dev, struct iw_point *data)
 {
-	struct rtl8180_priv	*priv = (struct rtl8180_priv *) dev->priv;
-	WLAN_CTX        	*wCtx = (WLAN_CTX *) ( priv->pwlanCtx );
+	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *) dev->priv;
+	//WLAN_CTX        	*wCtx = (WLAN_CTX *) ( priv->pwlanCtx );
+	struct stat_info *pstat=NULL;
 	DOT11_QUERY_STATS	*pStats = (DOT11_QUERY_STATS *)data->pointer;
-	int	sta_tbl_idx;
-
-	pStats->EventId = DOT11_EVENT_ACC_QUERY_STATS;
-	pStats->IsMoreEvent = 0;
 
 	if( pStats != NULL ){
-		if( wlan_sta_tbl_lookup(wCtx, pStats->MACAddr, &sta_tbl_idx) == TRUE ){
-			pStats->tx_packets = wCtx->wlan_sta_tbl[sta_tbl_idx].tx_packets ;
-			pStats->rx_packets = wCtx->wlan_sta_tbl[sta_tbl_idx].rx_packets ;
-			pStats->tx_bytes = wCtx->wlan_sta_tbl[sta_tbl_idx].tx_bytes ;
-			pStats->rx_bytes = wCtx->wlan_sta_tbl[sta_tbl_idx].rx_bytes ;
+		pStats->EventId = DOT11_EVENT_ACC_QUERY_STATS;
+		pStats->IsMoreEvent = 0;
+		
+		if( (pstat = get_stainfo(priv, pStats->MACAddr)) ){
+			pStats->tx_packets = pstat->tx_pkts;
+			pStats->rx_packets = pstat->rx_pkts;
+			pStats->tx_bytes = pstat->tx_bytes;
+			pStats->rx_bytes = pstat->rx_bytes;
 
 			pStats->IsSuccess = TRUE;
-			DEBUG_INFO("%s: Get wlan_sta_tbl[%d].stats!\n", (char *)__FUNCTION__, sta_tbl_idx);
+			DEBUG_INFO("%s: Get %02x:%02x:%02x:%02x:%02x:%02x stats!\n", (char *)__FUNCTION__,
+				pstat->hwaddr[0],pstat->hwaddr[1],pstat->hwaddr[2],pstat->hwaddr[3],pstat->hwaddr[4],pstat->hwaddr[5]);
 		}
 		else{
 			pStats->IsSuccess = FALSE;
-			DEBUG_ERR("%s: ERROR wlan_sta_tbl_lookup!\n", (char *)__FUNCTION__);
+			DEBUG_ERR("%s: ERROR, CAN NOT GET STA INFO!\n", (char *)__FUNCTION__);
 		}
 	}
 	else{
@@ -1310,28 +1336,30 @@ void DOT11_Process_Acc_QueryStats(struct net_device *dev, struct iw_point *data)
 //data->pointer = (unsigned char *)stats;
 void DOT11_Process_Acc_QueryStats_All(struct net_device *dev, struct iw_point *data)
 {
-	struct rtl8180_priv	*priv = (struct rtl8180_priv *) dev->priv;
-	WLAN_CTX        	*wCtx = (WLAN_CTX *) ( priv->pwlanCtx );
+	struct list_head *phead=NULL, *plist=NULL;
+	struct stat_info *pstat=NULL;
+	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *) dev->priv;
+	//WLAN_CTX        	*wCtx = (WLAN_CTX *) ( priv->pwlanCtx );
 	DOT11_QUERY_STATS	*pStats = (DOT11_QUERY_STATS *)data->pointer;
 	int i;
 	int cnt = 0;
 
-	if( pStats != NULL ){
+	phead = &priv->asoc_list;
 
-		for( i=1; i<=RTL_AP_MAX_STA_NUM; i++ ){
-			if( ( wCtx->wlan_sta_tbl[i].aid != 0 ) && GstaInfo_assoc( wCtx, i ) ){
-
-				pStats[cnt].EventId = DOT11_EVENT_ACC_QUERY_STATS_ALL;
-				pStats[cnt].IsMoreEvent = 0;
-
-				memcpy( pStats[cnt].MACAddr, wCtx->wlan_sta_tbl[i].addr, 6 );
-				pStats[cnt].tx_packets = wCtx->wlan_sta_tbl[i].tx_packets ;
-				pStats[cnt].rx_packets = wCtx->wlan_sta_tbl[i].rx_packets ;
-				pStats[cnt].tx_bytes = wCtx->wlan_sta_tbl[i].tx_bytes ;
-				pStats[cnt].rx_bytes = wCtx->wlan_sta_tbl[i].rx_bytes ;
-
-				cnt++;
-			}
+	if( pStats != NULL ){
+		plist = phead->next;
+		while (plist != phead) {
+			pstat = list_entry(plist, struct stat_info, asoc_list);
+		
+			pStats[cnt].EventId = DOT11_EVENT_ACC_QUERY_STATS_ALL;
+			pStats[cnt].IsMoreEvent = 0;
+			memcpy( pStats[cnt].MACAddr, pstat->hwaddr, MACADDRLEN );
+			pStats[cnt].tx_packets = pstat->tx_pkts;
+			pStats[cnt].rx_packets = pstat->rx_pkts;
+			pStats[cnt].tx_bytes = pstat->tx_bytes;
+			pStats[cnt].rx_bytes = pstat->rx_bytes;
+
+			cnt++;
 		}
 	}
 	else{
@@ -1629,12 +1657,12 @@ int rtl8192cd_ioctl_priv_daemonreq(struct net_device *dev, struct iw_point *data
 			break;
 
 		case DOT11_EVENT_ACC_SET_EXPIREDTIME:
-			//DOT11_Process_Acc_SetExpiredTime(dev, data);
+			DOT11_Process_Acc_SetExpiredTime(dev, data);
 			DEBUG_INFO("trying to Set ACC Expiredtime\n");
 			break;
 
 		case DOT11_EVENT_ACC_QUERY_STATS:
-			//DOT11_Process_Acc_QueryStats(dev, data);
+			DOT11_Process_Acc_QueryStats(dev, data);
 			DEBUG_INFO("trying to Set ACC Expiredtime\n");
 			break;
 
diff --git a/drivers/net/wireless/rtl8192cd/8192cd_security.h b/drivers/net/wireless/rtl8192cd/8192cd_security.h
index b0801e3..6320e2f 100644
--- a/drivers/net/wireless/rtl8192cd/8192cd_security.h
+++ b/drivers/net/wireless/rtl8192cd/8192cd_security.h
@@ -169,13 +169,7 @@ typedef enum{
 		DOT11_EVENT_WSC_PROBE_REQ_IND = 56,
 		DOT11_EVENT_WSC_PIN_IND = 57,
 		DOT11_EVENT_WSC_ASSOC_REQ_IE_IND = 58,
-		/* WPS2DOTX   */
-	/* support  Assigned MAC Addr,Assigned SSID,dymanic change STA's PIN code, 2011-0505 */	
-		DOT11_EVENT_WSC_SET_MY_PIN = 102,
-		DOT11_EVENT_WSC_SPEC_SSID = 103,
-		DOT11_EVENT_WSC_SPEC_MAC_IND = 104,
-	/* support  Assigned MAC Addr,Assigned SSID,dymanic change STA's PIN code, 2011-0505 */			
-	/* WPS2DOTX   */						
+
 
 #ifdef INCLUDE_WPS
 
@@ -214,6 +208,17 @@ typedef enum{
 	DOT11_EVENT_WSC_STEP_IND = 94,
 	DOT11_EVENT_WSC_OOB_IND = 95,
 #endif
+
+#ifdef P2P_SUPPORT
+		DOT11_EVENT_WSC_SWITCH_MODE = 100,
+		DOT11_EVENT_WSC_STOP = 101,				
+#endif
+	/* support  Assigned MAC Addr,Assigned SSID,dymanic change STA's PIN code, 2011-0505 */	
+		DOT11_EVENT_WSC_SET_MY_PIN = 102,
+		DOT11_EVENT_WSC_SPEC_SSID = 103,
+		DOT11_EVENT_WSC_SPEC_MAC_IND = 104,
+	/* support  Assigned MAC Addr,Assigned SSID,dymanic change STA's PIN code, 2011-0505 */			
+				
 #endif
 #ifdef	CONFIG_RTK_MESH
 	DOT11_EVENT_PATHSEL_GEN_RREQ = 59,
diff --git a/drivers/net/wireless/rtl8192cd/8192cd_sme.c b/drivers/net/wireless/rtl8192cd/8192cd_sme.c
index 3d6a470..9a8da94 100644
--- a/drivers/net/wireless/rtl8192cd/8192cd_sme.c
+++ b/drivers/net/wireless/rtl8192cd/8192cd_sme.c
@@ -30,14 +30,20 @@
 #include "./8192cd_psk.h"
 
 #ifdef CONFIG_RTK_MESH
-#include "./mesh_ext/mesh_util.h"
-#include "./mesh_ext/mesh_route.h"
+#include "../mesh_ext/mesh_util.h"
+#include "../mesh_ext/mesh_route.h"
 #ifdef MESH_USE_METRICOP
 #include "mesh_ext/mesh_11kv.h"
 #endif
 #endif
 
 #ifdef WIFI_SIMPLE_CONFIG
+#ifdef P2P_SUPPORT
+extern unsigned char WFA_OUI[];
+extern unsigned char WFA_OUI_PLUS_TYPE[];
+#define MAX_REASSEM_P2P_IE 512
+
+#endif
 #ifdef INCLUDE_WPS
 #include "./wps/wsc.h"
 #endif
@@ -61,7 +67,7 @@ unsigned char WMM_IE[] = {0x00, 0x50, 0xf2, 0x02, 0x00, 0x01};
 unsigned char WMM_PARA_IE[] = {0x00, 0x50, 0xf2, 0x02, 0x01, 0x01};
 #endif
 
-#define INTEL_OUI_NUM	72
+#define INTEL_OUI_NUM	89
 unsigned char INTEL_OUI[INTEL_OUI_NUM][3] =
 {{0x00, 0x02, 0xb3}, {0x00, 0x03, 0x47},
 {0x00, 0x04, 0x23}, {0x00, 0x07, 0xe9},
@@ -87,18 +93,27 @@ unsigned char INTEL_OUI[INTEL_OUI_NUM][3] =
 {0x00, 0x24, 0xd6}, {0x00, 0x24, 0xd7},
 {0x00, 0x26, 0xc6}, {0x00, 0x26, 0xc7},
 {0x00, 0x27, 0x0e}, {0x00, 0x27, 0x10},
-{0x00, 0x90, 0x27}, {0x00, 0xa0, 0xc9},
-{0x00, 0xaa, 0x00}, {0x00, 0xaa, 0x01},
-{0x00, 0xaa, 0x02}, {0x00, 0xd0, 0xb7},
-{0x08, 0x11, 0x96}, {0x18, 0x3d, 0xa2},
+{0x00, 0x50, 0xf1}, {0x00, 0x90, 0x27}, 
+{0x00, 0xa0, 0xc9}, {0x00, 0xaa, 0x00}, 
+{0x00, 0xaa, 0x01}, {0x00, 0xaa, 0x02}, 
+{0x00, 0xd0, 0xb7}, {0x00, 0xdb, 0xbf},
+{0x08, 0x11, 0x96}, {0x0c, 0xd2, 0x92},
+{0x10, 0x0b, 0xa9}, {0x18, 0x3d, 0xa2},
 {0x24, 0x77, 0x03}, {0x40, 0x25, 0xc2},
 {0x44, 0x85, 0x00}, {0x4c, 0x80, 0x93},
-{0x50, 0x2d, 0xa2}, {0x58, 0x94, 0x6b},
-{0x64, 0x80, 0x99}, {0x64, 0xd4, 0xda},
-{0x74, 0xe5, 0x0b}, {0x78, 0x92, 0x9c},
-{0x88, 0x53, 0x2e}, {0x8c, 0xa9, 0x82},
+{0x4c, 0xeb, 0x42}, {0x50, 0x2d, 0xa2}, 
+{0x58, 0x91, 0xcf}, {0x58, 0x94, 0x6b},
+{0x60, 0x67, 0x20}, {0x64, 0x80, 0x99}, 
+{0x64, 0xd4, 0xda}, {0x68, 0x05, 0xca},
+{0x68, 0x5d, 0x43}, {0x74, 0xe5, 0x0b}, 
+{0x78, 0x92, 0x9c}, {0x80, 0x9b, 0x20},
+{0x88, 0x53, 0x2e}, {0x8c, 0x70, 0x5a},
+{0x8c, 0xa9, 0x82}, {0x90, 0xe2, 0xba},
+{0x9c, 0x4e, 0x36}, {0xa0, 0x36, 0x9f},
 {0xa0, 0x88, 0xb4}, {0xac, 0x72, 0x89},
-{0xbc, 0x77, 0x37}, {0xdc, 0xa9, 0x71}};
+{0xb8, 0x03, 0x05}, {0xbc, 0x77, 0x37}, 
+{0xc4, 0x85, 0x08}, {0xdc, 0xa9, 0x71},
+{0xe0, 0x94, 0x67}};
 
 
 #ifdef DOT11D
@@ -291,11 +306,14 @@ static unsigned int OnDeAuthClnt(struct rtl8192cd_priv *priv, struct rx_frinfo *
 static void start_clnt_assoc(struct rtl8192cd_priv *priv);
 static void calculate_rx_beacon(struct rtl8192cd_priv *priv);
 static void updateTSF(struct rtl8192cd_priv *priv);
-#endif
-
-#if defined(CLIENT_MODE) && defined(WIFI_11N_2040_COEXIST)
+static void issue_PwrMgt_NullData(struct rtl8192cd_priv * priv);
+static unsigned int isOurFrameBuffred(unsigned char* tim, unsigned int aid);
+#ifdef WIFI_11N_2040_COEXIST
 static void issue_coexist_mgt(struct rtl8192cd_priv *priv);
 #endif
+#endif
+
+void SelectRTSInitialRate(struct rtl8192cd_priv *priv);
 
 struct mlme_handler {
 	unsigned int   num;
@@ -369,6 +387,13 @@ struct mlme_handler mlme_station_tbl[]={
 };
 #endif
 
+#ifdef CONFIG_RTL_WLAN_DOS_FILTER
+#define MAX_BLOCK_MAC		4
+unsigned char block_mac[MAX_BLOCK_MAC][6];
+unsigned int block_mac_idx = 0;
+unsigned int block_sta_time = 0;
+unsigned long block_priv;
+#endif
 
 static int is_support_wpa_aes(struct rtl8192cd_priv *priv, unsigned char *pucIE, unsigned long ulIELength)
 {
@@ -571,7 +596,7 @@ unsigned char *search_VendorExt_tag(unsigned char *data, unsigned char id, int l
 }
 /* WPS2DOTX   */
 
-static unsigned char *search_wsc_tag(unsigned char *data, unsigned short id, int len, int *out_len)
+unsigned char *search_wsc_tag(unsigned char *data, unsigned short id, int len, int *out_len)
 {
 	unsigned short tag, tag_len;
 	int size;
@@ -867,56 +892,6 @@ static void auth_expire(struct rtl8192cd_priv *priv)
 }
 
 
-static void check_RA_by_rssi(struct rtl8192cd_priv *priv, struct stat_info *pstat)
-{
-	int level = 0;
-
-	switch (pstat->rssi_level) {
-		case 1:
-			if (pstat->rssi >= priv->pshare->rf_ft_var.raGoDownUpper)
-				level = 1;
-			else if ((pstat->rssi >= priv->pshare->rf_ft_var.raGoDown20MLower) ||
-				((priv->pshare->is_40m_bw) && (pstat->ht_cap_len) &&
-				(pstat->rssi >= priv->pshare->rf_ft_var.raGoDown40MLower) &&
-				(pstat->ht_cap_buf.ht_cap_info & cpu_to_le16(_HTCAP_SUPPORT_CH_WDTH_))))
-				level = 2;
-			else
-				level = 3;
-			break;
-		case 2:
-			if (pstat->rssi > priv->pshare->rf_ft_var.raGoUpUpper)
-				level = 1;
-			else if ((pstat->rssi < priv->pshare->rf_ft_var.raGoDown40MLower) ||
-				((!pstat->ht_cap_len || !priv->pshare->is_40m_bw ||
-				!(pstat->ht_cap_buf.ht_cap_info & cpu_to_le16(_HTCAP_SUPPORT_CH_WDTH_))) &&
-				(pstat->rssi < priv->pshare->rf_ft_var.raGoDown20MLower)))
-				level = 3;
-			else
-				level = 2;
-			break;
-		case 3:
-			if (pstat->rssi > priv->pshare->rf_ft_var.raGoUpUpper)
-				level = 1;
-			else if ((pstat->rssi > priv->pshare->rf_ft_var.raGoUp20MLower) ||
-				((priv->pshare->is_40m_bw) && (pstat->ht_cap_len) &&
-				(pstat->rssi > priv->pshare->rf_ft_var.raGoUp40MLower) &&
-				(pstat->ht_cap_buf.ht_cap_info & cpu_to_le16(_HTCAP_SUPPORT_CH_WDTH_))))
-				level = 2;
-			else
-				level = 3;
-			break;
-		default:
-			if (isErpSta(pstat))
-				DEBUG_ERR("wrong rssi level setting\n");
-			break;
-	}
-
-	if (level != pstat->rssi_level) {
-		pstat->rssi_level = level;
-		add_update_RATid(priv, pstat);
-	}
-}
-
 
 #if 0 // def RTL8192SE
 void reset_1r_sta_RA(struct rtl8192cd_priv *priv, unsigned int sg_rate){
@@ -966,82 +941,6 @@ void reset_1r_sta_RA(struct rtl8192cd_priv *priv, unsigned int sg_rate){
 #endif
 
 
-void check_txrate_by_reg(struct rtl8192cd_priv *priv, struct stat_info *pstat)
-{
-	unsigned char initial_rate = 0x7f;
-	unsigned char legacyRA =0 ;
-
-	if( should_restrict_Nrate(priv, pstat) && is_fixedMCSTxRate(priv))
-		legacyRA = 1;
-	
-#ifdef STA_EXT
-	if (pstat->remapped_aid && (pstat->remapped_aid < FW_NUM_STAT-1))
-#else
-	if (pstat->aid && (pstat->aid < 32))
-#endif
-	{
-#ifdef WDS
-		if (((pstat->state & WIFI_WDS) && (priv->pmib->dot11WdsInfo.entry[pstat->wds_idx].txRate == 0)) ||
-			(!(pstat->state & WIFI_WDS) && (priv->pmib->dot11StationConfigEntry.autoRate)) || legacyRA)
-#else
-		if (priv->pmib->dot11StationConfigEntry.autoRate || legacyRA)
-#endif
-		{
-			initial_rate = RTL_R8(INIDATA_RATE_SEL + REMAP_AID(pstat)) & 0x7f;
-			if (initial_rate == 0x7f)
-				return;
-			if ((initial_rate&0x3f) < 12)
-				pstat->current_tx_rate = dot11_rate_table[initial_rate];
-			else
-				pstat->current_tx_rate = 0x80|((initial_rate&0x3f) -12);
-
-			if (initial_rate & BIT(6))
-				pstat->ht_current_tx_info |= TX_USE_SHORT_GI;
-			else
-				pstat->ht_current_tx_info &= ~TX_USE_SHORT_GI;
-
-			priv->pshare->current_tx_rate    = pstat->current_tx_rate;
-			priv->pshare->ht_current_tx_info = pstat->ht_current_tx_info;
-		} else if (pstat->ht_cap_len) {
-			unsigned int is_sgi = 0;
-
-			if (priv->pshare->is_40m_bw && (pstat->tx_bw == HT_CHANNEL_WIDTH_20_40)
-#ifdef WIFI_11N_2040_COEXIST
-				&& !((OPMODE & WIFI_AP_STATE) && priv->pmib->dot11nConfigEntry.dot11nCoexist &&
-				(priv->bg_ap_timeout || priv->force_20_sta || priv->switch_20_sta
-#ifdef STA_EXT
-				|| priv->force_20_sta_ext || priv->switch_20_sta_ext
-#endif
-				))
-#endif
-			) {
-				if (priv->pmib->dot11nConfigEntry.dot11nShortGIfor40M
-					&& (pstat->ht_cap_buf.ht_cap_info & cpu_to_le16(_HTCAP_SHORTGI_40M_)))
-					is_sgi++;
-			} else if (priv->pmib->dot11nConfigEntry.dot11nShortGIfor20M
-				&& (pstat->ht_cap_buf.ht_cap_info & cpu_to_le16(_HTCAP_SHORTGI_20M_))) {
-				is_sgi++;
-			}
-
-			if (is_sgi)
-				pstat->ht_current_tx_info |= TX_USE_SHORT_GI;
-			else
-				pstat->ht_current_tx_info &= ~TX_USE_SHORT_GI;
-		}
-
-		if (pstat->ht_cap_len) {
-			if (priv->pshare->is_40m_bw && (pstat->tx_bw == HT_CHANNEL_WIDTH_20_40))
-				pstat->ht_current_tx_info |= TX_USE_40M_MODE;
-			else
-				pstat->ht_current_tx_info &= ~TX_USE_40M_MODE;
-		}
-
-		priv->pshare->ht_current_tx_info = pstat->ht_current_tx_info;
-	} else {
-		DEBUG_INFO("sta has no aid found to check current tx rate\n");
-	}
-}
-
 
 // for simplify, we consider only two stations. Otherwise we may sorting all the stations and
 // hard to maintain the code.
@@ -1135,6 +1034,21 @@ static void assoc_expire(struct rtl8192cd_priv *priv)
 	{
 		pstat = list_entry(plist, struct stat_info, asoc_list);
 		pstat->link_time++;
+
+#ifdef CLIENT_MODE
+		if ((OPMODE & WIFI_STATION_STATE) && (pstat->expire_to > 0)) {
+			if ((priv->pshare->rf_ft_var.sta_mode_ps && !priv->ps_state) ||
+				(!priv->pshare->rf_ft_var.sta_mode_ps && priv->ps_state)) {
+				if (!priv->ps_state)
+					priv->ps_state++;
+				else
+					priv->ps_state = 0;
+
+				issue_PwrMgt_NullData(priv);
+			}
+		}
+#endif
+
 		// Check idle using packet transmit....nctu note it
 		ok_curr = pstat->tx_pkts - pstat->tx_fail;
 		ok_pre = pstat->tx_pkts_pre - pstat->tx_fail_pre;
@@ -1178,8 +1092,11 @@ static void assoc_expire(struct rtl8192cd_priv *priv)
 					if (!(pstat->state & WIFI_WDS_LAZY)) 
 #endif
 					{
-					cnt_assoc_num(priv, pstat, DECREASE, (char *)__FUNCTION__);
-					check_sta_characteristic(priv, pstat, DECREASE);
+						cnt_assoc_num(priv, pstat, DECREASE, (char *)__FUNCTION__);
+#ifdef CONFIG_RTL_88E_SUPPORT
+						if (GET_CHIP_VER(priv)!=VERSION_8188E) 
+#endif
+							check_sta_characteristic(priv, pstat, DECREASE);
 					}
 
 					// CAM entry update
@@ -1214,6 +1131,16 @@ static void assoc_expire(struct rtl8192cd_priv *priv)
 				}
 
 				pstat->expire_to--;
+#ifdef P2P_SUPPORT
+				if(pstat->expire_to == 0){
+					if(OPMODE&WIFI_P2P_SUPPORT && P2PMODE==P2P_TMP_GO){
+						if(pstat->is_p2p_client){
+							P2P_DEBUG("p2p client leaved excced %d seconds\n",P2P_CLIENT_ASSOC_EXPIRE);
+							p2p_client_remove(priv,pstat);
+						}
+					}
+				}
+#endif
 			}
 			else {
 				free_sta_tx_skb(priv, pstat);
@@ -1225,12 +1152,26 @@ static void assoc_expire(struct rtl8192cd_priv *priv)
 			/*
 			 * pass rssi info to f/w
 			 */
+#if defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT)
+			if (
+#ifdef CONFIG_RTL_92C_SUPPORT
+				(GET_CHIP_VER(priv)==VERSION_8192C) || (GET_CHIP_VER(priv)==VERSION_8188C) 
+#endif
+#ifdef CONFIG_RTL_92D_SUPPORT
+#ifdef CONFIG_RTL_92C_SUPPORT
+				|| 
+#endif
+				(GET_CHIP_VER(priv)==VERSION_8192D)
+#endif
+				) {
 #ifdef STA_EXT
-			if (REMAP_AID(pstat) < (FW_NUM_STAT - 1))
+				if (REMAP_AID(pstat) < (FW_NUM_STAT - 1))
+#endif
+					add_update_rssi(priv, pstat);
+			}
 #endif
-				add_update_rssi(priv, pstat);
 
-			if (priv->pshare->rf_ft_var.rssi_dump) {
+			if (priv->pshare->rf_ft_var.rssi_dump && !(priv->up_time % priv->pshare->rf_ft_var.rssi_dump)) {
 				panic_printk("[%d] %d%%  tx %s%d%s rx %s%d%s (ss %d %d)(FA %d)(CCA %d)(DIG 0x%x)(TP %d,%d)",
 					pstat->aid, pstat->rssi,
 					(pstat->current_tx_rate&0x80)? "MCS" : "",
@@ -1239,7 +1180,14 @@ static void assoc_expire(struct rtl8192cd_priv *priv)
 					(pstat->rx_rate&0x80)? "MCS" : "",
 					(pstat->rx_rate&0x80)? pstat->rx_rate&0x7f : pstat->rx_rate/2,
 					pstat->rx_splcp? "s" : " ",
-					pstat->rf_info.mimorssi[0], pstat->rf_info.mimorssi[1],
+#ifdef CONFIG_RTL_88E_SUPPORT
+					(GET_CHIP_VER(priv)==VERSION_8188E)?0:
+#endif
+					pstat->rf_info.mimorssi[0], 
+#ifdef CONFIG_RTL_88E_SUPPORT
+					(GET_CHIP_VER(priv)==VERSION_8188E)?0:
+#endif
+					pstat->rf_info.mimorssi[1],
 					priv->pshare->FA_total_cnt,
 					priv->pshare->CCA_total_cnt,
 					RTL_R8(0xc50),
@@ -1248,12 +1196,21 @@ static void assoc_expire(struct rtl8192cd_priv *priv)
 #ifdef CONFIG_RTL8672
 				panic_printk("(FA %x,%x %d, %d)",
 					RTL_R8(0xc50), RTL_R8(0xc58),
+#ifdef INTERFERENCE_CONTROL
+					priv->pshare->ofdm_FA_total_cnt,
+#else
 					priv->pshare->ofdm_FA_cnt1+priv->pshare->ofdm_FA_cnt2+priv->pshare->ofdm_FA_cnt3+priv->pshare->ofdm_FA_cnt4,
+#endif
 					priv->pshare->cck_FA_cnt);
 #endif
 				panic_printk("\n");
 			}
 
+#if defined(CONFIG_RTL_88E_SUPPORT) && defined(TXREPORT)
+			if ((GET_CHIP_VER(priv) == VERSION_8188E) && priv->pmib->dot11StationConfigEntry.autoRate)
+				priv->pshare->RaInfo[pstat->aid].RssiStaRA = pstat->rssi;
+#endif
+
 			// calculate STA number
 			if ((pstat->expire_to == 0)
 #ifdef WDS
@@ -1261,7 +1218,10 @@ static void assoc_expire(struct rtl8192cd_priv *priv)
 #endif
 			) {
 				cnt_assoc_num(priv, pstat, INCREASE, (char *)__FUNCTION__);
-				check_sta_characteristic(priv, pstat, INCREASE);
+#ifdef CONFIG_RTL_88E_SUPPORT
+				if (GET_CHIP_VER(priv)!=VERSION_8188E) 
+#endif
+					check_sta_characteristic(priv, pstat, INCREASE);
 
 				// CAM entry update
 				if (!SWCRYPTO) {
@@ -1285,7 +1245,16 @@ static void assoc_expire(struct rtl8192cd_priv *priv)
 
 #ifdef STA_EXT
 				// Resume Ratid
+#ifdef CONFIG_RTL_88E_SUPPORT
+			if (GET_CHIP_VER(priv)==VERSION_8188E) {
+#ifdef TXREPORT
+				add_RATid(priv, pstat);
+#endif
+			} else
+#endif
+			{
 				add_update_RATid(priv, pstat);
+			}
 #endif
 
 				//pstat->dwngrade_probation_idx = pstat->upgrade_probation_idx = 0;	// unused
@@ -1293,7 +1262,16 @@ static void assoc_expire(struct rtl8192cd_priv *priv)
 					pstat->hwaddr[0],pstat->hwaddr[1],pstat->hwaddr[2],pstat->hwaddr[3],pstat->hwaddr[4],pstat->hwaddr[5]);
 			}
 
-			pstat->expire_to = priv->expire_to;
+#ifdef 	P2P_SUPPORT
+			if( OPMODE&WIFI_P2P_SUPPORT && (P2PMODE==P2P_TMP_GO) ){
+				if(pstat->is_p2p_client)
+					pstat->expire_to = P2P_CLIENT_ASSOC_EXPIRE;
+
+			}else
+#endif
+			{
+				pstat->expire_to = priv->expire_to;
+			}
 
 		}
 
@@ -1312,17 +1290,37 @@ static void assoc_expire(struct rtl8192cd_priv *priv)
 			}
 		}
 #endif
+		// update proc bssdesc
+		if ((OPMODE & WIFI_STATION_STATE) && !memcmp(priv->pmib->dot11Bss.bssid, pstat->hwaddr, MACADDRLEN)) {
+			priv->pmib->dot11Bss.rssi = pstat->rssi; 
+			priv->pmib->dot11Bss.sq = pstat->sq; 
+		}
 
 		pstat->tx_pkts_pre = pstat->tx_pkts;
 		pstat->rx_pkts_pre = pstat->rx_pkts;
 		pstat->tx_fail_pre = pstat->tx_fail;
 
 		if ((priv->up_time % 3) == 0) {
+#ifndef DRVMAC_LB
 			if (priv->pmib->dot11StationConfigEntry.autoRate
 				|| (should_restrict_Nrate(priv, pstat) && is_fixedMCSTxRate(priv)))
 				check_RA_by_rssi(priv, pstat);
+#endif
 
-			check_txrate_by_reg(priv, pstat);
+#if defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT)
+			if (
+#ifdef CONFIG_RTL_92C_SUPPORT
+				(GET_CHIP_VER(priv)==VERSION_8192C) || (GET_CHIP_VER(priv)==VERSION_8188C) 
+#endif
+#ifdef CONFIG_RTL_92D_SUPPORT
+#ifdef CONFIG_RTL_92C_SUPPORT
+				|| 
+#endif
+				(GET_CHIP_VER(priv)==VERSION_8192D)
+#endif
+				)
+				check_txrate_by_reg(priv, pstat);
+#endif
 
 			/*
 			 *	Check if station is 2T
@@ -1334,7 +1332,7 @@ static void assoc_expire(struct rtl8192cd_priv *priv)
 			 *	Check if station is near by to use lower tx power
 			 */
 			if (priv->pshare->rf_ft_var.tx_pwr_ctrl) {
-				if ((pstat->hp_level == 0) && (pstat->rssi > HP_LOWER+5))
+				if ((pstat->hp_level == 0) && (pstat->rssi > HP_LOWER+4))
 					pstat->hp_level = 1;
 				else if ((pstat->hp_level == 1) && (pstat->rssi < HP_LOWER))
 					pstat->hp_level = 0;
@@ -1350,13 +1348,19 @@ static void assoc_expire(struct rtl8192cd_priv *priv)
 					pstat->no_rts = 1;
 			}
 #endif
-#if 0
-			const char thd = 30;		
-			if (!pstat->no_rts && pstat->rssi<thd) 
-				pstat->no_rts=1;
-			else if(pstat->no_rts && pstat->rssi>thd+5) 
-				pstat->no_rts=0;
+#ifdef CONFIG_RTL_88E_SUPPORT
+			if (GET_CHIP_VER(priv)==VERSION_8188E) {
+				const char thd = 20;
+				if (!pstat->no_rts && pstat->rssi<thd)
+					pstat->no_rts=1;
+				else if(pstat->no_rts && pstat->rssi>thd+5) 
+					pstat->no_rts=0;
+			}
 #endif
+
+			/* Count every Intel clients with complying throughput margin */
+			if ((pstat->tx_byte_cnt + pstat->rx_byte_cnt) >= priv->pshare->rf_ft_var.intel_rtylmt_tp_margin)
+				priv->pshare->intel_active_sta++;
 		}
 
 		choose_IOT_main_sta(priv, pstat);
@@ -1376,7 +1380,7 @@ static void assoc_expire(struct rtl8192cd_priv *priv)
 			pstat_highest = pstat;
 		}
 #if defined(HW_ANT_SWITCH)
-		if(priv->pshare->rf_ft_var.antHw_enable) 
+		if(HW_DIV_ENABLE) 
 			dm_STA_Ant_Select(priv, pstat);
 #endif
 
@@ -1403,9 +1407,14 @@ static void assoc_expire(struct rtl8192cd_priv *priv)
 	                        pstat->retry_inc = 0;
         	        }
         	}
-
-		if (((GET_ROOT(priv)->up_time % 3) == 1) && (pstat->rssi < priv->pshare->rssi_min) &&
+#if 1
+//#ifdef INTERFERENCE_CONTROL
+		if (/*((GET_ROOT(priv)->up_time % 3) == 1) && */(pstat->rssi < priv->pshare->rssi_min) &&
 			(pstat->expire_to > (priv->expire_to - priv->pshare->rf_ft_var.rssi_expire_to)))
+#else
+		if (((GET_ROOT(priv)->up_time % 3) == 1) && (pstat->rssi < priv->pshare->rssi_min) &&
+	               (pstat->expire_to > (priv->expire_to - priv->pshare->rf_ft_var.rssi_expire_to)))
+#endif
 			priv->pshare->rssi_min = pstat->rssi;
 
 		/*
@@ -1420,7 +1429,7 @@ static void assoc_expire(struct rtl8192cd_priv *priv)
 	}
 
 #if defined(HW_ANT_SWITCH)
-	if(priv->pshare->rf_ft_var.antHw_enable)  {
+	if(HW_DIV_ENABLE)  {
 		dm_HW_IdleAntennaSelect(priv);
 	}
 #endif
@@ -1579,7 +1588,7 @@ static int check_tx_hangup(struct rtl8192cd_priv *priv, int q_num, int *pTail, i
 
 	*pTail = tail;
 
-	if (CIRC_CNT_RTK(head, tail, NUM_TX_DESC))
+	if (CIRC_CNT_RTK(head, tail, CURRENT_NUM_TX_DESC))
 	{
 		*pIsEmpty = 0;
 		pdesc = pdescH + (tail);
@@ -1819,7 +1828,7 @@ int check_hangup(struct rtl8192cd_priv *priv)
 	void *vxd_info = NULL;
 #endif
 #endif // FAST_RECOVERY
-#ifdef CONFIG_RTL_WTDOG
+#if defined(CONFIG_RTL865X_WTDOG) || (defined(CONFIG_RTL_WTDOG) && defined(CONFIG_RTL_92D_SUPPORT))
 #if !(defined(CONFIG_RTL8196B) || defined(CONFIG_RTL_8196C))
 	unsigned long wtval;
 #endif
@@ -2252,7 +2261,7 @@ int check_hangup(struct rtl8192cd_priv *priv)
 		RESTORE_INT(flags);
 		SMP_UNLOCK(flags);
 
-#if defined(CONFIG_RTL865X_WTDOG) || (defined(CONFIG_RTL_WTDOG) && defined(CONFIG_RTL_92D_SUPPORT))
+#ifdef CONFIG_RTL_WTDOG
 #if !(defined(CONFIG_RTL8196B) || defined(CONFIG_RTL_819X))
 	*((volatile unsigned long *)0xB800311C) |=  1 << 23;
 	*((volatile unsigned long *)0xB800311C) = wtval;
@@ -2458,6 +2467,18 @@ void init_WMM_Para_Element(struct rtl8192cd_priv *priv, unsigned char *temp)
 	else if ((OPMODE & WIFI_STATION_STATE) ||(OPMODE & WIFI_ADHOC_STATE)) {  //  WMM STA
 		memcpy(temp, WMM_IE, 6);
 		temp[6] = 0x00;  //  set zero to WMM STA Qos Info field
+#ifdef WMM_APSD
+		if ((OPMODE & WIFI_STATION_STATE) && APSD_ENABLE && priv->uapsd_assoc) {
+			if (priv->pmib->dot11QosEntry.UAPSD_AC_BE)
+				temp[6] |= BIT(3);
+			if (priv->pmib->dot11QosEntry.UAPSD_AC_BK)
+				temp[6] |= BIT(2);
+			if (priv->pmib->dot11QosEntry.UAPSD_AC_VI)
+				temp[6] |= BIT(1);
+			if (priv->pmib->dot11QosEntry.UAPSD_AC_VO)
+				temp[6] |= BIT(0);
+		}
+#endif
 	}
 #endif
 }
@@ -2535,6 +2556,9 @@ __NOMIPS16
 static void process_WMM_para_ie(struct rtl8192cd_priv *priv, unsigned char *p)
 {
 	int ACI = (p[0] >> 5) & 0x03;
+	/*avoid unaligned load*/
+	unsigned short txoplimit;
+	memcpy(&txoplimit,&p[2],sizeof(unsigned short));
 	if ((ACI >= 0) && (ACI <= 3)) {
 		switch(ACI) {
 			case 0:
@@ -2542,44 +2566,28 @@ static void process_WMM_para_ie(struct rtl8192cd_priv *priv, unsigned char *p)
 				GET_STA_AC_BE_PARA.AIFSN = p[0] & 0x0f;
 				GET_STA_AC_BE_PARA.ECWmin = p[1] & 0x0f;
 				GET_STA_AC_BE_PARA.ECWmax = p[1] >> 4;
-				GET_STA_AC_BE_PARA.TXOPlimit = le16_to_cpu(*(unsigned short *)(&p[2]));
-				DEBUG_INFO("BE: ACM %d, AIFSN %d, ECWmin %d, ECWmax %d, TXOP %d\n",
-					GET_STA_AC_BE_PARA.ACM, GET_STA_AC_BE_PARA.AIFSN,
-					GET_STA_AC_BE_PARA.ECWmin, GET_STA_AC_BE_PARA.ECWmax,
-					GET_STA_AC_BE_PARA.TXOPlimit);
+				GET_STA_AC_BE_PARA.TXOPlimit = le16_to_cpu(txoplimit);
 				break;
 			case 3:
 				GET_STA_AC_VO_PARA.ACM = (p[0] >> 4) & 0x01;
 				GET_STA_AC_VO_PARA.AIFSN = p[0] & 0x0f;
 				GET_STA_AC_VO_PARA.ECWmin = p[1] & 0x0f;
 				GET_STA_AC_VO_PARA.ECWmax = p[1] >> 4;
-				GET_STA_AC_VO_PARA.TXOPlimit = le16_to_cpu(*(unsigned short *)(&p[2]));
-				DEBUG_INFO("VO: ACM %d, AIFSN %d, ECWmin %d, ECWmax %d, TXOP %d\n",
-					GET_STA_AC_VO_PARA.ACM, GET_STA_AC_VO_PARA.AIFSN,
-					GET_STA_AC_VO_PARA.ECWmin, GET_STA_AC_VO_PARA.ECWmax,
-					GET_STA_AC_VO_PARA.TXOPlimit);
+				GET_STA_AC_VO_PARA.TXOPlimit = le16_to_cpu(txoplimit);
 				break;
 			case 2:
 				GET_STA_AC_VI_PARA.ACM = (p[0] >> 4) & 0x01;
 				GET_STA_AC_VI_PARA.AIFSN = p[0] & 0x0f;
 				GET_STA_AC_VI_PARA.ECWmin = p[1] & 0x0f;
 				GET_STA_AC_VI_PARA.ECWmax = p[1] >> 4;
-				GET_STA_AC_VI_PARA.TXOPlimit = le16_to_cpu(*(unsigned short *)(&p[2]));
-				DEBUG_INFO("VI: ACM %d, AIFSN %d, ECWmin %d, ECWmax %d, TXOP %d\n",
-					GET_STA_AC_VI_PARA.ACM, GET_STA_AC_VI_PARA.AIFSN,
-					GET_STA_AC_VI_PARA.ECWmin, GET_STA_AC_VI_PARA.ECWmax,
-					GET_STA_AC_VI_PARA.TXOPlimit);
+				GET_STA_AC_VI_PARA.TXOPlimit = le16_to_cpu(txoplimit);
 				break;
 			default:
 				GET_STA_AC_BK_PARA.ACM = (p[0] >> 4) & 0x01;
 				GET_STA_AC_BK_PARA.AIFSN = p[0] & 0x0f;
 				GET_STA_AC_BK_PARA.ECWmin = p[1] & 0x0f;
 				GET_STA_AC_BK_PARA.ECWmax = p[1] >> 4;
-				GET_STA_AC_BK_PARA.TXOPlimit = le16_to_cpu(*(unsigned short *)(&p[2]));
-				DEBUG_INFO("BK: ACM %d, AIFSN %d, ECWmin %d, ECWmax %d, TXOP %d\n",
-					GET_STA_AC_BK_PARA.ACM, GET_STA_AC_BK_PARA.AIFSN,
-					GET_STA_AC_BK_PARA.ECWmin, GET_STA_AC_BK_PARA.ECWmax,
-					GET_STA_AC_BK_PARA.TXOPlimit);
+				GET_STA_AC_BK_PARA.TXOPlimit = le16_to_cpu(txoplimit);
 				break;
 		}
 	}
@@ -2605,6 +2613,8 @@ static void sta_config_EDCA_para(struct rtl8192cd_priv *priv)
 			| (((unsigned char)(GET_STA_AC_VO_PARA.ECWmax)) << 12)
 			| (((unsigned char)(GET_STA_AC_VO_PARA.ECWmin)) << 8)
 			| (ifs_time + GET_STA_AC_VO_PARA.AIFSN * slot_time);
+
+		RTL_W32(EDCA_VO_PARA, vo_edca);
 	}
 
 	if (GET_STA_AC_VI_PARA.AIFSN) {
@@ -2612,6 +2622,12 @@ static void sta_config_EDCA_para(struct rtl8192cd_priv *priv)
 			| (((unsigned char)(GET_STA_AC_VI_PARA.ECWmax)) << 12)
 			| (((unsigned char)(GET_STA_AC_VI_PARA.ECWmin)) << 8)
 			| (ifs_time + GET_STA_AC_VI_PARA.AIFSN * slot_time);
+
+		/* WiFi Client mode WMM test IOT refine */
+		if (priv->pmib->dot11OperationEntry.wifi_specific && (GET_STA_AC_VI_PARA.AIFSN == 2))
+			vi_edca = (vi_edca & ~0xff) | (ifs_time + (GET_STA_AC_VI_PARA.AIFSN + 1) * slot_time);
+
+		RTL_W32(EDCA_VI_PARA, vi_edca);
 	}
 
 	if (GET_STA_AC_BE_PARA.AIFSN) {
@@ -2619,6 +2635,8 @@ static void sta_config_EDCA_para(struct rtl8192cd_priv *priv)
 			| (((unsigned char)(GET_STA_AC_BE_PARA.ECWmax)) << 12)
 			| (((unsigned char)(GET_STA_AC_BE_PARA.ECWmin)) << 8)
 			| (ifs_time + GET_STA_AC_BE_PARA.AIFSN * slot_time);
+
+		RTL_W32(EDCA_BE_PARA, be_edca);
 	}
 
 	if (GET_STA_AC_BK_PARA.AIFSN) {
@@ -2629,35 +2647,6 @@ static void sta_config_EDCA_para(struct rtl8192cd_priv *priv)
 		
 		RTL_W32(EDCA_BK_PARA, bk_edca);
 	}
-
-	if (GET_STA_AC_VO_PARA.ACM) {
-		if (!GET_STA_AC_VI_PARA.ACM)
-			RTL_W32(EDCA_VO_PARA, vi_edca);
-		else if (!GET_STA_AC_BE_PARA.ACM)
-			RTL_W32(EDCA_VO_PARA, be_edca);
-		else
-			RTL_W32(EDCA_VO_PARA, bk_edca);
-	} else {
-		RTL_W32(EDCA_VO_PARA, vo_edca);
-	}
-
-	if (GET_STA_AC_VI_PARA.ACM) {
-		if (!GET_STA_AC_BE_PARA.ACM)
-			RTL_W32(EDCA_VI_PARA, be_edca);
-		else
-			RTL_W32(EDCA_VI_PARA, bk_edca);
-	} else {
-		/* WiFi Client mode WMM test IOT refine */
-		if (priv->pmib->dot11OperationEntry.wifi_specific && (GET_STA_AC_VI_PARA.AIFSN == 2))
-			vi_edca = (vi_edca & ~0xff) | (ifs_time + (GET_STA_AC_VI_PARA.AIFSN + 1) * slot_time);
-
-		RTL_W32(EDCA_VI_PARA, vi_edca);
-	}
-
-	if (GET_STA_AC_BE_PARA.ACM)
-		RTL_W32(EDCA_BE_PARA, bk_edca);
-	else
-		RTL_W32(EDCA_BE_PARA, be_edca);
 #else
 	if(GET_STA_AC_VO_PARA.AIFSN > 0) {
 		RTL_W32(EDCA_VO_PARA, (((unsigned short)(GET_STA_AC_VO_PARA.TXOPlimit)) << 16)
@@ -2699,7 +2688,15 @@ static void sta_config_EDCA_para(struct rtl8192cd_priv *priv)
 
 	priv->pmib->dot11QosEntry.EDCA_STA_config = 1;
 	priv->pshare->iot_mode_enable = 0;
+	if (priv->pshare->rf_ft_var.wifi_beq_iot)
+		priv->pshare->iot_mode_VI_exist = 0;
 	priv->pshare->iot_mode_VO_exist = 0;
+#ifdef WMM_VIBE_PRI
+	priv->pshare->iot_mode_BE_exist = 0;
+#endif
+#ifdef LOW_TP_TXOP
+	priv->pshare->BE_cwmax_enhance = 0;
+#endif
 }
 
 
@@ -2774,6 +2771,134 @@ static void process_rtk_ie(struct rtl8192cd_priv *priv)
 	}
 }
 
+#ifdef RADIUS_ACCOUNTING
+void indicate_sta_leaving(struct rtl8192cd_priv *priv,struct stat_info *pstat, unsigned long reason)
+{
+	DOT11_DISASSOCIATION_IND Disassociation_Ind;
+
+	memcpy((void *)Disassociation_Ind.MACAddr, (void *)(pstat->hwaddr), MACADDRLEN);
+	Disassociation_Ind.EventId = DOT11_EVENT_DISASSOCIATION_IND;
+	Disassociation_Ind.IsMoreEvent = 0;
+	Disassociation_Ind.Reason = reason;
+	Disassociation_Ind.tx_packets = pstat->tx_pkts;
+	Disassociation_Ind.rx_packets = pstat->rx_pkts;
+	Disassociation_Ind.tx_bytes   = pstat->tx_bytes;
+	Disassociation_Ind.rx_bytes   = pstat->rx_bytes;
+	DOT11_EnQueue((unsigned long)priv, priv->pevent_queue, (UINT8 *)&Disassociation_Ind,
+				sizeof(DOT11_DISASSOCIATION_IND));
+	psk_indicate_evt(priv, DOT11_EVENT_DISASSOCIATION_IND, pstat->hwaddr, NULL, 0);
+}
+
+int cal_statistics_acct(struct rtl8192cd_priv *priv)
+{
+	unsigned long ret=0;
+	struct list_head *phead=NULL, *plist=NULL;
+	struct stat_info *pstat=NULL;
+
+	phead = &priv->asoc_list;
+	plist = phead->next;
+
+	if( list_empty(phead) )
+		goto acct_cal_out;
+	
+	while (plist != phead) {
+		pstat = list_entry(plist, struct stat_info, asoc_list);
+		plist = plist->next;
+
+		if( pstat->link_time%ACCT_TP_INT == 0 ){
+			pstat->rx_bytes_1m = pstat->rx_bytes - pstat->rx_bytes_1m;
+			pstat->tx_bytes_1m = pstat->tx_bytes - pstat->tx_bytes_1m;
+		}
+	}
+acct_cal_out:
+	return ret;
+}
+
+int expire_sta_for_radiusacct(struct rtl8192cd_priv *priv)
+{
+	int ret=0;
+	struct list_head *phead=NULL, *plist=NULL;
+	struct stat_info *pstat=NULL;
+
+	phead = &priv->asoc_list;
+	plist = phead->next;
+
+	if( (ACCT_FUN_TIME == 0) && (ACCT_FUN_TP == 0))
+		goto acct_expire_out;
+
+	if(list_empty(phead))
+		goto acct_expire_out;
+
+	while (plist != phead) {
+		pstat = list_entry(plist, struct stat_info, asoc_list);
+		plist = plist->next;
+
+		if(pstat->link_time > ACCT_FUN_TIME*60 ){
+#if !defined(WITHOUT_ENQUEUE) && (defined(INCLUDE_WPA_PSK) || defined(WIFI_HAPD))
+			indicate_sta_leaving(priv,pstat,_RSON_AUTH_NO_LONGER_VALID_);
+#endif
+			issue_deauth(priv,pstat->hwaddr,_RSON_AUTH_NO_LONGER_VALID_);
+			cnt_assoc_num(priv, pstat, DECREASE, (char *)__FUNCTION__);
+#ifdef CONFIG_RTL_88E_SUPPORT
+			if (GET_CHIP_VER(priv)!=VERSION_8188E) 
+#endif
+				check_sta_characteristic(priv, pstat, DECREASE);
+
+			LOG_MSG("A STA(%02X:%02X:%02X:%02X:%02X:%02X) is deleted for accounting becoz of time-out\n",
+				pstat->hwaddr[0], pstat->hwaddr[1], pstat->hwaddr[2], pstat->hwaddr[3], pstat->hwaddr[4], pstat->hwaddr[5]);
+		}
+
+		if(pstat->tx_bytes_1m+pstat->rx_bytes_1m < ACCT_FUN_TP*(2^20) ){
+#if !defined(WITHOUT_ENQUEUE) && (defined(INCLUDE_WPA_PSK) || defined(WIFI_HAPD))
+			indicate_sta_leaving(priv,pstat,_RSON_AUTH_NO_LONGER_VALID_);
+#endif
+			issue_deauth(priv,pstat->hwaddr,_RSON_AUTH_NO_LONGER_VALID_);
+			cnt_assoc_num(priv, pstat, DECREASE, (char *)__FUNCTION__);
+#ifdef CONFIG_RTL_88E_SUPPORT
+			if (GET_CHIP_VER(priv)!=VERSION_8188E) 
+#endif
+				check_sta_characteristic(priv, pstat, DECREASE);
+
+			LOG_MSG("A STA(%02X:%02X:%02X:%02X:%02X:%02X) is deleted for accounting becoz of low TP\n",
+				pstat->hwaddr[0], pstat->hwaddr[1], pstat->hwaddr[2], pstat->hwaddr[3], pstat->hwaddr[4], pstat->hwaddr[5]);
+		}
+	}
+
+acct_expire_out:
+	return ret;
+}
+#endif	//#ifdef RADIUS_ACCOUNTING
+
+
+#ifdef SMART_REPEATER_MODE
+static void switch_chan_to_vxd(struct rtl8192cd_priv *priv)
+{
+#ifdef MBSSID
+	unsigned int i;
+#endif
+
+	priv->pmib->dot11RFEntry.dot11channel = priv->pshare->switch_chan_rp;
+	RTL_W8(TXPAUSE, 0xff);
+
+	DEBUG_INFO("Swiching channel to %d!\n", priv->pmib->dot11RFEntry.dot11channel);
+	priv->pmib->dot11OperationEntry.keep_rsnie = 1; 
+	
+#ifdef MBSSID
+	if (GET_ROOT(priv)->pmib->miscEntry.vap_enable) {
+		for (i=0; i<RTL8192CD_NUM_VWLAN; i++) {
+			if (IS_DRV_OPEN(priv->pvap_priv[i]))
+				priv->pvap_priv[i]->pmib->dot11OperationEntry.keep_rsnie = 1;
+		}
+	}
+#endif
+
+	rtl8192cd_close(priv->dev);
+	rtl8192cd_open(priv->dev);
+
+	RTL_W8(TXPAUSE, 0x00);			
+}
+#endif
+
 
 void rtl8192cd_expire_timer(unsigned long task_priv)
 {
@@ -2795,6 +2920,19 @@ void rtl8192cd_expire_timer(unsigned long task_priv)
 	// advance driver up timer
 	priv->up_time++;
 
+#ifdef TLN_STATS
+	if (priv->pshare->rf_ft_var.stats_time_interval) {
+		if (priv->stats_time_countdown) {
+			priv->stats_time_countdown--;
+		} else {
+			memset(&priv->wifi_stats, 0, sizeof(struct tln_wifi_stats));
+			memset(&priv->ext_wifi_stats, 0, sizeof(struct tln_ext_wifi_stats));
+
+			priv->stats_time_countdown = priv->pshare->rf_ft_var.stats_time_interval;
+		}
+	}
+#endif
+
 #ifdef	INCLUDE_WPS
 	// mount wsp wps_1sec_routine
 #if defined(UNIVERSAL_REPEATER) || defined(MBSSID)
@@ -2916,28 +3054,37 @@ void rtl8192cd_expire_timer(unsigned long task_priv)
 			calculate_sw_LED_interval(priv);
 	}
 
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv)!=VERSION_8188E)
+#endif
+	{
 #ifdef CLIENT_MODE
-	if (((OPMODE & WIFI_AP_STATE) ||
-		((OPMODE & WIFI_ADHOC_STATE) &&
-			((priv->join_res == STATE_Sta_Ibss_Active) || (priv->join_res == STATE_Sta_Ibss_Idle)))) &&
-		(priv->pmib->dot11BssType.net_work_type & WIRELESS_11G))
+		if (((OPMODE & WIFI_AP_STATE) ||
+			((OPMODE & WIFI_ADHOC_STATE) &&
+				((priv->join_res == STATE_Sta_Ibss_Active) || (priv->join_res == STATE_Sta_Ibss_Idle)))) &&
+			(priv->pmib->dot11BssType.net_work_type & WIRELESS_11G))
 #else
-	if ((OPMODE & WIFI_AP_STATE) &&
-		(priv->pmib->dot11BssType.net_work_type & WIRELESS_11G))
+		if ((OPMODE & WIFI_AP_STATE) &&
+			(priv->pmib->dot11BssType.net_work_type & WIRELESS_11G))
 #endif
-	{
-		if (priv->pmib->dot11ErpInfo.olbcDetected) {
-			if (priv->pmib->dot11ErpInfo.olbcExpired > 0)
-				priv->pmib->dot11ErpInfo.olbcExpired--;
-
-			if (priv->pmib->dot11ErpInfo.olbcExpired == 0) {
-				priv->pmib->dot11ErpInfo.olbcDetected = 0;
-				DEBUG_INFO("OLBC expired\n");
-				check_protection_shortslot(priv);
+		{
+			if (priv->pmib->dot11ErpInfo.olbcDetected) {
+				if (priv->pmib->dot11ErpInfo.olbcExpired > 0)
+					priv->pmib->dot11ErpInfo.olbcExpired--;
+
+				if (priv->pmib->dot11ErpInfo.olbcExpired == 0) {
+					priv->pmib->dot11ErpInfo.olbcDetected = 0;
+					DEBUG_INFO("OLBC expired\n");
+					check_protection_shortslot(priv);
+				}
 			}
 		}
 	}
 
+#ifdef TX_EARLY_MODE
+	priv->pshare->em_tx_byte_cnt  = priv->ext_stats.tx_byte_cnt;
+#endif
+
 	// calculate tx/rx throughput
 	priv->ext_stats.tx_avarage = (priv->ext_stats.tx_avarage/10)*7 + (priv->ext_stats.tx_byte_cnt/10)*3;
 	priv->ext_stats.tx_byte_cnt = 0;
@@ -3031,7 +3178,10 @@ void rtl8192cd_expire_timer(unsigned long task_priv)
 #endif
 
 	// Realtek proprietary IE
-	process_rtk_ie(priv);
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv)!=VERSION_8188E)
+#endif
+		process_rtk_ie(priv);
 
 	// check ACL log event
 	if ((OPMODE & WIFI_AP_STATE) && priv->acLogCountdown > 0) {
@@ -3048,6 +3198,8 @@ void rtl8192cd_expire_timer(unsigned long task_priv)
 		if (priv->pmib->dot11BssType.net_work_type & WIRELESS_11N) {
 			if (priv->ht_legacy_obss_to > 0)
 				priv->ht_legacy_obss_to--;
+			if (priv->ht_nomember_legacy_sta_to > 0)
+				priv->ht_nomember_legacy_sta_to--;
 		}
 	}
 #ifdef WIFI_11N_2040_COEXIST
@@ -3100,12 +3252,42 @@ void rtl8192cd_expire_timer(unsigned long task_priv)
 			realloc_RATid(priv);
 		}
 #endif
+
+#ifdef TX_EARLY_MODE
+		if (GET_TX_EARLY_MODE) {
+			if (!GET_EM_SWQ_ENABLE) {
+				if (priv->pshare->em_tx_byte_cnt > EM_TP_UP_BOUND) 
+					priv->pshare->reach_tx_limit_cnt++;				
+				else					
+					priv->pshare->reach_tx_limit_cnt = 0;	
+
+				if (priv->pshare->txop_enlarge && priv->pshare->reach_tx_limit_cnt >= WAIT_TP_TIME) {			
+					GET_EM_SWQ_ENABLE = 1;			
+					priv->pshare->reach_tx_limit_cnt = 0;				
+				}
+			}
+			else {			
+				if (priv->pshare->em_tx_byte_cnt < EM_TP_UP_BOUND)
+					priv->pshare->reach_tx_limit_cnt++;				
+				else					
+					priv->pshare->reach_tx_limit_cnt = 0;	
+
+				if (!priv->pshare->txop_enlarge || priv->pshare->reach_tx_limit_cnt >= WAIT_TP_TIME) {
+					GET_EM_SWQ_ENABLE = 0;
+					priv->pshare->reach_tx_limit_cnt = 0;
+				}
+			}
+		}		
+#endif
 	}
 
 #ifdef USB_PKT_RATE_CTRL_SUPPORT
 	usbPkt_timer_handler(priv);
 #endif
 
+	if (priv->pshare->rf_ft_var.rts_init_rate)
+		SelectRTSInitialRate(priv);
+
 #ifdef UNIVERSAL_REPEATER
 	if (IS_ROOT_INTERFACE(priv) && GET_VXD_PRIV(priv) &&
 			netif_running(GET_VXD_PRIV(priv)->dev))
@@ -3145,8 +3327,14 @@ void rtl8192cd_expire_timer(unsigned long task_priv)
 		if (!((OPMODE & WIFI_MP_STATE) || priv->pshare->rf_ft_var.mp_specific))
 #endif
 		{
-			if (priv->up_time % 2) {
-#if defined(CONFIG_RTL_NEW_AUTOCH)
+#ifdef INTERFERENCE_CONTROL
+			if (priv->pshare->rf_ft_var.rssi_dump && (priv->assoc_num == 0)) {
+				panic_printk("(FA %x,%x %d, %d)\n",
+					RTL_R8(0xc50), RTL_R8(0xc58), priv->pshare->ofdm_FA_total_cnt, priv->pshare->cck_FA_cnt);
+			}
+#endif
+			if (priv->up_time % 2) {
+#ifdef CONFIG_RTL_NEW_AUTOCH
 				if( priv->auto_channel ==0 || priv->auto_channel ==2 )
 #endif
 				FA_statistic(priv);
@@ -3155,60 +3343,109 @@ void rtl8192cd_expire_timer(unsigned long task_priv)
 					DIG_process(priv);
 			}
 
+			if (priv->pshare->phw->RTSInitRate_Candidate != priv->pshare->phw->RTSInitRate) {
+				priv->pshare->phw->RTSInitRate = priv->pshare->phw->RTSInitRate_Candidate;
+				RTL_W8(INIRTS_RATE_SEL, priv->pshare->phw->RTSInitRate);
+			}
+
 #ifdef SW_ANT_SWITCH
-			if (priv->pshare->rf_ft_var.antSw_enable && (priv->up_time % 4==1))
+			if ((SW_DIV_ENABLE)  && (priv->up_time % 4==1))
 				dm_SW_AntennaSwitch(priv, SWAW_STEP_PEAK);
 #endif
 
 			
 		}
 
+#if defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT)
 		if ( (priv->pmib->dot11RFEntry.ther) && ((priv->up_time % priv->pshare->rf_ft_var.tpt_period) == 0)){
 #ifdef CONFIG_RTL_92D_SUPPORT
-			if (GET_CHIP_VER(priv)==VERSION_8192D){
+			if (GET_CHIP_VER(priv)==VERSION_8192D)
 				tx_power_tracking_92D(priv);
-			} else 
 #endif
-			{
+#ifdef CONFIG_RTL_92C_SUPPORT			
+			if ((GET_CHIP_VER(priv)==VERSION_8192C) || (GET_CHIP_VER(priv)==VERSION_8188C))
 				tx_power_tracking(priv);
-			}
+#endif
 		}
-		
+#endif
+
 #ifdef HIGH_POWER_EXT_PA
 		if((priv->pshare->rf_ft_var.use_ext_pa) && (priv->pshare->rf_ft_var.tx_pwr_ctrl))
 			tx_power_control(priv);
-#endif		
-
+#endif
 
 		IOT_engine(priv);
 		rxBB_dm(priv);
 
-		if (priv->pshare->txpause_pstat != NULL) {
-			if (TSF_DIFF(priv->pshare->txpause_time, jiffies) > 100) {
-				RTL_W8(TXPAUSE, RTL_R8(TXPAUSE) & 0xe0);
-				priv->pshare->txpause_pstat = NULL;
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv) == VERSION_8188E) {
+#ifdef STA_EXT
+		if (REMAP_AID(pstat) < (RTL8188E_NUM_STAT - 1)) 
+#endif
+		{
+			struct list_head	*plist, *phead;
+			struct stat_info	*pstat;
+			
+			phead = &priv->sleep_list;
+			plist = phead->next;
+			
+			SAVE_INT_AND_CLI(flags);
+			while(plist != phead)
+			{
+				pstat = list_entry(plist, struct stat_info, sleep_list);
+				plist = plist->next;
+			
+				if (pstat->txpause_flag && (TSF_DIFF(jiffies, pstat->txpause_time) > 100)) {
+					RTL8188E_MACID_PAUSE(priv, 0, REMAP_AID(pstat));
+					pstat->txpause_time = 0;
+					pstat->txpause_flag = 0;
+				}
+			}
+			RESTORE_INT(flags);
+		}
+		}
+		else
+#endif
+		{
+			if (priv->pshare->txpause_pstat != NULL) {
+				if (TSF_DIFF(jiffies, priv->pshare->txpause_time) > 100) {
+					RTL_W8(TXPAUSE, RTL_R8(TXPAUSE) & 0xe0);
+					priv->pshare->txpause_pstat = NULL;
+				}
 			}
 		}
 	}
 
 
-#ifdef TXREPORT
-#ifdef TESTCHIP_SUPPORT
-	if (!IS_TEST_CHIP(priv))
+#if defined(TXREPORT) && (defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT))
+	if (
+#ifdef CONFIG_RTL_92C_SUPPORT
+		(GET_CHIP_VER(priv)==VERSION_8192C) || (GET_CHIP_VER(priv)==VERSION_8188C)
+#endif
+#ifdef CONFIG_RTL_92D_SUPPORT
+#ifdef CONFIG_RTL_92C_SUPPORT
+		|| 
+#endif
+		(GET_CHIP_VER(priv)==VERSION_8192D)
+#endif
+		) {
+#if defined(TESTCHIP_SUPPORT) && defined(CONFIG_RTL_92C_SUPPORT)
+		if (!IS_TEST_CHIP(priv))
 #endif
 #ifdef MP_TEST
-	if (!((OPMODE & WIFI_MP_STATE) || priv->pshare->rf_ft_var.mp_specific))
+		if (!((OPMODE & WIFI_MP_STATE) || priv->pshare->rf_ft_var.mp_specific))
 #endif
 #if defined(UNIVERSAL_REPEATER) || defined(MBSSID)
-	if (IS_ROOT_INTERFACE(priv))
+		if (IS_ROOT_INTERFACE(priv))
 #endif
-	{
+		{
 #ifdef DETECT_STA_EXISTANCE
-		LeavingSTA_RLCheck(priv);
+			LeavingSTA_RLCheck(priv);
 #endif
-		if (!(priv->up_time%priv->pmib->staDetectInfo.txRprDetectPeriod) && (priv->pshare->sta_query_idx==-1)) {
-			priv->pshare->sta_query_idx = 0;
-			requestTxReport(priv);
+			if (!(priv->up_time%priv->pmib->staDetectInfo.txRprDetectPeriod) && (priv->pshare->sta_query_idx==-1)) {
+				priv->pshare->sta_query_idx = 0;
+				requestTxReport(priv);
+			}
 		}
 	}
 #endif
@@ -3247,10 +3484,46 @@ void rtl8192cd_expire_timer(unsigned long task_priv)
 	}
 #endif
 
-	RESTORE_INT(flags);
-	SMP_UNLOCK(flags);
+#ifdef RADIUS_ACCOUNTING
+	//brian add for accounting
+	if(ACCT_FUN)
+	{
+		cal_statistics_acct(priv);
+		expire_sta_for_radiusacct(priv);
+	}
+#endif
+
+#if defined(UNIVERSAL_REPEATER) || defined(MBSSID)
+	if (IS_ROOT_INTERFACE(priv))
+#endif
+	{
+		switch(priv->pshare->intel_active_sta) {
+		case 0:
+		case 1:
+			priv->pshare->intel_rty_lmt =  0x30; /* 48 times */
+			break;
+		case 2:
+			priv->pshare->intel_rty_lmt =  0x18; /* 24 times */
+			break;
+		default:
+			priv->pshare->intel_rty_lmt =  0; /* use system default */
+			break;			
+		}
 
+		priv->pshare->intel_active_sta = 0;
 
+#ifdef SMART_REPEATER_MODE
+		if (priv->pshare->switch_chan_rp && 
+				priv->pmib->dot11RFEntry.dot11channel != priv->pshare->switch_chan_rp) {
+			DEBUG_INFO("swtich chan=%d\n",  priv->pshare->switch_chan_rp);
+			switch_chan_to_vxd(priv);			
+			priv->pshare->switch_chan_rp = 0;
+		}
+#endif		
+	}
+
+	RESTORE_INT(flags);
+	SMP_UNLOCK(flags);
 }
 
 
@@ -3261,7 +3534,7 @@ void rtl8192cd_expire_timer(unsigned long task_priv)
  *
  *	@retval	void
  */
- #define CHECK_CRYPTO
+// #define CHECK_CRYPTO
 void rtl8192cd_1sec_timer(unsigned long task_priv)
 {
 	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *)task_priv;
@@ -3321,6 +3594,18 @@ expire_timer:
 	rtl8192cd_expire_timer((unsigned long)priv);
 #endif
 
+#ifdef P2P_SUPPORT
+	if (OPMODE & WIFI_P2P_SUPPORT)
+		P2P_1sec_timer(priv);
+#endif
+
+#ifdef CONFIG_RTL_WLAN_DOS_FILTER
+	if ((block_sta_time > 0) && (block_priv == (unsigned long)priv))
+	{
+		block_sta_time--;
+	}
+#endif
+
 	mod_timer(&priv->expire_timer, jiffies + EXPIRE_TO);
 }
 
@@ -3348,18 +3633,36 @@ void pwr_state(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinfo)
 	{
 		if ((pstat->state & WIFI_SLEEP_STATE) == 0) {
 			pstat->state |= WIFI_SLEEP_STATE;
-			if (pstat == priv->pshare->highTP_found_pstat) {
-				if (priv->pshare->txpause_pstat == NULL) {
-					RTL_W8(TXPAUSE, RTL_R8(TXPAUSE) | 0x1f);
-					priv->pshare->txpause_pstat = pstat;
-					priv->pshare->txpause_time = jiffies;
+#ifdef CONFIG_RTL_88E_SUPPORT
+			if (GET_CHIP_VER(priv)!=VERSION_8188E)
+#endif
+			{
+				if (pstat == priv->pshare->highTP_found_pstat) {
+					if (priv->pshare->txpause_pstat == NULL) {
+						RTL_W8(TXPAUSE, RTL_R8(TXPAUSE) | 0x1f);
+						priv->pshare->txpause_pstat = pstat;
+						priv->pshare->txpause_time = jiffies;
+					}
 				}
 			}
 
 #ifdef STA_EXT
-			if (REMAP_AID(pstat) < (FW_NUM_STAT - 1))
+			if (
+#ifdef CONFIG_RTL_88E_SUPPORT
+				(GET_CHIP_VER(priv)==VERSION_8188E)?(REMAP_AID(pstat) < (RTL8188E_NUM_STAT - 1)):
+#endif
+				(REMAP_AID(pstat) < (FW_NUM_STAT - 1)))
 #endif
-				add_update_ps(priv, pstat);
+			{
+#ifdef CONFIG_RTL_88E_SUPPORT
+				if (GET_CHIP_VER(priv)==VERSION_8188E) {
+					RTL8188E_MACID_PAUSE(priv, 1, REMAP_AID(pstat));
+					pstat->txpause_flag = 1;
+					pstat->txpause_time = jiffies;
+				} else
+#endif
+					add_update_ps(priv, pstat);
+			}
 		}
 		if (!list_empty(&pstat->wakeup_list))
 		{
@@ -3375,19 +3678,37 @@ void pwr_state(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinfo)
 			RESTORE_INT(flags);
 			DEBUG_INFO("Add to sleep_list %02X%02X%02X%02X%02X%02X\n", sa[0],sa[1],sa[2],sa[3],sa[4],sa[5]);
 		}
-	}
-	else
-	{
+	} else {
 		if (pstat->state & WIFI_SLEEP_STATE) {
 			pstat->state &= ~(WIFI_SLEEP_STATE);
-			if (pstat == priv->pshare->txpause_pstat) {
-				RTL_W8(TXPAUSE, RTL_R8(TXPAUSE) & 0xe0);
-				priv->pshare->txpause_pstat = NULL;
+#ifdef CONFIG_RTL_88E_SUPPORT
+			if (GET_CHIP_VER(priv)!=VERSION_8188E) 
+#endif
+			{
+				if (pstat == priv->pshare->txpause_pstat) {
+					RTL_W8(TXPAUSE, RTL_R8(TXPAUSE) & 0xe0);
+					priv->pshare->txpause_pstat = NULL;
+				}
 			}
 #ifdef STA_EXT
-			if (REMAP_AID(pstat) < (FW_NUM_STAT - 1))
+			if (
+#ifdef CONFIG_RTL_88E_SUPPORT
+				(GET_CHIP_VER(priv)==VERSION_8188E)?(REMAP_AID(pstat) < (RTL8188E_NUM_STAT - 1)):
+#endif
+				(REMAP_AID(pstat) < (FW_NUM_STAT - 1)))
+#endif
+			{
+#ifdef CONFIG_RTL_88E_SUPPORT
+				if (GET_CHIP_VER(priv)==VERSION_8188E) {
+					if (pstat->txpause_flag) {
+						RTL8188E_MACID_PAUSE(priv, 0, REMAP_AID(pstat));
+						pstat->txpause_flag = 0;
+					}
+					pstat->txpause_time = 0;
+				} else
 #endif
-				add_update_ps(priv, pstat);
+					add_update_ps(priv, pstat);
+			}
 		}
 		if (!list_empty(&pstat->sleep_list)) {
 			SAVE_INT_AND_CLI(flags);
@@ -3396,14 +3717,18 @@ void pwr_state(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinfo)
 			DEBUG_INFO("Del fr sleep_list %02X%02X%02X%02X%02X%02X\n", sa[0],sa[1],sa[2],sa[3],sa[4],sa[5]);
 		}
 		if ((skb_queue_len(&pstat->dz_queue))
-#if defined(WIFI_WMM) && defined(WMM_APSD)
-			||((QOS_ENABLE) && (APSD_ENABLE) && (pstat->QosEnabled) && (pstat->apsd_pkt_buffering) &&
+#ifdef WIFI_WMM
+#ifdef WMM_APSD
+			||(
+#ifdef CLIENT_MODE
+				(OPMODE & WIFI_AP_STATE) &&
+#endif
+				(QOS_ENABLE) && (APSD_ENABLE) && (pstat->QosEnabled) && (pstat->apsd_pkt_buffering) &&
 				((!isFFempty(pstat->VO_dz_queue->head, pstat->VO_dz_queue->tail)) ||
 				 (!isFFempty(pstat->VI_dz_queue->head, pstat->VI_dz_queue->tail)) ||
 				 (!isFFempty(pstat->BE_dz_queue->head, pstat->BE_dz_queue->tail)) ||
 				 (!isFFempty(pstat->BK_dz_queue->head, pstat->BK_dz_queue->tail))))
 #endif
-#if defined(WIFI_WMM)
 			|| (!isFFempty(pstat->MGT_dz_queue->head, pstat->MGT_dz_queue->tail))
 #ifdef DZ_ADDBA_RSP
 			|| pstat->dz_addba.used
@@ -3614,7 +3939,11 @@ void process_dzqueue(struct rtl8192cd_priv *priv)
 // 2009.09.08
 		SAVE_INT_AND_CLI(flags);
 #if defined(WIFI_WMM) && defined(WMM_APSD)
-			if ((QOS_ENABLE) && (APSD_ENABLE) && pstat && (pstat->QosEnabled) && (pstat->apsd_pkt_buffering)) {
+			if (
+#ifdef CLIENT_MODE
+				(OPMODE & WIFI_AP_STATE) &&
+#endif
+				(QOS_ENABLE) && (APSD_ENABLE) && pstat && (pstat->QosEnabled) && (pstat->apsd_pkt_buffering)) {
 				pskb = (struct sk_buff *)deque(priv, &(pstat->VO_dz_queue->head), &(pstat->VO_dz_queue->tail),
 					(unsigned int)(pstat->VO_dz_queue->pSkb), NUM_APSD_TXPKT_QUEUE);
 				if (pskb == NULL) {
@@ -3631,20 +3960,16 @@ void process_dzqueue(struct rtl8192cd_priv *priv)
 								goto legacy_ps;
 							}
 							DEBUG_INFO("release BK pkt\n");
-						}
-						else {
+						} else {
 							DEBUG_INFO("release BE pkt\n");
 						}
-					}
-					else {
+					} else {
 						DEBUG_INFO("release VI pkt\n");
 					}
-				}
-				else {
+				} else {
 					DEBUG_INFO("release VO pkt\n");
 				}
-			}
-			else
+			} else
 legacy_ps:
 #endif
 #if defined(WIFI_WMM) 
@@ -3690,12 +4015,7 @@ legacy_ps:
 			rtl_atomic_dec(&priv->rtl_tx_skb_cnt);
 #endif
 
-#ifdef CONFIG_RTK_MESH
-			if (rtl8192cd_start_xmit(pskb, pskb->dev))
-#else
-			if (rtl8192cd_start_xmit(pskb, priv->dev))
-#endif
-
+			if (rtl8192cd_start_xmit_noM2U(pskb, pskb->dev))
 				rtl_kfree_skb(priv, pskb, _SKB_TX_);
 		}
 
@@ -3845,6 +4165,104 @@ int isErpSta(struct	stat_info *pstat)
 	return 0;
 }
 
+void SelectRTSInitialRate(struct rtl8192cd_priv *priv)
+{
+	unsigned int		BasicRateCfg;
+	unsigned char		RTSRateIndex=0; // 1M
+	unsigned char		LowestRateIdx=0xff;
+	unsigned char		TempRateIdx;
+	
+	struct stat_info	*pstat;
+	struct list_head	*phead, *plist;
+	
+	BasicRateCfg = priv->pmib->dot11StationConfigEntry.dot11BasicRates;
+	BasicRateCfg &= 0x1ff;		// limit RTS init rate is lower than or equal to 24M
+
+	if (priv->pmib->dot11ErpInfo.protection)
+	{
+		// Use CCK rate
+		BasicRateCfg &= 0xf;
+		while(BasicRateCfg > 0x1)
+		{
+			BasicRateCfg = (BasicRateCfg>> 1);
+			RTSRateIndex++;
+		}
+	}
+	else
+	{
+		if (priv->pmib->dot11StationConfigEntry.autoRate)
+		{
+			phead = &priv->asoc_list;
+			plist = phead->next;
+			
+			while(plist != phead)
+			{
+				pstat = list_entry(plist, struct stat_info, asoc_list);
+#ifdef STA_EXT
+				if (pstat->remapped_aid && (pstat->remapped_aid < FW_NUM_STAT-1)
+#else
+				if (pstat->aid && (pstat->aid < 32)
+#endif
+						&& (pstat->expire_to > 0))
+				{
+					TempRateIdx = RTL_R8(INIDATA_RATE_SEL + REMAP_AID(pstat)) & 0x3f;
+					
+					if(TempRateIdx < LowestRateIdx)
+						LowestRateIdx = TempRateIdx;
+				}
+				plist = plist->next;
+			}
+		}
+		else if (priv->pmib->dot11StationConfigEntry.fixedTxRate)	// Fixed Tx rate
+		{
+			LowestRateIdx = 0;
+			while ((priv->pmib->dot11StationConfigEntry.fixedTxRate & BIT(LowestRateIdx))==0)
+				++LowestRateIdx;
+		}
+		
+		// Adjust RTS Init rate when the data rate is MCS0~2, 8~10 which is lower than 24M.
+		if(LowestRateIdx == 12 || LowestRateIdx == 20) //MCS0, MCS8
+		{
+			RTSRateIndex = 4; // 6M
+		}
+		else if(LowestRateIdx == 13 || LowestRateIdx == 14 ||
+			LowestRateIdx == 21 || LowestRateIdx == 22) //MCS1, MCS2, MCS9, MCS10
+		{
+			RTSRateIndex = 6; // 12M
+		}
+		else 
+		{
+			if(BasicRateCfg != 0)
+			{
+			#if 0
+				// Select RTS Init rate
+				while(BasicRateCfg > 0x1)
+				{
+					BasicRateCfg = (BasicRateCfg>> 1);
+					RTSRateIndex++;
+				}
+			#else
+				// Default use 24Mbps for IOT issue.
+				// Suggested by Scott. Added by tynli. 2011.01.20.
+				RTSRateIndex = 8; // 24M
+			#endif
+			}
+			else
+			{
+				RTSRateIndex = 4; // 6M
+			}
+		}
+	}
+
+
+#if defined(UNIVERSAL_REPEATER) || defined(MBSSID)
+	if (IS_ROOT_INTERFACE(priv))
+		priv->pshare->phw->RTSInitRate_Candidate = RTSRateIndex;
+	else 
+#endif
+		if (RTSRateIndex < priv->pshare->phw->RTSInitRate_Candidate)
+			priv->pshare->phw->RTSInitRate_Candidate = RTSRateIndex;
+}
 
 /*----------------------------------------------------------------------------
 index: the information element id index, limit is the limit for search
@@ -4000,10 +4418,17 @@ static __inline__ unsigned char *update_tim(struct rtl8192cd_priv *priv,
 	pre_head = get_txhead(priv->pshare->phw, MCAST_QNUM);
 	txdesc_rollback(&pre_head);
 
+	if (priv->dtimcount == (priv->pmib->dot11StationConfigEntry.dot11DTIMPeriod - 1)
+		&&(*((unsigned char *)priv->beaconbuf + priv->timoffset + 4) & 0x01))  {
+		RTL_W16(RD_CTRL, RTL_R16(RD_CTRL) & (~ HIQ_NO_LMT_EN));
+	}
+	if(priv->dtimcount == (priv->pmib->dot11StationConfigEntry.dot11DTIMPeriod - 1)
+		&& !(get_desc((get_txdesc(priv->pshare->phw, MCAST_QNUM) + pre_head)->Dword0) & TX_OWN))
+		priv->pkt_in_hiQ = 0;
 	if ((priv->dtimcount == 0) &&
 		(priv->pkt_in_dtimQ ||
-		(get_desc((get_txdesc(priv->pshare->phw, MCAST_QNUM) + pre_head)->Dword0) & TX_OWN)))
-
+//		(get_desc((get_txdesc(priv->pshare->phw, MCAST_QNUM) + pre_head)->Dword0) & TX_OWN)))
+		priv->pkt_in_hiQ))
 		val8 = 0x01;
 	else
 		val8 = 0x00;
@@ -4031,17 +4456,7 @@ static __inline__ unsigned char *update_tim(struct rtl8192cd_priv *priv,
 		}
 		else
 #endif
-#if defined(WIFI_WMM)
-		if (!isFFempty(pstat->MGT_dz_queue->head, pstat->MGT_dz_queue->tail)){
-			printk("dz_mgmt set virtual bitmap\n");
-			set_pvb++;
-		}else
-#ifdef DZ_ADDBA_RSP
-		if (pstat->dz_addba.used)
-			set_pvb++;
-		else 
-#endif
-#endif
+
 		if (skb_queue_len(&pstat->dz_queue))
 			set_pvb++;
 
@@ -4118,9 +4533,11 @@ void construct_ht_ie(struct rtl8192cd_priv *priv, int use_40m, int offset)
 		memset(ht_cap, 0, sizeof(struct ht_cap_elmt));
 		ht_cap->ht_cap_info |= cpu_to_le16(use_40m ? _HTCAP_SUPPORT_CH_WDTH_ : 0);
 		ht_cap->ht_cap_info |= cpu_to_le16(_HTCAP_SMPWR_DISABLE_);
-		ht_cap->ht_cap_info |= cpu_to_le16(priv->pmib->dot11nConfigEntry.dot11nShortGIfor20M? _HTCAP_SHORTGI_20M_ : 0);
-		if (use_40m)
-		        ht_cap->ht_cap_info |= cpu_to_le16(priv->pmib->dot11nConfigEntry.dot11nShortGIfor40M? _HTCAP_SHORTGI_40M_ : 0);
+		if (priv->pmib->dot11RFEntry.dot11channel < 149) {
+			ht_cap->ht_cap_info |= cpu_to_le16(priv->pmib->dot11nConfigEntry.dot11nShortGIfor20M? _HTCAP_SHORTGI_20M_ : 0);
+			if (use_40m)
+				ht_cap->ht_cap_info |= cpu_to_le16(priv->pmib->dot11nConfigEntry.dot11nShortGIfor40M? _HTCAP_SHORTGI_40M_ : 0);
+		}
 		ht_cap->ht_cap_info |= cpu_to_le16(priv->pmib->dot11nConfigEntry.dot11nSTBC? (_HTCAP_TX_STBC_ | _HTCAP_RX_STBC_1S_) : 0);
 		ht_cap->ht_cap_info |= cpu_to_le16(priv->pmib->dot11nConfigEntry.dot11nAMSDURecvMax? _HTCAP_AMSDU_LEN_8K_ : 0);
 		ht_cap->ht_cap_info |= cpu_to_le16(_HTCAP_CCK_IN_40M_);
@@ -4173,6 +4590,10 @@ void construct_ht_ie(struct rtl8192cd_priv *priv, int use_40m, int offset)
 			ht_ie = &priv->ht_ie_buf;
 			ht_ie->info0 &= ~(_HTIE_2NDCH_OFFSET_BL_ | _HTIE_STA_CH_WDTH_);
 			if (use_40m && !(priv->bg_ap_timeout || priv->force_20_sta || priv->switch_20_sta
+#ifdef CONFIG_RTL_88E_SUPPORT
+				|| (GET_CHIP_VER(priv) == VERSION_8188E)?(priv->force_20_sta_88e_hw_ext 
+				|| priv->switch_20_sta_88e_hw_ext):(0)
+#endif
 #ifdef STA_EXT
 				|| priv->force_20_sta_ext || priv->switch_20_sta_ext
 #endif
@@ -4196,7 +4617,7 @@ void construct_ht_ie(struct rtl8192cd_priv *priv, int use_40m, int offset)
 
 		if (priv->ht_legacy_sta_num) {
 			priv->ht_ie_buf.info1 |= cpu_to_le16(_HTIE_OP_MODE3_);
-		} else if (priv->ht_legacy_obss_to) {
+		} else if (priv->ht_legacy_obss_to || priv->ht_nomember_legacy_sta_to) {
 			priv->ht_ie_buf.info1 &= cpu_to_le16(~_HTIE_OP_MODE3_);
 			priv->ht_ie_buf.info1 |= cpu_to_le16(_HTIE_OP_MODE1_);
 		} else {
@@ -4246,7 +4667,6 @@ void construct_obss_scan_para_ie(struct rtl8192cd_priv *priv)
 		memset(obss_scan_para, 0, sizeof(struct obss_scan_para_elmt));
 
 		// except word2, all are default values and meaningless for ap at present
-		// by victoryman, 20090521
 		obss_scan_para->word0 = cpu_to_le16(0x14);
 		obss_scan_para->word1 = cpu_to_le16(0x0a);
 		obss_scan_para->word2 = cpu_to_le16(180);	// set as 180 second for 11n test plan
@@ -4280,28 +4700,23 @@ void fill_bcn_desc(struct rtl8192cd_priv *priv, struct tx_desc *pdesc, void *dat
         priv->bcnTxAGC_bak = priv->bcnTxAGC;
     }
 
-	if (priv->pshare->is_40m_bw != priv->pshare->is_40m_bw_bak || forceUpdate)
-	{
+	if (priv->pshare->is_40m_bw != priv->pshare->is_40m_bw_bak || forceUpdate) {
 		memset(&pdesc->Dword4, 0, 4);
 
 		pdesc->Dword4 = set_desc(TX_DisDataFB | TX_UseRate);
 
-		if (priv->pshare->is_40m_bw) 
-		{
+		if (priv->pshare->is_40m_bw) {
 			if (priv->pshare->offset_2nd_chan == HT_2NDCH_OFFSET_BELOW)
 				pdesc->Dword4 |= set_desc(2 << TX_DataScSHIFT);
-	        else
-                pdesc->Dword4 |= set_desc(1 << TX_DataScSHIFT);
-        }
+			else
+				pdesc->Dword4 |= set_desc(1 << TX_DataScSHIFT);
+		}
 		priv->pshare->is_40m_bw_bak = priv->pshare->is_40m_bw;
 
 #ifdef CONFIG_RTL_92D_SUPPORT
-    if (priv->pmib->dot11RFEntry.phyBandSelect & PHY_BAND_5G)
-    {
-        pdesc->Dword4 |= set_desc((4 & TX_RtsRateMask) << TX_RtsRateSHIFT);
-    }
+		if (priv->pmib->dot11RFEntry.phyBandSelect & PHY_BAND_5G)
+			pdesc->Dword4 |= set_desc((4 & TX_RtsRateMask) << TX_RtsRateSHIFT);
 #endif
-
 	}
 
 	if (txLength != priv->tx_beacon_len || forceUpdate)
@@ -4325,19 +4740,21 @@ void fill_bcn_desc(struct rtl8192cd_priv *priv, struct tx_desc *pdesc, void *dat
 		}
         priv->pshare->is_40m_bw_bak = priv->pshare->is_40m_bw;
 
-#ifdef CONFIG_RTL_92D_SUPPORT
-    if (GET_CHIP_VER(priv)==VERSION_8192D){
-        pdesc->Dword2 &= set_desc(0x03ffffff); // clear related bits
+		if (priv->pmib->dot11RFEntry.txbf == 1) {
+			pdesc->Dword2 &= set_desc(0x03ffffff); // clear related bits
 
-        pdesc->Dword2 |= set_desc(1 << TX_TxAntCckSHIFT);   // Set Default CCK rate with 1T
-        pdesc->Dword2 |= set_desc(1 << TX_TxAntlSHIFT);     // Set Default Legacy rate with 1T
-        pdesc->Dword2 |= set_desc(1 << TX_TxAntHtSHIFT);    // Set Default Ht rate
+			pdesc->Dword2 |= set_desc(1 << TX_TxAntCckSHIFT);	// Set Default CCK rate with 1T
+			pdesc->Dword2 |= set_desc(1 << TX_TxAntlSHIFT); 	// Set Default Legacy rate with 1T
+			pdesc->Dword2 |= set_desc(1 << TX_TxAntHtSHIFT);	// Set Default Ht rate	
+		}
 
-        if (priv->pmib->dot11RFEntry.phyBandSelect & PHY_BAND_5G) {
-            pdesc->Dword4 |= set_desc((4 & TX_RtsRateMask) << TX_RtsRateSHIFT);
-            pdesc->Dword5 |= set_desc((4 & TX_DataRateMask) << TX_DataRateSHIFT);
-        }
-    }
+#ifdef CONFIG_RTL_92D_SUPPORT
+		if (GET_CHIP_VER(priv)==VERSION_8192D) {
+			if (priv->pmib->dot11RFEntry.phyBandSelect & PHY_BAND_5G) {
+				pdesc->Dword4 |= set_desc((4 & TX_RtsRateMask) << TX_RtsRateSHIFT);
+				pdesc->Dword5 |= set_desc((4 & TX_DataRateMask) << TX_DataRateSHIFT);
+			}
+		}
 #endif
 
 		priv->tx_beacon_len = txLength;
@@ -4351,6 +4768,12 @@ void fill_bcn_desc(struct rtl8192cd_priv *priv, struct tx_desc *pdesc, void *dat
 		memset(&pdesc->Dword3, 0, 4);
 		pdesc->Dword3 |= set_desc((GetSequence(dat_content) & TX_SeqMask) << TX_SeqSHIFT);
 	}
+#ifdef P2P_SUPPORT
+	if (priv->pmib->dot11RFEntry.phyBandSelect & PHY_BAND_2G) {
+		if(OPMODE&WIFI_P2P_SUPPORT && P2PMODE==P2P_TMP_GO)
+			pdesc->Dword5 |= set_desc((4 & TX_DataRateMask) << TX_DataRateSHIFT);
+	}
+#endif
 }
 #endif
 
@@ -4389,20 +4812,18 @@ void signin_beacon_desc(struct rtl8192cd_priv *priv, unsigned int *beaconbuf, un
 	rtl_cache_sync_wback(priv, get_desc(pdesc->Dword8), frlen, PCI_DMA_TODEVICE);
 
 #else
-
-	/* 
-	 * Intel IOT, dynamic enhance beacon tx AGC
+	/* Intel IOT, dynamic enhance beacon tx AGC
      */
     if (priv->bcnTxAGC_bak != priv->bcnTxAGC)
     {
-        memset(&pdesc->Dword6, 0, 4);
+		memset(&pdesc->Dword6, 0, 4);
 #ifdef HIGH_POWER_EXT_PA
-        if (!priv->pshare->rf_ft_var.use_ext_pa)
-#endif
-        if (priv->bcnTxAGC)
-        {
-            pdesc->Dword6 |= set_desc((((priv->bcnTxAGC*6) & 0xfffffffe) & TX_TxAgcAMask) << TX_TxAgcASHIFT);
-            pdesc->Dword6 |= set_desc((((priv->bcnTxAGC*6) & 0xfffffffe) & TX_TxAgcBMask) << TX_TxAgcBSHIFT);
+	    if (!priv->pshare->rf_ft_var.use_ext_pa)
+#endif	
+        if (priv->bcnTxAGC) 
+		{
+			pdesc->Dword6 |= set_desc((((priv->bcnTxAGC*6) & 0xfffffffe) & TX_TxAgcAMask) << TX_TxAgcASHIFT);
+	        pdesc->Dword6 |= set_desc((((priv->bcnTxAGC*6) & 0xfffffffe) & TX_TxAgcBMask) << TX_TxAgcBSHIFT);
         }
 
         priv->bcnTxAGC_bak = priv->bcnTxAGC;
@@ -4410,74 +4831,84 @@ void signin_beacon_desc(struct rtl8192cd_priv *priv, unsigned int *beaconbuf, un
 
 	if (priv->pshare->is_40m_bw != priv->pshare->is_40m_bw_bak)
     {
-        memset(&pdesc->Dword4, 0, 4);
+		memset(&pdesc->Dword4, 0, 4);
 
         pdesc->Dword4 = set_desc(TX_DisDataFB | TX_UseRate);
 
         if (priv->pshare->is_40m_bw)
         {
-            if (priv->pshare->offset_2nd_chan == HT_2NDCH_OFFSET_BELOW)
-                pdesc->Dword4 |= set_desc(2 << TX_DataScSHIFT);
+			if (priv->pshare->offset_2nd_chan == HT_2NDCH_OFFSET_BELOW)
+				pdesc->Dword4 |= set_desc(2 << TX_DataScSHIFT);
             else
-                pdesc->Dword4 |= set_desc(1 << TX_DataScSHIFT);
+				pdesc->Dword4 |= set_desc(1 << TX_DataScSHIFT);
         }
-
+        
         priv->pshare->is_40m_bw_bak = priv->pshare->is_40m_bw;
-
+        
 #ifdef CONFIG_RTL_92D_SUPPORT
-        if (priv->pmib->dot11RFEntry.phyBandSelect & PHY_BAND_5G)
-        {
-            pdesc->Dword4 |= set_desc((4 & TX_RtsRateMask) << TX_RtsRateSHIFT);
-        }
+	    if (priv->pmib->dot11RFEntry.phyBandSelect & PHY_BAND_5G) 
+		{
+			pdesc->Dword4 |= set_desc((4 & TX_RtsRateMask) << TX_RtsRateSHIFT);
+		}
 #endif
     }
 
+
 	if (frlen != priv->tx_beacon_len)
     {
-        memset(pdesc, 0, 24);
-        memset(&pdesc->Dword7, 0, 8);
+		memset(pdesc, 0, 24);
+	    memset(&pdesc->Dword7, 0, 8);
+
+	    pdesc->Dword0 = set_desc(TX_BMC|TX_FirstSeg| TX_LastSeg|  (32)<<TX_OffsetSHIFT | (frlen) << TX_PktSizeSHIFT);
+	    pdesc->Dword1 = set_desc(0x10 << TX_QSelSHIFT);
+	    pdesc->Dword3 |= set_desc((GetSequence(beaconbuf) & TX_SeqMask)<< TX_SeqSHIFT);
+//	    pdesc->Dword4 = set_desc((0x7 << TX_RaBRSRIDSHIFT) | TX_UseRate);	// need to confirm
+	    pdesc->Dword4 = set_desc(TX_DisDataFB | TX_UseRate);
+//	    pdesc->Dword4 = set_desc(TX_DisDataFB);
+//	    pdesc->Dword4 |= set_desc(0x08 << TX_RtsRateSHIFT);
+	
+		if (priv->pshare->is_40m_bw) 
+		{
+		    if (priv->pshare->offset_2nd_chan == HT_2NDCH_OFFSET_BELOW)
+			    pdesc->Dword4 |= set_desc(2 << TX_DataScSHIFT);
+		    else
+			    pdesc->Dword4 |= set_desc(1 << TX_DataScSHIFT);
+	    }
+		priv->pshare->is_40m_bw_bak = priv->pshare->is_40m_bw;
 
-        pdesc->Dword0 = set_desc(TX_BMC|TX_FirstSeg| TX_LastSeg|  (32)<<TX_OffsetSHIFT | (frlen) << TX_PktSizeSHIFT);
-        pdesc->Dword1 = set_desc(0x10 << TX_QSelSHIFT);
-        pdesc->Dword3 |= set_desc((GetSequence(beaconbuf) & TX_SeqMask)<< TX_SeqSHIFT);
-//      pdesc->Dword4 = set_desc((0x7 << TX_RaBRSRIDSHIFT) | TX_UseRate);   // need to confirm
-        pdesc->Dword4 = set_desc(TX_DisDataFB | TX_UseRate);
-//      pdesc->Dword4 = set_desc(TX_DisDataFB);
-//      pdesc->Dword4 |= set_desc(0x08 << TX_RtsRateSHIFT);
+		if (priv->pmib->dot11RFEntry.txbf == 1) {
+			pdesc->Dword2 &= set_desc(0x03ffffff); // clear related bits
 
-        if (priv->pshare->is_40m_bw)
-        {
-            if (priv->pshare->offset_2nd_chan == HT_2NDCH_OFFSET_BELOW)
-                pdesc->Dword4 |= set_desc(2 << TX_DataScSHIFT);
-            else
-                pdesc->Dword4 |= set_desc(1 << TX_DataScSHIFT);
-        }
-        priv->pshare->is_40m_bw_bak = priv->pshare->is_40m_bw;
+			pdesc->Dword2 |= set_desc(1 << TX_TxAntCckSHIFT);	// Set Default CCK rate with 1T
+			pdesc->Dword2 |= set_desc(1 << TX_TxAntlSHIFT); 	// Set Default Legacy rate with 1T
+			pdesc->Dword2 |= set_desc(1 << TX_TxAntHtSHIFT);	// Set Default Ht rate	
+		}
 
 #ifdef CONFIG_RTL_92D_SUPPORT
-        if (GET_CHIP_VER(priv)==VERSION_8192D){
-            pdesc->Dword2 &= set_desc(0x03ffffff); // clear related bits
-
-            pdesc->Dword2 |= set_desc(1 << TX_TxAntCckSHIFT);   // Set Default CCK rate with 1T
-            pdesc->Dword2 |= set_desc(1 << TX_TxAntlSHIFT);     // Set Default Legacy rate with 1T
-            pdesc->Dword2 |= set_desc(1 << TX_TxAntHtSHIFT);    // Set Default Ht rate
-
-            if (priv->pmib->dot11RFEntry.phyBandSelect & PHY_BAND_5G) {
-                pdesc->Dword4 |= set_desc((4 & TX_RtsRateMask) << TX_RtsRateSHIFT);
-                pdesc->Dword5 |= set_desc((4 & TX_DataRateMask) << TX_DataRateSHIFT);
-            }
-        }
+	    if (GET_CHIP_VER(priv)==VERSION_8192D){
+	        if (priv->pmib->dot11RFEntry.phyBandSelect & PHY_BAND_5G) {
+				pdesc->Dword4 |= set_desc((4 & TX_RtsRateMask) << TX_RtsRateSHIFT);
+	            pdesc->Dword5 |= set_desc((4 & TX_DataRateMask) << TX_DataRateSHIFT);
+			}
+		}
 #endif
-        priv->tx_beacon_len = frlen;
-        pdesc->Dword7 = set_desc(frlen & TX_TxBufSizeMask);
-        pdesc->Dword8 = set_desc(get_physical_addr(priv, beaconbuf, 128*sizeof(unsigned int), PCI_DMA_TODEVICE));
-    }
+		priv->tx_beacon_len = frlen;
+		pdesc->Dword7 = set_desc(frlen & TX_TxBufSizeMask);
+		pdesc->Dword8 = set_desc(get_physical_addr(priv, beaconbuf, 128*sizeof(unsigned int), PCI_DMA_TODEVICE));	
+	}
 	else
-    {
-        memset(&pdesc->Dword3, 0, 4);
-        pdesc->Dword3 |= set_desc((GetSequence(beaconbuf) & TX_SeqMask) << TX_SeqSHIFT);
-    }
-
+	{
+	    memset(&pdesc->Dword3, 0, 4);
+	    pdesc->Dword3 |= set_desc((GetSequence(beaconbuf) & TX_SeqMask) << TX_SeqSHIFT);
+	}
+	
+#ifdef P2P_SUPPORT
+	if (priv->pmib->dot11RFEntry.phyBandSelect & PHY_BAND_2G) {
+		if(OPMODE&WIFI_P2P_SUPPORT && P2PMODE==P2P_TMP_GO)
+			pdesc->Dword5 |= set_desc((4 & TX_DataRateMask) << TX_DataRateSHIFT);
+	}
+#endif
+ 
 	//set NextDescAddress
 #if 0
 	// next pointer should point to a descriptor
@@ -4487,7 +4918,7 @@ void signin_beacon_desc(struct rtl8192cd_priv *priv, unsigned int *beaconbuf, un
 #endif
 
 #if defined(RESERVE_TXDESC_FOR_EACH_IF) && (defined(UNIVERSAL_REPEATER) || defined(MBSSID))
-	if (priv->pmib->miscEntry.rsv_txdesc)
+	if (GET_ROOT(priv)->pmib->miscEntry.rsv_txdesc)
 		priv->use_txdesc_cnt[BEACON_QUEUE]++;
 #endif
 
@@ -4710,8 +5141,8 @@ void update_beacon(struct rtl8192cd_priv *priv)
 #endif
 
 #ifdef WIFI_SIMPLE_CONFIG
-		if (pmib->wscEntry.wsc_enable && pmib->wscEntry.beacon_ielen 
-			&& priv->pmib->dot11StationConfigEntry.dot11AclMode!=ACL_allow ) {
+		if (pmib->wscEntry.wsc_enable && pmib->wscEntry.beacon_ielen
+		&& priv->pmib->dot11StationConfigEntry.dot11AclMode!=ACL_allow) {
 			memcpy(pbuf, pmib->wscEntry.beacon_ie, pmib->wscEntry.beacon_ielen);
 			pbuf += pmib->wscEntry.beacon_ielen;
 			frlen += pmib->wscEntry.beacon_ielen;
@@ -4751,25 +5182,24 @@ void update_beacon(struct rtl8192cd_priv *priv)
 
 		pmib = GET_MIB(priv);
 		phw = GET_HW(priv);
-		
-		if (priv->update_bcn_period)
-        {
-            unsigned short val16 = 0;
-            pbuf = (unsigned char *)priv->beaconbuf;
-            frlen = 0;
-
-            pbuf += 24;
-            frlen += 24;
 
-            frlen += _TIMESTAMP_;   // for timestamp
-            pbuf += _TIMESTAMP_;
+		if (priv->update_bcn_period)
+		{
+			unsigned short val16 = 0;
+			pbuf = (unsigned char *)priv->beaconbuf;
+			frlen = 0;
+	
+			pbuf += 24;
+			frlen += 24;
 
-            //setup BeaconPeriod...
-            val16 = cpu_to_le16(pmib->dot11StationConfigEntry.dot11BeaconPeriod);
-            pbuf = set_fixed_ie(pbuf, _BEACON_ITERVAL_, (unsigned char *)&val16, &frlen);
-            priv->update_bcn_period = 0;
-        }
+	        frlen += _TIMESTAMP_;   // for timestamp
+		    pbuf += _TIMESTAMP_;
 
+			//setup BeaconPeriod...
+	        val16 = cpu_to_le16(pmib->dot11StationConfigEntry.dot11BeaconPeriod);
+		    pbuf = set_fixed_ie(pbuf, _BEACON_ITERVAL_, (unsigned char *)&val16, &frlen);
+			priv->update_bcn_period = 0;
+		}
 		frlen = priv->timoffset;
 		pbuf = (unsigned char *)priv->beaconbuf + priv->timoffset;
 
@@ -4823,8 +5253,8 @@ void update_beacon(struct rtl8192cd_priv *priv)
 			pbuf = set_ie(pbuf, _EXT_SUPPORTEDRATES_IE_, bssrate_len, pbssrate, &frlen);
 
 #ifdef DFS
+		static unsigned int set_stop_bcn = 0;
 		if (GET_ROOT(priv)->pmib->dot11DFSEntry.DFS_detected && priv->pshare->dfsSwitchChannel) {
-			static unsigned int set_stop_bcn = 0;
 			if (priv->pshare->dfsSwitchChCountDown) {
 				unsigned char tmpStr[3];
 				tmpStr[0] = 1;	/* channel switch mode */
@@ -4971,6 +5401,17 @@ void update_beacon(struct rtl8192cd_priv *priv)
 		}
 #endif
 
+#ifdef P2P_SUPPORT
+		if ((OPMODE&WIFI_P2P_SUPPORT) && ((P2PMODE==P2P_PRE_GO)||(P2PMODE ==P2P_TMP_GO)) ) 
+		{
+			if(priv->p2pPtr->p2p_beacon_ie_len){
+				memcpy(pbuf, priv->p2pPtr->p2p_beacon_ie, priv->p2pPtr->p2p_beacon_ie_len);
+				pbuf += priv->p2pPtr->p2p_beacon_ie_len;
+				frlen += priv->p2pPtr->p2p_beacon_ie_len;
+			}
+		}
+#endif
+
 /*
 		pdesc->Dword0 = set_desc(TX_FirstSeg| TX_LastSeg|  (32)<<TX_OffsetSHIFT | (frlen) << TX_PktSizeSHIFT);
 		pdesc->Dword1 = set_desc(0x10 << TX_QSelSHIFT);
@@ -5078,7 +5519,7 @@ void update_beacon(struct rtl8192cd_priv *priv)
  *	+-----------+-----------------+------------+------+--------------+------------------+	\n
  *	[Note] \n
  *	abridge FH (unused), CF (AP not support PCF), \n
- *	IBSS parameter set (STA), DTIM (AP), ERP P Ext rate  IE complete in Update beacon.\n
+ *	IBSS parameter set (STA), DTIM (AP), ERP ??Ext rate  IE complete in Update beacon.\n
  *	set_desc is important.
  */
 
@@ -5333,6 +5774,7 @@ void init_beacon(struct rtl8192cd_priv *priv)
 }
 
 
+#ifndef CONFIG_RTL_NEW_AUTOCH
 static void setChannelScore(int number, unsigned int *val, int min, int max)
 {
 	int i=0, score;
@@ -5353,6 +5795,8 @@ static void setChannelScore(int number, unsigned int *val, int min, int max)
 		}
 	}
 }
+#endif
+
 
 #if defined(CONFIG_RTL_NEW_AUTOCH) && defined(SS_CH_LOAD_PROC)
 static void record_SS_report(struct rtl8192cd_priv *priv)
@@ -5382,7 +5826,9 @@ static int selectClearChannel(struct rtl8192cd_priv *priv)
 	unsigned int score[64];
 	unsigned int minScore=0xffffffff;
 	int i, idx=0, idx_2G_end=-1, idx_5G_begin=-1, minChan=0;
+#ifndef CONFIG_RTL_NEW_AUTOCH
 	struct bss_desc *pBss=NULL;
+#endif
 #ifdef _DEBUG_RTL8192CD_
 	char tmpbuf[200];
 	int len=0;
@@ -5405,6 +5851,7 @@ static int selectClearChannel(struct rtl8192cd_priv *priv)
 		}
 	}
 
+#ifndef CONFIG_RTL_NEW_AUTOCH
 	for (i=0; i<priv->site_survey.count; i++) {
 		pBss = &priv->site_survey.bss[i];
 		for (idx=0; idx<priv->available_chnl_num; idx++) {
@@ -5417,6 +5864,7 @@ static int selectClearChannel(struct rtl8192cd_priv *priv)
 			}
 		}
 	}
+#endif
 
 	if (idx_2G_end >= 0)
 		for (i=0; i<=idx_2G_end; i++)
@@ -5425,42 +5873,71 @@ static int selectClearChannel(struct rtl8192cd_priv *priv)
 		for (i=idx_5G_begin; i<priv->available_chnl_num; i++)
 			score[i] = score5G[i - idx_5G_begin];
 		
-#if defined(CONFIG_RTL_NEW_AUTOCH)
+#ifdef CONFIG_RTL_NEW_AUTOCH
 	{
-		unsigned int y, fa_thd=0, cca_thd=0, ch_num=0, ch_begin=0, ch_end= priv->available_chnl_num;
+		unsigned int y, /*cca_thd=0, ch_num=0,*/ ch_begin=0, ch_end= priv->available_chnl_num;
+		/*unsigned int mac_rx_th=0, mac_rx_ch_count=0, fa_ch_count=0;*/
 		if (idx_2G_end >= 0) 
 			ch_end = idx_2G_end+1;
 		if (idx_5G_begin >= 0)  
 			ch_begin = idx_5G_begin;
-		
-		for (y=ch_begin; y<ch_end; y++)  {
-			fa_thd += priv->chnl_ss_fa_count[y];
-			if( priv->chnl_ss_cca_count[y] > priv->chnl_ss_fa_count[y])
-				priv->chnl_ss_cca_count[y]-= priv->chnl_ss_fa_count[y];
-			else
-				priv->chnl_ss_cca_count[y] = 0;
-		}
-
 
-		fa_thd /= (ch_end-ch_begin);
-		
-		for (y=ch_begin; y<ch_end; y++)  {
-			if( priv->chnl_ss_fa_count[y] > fa_thd)  {
-				score[y] = 0xffffffff;
-				priv->chnl_ss_cca_count[y] = 0; // ignore cca 
-			}
-			else {
-				cca_thd += priv->chnl_ss_cca_count[y];
-				++ch_num;
+		/*
+		 * 	For each channel, weighting behind channels with MAC RX counter
+		 * 	For each channel, weighting the channel with FA counter
+		 */
+		for (y=ch_begin; y<ch_end; y++) {
+			score[y] += 10 * priv->chnl_ss_mac_rx_count[y];
+			score[y] += priv->chnl_ss_fa_count[y];
+#ifdef CONFIG_RTL_92D_SUPPORT
+			if (priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_2G)
+#endif
+			{
+				if ((int)(y-3) >= (int)ch_begin)
+					score[y-3] += 5 * priv->chnl_ss_mac_rx_count[y];
+				if ((int)(y-2) >= (int)ch_begin)
+					score[y-2] += 9 * priv->chnl_ss_mac_rx_count[y];
+				if ((int)(y-1) >= (int)ch_begin)
+					score[y-1] += 9 * priv->chnl_ss_mac_rx_count[y];
+				if ((int)(y+1) < (int)ch_end)
+					score[y+1] += 9 * priv->chnl_ss_mac_rx_count[y];
+				if ((int)(y+2) < (int)ch_end)
+					score[y+2] += 9 * priv->chnl_ss_mac_rx_count[y];
+				if ((int)(y+3) < (int)ch_end)
+					score[y+3] += 5 * priv->chnl_ss_mac_rx_count[y];
 			}
-		}		
-
-		cca_thd /= ch_num;
-		for (y=ch_begin; y<ch_end; y++)  {
-			if( priv->chnl_ss_cca_count[y] > cca_thd)  
-				score[y] = 0xffffffff;
 		}
 
+		for (y=ch_begin; y<ch_end; y++) {
+			if (priv->chnl_ss_mac_rx_count_40M[y]) {
+				score[y] += 10 * priv->chnl_ss_mac_rx_count_40M[y];
+#ifdef CONFIG_RTL_92D_SUPPORT
+				if (priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_2G)
+#endif
+				{
+					if ((int)(y-5) >= (int)ch_begin)
+						score[y-5] += 5 * priv->chnl_ss_mac_rx_count_40M[y];
+					if ((int)(y-4) >= (int)ch_begin)
+						score[y-4] += 7 * priv->chnl_ss_mac_rx_count_40M[y];
+					if ((int)(y-3) >= (int)ch_begin)
+						score[y-3] += 7 * priv->chnl_ss_mac_rx_count_40M[y];
+					if ((int)(y-2) >= (int)ch_begin)
+						score[y-2] += 9 * priv->chnl_ss_mac_rx_count_40M[y];
+					if ((int)(y-1) >= (int)ch_begin)
+						score[y-1] += 9 * priv->chnl_ss_mac_rx_count_40M[y];
+					if ((int)(y+1) < (int)ch_end)
+						score[y+1] += 9 * priv->chnl_ss_mac_rx_count_40M[y];
+					if ((int)(y+2) < (int)ch_end)
+						score[y+2] += 9 * priv->chnl_ss_mac_rx_count_40M[y];
+					if ((int)(y+3) < (int)ch_end)
+						score[y+3] += 7 * priv->chnl_ss_mac_rx_count_40M[y];
+					if ((int)(y+4) < (int)ch_end)
+						score[y+4] += 7 * priv->chnl_ss_mac_rx_count_40M[y];
+					if ((int)(y+5) < (int)ch_end)
+						score[y+5] += 5 * priv->chnl_ss_mac_rx_count_40M[y];
+				}
+			}
+		}
 #ifdef 	SS_CH_LOAD_PROC
 
 		// caculate noise level -- suggested by wilson
@@ -5601,8 +6078,26 @@ static int selectClearChannel(struct rtl8192cd_priv *priv)
 
 	// skip channel 14 if don't support ofdm
 	if ((priv->pmib->dot11RFEntry.disable_ch14_ofdm) &&
-		(minChan == 14))
+		(minChan == 14)) {
 		minChan = 13;
+		for (i=0; i<priv->available_chnl_num; i++) {
+			if (priv->available_chnl[i] == 13)
+				idx = i;
+		}
+	}
+
+#ifdef CONFIG_RTL_NEW_AUTOCH
+	RTL_W32(RXERR_RPT, RXERR_RPT_RST);
+
+	{
+		unsigned int y, ch_begin=0, ch_end= priv->available_chnl_num;
+		if (idx_2G_end >= 0) 
+			ch_end = idx_2G_end+1;
+		if (idx_5G_begin >= 0)  
+			ch_begin = idx_5G_begin;
+
+	}
+#endif
 
 // auto adjust contro-sideband
 	if ((priv->pmib->dot11BssType.net_work_type & WIRELESS_11N)
@@ -5621,13 +6116,34 @@ static int selectClearChannel(struct rtl8192cd_priv *priv)
 		} else
 #endif		
 		{
-			if (minChan < 5) {
-				GET_MIB(priv)->dot11nConfigEntry.dot11n2ndChOffset = HT_2NDCH_OFFSET_ABOVE;
-				priv->pshare->offset_2nd_chan	= HT_2NDCH_OFFSET_ABOVE;
-			}
-			else if (minChan > 7) {
-				GET_MIB(priv)->dot11nConfigEntry.dot11n2ndChOffset = HT_2NDCH_OFFSET_BELOW;
-				priv->pshare->offset_2nd_chan	= HT_2NDCH_OFFSET_BELOW;
+			unsigned int set_above=0;
+#ifdef CONFIG_RTL_NEW_AUTOCH
+			unsigned int ch_max;
+
+			if (priv->available_chnl[idx_2G_end] >= 13)
+				ch_max = 13;
+			else
+				ch_max = priv->available_chnl[idx_2G_end];
+
+			if ((minChan >= 5) && (minChan <= (ch_max-5))) {
+				if (score[minChan+4] > score[minChan-4]) { /* what if some channels were cancelled? */
+					GET_MIB(priv)->dot11nConfigEntry.dot11n2ndChOffset = HT_2NDCH_OFFSET_BELOW;
+					priv->pshare->offset_2nd_chan	= HT_2NDCH_OFFSET_BELOW;
+				} else {
+					GET_MIB(priv)->dot11nConfigEntry.dot11n2ndChOffset = HT_2NDCH_OFFSET_ABOVE;
+					priv->pshare->offset_2nd_chan	= HT_2NDCH_OFFSET_ABOVE;
+				}
+			} else
+#endif
+			{
+				if (minChan < 5) {
+					GET_MIB(priv)->dot11nConfigEntry.dot11n2ndChOffset = HT_2NDCH_OFFSET_ABOVE;
+					priv->pshare->offset_2nd_chan	= HT_2NDCH_OFFSET_ABOVE;
+				}
+				else if (minChan > 7) {
+					GET_MIB(priv)->dot11nConfigEntry.dot11n2ndChOffset = HT_2NDCH_OFFSET_BELOW;
+					priv->pshare->offset_2nd_chan	= HT_2NDCH_OFFSET_BELOW;
+				}
 			}
 		}
 	}
@@ -5635,6 +6151,22 @@ static int selectClearChannel(struct rtl8192cd_priv *priv)
 	return minChan;
 }
 
+#ifdef CONFIG_RTL_WLAN_DOS_FILTER
+int issue_disassoc_from_kernel(void *priv, unsigned char *mac)
+{
+	memcpy(block_mac[block_mac_idx], mac, 6);
+	block_mac_idx++;
+	block_mac_idx = block_mac_idx % MAX_BLOCK_MAC;
+	
+	if (priv != NULL) {
+//		issue_disassoc((struct rtl8192cd_priv *)priv, mac, _RSON_UNSPECIFIED_);
+		issue_deauth((struct rtl8192cd_priv *)priv, mac, _RSON_UNSPECIFIED_);
+		block_sta_time = ((struct rtl8192cd_priv *)priv)->pshare->rf_ft_var.dos_block_time;
+		block_priv = (unsigned long)priv;
+	}
+	return 0;
+}
+#endif
 
 /**
  *	@brief	issue de-authenticaion
@@ -5669,6 +6201,25 @@ void issue_deauth_MP(struct rtl8192cd_priv *priv,	unsigned char *da, int reason,
 		return;
 	}
 
+#ifdef TLN_STATS
+	stats_conn_rson_counts(priv, reason);
+#endif
+
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv)==VERSION_8188E) {
+		struct stat_info *pstat = get_stainfo(priv, da);
+
+		if (pstat
+#ifdef STA_EXT
+			&& (REMAP_AID(pstat) < (RTL8188E_NUM_STAT - 1))
+#endif
+			) {
+			RTL8188E_MACID_NOLINK(priv, 1, REMAP_AID(pstat));
+			RTL8188E_MACID_PAUSE(priv, 0, REMAP_AID(pstat));
+		}
+	}
+#endif
+
 	txinsn.retry = priv->pmib->dot11OperationEntry.dot11ShortRetryLimit;
 
 	pmib= GET_MIB(priv);
@@ -5701,11 +6252,22 @@ void issue_deauth_MP(struct rtl8192cd_priv *priv,	unsigned char *da, int reason,
 
 	pbuf = set_fixed_ie(pbuf, _RSON_CODE_ , (unsigned char *)&val, &txinsn.fr_len);
 
+#ifdef P2P_SUPPORT
+	if(OPMODE&WIFI_P2P_SUPPORT && P2PMODE==P2P_CLIENT){
+		if(priv->p2pPtr->p2p_disass_ie_len){
+			memcpy(pbuf, priv->p2pPtr->p2p_disass_ie, priv->p2pPtr->p2p_disass_ie_len);
+			pbuf += priv->p2pPtr->p2p_disass_ie_len;
+			txinsn.fr_len += priv->p2pPtr->p2p_disass_ie_len;
+		}
+	}
+#endif
+
+
 	SetFrameType((txinsn.phdr),WIFI_MGT_TYPE);
 	SetFrameSubType((txinsn.phdr),WIFI_DEAUTH);
 
 	memcpy((void *)GetAddr1Ptr((txinsn.phdr)), da, MACADDRLEN);
-	memcpy((void *)GetAddr2Ptr((txinsn.phdr)), bssid, MACADDRLEN);
+	memcpy((void *)GetAddr2Ptr((txinsn.phdr)), GET_MY_HWADDR, MACADDRLEN);
 
 #ifdef CONFIG_RTK_MESH
 	if (TRUE == is_11s)
@@ -5743,6 +6305,25 @@ void issue_disassoc(struct rtl8192cd_priv *priv, unsigned char *da, int reason)
 		return;
 	}
 
+#ifdef TLN_STATS
+	stats_conn_rson_counts(priv, reason);
+#endif
+
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv)==VERSION_8188E) {
+		struct stat_info *pstat = get_stainfo(priv, da);
+
+		if (pstat
+#ifdef STA_EXT
+			&& (REMAP_AID(pstat) < (RTL8188E_NUM_STAT - 1))
+#endif
+			) {
+			RTL8188E_MACID_NOLINK(priv, 1, REMAP_AID(pstat));
+			RTL8188E_MACID_PAUSE(priv, 0, REMAP_AID(pstat));
+		}
+	}
+#endif
+
 	txinsn.retry = priv->pmib->dot11OperationEntry.dot11ShortRetryLimit;
 
 	pmib= GET_MIB(priv);
@@ -5771,6 +6352,16 @@ void issue_disassoc(struct rtl8192cd_priv *priv, unsigned char *da, int reason)
 
 	pbuf = set_fixed_ie(pbuf, _RSON_CODE_, (unsigned char *)&val, &txinsn.fr_len);
 
+#ifdef P2P_SUPPORT
+	if(OPMODE&WIFI_P2P_SUPPORT && P2PMODE==P2P_CLIENT){
+		if(priv->p2pPtr->p2p_disass_ie_len){
+			memcpy(pbuf, priv->p2pPtr->p2p_disass_ie, priv->p2pPtr->p2p_disass_ie_len);
+			pbuf += priv->p2pPtr->p2p_disass_ie_len;
+			txinsn.fr_len += priv->p2pPtr->p2p_disass_ie_len;
+		}
+	}
+#endif
+
 	SetFrameType((txinsn.phdr), WIFI_MGT_TYPE);
 	SetFrameSubType((txinsn.phdr), WIFI_DISASSOC);
 
@@ -5988,6 +6579,10 @@ void issue_asocrsp(struct rtl8192cd_priv *priv, unsigned short status, struct st
 	unsigned char	*bssid,*pbuf;
 	DECLARE_TXINSN(txinsn);
 
+#ifdef TLN_STATS
+	stats_conn_status_counts(priv, status);
+#endif
+
 	txinsn.retry = priv->pmib->dot11OperationEntry.dot11ShortRetryLimit;
 
 	pmib= GET_MIB(priv);
@@ -6001,6 +6596,18 @@ void issue_asocrsp(struct rtl8192cd_priv *priv, unsigned short status, struct st
 	txinsn.fixed_rate = 1;
 	pbuf = txinsn.pframe  = get_mgtbuf_from_poll(priv);
 
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv)==VERSION_8188E) {
+#ifdef STA_EXT
+		if (REMAP_AID(pstat) < (RTL8188E_NUM_STAT - 1))
+#endif
+		{
+			RTL8188E_MACID_NOLINK(priv, (status == _STATS_SUCCESSFUL_)?0:1, REMAP_AID(pstat));
+			RTL8188E_MACID_PAUSE(priv, 0, REMAP_AID(pstat));
+		}
+	}
+#endif
+
 	if (pbuf == NULL)
 		goto issue_asocrsp_fail;
 
@@ -6077,6 +6684,18 @@ void issue_asocrsp(struct rtl8192cd_priv *priv, unsigned short status, struct st
 	if (priv->pshare->rtk_ie_len)
 		pbuf = set_ie(pbuf, _RSN_IE_1_, priv->pshare->rtk_ie_len, priv->pshare->rtk_ie_buf, &txinsn.fr_len);
 
+#ifdef P2P_SUPPORT
+	if(OPMODE&WIFI_P2P_SUPPORT && P2PMODE==P2P_TMP_GO){
+		if(pstat->is_p2p_client){
+			if(priv->p2pPtr->p2p_assoc_RspIe_len){
+				memcpy(pbuf, priv->p2pPtr->p2p_assoc_RspIe , priv->p2pPtr->p2p_assoc_RspIe_len);
+				pbuf += priv->p2pPtr->p2p_assoc_RspIe_len;
+				txinsn.fr_len += priv->p2pPtr->p2p_assoc_RspIe_len;
+			}
+		}			
+	}
+#endif
+
 	if ((pkt_type == WIFI_ASSOCRSP) || (pkt_type == WIFI_REASSOCRSP))
 		SetFrameSubType((txinsn.phdr), pkt_type);
 	else
@@ -6133,6 +6752,10 @@ int fill_probe_rsp_content(struct rtl8192cd_priv *priv,
 	unsigned long		flags;
 #endif
 
+#ifdef P2P_SUPPORT
+	int need_include_p2pie = 0;
+#endif
+
 	pmib= GET_MIB(priv);
 
 	bssid = pmib->dot11StationConfigEntry.dot11Bssid;
@@ -6143,6 +6766,14 @@ int fill_probe_rsp_content(struct rtl8192cd_priv *priv,
     val = cpu_to_le16(pmib->dot11StationConfigEntry.dot11BeaconPeriod);
 	pbuf = set_fixed_ie(pbuf,  _BEACON_ITERVAL_ , (unsigned char *)&val, (unsigned int *)&fr_len);
 
+#ifdef P2P_SUPPORT
+	if( (OPMODE & WIFI_P2P_SUPPORT) 
+		&& (P2PMODE == P2P_DEVICE) 
+		&& (P2P_STATE == P2P_S_LISTEN))
+	{
+		val |= cpu_to_le16(BIT(0)); //set ESS	 to 1
+	}else
+#endif
 #ifdef CONFIG_RTK_MESH
 	if ((1 == GET_MIB(priv)->dot1180211sInfo.mesh_enable) && (0 == GET_MIB(priv)->dot1180211sInfo.mesh_ap_enable))	// non-AP MP (MAP)	only, popen:802.11s Draft 1.0 P17  7.3.1.4 : ESS & IBSS are "0" (PS:val Reset here.)
 		val = 0;
@@ -6175,10 +6806,23 @@ int fill_probe_rsp_content(struct rtl8192cd_priv *priv,
 
 	pbuf = set_ie(pbuf, _SSID_IE_, ssid_len, ssid, (unsigned int *)&fr_len);
 
+#ifdef P2P_SUPPORT
+	if(OPMODE&WIFI_P2P_SUPPORT)
+		get_bssrate_set(priv, _SUPPORTED_RATES_NO_CCK_, &pbssrate, &bssrate_len);	
+	else
+#endif
 	get_bssrate_set(priv, _SUPPORTEDRATES_IE_, &pbssrate, &bssrate_len);
 	pbuf = set_ie(pbuf, _SUPPORTEDRATES_IE_, bssrate_len, pbssrate, (unsigned int *)&fr_len);
 
-	val8 = pmib->dot11RFEntry.dot11channel;
+
+#ifdef P2P_SUPPORT		// fill DSSET
+	if((OPMODE&WIFI_P2P_SUPPORT) && (P2PMODE == P2P_DEVICE)&& (P2P_STATE==P2P_S_LISTEN )){
+		val8 = priv->pmib->p2p_mib.p2p_listen_channel;
+	}else
+#endif
+	{
+		val8 = pmib->dot11RFEntry.dot11channel;
+	}
 
 	pbuf = set_ie(pbuf, _DSSET_IE_, 1, &val8 , (unsigned int *)&fr_len);
 
@@ -6243,17 +6887,9 @@ int fill_probe_rsp_content(struct rtl8192cd_priv *priv,
 		pbuf = set_ie(pbuf, _RSN_IE_1_, _WMM_Para_Element_Length_, GET_WMM_PARA_IE, (unsigned int *)&fr_len);
 #endif
 
-#ifdef WIFI_SIMPLE_CONFIG
-/*modify for WPS2DOTX SUPPORT*/
-	if (!priv->pshare->rf_ft_var.NDSi_support 
-		&& priv->pmib->dot11StationConfigEntry.dot11AclMode!=ACL_allow){
-		if (pmib->wscEntry.wsc_enable && pmib->wscEntry.probe_rsp_ielen) {
-			memcpy(pbuf, pmib->wscEntry.probe_rsp_ie, pmib->wscEntry.probe_rsp_ielen);
-			pbuf += pmib->wscEntry.probe_rsp_ielen;
-			fr_len += pmib->wscEntry.probe_rsp_ielen;
-		}
-	}
-#endif
+
+
+
 
 	if (priv->pmib->dot11BssType.net_work_type & WIRELESS_11N) {
 		/*
@@ -6317,6 +6953,50 @@ int fill_probe_rsp_content(struct rtl8192cd_priv *priv,
 		fr_len += pmib->miscEntry.private_ie_len;
 	}
 
+#ifdef P2P_SUPPORT		
+	if(	(P2PMODE == P2P_DEVICE) && (P2P_STATE == P2P_S_LISTEN))	 
+	{
+		if(pmib->wscEntry.probe_rsp_ielen){
+			memcpy(pbuf, pmib->wscEntry.probe_rsp_ie, pmib->wscEntry.probe_rsp_ielen);
+			pbuf += pmib->wscEntry.probe_rsp_ielen;
+			fr_len += pmib->wscEntry.probe_rsp_ielen;
+		}
+	}
+	else
+#endif
+#ifdef WIFI_SIMPLE_CONFIG
+	{
+		if (!priv->pshare->rf_ft_var.NDSi_support
+		&& priv->pmib->dot11StationConfigEntry.dot11AclMode!=ACL_allow){
+			if (pmib->wscEntry.wsc_enable && pmib->wscEntry.probe_rsp_ielen) {
+				memcpy(pbuf, pmib->wscEntry.probe_rsp_ie, pmib->wscEntry.probe_rsp_ielen);
+				pbuf += pmib->wscEntry.probe_rsp_ielen;
+				fr_len += pmib->wscEntry.probe_rsp_ielen;
+			}
+		}
+	}
+#endif
+
+#ifdef P2P_SUPPORT
+	if( (OPMODE&WIFI_P2P_SUPPORT) && (P2PMODE == P2P_TMP_GO)){
+		if(priv->p2pPtr->probe_rps_to_p2p_dev){
+			need_include_p2pie = 1;
+			priv->p2pPtr->probe_rps_to_p2p_dev = 0;
+		}
+	}
+
+	if ( ((P2PMODE == P2P_DEVICE) && (P2P_STATE == P2P_S_LISTEN)) 
+		 ||  need_include_p2pie ) 
+	{
+		if(priv->p2pPtr->p2p_probe_rsp_ie_len){
+			memcpy(pbuf, priv->p2pPtr->p2p_probe_rsp_ie, priv->p2pPtr->p2p_probe_rsp_ie_len);
+			pbuf += priv->p2pPtr->p2p_probe_rsp_ie_len ;
+			fr_len += priv->p2pPtr->p2p_probe_rsp_ie_len ;
+		}
+	}	
+#endif
+
+
 
 	SetFrameSubType((phdr), WIFI_PROBERSP);
 	memcpy((void *)GetAddr2Ptr((phdr)), GET_MY_HWADDR, MACADDRLEN);
@@ -6340,7 +7020,15 @@ int fill_probe_rsp_content(struct rtl8192cd_priv *priv,
 		memset((void *)GetAddr3Ptr((phdr)), 0, MACADDRLEN);
 	else
 #endif
-	memcpy((void *)GetAddr3Ptr((phdr)), bssid, MACADDRLEN);
+#ifdef P2P_SUPPORT		
+	if(	(P2PMODE == P2P_DEVICE) && (P2P_STATE == P2P_S_LISTEN))	{
+		memcpy((void *)GetAddr3Ptr((phdr)), GET_MY_HWADDR , MACADDRLEN);
+	}
+	else
+#endif
+	{
+		memcpy((void *)GetAddr3Ptr((phdr)), bssid, MACADDRLEN);
+	}
 
 	return fr_len;
 }
@@ -6364,7 +7052,8 @@ int fill_probe_rsp_content(struct rtl8192cd_priv *priv,
  *	\param	ssid_len	SSID length
  *	\param 	set_privacy	Use Robust security network
  */
-static void issue_probersp(struct rtl8192cd_priv *priv, unsigned char *da,
+//static 	;  extern for P2P_SUPPORT
+void issue_probersp(struct rtl8192cd_priv *priv, unsigned char *da,
 				UINT8 *ssid, int ssid_len, int set_privacy)
 {
 #ifdef CONFIG_RTK_MESH
@@ -6483,20 +7172,62 @@ void issue_probereq_MP(struct rtl8192cd_priv *priv, unsigned char *ssid, int ssi
 
 	pbuf = set_ie(pbuf, _SSID_IE_, ssid_len, ssid, &txinsn.fr_len);
 
-	get_bssrate_set(priv, _SUPPORTEDRATES_IE_, &pbssrate, &bssrate_len);
+	/*fill supported rates*/ 
+
+#ifdef P2P_SUPPORT
+	if(OPMODE&WIFI_P2P_SUPPORT){
+		get_bssrate_set(priv, _SUPPORTED_RATES_NO_CCK_, &pbssrate, &bssrate_len);	
+	}else
+#endif
+	{
+		get_bssrate_set(priv, _SUPPORTEDRATES_IE_, &pbssrate, &bssrate_len);	
+	}
+
+	
 	pbuf = set_ie(pbuf, _SUPPORTEDRATES_IE_ , bssrate_len , pbssrate, &txinsn.fr_len);
 
 	if (get_bssrate_set(priv, _EXT_SUPPORTEDRATES_IE_, &pbssrate, &bssrate_len))
 		pbuf = set_ie(pbuf, _EXT_SUPPORTEDRATES_IE_ , bssrate_len , pbssrate, &txinsn.fr_len);
 
+#ifdef P2P_SUPPORT		
+	if (OPMODE&WIFI_P2P_SUPPORT) 
+	{		/*add wsc ie*/
+		if(pmib->wscEntry.probe_rsp_ielen){
+			memcpy(pbuf, pmib->wscEntry.probe_rsp_ie, pmib->wscEntry.probe_rsp_ielen);
+			pbuf += pmib->wscEntry.probe_rsp_ielen;
+			txinsn.fr_len += pmib->wscEntry.probe_rsp_ielen;
+		}
+	}
+	else
+#endif
 #ifdef WIFI_SIMPLE_CONFIG
-	if (pmib->wscEntry.wsc_enable && pmib->wscEntry.probe_req_ielen) {
-		memcpy(pbuf, pmib->wscEntry.probe_req_ie, pmib->wscEntry.probe_req_ielen);
-		pbuf += pmib->wscEntry.probe_req_ielen;
-		txinsn.fr_len += pmib->wscEntry.probe_req_ielen;
+	{
+		if (pmib->wscEntry.wsc_enable && pmib->wscEntry.probe_req_ielen) {
+			memcpy(pbuf, pmib->wscEntry.probe_req_ie, pmib->wscEntry.probe_req_ielen);
+			pbuf += pmib->wscEntry.probe_req_ielen;
+			txinsn.fr_len += pmib->wscEntry.probe_req_ielen;
+		}
 	}
 #endif
 
+#ifdef P2P_SUPPORT
+	if (OPMODE&WIFI_P2P_SUPPORT) 
+	{
+		if(priv->p2pPtr->p2p_probe_req_ie_len){
+
+			memcpy(pbuf, priv->p2pPtr->p2p_probe_req_ie, 
+				priv->p2pPtr->p2p_probe_req_ie_len);
+			
+			pbuf += priv->p2pPtr->p2p_probe_req_ie_len ;
+			txinsn.fr_len += priv->p2pPtr->p2p_probe_req_ie_len ;
+			
+		}
+
+	}	
+#endif
+
+
+
 #ifdef CONFIG_RTK_MESH	// mesh_profile Configure by WEB in the future, Maybe delete, Preservation before delete
 	if((TRUE == is_11s) && (1 == GET_MIB(priv)->dot1180211sInfo.mesh_enable) && (TRUE == priv->mesh_profile[0].used)
 			&& (MESH_PEER_LINK_CAP_NUM(priv) > 0))
@@ -6781,7 +7512,10 @@ void issue_ADDBAreq(struct rtl8192cd_priv *priv, struct stat_info *pstat, unsign
 
 	DEBUG_INFO("ADDBA-req sent to AID %d, token %d TID %d size %d seq %d\n",
 		pstat->aid, pstat->dialog_token, TID, max_size, pstat->AC_seq[TID]);
-
+	/*
+	panic_printk("ADDBA-req sent to AID %d, token %d TID %d size %d seq %d\n",
+		pstat->aid, pstat->dialog_token, TID, max_size, pstat->AC_seq[TID]);
+	*/
 	if ((rtl8192cd_firetx(priv, &txinsn)) == SUCCESS) {
 		//pstat->ADDBA_ready++;
 		return;
@@ -6998,47 +7732,30 @@ send_rtk_wake_up_fail:
 
 
 #ifdef CONFIG_RTL_92D_SUPPORT
-int clnt_ss_check_band(struct rtl8192cd_priv *priv, unsigned int channel){
+int clnt_ss_check_band(struct rtl8192cd_priv *priv, unsigned int channel)
+{
 #ifdef CLIENT_MODE
 	if (OPMODE & (WIFI_STATION_STATE|WIFI_ADHOC_STATE)) {
 		if (priv->pmib->dot11RFEntry.macPhyMode==SINGLEMAC_SINGLEPHY) {
 			if (channel > 14 && priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_2G){
 				//printk("change to 5G %d\n", channel);
-
-				//Stop receiving Management frames & Clear Rx
-				RTL_W32(RCR, RTL_R32(RCR) & ~(RCR_AMF));
-				rtl8192cd_rx_isr(priv);
-
 				// stop BB
 				PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0x00f00000, 0xf);
 				priv->pmib->dot11RFEntry.phyBandSelect = PHY_BAND_5G;
 				//priv->pmib->dot11BssType.net_work_type = (WIRELESS_11A|WIRELESS_11N);
 				UpdateBBRFVal8192DE(priv);
 				PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0x00f00000, 0x0);
-
-				//Restore receiving Management frames
-				RTL_W32(RCR, RTL_R32(RCR) | (RCR_AMF));
-
 				return 1;
 			}
 			
 			if (channel <= 14 && priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_5G){
 				//printk("change to 2G %d\n", channel);
-
-				//Stop receiving Management frames & Clear Rx
-				RTL_W32(RCR, RTL_R32(RCR) & ~(RCR_AMF));
-				rtl8192cd_rx_isr(priv);
-
 				PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0x00f00000, 0xf);
 				priv->pmib->dot11RFEntry.phyBandSelect = PHY_BAND_2G;
 				//priv->pmib->dot11BssType.net_work_type = (WIRELESS_11B|WIRELESS_11G|WIRELESS_11N);
 				//PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0x00f00000, 0x0);
 				UpdateBBRFVal8192DE(priv);
 				PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0x00f00000, 0x0);
-
-				//Restore receiving Management frames
-				RTL_W32(RCR, RTL_R32(RCR) | (RCR_AMF));
-
 				return 1;
 			}
 		}
@@ -7048,6 +7765,7 @@ int clnt_ss_check_band(struct rtl8192cd_priv *priv, unsigned int channel){
 }
 #endif
 
+
 /**
  *	@brief	Process Site Survey
  *
@@ -7069,6 +7787,14 @@ void start_clnt_ss(struct rtl8192cd_priv *priv)
 		del_timer_sync(&priv->idle_timer);
 #endif
 
+#ifdef P2P_SUPPORT
+	if( (OPMODE & WIFI_P2P_SUPPORT)&& (P2PMODE == P2P_DEVICE)&&(P2P_STATE == P2P_S_LISTEN)){
+		P2P_DEBUG("p2p device listen mode don't SS!!\n");
+		return;
+	}
+#endif					
+
+
 	OPMODE &= (~WIFI_SITE_MONITOR);
 
 	SAVE_INT_AND_CLI(flags);
@@ -7125,6 +7851,11 @@ void start_clnt_ss(struct rtl8192cd_priv *priv)
 		priv->pshare->CurrentChannelBW = HT_CHANNEL_WIDTH_20;
 		SwBWMode(priv, priv->pshare->CurrentChannelBW, priv->pshare->offset_2nd_chan);
 		SwChnl(priv, priv->site_survey.ss_channel, priv->pshare->offset_2nd_chan);
+		
+#if defined(CONFIG_RTL_92D_SUPPORT) && !defined(CONFIG_RTL_DUAL_PCIESLOT_BIWLAN_D)
+		if ((GET_CHIP_VER(priv) == VERSION_8192D) && (priv->pmib->dot11RFEntry.macPhyMode == SINGLEMAC_SINGLEPHY)) 
+			PHY_IQCalibrate(priv);
+#endif					
 	}
 
 	memset((void *)&priv->site_survey.bss, 0, sizeof(struct bss_desc)*MAX_BSS_NUM);
@@ -7140,7 +7871,7 @@ void start_clnt_ss(struct rtl8192cd_priv *priv)
 		memset((void *)&priv->site_survey.rsn_ie, 0, sizeof(struct rsn_ie_info)*MAX_BSS_NUM);
 #endif 
 
-#ifdef TESTCHIP_SUPPORT
+#if defined(TESTCHIP_SUPPORT) && defined(CONFIG_RTL_92C_SUPPORT)
 	if(IS_TEST_CHIP(priv))
 		RTL_W8(BCN_CTRL, RTL_R8(BCN_CTRL) | DIS_TSF_UPDATE);
 	else
@@ -7148,7 +7879,7 @@ void start_clnt_ss(struct rtl8192cd_priv *priv)
 		RTL_W8(BCN_CTRL, RTL_R8(BCN_CTRL) | DIS_TSF_UPDATE_N);
 
 #if defined(CLIENT_MODE)
-#ifdef TESTCHIP_SUPPORT
+#if defined(TESTCHIP_SUPPORT) && defined(CONFIG_RTL_92C_SUPPORT)
 	if( IS_TEST_CHIP(priv) ) {		
 		if ((OPMODE & WIFI_STATION_STATE) || (OPMODE & WIFI_ADHOC_STATE))
 			RTL_W32(RCR, RTL_R32(RCR) & ~RCR_CBSSID);
@@ -7175,9 +7906,12 @@ void start_clnt_ss(struct rtl8192cd_priv *priv)
 #endif	
 	OPMODE |= WIFI_SITE_MONITOR;
 	RESTORE_INT(flags);
-#if defined(CONFIG_RTL_NEW_AUTOCH)
+#ifdef CONFIG_RTL_NEW_AUTOCH
 	if (priv->auto_channel == 1) {
 		reset_FA_reg(priv);
+
+		if (OPMODE & WIFI_AP_STATE)
+			RTL_W32(RXERR_RPT, RXERR_RPT_RST);
 	}
 #endif
 	{
@@ -7206,10 +7940,22 @@ void start_clnt_ss(struct rtl8192cd_priv *priv)
 				else
 #endif
 				{
-					if (priv->ss_ssidlen == 0)
-						issue_probereq(priv, NULL, 0, NULL);
-					else
+					if (priv->ss_ssidlen == 0){
+
+#ifdef P2P_SUPPORT						
+						if( OPMODE&WIFI_P2P_SUPPORT && 
+							((P2PMODE==P2P_DEVICE)||(P2PMODE==P2P_CLIENT)) ){
+							//P2P_DEBUG("p2p scan (chann:%d)\n",priv->site_survey.ss_channel);
+							issue_probereq(priv, "DIRECT-", 7, NULL);
+						}else
+#endif
+						{
+							issue_probereq(priv, NULL, 0, NULL);
+						}
+				
+					}else{
 						issue_probereq(priv, priv->ss_ssid, priv->ss_ssidlen, NULL);
+					}
 				}
 			}
 		}
@@ -7229,16 +7975,23 @@ void start_clnt_ss(struct rtl8192cd_priv *priv)
 		(((priv->site_survey.ss_channel >= 52) &&
 		(priv->site_survey.ss_channel <= 64)) || 
 		((priv->site_survey.ss_channel >= 100) &&
-		(priv->site_survey.ss_channel <= 140))))
+		(priv->site_survey.ss_channel <= 140)))){
 		mod_timer(&priv->ss_timer, jiffies + SS_PSSV_TO
 		#ifdef CONFIG_RTK_MESH //GANTOE for site survey 2008/12/25
 			+ ( flags ) // for the deafness problem
 		#endif
 		);
-	else
+	}else
+#endif
+#ifdef P2P_SUPPORT
+	if(OPMODE&WIFI_P2P_SUPPORT && P2P_STATE == P2P_S_SEARCH){
+		/*search phase (only 1,6,11) use 120ms*/
+		P2P_DEBUG("120ms\n");
+		mod_timer(&priv->ss_timer, jiffies + SS_PSSV_TO);
+	}else
 #endif
 	{
-#if defined(CONFIG_RTL_NEW_AUTOCH)
+#ifdef CONFIG_RTL_NEW_AUTOCH
 	if (priv->auto_channel == 1)
 		mod_timer(&priv->ss_timer, jiffies + SS_AUTO_CHNL_TO
 #ifdef CONFIG_RTK_MESH 		//GANTOE for site survey 2008/12/25
@@ -7405,15 +8158,77 @@ void rtl8192cd_ss_timer(unsigned long task_priv)
 		if (priv->site_survey.ss_channel == priv->available_chnl[idx])
 			break;
 
-#if defined(CONFIG_RTL_NEW_AUTOCH)
+#ifdef CONFIG_RTL_NEW_AUTOCH
 	if (priv->auto_channel == 1) {
-		hold_CCA_FA_counter(priv);
-		_FA_statistic(priv);
+		unsigned int ofdm_ok, cck_ok, ht_ok;
+
+		if (!priv->site_survey.to_scan_40M) {
+			hold_CCA_FA_counter(priv);
+			_FA_statistic(priv);
+#ifdef INTERFERENCE_CONTROL
+			priv->chnl_ss_fa_count[idx] = priv->pshare->FA_total_cnt;
+#else
+			priv->chnl_ss_fa_count[idx] = priv->pshare->FA_total_cnt + RTL_R16(0xcf0) + RTL_R16(0xcf2);
+#endif
+			priv->chnl_ss_cca_count[idx] = ((RTL_R8(0xa60)<<8)|RTL_R8(0xa61)) + RTL_R16(0xda0);
+
+			release_CCA_FA_counter(priv);
+		}
+
+		RTL_W32(RXERR_RPT, 0 << RXERR_RPT_SEL_SHIFT);
+		ofdm_ok = RTL_R16(RXERR_RPT);
 
-		priv->chnl_ss_fa_count[idx] = priv->pshare->FA_total_cnt;
-		priv->chnl_ss_cca_count[idx] = ((RTL_R8(0xa60)<<8)|RTL_R8(0xa61)) + RTL_R16(0xda0);
-		release_CCA_FA_counter(priv);
+		RTL_W32(RXERR_RPT, 3 << RXERR_RPT_SEL_SHIFT);
+		cck_ok = RTL_R16(RXERR_RPT);
 
+		RTL_W32(RXERR_RPT, 6 << RXERR_RPT_SEL_SHIFT);
+		ht_ok = RTL_R16(RXERR_RPT);
+
+		RTL_W32(RXERR_RPT, RXERR_RPT_RST);
+
+		if (priv->site_survey.to_scan_40M) {
+			unsigned int z=0, ch_begin=0, ch_end=priv->available_chnl_num, 
+				current_ch = PHY_QueryRFReg(priv, RF92CD_PATH_A, 0x18, 0xff, 1);
+			int idx_2G_end=-1;
+#ifdef CONFIG_RTL_92D_SUPPORT
+			int idx_5G_begin=-1;
+			if (priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_5G) {
+				for (z=0; z<priv->available_chnl_num; z++) {
+					if (priv->available_chnl[z] > 14) {
+						idx_5G_begin = z;
+						break;
+					}
+				}
+				if (idx_5G_begin >= 0) 
+					ch_begin = idx_5G_begin;
+
+				for (z=ch_begin; z < ch_end; z++) {
+					if ((priv->available_chnl[z] == (current_ch+2)) || (priv->available_chnl[z] == (current_ch-2))) {
+						priv->chnl_ss_mac_rx_count_40M[z] = ofdm_ok + cck_ok + ht_ok;
+					}
+				}
+			} else
+#endif
+			{
+				for (z=0; z<priv->available_chnl_num; z++) {
+					if (priv->available_chnl[z] <= 14)
+						idx_2G_end = z;
+					else
+						break;
+				}
+				if (idx_2G_end >= 0) 
+					ch_end = idx_2G_end+1;
+
+				for (z=ch_begin; z < ch_end; z++) {
+					if (priv->available_chnl[z] == current_ch) {
+						priv->chnl_ss_mac_rx_count_40M[z] = ofdm_ok + cck_ok + ht_ok;
+						break;
+					}
+				}
+			}
+		} else {
+			priv->chnl_ss_mac_rx_count[idx] = ofdm_ok + cck_ok + ht_ok;
+		}
 	}
 #endif
 
@@ -7430,10 +8245,30 @@ void rtl8192cd_ss_timer(unsigned long task_priv)
 //--------------------------- 2007-04-14
 
 		priv->site_survey.ss_channel = priv->available_chnl[idx+1];
+
+#ifdef CONFIG_RTL_NEW_AUTOCH
+		if ((priv->auto_channel == 1) && priv->site_survey.to_scan_40M) {
+#ifdef CONFIG_RTL_92D_SUPPORT
+			if (priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_5G) {
+				unsigned int current_ch = PHY_QueryRFReg(priv, RF92CD_PATH_A, 0x18, 0xff, 1);
+
+				if (((priv->site_survey.ss_channel+2) == current_ch) || ((priv->site_survey.ss_channel-2) == current_ch)) {
+					if ((idx+2) >= (priv->available_chnl_num - 1))
+						loop_finish = 1;
+					else
+						priv->site_survey.ss_channel = priv->available_chnl[idx+2];
+				}
+			} else
+#endif
+			{
+				if (priv->site_survey.ss_channel == 14)
+					loop_finish = 1;
+			}
+		}
+#endif
 	}
 
-	if (loop_finish)
-	{
+	if (loop_finish) {
 		priv->site_survey_times++;		
 #ifdef SIMPLE_CH_UNI_PROTOCOL
 		if(GET_MIB(priv)->dot1180211sInfo.mesh_enable && (priv->auto_channel & 0x30) )
@@ -7469,8 +8304,7 @@ void rtl8192cd_ss_timer(unsigned long task_priv)
 
 // only do multiple scan when site-survey request, david+2006-01-25
 //		if (priv->site_survey_times < SS_COUNT)
-		if (priv->ss_req_ongoing && priv->site_survey_times < SS_COUNT)
-		{
+		if (priv->ss_req_ongoing && priv->site_survey_times < SS_COUNT) {
 // mark by david ---------------------
 #if 0
 			// scan again
@@ -7482,8 +8316,51 @@ void rtl8192cd_ss_timer(unsigned long task_priv)
 			priv->site_survey.ss_channel = priv->available_chnl[0];
 
 		}
-		else
-		{
+#ifdef CONFIG_RTL_NEW_AUTOCH
+		else if ((priv->auto_channel == 1) && !priv->site_survey.to_scan_40M) {
+			unsigned int z=0, ch_begin=0, ch_end=priv->available_chnl_num;
+			int idx_2G_end=-1;
+#ifdef CONFIG_RTL_92D_SUPPORT
+			int idx_5G_begin=-1;
+			if (priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_5G) {
+				for (z=0; z<priv->available_chnl_num; z++) {
+					if (priv->available_chnl[z] > 14) {
+						idx_5G_begin = z;
+						break;
+					}
+				}
+				if (idx_5G_begin < 0) 
+					goto skip_40M_ss;
+			} else 
+#endif
+			{
+				for (z=0; z<priv->available_chnl_num; z++) {
+					if (priv->available_chnl[z] < 14)
+						idx_2G_end = z;
+					else
+						break;
+				}
+				if (idx_2G_end >= 0) 
+					ch_end = idx_2G_end+1;
+
+				for (z=ch_begin; z < ch_end; z++)
+					if ((priv->available_chnl[z] >= 5) && (priv->available_chnl[z] < 14))
+						break;
+				if (z == ch_end)
+					goto skip_40M_ss;
+			}
+
+			priv->site_survey.to_scan_40M++;
+			priv->site_survey.ss_channel = priv->available_chnl[z];
+			priv->site_survey_times = 0;
+			priv->pshare->CurrentChannelBW = HT_CHANNEL_WIDTH_20_40;
+		}
+#endif
+		else {
+#ifdef CONFIG_RTL_NEW_AUTOCH
+skip_40M_ss:
+			priv->site_survey.to_scan_40M = 0;
+#endif
 			// scan end			
 			OPMODE &= ~WIFI_SITE_MONITOR;
 #if defined(CONFIG_RTL_92D_SUPPORT) && defined(CONFIG_RTL_NOISE_CONTROL)
@@ -7513,7 +8390,7 @@ void rtl8192cd_ss_timer(unsigned long task_priv)
 
 			
 			DIG_for_site_survey(priv, FALSE);
-#ifdef TESTCHIP_SUPPORT
+#if defined(TESTCHIP_SUPPORT) && defined(CONFIG_RTL_92C_SUPPORT)
 		if( IS_TEST_CHIP(priv) ) {
 				if ((OPMODE & WIFI_STATION_STATE) || (OPMODE & WIFI_ADHOC_STATE)) {
 #ifdef UNIVERSAL_REPEATER
@@ -7683,8 +8560,17 @@ void rtl8192cd_ss_timer(unsigned long task_priv)
 			}
 			// backup the bss database
 			else if (priv->ss_req_ongoing) {
-				priv->site_survey.count_backup = priv->site_survey.count;
-				memcpy(priv->site_survey.bss_backup, priv->site_survey.bss, sizeof(struct bss_desc)*priv->site_survey.count);
+#ifdef P2P_SUPPORT
+				if((OPMODE&WIFI_P2P_SUPPORT)
+					&& P2P_DISCOVERY){
+					//for keep  priv->site_survey.count_backup when P2P discovery
+				}
+				else
+#endif
+				{
+					priv->site_survey.count_backup = priv->site_survey.count;
+					memcpy(priv->site_survey.bss_backup, priv->site_survey.bss, sizeof(struct bss_desc)*priv->site_survey.count);
+				}				
 #ifdef WIFI_SIMPLE_CONFIG
 				memcpy(priv->site_survey.ie_backup, priv->site_survey.ie, sizeof(struct wps_ie_info)*priv->site_survey.count);
 #endif
@@ -7702,9 +8588,27 @@ void rtl8192cd_ss_timer(unsigned long task_priv)
 				}
 				else if (priv->join_res == STATE_Sta_Roaming_Scan)
 					start_clnt_lookup(priv, 1);
-				else
+				else if(priv->join_res == STATE_Sta_No_Bss) {
+					priv->join_res = STATE_Sta_Roaming_Scan;
+					start_clnt_lookup(priv, 1);
+				}
 					;
 #endif
+
+#ifdef SMART_REPEATER_MODE
+				if (priv->ss_req_ongoing == 3) {
+					SSID2SCAN_LEN = GET_MIB(GET_VXD_PRIV(priv))->dot11StationConfigEntry.dot11SSIDtoScanLen;
+					memcpy(SSID2SCAN, GET_MIB(GET_VXD_PRIV(priv))->dot11StationConfigEntry.dot11SSIDtoScan, SSID2SCAN_LEN);
+
+					priv->site_survey.count_target = priv->site_survey.count;
+					memcpy(priv->site_survey.bss_target, priv->site_survey.bss, sizeof(struct bss_desc)*priv->site_survey.count);					
+					priv->join_index = -1;
+					start_clnt_lookup(priv, 0);			
+				
+					mod_timer(&priv->pshare->check_vxd_ap, jiffies + CHECK_VXD_AP_TIMEOUT);
+				}
+#endif			
+
 				priv->ss_req_ongoing = 0;
 
 #ifdef WIFI_WPAS
@@ -7734,6 +8638,9 @@ void rtl8192cd_ss_timer(unsigned long task_priv)
 #ifdef CHECK_BEACON_HANGUP
 			priv->pshare->beacon_wait_cnt = 2;
 #endif
+#ifdef CONFIG_RTL8672
+			OPMODE &= (~WIFI_WAIT_FOR_CHANNEL_SELECT);
+#endif
 			SMP_UNLOCK(flags);
 			return;
 		}
@@ -7743,6 +8650,10 @@ void rtl8192cd_ss_timer(unsigned long task_priv)
 	if (IS_ROOT_INTERFACE(priv))
 #endif
 	{
+#ifdef CONFIG_RTL_92D_SUPPORT
+		int band_switch = 0;
+#endif
+	
 	// now, change RF channel...
 #ifdef DFS
 		if (!priv->pmib->dot11DFSEntry.disable_DFS) {
@@ -7754,16 +8665,43 @@ void rtl8192cd_ss_timer(unsigned long task_priv)
 #endif
 #if defined(CONFIG_RTL_92D_SUPPORT) && !defined(CONFIG_RTL_DUAL_PCIESLOT_BIWLAN_D)
 		if ((GET_CHIP_VER(priv) == VERSION_8192D) && priv->pmib->dot11RFEntry.macPhyMode==SINGLEMAC_SINGLEPHY) {
-			clnt_ss_check_band(priv, priv->site_survey.ss_channel); 
+			band_switch = clnt_ss_check_band(priv, priv->site_survey.ss_channel);		
 		}
 #endif
 
-		SwChnl(priv, priv->site_survey.ss_channel, priv->pshare->offset_2nd_chan);
-#if defined(CONFIG_RTL_NEW_AUTOCH)
-		if (priv->auto_channel == 1) {
-			reset_FA_reg(priv);
-		}
+#ifdef CONFIG_RTL_NEW_AUTOCH
+		if (priv->site_survey.to_scan_40M) {
+#ifdef CONFIG_RTL_92D_SUPPORT
+			if (priv->pmib->dot11RFEntry.phyBandSelect & PHY_BAND_5G) {
+				if( (priv->site_survey.ss_channel>140) ? ((priv->site_survey.ss_channel-1)%8) : (priv->site_survey.ss_channel%8)) {
+					SwChnl(priv, priv->site_survey.ss_channel, HT_2NDCH_OFFSET_ABOVE);
+					SwBWMode(priv, priv->pshare->CurrentChannelBW, HT_2NDCH_OFFSET_ABOVE);
+				} else {
+					SwChnl(priv, priv->site_survey.ss_channel, HT_2NDCH_OFFSET_BELOW);
+					SwBWMode(priv, priv->pshare->CurrentChannelBW, HT_2NDCH_OFFSET_BELOW);
+				}
+
+			} else
+#endif
+			{
+				/* set channel >= 5 for algo requirement */
+				SwChnl(priv, priv->site_survey.ss_channel, HT_2NDCH_OFFSET_BELOW);
+				SwBWMode(priv, priv->pshare->CurrentChannelBW, HT_2NDCH_OFFSET_BELOW);
+			}
+		} else
 #endif
+		{
+			SwChnl(priv, priv->site_survey.ss_channel, priv->pshare->offset_2nd_chan);
+#ifdef CONFIG_RTL_92D_SUPPORT
+			if ((GET_CHIP_VER(priv) == VERSION_8192D) && 
+					(priv->pmib->dot11RFEntry.macPhyMode == SINGLEMAC_SINGLEPHY) && band_switch)
+				PHY_IQCalibrate(priv);
+#endif
+#ifdef CONFIG_RTL_NEW_AUTOCH
+			if (priv->auto_channel == 1)
+				reset_FA_reg(priv);
+#endif
+		}
 	}
 
 	{
@@ -7791,14 +8729,24 @@ void rtl8192cd_ss_timer(unsigned long task_priv)
 				else
 #endif				
 				// issue probe_req here...
-				if (priv->ss_ssidlen == 0)
-					issue_probereq(priv, NULL, 0, NULL);
-				else
+				if (priv->ss_ssidlen == 0){
+
+#ifdef P2P_SUPPORT
+						if( OPMODE&WIFI_P2P_SUPPORT && 
+							((P2PMODE==P2P_DEVICE)||(P2PMODE==P2P_CLIENT)) ){
+							//P2P_DEBUG("p2p scan (chann:%d)\n",priv->site_survey.ss_channel);							
+							issue_probereq(priv, "DIRECT-", 7, NULL);
+						}else
+#endif					
+						{
+							issue_probereq(priv, NULL, 0, NULL);
+						}
+				}else{
 					issue_probereq(priv, priv->ss_ssid, priv->ss_ssidlen, NULL);
+				}
 			}
 		}
 	}
-
 	SMP_UNLOCK(flags);
 
 	// now, start another timer again.
@@ -7812,7 +8760,7 @@ void rtl8192cd_ss_timer(unsigned long task_priv)
 	else
 #endif
 	{
-#if defined(CONFIG_RTL_NEW_AUTOCH)
+#ifdef CONFIG_RTL_NEW_AUTOCH
 		if (priv->auto_channel == 1) 
 			mod_timer(&priv->ss_timer, jiffies + SS_AUTO_CHNL_TO);
 		else 
@@ -8017,13 +8965,245 @@ next_id_wapi:
 			debug_out("WSC_IE",priv->site_survey.ie[index].data,totallen);									
 		}		
 		*/
-		
 	}
+
 #endif
 /* WPS2DOTX*/
 }
 
+#ifdef P2P_SUPPORT
+int p2p_collect_bss_info(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinfo)
+{
+
+	int index ;
+	int len;
+	unsigned char  *pframe, *sa, channel_tmp;
+	int role;		
+	int idx=0;
+	int exist=0;	
+	unsigned char *ptmp=NULL;
+	unsigned char *SsidPtr=NULL;
+	int ssidlen = 0;
+
+	/* p2p IE must support fragment and reassembly ;
+		this method is sample for support reassembly*/  
+	static	unsigned char ReAssem_p2pie[MAX_REASSEM_P2P_IE];
+	static	unsigned char ReAssem_wscie[MAX_REASSEM_P2P_IE];		
+
+	int IEfoundtimes = 0 ;
+	unsigned char *p2pIEPtr = ReAssem_p2pie ;
+	int p2pIElen=0;
+	
+	unsigned char *wscIEPtr = ReAssem_wscie ;
+	int wscIElen=0;	
+
+	struct device_info_s p2p_devic_info;
+	memset(&p2p_devic_info,0,sizeof(struct device_info_s));
+	
+	pframe = get_pframe(pfrinfo);
+	sa = GetAddr2Ptr(pframe);
+
+	if (priv->site_survey.count >= MAX_BSS_NUM){
+		P2P_DEBUG("bss count > MAX_BSS_NUM!!!\n");
+		return 0;
+	}
+
+	/* chk DA is broadcast or my p2p device-addr (default use MY-HW-ADDR as p2p device addrree)*/
+	if( memcmp(GetAddr1Ptr(pframe), "\xff\xff\xff\xff\xff\xff", 6) 
+		&& memcmp(GetAddr1Ptr(pframe), GET_MY_HWADDR, 6))
+	{
+		P2P_DEBUG("DA mismatch!\n");
+		return 0;
+	}
+
+	
+	/*get SSID*/ 
+	SsidPtr = get_ie(pframe + WLAN_HDR_A3_LEN + _PROBERSP_IE_OFFSET_, _SSID_IE_, &ssidlen,
+	pfrinfo->pktlen - WLAN_HDR_A3_LEN - _PROBERSP_IE_OFFSET_);
+		
+
+	/* chk ssid == wildcard SSID ("DIRECT-")*/ 
+	if(SsidPtr 
+		&&	(*(SsidPtr+2) == 'D' ) && (*(SsidPtr+3) == 'I' ) 
+		&&	(*(SsidPtr+4) == 'R')&&	(*(SsidPtr+5) == 'E')
+		&&	(*(SsidPtr+6) == 'C')&&	(*(SsidPtr+7) == 'T')
+		&&	(*(SsidPtr+8) == '-'))
+	{
+		P2P_DEBUG("device: %02x%02x%02x:%02x%02x%02x\n" ,
+			sa[0],sa[1],sa[2],sa[3],sa[4],sa[5]);					
+		
+	}else{	
+		return 0;
+	}
+
+
+	/*----------------------------find P2P IE -----------------------------------start*/
+
+	/*  Get P2P IE from Probe_RSP */
+	IEfoundtimes = 0;
+	len = 0 ;	
+	ptmp = pframe + WLAN_HDR_A3_LEN + _PROBERSP_IE_OFFSET_ ;			
+
+	/*support ReAssemble*/	
+	for (;;)
+	{
+		ptmp = get_ie(ptmp, _P2P_IE_, &len,	
+			pfrinfo->pktlen - WLAN_HDR_A3_LEN - _PROBERSP_IE_OFFSET_ - len);			
+	
+		if (ptmp) {
+			if (!memcmp(ptmp+2, WFA_OUI_PLUS_TYPE, 4)) {
+				IEfoundtimes ++;
+				memcpy(p2pIEPtr , ptmp+6 ,len-4);
+				p2pIEPtr+= (len-4);
+			}
+
+		}
+		else{
+			break;
+		}
+		ptmp = ptmp + len + 2;
+		
+	}
+
+
+			
+	if(IEfoundtimes){
+		if(IEfoundtimes>1){
+			P2P_DEBUG("ReAssembly p2p IE\n");
+		}
+		p2pIElen = (int)(((unsigned long)p2pIEPtr)-((unsigned long)ReAssem_p2pie));		
+		if(p2pIElen > MAX_REASSEM_P2P_IE){
+			P2P_DEBUG("\n\n	ReAssem WSC IE exceed MAX_REASSEM_P2P_IE , chk!!!\n\n");
+			return 0;
+		}
+		
+	}else{
+		return 0;
+	}	
+	/*----------------------------find P2P IE -----------------------------------end*/
+
+
+	/*----------------------------find WSC IE -----------------------------------start*/
+
+	/*  Get WSC IE from Probe Rsp */
+	IEfoundtimes = 0;
+	len = 0;
+
+	ptmp = pframe + WLAN_HDR_A3_LEN + _PROBERSP_IE_OFFSET_ ;
+	for (;;)
+	{
+		ptmp = get_ie(ptmp, _WPS_IE_, &len,	
+			pfrinfo->pktlen - WLAN_HDR_A3_LEN - _PROBERSP_IE_OFFSET_ - len);			
+	
+		if (ptmp) {
+			if (!memcmp(ptmp+2, WSC_IE_OUI, 4)) {
+
+				IEfoundtimes ++;
+				memcpy(wscIEPtr , ptmp+6 ,len-4);
+				wscIEPtr+= (len-4);
+			}
+		}
+		else{
+			break;
+		}
+		ptmp = ptmp + len + 2;
+		
+	}
+
+	if(IEfoundtimes){
+		wscIElen = (int)(((unsigned long)wscIEPtr)-((unsigned long)ReAssem_wscie));
+
+		if(IEfoundtimes>1){
+			P2P_DEBUG("ReAssembly WSC IE\n");
+		}
+
+		if(wscIElen > MAX_REASSEM_P2P_IE){
+			P2P_DEBUG("\n\n	ReAssem WSC IE exceed MAX_REASSEM_P2P_IE , chk!!!\n\n");
+			return 0;			
+		}		
+		
+	}else{
+		P2P_DEBUG("no found wsc IE \n");					
+		return 0 ;
+	}	
+	/*----------------------------find wsc IE -----------------------------------end*/
+
+
+	/*--- record rx form which channel from _DSSET_IE_ for later use---*/	
+	ptmp = get_ie(pframe + WLAN_HDR_A3_LEN + _PROBERSP_IE_OFFSET_, _DSSET_IE_, &len,
+		pfrinfo->pktlen - WLAN_HDR_A3_LEN - _PROBERSP_IE_OFFSET_);
+
+	
+	if (ptmp != NULL){
+		channel_tmp = *(ptmp+2);
+	}else{
+		channel_tmp = priv->site_survey.ss_channel;	
+	}	
+	/*--- record rx form which channel from _DSSET_IE_ for later use---*/	
+
+
+	
+	/*-----chk target is GO or device-----*/
+	//p2pIEPtr = ReAssem_p2pie;
+	role = p2p_get_role(priv,ReAssem_p2pie,p2pIElen);
+	
+	if(role == R_P2P_DEVICE){  
+
+		p2p_get_device_info(priv,ReAssem_p2pie,p2pIElen,&p2p_devic_info);
+		
+	}
+	else if(role == R_P2P_GO){
+
+			if(p2p_get_GO_p2p_info(priv,ReAssem_p2pie,p2pIElen,&p2p_devic_info)==FAIL){
+				/*no include device addr in P2P IE*/ 
+				memcpy(p2p_devic_info.dev_address , pfrinfo->sa ,6);
+			}
+			
+			p2p_get_GO_wsc_info(priv,ReAssem_wscie,wscIElen,&p2p_devic_info);				
+	}
+	/*-----chk target is GO or device-----*/
+	
+	
+	/*---find free site_survey bss---*/
+	if(priv->site_survey.count_backup==0){
+		index=0;
+		priv->site_survey.count_backup++;
+	}else{
+		// search if exist
+		for(idx=0  ; idx<priv->site_survey.count_backup ; idx++){
+			if(!memcmp(priv->site_survey.bss_backup[idx].p2paddress
+				,p2p_devic_info.dev_address ,6))
+			{
+				exist=1;
+				index = idx;
+				break;
+			}
+		}
+		if(exist==0){
+			index = idx;
+			priv->site_survey.count_backup++;
+		}
+	}
+
+	// now recored this bss info
+	priv->site_survey.bss_backup[index].channel = channel_tmp ;
+	priv->site_survey.bss_backup[index].p2prole = role;		
+	
+	memcpy(priv->site_survey.bss_backup[index].p2paddress,p2p_devic_info.dev_address ,6);
+	//memcpy(priv->site_survey.bss_backup[index].p2pdevname , p2p_devic_info.devname ,33);	
+	strcpy(priv->site_survey.bss_backup[index].p2pdevname , p2p_devic_info.devname);	
+	priv->site_survey.bss_backup[index].p2pwscconfig = p2p_devic_info.config_method;		
+
+	if(role == R_P2P_GO){
+		memcpy(priv->site_survey.bss_backup[index].ssid , SsidPtr+2	, ssidlen);	
+		priv->site_survey.bss_backup[index].ssid[ssidlen]='\0';
+		//P2P_DEBUG("ssid=%s\n",priv->site_survey.bss_backup[index].ssid);
+	}
+	
+	return SUCCESS;
+}
 
+#endif
 /**
  *	@brief	After site survey, collect BSS information to site_survey.bss[index]
  *
@@ -8042,6 +9222,14 @@ int collect_bss_info(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinfo)
 	DOT11_WPA2_MULTICAST_CIPHER wpa2MulticastCipher;
 	unsigned char OUI2[] = {0x00, 0x0f, 0xac};
 
+#ifdef P2P_SUPPORT
+	static	unsigned char ReAssem_p2pie[MAX_REASSEM_P2P_IE];
+	int IEfoundtimes=0;
+	unsigned char *p2pIEPtr = ReAssem_p2pie ;
+	int p2pIElen=0;
+#endif
+
+	
 	pframe = get_pframe(pfrinfo);
 #ifdef CONFIG_RTK_MESH
 // GANTOE for site survey 2008/12/25 ====
@@ -8073,7 +9261,7 @@ int collect_bss_info(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinfo)
 					pfrinfo->pktlen - WLAN_HDR_A3_LEN - _BEACON_IE_OFFSET_);
 				if (p != NULL)
 					channel = *(p+2);
-				if (channel) {
+				if (channel && (channel <= 14)) {
 					priv->bg_ap_timeout = 180;
 					priv->bg_ap_timeout_ch[channel-1] = 180;
 					channel = 0;
@@ -8102,17 +9290,48 @@ int collect_bss_info(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinfo)
 	if (p != NULL)
 		channel = *(p+2);
 	else {
-			p = get_ie(pframe + WLAN_HDR_A3_LEN + _BEACON_IE_OFFSET_, _HT_IE_, &len,
-					pfrinfo->pktlen - WLAN_HDR_A3_LEN - _BEACON_IE_OFFSET_);
-			if (p !=  NULL) 
-				channel = *(p+2);
-			else
+		p = get_ie(pframe + WLAN_HDR_A3_LEN + _BEACON_IE_OFFSET_, _HT_IE_, &len,
+			pfrinfo->pktlen - WLAN_HDR_A3_LEN - _BEACON_IE_OFFSET_);
+		if (p !=  NULL) 
+			channel = *(p+2);
+		else {
+			if (priv->site_survey.ss_channel > 14)
 				channel = priv->site_survey.ss_channel;	
+			else {
+				DEBUG_INFO("Beacon/Probe rsp doesn't carry channel info\n");
+				return SUCCESS;
+			}
+		}
 	}
 
-	for(i=0; i<priv->site_survey.count; i++)
-	{
+	for(i=0; i<priv->site_survey.count; i++) {
 		if (!memcmp((void *)addr, priv->site_survey.bss[i].bssid, MACADDRLEN)) {
+#if defined(CLIENT_MODE) && defined(WIFI_WMM) && defined(WMM_APSD)  //  WMM STA
+			if ((OPMODE & WIFI_STATION_STATE) && QOS_ENABLE && APSD_ENABLE 
+				&& (channel == priv->site_survey.bss[i].channel)) {  // get WMM IE / WMM Parameter IE
+				p = pframe + WLAN_HDR_A3_LEN + _BEACON_IE_OFFSET_;
+				for (;;) {
+					p = get_ie(p, _RSN_IE_1_, &len,
+						pfrinfo->pktlen - (p - pframe));
+					if (p != NULL) {
+						if (!memcmp(p+2, WMM_PARA_IE, 6)) {
+							priv->site_survey.bss[i].t_stamp[1] |= BIT(0);  //  set t_stamp[1] bit 0 when AP supports WMM
+
+							if (*(p+8) & BIT(7))
+								priv->site_survey.bss[i].t_stamp[1] |= BIT(3);  //  set t_stamp[1] bit 3 when AP supports UAPSD
+							else
+								priv->site_survey.bss[i].t_stamp[1] &= ~(BIT(3));  //  reset t_stamp[1] bit 3 when AP not support UAPSD
+							break;
+						}
+					} else {
+						priv->site_survey.bss[i].t_stamp[1] &= ~(BIT(0)|BIT(3));  //  reset t_stamp[1] bit 0 when AP not support WMM & UAPSD
+						break;
+					}
+					p = p + len + 2;
+				}
+			}
+#endif
+
 			if ((unsigned char)pfrinfo->rssi > priv->site_survey.bss[i].rssi) {
 				priv->site_survey.bss[i].rssi = (unsigned char)pfrinfo->rssi;
 #ifdef WIFI_SIMPLE_CONFIG
@@ -8265,14 +9484,65 @@ int collect_bss_info(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinfo)
 
 	if (channel <= 14)
 	{
-		if (!(pmib->dot11BssType.net_work_type & WIRELESS_11B))
-			if (((basicrate & 0xff0) == 0) && ((supportrate & 0xff0) == 0))
+#ifdef P2P_SUPPORT
+		if((OPMODE&WIFI_P2P_SUPPORT)){
+			/*under P2P mode allow no support B rate*/ 
+		}
+		else
+#endif
+		if (!(pmib->dot11BssType.net_work_type & WIRELESS_11B)){
+			if (((basicrate & 0xff0) == 0) && ((supportrate & 0xff0) == 0)){
 				return 0;
+			}
+		}
 
-		if (!(pmib->dot11BssType.net_work_type & WIRELESS_11G))
-			if (((basicrate & 0xf) == 0) && ((supportrate & 0xf) == 0))
+		if (!(pmib->dot11BssType.net_work_type & WIRELESS_11G)){
+			if (((basicrate & 0xf) == 0) && ((supportrate & 0xf) == 0)){
 				return 0;
+			}
+		}
 	}
+#ifdef P2P_SUPPORT	
+	p = pframe + WLAN_HDR_A3_LEN + _BEACON_IE_OFFSET_ ;
+
+	/*support ReAssemble*/	
+	for (;;){
+		
+		p = get_ie(p, _P2P_IE_, &len,	
+			pfrinfo->pktlen - WLAN_HDR_A3_LEN - _BEACON_IE_OFFSET_ - len);				
+		if (p) {
+			if (!memcmp(p+2, WFA_OUI_PLUS_TYPE, 4)) {
+				IEfoundtimes ++;
+				memcpy(p2pIEPtr , p+2+4 ,len-4);
+				p2pIEPtr+= (len-4);				
+			}
+		}
+		else{
+			break;
+		}
+		p = p + len + 2;
+		
+	}
+
+	if(IEfoundtimes){
+		if(IEfoundtimes>1){
+			P2P_DEBUG("ReAssembly p2p IE\n");
+		}		
+		p2pIElen = (int)(((unsigned long)p2pIEPtr)-((unsigned long)ReAssem_p2pie));		
+
+		if(p2pIElen > MAX_REASSEM_P2P_IE){
+			P2P_DEBUG("\n\n	reassemble P2P IE exceed MAX_REASSEM_P2P_IE , chk!!!\n\n");
+			return 0;			
+		}else{
+			/*if target AP support management function ; skip it*/
+			if(P2P_filter_manage_ap(priv , ReAssem_p2pie , p2pIElen )){
+				return 0;
+			}
+		}
+	}
+	
+	
+#endif
 
 	/*
 	 * okay, recording this bss...
@@ -8519,11 +9789,27 @@ int collect_bss_info(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinfo)
 			if (p != NULL) {
 				if ((!memcmp(p+2, WMM_IE, 6)) || (!memcmp(p+2, WMM_PARA_IE, 6))) {
 					priv->site_survey.bss[index].t_stamp[1] |= BIT(0);  //  set t_stamp[1] bit 0 when AP supports WMM
-					break;
+#if defined(CLIENT_MODE) && defined(WMM_APSD)
+					if ((OPMODE & WIFI_STATION_STATE) && APSD_ENABLE) {
+						if (!memcmp(p+2, WMM_PARA_IE, 6)) {
+							if (*(p+8) & BIT(7))
+								priv->site_survey.bss[index].t_stamp[1] |= BIT(3);  //  set t_stamp[1] bit 3 when AP supports UAPSD
+							else
+								priv->site_survey.bss[index].t_stamp[1] &= ~(BIT(3));  //  reset t_stamp[1] bit 3 when AP not support UAPSD
+							break;
+						} else {
+							priv->site_survey.bss[index].t_stamp[1] &= ~(BIT(3));  //  reset t_stamp[1] bit 3 when AP not support UAPSD
+						}
+					} else
+#endif
+						break;
 				}
-			}
-			else {
+			} else {
 				priv->site_survey.bss[index].t_stamp[1] &= ~(BIT(0));  //  reset t_stamp[1] bit 0 when AP not support WMM
+#if defined(CLIENT_MODE) && defined(WMM_APSD)
+				if ((OPMODE & WIFI_STATION_STATE) && APSD_ENABLE)
+					priv->site_survey.bss[index].t_stamp[1] &= ~(BIT(3));  //  reset t_stamp[1] bit 3 when AP not support UAPSD
+#endif
 				break;
 			}
 			p = p + len + 2;
@@ -8771,6 +10057,12 @@ static unsigned int OnAssocReq(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 	unsigned int		status = _STATS_SUCCESSFUL_;
 	unsigned short		frame_type, ie_offset=0, val16;
 
+#ifdef P2P_SUPPORT
+	unsigned char ReAssem_p2pie[MAX_REASSEM_P2P_IE];
+	int IEfoundtimes;
+	unsigned char *p2pIEPtr = ReAssem_p2pie ;
+	int p2pIElen;
+#endif
 	pmib = GET_MIB(priv);
 	pframe = get_pframe(pfrinfo);
 	pstat = get_stainfo(priv, GetAddr2Ptr(pframe));
@@ -8826,6 +10118,21 @@ static unsigned int OnAssocReq(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 		goto OnAssocReqFail;
 	}
 
+#ifdef CONFIG_RTL_WLAN_DOS_FILTER
+	if (block_sta_time)
+	{
+		int i;
+		for (i=0; i<MAX_BLOCK_MAC;i++)
+		{
+			if (memcmp(pstat->hwaddr, block_mac[i], 6) == 0)
+			{
+				status = _STATS_OTHER_;
+				goto OnAssocReqFail;
+			}				
+		}
+	}
+#endif
+
 	/* Rate adpative algorithm */
 	if (pstat->check_init_tx_rate)
 		pstat->check_init_tx_rate = 0;
@@ -8886,7 +10193,14 @@ static unsigned int OnAssocReq(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 		}
 	}
 #endif
-#if 0
+#if 0	
+#ifdef P2P_SUPPORT
+	if((OPMODE & WIFI_P2P_SUPPORT)){
+
+	}
+	else
+#endif
+	{
 	if (check_basic_rate(priv, supportRate, supportRateNum) == FAIL) {		// check basic rate. jimmylin 2004/12/02
 		DEBUG_WARN("Rx a sta assoc-req which basic rates not match! %02X%02X%02X%02X%02X%02X\n",
 			pstat->hwaddr[0],pstat->hwaddr[1],pstat->hwaddr[2],pstat->hwaddr[3],pstat->hwaddr[4],pstat->hwaddr[5]);
@@ -8895,6 +10209,7 @@ static unsigned int OnAssocReq(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 			goto OnAssocReqFail;
 		}
 	}
+	}
 #endif
 	get_matched_rate(priv, supportRate, &supportRateNum, 0);
 	update_support_rate(pstat, supportRate, supportRateNum);
@@ -8918,6 +10233,16 @@ static unsigned int OnAssocReq(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 		goto OnAssocReqFail;
 
 	// now the station is qualified to join our BSS...
+#if defined(BR_SHORTCUT) && defined(RTL_CACHED_BR_STA)
+	{
+		extern unsigned char cached_br_sta_mac[MACADDRLEN];
+		extern struct net_device *cached_br_sta_dev;
+		if (!memcmp(GetAddr2Ptr(pframe), cached_br_sta_mac, MACADDRLEN)){
+			cached_br_sta_dev=NULL;
+			memset(cached_br_sta_mac,0,MACADDRLEN);
+		}
+	}
+#endif
 
 #ifdef WIFI_WMM
 	// check if there is WMM IE
@@ -8954,6 +10279,9 @@ static unsigned int OnAssocReq(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 	}
 #endif
 
+
+// ====2011-0926 ;roll back ; ht issue 
+#if 1
 	if (priv->pmib->dot11BssType.net_work_type & WIRELESS_11N) {
 		p = get_ie(pframe + WLAN_HDR_A3_LEN + ie_offset, _HT_CAP_, &len,
 				pfrinfo->pktlen - WLAN_HDR_A3_LEN - ie_offset);
@@ -9003,13 +10331,17 @@ static unsigned int OnAssocReq(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 				pstat->tx_bw = HT_CHANNEL_WIDTH_20_40;
 		}
 		else {
-			if (priv->pmib->dot11StationConfigEntry.legacySTADeny & WIRELESS_11G) {
-				DEBUG_ERR("Deny legacy STA association!\n");
-				status = _STATS_RATE_FAIL_;
-				goto OnAssocReqFail;
+			if(!priv->pmib->wscEntry.wsc_enable){
+				if (priv->pmib->dot11StationConfigEntry.legacySTADeny & WIRELESS_11G) {
+					DEBUG_ERR("Deny legacy STA association!\n");
+					status = _STATS_RATE_FAIL_;
+					goto OnAssocReqFail;
+				}
 			}
 		}
 	}
+#endif
+// ====2011-0926 ; ht issue
 
 #ifdef WIFI_WMM
 	if (QOS_ENABLE) {
@@ -9020,6 +10352,54 @@ static unsigned int OnAssocReq(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 	}
 #endif
 
+
+#ifdef P2P_SUPPORT	
+	if(OPMODE&WIFI_P2P_SUPPORT){
+		p = pframe + WLAN_HDR_A3_LEN + ie_offset ;
+		for (;;)
+		{
+			p = get_ie(p, _P2P_IE_, &len,	
+				pfrinfo->pktlen - WLAN_HDR_A3_LEN - ie_offset - len);				
+			if (p) {
+				if (!memcmp(p+2, WFA_OUI_PLUS_TYPE, 4)) {
+					IEfoundtimes ++;
+					memcpy(p2pIEPtr , p+6 ,len-4);
+					p2pIEPtr+= (len-4);				
+				}
+			}
+			else{
+				break;
+			}
+			p = p + len + 2;
+			
+		}
+
+		if(IEfoundtimes){
+			
+			if(IEfoundtimes>1){
+				P2P_DEBUG("ReAssembly p2p IE\n");
+			}		
+			p2pIElen = (int)(((unsigned long)p2pIEPtr)-((unsigned long)ReAssem_p2pie));		
+			
+			if(p2pIElen > MAX_REASSEM_P2P_IE){
+				P2P_DEBUG("\n\n	reassemble P2P IE exceed MAX_REASSEM_P2P_IE , chk!!!\n\n");
+			}else{
+				/*just start record GC's info when i am Real GO*/
+				if(P2PMODE == P2P_TMP_GO){
+					P2P_on_assoc_req(priv,ReAssem_p2pie,p2pIElen , pfrinfo->sa);
+					P2P_DEBUG("GC come from:\n");				
+					printMac(pfrinfo->sa);
+					p2p_debug_out("p2pie at assoc_req: ", ReAssem_p2pie, p2pIElen);
+					pstat->is_p2p_client = 1;
+
+				}
+			}
+		}
+	} 
+	
+#endif
+
+
 	// Realtek proprietary IE
 	p = pframe + WLAN_HDR_A3_LEN + ie_offset; len = 0;
 	for (;;)
@@ -9101,9 +10481,10 @@ static unsigned int OnAssocReq(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 		p = get_ie(p, _RSN_IE_1_, &len,
 			pfrinfo->pktlen - (p - pframe));
 		if (p != NULL) {
-			if (!memcmp(p+2, Ralink_OUI1, 3))
+			if (!memcmp(p+2, Ralink_OUI1, 3)) {
 				pstat->is_ralink_sta = TRUE;
 				break;
+			}
 		}
 		else
 			break;
@@ -9136,14 +10517,26 @@ static unsigned int OnAssocReq(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 		list_add_tail(&pstat->asoc_list, &priv->asoc_list);
 		//printk("wlan%d pstat->asoc_list = %p priv->asoc_list=%p\n",priv->pshare->wlandev_idx, pstat->asoc_list, priv->asoc_list);
 		cnt_assoc_num(priv, pstat, INCREASE, (char *)__FUNCTION__);
-		check_sta_characteristic(priv, pstat, INCREASE);
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv)!=VERSION_8188E) 
+#endif
+			check_sta_characteristic(priv, pstat, INCREASE);
 		if (priv->pmib->dot11BssType.net_work_type & WIRELESS_11N)
 			construct_ht_ie(priv, priv->pshare->is_40m_bw, priv->pshare->offset_2nd_chan);
 	}
 	RESTORE_INT(flags);
 
 	assign_tx_rate(priv, pstat, pfrinfo);
-	add_update_RATid(priv, pstat);
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv)==VERSION_8188E) {
+#ifdef TXREPORT
+		add_RATid(priv, pstat);
+#endif
+	} else
+#endif
+	{
+		add_update_RATid(priv, pstat);
+	}
 	assign_aggre_mthod(priv, pstat);
 	assign_aggre_size(priv, pstat);
 	
@@ -9262,14 +10655,26 @@ static unsigned int OnAssocReq(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 #endif
 
 #ifdef RTL_WPA2
-			if ((*(unsigned char *)p == _RSN_IE_1_) && (len >= 4) && (!memcmp((void *)(p + 2), (void *)rsnie_hdr, 4)))
+			if ((*(unsigned char *)p == _RSN_IE_1_) && (len >= 4) && (!memcmp((void *)(p + 2), (void *)rsnie_hdr, 4))) {
+#ifdef TLN_STATS
+				pstat->enterpise_wpa_info = STATS_ETP_WPA;
+#endif
 				break;
+}
 
-			if ((*(unsigned char *)p == _RSN_IE_2_) && (len >= 2) && (!memcmp((void *)(p + 2), (void *)rsnie_hdr_wpa2, 2)))
+			if ((*(unsigned char *)p == _RSN_IE_2_) && (len >= 2) && (!memcmp((void *)(p + 2), (void *)rsnie_hdr_wpa2, 2))) {
+#ifdef TLN_STATS
+				pstat->enterpise_wpa_info = STATS_ETP_WPA2;
+#endif
 				break;
+			}
 #else
-			if ((len >= 4) && (!memcmp((void *)(p + 2), (void *)rsnie_hdr, 4)))
+			if ((len >= 4) && (!memcmp((void *)(p + 2), (void *)rsnie_hdr, 4))) {
+#ifdef TLN_STATS
+				pstat->enterpise_wpa_info = STATS_ETP_WPA;
+#endif
 				break;
+			}
 #endif
 
 			p = p + len + 2;
@@ -9390,6 +10795,27 @@ static unsigned int OnAssocReq(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 /* WPS2DOTX   -end*/		
 #endif
 
+// ====2011-0926 ;roll back ; ht issue
+#if 1
+	if(priv->pmib->wscEntry.wsc_enable) {
+		if (!pstat->ht_cap_len && (priv->pmib->dot11StationConfigEntry.legacySTADeny & WIRELESS_11G)) {
+			DEBUG_ERR("Deny legacy STA association!\n");
+			status = _STATS_RATE_FAIL_;
+			SAVE_INT_AND_CLI(flags);
+			list_del_init(&pstat->asoc_list);
+			RESTORE_INT(flags);
+			cnt_assoc_num(priv, pstat, DECREASE, (char *)__FUNCTION__);
+#ifdef CONFIG_RTL_88E_SUPPORT
+			if (GET_CHIP_VER(priv)!=VERSION_8188E) 
+#endif
+				check_sta_characteristic(priv, pstat, DECREASE);
+			goto OnAssocReqFail;
+		}
+	}
+#endif
+// ====2011-0926 end
+
+
 	if ((priv->pmib->dot11BssType.net_work_type & WIRELESS_11N) &&
 		(pmib->dot1180211AuthEntry.dot11PrivacyAlgrthm != _NO_PRIVACY_))
 	{
@@ -9397,6 +10823,11 @@ static unsigned int OnAssocReq(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 		if 	((pmib->dot1180211AuthEntry.dot11PrivacyAlgrthm == _WEP_40_PRIVACY_) ||
 			 (pmib->dot1180211AuthEntry.dot11PrivacyAlgrthm == _WEP_104_PRIVACY_))
 			mask_mcs_rate = 2;
+#ifdef CONFIG_RTL_WAPI_SUPPORT	
+		else if(pmib->dot1180211AuthEntry.dot11PrivacyAlgrthm == _WAPI_SMS4_) {
+			mask_mcs_rate = 0;
+		}
+#endif
 		else {
 			if (p == NULL)
 				mask_mcs_rate = 1;
@@ -9417,7 +10848,16 @@ static unsigned int OnAssocReq(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 		if (mask_mcs_rate) {
 			pstat->is_legacy_encrpt = mask_mcs_rate;
 			assign_tx_rate(priv, pstat, pfrinfo);
-			add_update_RATid(priv, pstat);
+#ifdef CONFIG_RTL_88E_SUPPORT
+			if (GET_CHIP_VER(priv)==VERSION_8188E) {
+#ifdef TXREPORT
+				add_RATid(priv, pstat);
+#endif
+			} else
+#endif
+			{
+				add_update_RATid(priv, pstat);
+			}
 			assign_aggre_mthod(priv, pstat);
 		}
 	}
@@ -9640,10 +11080,23 @@ OnAssocReqSuccess:
 #endif
 			extern unsigned char cached_eth_addr[6];
 			extern struct net_device *cached_dev;
+
+#ifdef BR_SHORTCUT_C2
+			extern unsigned char cached_eth_addr2[6];
+			extern struct net_device *cached_dev2;
+#endif
+
 			if(memcmp(cached_eth_addr, GetAddr2Ptr(pframe), MACADDRLEN) == 0)
 				cached_dev = NULL;
+#ifdef BR_SHORTCUT_C2
+			else if(memcmp(cached_eth_addr2, GetAddr2Ptr(pframe), MACADDRLEN) == 0)
+				cached_dev2 = NULL;
+#endif
 		}
 #endif
+#if defined(CONFIG_RTL_FASTBRIDGE)
+		rtl_fb_del_entry(GetAddr2Ptr(pframe));
+#endif
 	}
 #endif // CONFIG_RTK_MESH && PU_STANDARD_SME
 
@@ -9717,12 +11170,34 @@ OnAssocReqFail:
 	return FAIL;
 }
 
-
+#ifdef P2P_SUPPORT
+int is_brate(unsigned char rrate)
+{
+	if(rrate==0x82 || rrate==0x84 ||  rrate==0x8b || rrate==0x96 )
+		return 1;
+	else
+		return 0;
+}
+#endif
 static unsigned int OnProbeReq(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinfo)
 {
 	struct wifi_mib	*pmib;
-	unsigned char	*pframe, *p;
+	unsigned char	*pframe;
+	unsigned char	*ssidptrx=NULL;
 	unsigned int	len;
+
+#ifdef P2P_SUPPORT
+	int idx=0;
+	int brateonly = 1;
+	static unsigned char ReAssem_p2pie[MAX_REASSEM_P2P_IE];
+
+	unsigned char *p2pIEPtr = ReAssem_p2pie ;	
+	int IEfoundtimes=0;
+	int p2pIElen=0;
+#endif
+
+
+	
 	unsigned char	*bssid;
 
 #ifdef WDS
@@ -9735,6 +11210,9 @@ static unsigned int OnProbeReq(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 	unsigned int foundtimes=0;		
 	int lenx =	0;
 	//WPS2DOTX
+#if	defined(WIFI_SIMPLE_CONFIG) || defined(P2P_SUPPORT)
+	unsigned char *ptmp;
+#endif		
 
 	bssid  = BSSID;
 	pmib   = GET_MIB(priv);
@@ -9743,12 +11221,23 @@ static unsigned int OnProbeReq(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 	if (!IS_DRV_OPEN(priv))
 		return FAIL;
 
-	if (!((OPMODE & WIFI_AP_STATE) || (OPMODE & WIFI_ADHOC_STATE))
+
+#ifdef P2P_SUPPORT
+		if((OPMODE&WIFI_P2P_SUPPORT) && 
+			((P2PMODE == P2P_DEVICE) && (P2P_STATE == P2P_S_LISTEN))){
+				/*allow (p2p device mode && under listen state) can process probe_req frame*/
+		}
+		else
+#endif
+		{	
+			if (!((OPMODE & WIFI_AP_STATE) || (OPMODE & WIFI_ADHOC_STATE))
 #ifdef MP_TEST
-		|| priv->pshare->rf_ft_var.mp_specific
+			|| priv->pshare->rf_ft_var.mp_specific
 #endif
-		)
-		return FAIL;
+			)
+				return FAIL;
+
+		}
 
 #ifdef WDS
 	if (pmib->dot11WdsInfo.wdsEnabled && pmib->dot11WdsInfo.wdsPure) {
@@ -9780,14 +11269,8 @@ static unsigned int OnProbeReq(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 		return OnProbeReq_MP(priv, pfrinfo);
 #endif
 
-	p = get_ie(pframe + WLAN_HDR_A3_LEN + _PROBEREQ_IE_OFFSET_, _SSID_IE_, (int *)&len,
-			pfrinfo->pktlen - WLAN_HDR_A3_LEN - _PROBEREQ_IE_OFFSET_);
-
-	if (p == NULL)
-		goto OnProbeReqFail;
 
 #ifdef WIFI_SIMPLE_CONFIG
-/* WPS2DOTX   */
 	if (priv->pmib->wscEntry.wsc_enable & 2) { // work as AP (not registrar)
 		unsigned char *ptmp;
 		unsigned int lentmp;
@@ -9816,17 +11299,127 @@ static unsigned int OnProbeReq(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 		}
 		if(foundtimes){
 			lenx = (int)(((unsigned long)awPtr)-((unsigned long)tmp_assem_wscie));	
-			wsc_forward_probe_request(priv, pframe, tmp_assem_wscie, lenx);
-			
-			//if(foundtimes>1)
-			//	debug_out("ReAss probe_Req wsc_ie ",tmp_assem_wscie,lenx);			
-			
+			if(foundtimes>1){
+				tmp_assem_wscie[1] = lenx-2;
+				//debug_out("ReAss probe_Req wsc_ie ",tmp_assem_wscie,lenx);					
+			}
+			wsc_forward_probe_request(priv, pframe, tmp_assem_wscie, lenx);						
 		}		
 	}
 /* WPS2DOTX   */	
 #endif
 
 
+
+
+
+
+#ifdef P2P_SUPPORT
+	if((OPMODE&WIFI_P2P_SUPPORT) 
+		&& (((P2PMODE == P2P_DEVICE) && (P2P_STATE == P2P_S_LISTEN))
+			  || (P2PMODE == P2P_TMP_GO )) )
+	{
+							
+		
+		/*chk SSID -start*/
+		ssidptrx = get_ie(pframe + WLAN_HDR_A3_LEN + _PROBEREQ_IE_OFFSET_, _SSID_IE_, (int *)&len,
+				pfrinfo->pktlen - WLAN_HDR_A3_LEN - _PROBEREQ_IE_OFFSET_);
+
+		if (ssidptrx == NULL){
+			//P2P_DEBUG("\n");		
+			goto OnProbeReqFail;	
+		}
+			
+		if( len==7 && (*(ssidptrx+2) == 'D' ) && (*(ssidptrx+3) == 'I' ) 
+			&&	(*(ssidptrx+4) == 'R')&&	(*(ssidptrx+5) == 'E')
+			&&	(*(ssidptrx+6) == 'C')&&	(*(ssidptrx+7) == 'T')
+			&&	(*(ssidptrx+8) == '-'))
+		{
+			//P2P_SME_P("chk (DIRECT-) ssid\n");
+		}else{
+
+			if((P2PMODE == P2P_DEVICE) && (P2P_STATE == P2P_S_LISTEN)){
+					//P2P_DEBUG("\n");			
+				goto OnProbeReqFail;		
+			}else if(P2PMODE == P2P_TMP_GO ){
+					//P2P_DEBUG("\n");		
+				goto normal_probe_req;
+			}
+		}
+
+		/*------chk if target include B rate only ------*/
+		ptmp = get_ie(pframe + WLAN_HDR_A3_LEN + _PROBEREQ_IE_OFFSET_,_SUPPORTEDRATES_IE_,
+			(int *)&len,pfrinfo->pktlen - WLAN_HDR_A3_LEN - _PROBEREQ_IE_OFFSET_);
+		if(ptmp){
+			for(idx=0;idx<len;idx++){
+				if(is_brate(ptmp[idx])==0){
+					brateonly = 0;
+					break;
+				}
+			}			
+		}
+		if((P2PMODE == P2P_DEVICE) && (P2P_STATE == P2P_S_LISTEN) && brateonly){
+			P2P_DEBUG("	...don't care b rate only device\n");
+			goto OnProbeReqFail; // don't care b rate only device
+		}
+
+
+		/*------chk include P2P IE ------*/
+		ptmp = pframe + WLAN_HDR_A3_LEN + _PROBEREQ_IE_OFFSET_;	
+		/*support ReAssemble*/
+		for (;;)
+		{
+			ptmp = get_ie(ptmp, _P2P_IE_, (int *)&len,
+				pfrinfo->pktlen - WLAN_HDR_A3_LEN - _PROBEREQ_IE_OFFSET_ - len);
+			if (ptmp != NULL) {
+				if (!memcmp(ptmp+2, WFA_OUI_PLUS_TYPE, 4)) {
+					IEfoundtimes ++;
+					memcpy(p2pIEPtr , ptmp+6 ,len-4);
+					p2pIEPtr+= (len-4);	
+				}
+			}
+			else{
+				break;
+			}
+			ptmp = ptmp + len + 2;
+			
+		}
+				
+		if(IEfoundtimes){
+			
+			if(IEfoundtimes>1){
+				P2P_DEBUG("ReAssembly p2p IE\n");
+			}		
+			p2pIElen = (int)(((unsigned long)p2pIEPtr)-((unsigned long)ReAssem_p2pie));		
+			
+			if(p2pIElen > MAX_REASSEM_P2P_IE){
+				P2P_DEBUG("\n\n	reassemble P2P IE exceed MAX_REASSEM_P2P_IE , chk!!!\n\n");
+			}else{
+				P2P_on_probe_req(priv, pfrinfo, ReAssem_p2pie, p2pIElen);
+				return SUCCESS;
+			}
+		}
+		else{
+			if((P2PMODE == P2P_DEVICE) && (P2P_STATE == P2P_S_LISTEN))
+				goto OnProbeReqFail;		
+			else if(P2PMODE == P2P_TMP_GO )
+				goto normal_probe_req;	
+		}	
+		/*------chk include P2P IE ------*/
+	
+
+
+	}
+
+
+normal_probe_req:
+#endif
+	ssidptrx = get_ie(pframe + WLAN_HDR_A3_LEN + _PROBEREQ_IE_OFFSET_, _SSID_IE_, (int *)&len,
+			pfrinfo->pktlen - WLAN_HDR_A3_LEN - _PROBEREQ_IE_OFFSET_);
+
+	if (ssidptrx == NULL)
+		goto OnProbeReqFail;
+
 	if (len == 0) {
 		if (HIDDEN_AP)
 			goto OnProbeReqFail;
@@ -9835,11 +11428,11 @@ static unsigned int OnProbeReq(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 	}
 
 	if ((len != SSID_LEN) ||
-			memcmp((void *)(p+2), (void *)SSID, SSID_LEN)) {
+			memcmp((void *)(ssidptrx+2), (void *)SSID, SSID_LEN)) {
 		if ((len == 3) &&
-				((*(p+2) == 'A') || (*(p+2) == 'a')) &&
-				((*(p+3) == 'N') || (*(p+3) == 'n')) &&
-				((*(p+4) == 'Y') || (*(p+4) == 'y'))) {
+				((*(ssidptrx+2) == 'A') || (*(ssidptrx+2) == 'a')) &&
+				((*(ssidptrx+3) == 'N') || (*(ssidptrx+3) == 'n')) &&
+				((*(ssidptrx+4) == 'Y') || (*(ssidptrx+4) == 'y'))) {
 			if (pmib->dot11OperationEntry.deny_any)
 				goto OnProbeReqFail;
 			else
@@ -9894,7 +11487,17 @@ static unsigned int OnProbeRsp(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 // ==== modified by GANTOE for site survey 2008/12/25 ====
 	if (OPMODE & WIFI_SITE_MONITOR)
 	{
+
+#ifdef P2P_SUPPORT
+		if( (OPMODE&WIFI_P2P_SUPPORT) && ((P2PMODE == P2P_DEVICE) || (P2PMODE == P2P_CLIENT)))
+		{
+			p2p_collect_bss_info(priv, pfrinfo);
+		}
+		else
+#endif
 		collect_bss_info(priv, pfrinfo);
+		
+		
 #if defined(CONFIG_RTL_WAPI_SUPPORT)
 		p = get_ie(pframe + WLAN_HDR_A3_LEN, _EID_WAPI_, 
 			&len, pfrinfo->pktlen);
@@ -9916,7 +11519,16 @@ static unsigned int OnProbeRsp(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 			else
 				pstat->tx_bw = HT_CHANNEL_WIDTH_20;
 
-			add_update_RATid(priv, pstat);
+#ifdef CONFIG_RTL_88E_SUPPORT
+			if (GET_CHIP_VER(priv)==VERSION_8188E) {
+#ifdef TXREPORT
+				add_RATid(priv, pstat);
+#endif
+			} else
+#endif
+			{
+				add_update_RATid(priv, pstat);
+			}
 			assign_aggre_mthod(priv, pstat);
 			assign_tx_rate(priv, pstat, pfrinfo);
 			assign_aggre_size(priv, pstat);
@@ -10132,6 +11744,21 @@ static unsigned int OnBeacon(struct rtl8192cd_priv *priv, struct rx_frinfo *pfri
 			if (p == NULL)
 				priv->ht_legacy_obss_to = 60;	
 		}
+
+		if (!priv->pmib->dot11StationConfigEntry.protectionDisabled &&
+				!priv->pmib->dot11StationConfigEntry.nmlscDetectDisabled) {
+		
+				p = get_ie(pframe + WLAN_HDR_A3_LEN + _BEACON_IE_OFFSET_, _HT_IE_, &len,
+						pfrinfo->pktlen - WLAN_HDR_A3_LEN - _BEACON_IE_OFFSET_);
+				if (p !=  NULL) {
+					struct ht_info_elmt *ht_info=(struct ht_info_elmt *)(p+2);
+					if (len) {
+						unsigned int prot_mode =  (cpu_to_le16(ht_info->info1) & 0x03);
+						if (prot_mode == _HTIE_OP_MODE3_)
+							priv->ht_nomember_legacy_sta_to= 60;	
+					}
+				}		
+		}
 	}
 
 #ifdef WIFI_11N_2040_COEXIST
@@ -10170,6 +11797,16 @@ static unsigned int OnDisassoc(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 		return 0;
 #endif
 
+#ifdef P2P_SUPPORT
+	P2P_DEBUG("	............on DisAssoc\n");
+	MAC_PRINT(pstat->hwaddr);
+	if(OPMODE&WIFI_P2P_SUPPORT && (P2PMODE == P2P_TMP_GO)){
+		if(pstat->is_p2p_client){
+			p2p_client_remove(priv,pstat);
+		}
+	}
+#endif
+
 	reason = cpu_to_le16(*(unsigned short *)((unsigned int)pframe + WLAN_HDR_A3_LEN ));
 	DEBUG_INFO("receiving disassoc from station %02X%02X%02X%02X%02X%02X reason %d\n",
 		pstat->hwaddr[0], pstat->hwaddr[1], pstat->hwaddr[2],
@@ -10183,8 +11820,22 @@ static unsigned int OnDisassoc(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 		if (pstat->expire_to > 0)
 		{
 			cnt_assoc_num(priv, pstat, DECREASE, (char *)__FUNCTION__);
-			check_sta_characteristic(priv, pstat, DECREASE);
+#ifdef CONFIG_RTL_88E_SUPPORT
+			if (GET_CHIP_VER(priv)!=VERSION_8188E) 
+#endif
+				check_sta_characteristic(priv, pstat, DECREASE);
+		}
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv)==VERSION_8188E) {
+#ifdef STA_EXT
+			if (REMAP_AID(pstat) < (RTL8188E_NUM_STAT - 1))
+#endif
+			{
+				RTL8188E_MACID_NOLINK(priv, 1, REMAP_AID(pstat));
+				RTL8188E_MACID_PAUSE(priv, 0, REMAP_AID(pstat));
+			}
 		}
+#endif
 	}
 
 #ifdef CONFIG_RTL8186_KB
@@ -10199,17 +11850,6 @@ static unsigned int OnDisassoc(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 #endif
 
 	// Need change state back to autehnticated
-	release_stainfo(priv, pstat);
-	init_stainfo(priv, pstat);
-	pstat->state |= WIFI_AUTH_SUCCESS;
-	pstat->expire_to = priv->assoc_to;
-	list_add_tail(&(pstat->auth_list), &(priv->auth_list));
-
-	RESTORE_INT(flags);
-
-	LOG_MSG("A wireless client is disassociated - %02X:%02X:%02X:%02X:%02X:%02X\n",
-		*sa, *(sa+1), *(sa+2), *(sa+3), *(sa+4), *(sa+5));
-
 	if (IEEE8021X_FUN)
 	{
 #ifndef WITHOUT_ENQUEUE
@@ -10224,11 +11864,26 @@ static unsigned int OnDisassoc(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 		DOT11_EnQueue((unsigned long)priv, priv->pevent_queue, (UINT8 *)&Disassociation_Ind,
 					sizeof(DOT11_DISASSOCIATION_IND));
 #endif
+	}
+
+	release_stainfo(priv, pstat);
+	init_stainfo(priv, pstat);
+	pstat->state |= WIFI_AUTH_SUCCESS;
+	pstat->expire_to = priv->assoc_to;
+	list_add_tail(&(pstat->auth_list), &(priv->auth_list));
+
+	RESTORE_INT(flags);
+
+	if (IEEE8021X_FUN)
+	{
 #if defined(INCLUDE_WPA_PSK) || defined(WIFI_HAPD)
 		psk_indicate_evt(priv, DOT11_EVENT_DISASSOCIATION_IND, sa, NULL, 0);
 #endif
 	}
 
+	LOG_MSG("A wireless client is disassociated - %02X:%02X:%02X:%02X:%02X:%02X\n",
+		*sa, *(sa+1), *(sa+2), *(sa+3), *(sa+4), *(sa+5));
+
 #ifdef WIFI_HAPD
 	event_indicate_hapd(priv, sa, HAPD_EXIRED, NULL);
 #ifdef HAPD_DRV_PSK_WPS
@@ -10486,7 +12141,10 @@ static unsigned int OnAuth(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinf
 			if (pstat->expire_to > 0)
 			{
 				cnt_assoc_num(priv, pstat, DECREASE, (char *)__FUNCTION__);
-				check_sta_characteristic(priv, pstat, DECREASE);
+#ifdef CONFIG_RTL_88E_SUPPORT
+				if (GET_CHIP_VER(priv)!=VERSION_8188E) 
+#endif
+					check_sta_characteristic(priv, pstat, DECREASE);
 			}
 		}
 		if (seq==1) {
@@ -10496,15 +12154,19 @@ static unsigned int OnAuth(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinf
 
 			ipmc_num = pstat->ipmc_num;
 			if (ipmc_num)
-				memcpy(ipmc, pstat->ipmc, ipmc_num * sizeof(struct ip_mcast_info));
+				memcpy(ipmc, pstat->ipmc, MAX_IP_MC_ENTRY * sizeof(struct ip_mcast_info));
 #endif
 			release_stainfo(priv, pstat);
 			init_stainfo(priv, pstat);
+#if defined(CONFIG_RTL_88E_SUPPORT) && defined(TXREPORT)
+			if (GET_CHIP_VER(priv)==VERSION_8188E)
+				RateAdaptiveInfoInit(&priv->pshare->RaInfo[pstat->aid]);
+#endif
 			pstat->tpcache_mgt = GetTupleCache(pframe);
 #ifdef  SUPPORT_TX_MCAST2UNI
 			if (ipmc_num) {
 				pstat->ipmc_num = ipmc_num;
-				memcpy(pstat->ipmc, ipmc, ipmc_num * sizeof(struct ip_mcast_info));
+				memcpy(pstat->ipmc, ipmc, MAX_IP_MC_ENTRY * sizeof(struct ip_mcast_info));
 			}
 #endif
 
@@ -10712,6 +12374,9 @@ auth_fail:
 	}
 
 	issue_auth(priv, pstat, (unsigned short)status);
+#ifdef TLN_STATS
+	stats_conn_status_counts(priv, status);
+#endif
 
 	if (alloc_pstat)
 		kfree(pstat);
@@ -10751,6 +12416,15 @@ static unsigned int OnDeAuth(struct rtl8192cd_priv *priv, struct rx_frinfo *pfri
 		return 0;
 #endif
 
+#ifdef P2P_SUPPORT
+	P2P_DEBUG("on deauth\n");
+	MAC_PRINT(pstat->hwaddr);
+	if(OPMODE&WIFI_P2P_SUPPORT && (P2PMODE == P2P_TMP_GO)){
+		if(pstat->is_p2p_client)
+			p2p_client_remove(priv,pstat);
+	}
+#endif
+
 	reason = cpu_to_le16(*(unsigned short *)((unsigned int)pframe + WLAN_HDR_A3_LEN ));
 	DEBUG_INFO("receiving deauth from station %02X%02X%02X%02X%02X%02X reason %d\n",
 		pstat->hwaddr[0], pstat->hwaddr[1], pstat->hwaddr[2],
@@ -10763,7 +12437,10 @@ static unsigned int OnDeAuth(struct rtl8192cd_priv *priv, struct rx_frinfo *pfri
 		if (pstat->expire_to > 0)
 		{
 			cnt_assoc_num(priv, pstat, DECREASE, (char *)__FUNCTION__);
-			check_sta_characteristic(priv, pstat, DECREASE);
+#ifdef CONFIG_RTL_88E_SUPPORT
+			if (GET_CHIP_VER(priv)!=VERSION_8188E) 
+#endif
+				check_sta_characteristic(priv, pstat, DECREASE);
 
 #ifdef CONFIG_RTK_MESH
 			if (isPossibleNeighbor(pstat))
@@ -10775,6 +12452,17 @@ static unsigned int OnDeAuth(struct rtl8192cd_priv *priv, struct rx_frinfo *pfri
 			}
 #endif
 		}
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv)==VERSION_8188E) {
+#ifdef STA_EXT
+			if (REMAP_AID(pstat) < (RTL8188E_NUM_STAT - 1))
+#endif
+			{
+				RTL8188E_MACID_NOLINK(priv, 1, REMAP_AID(pstat));
+				RTL8188E_MACID_PAUSE(priv, 0, REMAP_AID(pstat));
+			}
+		}
+#endif
 	}
 	RESTORE_INT(flags);
 
@@ -10822,6 +12510,9 @@ static unsigned int OnDeAuth(struct rtl8192cd_priv *priv, struct rx_frinfo *pfri
 
 static unsigned int OnWmmAction(struct rtl8192cd_priv *priv, struct rx_frinfo *pfrinfo)
 {
+#ifdef P2P_SUPPORT
+	int needRdyAssoc=1;
+#endif		
 #ifdef CONFIG_RTK_MESH
 	// please add the codes to check where the action frame is rreq, rrep or rrer
 	// (check  the action field )
@@ -10899,7 +12590,11 @@ ACTIVE_NOT_11S:
 #endif	// CONFIG_RTK_MESH
 
 #ifdef WIFI_WMM
-	if (QOS_ENABLE) {
+	if (QOS_ENABLE
+#ifdef P2P_SUPPORT
+		|| (OPMODE&WIFI_P2P_SUPPORT)
+#endif
+	) {
 		unsigned char *sa = pfrinfo->sa;
 		unsigned char *da = pfrinfo->da;
 		struct stat_info *pstat = get_stainfo(priv, sa);
@@ -10919,10 +12614,28 @@ ACTIVE_NOT_11S:
 		}
 #endif
 
-		if ((!IS_MCAST(da)) && (pstat)) {
-			pframe = get_pframe(pfrinfo) + WLAN_HDR_A3_LEN;	//start of action frame content
-			Category_field = pframe[0];
-			Action_field = pframe[1];
+		pframe = get_pframe(pfrinfo) + WLAN_HDR_A3_LEN;	//start of action frame content
+		Category_field = pframe[0];
+		Action_field = pframe[1];
+		
+#ifdef P2P_SUPPORT
+		if(OPMODE&WIFI_P2P_SUPPORT){
+			if(	(Category_field==4 && Action_field==9) 
+				//|| (Category_field==_VENDOR_ACTION_ID_)
+				)
+			{
+				needRdyAssoc=0;
+			}
+		}
+#endif
+
+		if ((!IS_MCAST(da)) && (pstat 
+#ifdef P2P_SUPPORT
+			|| needRdyAssoc==0 
+#endif				
+			)) 
+		{
+			
 			switch (Category_field) {
 				case _BLOCK_ACK_CATEGORY_ID_:
 					switch (Action_field) {
@@ -10975,6 +12688,7 @@ ACTIVE_NOT_11S:
 							if (status_code != _STATS_SUCCESSFUL_) {
 								pstat->ADDBA_ready[TID] = 0;
 							} else {
+								DEBUG_INFO("%s %d increase ADDBA_ready, clear ADDBA_sent\n",__func__,__LINE__);
 								pstat->ADDBA_ready[TID]++;
 								pstat->ADDBA_sent[TID] = 0;
 							}
@@ -10992,7 +12706,7 @@ ACTIVE_NOT_11S:
 					}
 					break;
 
-#ifdef WIFI_11N_2040_COEXIST
+#if	defined(WIFI_11N_2040_COEXIST) || defined(P2P_SUPPORT)
 				case _PUBLIC_CATEGORY_ID_:
 					switch (Action_field) {
 						case _2040_COEXIST_ACTION_ID_:
@@ -11017,7 +12731,17 @@ ACTIVE_NOT_11S:
 										else
 											priv->switch_20_sta_ext |= BIT(pstat->aid - 1 - FW_NUM_STAT);
 #else
-										priv->switch_20_sta |= BIT(pstat->aid - 1);
+#ifdef CONFIG_RTL_88E_SUPPORT
+										if (GET_CHIP_VER(priv) == VERSION_8188E) {
+											if (pstat->aid <= 32)
+												priv->switch_20_sta |= BIT(pstat->aid - 1);
+											else
+												priv->switch_20_sta_88e_hw_ext |= BIT(pstat->aid - 1 - 32);
+										} else
+#endif
+										{
+											priv->switch_20_sta |= BIT(pstat->aid - 1);
+										}
 #endif
 										if (pframe[4] & _40M_INTOLERANT_) {
 											DEBUG_INFO("Public Action frame: force 20m by 40m intolerant\n");
@@ -11032,7 +12756,17 @@ ACTIVE_NOT_11S:
 											else
 												priv->switch_20_sta_ext |= BIT(pstat->aid - 1 - FW_NUM_STAT);
 #else
-											priv->switch_20_sta |= BIT(pstat->aid - 1);
+#ifdef CONFIG_RTL_88E_SUPPORT
+											if (GET_CHIP_VER(priv) == VERSION_8188E) {
+												if (pstat->aid <= 32)
+													priv->switch_20_sta |= BIT(pstat->aid - 1);
+												else
+													priv->switch_20_sta_88e_hw_ext |= BIT(pstat->aid - 1 - 32);
+											} else
+#endif
+											{
+												priv->switch_20_sta |= BIT(pstat->aid - 1);
+											}
 #endif
 											DEBUG_INFO("Public Action frame: force 20m by channel report\n");
 										} else {
@@ -11040,9 +12774,19 @@ ACTIVE_NOT_11S:
 											if (pstat->aid <= FW_NUM_STAT)
 												priv->switch_20_sta &= ~BIT(pstat->aid - 1);
 											else
-												priv->switch_20_sta &= ~BIT(pstat->aid - 1 - FW_NUM_STAT);
+												priv->switch_20_sta_ext &= ~BIT(pstat->aid - 1 - FW_NUM_STAT);
 #else
-											priv->switch_20_sta &= ~BIT(pstat->aid - 1);
+#ifdef CONFIG_RTL_88E_SUPPORT
+											if (GET_CHIP_VER(priv) == VERSION_8188E) {
+												if (pstat->aid <= 32)
+													priv->switch_20_sta &= ~BIT(pstat->aid - 1);
+												else
+													priv->switch_20_sta_88e_hw_ext &= ~BIT(pstat->aid - 1 - 32);
+											} else
+#endif
+											{
+												priv->switch_20_sta &= ~BIT(pstat->aid - 1);
+											}
 #endif
 											DEBUG_INFO("Public Action frame: cancel force 20m\n");
 										}
@@ -11058,6 +12802,13 @@ ACTIVE_NOT_11S:
 								DEBUG_WARN("Public Action frame received but func off\n");
 							}
 							break;
+#ifdef P2P_SUPPORT
+						case _P2P_PUBLIC_ACTION_FIELD_:
+							if(!memcmp(&pframe[2] , WFA_OUI_PLUS_TYPE,4)){							
+								P2P_on_public_action(priv,pfrinfo);
+							}
+							break;
+#endif							
 						default:
 							DEBUG_INFO("Public Action frame received but not support yet\n");
 							goto error_frame;
@@ -11078,18 +12829,33 @@ ACTIVE_NOT_11S:
 						}
 						if ((previous_mimo_ps|pstat->MIMO_ps)&_HT_MIMO_PS_STATIC_) {
 							assign_tx_rate(priv, pstat, pfrinfo);
-							add_update_RATid(priv, pstat);
+#ifdef CONFIG_RTL_88E_SUPPORT
+							if (GET_CHIP_VER(priv)==VERSION_8188E) {
+#ifdef TXREPORT
+								add_RATid(priv, pstat);
+#endif
+							} else
+#endif
+							{
+								add_update_RATid(priv, pstat);
+							}
 						}
 #ifdef TX_SHORTCUT
 						if ((previous_mimo_ps|pstat->MIMO_ps)&_HT_MIMO_PS_DYNAMIC_) 
 							do_tx_slowpath++;
 #endif
 						check_NAV_prot_len(priv, pstat, 0);
-					}
-					else
+					} else {
 						DEBUG_INFO("HT Action Frame is received but not support yet\n");
+					}
 					break;
-
+#ifdef P2P_SUPPORT
+				case _VENDOR_ACTION_ID_:
+					if(!memcmp(&pframe[1],WFA_OUI_PLUS_TYPE,WFA_OUI_PLUS_TYPE_LEN)){
+						P2P_on_action(priv,pfrinfo);
+					}
+					break;	
+#endif
 				default:
 					DEBUG_INFO("Action Frame is received but not support yet\n");
 					break;
@@ -11135,6 +12901,7 @@ static void update_bss(struct Dot11StationConfigEntry *dst, struct bss_desc *src
 }
 
 
+
 /**
  *	@brief	Authenticat success, Join a BSS
  *
@@ -11317,8 +13084,20 @@ static unsigned int issue_assocreq(struct rtl8192cd_priv *priv)
 			if (!memcmp((void *)bssid, bss[k].bssid, MACADDRLEN)) {
 
 #ifdef WIFI_WMM
-				if ((QOS_ENABLE) && (bss[k].t_stamp[1] & BIT(0)))	//  AP supports WMM when t_stamp[1] bit 0 is set
+				//  AP supports WMM when t_stamp[1] bit 0 is set
+				if ((QOS_ENABLE) && (bss[k].t_stamp[1] & BIT(0))) {
+#ifdef WMM_APSD
+					if (APSD_ENABLE) {
+						if (bss[k].t_stamp[1] & BIT(3))
+							priv->uapsd_assoc++;
+						else 
+							priv->uapsd_assoc = 0;
+
+						init_WMM_Para_Element(priv, priv->pmib->dot11QosEntry.WMM_IE);
+					}
+#endif
 					pbuf = set_ie(pbuf, _RSN_IE_1_, _WMM_IE_Length_, GET_WMM_IE, &txinsn.fr_len);
+				}
 #endif
 				if ((priv->pmib->dot11BssType.net_work_type & WIRELESS_11N) &&
 						(bss[k].network & WIRELESS_11N)) {
@@ -11357,7 +13136,19 @@ static unsigned int issue_assocreq(struct rtl8192cd_priv *priv)
 		txinsn.fr_len += pmib->wscEntry.assoc_ielen;
 	}
 #endif
+#ifdef P2P_SUPPORT
+	if((OPMODE&WIFI_P2P_SUPPORT)&&(P2PMODE == P2P_CLIENT)){
 
+		if(priv->p2pPtr->p2p_assocReq_ie_len) {
+			
+			memcpy(pbuf, priv->p2pPtr->p2p_assocReq_ie, priv->p2pPtr->p2p_assocReq_ie_len);
+			
+			pbuf += priv->p2pPtr->p2p_assocReq_ie_len;
+			txinsn.fr_len += priv->p2pPtr->p2p_assocReq_ie_len;
+		}
+
+	}
+#endif
 #ifdef CONFIG_RTL_WAPI_SUPPORT
 		if (priv->pmib->wapiInfo.wapiType!=wapiDisable)
 		{
@@ -11441,11 +13232,25 @@ void start_clnt_auth(struct rtl8192cd_priv *priv)
 		}
 #endif
 		SwChnl(priv, priv->pmib->dot11Bss.channel, 0);
+
+		{
+			unsigned int trigger_iqk = 0;
 #ifdef CONFIG_RTL_92D_SUPPORT
-		if (GET_CHIP_VER(priv) == VERSION_8192D){
-			PHY_IQCalibrate(priv);
-		}
+			if ((GET_CHIP_VER(priv) == VERSION_8192D) && (priv->pmib->dot11Bss.channel > 14)) {
+				priv->pshare->iqk_5g_done = 0;
+				trigger_iqk++;
+			} else
 #endif
+			{
+				if (priv->pmib->dot11Bss.channel <= 14) {
+					priv->pshare->iqk_2g_done = 0;
+					trigger_iqk++;
+				}
+			}
+
+			if (trigger_iqk)
+				PHY_IQCalibrate(priv);
+		}
 
 	}
 
@@ -11498,11 +13303,24 @@ void clean_for_join(struct rtl8192cd_priv *priv)
 {
 	int i;
 	unsigned long flags;
-
+#ifdef P2P_SUPPORT
+	int p2p_support=0;
+#endif
 	SAVE_INT_AND_CLI(flags);
 	memset(BSSID, 0, MACADDRLEN);
+#ifdef P2P_SUPPORT
+	if(OPMODE & WIFI_P2P_SUPPORT)
+		p2p_support = 1;
+#endif
 	OPMODE = OPMODE & (WIFI_STATION_STATE | WIFI_ADHOC_STATE);
 
+#ifdef P2P_SUPPORT
+	if(p2p_support)
+		OPMODE |= WIFI_P2P_SUPPORT;
+#endif
+
+	//P2P_DEBUG("\n\n\n");
+
 	for(i=0; i<NUM_STAT; i++) {
 		if (priv->pshare->aidarray[i] && (priv->pshare->aidarray[i]->used == TRUE)) {
 #if defined(UNIVERSAL_REPEATER) || defined(MBSSID)
@@ -11574,7 +13392,6 @@ unsigned int mod64(unsigned int A1, unsigned int A2, unsigned int b)
 	return r;
 }
 
-
 static void updateTSF(struct rtl8192cd_priv *priv)
 {
 	UINT64 tsf;
@@ -11612,6 +13429,14 @@ void start_clnt_join(struct rtl8192cd_priv *priv)
 	unsigned char null_mac[]={0,0,0,0,0,0};
 	unsigned char random;
 	int i;
+#ifdef P2P_SUPPORT
+	int p2p_support=0;
+#endif
+
+#ifdef DFS
+	if (priv->pmib->dot11DFSEntry.disable_tx)
+		priv->pmib->dot11DFSEntry.disable_tx = 0;
+#endif
 
 // stop ss_timer before join ------------------------
 	if (timer_pending(&priv->ss_timer))
@@ -11640,14 +13465,24 @@ void start_clnt_join(struct rtl8192cd_priv *priv)
 				priv->recover_join_req = 1;
 #endif
 			clean_for_join(priv);
+
+#ifdef P2P_SUPPORT
+			if(OPMODE & WIFI_P2P_SUPPORT)
+				p2p_support = 1;
+#endif
 			OPMODE = WIFI_STATION_STATE;
+#ifdef P2P_SUPPORT
+			if(p2p_support)
+				OPMODE |= WIFI_P2P_SUPPORT;
+#endif
+
 #ifdef UNIVERSAL_REPEATER
 			if (IS_ROOT_INTERFACE(priv))
 #endif
 			{
 				RTL_W32(CR, (RTL_R32(CR) & ~(NETYPE_Mask << NETYPE_SHIFT)) | ((NETYPE_INFRA & NETYPE_Mask) << NETYPE_SHIFT));
 				updateTSF(priv);
-#ifdef TESTCHIP_SUPPORT
+#if defined(TESTCHIP_SUPPORT) && defined(CONFIG_RTL_92C_SUPPORT)
 				if (IS_TEST_CHIP(priv))
 					RTL_W8(BCN_CTRL, RTL_R8(BCN_CTRL) & ~(DIS_TSF_UPDATE |DIS_SUB_STATE));
 				else
@@ -11696,11 +13531,25 @@ void start_clnt_join(struct rtl8192cd_priv *priv)
 			}
 #endif
 			SwChnl(priv, pmib->dot11Bss.channel, priv->pshare->offset_2nd_chan);
+
+			{
+				unsigned int trigger_iqk = 0;
 #ifdef CONFIG_RTL_92D_SUPPORT
-			if (GET_CHIP_VER(priv) == VERSION_8192D){
-				PHY_IQCalibrate(priv);
-			}
+				if ((GET_CHIP_VER(priv) == VERSION_8192D) && (priv->pmib->dot11Bss.channel > 14)) {
+					priv->pshare->iqk_5g_done = 0;
+					trigger_iqk++;
+				} else
 #endif
+				{
+					if (priv->pmib->dot11Bss.channel <= 14) {
+						priv->pshare->iqk_2g_done = 0;
+						trigger_iqk++;
+					}
+				}
+
+				if (trigger_iqk)
+					PHY_IQCalibrate(priv);
+			}
 
 			DEBUG_INFO("Join IBSS: chan=%d, 40M=%d, offset=%d\n", pmib->dot11Bss.channel,
 				priv->pshare->is_40m_bw, priv->pshare->offset_2nd_chan);
@@ -11708,7 +13557,7 @@ void start_clnt_join(struct rtl8192cd_priv *priv)
 			join_bss(priv);
 			RTL_W32(CR, (RTL_R32(CR) & ~(NETYPE_Mask << NETYPE_SHIFT)) | ((NETYPE_ADHOC & NETYPE_Mask) << NETYPE_SHIFT));
 			updateTSF(priv);
-#ifdef TESTCHIP_SUPPORT
+#if defined(TESTCHIP_SUPPORT) && defined(CONFIG_RTL_92C_SUPPORT)
 			if (IS_TEST_CHIP(priv))
 				RTL_W8(BCN_CTRL, RTL_R8(BCN_CTRL) & ~(DIS_TSF_UPDATE ));
 			else
@@ -11794,12 +13643,24 @@ void start_clnt_join(struct rtl8192cd_priv *priv)
 
 			SwChnl(priv, pmib->dot11Bss.channel, priv->pshare->offset_2nd_chan);
 
+			{
+				unsigned int trigger_iqk = 0;
 #ifdef CONFIG_RTL_92D_SUPPORT
-			if (priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_2G)
-				IQK_92D_2G(priv);
-			else
-				IQK_92D_5G_n(priv);
+				if ((GET_CHIP_VER(priv) == VERSION_8192D) && (priv->pmib->dot11Bss.channel > 14)) {
+					priv->pshare->iqk_5g_done = 0;
+					trigger_iqk++;
+				} else
 #endif
+				{
+					if (priv->pmib->dot11Bss.channel <= 14) {
+						priv->pshare->iqk_2g_done = 0;
+						trigger_iqk++;
+					}
+				}
+
+				if (trigger_iqk)
+					PHY_IQCalibrate(priv);
+			}
 
 			DEBUG_INFO("Start IBSS: chan=%d, 40M=%d, offset=%d\n", pmib->dot11Bss.channel,
 				priv->pshare->is_40m_bw, priv->pshare->offset_2nd_chan);
@@ -11809,7 +13670,7 @@ void start_clnt_join(struct rtl8192cd_priv *priv)
 			join_bss(priv);
 			RTL_W32(CR, (RTL_R32(CR) & ~(NETYPE_Mask << NETYPE_SHIFT)) | ((NETYPE_ADHOC & NETYPE_Mask) << NETYPE_SHIFT));
 			updateTSF(priv);
-#ifdef TESTCHIP_SUPPORT
+#if defined(TESTCHIP_SUPPORT) && defined(CONFIG_RTL_92C_SUPPORT)
 			if (IS_TEST_CHIP(priv))
 				RTL_W8(BCN_CTRL, RTL_R8(BCN_CTRL) & ~(DIS_TSF_UPDATE));
 			else
@@ -11846,10 +13707,26 @@ void start_clnt_join(struct rtl8192cd_priv *priv)
 			}
 #endif
 			SwChnl(priv, pmib->dot11Bss.channel, priv->pshare->offset_2nd_chan);
+
+			{
+				unsigned int trigger_iqk = 0;
 #ifdef CONFIG_RTL_92D_SUPPORT
-			if (GET_CHIP_VER(priv) == VERSION_8192D)
-				PHY_IQCalibrate(priv);
+				if ((GET_CHIP_VER(priv) == VERSION_8192D) && (priv->pmib->dot11Bss.channel > 14)) {
+					priv->pshare->iqk_5g_done = 0;
+					trigger_iqk++;
+				} else
 #endif
+				{
+					if (priv->pmib->dot11Bss.channel <= 14) {
+						priv->pshare->iqk_2g_done = 0;
+						trigger_iqk++;
+					}
+				}
+
+				if (trigger_iqk)
+					PHY_IQCalibrate(priv);
+			}
+
 			RTL_W32(CR, (RTL_R32(CR) & ~(NETYPE_Mask << NETYPE_SHIFT)) | ((NETYPE_ADHOC & NETYPE_Mask) << NETYPE_SHIFT));
 
 			DEBUG_INFO("Start IBSS: chan=%d, 40M=%d, offset=%d\n", pmib->dot11Bss.channel,
@@ -11901,6 +13778,18 @@ static int check_bss_networktype(struct rtl8192cd_priv * priv, struct bss_desc *
 	return result;
 }
 
+#ifdef SMART_REPEATER_MODE
+static int check_vxd_ap_security(struct rtl8192cd_priv *priv, struct bss_desc *bss)
+{
+	if ((GET_MIB(GET_VXD_PRIV(priv))->dot1180211AuthEntry.dot11PrivacyAlgrthm && (bss->capability&BIT(4))) ||
+		((GET_MIB(GET_VXD_PRIV(priv))->dot1180211AuthEntry.dot11PrivacyAlgrthm==0) && ((bss->capability&BIT(4))==0))) {
+		if (check_bss_networktype(GET_VXD_PRIV(priv), bss)) 
+			return 1;			
+	}
+	return 0;
+}
+#endif
+
 
 /**
  *	@brief	STA don't how to do
@@ -11917,9 +13806,39 @@ void start_clnt_lookup(struct rtl8192cd_priv *priv, int rescan)
 	char tmpbuf[33];
 	int i;
 
+#ifdef P2P_SUPPORT
+	if((OPMODE&WIFI_P2P_SUPPORT)&&(P2PMODE == P2P_DEVICE)){
+		P2P_DEBUG("P2P_DEVICE don't lookup\n");
+		return;							
+	}
+#endif
+
+
+
 	if (rescan || ((priv->site_survey.count_target > 0) &&
 		((priv->join_index+1) >= priv->site_survey.count_target)))
 	{
+#ifdef P2P_SUPPORT
+	if((OPMODE & WIFI_P2P_SUPPORT ) && (P2PMODE == P2P_CLIENT) )
+	{
+		// client data can't connected yet
+		//if(	P2P_STATE == P2P_S_IDLE)
+		{
+			priv->p2pPtr->clientmode_try_connect ++;
+			P2P_DEBUG("P2P_client try to connect (%d) timeout=%d seconds\n",
+				priv->p2pPtr->clientmode_try_connect,CLIENT_MODE_WAIT_TIME);		
+
+			if(	priv->p2pPtr->clientmode_try_connect >= CLIENT_MODE_WAIT_TIME)
+			{
+				P2P_DEBUG("P2P client exceed %d seconds don't connect,backto p2p dev!\n",CLIENT_MODE_WAIT_TIME);
+				priv->p2pPtr->clientmode_try_connect = 0;
+				P2P_STATE = P2P_S_back2dev;
+				return;	
+			}
+		}
+
+	}		
+#endif
 		priv->join_res = STATE_Sta_Roaming_Scan;
 		if (OPMODE & WIFI_SITE_MONITOR) // if scanning, scan later
 			return;
@@ -11932,7 +13851,11 @@ void start_clnt_lookup(struct rtl8192cd_priv *priv, int rescan)
 		return;
 	}
 
-	memset(&pmib->dot11Bss, 0, sizeof(struct bss_desc));
+#ifdef SMART_REPEATER_MODE
+	if (priv->ss_req_ongoing != 3)
+#endif
+		memset(&pmib->dot11Bss, 0, sizeof(struct bss_desc));
+
 	if (SSID2SCAN_LEN > 0)
 	{
 		for (i=priv->join_index+1; i<priv->site_survey.count_target; i++)
@@ -11943,12 +13866,29 @@ void start_clnt_lookup(struct rtl8192cd_priv *priv, int rescan)
 			{
 				// check BSSID
 				if (!memcmp(pmib->dot11StationConfigEntry.dot11DesiredBssid, null_mac, MACADDRLEN) ||
-					!memcmp(priv->site_survey.bss_target[i].bssid, pmib->dot11StationConfigEntry.dot11DesiredBssid, MACADDRLEN))
+					!memcmp(priv->site_survey.bss_target[i].bssid, pmib->dot11StationConfigEntry.dot11DesiredBssid, MACADDRLEN)
+#ifdef SMART_REPEATER_MODE
+					|| (priv->ss_req_ongoing == 3)
+#endif
+					)
 				{
 					// check BSS type
 					if (((OPMODE & WIFI_STATION_STATE) && (priv->site_survey.bss_target[i].bsstype == WIFI_AP_STATE)) ||
-						((OPMODE & WIFI_ADHOC_STATE) && (priv->site_survey.bss_target[i].bsstype == WIFI_ADHOC_STATE)))
+						((OPMODE & WIFI_ADHOC_STATE) && (priv->site_survey.bss_target[i].bsstype == WIFI_ADHOC_STATE))
+#ifdef SMART_REPEATER_MODE
+						|| ((priv->ss_req_ongoing == 3) && (priv->site_survey.bss_target[i].bsstype == WIFI_AP_STATE))
+#endif
+						)
 					{
+#ifdef SMART_REPEATER_MODE
+						if (priv->ss_req_ongoing == 3) {										
+							if (check_vxd_ap_security(priv, &priv->site_survey.bss_target[i])) {							
+								priv->pshare->switch_chan_rp = priv->site_survey.bss_target[i].channel;				
+								break;
+							}
+						}
+#endif
+					
 						// check encryption
 						if (((priv->pmib->dot1180211AuthEntry.dot11PrivacyAlgrthm) && (priv->site_survey.bss_target[i].capability&BIT(4))) ||
 							((priv->pmib->dot1180211AuthEntry.dot11PrivacyAlgrthm==0) && ((priv->site_survey.bss_target[i].capability&BIT(4))==0)))
@@ -11956,6 +13896,15 @@ void start_clnt_lookup(struct rtl8192cd_priv *priv, int rescan)
 							// check network type
 							if (check_bss_networktype(priv, &(priv->site_survey.bss_target[i])))
 							{
+
+#ifdef UNIVERSAL_REPEATER
+								if (IS_VXD_INTERFACE(priv) && 
+#ifdef SMART_REPEATER_MODE
+									priv->ss_req_ongoing != 3 &&
+#endif									
+										GET_MIB(GET_ROOT_PRIV(priv))->dot11RFEntry.dot11channel != priv->site_survey.bss_target[i].channel) 
+									continue;																
+#endif						
 								memcpy(tmpbuf, SSID2SCAN, SSID2SCAN_LEN);
 								tmpbuf[SSID2SCAN_LEN] = '\0';
 								DEBUG_INFO("found desired bss [%s], start to join\n", tmpbuf);
@@ -12014,7 +13963,11 @@ void start_clnt_lookup(struct rtl8192cd_priv *priv, int rescan)
 #ifdef WIFI_WPAS
 	if(priv->wpas_manual_assoc == 0)
 #endif
-	start_clnt_join(priv);
+
+#ifdef SMART_REPEATER_MODE
+	if (priv->ss_req_ongoing != 3)
+#endif
+		start_clnt_join(priv);
 }
 
 
@@ -12216,6 +14169,13 @@ static unsigned int OnAssocRsp(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 	int		supportRateNum;
 	UINT16	val;
 	int		len;
+#ifdef P2P_SUPPORT
+	unsigned char ReAssem_p2pie[MAX_REASSEM_P2P_IE];
+	int IEfoundtimes=0;
+	unsigned char *p2pIEPtr = ReAssem_p2pie ;
+	int p2pIElen=0;
+#endif
+
 
 	if (!(OPMODE & WIFI_STATION_STATE))
 		return SUCCESS;
@@ -12259,6 +14219,19 @@ static unsigned int OnAssocRsp(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 		pstat->tpcache_mgt = GetTupleCache(pframe);
 	}
 
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv)==VERSION_8188E) {
+		if (pstat
+#ifdef STA_EXT
+			&& (REMAP_AID(pstat) < (RTL8188E_NUM_STAT - 1))
+#endif
+			) {
+			RTL8188E_MACID_NOLINK(priv, 0, REMAP_AID(pstat));
+			RTL8188E_MACID_PAUSE(priv, 0, REMAP_AID(pstat));
+		}
+	}
+#endif
+
 	// Realtek proprietary IE
 	p = pframe + WLAN_HDR_A3_LEN + _ASOCRSP_IE_OFFSET_; len = 0;
 	for (;;) {
@@ -12291,6 +14264,67 @@ static unsigned int OnAssocRsp(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 		p = p + len + 2;
 	}
 
+	// identify if this is Broadcom sta
+	p = pframe + WLAN_HDR_A3_LEN + _ASOCRSP_IE_OFFSET_; len = 0;
+	pstat->is_broadcom_sta = FALSE;
+	for (;;)
+	{
+		unsigned char Broadcom_OUI1[]={0x00, 0x05, 0xb5};
+		unsigned char Broadcom_OUI2[]={0x00, 0x0a, 0xf7};
+		unsigned char Broadcom_OUI3[]={0x00, 0x10, 0x18};
+
+		p = get_ie(p, _RSN_IE_1_, &len,
+				pfrinfo->pktlen - (p - pframe));
+		if (p != NULL) {
+			if (!memcmp(p+2, Broadcom_OUI1, 3) ||
+					!memcmp(p+2, Broadcom_OUI2, 3) ||
+					!memcmp(p+2, Broadcom_OUI3, 3)) {
+				pstat->is_broadcom_sta = TRUE;
+				break;
+			}
+		}
+		else
+			break;
+
+		p = p + len + 2;
+	}
+
+	// identify if this is ralink sta
+	p = pframe + WLAN_HDR_A3_LEN + _ASOCRSP_IE_OFFSET_; len = 0;
+	pstat->is_ralink_sta = FALSE;
+	for (;;)
+	{
+		unsigned char Ralink_OUI1[]={0x00, 0x0c, 0x43};
+
+		p = get_ie(p, _RSN_IE_1_, &len,
+			pfrinfo->pktlen - (p - pframe));
+		if (p != NULL) {
+			if (!memcmp(p+2, Ralink_OUI1, 3)) {
+				pstat->is_ralink_sta = TRUE;
+				break;
+			}	
+		}
+		else
+			break;
+		p = p + len + 2;
+	}
+
+	if (!pstat->is_realtek_sta && !pstat->is_broadcom_sta && !pstat->is_ralink_sta) {
+		unsigned int z = 0;
+		for (z = 0; z < INTEL_OUI_NUM; z++) {
+			if ((pstat->hwaddr[0] == INTEL_OUI[z][0]) &&
+				(pstat->hwaddr[1] == INTEL_OUI[z][1]) &&
+				(pstat->hwaddr[2] == INTEL_OUI[z][2])) {
+				pstat->is_intel_sta = TRUE;
+				pstat->no_rts = 1;
+				break;
+			}
+		}
+
+		if (z == INTEL_OUI_NUM)
+			pstat->is_intel_sta = FALSE;
+	}
+
 	// get rates
 	p = get_ie(pframe + WLAN_HDR_A3_LEN + _ASOCRSP_IE_OFFSET_, _SUPPORTEDRATES_IE_, &len,
 		pfrinfo->pktlen - WLAN_HDR_A3_LEN - _ASOCRSP_IE_OFFSET_);
@@ -12365,6 +14399,23 @@ static unsigned int OnAssocRsp(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 						process_WMM_para_ie(priv, p);  //get the info
 						p += 4;
 					}
+					DEBUG_INFO("BE: ACM %d, AIFSN %d, ECWmin %d, ECWmax %d, TXOP %d\n",
+						GET_STA_AC_BE_PARA.ACM, GET_STA_AC_BE_PARA.AIFSN,
+						GET_STA_AC_BE_PARA.ECWmin, GET_STA_AC_BE_PARA.ECWmax,
+						GET_STA_AC_BE_PARA.TXOPlimit);
+					DEBUG_INFO("VO: ACM %d, AIFSN %d, ECWmin %d, ECWmax %d, TXOP %d\n",
+						GET_STA_AC_VO_PARA.ACM, GET_STA_AC_VO_PARA.AIFSN,
+						GET_STA_AC_VO_PARA.ECWmin, GET_STA_AC_VO_PARA.ECWmax,
+						GET_STA_AC_VO_PARA.TXOPlimit);
+					DEBUG_INFO("VI: ACM %d, AIFSN %d, ECWmin %d, ECWmax %d, TXOP %d\n",
+						GET_STA_AC_VI_PARA.ACM, GET_STA_AC_VI_PARA.AIFSN,
+						GET_STA_AC_VI_PARA.ECWmin, GET_STA_AC_VI_PARA.ECWmax,
+						GET_STA_AC_VI_PARA.TXOPlimit);
+					DEBUG_INFO("BK: ACM %d, AIFSN %d, ECWmin %d, ECWmax %d, TXOP %d\n",
+						GET_STA_AC_BK_PARA.ACM, GET_STA_AC_BK_PARA.AIFSN,
+						GET_STA_AC_BK_PARA.ECWmin, GET_STA_AC_BK_PARA.ECWmax,
+						GET_STA_AC_BK_PARA.TXOPlimit);
+
 #if defined(UNIVERSAL_REPEATER) || defined(MBSSID)
 					if (IS_ROOT_INTERFACE(priv))
 #endif
@@ -12382,11 +14433,56 @@ static unsigned int OnAssocRsp(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 			}
 			p = p + len + 2;
 		}
-	}
-	else
+	} 
+	else {
 		pstat->QosEnabled = 0;
+	}
+#endif
+
+
+#ifdef P2P_SUPPORT	
+	p = pframe + WLAN_HDR_A3_LEN + _ASOCRSP_IE_OFFSET_ ;
+
+	/*support ReAssemble*/		
+	for (;;)
+	{
+		/*get P2P_IE*/ 
+		p = get_ie(p, _P2P_IE_, &len,	
+			pfrinfo->pktlen - WLAN_HDR_A3_LEN - _ASOCRSP_IE_OFFSET_ - len);			
+	
+		if (p) {
+			if (!memcmp(p+2, WFA_OUI_PLUS_TYPE, 4)) {
+					memcpy(p2pIEPtr , p+6 ,len - 4);
+					p2pIEPtr += (len - 4);
+					IEfoundtimes ++;
+			}
+		}
+		else{
+			break;
+		}
+		p = p + len + 2;
+		
+	}
+
+	if(IEfoundtimes){
+		
+		if(IEfoundtimes>1){
+			P2P_DEBUG("ReAssembly p2p IE\n");
+		}
+		p2pIElen = (int)(((unsigned long)p2pIEPtr)-((unsigned long)ReAssem_p2pie));		
+		
+		if(p2pIElen > MAX_REASSEM_P2P_IE){
+			P2P_DEBUG("\n\n	reassemble P2P IE exceed MAX_REASSEM_P2P_IE , chk!!!\n\n");
+		}else{
+			P2P_on_assoc_rsp(priv,pfrinfo->sa);
+			pstat->is_p2p_client = 1;
+		}
+	}
+		
 #endif
 
+
+
 	if ((priv->pmib->dot11BssType.net_work_type & WIRELESS_11N) && priv->ht_cap_len) {
 		p = get_ie(pframe + WLAN_HDR_A3_LEN + _ASOCRSP_IE_OFFSET_, _HT_CAP_, &len,
 				pfrinfo->pktlen - WLAN_HDR_A3_LEN - _ASOCRSP_IE_OFFSET_);
@@ -12406,8 +14502,8 @@ static unsigned int OnAssocRsp(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 
 			priv->ht_protection = 0;
 			if (!priv->pmib->dot11StationConfigEntry.protectionDisabled && pstat->ht_ie_len) {
-				if ((pstat->ht_ie_buf.info1 & cpu_to_le16(_HTIE_OP_MODE1_)) ||
-				(pstat->ht_ie_buf.info1 & cpu_to_le16(_HTIE_OP_MODE3_)))
+				unsigned int prot_mode =  (cpu_to_le16(pstat->ht_ie_buf.info1) & 0x03);
+				if (prot_mode == _HTIE_OP_MODE1_ || prot_mode == _HTIE_OP_MODE3_)
 					priv->ht_protection = 1;
 			}
 		} else {
@@ -12521,6 +14617,16 @@ static unsigned int OnAssocRsp(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 	if (timer_pending(&priv->reassoc_timer))
 		del_timer_sync(&priv->reassoc_timer);
 
+	// clear cached Dev	
+#if defined(BR_SHORTCUT) && defined(CLIENT_MODE)
+	{
+		extern unsigned char cached_sta_mac[6];
+		extern struct net_device *cached_sta_dev;
+		memset(cached_sta_mac, 0, MACADDRLEN);
+		cached_sta_dev = NULL;
+	}
+#endif
+	
 	RESTORE_INT(flags);
 
 	OPMODE |= WIFI_ASOC_STATE;
@@ -12613,21 +14719,52 @@ static unsigned int OnAssocRsp(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 //#ifdef BR_SHORTCUT
 #if 0
 	clear_shortcut_cache();
+#if defined(CONFIG_RTL_FASTBRIDGE)
+	rtl_fb_flush();
+#endif
+#endif
+
+	priv->pshare->AP_BW = -1;			
+#ifdef UNIVERSAL_REPEATER
+	if (IS_VXD_INTERFACE(priv)) {
+		if(GET_ROOT_PRIV(priv)->pmib->dot11nConfigEntry.dot11nUse40M) {
+			if((pstat->ht_cap_len > 0) && (pstat->ht_ie_len > 0) &&
+			(pstat->ht_ie_buf.info0 & _HTIE_STA_CH_WDTH_) &&
+			(pstat->ht_cap_buf.ht_cap_info & cpu_to_le16(_HTCAP_SUPPORT_CH_WDTH_))) {
+				priv->pshare->is_40m_bw = 1;
+			}
+		}
+	}	
 #endif
 
 #ifdef UNIVERSAL_REPEATER
 	if (IS_ROOT_INTERFACE(priv))
 #endif
 	{
-		if ((pstat->ht_cap_len > 0) && (pstat->ht_ie_len > 0) && priv->pshare->AP_BW) {
-//				(pstat->ht_ie_buf.info0 & _HTIE_STA_CH_WDTH_) &&
-//		(pstat->ht_cap_buf.ht_cap_info & cpu_to_le16(_HTCAP_SUPPORT_CH_WDTH_))) {
+		if ((pstat->ht_cap_len > 0) && (pstat->ht_ie_len > 0) &&				
+			(pstat->ht_ie_buf.info0 & _HTIE_STA_CH_WDTH_) &&					
+			(pstat->ht_cap_buf.ht_cap_info & cpu_to_le16(_HTCAP_SUPPORT_CH_WDTH_))) {
 			priv->pshare->is_40m_bw = 1;
 			if ((pstat->ht_ie_buf.info0 & _HTIE_2NDCH_OFFSET_BL_) == _HTIE_2NDCH_OFFSET_BL_)
 				priv->pshare->offset_2nd_chan = HT_2NDCH_OFFSET_BELOW;
 			else
 				priv->pshare->offset_2nd_chan = HT_2NDCH_OFFSET_ABOVE;
 
+			if (priv->pshare->is_40m_bw == 1) {
+				if (priv->pshare->offset_2nd_chan == HT_2NDCH_OFFSET_ABOVE) {
+					int i, channel = priv->pmib->dot11Bss.channel + 4;
+					for (i=0; i<priv->available_chnl_num; i++) {
+						if (channel == priv->available_chnl[i])
+							break;
+					}
+					if (i == priv->available_chnl_num) {
+						priv->pshare->is_40m_bw = 0;
+						priv->pshare->offset_2nd_chan = HT_2NDCH_OFFSET_DONTCARE;
+						DEBUG_INFO("AP is 40M (ch%d-ch%d) but not fit region domain, sw back to 20M\n", priv->pmib->dot11Bss.channel, channel);
+					}
+				}
+			}
+
 #ifdef CONFIG_RTL_92D_SUPPORT
 			if ((GET_CHIP_VER(priv) == VERSION_8192D)&&(priv->pmib->dot11RFEntry.macPhyMode==SINGLEMAC_SINGLEPHY)) {
 				clnt_ss_check_band(priv, priv->pmib->dot11Bss.channel); 
@@ -12641,13 +14778,17 @@ static unsigned int OnAssocRsp(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 #ifdef CONFIG_RTL_92D_SUPPORT
 			if (GET_CHIP_VER(priv) == VERSION_8192D)
 				PHY_IQCalibrate(priv);
+
+#ifdef DPK_92D		
+			if (priv->pmib->dot11RFEntry.phyBandSelect==PHY_BAND_5G && priv->pshare->rf_ft_var.dpk_on)
+				PHY_DPCalibrate(priv);
+#endif
 #endif
 
 			DEBUG_INFO("%s: set chan=%d, 40M=%d, offset_2nd_chan=%d\n",
 				__FUNCTION__,
 				priv->pmib->dot11Bss.channel,
 				priv->pshare->is_40m_bw,  priv->pshare->offset_2nd_chan);
-
 		}
 		else {
 			priv->pshare->is_40m_bw = 0;
@@ -12695,7 +14836,22 @@ static unsigned int OnAssocRsp(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 	set_keymapping_wep(priv, pstat);
 #endif
 
-	add_update_RATid(priv, pstat);
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv)==VERSION_8188E) {
+#ifdef TXREPORT
+		add_RATid(priv, pstat);
+#endif
+	} else
+#endif
+	{
+		add_update_RATid(priv, pstat);
+	}
+
+#ifdef P2P_SUPPORT
+	if ((OPMODE & WIFI_P2P_SUPPORT) && (P2PMODE == P2P_CLIENT))
+		RTL_W32(RCR, RTL_R32(RCR) | RCR_CBSSID_ADHOC);
+#endif
+
 
 #ifdef WIFI_WPAS
 	//printk("_Eric WPAS_REGISTERED at %s %d\n", __FUNCTION__, __LINE__);
@@ -12714,6 +14870,14 @@ static unsigned int OnAssocRsp(struct rtl8192cd_priv *priv, struct rx_frinfo *pf
 	}
 #endif
 
+#ifdef CLIENT_MODE
+	if ((OPMODE & WIFI_STATION_STATE) && pstat->is_broadcom_sta) {
+		if (priv->pmib->dot11RFEntry.phyBandSelect & PHY_BAND_5G) { 
+			RTL_W8(0x51a, 0x0f);
+		}
+	}
+#endif
+
 	return SUCCESS;
 
 assoc_rejected:
@@ -12751,6 +14915,13 @@ static unsigned int OnBeaconClnt_Bss(struct rtl8192cd_priv *priv, struct rx_frin
 	unsigned int i, vo_txop=0, vi_txop=0, be_txop=0, bk_txop=0;
 	unsigned long flags;
 #endif
+#ifdef P2P_SUPPORT
+	unsigned char *ptr;
+	static	unsigned char ReAssem_p2pie[MAX_REASSEM_P2P_IE];
+	int IEfoundtimes=0;
+	unsigned char *p2pIEPtr = ReAssem_p2pie ;
+	int p2pIElen=0;
+#endif
 
 	pframe = get_pframe(pfrinfo);
 	bssid = GetAddr3Ptr(pframe);
@@ -12775,7 +14946,7 @@ static unsigned int OnBeaconClnt_Bss(struct rtl8192cd_priv *priv, struct rx_frin
 				pfrinfo->pktlen - WLAN_HDR_A3_LEN - _BEACON_IE_OFFSET_);
 			if (p != NULL)
 				channel = *(p+2);
-			if (channel) {
+			if (channel && (channel <= 14)) {
 				priv->bg_ap_timeout = 180;
 				priv->bg_ap_timeout_ch[channel-1] = 180;
 				channel = 0;
@@ -12820,6 +14991,27 @@ static unsigned int OnBeaconClnt_Bss(struct rtl8192cd_priv *priv, struct rx_frin
 		}
 	}
 
+	if (priv->ps_state) {
+		p = get_ie(pframe + WLAN_HDR_A3_LEN + _BEACON_IE_OFFSET_, _TIM_IE_, &len,
+			pfrinfo->pktlen - WLAN_HDR_A3_LEN - _BEACON_IE_OFFSET_);
+		if (p != NULL) {
+			if (isOurFrameBuffred(p, priv->aid) == TRUE) {
+#if defined(WIFI_WMM) && defined(WMM_APSD)
+				if (QOS_ENABLE && APSD_ENABLE && priv->uapsd_assoc) {
+					if (!(priv->pmib->dot11QosEntry.UAPSD_AC_BE && 
+						priv->pmib->dot11QosEntry.UAPSD_AC_BK && 
+						priv->pmib->dot11QosEntry.UAPSD_AC_VI && 
+						priv->pmib->dot11QosEntry.UAPSD_AC_VO))
+						issue_PsPoll(priv);
+				} else
+#endif
+				{
+					issue_PsPoll(priv);
+				}
+			}
+		}
+	}
+
 	if (val16 & BIT(5))
 		pstat->useShortPreamble = 1;
 	else
@@ -12866,27 +15058,38 @@ static unsigned int OnBeaconClnt_Bss(struct rtl8192cd_priv *priv, struct rx_frin
 
 			priv->ht_protection = 0;
 			if (!priv->pmib->dot11StationConfigEntry.protectionDisabled && pstat->ht_ie_len) {
-				if ((pstat->ht_ie_buf.info1 & cpu_to_le16(_HTIE_OP_MODE1_)) ||
-					(pstat->ht_ie_buf.info1 & cpu_to_le16(_HTIE_OP_MODE3_)))
+				unsigned int prot_mode =  (cpu_to_le16(pstat->ht_ie_buf.info1) & 0x03);
+				if (prot_mode == _HTIE_OP_MODE1_ || prot_mode == _HTIE_OP_MODE3_)
 					priv->ht_protection = 1;
 			}
 		}
 
+		//if ((priv->beacon_period > 200) || ((priv->rxBeaconNumInPeriod % 3) == 0)) {
 		p = get_ie(pframe + WLAN_HDR_A3_LEN + _BEACON_IE_OFFSET_, _HT_CAP_, &len,
 				pfrinfo->pktlen - WLAN_HDR_A3_LEN - _BEACON_IE_OFFSET_);
 		if (p !=  NULL) {
 			struct ht_cap_elmt *ht_cap = (struct ht_cap_elmt *)(p+2);
-			unsigned char htcap_chwd_old = (pstat->ht_cap_buf.ht_cap_info & cpu_to_le16(_HTCAP_SUPPORT_CH_WDTH_))?1:0;
-			unsigned char htcap_chwd_cur = (ht_cap->ht_cap_info & cpu_to_le16(_HTCAP_SUPPORT_CH_WDTH_))?1:0;
-			priv->pshare->AP_BW = (((pstat->ht_cap_buf.ht_cap_info & cpu_to_le16(_HTCAP_SUPPORT_CH_WDTH_)) && pstat->ht_ie_buf.info0 & _HTIE_STA_CH_WDTH_) ? 1 : 0 );
-			if (priv->pshare->CurrentChannelBW != priv->pshare->AP_BW || (htcap_chwd_old != htcap_chwd_cur)) {
-				DEBUG_INFO("%s: AP has changed BW, reconnect...\n", __FUNCTION__);
-				goto ReConn;
+			int htcap_chwd_cur = 0;
+
+			if (OPMODE & WIFI_ASOC_STATE) {			
+				if ((ht_cap->ht_cap_info & cpu_to_le16(_HTCAP_SUPPORT_CH_WDTH_)) &&
+						(pstat->ht_ie_buf.info0 & _HTIE_STA_CH_WDTH_))
+					htcap_chwd_cur = 1;
+			
+				if (priv->pshare->AP_BW < 0)
+					priv->pshare->AP_BW = htcap_chwd_cur;
+				else {
+					if (priv->pshare->AP_BW != htcap_chwd_cur) {
+						DEBUG_INFO("%s: AP has changed BW, reconnect...\n", __FUNCTION__);
+						goto ReConn;
+					}
+				}
 			}
 		} else {
 			DEBUG_INFO("%s: AP HT capability missing, reconnect...\n", __FUNCTION__);
 			goto ReConn;
 		}
+		//}
 	}
 
 	/*
@@ -12925,6 +15128,22 @@ static unsigned int OnBeaconClnt_Bss(struct rtl8192cd_priv *priv, struct rx_frin
 					sta_config_EDCA_para(priv);
 					RESTORE_INT(flags);
 					DEBUG_INFO("Client mode EDCA updated from beacon\n");
+					DEBUG_INFO("BE: ACM %d, AIFSN %d, ECWmin %d, ECWmax %d, TXOP %d\n",
+						GET_STA_AC_BE_PARA.ACM, GET_STA_AC_BE_PARA.AIFSN,
+						GET_STA_AC_BE_PARA.ECWmin, GET_STA_AC_BE_PARA.ECWmax,
+						GET_STA_AC_BE_PARA.TXOPlimit);
+					DEBUG_INFO("VO: ACM %d, AIFSN %d, ECWmin %d, ECWmax %d, TXOP %d\n",
+						GET_STA_AC_VO_PARA.ACM, GET_STA_AC_VO_PARA.AIFSN,
+						GET_STA_AC_VO_PARA.ECWmin, GET_STA_AC_VO_PARA.ECWmax,
+						GET_STA_AC_VO_PARA.TXOPlimit);
+					DEBUG_INFO("VI: ACM %d, AIFSN %d, ECWmin %d, ECWmax %d, TXOP %d\n",
+						GET_STA_AC_VI_PARA.ACM, GET_STA_AC_VI_PARA.AIFSN,
+						GET_STA_AC_VI_PARA.ECWmin, GET_STA_AC_VI_PARA.ECWmax,
+						GET_STA_AC_VI_PARA.TXOPlimit);
+					DEBUG_INFO("BK: ACM %d, AIFSN %d, ECWmin %d, ECWmax %d, TXOP %d\n",
+						GET_STA_AC_BK_PARA.ACM, GET_STA_AC_BK_PARA.AIFSN,
+						GET_STA_AC_BK_PARA.ECWmin, GET_STA_AC_BK_PARA.ECWmax,
+						GET_STA_AC_BK_PARA.TXOPlimit);
 				}
 			}
 		}
@@ -12982,6 +15201,54 @@ static unsigned int OnBeaconClnt_Bss(struct rtl8192cd_priv *priv, struct rx_frin
 	}
 #endif
 
+#ifdef P2P_SUPPORT
+	if ((OPMODE&WIFI_P2P_SUPPORT) && (P2PMODE == P2P_CLIENT)) {
+		/*just  take care beacon come from my BSSID*/
+		if(!memcmp(BSSID,pfrinfo->sa,6)){
+		ptr = pframe + WLAN_HDR_A3_LEN + _BEACON_IE_OFFSET_;
+		len = 0;
+
+		/*support ReAssemble*/		
+		for (;;)
+		{
+			/* get P2P_IE */
+			ptr = get_ie(ptr, _P2P_IE_, &len,
+				pfrinfo->pktlen - WLAN_HDR_A3_LEN - _BEACON_IE_OFFSET_ - len);
+			
+			if (ptr) {
+				if (!memcmp(ptr+2, WFA_OUI_PLUS_TYPE, 4)) {
+
+					memcpy(p2pIEPtr , ptr+6 ,len - 4);
+					p2pIEPtr += (len - 4);
+					IEfoundtimes ++;
+					
+				}
+			}
+			else{
+				break;
+			}
+
+			ptr = ptr + len + 2;
+		}
+		
+		if(IEfoundtimes){
+			
+			//if(IEfoundtimes>1)
+			//	P2P_DEBUG("ReAssembly p2p IE\n");
+			
+			p2pIElen = (int)(((unsigned long)p2pIEPtr)-((unsigned long)ReAssem_p2pie));		
+			
+			if(p2pIElen > MAX_REASSEM_P2P_IE){
+				P2P_DEBUG("\n\n	reassemble P2P IE exceed MAX_REASSEM_P2P_IE , chk!!!\n\n");
+			}else{
+				P2P_client_on_beacon(priv, ReAssem_p2pie , p2pIElen , GetSequence(pframe));
+			}
+		}
+
+		}
+	}
+#endif
+
 	return SUCCESS;
 
 ReConn:
@@ -13280,14 +15547,26 @@ static unsigned int OnBeaconClnt_Ibss(struct rtl8192cd_priv *priv, struct rx_fri
 		pstat->expire_to = priv->expire_to;
 		list_add_tail(&pstat->asoc_list, &priv->asoc_list);
 		cnt_assoc_num(priv, pstat, INCREASE, (char *)__FUNCTION__);
-		check_sta_characteristic(priv, pstat, INCREASE);
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv)!=VERSION_8188E) 
+#endif
+			check_sta_characteristic(priv, pstat, INCREASE);
 		RESTORE_INT(flags);
 
 		LOG_MSG("An IBSS client is detected - %02X:%02X:%02X:%02X:%02X:%02X\n",
 			*GetAddr2Ptr(pframe), *(GetAddr2Ptr(pframe)+1), *(GetAddr2Ptr(pframe)+2),
 			*(GetAddr2Ptr(pframe+3)), *(GetAddr2Ptr(pframe)+4), *(GetAddr2Ptr(pframe)+5));
 
-		add_update_RATid(priv, pstat);
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv)==VERSION_8188E) {
+#ifdef TXREPORT
+			add_RATid(priv, pstat);
+#endif
+		} else
+#endif
+		{
+			add_update_RATid(priv, pstat);
+		}
 	}
 
 	if (timer_pending(&priv->idle_timer))
@@ -13315,7 +15594,16 @@ static unsigned int OnBeaconClnt(struct rtl8192cd_priv *priv, struct rx_frinfo *
 
 	// Site survey and collect information
 	if (OPMODE & WIFI_SITE_MONITOR) {
-		collect_bss_info(priv, pfrinfo);
+
+#ifdef P2P_SUPPORT
+		if( (OPMODE&WIFI_P2P_SUPPORT) && (P2PMODE == P2P_DEVICE) ){
+
+		}
+		else
+#endif
+		{
+			collect_bss_info(priv, pfrinfo);
+		}
 		return SUCCESS;
 	}
 
@@ -13323,6 +15611,10 @@ static unsigned int OnBeaconClnt(struct rtl8192cd_priv *priv, struct rx_frinfo *
 	if ((OPMODE & (WIFI_STATION_STATE | WIFI_ASOC_STATE)) ==
 		(WIFI_STATION_STATE | WIFI_ASOC_STATE))
 		ret = OnBeaconClnt_Bss(priv, pfrinfo);
+#if defined(WIFI_WMM) && defined(WMM_APSD)
+	else if (QOS_ENABLE && APSD_ENABLE && (OPMODE & WIFI_STATION_STATE) && !(OPMODE & WIFI_ASOC_STATE))
+		collect_bss_info(priv, pfrinfo);
+#endif
 
 	// Ad-hoc client mode, check peer's beacon
 	if ((OPMODE & WIFI_ADHOC_STATE) &&
@@ -13360,6 +15652,21 @@ static unsigned int OnDisassocClnt(struct rtl8192cd_priv *priv, struct rx_frinfo
 		memcpy(&val16, (pframe + WLAN_HDR_A3_LEN), 2);
 		DEBUG_INFO("recv Disassociation, reason: %d\n", le16_to_cpu(val16));
 
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv)==VERSION_8188E) {
+			struct stat_info *pstat = get_stainfo(priv, pfrinfo->da);
+
+			if (pstat
+#ifdef STA_EXT
+				&& (REMAP_AID(pstat) < (RTL8188E_NUM_STAT - 1))
+#endif
+				) {
+				RTL8188E_MACID_NOLINK(priv, 1, REMAP_AID(pstat));
+				RTL8188E_MACID_PAUSE(priv, 0, REMAP_AID(pstat));
+			}
+		}
+#endif
+
 		OPMODE &= ~(WIFI_AUTH_SUCCESS | WIFI_ASOC_STATE);
 		priv->join_res = STATE_Sta_No_Bss;
 
@@ -13555,6 +15862,18 @@ static unsigned int OnDeAuthClnt(struct rtl8192cd_priv *priv, struct rx_frinfo *
 		if (!list_empty(&pstat->asoc_list)) {
 			list_del_init(&pstat->asoc_list);
 			cnt_assoc_num(priv, pstat, DECREASE, (char *)__FUNCTION__);
+
+#ifdef CONFIG_RTL_88E_SUPPORT
+			if (GET_CHIP_VER(priv)==VERSION_8188E) {
+#ifdef STA_EXT
+				if (REMAP_AID(pstat) < (RTL8188E_NUM_STAT - 1))
+#endif
+				{
+					RTL8188E_MACID_NOLINK(priv, 1, REMAP_AID(pstat));
+					RTL8188E_MACID_PAUSE(priv, 0, REMAP_AID(pstat));
+				}
+			}
+#endif
 		}
 		RESTORE_INT(flags);
 
@@ -13593,6 +15912,114 @@ do_scan:
 
 	return SUCCESS;
 }
+
+
+static void issue_PwrMgt_NullData(struct rtl8192cd_priv *priv)
+{
+	struct wifi_mib *pmib;
+	unsigned char *hwaddr;
+	DECLARE_TXINSN(txinsn);
+
+	pmib = GET_MIB(priv);
+	txinsn.retry = pmib->dot11OperationEntry.dot11ShortRetryLimit;
+	hwaddr = pmib->dot11OperationEntry.hwaddr;
+
+	txinsn.q_num = MANAGE_QUE_NUM;
+	txinsn.tx_rate = find_rate(priv, NULL, 0, 1);
+	txinsn.lowest_tx_rate = txinsn.tx_rate;
+	txinsn.fixed_rate = 1;
+	txinsn.phdr = get_wlanhdr_from_poll(priv);
+	txinsn.pframe = NULL;
+
+	if (txinsn.phdr == NULL)
+		goto send_fail;
+
+	memset((void *)(txinsn.phdr), 0, sizeof (struct	wlan_hdr));
+
+	SetFrameSubType(txinsn.phdr, WIFI_DATA_NULL);
+	SetToDs(txinsn.phdr);
+	if (priv->ps_state)
+		SetPwrMgt(txinsn.phdr);
+	else
+		ClearPwrMgt(txinsn.phdr);
+
+	memcpy((void *)GetAddr1Ptr((txinsn.phdr)), BSSID, MACADDRLEN);
+	memcpy((void *)GetAddr2Ptr((txinsn.phdr)), hwaddr, MACADDRLEN);
+	memcpy((void *)GetAddr3Ptr((txinsn.phdr)),  BSSID, MACADDRLEN);
+	txinsn.hdr_len = WLAN_HDR_A3_LEN;
+
+	if ((rtl8192cd_firetx(priv, &txinsn)) == SUCCESS)
+		return;
+
+send_fail:
+
+	if (txinsn.phdr)
+		release_wlanhdr_to_poll(priv, txinsn.phdr);
+}
+
+
+void issue_PsPoll(struct rtl8192cd_priv *priv)
+{
+	struct wifi_mib *pmib;
+	unsigned char *hwaddr;
+	DECLARE_TXINSN(txinsn);
+
+	pmib = GET_MIB(priv);
+	txinsn.retry = pmib->dot11OperationEntry.dot11ShortRetryLimit;
+	hwaddr = pmib->dot11OperationEntry.hwaddr;
+
+	txinsn.q_num = MANAGE_QUE_NUM;
+	txinsn.tx_rate = find_rate(priv, NULL, 0, 1);
+	txinsn.lowest_tx_rate = txinsn.tx_rate;
+	txinsn.fixed_rate = 1;
+	txinsn.phdr = get_wlanhdr_from_poll(priv);
+	txinsn.pframe = NULL;
+
+	if (txinsn.phdr == NULL)
+		goto send_fail;
+
+	memset((void *)(txinsn.phdr), 0, sizeof (struct	wlan_hdr));
+
+	SetFrameSubType(txinsn.phdr, WIFI_PSPOLL);
+	SetPwrMgt(txinsn.phdr);
+	SetPsPollAid(txinsn.phdr, priv->aid);
+
+	memcpy((void *)GetAddr1Ptr((txinsn.phdr)), BSSID, MACADDRLEN);
+	memcpy((void *)GetAddr2Ptr((txinsn.phdr)), hwaddr, MACADDRLEN);
+	txinsn.hdr_len = WLAN_HDR_PSPOLL;
+
+	if ((rtl8192cd_firetx(priv, &txinsn)) == SUCCESS)
+		return;
+
+send_fail:
+
+	if (txinsn.phdr)
+		release_wlanhdr_to_poll(priv, txinsn.phdr);
+}
+
+
+static unsigned int isOurFrameBuffred(unsigned char* tim, unsigned int aid)
+{
+	unsigned int numSta;
+	
+	numSta = (*(tim + 4) & 0xFE) * 8;
+	if (!((aid < numSta) || (aid >= (numSta + (*(tim + 1)-3)*8)))) {
+		unsigned int offset;
+		unsigned int offset_byte;
+		unsigned int offset_bit;
+		unsigned char *PartialBitmap = tim + 5;
+		unsigned int result;
+
+		offset = aid - numSta;
+		offset_byte = offset / 8;
+		offset_bit  = offset % 8;
+		result = PartialBitmap[offset_byte] & (1 << offset_bit);
+
+		return (result) ? TRUE : FALSE;
+	}
+
+	return FALSE;
+}
 #endif // CLIENT_MODE
 
 
@@ -13687,10 +16114,17 @@ static void set_sw_LED0(struct rtl8192cd_priv *priv, int flag)
 		set_swGpio_LED(priv, 0, flag);
 #else
 
+#if defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT)
 	if (flag)
 		RTL_W32(LEDCFG, (RTL_R32(LEDCFG) & 0xfffffff0) | LED0SV);
 	else
 		RTL_W32(LEDCFG, RTL_R32(LEDCFG) & 0xfffffff0);
+#elif defined(CONFIG_RTL_88E_SUPPORT)
+	if (flag)
+		RTL_W32(GPIO_PIN_CTRL, (RTL_R32(GPIO_PIN_CTRL) | 0x00002000));
+	else
+		RTL_W32(GPIO_PIN_CTRL, (RTL_R32(GPIO_PIN_CTRL) & ~(0x00002000)));
+#endif
 #endif
 }
 
@@ -13702,6 +16136,7 @@ static void set_sw_LED1(struct rtl8192cd_priv *priv, int flag)
 		set_swGpio_LED(priv, 1, flag);
 #else
 
+#if defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT)
 #ifdef CONFIG_RTL_92D_SUPPORT
 	if (GET_CHIP_VER(priv) == VERSION_8192D) {
 		if (flag)
@@ -13717,6 +16152,7 @@ static void set_sw_LED1(struct rtl8192cd_priv *priv, int flag)
 			RTL_W32(LEDCFG, RTL_R32(LEDCFG) & 0xfffff0ff);
 	}
 #endif
+#endif
 }
 
 
@@ -13727,17 +16163,20 @@ static void set_sw_LED2(struct rtl8192cd_priv *priv, int flag)
 		set_swGpio_LED(priv, 2, flag);
 #else
 
+#if defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT)
 	if (flag)
 		RTL_W32(LEDCFG, (RTL_R32(LEDCFG) & 0xfff0ffff) | LED2SV);
 	else
 		RTL_W32(LEDCFG, RTL_R32(LEDCFG) & 0xfff0ffff);
 #endif
+#endif
 }
 
 
 static void LED_Interval_timeout(unsigned long task_priv)
 {
 	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *)task_priv;
+	int led_on_time= LED_ON_TIME;
 
 	if (!(priv->drv_state & DRV_STATE_OPEN))
 		return;
@@ -13751,14 +16190,19 @@ static void LED_Interval_timeout(unsigned long task_priv)
 			(LED_TYPE == LEDTYPE_SW_ENABLETXRXDATA) ||
 			((LED_TYPE == LEDTYPE_SW_ADATA_GDATA) && (priv->pshare->curr_band == BAND_5G)) ||
 			(LED_TYPE == LEDTYPE_SW_LED2_GPIO8_LINKTXRX) ||
+			(LED_TYPE == LEDTYPE_SW_LED2_GPIO8_ENABLETXRXDATA) ||
+			(LED_TYPE == LEDTYPE_SW_LED2_GPIO8_ASOCTXRXDATA) ||  
 			(LED_TYPE == LEDTYPE_SW_LED2_GPIO10_LINKTXRX) ||
 			(LED_TYPE == LEDTYPE_SW_LED1_GPIO10_LINKTXRX) ||
-			(LED_TYPE == LEDTYPE_SW_LED2_GPIO8_ENABLETXRXDATA)||
+			(LED_TYPE == LEDTYPE_SW_LED2_GPIO8_LINKTXRXDATA) ||
 			(LED_TYPE == LEDTYPE_SW_LED1_ENABLETXRXDATA)) 
 		{
 			if (!priv->pshare->set_led_in_progress) {
-				if ((LED_TYPE == LEDTYPE_SW_LED2_GPIO8_LINKTXRX) || (LED_TYPE == LEDTYPE_SW_LED2_GPIO10_LINKTXRX) ||
-					(LED_TYPE == LEDTYPE_SW_LED2_GPIO8_ENABLETXRXDATA))
+				if ((LED_TYPE == LEDTYPE_SW_LED2_GPIO8_LINKTXRX) ||
+					(LED_TYPE == LEDTYPE_SW_LED2_GPIO8_ENABLETXRXDATA) ||
+					(LED_TYPE == LEDTYPE_SW_LED2_GPIO8_ASOCTXRXDATA) || 
+					(LED_TYPE == LEDTYPE_SW_LED2_GPIO10_LINKTXRX) ||
+					(LED_TYPE == LEDTYPE_SW_LED2_GPIO8_LINKTXRXDATA))
 					set_sw_LED2(priv, priv->pshare->LED_Toggle);
 				else if (LED_TYPE == LEDTYPE_SW_LED1_GPIO10_LINKTXRX || LED_TYPE == LEDTYPE_SW_LED1_ENABLETXRXDATA)
 					set_sw_LED1(priv, priv->pshare->LED_Toggle);
@@ -13771,13 +16215,19 @@ static void LED_Interval_timeout(unsigned long task_priv)
 		}
 	}
 
+	if( (LED_TYPE == LEDTYPE_SW_LED2_GPIO8_ASOCTXRXDATA) && 
+	    (!(OPMODE & WIFI_ASOC_STATE)))  //client not assco  , mark_led
+	{		
+		led_on_time = LED_NOBLINK_TIME;
+	}
+
 	if ( priv->pshare->LED_Toggle == priv->pshare->LED_ToggleStart) {
 		mod_timer(&priv->pshare->LED_Timer, jiffies + priv->pshare->LED_Interval);
 	} else {
 		if 	(LED_TYPE == LEDTYPE_SW_CUSTOM1)
 			mod_timer(&priv->pshare->LED_Timer, jiffies + priv->pshare->LED_Interval);
 		else
-			mod_timer(&priv->pshare->LED_Timer, jiffies + LED_ON_TIME);
+			mod_timer(&priv->pshare->LED_Timer, jiffies + led_on_time); 
 	}
 
 	priv->pshare->LED_Toggle = (priv->pshare->LED_Toggle + 1) % 2;
@@ -13786,7 +16236,12 @@ static void LED_Interval_timeout(unsigned long task_priv)
 
 void enable_sw_LED(struct rtl8192cd_priv *priv, int init)
 {
+	if (LED_TYPE == LEDTYPE_SW_LED2_GPIO8_ASOCTXRXDATA) 
+		if (!(OPMODE & WIFI_STATION_STATE)) // if it is not Client mode , then run orignal 12 type
+			LED_TYPE = LEDTYPE_SW_LED2_GPIO8_ENABLETXRXDATA ;  
+	     
 	// configure mac to use SW LED
+#if defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT)
 	if (LED_TYPE == LEDTYPE_SW_LED2_GPIO10_LINKTXRX)
 		RTL_W32(LEDCFG, LED2EN | LED2SV);
 #ifdef CONFIG_RTL_92D_SUPPORT
@@ -13794,10 +16249,15 @@ void enable_sw_LED(struct rtl8192cd_priv *priv, int init)
 		RTL_W32(LEDCFG, LED1DIS_92D | LED1SV_92D);
 #endif
 	else if ((LED_TYPE == LEDTYPE_SW_LED2_GPIO8_LINKTXRX) ||
-		(LED_TYPE == LEDTYPE_SW_LED2_GPIO8_ENABLETXRXDATA))
-		RTL_W32(LEDCFG, GP8_LED | LED2EN | LED2SV);
+		(LED_TYPE == LEDTYPE_SW_LED2_GPIO8_ENABLETXRXDATA) ||
+		(LED_TYPE == LEDTYPE_SW_LED2_GPIO8_ASOCTXRXDATA) || 	
+		(LED_TYPE == LEDTYPE_SW_LED2_GPIO8_LINKTXRXDATA))
+		RTL_W32(LEDCFG, (RTL_R32(LEDCFG)&0xFF00FFFF) | GP8_LED | LED2EN | LED2SV);
 	else
-	RTL_W32(LEDCFG, LED2SV | LED1SV | LED0SV);
+		RTL_W32(LEDCFG, LED2SV | LED1SV | LED0SV);
+#elif defined(CONFIG_RTL_88E_SUPPORT)
+	RTL_W32(GPIO_PIN_CTRL, (RTL_R32(GPIO_PIN_CTRL) | 0x20200000));
+#endif
 
 	priv->pshare->LED_Interval = LED_INTERVAL_TIME;
 	priv->pshare->LED_Toggle = 0;
@@ -13833,7 +16293,8 @@ void enable_sw_LED(struct rtl8192cd_priv *priv, int init)
 		set_sw_LED1(priv, LED_ON);
 		priv->pshare->LED_ToggleStart = LED_ON;
 	}
-	else if (LED_TYPE == LEDTYPE_SW_LED2_GPIO8_ENABLETXRXDATA) {
+	else if ((LED_TYPE == LEDTYPE_SW_LED2_GPIO8_ENABLETXRXDATA) ||
+		(LED_TYPE == LEDTYPE_SW_LED2_GPIO8_ASOCTXRXDATA) ) {
 		set_sw_LED2(priv, LED_ON);
 		priv->pshare->LED_ToggleStart = LED_ON;
 	}
@@ -13872,6 +16333,15 @@ void calculate_sw_LED_interval(struct rtl8192cd_priv *priv)
 	if (priv->pshare->set_led_in_progress)
 		return;
 
+	if( (LED_TYPE == LEDTYPE_SW_LED2_GPIO8_ASOCTXRXDATA) && 
+	    (!(OPMODE & WIFI_ASOC_STATE)))  //client not assco  , mark_led
+      {        
+      	 priv->pshare->LED_Interval = LED_NOBLINK_TIME; // force one second
+      	 priv->pshare->LED_tx_cnt_log = priv->pshare->LED_tx_cnt; // sync tx/rx cnt
+	 priv->pshare->LED_rx_cnt_log = priv->pshare->LED_rx_cnt;      
+	 return ;
+      }
+
 	// calculate counter delta
 	delta += UINT32_DIFF(priv->pshare->LED_tx_cnt, priv->pshare->LED_tx_cnt_log);
 	delta += UINT32_DIFF(priv->pshare->LED_rx_cnt, priv->pshare->LED_rx_cnt_log);
@@ -13900,8 +16370,10 @@ void calculate_sw_LED_interval(struct rtl8192cd_priv *priv)
 
 		if ((LED_TYPE == LEDTYPE_SW_LINK_TXRX) ||
 			(LED_TYPE == LEDTYPE_SW_LINKTXRX) ||
-			(LED_TYPE == LEDTYPE_SW_LED2_GPIO8_LINKTXRX) || (LED_TYPE == LEDTYPE_SW_LED2_GPIO10_LINKTXRX) ||
+			(LED_TYPE == LEDTYPE_SW_LED2_GPIO8_LINKTXRX) ||
+			(LED_TYPE == LEDTYPE_SW_LED2_GPIO10_LINKTXRX) ||
 			(LED_TYPE == LEDTYPE_SW_LED1_GPIO10_LINKTXRX) ||
+			(LED_TYPE == LEDTYPE_SW_LED2_GPIO8_LINKTXRXDATA) ||
 			(LED_TYPE == LEDTYPE_SW_CUSTOM1))
 			scale_num = scale_num*2;
 
@@ -13924,8 +16396,10 @@ void calculate_sw_LED_interval(struct rtl8192cd_priv *priv)
 
 	if ((LED_TYPE == LEDTYPE_SW_LINKTXRX) ||
 		(LED_TYPE == LEDTYPE_SW_LINKTXRXDATA) ||
-		(LED_TYPE == LEDTYPE_SW_LED2_GPIO8_LINKTXRX) || (LED_TYPE == LEDTYPE_SW_LED2_GPIO10_LINKTXRX) ||
-		(LED_TYPE == LEDTYPE_SW_LED1_GPIO10_LINKTXRX)) {
+		(LED_TYPE == LEDTYPE_SW_LED2_GPIO8_LINKTXRX) ||
+		(LED_TYPE == LEDTYPE_SW_LED2_GPIO10_LINKTXRX) ||
+		(LED_TYPE == LEDTYPE_SW_LED1_GPIO10_LINKTXRX) ||
+		(LED_TYPE == LEDTYPE_SW_LED2_GPIO8_LINKTXRXDATA)) {
 		if (priv->link_status)
 			priv->pshare->LED_ToggleStart = LED_ON;
 		else
@@ -14055,10 +16529,25 @@ void control_wireless_led(struct rtl8192cd_priv *priv, int enable)
 
 
 #ifdef DFS
+
+void rtl8192cd_dfs_chk_timer(unsigned long task_priv)
+{
+	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *)task_priv;
+	if (timer_pending(&priv->dfs_chk_timer)){
+		del_timer_sync(&priv->dfs_chk_timer);
+	}
+	
+	PHY_SetBBReg(priv, 0xcdc, BIT(8)|BIT(9), 1);
+	PRINT_INFO("DFS CP END.\n");
+}
+
+
 void rtl8192cd_DFS_timer(unsigned long task_priv)
 {
 	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *)task_priv;
 	unsigned int radar_type = 0;	/* 0 for short, 1 for long */
+	unsigned int dfs_chk;
+	int tp_th = ((priv->pshare->is_40m_bw)?45:20);
 
 	if (!(priv->drv_state & DRV_STATE_OPEN))
 		return;
@@ -14067,13 +16556,20 @@ void rtl8192cd_DFS_timer(unsigned long task_priv)
 	if ((priv->pwr_state == L2) || (priv->pwr_state == L1))
 		goto exit_timer;
 #endif
+	if (((priv->ext_stats.tx_avarage+priv->ext_stats.rx_avarage)>>17)>tp_th){
+		dfs_chk = 1;
+		PHY_SetBBReg(priv, 0xcdc, BIT(8)|BIT(9), 0);
+	}else{
+		dfs_chk = 0;
+		PHY_SetBBReg(priv, 0xcdc, BIT(8)|BIT(9), 1);
+	}
 
 	if (!(priv->pmib->dot11StationConfigEntry.dot11RegDomain == DOMAIN_ETSI))
 	{
-	if (PHY_QueryBBReg(priv, 0xcf8, BIT(31))) {
-		radar_type++;
-		priv->pmib->dot11DFSEntry.DFS_detected = 1;
-	}
+		if (PHY_QueryBBReg(priv, 0xcf8, BIT(31))) {
+			radar_type++;
+			priv->pmib->dot11DFSEntry.DFS_detected = 1;
+		}
 	}
 
 	if (PHY_QueryBBReg(priv, 0xcf8, BIT(23)))
@@ -14088,8 +16584,8 @@ void rtl8192cd_DFS_timer(unsigned long task_priv)
 			priv->pshare->rf_ft_var.dfsdbgcnt = 1;
 		else
 			priv->pshare->rf_ft_var.dfsdbgcnt++;
-		panic_printk("[%d] DFS dbg mode, Radar is detected as %x%x !\n", priv->pshare->rf_ft_var.dfsdbgcnt,
-			radar_type, PHY_QueryBBReg(priv, 0xcf4, bMaskDWord)&0xffff);
+		panic_printk("[%d] DFS dbg mode, Radar is detected as %x%x (%d)!\n", priv->pshare->rf_ft_var.dfsdbgcnt,
+			radar_type, PHY_QueryBBReg(priv, 0xcf4, bMaskDWord)&0xffff, RTL_JIFFIES_TO_MILISECONDS(jiffies));
 		priv->pshare->rf_ft_var.dfsrctime = jiffies;
 		priv->pmib->dot11DFSEntry.DFS_detected = 0;
 		PHY_SetBBReg(priv, 0xc84, BIT(25), 0);
@@ -14098,9 +16594,33 @@ void rtl8192cd_DFS_timer(unsigned long task_priv)
 	}
 
 	if (!priv->pmib->dot11DFSEntry.disable_DFS && priv->pmib->dot11DFSEntry.DFS_detected) {
+
+		PRINT_INFO("Radar is detected as %x%x (%d)!\n", radar_type, PHY_QueryBBReg(priv, 0xcf4, bMaskDWord)&0xffff, RTL_JIFFIES_TO_MILISECONDS(jiffies));
+		
+		if (timer_pending(&priv->dfs_chk_timer)){
+			del_timer_sync(&priv->dfs_chk_timer);
+			PHY_SetBBReg(priv, 0xcdc, BIT(8)|BIT(9), 1);
+			PRINT_INFO("DFS CP2. Switch channel!\n");
+		}else{
+			if (dfs_chk){
+				// reset dfs flag and counter
+				priv->pmib->dot11DFSEntry.DFS_detected = 0;
+				PHY_SetBBReg(priv, 0xc84, BIT(25), 0);
+				PHY_SetBBReg(priv, 0xc84, BIT(25), 1);
+				
+				PRINT_INFO("DFS CP1.\n");
+				init_timer(&priv->dfs_chk_timer);
+				priv->dfs_chk_timer.data = (unsigned long) priv;
+				priv->dfs_chk_timer.function = rtl8192cd_dfs_chk_timer;
+				
+				mod_timer(&priv->dfs_chk_timer, jiffies + RTL_SECONDS_TO_JIFFIES(300));
+
+				goto exit_timer;
+			}
+		}
+		
 		RTL_W8(TXPAUSE, 0xf);	/* disable transmitter */
 		priv->pmib->dot11DFSEntry.disable_tx = 1;
-		PRINT_INFO("Radar is detected as %x%x !\n", radar_type, PHY_QueryBBReg(priv, 0xcf4, bMaskDWord)&0xffff);
 
 		if (timer_pending(&priv->ch_avail_chk_timer)) {
 			del_timer_sync(&priv->ch_avail_chk_timer);
@@ -14467,91 +16987,35 @@ unsigned int DFS_SelectChannel(struct rtl8192cd_priv *priv)
 	unsigned int num, random_base, which_channel;
 	int reg = priv->pmib->dot11StationConfigEntry.dot11RegDomain;
 
-	if (priv->pshare->CurrentChannelBW == HT_CHANNEL_WIDTH_20){
-		if (reg == DOMAIN_FCC)
-			random_base = 9;
-		else if (reg == DOMAIN_IC)
-			random_base = 8;
-		else
-			random_base = 4;
-
+	if (priv->pshare->CurrentChannelBW == HT_CHANNEL_WIDTH_20) {
 		get_random_bytes(&random, 1);
-		num = random % random_base;
-
-		switch(num) {
-		case 0:
-			which_channel = 36;
-			break;
-		case 1:
-			which_channel = 40;
-			break;
-		case 2:
-			which_channel = 44;
-			break;
-		case 3:
-			which_channel = 48;
-			break;
-		case 4:
-			which_channel = 149;
-			break;
-		case 5:
-			which_channel = 153;
-			break;
-		case 6:
-			which_channel = 157;
-			break;
-		case 7:
-			which_channel = 161;
-			break;
-		case 8:
-			which_channel = 165;
-		default:
-			which_channel = 36;
-			break;
-		}
-	}else{
+		num = random % priv->Not_DFS_chnl_num;
+		which_channel = priv->Not_DFS_chnl[num];
+	} else {
 		//40M
 		if (reg == DOMAIN_FCC)
 			random_base = 4;
 		else if (reg == DOMAIN_IC)
 			random_base = 4;
+		else if (reg == DOMAIN_NCC)
+			random_base = 3;
 		else
 			random_base = 2;
 
 		get_random_bytes(&random, 1);
 		num = random % random_base;
 
-		switch(num) {
-		case 0:
-			if (priv->pshare->offset_2nd_chan == HT_2NDCH_OFFSET_BELOW)
-				which_channel = 40;
-			else
-				which_channel = 36;
-			break;
-		case 1:
-			if (priv->pshare->offset_2nd_chan == HT_2NDCH_OFFSET_BELOW)
-				which_channel = 48;
-			else
-				which_channel = 44;
-			break;
-		case 2:
-			if (priv->pshare->offset_2nd_chan == HT_2NDCH_OFFSET_BELOW)
-				which_channel = 153;
-			else
-				which_channel = 149;
-			break;
-		case 3:
+		if (reg == DOMAIN_NCC) {
 			if (priv->pshare->offset_2nd_chan == HT_2NDCH_OFFSET_BELOW)
-				which_channel = 161;
+				which_channel = priv->Not_DFS_chnl[num*2+2];
 			else
-				which_channel = 157;
-			break;
-		default:
+				which_channel = priv->Not_DFS_chnl[num*2+1];
+		}
+		else {
 			if (priv->pshare->offset_2nd_chan == HT_2NDCH_OFFSET_BELOW)
-				which_channel = 48;
+				which_channel = priv->Not_DFS_chnl[num*2+1];
 			else
-				which_channel = 44;
-			break;
+				which_channel = priv->Not_DFS_chnl[num*2];
 		}
 	}
 
@@ -14637,12 +17101,14 @@ void DFS_SwChnl_clnt(struct rtl8192cd_priv *priv)
 
 			panic_printk("Switched to DFS band (ch %d) again!!\n", priv->pmib->dot11RFEntry.dot11channel);
 
-	 } else {
-	 	if (GET_CHIP_VER(priv) == VERSION_8192D)
-			PHY_IQCalibrate(priv);
 	 }
-	
-		
+
+#ifdef CONFIG_RTL_92D_SUPPORT
+	if ((GET_CHIP_VER(priv) == VERSION_8192D) && (priv->pmib->dot11Bss.channel > 14)) {
+		priv->pshare->iqk_5g_done = 0;
+		PHY_IQCalibrate(priv);
+	}
+#endif
 }
 
 
@@ -14687,19 +17153,61 @@ void DFS_SetReg(struct rtl8192cd_priv *priv)
 
 	if (priv->pmib->dot11StationConfigEntry.dot11RegDomain == DOMAIN_ETSI) {
 		PHY_SetBBReg(priv, 0xc8c, BIT(23) | BIT(22), 3);
+		PHY_SetBBReg(priv, 0xc30, 0xf, 0xa);
 		PHY_SetBBReg(priv, 0xcdc, 0xf0000, 4);
+		PHY_SetBBReg(priv, 0xcd8, 0xf0000, 0x3);
 	} else {
 		PHY_SetBBReg(priv, 0xc8c, BIT(23) | BIT(22), 0);
 		PHY_SetBBReg(priv, 0xcd8, 0xffff, 0x1a1f);
+		PHY_SetBBReg(priv, 0xcd8, 0xf0000, 0x4);
 	}
 
-	if (!priv->pshare->rf_ft_var.dfsdbgmode)
-		PHY_SetBBReg(priv, 0xc7c, BIT(28), 1); // ynlin dbg
-		
 	/*
 	 *	Enable h/w DFS detect
 	 */
 	PHY_SetBBReg(priv, 0xc84, BIT(25), 1);
+
+	if (!priv->pshare->rf_ft_var.dfsdbgmode){
+		PHY_SetBBReg(priv, 0xc7c, BIT(28), 1); // ynlin dbg
+	}
+
 }
 #endif
 
+
+#ifdef SMART_REPEATER_MODE
+void check_vxd_ap_timer(unsigned long task_priv)
+{
+	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *)task_priv;
+	unsigned long flags;
+	unsigned int timeout = CHECK_VXD_AP_TIMEOUT;
+
+	SAVE_INT_AND_CLI(flags);
+	SMP_LOCK(flags);
+
+	if (GET_VXD_PRIV(priv) &&
+		(GET_VXD_PRIV(priv)->drv_state & DRV_STATE_VXD_INIT) && 
+			netif_running(GET_VXD_PRIV(priv)->dev)) {			
+		if (!(GET_MIB(GET_VXD_PRIV(priv))->dot11OperationEntry.opmode & WIFI_ASOC_STATE)) {			
+			if (!netif_running(priv->dev) || priv->ss_req_ongoing) {				
+				timeout = RTL_SECONDS_TO_JIFFIES(1);
+				goto out;
+			}
+			priv->ss_ssidlen = 0;			
+			priv->ss_req_ongoing = 3;
+			priv->pshare->switch_chan_rp = 0;		
+			start_clnt_ss(priv);			
+			timeout = 0;
+		}
+	}
+
+out:
+	if (timeout)	
+		mod_timer(&priv->pshare->check_vxd_ap, jiffies + timeout);	
+	
+	RESTORE_INT(flags);
+	SMP_UNLOCK(flags);	
+}
+#endif /* SMART_REPEATER_MODE */
+
+
diff --git a/drivers/net/wireless/rtl8192cd/8192cd_tx.c b/drivers/net/wireless/rtl8192cd/8192cd_tx.c
index 6aaf3da..d68f950 100644
--- a/drivers/net/wireless/rtl8192cd/8192cd_tx.c
+++ b/drivers/net/wireless/rtl8192cd/8192cd_tx.c
@@ -64,14 +64,34 @@ unsigned int PRI_TO_QNUM(struct rtl8192cd_priv *priv, int priority)
 		return priv->pmib->dot11QosEntry.TID_mapping[priority];
 	}
 	else {
-		if ((priority == 0) || (priority == 3))
-			return BE_QUEUE;
-		else if ((priority == 7) || (priority == 6))
-			return VO_QUEUE;
-		else if ((priority == 5) || (priority == 4))
-			return VI_QUEUE;
-		else
+		if ((priority == 0) || (priority == 3)) {
+			if (!((OPMODE & WIFI_STATION_STATE) && GET_STA_AC_BE_PARA.ACM))
+				return BE_QUEUE;
+			else
+				return BK_QUEUE;
+		} else if ((priority == 7) || (priority == 6)) {
+			if (!((OPMODE & WIFI_STATION_STATE) && GET_STA_AC_VO_PARA.ACM)) {
+				return VO_QUEUE;
+			} else {
+				if (!GET_STA_AC_VI_PARA.ACM)
+					return VI_QUEUE;
+				else if (!GET_STA_AC_BE_PARA.ACM)
+					return BE_QUEUE;
+				else
+					return BK_QUEUE;
+			}
+		} else if ((priority == 5) || (priority == 4)) {
+			if (!((OPMODE & WIFI_STATION_STATE) && GET_STA_AC_VI_PARA.ACM)) {
+				return VI_QUEUE;
+			} else {
+				if (!GET_STA_AC_BE_PARA.ACM) 
+					return BE_QUEUE;
+				else
+					return BK_QUEUE;
+			}
+		} else {
 			return BK_QUEUE;
+		}
 	}
 }
 #else
@@ -96,6 +116,11 @@ extern struct port_map wlanDev[RTL8192CD_NUM_VWLAN+1];
 extern int g_port_mapping;
 #endif
 
+
+#ifdef CONFIG_RTL_WAPI_SUPPORT
+extern void SecSWSMS4Encryption(struct rtl8192cd_priv  *priv, struct tx_insn* txcfg);
+#endif
+
 #ifdef STA_EXT
 extern unsigned short MCS_DATA_RATE[2][2][16];
 
@@ -136,11 +161,21 @@ unsigned int get_tx_rate(struct rtl8192cd_priv *priv, struct stat_info *pstat)
 {
 #ifdef STA_EXT
 	if (priv->pmib->dot11StationConfigEntry.autoRate
-		&& pstat->remapped_aid < FW_NUM_STAT-1/*!(priv->STA_map & BIT(pstat->aid)*/
-		) {
-			return pstat->current_tx_rate;
+		&& pstat->remapped_aid < 
+#ifdef CONFIG_RTL_88E_SUPPORT
+		(GET_CHIP_VER(priv)==VERSION_8188E)?(RTL8188E_NUM_STAT-1):
+#endif
+		(FW_NUM_STAT-1)/*!(priv->STA_map & BIT(pstat->aid)*/
+	) {
+		if (priv->pmib->dot11RFEntry.txbf == 1)
+			check_txrate_by_reg(priv, pstat);
+		return pstat->current_tx_rate;
 	} else {
-		if (pstat->remapped_aid == FW_NUM_STAT-1/*(priv->STA_map & BIT(pstat->aid)) != 0*/) {
+		if (
+#ifdef CONFIG_RTL_88E_SUPPORT
+			(GET_CHIP_VER(priv)==VERSION_8188E)?(pstat->remapped_aid == RTL8188E_NUM_STAT-1):
+#endif
+			(pstat->remapped_aid == FW_NUM_STAT-1/*(priv->STA_map & BIT(pstat->aid)) != 0*/)) {
 			// firmware does not keep the aid ...
 			//use default rate instead
 			if (pstat->ht_cap_len) {	// is N client
@@ -183,8 +218,9 @@ unsigned int get_tx_rate(struct rtl8192cd_priv *priv, struct stat_info *pstat)
 		}
 	}
 #else
-	if ((GET_CHIP_VER(priv)==VERSION_8192D) && (priv->pmib->dot11RFEntry.txbf==1))
+	if (priv->pmib->dot11RFEntry.txbf == 1)
 		check_txrate_by_reg(priv, pstat);
+
 	return pstat->current_tx_rate;
 #endif
 }
@@ -252,6 +288,10 @@ void assign_wlanseq(struct rtl8192cd_hw *phw, unsigned char *pframe, struct stat
 				phw->VI_pkt_count++;
 			else if ((tid == 2) || (tid == 1))
 				phw->BK_pkt_count++;
+#ifdef WMM_VIBE_PRI
+			else
+				phw->BE_pkt_count++;
+#endif
 		}
 	}
 	else
@@ -290,7 +330,7 @@ __MIPS16 __IRAM_IN_865X static unsigned int get_skb_priority(struct rtl8192cd_pr
 			if ((protocol[0] == 0x08) && (protocol[1] == 0x00))
 			{
 #ifdef CONFIG_RTK_MESH
-				if(is_11s & 8)
+				if(is_11s & RELAY_11S)
 				{
 					if(skb->data[14]&1) // 6 addr
 						pri = (skb->data[31] & 0xe0) >> 5;
@@ -299,13 +339,34 @@ __MIPS16 __IRAM_IN_865X static unsigned int get_skb_priority(struct rtl8192cd_pr
 				}
 				else
 #endif
+				{
 					pri = (skb->data[15] & 0xe0) >> 5;
+				}
 			}
 			else if ((skb->cb[0]>0) && (skb->cb[0]<8))	// Ethernet driver will parse priority and put in cb[0]
 				pri = skb->cb[0];
 			else
 				pri = 0;
 		}
+
+#ifdef CLIENT_MODE
+		if ((OPMODE & (WIFI_STATION_STATE | WIFI_ASOC_STATE)) == (WIFI_STATION_STATE | WIFI_ASOC_STATE)) {
+			if (GET_STA_AC_VO_PARA.ACM) {
+				if (!GET_STA_AC_VI_PARA.ACM) 
+					pri = 5;
+				else if (!GET_STA_AC_BE_PARA.ACM)
+					pri = 0;
+				else
+					pri = 1;
+			} else if (GET_STA_AC_VI_PARA.ACM) {
+				if (!GET_STA_AC_BE_PARA.ACM)
+					pri = 0;
+				else
+					pri = 1;
+			} else if (GET_STA_AC_BE_PARA.ACM)
+				pri = 1;	// DSCP_BK tag = 1;
+		}
+#endif	
 		skb->cb[1] = pri;
 
 		return pri;
@@ -530,19 +591,19 @@ static int rtl8192cd_tx_clientMode(struct rtl8192cd_priv *priv, struct sk_buff *
 #ifdef RTK_BR_EXT
 		int res, is_vlan_tag=0, i, do_nat25=1;
 		unsigned short vlan_hdr=0;
+		int lltd_flag=0;
 
-		mac_clone_handle_frame(priv, skb);
+		if (!priv->pmib->wscEntry.wsc_enable)
+			mac_clone_handle_frame(priv, skb);
 
 		if (!priv->pmib->ethBrExtInfo.nat25_disable) {
-//			if (priv->dev->br_port &&
-//				 !memcmp(skb->data+MACADDRLEN, priv->br_mac, MACADDRLEN)) {
 			if (*((unsigned short *)(skb->data+MACADDRLEN*2)) == __constant_htons(ETH_P_8021Q)) {
 				is_vlan_tag = 1;
 				vlan_hdr = *((unsigned short *)(skb->data+MACADDRLEN*2+2));
 				for (i=0; i<6; i++)
 					*((unsigned short *)(skb->data+MACADDRLEN*2+2-i*2)) = *((unsigned short *)(skb->data+MACADDRLEN*2-2-i*2));
 				skb_pull(skb, 4);
-//			}
+			}
 
 			if (!memcmp(skb->data+MACADDRLEN, priv->br_mac, MACADDRLEN) &&
 				(*((unsigned short *)(skb->data+MACADDRLEN*2)) == __constant_htons(ETH_P_IP)))
@@ -566,11 +627,18 @@ static int rtl8192cd_tx_clientMode(struct rtl8192cd_priv *priv, struct sk_buff *
 					else {
 						memset(priv->scdb_mac, 0, MACADDRLEN);
 						memset(priv->scdb_ip, 0, 4);
-						}
 					}
 				}
 			}
 
+			if (*((unsigned short *)(skb->data+MACADDRLEN*2)) == __constant_htons(0x88d9)) {
+				if(skb->data[0] & 0x1)
+				{
+					do_nat25=0;
+					lltd_flag=1;
+				}
+			}
+
 			if (do_nat25)
 			{
 				if (nat25_db_handle(priv, skb, NAT25_CHECK) == 0) {
@@ -612,9 +680,10 @@ static int rtl8192cd_tx_clientMode(struct rtl8192cd_priv *priv, struct sk_buff *
 				}
 			}
 
-			memcpy(skb->data+MACADDRLEN, GET_MY_HWADDR, MACADDRLEN);
-
-			dhcp_flag_bcast(priv, skb);
+			if(lltd_flag != 1)
+			{
+				memcpy(skb->data+MACADDRLEN, GET_MY_HWADDR, MACADDRLEN);
+			}
 
 			if (is_vlan_tag) {
 				skb_push(skb, 4);
@@ -628,7 +697,7 @@ static int rtl8192cd_tx_clientMode(struct rtl8192cd_priv *priv, struct sk_buff *
 			if (*((unsigned short *)(skb->data+MACADDRLEN*2)) == __constant_htons(ETH_P_8021Q)) {
 				is_vlan_tag = 1;
 			}
-				
+
 			if(is_vlan_tag){
 				if(ICMPV6_MCAST_MAC(skb->data) && ICMPV6_PROTO1A_VALN(skb->data)){
 					memcpy(skb->data+MACADDRLEN, GET_MY_HWADDR, MACADDRLEN);
@@ -638,7 +707,7 @@ static int rtl8192cd_tx_clientMode(struct rtl8192cd_priv *priv, struct sk_buff *
 				if(ICMPV6_MCAST_MAC(skb->data) && ICMPV6_PROTO1A(skb->data)){
 					memcpy(skb->data+MACADDRLEN, GET_MY_HWADDR, MACADDRLEN);
 				}
-			}	
+			}
 		}
 
 
@@ -786,7 +855,10 @@ int get_tx_sc_index(struct rtl8192cd_priv *priv, struct stat_info *pstat, unsign
 		else				
 #endif
 		{
-			if (!memcmp(hdr, &pstat->tx_sc_ent[i].ethhdr, sizeof(struct wlan_ethhdr_t)))	
+			unsigned char *ptr;
+
+			ptr = (unsigned char *)&pstat->tx_sc_ent[i].ethhdr;
+			if (!memcmp(hdr, &pstat->tx_sc_ent[i].ethhdr, sizeof(struct wlan_ethhdr_t)))
 				return i;
 		}
 	}
@@ -938,6 +1010,11 @@ static int rtl8192cd_tx_slowPath(struct rtl8192cd_priv *priv, struct sk_buff *sk
 			DEBUG_WARN("non supported mode yet!\n");
 	}
 
+#ifdef USE_TXQUEUE
+	if (GET_ROOT(priv)->pmib->miscEntry.use_txq && priv->pshare->iot_mode_enable)
+		rtl8192cd_tx_dsr((unsigned long)priv);
+#endif
+
 	if (rtl8192cd_wlantx(priv, txcfg) == CONGESTED)
 	{
 		rtl8192cd_tx_xmitSkbFail(priv, skb, dev, wdsDev, txcfg);
@@ -983,6 +1060,31 @@ int rtl8192cd_start_xmit(struct sk_buff *skb, struct net_device *dev)
 }
 
 
+#ifdef SUPPORT_TX_MCAST2UNI
+
+__IRAM_IN_865X
+int rtl8192cd_start_xmit_noM2U(struct sk_buff *skb, struct net_device *dev)
+{
+#ifdef NETDEV_NO_PRIV
+	struct rtl8192cd_priv *priv = ((struct rtl8192cd_priv *)netdev_priv(dev))->wlan_priv;
+#else
+	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *)dev->priv;
+#endif
+	unsigned long x;
+	int ret;
+
+	SAVE_INT_AND_CLI(x);
+	SMP_LOCK_XMIT(x);
+
+	ret = __rtl8192cd_start_xmit(skb, dev, TX_NO_MUL2UNI);
+
+	RESTORE_INT(x);
+	SMP_UNLOCK_XMIT(x);
+	return ret;
+}
+
+#endif
+
 #ifdef SUPPORT_TX_AMSDU
 static int amsdu_xmit(struct rtl8192cd_priv *priv, struct stat_info *pstat, struct tx_insn *txcfg, int tid,
 				int from_isr, struct net_device *wdsDev, struct net_device *dev)
@@ -1011,7 +1113,7 @@ static int amsdu_xmit(struct rtl8192cd_priv *priv, struct stat_info *pstat, stru
 
 		if (is_first) {
 			if (skb_queue_len(&pstat->amsdu_tx_que[tid]) > 0) {
-				space = CIRC_SPACE_RTK(*tx_head, *tx_tail, NUM_TX_DESC);
+				space = CIRC_SPACE_RTK(*tx_head, *tx_tail, CURRENT_NUM_TX_DESC);
 				if (space < 10) {
 #ifdef SMP_SYNC
 					if (!priv->pshare->has_triggered_tx_tasklet) {
@@ -1022,7 +1124,7 @@ static int amsdu_xmit(struct rtl8192cd_priv *priv, struct stat_info *pstat, stru
 					rtl8192cd_tx_dsr((unsigned long)priv);
 #endif
 				
-					space = CIRC_SPACE_RTK(*tx_head, *tx_tail, NUM_TX_DESC);
+					space = CIRC_SPACE_RTK(*tx_head, *tx_tail, CURRENT_NUM_TX_DESC);
 					if (space < 10) {
 						// printk("Tx desc not enough for A-MSDU!\n");
 						__skb_queue_head(&pstat->amsdu_tx_que[tid], pskb);
@@ -1224,14 +1326,14 @@ void amsdu_timeout(struct rtl8192cd_priv *priv, unsigned int current_time)
 	tx_head = get_txhead_addr(phw, q_num);
 	tx_tail = get_txtail_addr(phw, q_num);
 
-	cnt = CIRC_CNT_RTK(*tx_head, *tx_tail, NUM_TX_DESC);
+	cnt = CIRC_CNT_RTK(*tx_head, *tx_tail, CURRENT_NUM_TX_DESC);
 
 #if 0
 	if (cnt <= AMSDU_TX_DESC_TH)
 		return RET_AGGRE_BYPASS;
 #endif
 
-	if (cnt == (NUM_TX_DESC - 1))
+	if (cnt == (CURRENT_NUM_TX_DESC - 1))
 		return RET_AGGRE_DESC_FULL;
 
 #ifdef MESH_AMSDU
@@ -1325,7 +1427,7 @@ static inline void check_tx_queue(struct rtl8192cd_priv *priv)
 #endif
 		tx_head = get_txhead_addr(phw, BE_QUEUE);// use BE queue to send multicast
 		tx_tail = get_txtail_addr(phw, BE_QUEUE);
-		if(CIRC_SPACE_RTK(*tx_head, *tx_tail, NUM_TX_DESC) <(NUM_TX_DESC/4))
+		if(CIRC_SPACE_RTK(*tx_head, *tx_tail, CURRENT_NUM_TX_DESC) <(CURRENT_NUM_TX_DESC/4))
 		{
 			rtl8192cd_tx_queueDsr(priv, BE_QUEUE);
 			//int recycleCnt;
@@ -1346,6 +1448,25 @@ static inline void check_tx_queue(struct rtl8192cd_priv *priv)
 #define ETH_SKB_FREE_TH 100
 #endif
 
+int isSpecialFloodMac(struct rtl8192cd_priv *priv, struct sk_buff *skb)
+{
+	int i;
+	if(priv->pshare->rf_ft_var.mc2u_flood_ctrl==0)
+	{
+		return 0;
+	}
+	
+	for(i=0; i< priv->pshare->rf_ft_var.mc2u_flood_mac_num; i++)
+	{
+		if(memcmp(skb->data, priv->pshare->rf_ft_var.mc2u_flood_mac[i].macAddr,MACADDRLEN)==0)
+		{
+			return 1;
+		}
+
+	}
+	return 0;
+}
+
 int mlcst2unicst(struct rtl8192cd_priv *priv, struct sk_buff *skb)
 {
 	struct stat_info *pstat;
@@ -1365,7 +1486,7 @@ int mlcst2unicst(struct rtl8192cd_priv *priv, struct sk_buff *skb)
 	memcpy(origDest, skb->data, 6);
 
 	// all multicast managment packet try do m2u
-	if( IS_IGMP_PROTO(skb->data) || isICMPv6Mng(skb) || IS_ICMPV6_PROTO(skb->data))
+	if( isSpecialFloodMac(priv,skb) || IS_MDNSV4_MAC(skb->data)||IS_MDNSV6_MAC(skb->data)||IS_IGMP_PROTO(skb->data) || isICMPv6Mng(skb) || IS_ICMPV6_PROTO(skb->data))
 	{
 		/*added by qinjunjie,do multicast to unicast conversion, and send to every associated station */
 		phead = &priv->asoc_list;
@@ -1418,7 +1539,7 @@ int mlcst2unicst(struct rtl8192cd_priv *priv, struct sk_buff *skb)
 		return TRUE;
 	}
 
-#ifdef VIDEO_STREAMING_REFINE
+//#ifdef VIDEO_STREAMING_REFINE
 	// for video streaming refine 
 	struct stat_info *pstat_found = NULL;
 	phead = &priv->asoc_list;
@@ -1463,27 +1584,45 @@ int mlcst2unicst(struct rtl8192cd_priv *priv, struct sk_buff *skb)
 			M2Uanyway=1;
 			fwdCnt = priv->assoc_num;			
 		}else{
-			return FALSE;		
+			if(!priv->pshare->rf_ft_var.mc2u_drop_unknown) 
+			{
+				return FALSE;
+			}
+			else
+			{
+				priv->ext_stats.tx_drops++;
+				dev_kfree_skb_any(skb);
+				return TRUE;
+
+			}
 		}
 #else
-		/*case: if M2U can't success then 
-		  forward by multicast(orig method) */ 
-		return FALSE;		
-
+		if(!priv->pshare->rf_ft_var.mc2u_drop_unknown) 
+		{
+			/*case: if M2U can't success then 
+			  forward by multicast(orig method),
+			  defect: may affect system performance
+		    	 advantage:better compatibility*/ 
+			return FALSE;		
+		}
+		else
+		{
 
 		/*case: if M2U can't success then drop this packet ;
-		    defect:maybe some management packet will lose */ 
-	    /*
-		priv->ext_stats.tx_drops++;
-		dev_kfree_skb_any(skb);
-		return TRUE;
-		*/ 
+		    defect:maybe some management packet will lose
+		    advantage:better performance*/ 
+	   	
+			priv->ext_stats.tx_drops++;
+			dev_kfree_skb_any(skb);
+			return TRUE;
+			
+		}
 
 #endif
 
 
 	}
-#endif
+//#endif
 
 
 	
@@ -1509,7 +1648,7 @@ int mlcst2unicst(struct rtl8192cd_priv *priv, struct sk_buff *skb)
 				rtl8192cd_tx_queueDsr(priv, q_num);
 
 				if (priv->stop_tx_mcast2uni  == 1 &&
-						CIRC_SPACE_RTK(*tx_head, *tx_tail, NUM_TX_DESC) > (NUM_TX_DESC*1)/4) {
+						CIRC_SPACE_RTK(*tx_head, *tx_tail, CURRENT_NUM_TX_DESC) > (CURRENT_NUM_TX_DESC*1)/4) {
 					priv->stop_tx_mcast2uni = 0;
 				}
 #if defined(CONFIG_RTL865X_ETH_PRIV_SKB) || defined(CONFIG_RTL_ETH_PRIV_SKB)
@@ -1526,7 +1665,7 @@ int mlcst2unicst(struct rtl8192cd_priv *priv, struct sk_buff *skb)
 					}
                                                 }
 			else {
-				if (CIRC_SPACE_RTK(*tx_head, *tx_tail, NUM_TX_DESC) < 20) {
+				if (CIRC_SPACE_RTK(*tx_head, *tx_tail, CURRENT_NUM_TX_DESC) < 20) {
 					priv->stop_tx_mcast2uni = 1;
 					dev_kfree_skb_any(skb);
 					priv->ext_stats.tx_drops++;
@@ -1694,6 +1833,65 @@ int check_txdesc_dynamic_mechanism(struct rtl8192cd_priv *priv, int q_num, int t
 	
 	return -1;
 }
+
+#ifdef USE_TXQUEUE
+int check_txq_dynamic_mechanism(struct rtl8192cd_priv *priv, int q_num)
+{
+	struct rtl8192cd_priv *root_priv = NULL;
+	unsigned int lower_limit = priv->pshare->num_txq_lower_limit;
+	unsigned int avail_cnt = priv->pshare->num_txq_cnt;
+	unsigned int used = priv->use_txq_cnt[q_num];
+	unsigned int accu = 0, i;
+	
+	if (IS_ROOT_INTERFACE(priv))
+		root_priv = priv;
+	else
+		root_priv = GET_ROOT_PRIV(priv);
+		
+	if (IS_ROOT_INTERFACE(priv))
+	{
+		if ( IS_DRV_OPEN(priv) )
+			accu += used;
+	}
+	else
+	{
+		if ( IS_DRV_OPEN(root_priv) )
+			accu += MAX_NUM(root_priv->use_txq_cnt[q_num], lower_limit);
+	}
+		
+#ifdef UNIVERSAL_REPEATER
+	if (IS_VXD_INTERFACE(priv))
+	{
+		if ( IS_DRV_OPEN(priv) )
+			accu += used;
+	}
+	else
+	{
+		if ( IS_DRV_OPEN(root_priv->pvxd_priv) )
+			accu += MAX_NUM(root_priv->pvxd_priv->use_txq_cnt[q_num], lower_limit);
+	}
+#endif
+	
+#ifdef MBSSID
+	for (i=0; i<RTL8192CD_NUM_VWLAN; i++)
+	{
+		if ( IS_DRV_OPEN(root_priv->pvap_priv[i]) )
+		{
+			if (root_priv->pvap_priv[i] == priv)
+				accu += used;
+			else
+				accu += MAX_NUM(root_priv->pvap_priv[i]->use_txq_cnt[q_num], lower_limit);
+		}
+	}
+#endif
+		
+	if (accu < avail_cnt)
+		return 0;
+
+	return -1;
+
+}
+#endif
 #endif
 
 
@@ -1748,33 +1946,33 @@ static void rtl8192cd_fill_fwinfo(struct rtl8192cd_priv *priv, struct tx_insn* t
 	}
 #endif
 
-#ifdef CONFIG_RTL_92D_SUPPORT
-	if (GET_CHIP_VER(priv)==VERSION_8192D){
+	if (priv->pmib->dot11RFEntry.txbf == 1) {
 		pdesc->Dword2 &= set_desc(0x03ffffff); // clear related bits
 		pdesc->Dword2 |= set_desc(1 << TX_TxAntCckSHIFT); 	// Set Default CCK rate with 1T
 		pdesc->Dword2 |= set_desc(1 << TX_TxAntlSHIFT); 	// Set Default Legacy rate with 1T
 		pdesc->Dword2 |= set_desc(1 << TX_TxAntHtSHIFT); 	// Set Default Ht rate		
 	}
-#endif
 
 	if (is_MCS_rate(txcfg->tx_rate))	// HT rates
 	{
 		txRate = txcfg->tx_rate & 0x7f;
 		txRate += 12;
 		
-#ifdef CONFIG_RTL_92D_SUPPORT
-		if (GET_CHIP_VER(priv)==VERSION_8192D){
-			if (txRate <= 0x12){
+		if (priv->pmib->dot11RFEntry.txbf == 1) {
+			if (txRate <= 0x12) {
 				pdesc->Dword2 |= set_desc(3 << TX_TxAntHtSHIFT); // Set Ht rate < MCS6 with 2T
 			}
 		}
-#endif
 
 		if (priv->pshare->is_40m_bw) {
 			if (txcfg->pstat && (txcfg->pstat->tx_bw == HT_CHANNEL_WIDTH_20_40)
 #ifdef WIFI_11N_2040_COEXIST
 				&& !(priv->pmib->dot11nConfigEntry.dot11nCoexist && (((OPMODE & WIFI_AP_STATE) && 
 				(priv->bg_ap_timeout ||priv->force_20_sta || priv->switch_20_sta
+#ifdef CONFIG_RTL_88E_SUPPORT
+				|| (GET_CHIP_VER(priv) == VERSION_8188E)?(priv->force_20_sta_88e_hw_ext 
+				|| priv->switch_20_sta_88e_hw_ext):(0)
+#endif
 #ifdef STA_EXT
 				|| priv->force_20_sta_ext || priv->switch_20_sta_ext
 #endif
@@ -1789,9 +1987,14 @@ static void rtl8192cd_fill_fwinfo(struct rtl8192cd_priv *priv, struct tx_insn* t
 				) {
 				pdesc->Dword4 |= set_desc(TX_DataBw | (3 << TX_DataScSHIFT));
 
-				if (priv->pmib->dot11nConfigEntry.dot11nShortGIfor40M &&
-					txcfg->pstat && (txcfg->pstat->ht_cap_buf.ht_cap_info & cpu_to_le16(_HTCAP_SHORTGI_40M_)))
-					n_txshort = 1;
+#if defined(CONFIG_RTL_88E_SUPPORT) && defined(TXREPORT)
+				if ((txcfg->fixed_rate) || (GET_CHIP_VER(priv)!=VERSION_8188E))
+#endif
+				{
+					if (priv->pmib->dot11nConfigEntry.dot11nShortGIfor40M &&
+						txcfg->pstat && (txcfg->pstat->ht_cap_buf.ht_cap_info & cpu_to_le16(_HTCAP_SHORTGI_40M_)))
+						n_txshort = 1;
+				}
 			}
 			else {
 				if (priv->pshare->offset_2nd_chan == HT_2NDCH_OFFSET_BELOW)
@@ -1799,21 +2002,42 @@ static void rtl8192cd_fill_fwinfo(struct rtl8192cd_priv *priv, struct tx_insn* t
 				else
 					pdesc->Dword4 |= set_desc((1 << TX_DataScSHIFT) | (1 << TX_RtsScSHIFT));
 
+#if defined(CONFIG_RTL_88E_SUPPORT) && defined(TXREPORT)
+				if ((txcfg->fixed_rate) || (GET_CHIP_VER(priv)!=VERSION_8188E))
+#endif
+				{
+					if (priv->pmib->dot11nConfigEntry.dot11nShortGIfor20M &&
+						txcfg->pstat && (txcfg->pstat->ht_cap_buf.ht_cap_info & cpu_to_le16(_HTCAP_SHORTGI_20M_)))
+						n_txshort = 1;
+				}
+			}
+		} else {
+#if defined(CONFIG_RTL_88E_SUPPORT) && defined(TXREPORT)
+			if ((txcfg->fixed_rate) || (GET_CHIP_VER(priv)!=VERSION_8188E))
+#endif
+			{
 				if (priv->pmib->dot11nConfigEntry.dot11nShortGIfor20M &&
 					txcfg->pstat && (txcfg->pstat->ht_cap_buf.ht_cap_info & cpu_to_le16(_HTCAP_SHORTGI_20M_)))
 					n_txshort = 1;
 			}
 		}
-		else {
-			if (priv->pmib->dot11nConfigEntry.dot11nShortGIfor20M &&
-				txcfg->pstat && (txcfg->pstat->ht_cap_buf.ht_cap_info & cpu_to_le16(_HTCAP_SHORTGI_20M_)))
+
+#if defined(CONFIG_RTL_88E_SUPPORT) && defined(TXREPORT)
+		if ((GET_CHIP_VER(priv)==VERSION_8188E) && !(txcfg->fixed_rate)) {
+			if (txcfg->pstat->ht_current_tx_info & TX_USE_SHORT_GI)
 				n_txshort = 1;
 		}
+#endif
 
 		if ((txcfg->aggre_en >= FG_AGGRE_MPDU) && (txcfg->aggre_en <= FG_AGGRE_MPDU_BUFFER_LAST)) {
 			int TID = ((struct sk_buff *)txcfg->pframe)->cb[1];
 			if (txcfg->pstat->ADDBA_ready[TID]) {
-				pdesc->Dword1 |= set_desc(TX_AggEn);
+#ifdef CONFIG_RTL_88E_SUPPORT
+				if (GET_CHIP_VER(priv)==VERSION_8188E)
+					pdesc->Dword2 |= set_desc(TXdesc_88E_AggEn);
+				else
+#endif
+					pdesc->Dword1 |= set_desc(TX_AggEn);
 
 				/*
 				 * assign aggr size
@@ -1838,11 +2062,21 @@ static void rtl8192cd_fill_fwinfo(struct rtl8192cd_priv *priv, struct tx_insn* t
 			//set Break
 			if((txcfg->q_num >=1 && txcfg->q_num <=4)){
 				if((txcfg->pstat != priv->pshare->CurPstat[txcfg->q_num-1])) {
-					pdesc->Dword1 |= set_desc(TX_BK);
+#ifdef CONFIG_RTL_88E_SUPPORT
+					if (GET_CHIP_VER(priv)==VERSION_8188E)
+						pdesc->Dword2 |= set_desc(TXdesc_88E_BK);
+					else
+#endif
+						pdesc->Dword1 |= set_desc(TX_BK);
 					priv->pshare->CurPstat[txcfg->q_num-1] = txcfg->pstat;
 				}				
 			} else {
-				pdesc->Dword1 |= set_desc(TX_BK);
+#ifdef CONFIG_RTL_88E_SUPPORT
+				if (GET_CHIP_VER(priv)==VERSION_8188E)
+					pdesc->Dword2 |= set_desc(TXdesc_88E_BK);
+				else
+#endif
+					pdesc->Dword1 |= set_desc(TX_BK);
 			}
 		}
 
@@ -1888,18 +2122,20 @@ static void rtl8192cd_fill_fwinfo(struct rtl8192cd_priv *priv, struct tx_insn* t
 					(priv->ht_protection /*|| txcfg->pstat->is_rtl8190_sta*/))
 				{
 					n_protection = 1;
-					pdesc->Dword4 |=set_desc(TX_RtsEn);
 					if (priv->pmib->dot11ErpInfo.ctsToSelf)
 						pdesc->Dword4 |= set_desc(TX_CTS2Self);
+					else					
+						pdesc->Dword4 |=set_desc(TX_RtsEn);
 				}
 				else if ((priv->pmib->dot11BssType.net_work_type & WIRELESS_11G) &&
 					(!is_CCK_rate(txcfg->tx_rate)) && // OFDM mode
 					priv->pmib->dot11ErpInfo.protection)
 				{
 					erp_protection = 1;
-					pdesc->Dword4 |=set_desc(TX_RtsEn);
 					if (priv->pmib->dot11ErpInfo.ctsToSelf)
 						pdesc->Dword4 |= set_desc(TX_CTS2Self);
+					else						
+						pdesc->Dword4 |=set_desc(TX_RtsEn);
 				}
 				else if ((priv->pmib->dot11BssType.net_work_type & WIRELESS_11N) &&
 					(txcfg->pstat) && (txcfg->pstat->MIMO_ps & _HT_MIMO_PS_DYNAMIC_) &&
@@ -1925,8 +2161,7 @@ static void rtl8192cd_fill_fwinfo(struct rtl8192cd_priv *priv, struct tx_insn* t
 
 		if (is_MCS_rate(rate)) {	// HT rates
 			// can we use HT rates for RTS?
-		}
-		else {
+		} else {
 			unsigned int rtsTxRate  = 0;
 			rtsTxRate = get_rate_index_from_ieee_value(rate);
 			if (erp_protection) {
@@ -1944,9 +2179,28 @@ static void rtl8192cd_fill_fwinfo(struct rtl8192cd_priv *priv, struct tx_insn* t
 					}
 				}
 				pdesc->Dword4 |= (rtsShort == 1)? set_desc(TX_RtsShort): 0;
-			}
-			else if (n_protection)
+			} 
+#ifdef CONFIG_RTL_88E_SUPPORT
+			else if ((GET_CHIP_VER(priv)==VERSION_8188E) && is_MCS_rate(txcfg->tx_rate)) {
+				switch (txcfg->tx_rate & 0x7f) {
+				case 0:
+					rtsTxRate = get_rate_index_from_ieee_value(12);	// 6 Mbps
+					break;
+				case 1:
+					rtsTxRate = get_rate_index_from_ieee_value(24);	// 12 Mbis
+					break;
+				case 2:
+					rtsTxRate = get_rate_index_from_ieee_value(36);	// 18 Mbps
+					break;
+				default:
+					rtsTxRate = get_rate_index_from_ieee_value(48);
+					break;
+				}
+			} 
+#endif
+			else if (n_protection) {
 				rtsTxRate = get_rate_index_from_ieee_value(48);
+			}
 			else {	// > RTS threshold
 			}
 			pdesc->Dword4 |= set_desc((rtsTxRate & TX_RtsRateMask) << TX_RtsRateSHIFT);
@@ -1959,7 +2213,11 @@ static void rtl8192cd_fill_fwinfo(struct rtl8192cd_priv *priv, struct tx_insn* t
 
 	if(n_txshort == 1
 #ifdef STA_EXT
-		&& txcfg->pstat && txcfg->pstat->remapped_aid < FW_NUM_STAT -1
+		&& txcfg->pstat && 
+#ifdef CONFIG_RTL_88E_SUPPORT
+		(GET_CHIP_VER(priv)==VERSION_8188E)?(txcfg->pstat->remapped_aid < RTL8188E_NUM_STAT -1):
+#endif
+		(txcfg->pstat->remapped_aid < FW_NUM_STAT -1)
 #endif
 	)
 		pdesc->Dword5 |= set_desc(TX_SGI);
@@ -2011,10 +2269,10 @@ static void rtl8192cd_fill_fwinfo(struct rtl8192cd_priv *priv, struct tx_insn* t
 		}
 #endif
 
-		else if (is_MCS_rate(txcfg->pstat->current_tx_rate) && (txcfg->pstat->is_intel_sta) && !(txcfg->pstat->leave))
-		{
+		else if (is_MCS_rate(txcfg->pstat->current_tx_rate) && (txcfg->pstat->is_intel_sta) 
+			&& !(txcfg->pstat->leave) && priv->pshare->intel_rty_lmt) {
 			pdesc->Dword5 |= set_desc(TX_RtyLmtEn);
-                        pdesc->Dword5 |= set_desc((0x30 & TX_DataRtyLmtMask) << TX_DataRtyLmtSHIFT);
+			pdesc->Dword5 |= set_desc((priv->pshare->intel_rty_lmt & TX_DataRtyLmtMask) << TX_DataRtyLmtSHIFT);
 		}
 		else if ((txcfg->pstat->is_broadcom_sta) && (txcfg->pstat->retry_inc) && !(txcfg->pstat->leave))
                 {
@@ -2042,9 +2300,36 @@ static void rtl8192cd_fill_fwinfo(struct rtl8192cd_priv *priv, struct tx_insn* t
 	}
 }
 
+
+#ifdef TX_EARLY_MODE
+__MIPS16
+__IRAM_IN_865X
+static void insert_emcontent(struct rtl8192cd_priv *priv, struct tx_insn* txcfg, unsigned char *buf)
+{
+	struct stat_info *pstat = txcfg->pstat;
+	unsigned int dw[2];
+
+	dw[0] = set_desc((pstat->empkt_num & 0xf) |
+							(((pstat->empkt_len[0]+pstat->emextra_len) << 4) & 0xfff0) |
+							(((pstat->empkt_len[1]+pstat->emextra_len) << 16) & 0xfff0000) |
+							(((pstat->empkt_len[2]+pstat->emextra_len) << 28) & 0xf0000000) 	
+							);
+	dw[1] = set_desc((((pstat->empkt_len[2]+pstat->emextra_len) >> 4) & 0xff) |
+							(((pstat->empkt_len[3]+pstat->emextra_len) << 8) & 0xfff00) |							
+							(((pstat->empkt_len[4]+pstat->emextra_len) << 20) & 0xfff00000) 
+							);
+	memcpy(buf, dw, 8);
+}
+#endif
+
+
 // I AM not sure that if our Buffersize and PKTSize is right,
 // If there are any problem, fix this first
+#ifdef CONFIG_RTK_MESH
+int rtl8192cd_signin_txdesc(struct rtl8192cd_priv *priv, struct tx_insn* txcfg, struct wlan_ethhdr_t *wlan_ethhdr_p)
+#else
 int rtl8192cd_signin_txdesc(struct rtl8192cd_priv *priv, struct tx_insn* txcfg)
+#endif
 {
 	struct tx_desc		*phdesc, *pdesc, *pndesc, *picvdesc, *pmicdesc, *pfrstdesc;
 	struct tx_desc_info	*pswdescinfo, *pdescinfo, *pndescinfo, *picvdescinfo, *pmicdescinfo;
@@ -2172,7 +2457,11 @@ int rtl8192cd_signin_txdesc(struct rtl8192cd_priv *priv, struct tx_insn* txcfg)
 					memset(tempQosControl, 0, 2);
 					tempQosControl[0] = ((struct sk_buff *)txcfg->pframe)->cb[1];
 #ifdef WMM_APSD
-					if ((APSD_ENABLE) && (txcfg->pstat) && (txcfg->pstat->state & WIFI_SLEEP_STATE) &&
+					if (
+#ifdef CLIENT_MODE
+						(OPMODE & WIFI_AP_STATE) &&
+#endif
+						(APSD_ENABLE) && (txcfg->pstat) && (txcfg->pstat->state & WIFI_SLEEP_STATE) &&
 						(!GetMData(txcfg->phdr)) &&
 						((((tempQosControl[0] == 7) || (tempQosControl[0] == 6)) && (txcfg->pstat->apsd_bitmap & 0x01)) ||
 						 (((tempQosControl[0] == 5) || (tempQosControl[0] == 4)) && (txcfg->pstat->apsd_bitmap & 0x02)) ||
@@ -2183,6 +2472,9 @@ int rtl8192cd_signin_txdesc(struct rtl8192cd_priv *priv, struct tx_insn* txcfg)
 					if (txcfg->aggre_en == FG_AGGRE_MSDU_FIRST)
 						tempQosControl[0] |= BIT(7);
 
+					if (priv->pmib->dot11nConfigEntry.dot11nTxNoAck)
+						tempQosControl[0] |= BIT(5);
+
 					memcpy((void *)GetQosControl((txcfg->phdr)), tempQosControl, 2);
 				}
 			}
@@ -2211,9 +2503,20 @@ int rtl8192cd_signin_txdesc(struct rtl8192cd_priv *priv, struct tx_insn* txcfg)
 
 		pdesc->Dword0 |= set_desc(32 << TX_OffsetSHIFT); // tx_desc size
 
-		if (IS_MCAST(da)) {
+		if (IS_MCAST(GetAddr1Ptr ((unsigned char *)txcfg->phdr)))
 			pdesc->Dword0 |= set_desc(TX_BMC);
+
+#ifdef CLIENT_MODE
+		if (OPMODE & WIFI_STATION_STATE) {
+			if (GetFrameSubType(txcfg->phdr) == WIFI_PSPOLL)
+				pdesc->Dword1 |= set_desc(TX_NAVUSEHDR);
+
+			if (priv->ps_state)
+				SetPwrMgt(pwlhdr);
+			else
+				ClearPwrMgt(pwlhdr);
 		}
+#endif
 
 		if (i != (txcfg->frg_num - 1))
 		{
@@ -2260,11 +2563,13 @@ int rtl8192cd_signin_txdesc(struct rtl8192cd_priv *priv, struct tx_insn* txcfg)
 		case MGNT_QUEUE:
 			q_select = 0x12;
 			break;
-#if defined(DRVMAC_LB) && defined(WIFI_WMM)
+#if defined(DRVMAC_LB)
+#if defined(WIFI_WMM)
 		case BE_QUEUE:
 			q_select = 0;
 			break;
 #endif
+#endif
 		default:
 			// data packet
 #ifdef RTL_MANUAL_EDCA
@@ -2296,44 +2601,61 @@ int rtl8192cd_signin_txdesc(struct rtl8192cd_priv *priv, struct tx_insn* txcfg)
 
 // Set RateID
 		if (txcfg->pstat) {
-			if (txcfg->pstat->aid != MANAGEMENT_AID)	{
-			u8 ratid;
+			if (txcfg->pstat->aid != MANAGEMENT_AID) {
+				u8 ratid;
 
 #ifdef CONFIG_RTL_92D_SUPPORT
-			if (priv->pmib->dot11RFEntry.phyBandSelect & PHY_BAND_5G){
-				if (txcfg->pstat->tx_ra_bitmap & 0xffff000) {
-					if (priv->pshare->is_40m_bw)
-						ratid = ARFR_2T_Band_A_40M;
-					else
-						ratid = ARFR_2T_Band_A_20M;
-				} else {
-					ratid = ARFR_G_ONLY;
-				}
-			} else 
+				if (priv->pmib->dot11RFEntry.phyBandSelect & PHY_BAND_5G){
+					if (txcfg->pstat->tx_ra_bitmap & 0xffff000) {
+						if (priv->pshare->is_40m_bw)
+							ratid = ARFR_2T_Band_A_40M;
+						else
+							ratid = ARFR_2T_Band_A_20M;
+					} else {
+						ratid = ARFR_G_ONLY;
+					}
+				} else 
 #endif
-			{			
-				if (txcfg->pstat->tx_ra_bitmap & 0xff00000) {
-					if (priv->pshare->is_40m_bw)
-						ratid = ARFR_2T_40M;
-					else
-						ratid = ARFR_2T_20M;
-				} else if (txcfg->pstat->tx_ra_bitmap & 0xff000) {
-					if (priv->pshare->is_40m_bw)
-						ratid = ARFR_1T_40M;
-					else
-						ratid = ARFR_1T_20M;
-				} else if (txcfg->pstat->tx_ra_bitmap & 0xff0) {
-					ratid = ARFR_BG_MIX;
-				} else {
-					ratid = ARFR_B_ONLY;
-				}
-			}
-			pdesc->Dword1 |= set_desc((ratid & TX_RateIDMask) << TX_RateIDSHIFT);			
-// Set MacID
-			pdesc->Dword1 |= set_desc(REMAP_AID(txcfg->pstat) & TX_MacIdMask);;
+				{			
+					if (txcfg->pstat->tx_ra_bitmap & 0xff00000) {
+						if (priv->pshare->is_40m_bw)
+							ratid = ARFR_2T_40M;
+						else
+							ratid = ARFR_2T_20M;
+					} else if (txcfg->pstat->tx_ra_bitmap & 0xff000) {
+						if (priv->pshare->is_40m_bw)
+							ratid = ARFR_1T_40M;
+						else
+							ratid = ARFR_1T_20M;
+					} else if (txcfg->pstat->tx_ra_bitmap & 0xff0) {
+						ratid = ARFR_BG_MIX;
+					} else {
+						ratid = ARFR_B_ONLY;
+					}
+
 
+#ifdef P2P_SUPPORT	/*tx to GC no user B rate*/
+					if(txcfg->pstat->is_p2p_client){
+						switch(ratid) {
+							case  ARFR_BG_MIX :
+								ratid = ARFR_G_ONLY;
+								break;
+							default:
+								ratid = ARFR_2T_Band_A_40M;		
+						}
+					}
+#endif				
+				}
+				pdesc->Dword1 |= set_desc((ratid & TX_RateIDMask) << TX_RateIDSHIFT);
+	// Set MacID
+#ifdef CONFIG_RTL_88E_SUPPORT
+				if (GET_CHIP_VER(priv)==VERSION_8188E)
+					pdesc->Dword1 |= set_desc(REMAP_AID(txcfg->pstat) & TXdesc_88E_MacIdMask);
+				else
+#endif
+					pdesc->Dword1 |= set_desc(REMAP_AID(txcfg->pstat) & TX_MacIdMask);
 			}
-	} else {
+		} else {
 	
 #ifdef CONFIG_RTL_92D_SUPPORT
 		if (priv->pmib->dot11RFEntry.phyBandSelect & PHY_BAND_5G)
@@ -2346,9 +2668,17 @@ int rtl8192cd_signin_txdesc(struct rtl8192cd_priv *priv, struct tx_insn* txcfg)
 		pdesc->Dword5 |= set_desc((0x1f & TX_DataRateFBLmtMask) << TX_DataRateFBLmtSHIFT);
 		if (txcfg->fixed_rate)
 			pdesc->Dword4 |= set_desc(TX_DisDataFB|TX_DisRtsFB|TX_UseRate);
+#ifdef CONFIG_RTL_88E_SUPPORT
+		else if (GET_CHIP_VER(priv)==VERSION_8188E)
+			pdesc->Dword4 |= set_desc(TX_UseRate);
+#endif
 
 #ifdef STA_EXT
-		if(txcfg->pstat && txcfg->pstat->remapped_aid == FW_NUM_STAT-1/*(priv->pshare->STA_map & BIT(txcfg->pstat->aid)*/)
+		if(txcfg->pstat && 
+#ifdef CONFIG_RTL_88E_SUPPORT
+			(GET_CHIP_VER(priv)==VERSION_8188E)?(txcfg->pstat->remapped_aid == RTL8188E_NUM_STAT-1):
+#endif
+			(txcfg->pstat->remapped_aid == FW_NUM_STAT-1/*(priv->pshare->STA_map & BIT(txcfg->pstat->aid)*/))
 			pdesc->Dword4 |= set_desc(TX_UseRate);
 #endif
 
@@ -2399,6 +2729,21 @@ int rtl8192cd_signin_txdesc(struct rtl8192cd_priv *priv, struct tx_insn* txcfg)
 			}
 		}
 
+#ifdef TX_EARLY_MODE
+		if (GET_TX_EARLY_MODE && pwlhdr && i == 0) {
+			pdesc->Dword0 = set_desc((get_desc(pdesc->Dword0) & 0xff00ffff) | (0x28 << TX_OffsetSHIFT));
+			pdesc->Dword1 = set_desc(get_desc(pdesc->Dword1) | (1 << TX_PktOffsetSHIFT));
+			pdesc->Dword7 = set_desc(get_desc(pdesc->Dword7) + 8);
+
+			memset(pwlhdr-8, '\0', 8);			
+			if (txcfg->pstat && txcfg->pstat->empkt_num > 0) 			
+				insert_emcontent(priv, txcfg, pwlhdr-8);
+			
+			pdesc->Dword8 = set_desc(get_physical_addr(priv, pwlhdr-8,
+				get_desc(pdesc->Dword7)&TX_TxBufSizeMask, PCI_DMA_TODEVICE));	
+		}
+		else
+#endif
 		pdesc->Dword8 = set_desc(get_physical_addr(priv, pwlhdr,
 			(get_desc(pdesc->Dword7)&TX_TxBufSizeMask), PCI_DMA_TODEVICE));
 
@@ -2420,8 +2765,30 @@ int rtl8192cd_signin_txdesc(struct rtl8192cd_priv *priv, struct tx_insn* txcfg)
 #endif
 				|| (txcfg->privacy && !UseSwCrypto(priv, txcfg->pstat, (txcfg->pstat ? FALSE : TRUE)))) &&
 				!GetMData(txcfg->phdr) ) {
-			idx = get_tx_sc_free_entry(priv, txcfg->pstat, (pbuf - sizeof(struct wlan_ethhdr_t)));
-			memcpy((void *)&txcfg->pstat->tx_sc_ent[idx].ethhdr, (pbuf - sizeof(struct wlan_ethhdr_t)), sizeof(struct wlan_ethhdr_t));
+
+#ifdef CONFIG_RTK_MESH
+			if( txcfg->is_11s&0x1) {
+				if( wlan_ethhdr_p ) {
+					idx = get_tx_sc_free_entry(priv, txcfg->pstat, wlan_ethhdr_p);
+				} else {
+					txsc_debug("rtl8192cd_signin_txdesc invoked with NULL pointer\n");
+					idx = get_tx_sc_free_entry(priv, txcfg->pstat, pbuf - sizeof(struct wlan_ethhdr_t));
+				}
+			} else
+#endif
+				idx = get_tx_sc_free_entry(priv, txcfg->pstat, pbuf - sizeof(struct wlan_ethhdr_t));
+
+#ifdef CONFIG_RTK_MESH
+			if( txcfg->is_11s&0x1) {
+				if( wlan_ethhdr_p ) {
+					memcpy((void *)&txcfg->pstat->tx_sc_ent[idx].ethhdr, wlan_ethhdr_p, sizeof(struct wlan_ethhdr_t));
+				} else {
+					memcpy((void *)&txcfg->pstat->tx_sc_ent[idx].ethhdr, pbuf - sizeof(struct wlan_ethhdr_t), sizeof(struct wlan_ethhdr_t));
+				}
+			} else
+#endif
+				memcpy((void *)&txcfg->pstat->tx_sc_ent[idx].ethhdr, pbuf - sizeof(struct wlan_ethhdr_t), sizeof(struct wlan_ethhdr_t));
+
 			desc_copy(&txcfg->pstat->tx_sc_ent[idx].hwdesc1, pdesc);
 			descinfo_copy(&txcfg->pstat->tx_sc_ent[idx].swdesc1, pdescinfo);
 			txcfg->pstat->protection = priv->pmib->dot11ErpInfo.protection;
@@ -2827,7 +3194,9 @@ init_deschead:
 #endif
 
 	if (q_num == HIGH_QUEUE) {
-		priv->pshare->pkt_in_hiQ = 1;
+//		priv->pshare->pkt_in_hiQ = 1;
+		priv->pkt_in_hiQ = 1;
+
 		return 0;
 	} else {
 		tx_poll(priv, q_num);
@@ -3076,7 +3445,7 @@ int reuse_meshhdr(struct rtl8192cd_priv *priv, struct tx_insn *txcfg)
 #ifndef __LINUX_2_6__
 __MIPS16
 #endif
-int start_xmit_mesh(struct sk_buff *skb, struct net_device *dev, int *tx_flag, struct tx_insn *txcfg)
+int start_xmit_mesh(struct sk_buff *skb, struct net_device *dev, struct tx_insn *txcfg)
 {
 	struct stat_info	*pstat=NULL;
 	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *)dev->priv;
@@ -3092,6 +3461,7 @@ int start_xmit_mesh(struct sk_buff *skb, struct net_device *dev, int *tx_flag, s
 	if(mesh_debug_tx2( priv, skb)<0)
 		return 0;
 #endif
+
 	if(memcmp(skb->data, zero14, sizeof(zero14))==0)
 	{
 		if(issue_11s_mesh_action(skb, dev)==0)
@@ -3109,10 +3479,9 @@ int start_xmit_mesh(struct sk_buff *skb, struct net_device *dev, int *tx_flag, s
 		}
 	}
 
-		if(!dot11s_datapath_decision(skb, txcfg, 1)) //the dest form bridge need be update to proxy table
-			return 0;
+	if(!dot11s_datapath_decision(skb, txcfg, 1)) //the dest form bridge need be update to proxy table
+		return 0;
 
-	*tx_flag = TX_NO_MUL2UNI;
 	return 1;
 }
 #endif
@@ -3275,6 +3644,28 @@ send_qos_fail:
 }
 #endif
 
+#ifdef TX_EARLY_MODE
+__MIPS16
+__IRAM_IN_865X
+static void get_tx_early_info(struct stat_info  *pstat,  struct sk_buff_head *pqueue)
+{	
+	struct sk_buff *next_skb;
+
+	pstat->empkt_num = 0;
+	memset(pstat->empkt_len, '\0', sizeof(pstat->empkt_len));
+	
+	skb_queue_walk(pqueue, next_skb) {
+		pstat->empkt_len[pstat->empkt_num++] = next_skb->len;
+
+		if (skb_queue_is_last(pqueue, next_skb))
+			break;
+
+		if (pstat->empkt_num >= 5)
+			break;
+	}	
+}
+#endif
+
 #ifdef SW_TX_QUEUE
 __MIPS16
 __IRAM_IN_865X
@@ -3284,7 +3675,7 @@ void rtl8192cd_beq_timer(unsigned long task_priv)
 {
     struct stat_info        *pstat = (struct stat_info *)task_priv;
     struct sk_buff *skb = NULL;
-	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *)skb->dev->priv;
+	struct rtl8192cd_priv *priv;
 	unsigned long x;
 
     while(1) {
@@ -3292,6 +3683,14 @@ void rtl8192cd_beq_timer(unsigned long task_priv)
 
         if (skb == NULL)
         	break;
+		
+		priv = (struct rtl8192cd_priv *)skb->dev->priv;
+
+#ifdef TX_EARLY_MODE
+	if (priv && GET_TX_EARLY_MODE && GET_EM_SWQ_ENABLE) 
+		get_tx_early_info(pstat, &pstat->swq.be_queue);		
+#endif		
+		
 		SAVE_INT_AND_CLI(x);
         __rtl8192cd_start_xmit_out(skb, pstat);
 		RESTORE_INT(x);
@@ -3303,7 +3702,7 @@ void rtl8192cd_bkq_timer(unsigned long task_priv)
 {
     struct stat_info        *pstat = (struct stat_info *)task_priv;
     struct sk_buff *skb = NULL;
-	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *)skb->dev->priv;
+	struct rtl8192cd_priv *priv;
 	unsigned long x;
 
     while(1) {
@@ -3311,6 +3710,14 @@ void rtl8192cd_bkq_timer(unsigned long task_priv)
 
         if (skb == NULL)
         	break;
+
+		priv = (struct rtl8192cd_priv *)skb->dev->priv;
+
+#ifdef TX_EARLY_MODE
+	if (priv && GET_TX_EARLY_MODE && GET_EM_SWQ_ENABLE) 
+		get_tx_early_info(pstat, &pstat->swq.bk_queue);		
+#endif		
+		
 		SAVE_INT_AND_CLI(x);
         __rtl8192cd_start_xmit_out(skb, pstat);
 		RESTORE_INT(x);
@@ -3322,7 +3729,7 @@ void rtl8192cd_viq_timer(unsigned long task_priv)
 {
     struct stat_info        *pstat = (struct stat_info *)task_priv;
     struct sk_buff *skb = NULL;
-	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *)skb->dev->priv;
+	struct rtl8192cd_priv *priv;
 	unsigned long x;
 
     while(1) {
@@ -3330,6 +3737,14 @@ void rtl8192cd_viq_timer(unsigned long task_priv)
 
         if (skb == NULL)
         	break;
+		
+		priv = (struct rtl8192cd_priv *)skb->dev->priv;
+
+#ifdef TX_EARLY_MODE
+	if (priv && GET_TX_EARLY_MODE && GET_EM_SWQ_ENABLE) 
+		get_tx_early_info(pstat, &pstat->swq.vi_queue);		
+#endif		
+		
 		SAVE_INT_AND_CLI(x);
         __rtl8192cd_start_xmit_out(skb, pstat);
 		RESTORE_INT(x);
@@ -3341,7 +3756,7 @@ void rtl8192cd_voq_timer(unsigned long task_priv)
 {
     struct stat_info        *pstat = (struct stat_info *)task_priv;
     struct sk_buff *skb = NULL;
-	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *)skb->dev->priv;
+	struct rtl8192cd_priv *priv;
 	unsigned long x;
 
     while(1) {
@@ -3349,6 +3764,14 @@ void rtl8192cd_voq_timer(unsigned long task_priv)
 
         if (skb == NULL)
         	break;
+
+		priv = (struct rtl8192cd_priv *)skb->dev->priv;
+
+#ifdef TX_EARLY_MODE
+	if (priv && GET_TX_EARLY_MODE && GET_EM_SWQ_ENABLE) 
+		get_tx_early_info(pstat, &pstat->swq.vo_queue);		
+#endif		
+		
 		SAVE_INT_AND_CLI(x);
         __rtl8192cd_start_xmit_out(skb, pstat);
 		RESTORE_INT(x);
@@ -3358,7 +3781,7 @@ void rtl8192cd_voq_timer(unsigned long task_priv)
 
 __MIPS16
 __IRAM_IN_865X
-int sw_dequeue(struct sk_buff_head *pqueue,  struct timer_list *ptimer)//, int *pempty)
+int sw_dequeue(struct rtl8192cd_priv *priv, struct sk_buff_head *pqueue,  struct timer_list *ptimer)//, int *pempty)
 {
 	struct stat_info       *pstat = ptimer->data;
     if (timer_pending(ptimer))
@@ -3370,6 +3793,12 @@ int sw_dequeue(struct sk_buff_head *pqueue,  struct timer_list *ptimer)//, int *
     	tmpskb = skb_dequeue(pqueue);
         if (tmpskb == NULL)
            	break;
+
+#ifdef TX_EARLY_MODE
+	if (GET_TX_EARLY_MODE && GET_EM_SWQ_ENABLE) 
+		get_tx_early_info(pstat, pqueue);			
+#endif
+		
         __rtl8192cd_start_xmit_out(tmpskb, pstat);
 	}
 	return 0;
@@ -3425,7 +3854,7 @@ int sw_enqueue(struct rtl8192cd_priv *priv, struct sk_buff *skb, struct stat_inf
 
 	if (!pstat->ADDBA_ready[pri])
 	{
-		sw_dequeue(pqueue, ptimer);
+		sw_dequeue(priv, pqueue, ptimer);
 		*pempty = 0;
 		return 0;
 	}
@@ -3436,8 +3865,12 @@ int sw_enqueue(struct rtl8192cd_priv *priv, struct sk_buff *skb, struct stat_inf
 	//			else
 		//aggr_len = MAX_AGGR_NUM;
 
+#ifdef TX_EARLY_MODE
+	if (q_len >= (GET_EM_SWQ_ENABLE ? MAX_EM_QUE_NUM : MAX_AGGR_NUM)) {
+#else
 	if (q_len >= MAX_AGGR_NUM) {
-		sw_dequeue(pqueue, ptimer);//, pempty);
+#endif		
+		sw_dequeue(priv, pqueue, ptimer);//, pempty);
 		*pempty = 0;
 		return 0;
 	} else if (q_len == 1) {
@@ -3546,6 +3979,7 @@ int __rtl8192cd_start_xmit(struct sk_buff *skb, struct net_device *dev, int tx_f
 #endif
 	struct tx_insn tx_insn;
 	int real_len;
+
 	DECLARE_TXCFG(txcfg, tx_insn);
 
 	if (skb->len < 15)
@@ -3564,27 +3998,51 @@ int __rtl8192cd_start_xmit(struct sk_buff *skb, struct net_device *dev, int tx_f
 	{
 		if (SUCCESS==rtl_isPassthruFrame(skb->data))
 		{
-	
-			#if defined(CONFIG_RTL_92D_SUPPORT)
-			  unsigned int wispWlanIndex=(passThruStatusWlan&WISP_WLAN_IDX_MASK)>>WISP_WLAN_IDX_RIGHT_SHIFT;
-			  if ((wlan_device[wispWlanIndex].priv->drv_state & DRV_STATE_OPEN )&&
-			  	 (((GET_MIB(wlan_device[wispWlanIndex].priv))->dot11OperationEntry.opmode) & WIFI_STATION_STATE))
-			  {
-				#ifdef NETDEV_NO_PRIV
-			        dev=skb->dev=((struct rtl8192cd_priv *)netdev_priv(wlan_device[wispWlanIndex].priv->pWlanDev))->wlan_priv->dev;
-				#else	
-				dev=skb->dev=wlan_device[wispWlanIndex].priv->dev;
+			if(passThruStatusWlan & 0x8) //WISP Mode Enable. default is vxd
+			{
+				#if defined(CONFIG_RTL_92D_SUPPORT)
+				  unsigned int wispWlanIndex=(passThruStatusWlan&WISP_WLAN_IDX_MASK)>>WISP_WLAN_IDX_RIGHT_SHIFT;
+				  if ((wlan_device[wispWlanIndex].priv->drv_state & DRV_STATE_OPEN )&&
+				  	 ((GET_MIB(GET_VXD_PRIV((wlan_device[wispWlanIndex].priv)))->dot11OperationEntry.opmode) & WIFI_STATION_STATE))
+				  {
+					#ifdef NETDEV_NO_PRIV
+				       dev=skb->dev=((struct rtl8192cd_priv *)(((struct rtl8192cd_priv *)netdev_priv(wlan_device[wispWlanIndex].priv->pWlanDev))->wlan_priv))->pvxd_priv->dev;
+					#else	
+					dev=skb->dev=GET_VXD_PRIV(wlan_device[wispWlanIndex].priv)->dev;
+					#endif
+				  } else {
+					goto RTL_PASSTHRU_FREE_AND_STOP;
+				  }
+				#else		
+					#ifdef NETDEV_NO_PRIV
+					dev=skb->dev=((struct rtl8192cd_priv *)(((struct rtl8192cd_priv *)netdev_priv(wlan_device[passThruWanIdx].priv->pWlanDev))->wlan_priv))->pvxd_priv->dev;
+					#else	
+					dev=skb->dev= GET_VXD_PRIV(wlan_device[passThruWanIdx].priv)->dev;
+					#endif
 				#endif
-			  } else {
-				goto RTL_PASSTHRU_FREE_AND_STOP;
-			  }
-			#else		
-				#ifdef NETDEV_NO_PRIV
-				dev=skb->dev=((struct rtl8192cd_priv *)netdev_priv(wlan_device[passThruWanIdx].priv->pWlanDev))->wlan_priv->dev;
-				#else	
-				dev=skb->dev=((struct rtl8192cd_priv *)(wlan_device[passThruWanIdx].priv->pWlanDev->priv))->dev;
+			} else
+			{
+				#if defined(CONFIG_RTL_92D_SUPPORT)
+				  unsigned int wispWlanIndex=(passThruStatusWlan&WISP_WLAN_IDX_MASK)>>WISP_WLAN_IDX_RIGHT_SHIFT;
+				  if ((wlan_device[wispWlanIndex].priv->drv_state & DRV_STATE_OPEN )&&
+				  	 (((GET_MIB(wlan_device[wispWlanIndex].priv))->dot11OperationEntry.opmode) & WIFI_STATION_STATE))
+				  {
+					#ifdef NETDEV_NO_PRIV
+				        dev=skb->dev=((struct rtl8192cd_priv *)netdev_priv(wlan_device[wispWlanIndex].priv->pWlanDev))->wlan_priv->dev;
+					#else	
+					dev=skb->dev=wlan_device[wispWlanIndex].priv->dev;
+					#endif
+				  } else {
+					goto RTL_PASSTHRU_FREE_AND_STOP;
+				  }
+				#else		
+					#ifdef NETDEV_NO_PRIV
+					dev=skb->dev=((struct rtl8192cd_priv *)netdev_priv(wlan_device[passThruWanIdx].priv->pWlanDev))->wlan_priv->dev;
+					#else	
+					dev=skb->dev=((struct rtl8192cd_priv *)(wlan_device[passThruWanIdx].priv->pWlanDev->priv))->dev;
+					#endif
 				#endif
-			#endif
+			}
 		} else {
 			goto RTL_PASSTHRU_FREE_AND_STOP;
 		}
@@ -3628,19 +4086,17 @@ int __rtl8192cd_start_xmit(struct sk_buff *skb, struct net_device *dev, int tx_f
 	priv = (struct rtl8192cd_priv *)dev->priv;
 #endif
 
-#ifdef SW_TX_QUEUE
+//#ifdef SW_TX_QUEUE
         skb->dev = dev;
-#endif
+//#endif
 
 #ifdef CONFIG_RTK_MESH
-	skb->dev = dev;
-	if( priv->pmib->dot1180211sInfo.mesh_enable && (dev == priv->mesh_dev))
-		if(!start_xmit_mesh(skb, dev, &tx_flag, txcfg))
-#ifdef SW_TX_QUEUE
-            goto stop_proctx;
-#else
-			goto stop_proc;
-#endif
+//	skb->dev = dev;
+
+	if( priv->pmib->dot1180211sInfo.mesh_enable && (dev == priv->mesh_dev)) {
+		tx_flag = TX_NO_MUL2UNI;
+		goto mesh_skip;
+	}
 #endif // CONFIG_RTK_MESH
 
 #ifdef WDS
@@ -3705,9 +4161,17 @@ int __rtl8192cd_start_xmit(struct sk_buff *skb, struct net_device *dev, int tx_f
 #endif
 
 #ifdef CONFIG_RTL8672
+#ifdef SUPPORT_TX_MCAST2UNI
+	skb->cb[16] = tx_flag;
+#endif
+
 	//IGMP snooping
 	if (check_wlan_mcast_tx(skb)==1) {
+#ifdef SW_TX_QUEUE
+		goto free_and_stoptx;
+#else
 		goto free_and_stop;
+#endif		
 	}
 
 	// Mason Yu
@@ -3715,7 +4179,11 @@ int __rtl8192cd_start_xmit(struct sk_buff *skb, struct net_device *dev, int tx_f
 		for (k=0; k<5; k++) {
 			if (dev == wlanDev[k].dev_pointer) {
 				if (wlanDev[k].dev_ifgrp_member!=0 && skb->vlan_member!=0 && skb->vlan_member!=wlanDev[k].dev_ifgrp_member) {
+#ifdef SW_TX_QUEUE
+					goto free_and_stoptx;
+#else					
 					goto free_and_stop;
+#endif					
 				}
 				break;
 			}
@@ -3757,6 +4225,7 @@ int __rtl8192cd_start_xmit(struct sk_buff *skb, struct net_device *dev, int tx_f
 	if (priv->pmib->vlan.global_vlan &&
 			ntohs(*((UINT16 *)((UINT8 *)skb->data + ETH_ALEN*2))) != 0x888e) {
 		int get_pri = 0;
+#ifdef WIFI_WMM
 		if (QOS_ENABLE) {
 #ifdef CLIENT_MODE
 			if ((OPMODE & (WIFI_STATION_STATE | WIFI_ASOC_STATE)) == (WIFI_STATION_STATE | WIFI_ASOC_STATE))
@@ -3776,6 +4245,7 @@ int __rtl8192cd_start_xmit(struct sk_buff *skb, struct net_device *dev, int tx_f
 			if (pstat && pstat->QosEnabled)
 				get_pri = 1;
 		}
+#endif
 
 		if (!get_pri)
 			skb->cb[0] = '\0';
@@ -3866,6 +4336,8 @@ int __rtl8192cd_start_xmit(struct sk_buff *skb, struct net_device *dev, int tx_f
 			goto stop_proc;
 #endif
 		}
+		
+		dhcp_flag_bcast(priv, skb);
 	}
 #endif // CLIENT_MODE
 
@@ -3888,6 +4360,69 @@ int __rtl8192cd_start_xmit(struct sk_buff *skb, struct net_device *dev, int tx_f
 	}
 #endif
 
+#ifdef USE_TXQUEUE
+	if (GET_ROOT(priv)->pmib->miscEntry.use_txq && priv->pshare->iot_mode_enable) {
+		int pri = 0, qnum = BE_QUEUE, qlen = 0, qidx = 0;
+		pri = get_skb_priority(priv, skb);
+#ifdef RTL_MANUAL_EDCA
+        q_num = PRI_TO_QNUM(priv, pri);
+#else
+		PRI_TO_QNUM(pri, qnum, priv->pmib->dot11OperationEntry.wifi_specific);
+#endif
+		
+		if (!priv->pshare->txq_isr)
+		{
+			if (txq_len(&priv->pshare->txq_list[qnum]) > 0)
+			{
+#if defined(RESERVE_TXDESC_FOR_EACH_IF) && (defined(UNIVERSAL_REPEATER) || defined(MBSSID))
+				if (GET_ROOT(priv)->pmib->miscEntry.rsv_txdesc) {
+					if (!check_txq_dynamic_mechanism(priv, qnum)) {
+						append_skb_to_txq_tail(&priv->pshare->txq_list[qnum], priv, skb, dev, &priv->pshare->txq_pool);
+						priv->use_txq_cnt[qnum]++;
+						priv->pshare->txq_check = 1;
+#ifdef SW_TX_QUEUE
+				        goto stop_proctx;
+#else
+						goto stop_proc;
+#endif
+					} else {
+						DEBUG_ERR("TX DROP: exceed the tx queue!\n");
+						priv->ext_stats.tx_drops++;
+#ifdef SW_TX_QUEUE
+			            goto free_and_stoptx;
+#else
+						goto free_and_stop;
+#endif
+					}
+				}
+				else
+#endif
+				{
+					for (qidx=0; qidx<7; qidx++)
+						qlen += txq_len(&priv->pshare->txq_list[qidx]);
+					if (qlen < TXQUEUE_SIZE) {
+						append_skb_to_txq_tail(&priv->pshare->txq_list[qnum], priv, skb, dev, &priv->pshare->txq_pool);
+						priv->pshare->txq_check = 1;
+#ifdef SW_TX_QUEUE
+			            goto stop_proctx;
+#else
+						goto stop_proc;
+#endif
+					} else {
+						DEBUG_ERR("TX DROP: exceed the tx queue!\n");
+						priv->ext_stats.tx_drops++;
+#ifdef SW_TX_QUEUE
+			            goto free_and_stoptx;
+#else
+						goto free_and_stop;
+#endif
+					}
+				}
+			}
+		}
+	}
+#endif
+
 #ifdef ENABLE_RTL_SKB_STATS
 	rtl_atomic_inc(&priv->rtl_tx_skb_cnt);
 #endif
@@ -3898,16 +4433,19 @@ int __rtl8192cd_start_xmit(struct sk_buff *skb, struct net_device *dev, int tx_f
 	else
 #endif
 #ifdef CONFIG_RTK_MESH
-	if(dev == priv->mesh_dev)
+	if(dev == priv->mesh_dev) {
 		da = txcfg->nhop_11s;
+	}
 	else
 #endif
+	{
 
 #ifdef MCAST2UI_REFINE
         da = &skb->cb[10];
 #else
-	da = skb->data;
+		da = skb->data;
 #endif
+	}
 
 #ifdef CLIENT_MODE
 	if ((OPMODE & (WIFI_STATION_STATE | WIFI_ASOC_STATE)) == (WIFI_STATION_STATE | WIFI_ASOC_STATE))
@@ -3924,6 +4462,10 @@ int __rtl8192cd_start_xmit(struct sk_buff *skb, struct net_device *dev, int tx_f
 #ifdef SW_TX_QUEUE
 		if (pstat) {
 			swq_out = priv->swq_en | pstat->swq.beq_empty | pstat->swq.viq_empty | pstat->swq.voq_empty | pstat->swq.bkq_empty;
+#ifdef TX_EARLY_MODE
+			if (GET_TX_EARLY_MODE && GET_EM_SWQ_ENABLE) 
+				priv->swq_en = 1;		
+#endif			
 		}
 #endif
 	}
@@ -3943,6 +4485,9 @@ int __rtl8192cd_start_xmit(struct sk_buff *skb, struct net_device *dev, int tx_f
 
 	//if ((pstat == NULL) || (pstat && (!priv->swq_en) && (!(pstat->swq.beq_empty | pstat->swq.viq_empty | pstat->swq.voq_empty | pstat->swq.bkq_empty))))
 	if (swq_out == 0) {
+#ifdef CONFIG_RTK_MESH
+mesh_skip:
+#endif
      		return __rtl8192cd_start_xmit_out(skb, pstat);
 	} else if (priv->swq_en) {
 		return sw_enqueue(priv,skb,pstat);
@@ -3980,9 +4525,10 @@ int __rtl8192cd_start_xmit(struct sk_buff *skb, struct net_device *dev, int tx_f
 				continue;
 
 			ptimer->data = (unsigned long)pstat;
-			sw_dequeue(pqueue, ptimer);//, pempty, pstat);
+			sw_dequeue(priv, pqueue, ptimer);//, pempty, pstat);
 			*pempty = 0;
 		}
+
 	    __rtl8192cd_start_xmit_out(skb, pstat);
 	}
     goto stop_proctx;
@@ -4007,6 +4553,7 @@ int __rtl8192cd_start_xmit_out(struct sk_buff *skb, struct stat_info *pstat) //s
     struct net_device *wdsDev = NULL;
 #if defined(CONFIG_RTL8672) || defined(TX_SHORTCUT)
     int k;
+    int tx_flag;
 #endif
     struct tx_insn tx_insn;
     int real_len;
@@ -4014,6 +4561,15 @@ int __rtl8192cd_start_xmit_out(struct sk_buff *skb, struct stat_info *pstat) //s
 
 	priv = (struct rtl8192cd_priv *)dev->priv;
 
+#ifdef CONFIG_RTL8672
+#ifdef SUPPORT_TX_MCAST2UNI
+	if (tx_flag == TX_NO_MUL2UNI)
+		txcfg->isMC2UC = 1;
+	else
+		txcfg->isMC2UC = 0;
+#endif
+#endif
+
 #ifdef WDS
 	if (dev->base_addr) {
 		// normal packets
@@ -4033,6 +4589,11 @@ int __rtl8192cd_start_xmit_out(struct sk_buff *skb, struct stat_info *pstat) //s
 
 #endif
 
+#ifdef CONFIG_RTL_MESH_SUPPORT
+	if( skb->dev == priv->mesh_dev )
+		if(!start_xmit_mesh(skb, dev, txcfg))
+			goto stop_proc;
+#endif
 /*
 	if (UseSwCrypto(priv, pstat, (pstat ? FALSE : TRUE)) ||					// sw enc will modify content
 		(pstat && (get_sta_encrypt_algthm(priv, pstat) == _TKIP_PRIVACY_)))	// need append MIC
@@ -4075,12 +4636,14 @@ int __rtl8192cd_start_xmit_out(struct sk_buff *skb, struct stat_info *pstat) //s
 #ifdef MCAST2UI_REFINE
                 if ((pstat && ((pstat->state & (WIFI_SLEEP_STATE | WIFI_ASOC_STATE)) ==
                                 (WIFI_SLEEP_STATE | WIFI_ASOC_STATE))) ||
-                        (IS_MCAST(&skb->cb[10]) && (priv->sleep_list.next != &priv->sleep_list) &&
+                        (((IS_MCAST(&skb->cb[10]) && (priv->sleep_list.next != &priv->sleep_list)) ||
+                        ((priv->pshare->rf_ft_var.bcast_to_dzq) && (skb->cb[10] == 0xff))) &&
                                 (!priv->release_mcast)))
 #else
 		if ((pstat && ((pstat->state & (WIFI_SLEEP_STATE | WIFI_ASOC_STATE)) ==
 				(WIFI_SLEEP_STATE | WIFI_ASOC_STATE))) ||
-			(IS_MCAST(skb->data) && (priv->sleep_list.next != &priv->sleep_list) &&
+			(((IS_MCAST(skb->data) && (priv->sleep_list.next != &priv->sleep_list)) ||
+			(priv->pshare->rf_ft_var.bcast_to_dzq && (*(skb->data) == 0xff))) &&
 				(!priv->release_mcast)))
 #endif
 		{
@@ -4193,7 +4756,7 @@ int __rtl8192cd_start_xmit_out(struct sk_buff *skb, struct stat_info *pstat) //s
 			tx_tail = get_txtail_addr(phw, q_num);
 			// check if we need active tx tasklet
 #ifdef __KERNEL__
-			if (CIRC_SPACE_RTK(*tx_head, *tx_tail, NUM_TX_DESC) < NUM_TX_DESC/2) {
+			if (CIRC_SPACE_RTK(*tx_head, *tx_tail, CURRENT_NUM_TX_DESC) < CURRENT_NUM_TX_DESC/2) {
 				if (!priv->pshare->has_triggered_tx_tasklet) {
 					tasklet_schedule(&priv->pshare->tx_tasklet);
 					priv->pshare->has_triggered_tx_tasklet = 1;
@@ -4201,36 +4764,81 @@ int __rtl8192cd_start_xmit_out(struct sk_buff *skb, struct stat_info *pstat) //s
 			}
 #endif
 			// Check if we need to reclaim TX-ring before processing TX
-			if (CIRC_SPACE_RTK(*tx_head, *tx_tail, NUM_TX_DESC) < 10) {
+			if (CIRC_SPACE_RTK(*tx_head, *tx_tail, CURRENT_NUM_TX_DESC) < 10) {
 				rtl8192cd_tx_queueDsr(priv, q_num);
 			}
 
-#if defined(RESERVE_TXDESC_FOR_EACH_IF) && (defined(UNIVERSAL_REPEATER) || defined(MBSSID))
-			if ( priv->pmib->miscEntry.rsv_txdesc ) {
+#if defined(RESERVE_TXDESC_FOR_EACH_IF)
+#if defined(UNIVERSAL_REPEATER) || defined(MBSSID)
+			if ( GET_ROOT(priv)->pmib->miscEntry.rsv_txdesc ) {
 				if( check_txdesc_dynamic_mechanism(priv, q_num, 2) ) {
-					DEBUG_WARN("%d hw Queue desc exceed available count: used:%d\n", q_num, priv->use_txdesc_cnt[q_num]);
-					rtl8192cd_tx_xmitSkbFail(priv, skb, dev, wdsDev, txcfg);
+#ifdef USE_TXQUEUE
+					if (GET_ROOT(priv)->pmib->miscEntry.use_txq && priv->pshare->iot_mode_enable) {
+						if (priv->pshare->txq_isr) {
+							append_skb_to_txq_head(&priv->pshare->txq_list[q_num], priv, skb, dev, &priv->pshare->txq_pool);
+							priv->pshare->txq_stop = 1;
+						} else {
+							append_skb_to_txq_tail(&priv->pshare->txq_list[q_num], priv, skb, dev, &priv->pshare->txq_pool);
+						}
+						priv->use_txq_cnt[q_num]++;
+						priv->pshare->txq_check = 1;
+					}
+					else
+#endif
+					{
+						DEBUG_WARN("%d hw Queue desc exceed available count: used:%d\n", q_num, priv->use_txdesc_cnt[q_num]);
+						rtl8192cd_tx_xmitSkbFail(priv, skb, dev, wdsDev, txcfg);
+					}
 					goto stop_proc;
 				}
 			} else
 #endif
+#endif
 			{
-//			if ((2 + 2) > CIRC_SPACE_RTK(*tx_head, *tx_tail, NUM_TX_DESC)) //per mpdu, we need 2 desc...
-			if ((4) > CIRC_SPACE_RTK(*tx_head, *tx_tail, NUM_TX_DESC)) //per mpdu, we need 2 desc...
+#ifdef TX_EARLY_MODE
+			if (((GET_TX_EARLY_MODE && GET_EM_SWQ_ENABLE) ? 14 : 4) >
+					 CIRC_SPACE_RTK(*tx_head, *tx_tail, CURRENT_NUM_TX_DESC))
+#else
+			if ((4) > CIRC_SPACE_RTK(*tx_head, *tx_tail, CURRENT_NUM_TX_DESC)) //per mpdu, we need 2 desc...
+#endif
 			{
 				// 2 is for spare...
-				DEBUG_ERR("%d hw Queue desc not available! head=%d, tail=%d request %d\n",q_num,*tx_head,*tx_tail,2);
-				rtl8192cd_tx_xmitSkbFail(priv, skb, dev, wdsDev, txcfg);
+#ifdef USE_TXQUEUE
+				if (GET_ROOT(priv)->pmib->miscEntry.use_txq && priv->pshare->iot_mode_enable) {
+					if (priv->pshare->txq_isr) {
+						append_skb_to_txq_head(&priv->pshare->txq_list[q_num], priv, skb, dev, &priv->pshare->txq_pool);
+						priv->pshare->txq_stop = 1;
+					} else {
+						append_skb_to_txq_tail(&priv->pshare->txq_list[q_num], priv, skb, dev, &priv->pshare->txq_pool);
+					}
+					priv->pshare->txq_check = 1;
+				}
+				else
+#endif
+				{
+					DEBUG_ERR("%d hw Queue desc not available! head=%d, tail=%d request %d\n",q_num,*tx_head,*tx_tail,2);
+					rtl8192cd_tx_xmitSkbFail(priv, skb, dev, wdsDev, txcfg);
+				}
 				goto stop_proc;
 			}
 			}
 
 #if defined(MESH_TX_SHORTCUT)
-			if((txcfg->is_11s&1) && !mesh_txsc_decision(txcfg, &pstat->tx_sc_ent[k].txcfg))
+			if((txcfg->is_11s&1) && !mesh_txsc_decision(txcfg, &pstat->tx_sc_ent[k].txcfg)) {
 					goto just_skip;
+			}
 #endif
-
 			memcpy(txcfg, &pstat->tx_sc_ent[k].txcfg, sizeof(struct tx_insn));
+
+#ifdef CONFIG_RTL8672
+#ifdef SUPPORT_TX_MCAST2UNI
+			if (tx_flag == TX_NO_MUL2UNI)
+				txcfg->isMC2UC = 1;
+			else
+				txcfg->isMC2UC = 0;
+#endif
+#endif
+
 			txcfg->phdr = (UINT8 *)get_wlanllchdr_from_poll(priv);
 			if (txcfg->phdr == NULL) {
 				DEBUG_ERR("Can't alloc wlan header!\n");
@@ -4263,14 +4871,20 @@ int __rtl8192cd_start_xmit_out(struct sk_buff *skb, struct stat_info *pstat) //s
 
 #ifdef MESH_TX_SHORTCUT
 			if ( (txcfg->is_11s&1) && (GetFrameSubType(txcfg->phdr) == WIFI_11S_MESH))
-                    if( !reuse_meshhdr(priv, txcfg) )
+                    if( !reuse_meshhdr(priv, txcfg) ) {
+							txsc_debug("Mesh reuse header\n");
 					        goto stop_proc;
+					}
 #endif
 			txcfg->tx_rate = get_tx_rate(priv, pstat);
 			txcfg->lowest_tx_rate = get_lowest_tx_rate(priv, pstat, txcfg->tx_rate);
-
 			// log tx statistics...
+
+#ifdef CONFIG_RTL8672
+			tx_sum_up(priv, pstat, txcfg->fr_len+txcfg->hdr_len+txcfg->iv+txcfg->llc+txcfg->mic+txcfg->icv, txcfg);
+#else
 			tx_sum_up(priv, pstat, txcfg->fr_len+txcfg->hdr_len+txcfg->iv+txcfg->llc+txcfg->mic+txcfg->icv);
+#endif
 			SNMP_MIB_INC(dot11TransmittedFragmentCount, 1);
 
 #ifdef PCIE_POWER_SAVING
@@ -4301,7 +4915,11 @@ int __rtl8192cd_start_xmit_out(struct sk_buff *skb, struct stat_info *pstat) //s
 				(pstat->protection == priv->pmib->dot11ErpInfo.protection) &&
 				(pstat->ht_protection == priv->ht_protection)
 #if defined(WIFI_WMM) && defined(WMM_APSD)
-				&& (!((APSD_ENABLE) && (pstat->state & WIFI_SLEEP_STATE)))
+				&& (!(
+#ifdef CLIENT_MODE
+				(OPMODE & WIFI_AP_STATE) &&
+#endif
+				(APSD_ENABLE) && (pstat->state & WIFI_SLEEP_STATE)))
 #endif
 				) {
 
@@ -4325,7 +4943,11 @@ int __rtl8192cd_start_xmit_out(struct sk_buff *skb, struct stat_info *pstat) //s
 
 
 				{
-					if ((skb_headroom(skb) >= (txcfg->hdr_len + txcfg->llc + txcfg->iv)) &&
+					if ((skb_headroom(skb) >= (txcfg->hdr_len + txcfg->llc + txcfg->iv
+#ifdef TX_EARLY_MODE
+						+ (GET_TX_EARLY_MODE ? 8 : 0)
+#endif
+						)) &&
 						!skb_cloned(skb) &&
 						(txcfg->privacy != _TKIP_PRIVACY_)
 #if defined(CONFIG_RTL_WAPI_SUPPORT)
@@ -4340,21 +4962,24 @@ int __rtl8192cd_start_xmit_out(struct sk_buff *skb, struct stat_info *pstat) //s
 					}
 				}
 
-#if defined(RESERVE_TXDESC_FOR_EACH_IF) && (defined(UNIVERSAL_REPEATER) || defined(MBSSID))
-				if (priv->pmib->miscEntry.rsv_txdesc) {
+#if defined(RESERVE_TXDESC_FOR_EACH_IF)
+#if (defined(UNIVERSAL_REPEATER) || defined(MBSSID))
+				if (GET_ROOT(priv)->pmib->miscEntry.rsv_txdesc) {
 					priv->use_txdesc_cnt[q_num] += (txcfg->one_txdesc)? 1 : 2;
 					if ( rtl8192cd_signin_txdesc_shortcut(priv, txcfg, k))
 						priv->use_txdesc_cnt[q_num] -= (txcfg->one_txdesc)? 1 : 2;
 				} else
 #endif
+#endif
 				{
 				rtl8192cd_signin_txdesc_shortcut(priv, txcfg, k);
 				}
 				goto stop_proc;
 			}
 
-#if defined(RESERVE_TXDESC_FOR_EACH_IF) && (defined(UNIVERSAL_REPEATER) || defined(MBSSID))
-			if (priv->pmib->miscEntry.rsv_txdesc) {
+#if defined(RESERVE_TXDESC_FOR_EACH_IF)
+#if (defined(UNIVERSAL_REPEATER) || defined(MBSSID))
+			if (GET_ROOT(priv)->pmib->miscEntry.rsv_txdesc) {
 				int desc_num=2;	
 				if ( txcfg->privacy
 #if defined(CONFIG_RTL_WAPI_SUPPORT)
@@ -4369,8 +4994,13 @@ int __rtl8192cd_start_xmit_out(struct sk_buff *skb, struct stat_info *pstat) //s
 				}
 			} else
 #endif
+#endif
 			{
+#ifdef CONFIG_RTK_MESH
+				rtl8192cd_signin_txdesc(priv, txcfg, NULL);
+#else
 				rtl8192cd_signin_txdesc(priv, txcfg);
+#endif
 			}
 
 			pstat->tx_sc_ent[k].txcfg.tx_rate = txcfg->tx_rate;
@@ -4380,7 +5010,6 @@ int __rtl8192cd_start_xmit_out(struct sk_buff *skb, struct stat_info *pstat) //s
 #ifdef CONFIG_RTK_MESH
 just_skip:
 #endif
-
 	/* ==================== Slow path of packet TX process ==================== */
 	if (rtl8192cd_tx_slowPath(priv, skb, pstat, dev, wdsDev, txcfg) == TX_PROCEDURE_CTRL_STOP) {
 		goto stop_proc;
@@ -4483,8 +5112,7 @@ int rtl8192cd_signin_txdesc_shortcut(struct rtl8192cd_priv *priv, struct tx_insn
 	pdesc->Dword3 = 0;
 	pdesc->Dword3 = set_desc((GetSequence(txcfg->phdr) & TX_SeqMask) << TX_SeqSHIFT);
 
-#ifdef CONFIG_RTL_92D_SUPPORT
-	if (GET_CHIP_VER(priv)==VERSION_8192D){
+	if (priv->pmib->dot11RFEntry.txbf == 1) {
 		pdesc->Dword2 &= set_desc(0x03ffffff); // clear related bits
 		pdesc->Dword2 |= set_desc(1 << TX_TxAntCckSHIFT);	// Set Default CCK rate with 1T
 		pdesc->Dword2 |= set_desc(1 << TX_TxAntlSHIFT); 	// Set Default Legacy rate with 1T
@@ -4496,30 +5124,91 @@ int rtl8192cd_signin_txdesc_shortcut(struct rtl8192cd_priv *priv, struct tx_insn
 			}
 		}
 	}
-#endif
 
 //	if (txcfg->pstat)
 //		pdesc->Dword1 |= set_desc(txcfg->pstat->aid & TX_MACIDMask);
 
 	//set Break
 	if((txcfg->q_num >=1 && txcfg->q_num <=4)){
-		if((txcfg->pstat != priv->pshare->CurPstat[txcfg->q_num-1])) {
+		if((pstat != priv->pshare->CurPstat[txcfg->q_num-1])) {
+#ifdef CONFIG_RTL_88E_SUPPORT
+			if (GET_CHIP_VER(priv)==VERSION_8188E)
+				pdesc->Dword2 |= set_desc(TXdesc_88E_BK);
+			else
+#endif
+				pdesc->Dword1 |= set_desc(TX_BK);
+			priv->pshare->CurPstat[txcfg->q_num-1] = pstat;
+		} else
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv)==VERSION_8188E) {
+			pdesc->Dword2 &= set_desc(~TXdesc_88E_BK);
+		} else
+#endif
+		{
+			pdesc->Dword1 &= set_desc(~TX_BK); // clear it
+		}
+	} else {
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if (GET_CHIP_VER(priv)==VERSION_8188E)
+			pdesc->Dword2 |= set_desc(TXdesc_88E_BK);
+		else
+#endif
 			pdesc->Dword1 |= set_desc(TX_BK);
-			priv->pshare->CurPstat[txcfg->q_num-1] = txcfg->pstat;
+	}
+
+	if (pstat->is_intel_sta) {
+		if (is_MCS_rate(pstat->current_tx_rate) && !(pstat->leave)
+			&& priv->pshare->intel_rty_lmt) {
+			pdesc->Dword5 |= set_desc(TX_RtyLmtEn);
+			pdesc->Dword5 |= set_desc((priv->pshare->intel_rty_lmt & TX_DataRtyLmtMask) << TX_DataRtyLmtSHIFT);
+		} else {
+			pdesc->Dword5 &= set_desc(~TX_RtyLmtEn);
+			pdesc->Dword5 &= set_desc(~(TX_DataRtyLmtMask << TX_DataRtyLmtSHIFT));
 		}
+	}
+
+#if defined(CONFIG_RTL_88E_SUPPORT) && defined(TXREPORT)
+	if ((GET_CHIP_VER(priv)==VERSION_8188E) && (!txcfg->fixed_rate)) {
+		if (pstat->ht_current_tx_info & TX_USE_SHORT_GI)
+			pdesc->Dword5 |= set_desc(TX_SGI);
 		else
-			pdesc->Dword1 &= set_desc(~TX_BK); // clear it		
-	} else {
-		pdesc->Dword1 |= set_desc(TX_BK);
-	}		
+			pdesc->Dword5 &= set_desc(~TX_SGI);
+	}
+#endif
 
 	if (txcfg->one_txdesc) {
-		pdesc->Dword0 = set_desc((get_desc(pdesc->Dword0) & 0xffff0000) |
-			TX_LastSeg | (txcfg->hdr_len + txcfg->llc + txcfg->iv + txcfg->fr_len));
-		pdesc->Dword7 = set_desc((get_desc(pdesc->Dword7) & 0xffff0000) |
-			(txcfg->hdr_len + txcfg->llc + txcfg->iv + txcfg->fr_len));
+#ifdef TX_EARLY_MODE
+		if (GET_TX_EARLY_MODE) {
+			pdesc->Dword0 = set_desc(((get_desc(pdesc->Dword0) & 0xff00ffff) |(0x28 << TX_OffsetSHIFT)) |
+									TX_LastSeg | 	(txcfg->hdr_len + txcfg->llc + txcfg->iv + txcfg->fr_len));
+			pdesc->Dword1 = set_desc(get_desc(pdesc->Dword1) | (1 << TX_PktOffsetSHIFT) );
+			pdesc->Dword7 = set_desc((get_desc(pdesc->Dword7) & 0xffff0000) |
+						(txcfg->hdr_len + txcfg->llc + txcfg->iv + txcfg->fr_len+8));
+			
+			memset(txcfg->phdr-8, '\0', 8);			
+			if (pstat->empkt_num > 0) 				
+				insert_emcontent(priv, txcfg, txcfg->phdr-8);
+						
+			pdesc->Dword8 = set_desc(get_physical_addr(priv, txcfg->phdr-8,
+				(get_desc(pdesc->Dword7)&TX_TxBufSizeMask), PCI_DMA_TODEVICE));
+					
+		}
+		else
+#endif
+		{		
+			pdesc->Dword0 = set_desc((get_desc(pdesc->Dword0) & 0xffff0000) |
+				TX_LastSeg | (txcfg->hdr_len + txcfg->llc + txcfg->iv + txcfg->fr_len));
+			pdesc->Dword7 = set_desc((get_desc(pdesc->Dword7) & 0xffff0000) |
+				(txcfg->hdr_len + txcfg->llc + txcfg->iv + txcfg->fr_len));
+		}
 	}
 
+#ifdef TX_EARLY_MODE
+	if (GET_TX_EARLY_MODE) 
+		pdesc->Dword8 = set_desc(get_physical_addr(priv, txcfg->phdr-8,
+			(get_desc(pdesc->Dword7)& TX_TxBufSizeMask), PCI_DMA_TODEVICE));
+	else
+#endif
 	pdesc->Dword8 = set_desc(get_physical_addr(priv, txcfg->phdr,
 		(get_desc(pdesc->Dword7)& TX_TxBufSizeMask), PCI_DMA_TODEVICE));
 
@@ -4530,17 +5219,29 @@ int rtl8192cd_signin_txdesc_shortcut(struct rtl8192cd_priv *priv, struct tx_insn
 		pdescinfo->pframe = pskb;
 		pdescinfo->priv = priv;
 #if defined(WIFI_WMM) && defined(WMM_APSD)
-		pdescinfo->pstat = txcfg->pstat;
+		pdescinfo->pstat = pstat;
 #endif
 	}
 	else {
 		pdescinfo->pframe = txcfg->phdr;
 #if defined(WIFI_WMM) && defined(WMM_APSD)
 		pdescinfo->priv = priv;
-		pdescinfo->pstat = txcfg->pstat;
+		pdescinfo->pstat = pstat;
 #endif
 	}
 
+#ifdef CLIENT_MODE
+	if (OPMODE & WIFI_STATION_STATE) {
+		if (GetFrameSubType(pdescinfo->pframe) == WIFI_PSPOLL)
+			pdesc->Dword1 |= set_desc(TX_NAVUSEHDR);
+
+		if (priv->ps_state)
+			SetPwrMgt(pdescinfo->pframe);
+		else
+			ClearPwrMgt(pdescinfo->pframe);
+	}
+#endif
+
 	pfrst_dma_desc = dma_txhead[*tx_head];
 /*
 #ifdef USE_RTL8186_SDK
@@ -4723,6 +5424,7 @@ static int check_txdesc(struct rtl8192cd_priv *priv, struct tx_insn* txcfg)
 
 			txcfg->tx_rate = get_tx_rate(priv, pstat);
 			txcfg->lowest_tx_rate = get_lowest_tx_rate(priv, pstat, txcfg->tx_rate);
+
 			if (priv->pmib->dot11WdsInfo.entry[pstat->wds_idx].txRate)
 				txcfg->fixed_rate = 1;
 			txcfg->need_ack = 1;
@@ -4786,7 +5488,7 @@ static int check_txdesc(struct rtl8192cd_priv *priv, struct tx_insn* txcfg)
 		if (!da)
 #endif
 #ifdef MCAST2UI_REFINE
-                        da = &pskb->cb[10];
+			da = &pskb->cb[10];
 #else
 			da = pskb->data;
 #endif
@@ -4895,6 +5597,7 @@ static int check_txdesc(struct rtl8192cd_priv *priv, struct tx_insn* txcfg)
 			}
 
 			if (txcfg->aggre_en >= FG_AGGRE_MPDU && txcfg->aggre_en <= FG_AGGRE_MPDU_BUFFER_LAST) {
+				//panic_printk("%s %d pstat->ADDBA_ready[priority]=%d, priority=%d\n",__func__,__LINE__,pstat->ADDBA_ready[priority],priority);
 				if (!pstat->ADDBA_ready[priority]) {
 					if ((pstat->ADDBA_req_num[priority] < 5) && !pstat->ADDBA_sent[priority]) {
 						pstat->ADDBA_req_num[priority]++;
@@ -5025,7 +5728,7 @@ static int check_txdesc(struct rtl8192cd_priv *priv, struct tx_insn* txcfg)
 			txcfg->need_ack = 0;
 			txcfg->rts_thrshld = 10000;
 		}
-		else
+		else if(!(txcfg->phdr && (GetFrameType(txcfg->phdr) == WIFI_MGT_TYPE) && (GetFrameSubType((unsigned char *) (txcfg->phdr))>>4 == 5)))	//  exclude probe rsp
 		{
 			pstat = get_stainfo(priv, da);
 			txcfg->pstat = pstat;
@@ -5095,9 +5798,11 @@ int __rtl8192cd_firetx(struct rtl8192cd_priv *priv, struct tx_insn* txcfg)
 	pethhdr = &ethhdr;
 #endif
 
-#if defined(RESERVE_TXDESC_FOR_EACH_IF) && (defined(UNIVERSAL_REPEATER) || defined(MBSSID))
+#if defined(RESERVE_TXDESC_FOR_EACH_IF)
+#if(defined(UNIVERSAL_REPEATER) || defined(MBSSID))
 	unsigned int		txdesc_need = 1, ret_txdesc = 0;
 #endif
+#endif
 	unsigned int		x;
 
 	/*---frag_thrshld setting---plus tune---0115*/
@@ -5177,21 +5882,58 @@ int __rtl8192cd_firetx(struct rtl8192cd_priv *priv, struct tx_insn* txcfg)
 		else
 			val32 = txcfg->frg_num * 2;
 
-#if defined(RESERVE_TXDESC_FOR_EACH_IF) && (defined(UNIVERSAL_REPEATER) || defined(MBSSID))
-		if(priv->pmib->miscEntry.rsv_txdesc) {
+#if defined(RESERVE_TXDESC_FOR_EACH_IF)
+#if (defined(UNIVERSAL_REPEATER) || defined(MBSSID))
+		if(GET_ROOT(priv)->pmib->miscEntry.rsv_txdesc) {
 			if (check_txdesc_dynamic_mechanism(priv, q_num, val32)) {
-				DEBUG_WARN("%d hw Queue desc exceed available count: used:%d\n", q_num,priv->use_txdesc_cnt[q_num]);
-				return CONGESTED;
+#ifdef USE_TXQUEUE
+				if (GET_ROOT(priv)->pmib->miscEntry.use_txq && priv->pshare->iot_mode_enable) {
+					if (priv->pshare->txq_isr) {
+						append_skb_to_txq_head(&priv->pshare->txq_list[q_num], priv, txcfg->pframe, priv->dev, &priv->pshare->txq_pool);
+						priv->pshare->txq_stop = 1;
+					} else {
+						append_skb_to_txq_tail(&priv->pshare->txq_list[q_num], priv, txcfg->pframe, priv->dev, &priv->pshare->txq_pool);
+					}
+					if (txcfg->phdr)
+						release_wlanllchdr_to_poll(priv, txcfg->phdr);
+					priv->use_txq_cnt[q_num]++;
+					priv->pshare->txq_check = 1;
+					return SUCCESS;					
+				}
+				else
+#endif
+				{
+					DEBUG_WARN("%d hw Queue desc exceed available count: used:%d\n", q_num,priv->use_txdesc_cnt[q_num]);
+					return CONGESTED;
+				}
 			}
 			txdesc_need = val32;
 		} else
 #endif
+#endif
 		{
-		if ((val32 + 2) > CIRC_SPACE_RTK(*tx_head, *tx_tail, NUM_TX_DESC)) //per mpdu, we need 2 desc...
+		if ((val32 + 2) > CIRC_SPACE_RTK(*tx_head, *tx_tail, CURRENT_NUM_TX_DESC)) //per mpdu, we need 2 desc...
 		{
 			 // 2 is for spare...
-			DEBUG_ERR("%d hw Queue desc not available! head=%d, tail=%d request %d\n",q_num,*tx_head,*tx_tail,val32);
-			 return CONGESTED;
+#ifdef USE_TXQUEUE
+			if (GET_ROOT(priv)->pmib->miscEntry.use_txq && priv->pshare->iot_mode_enable) {
+				if (priv->pshare->txq_isr) {
+					append_skb_to_txq_head(&priv->pshare->txq_list[q_num], priv, txcfg->pframe, priv->dev, &priv->pshare->txq_pool);
+					priv->pshare->txq_stop = 1;
+				} else {
+					append_skb_to_txq_tail(&priv->pshare->txq_list[q_num], priv, txcfg->pframe, priv->dev, &priv->pshare->txq_pool);
+				}
+				if (txcfg->phdr)
+					release_wlanllchdr_to_poll(priv, txcfg->phdr);
+				priv->pshare->txq_check = 1;
+				return SUCCESS;
+			}
+			else
+#endif
+			{
+				DEBUG_ERR("%d hw Queue desc not available! head=%d, tail=%d request %d\n",q_num,*tx_head,*tx_tail,val32);
+				return CONGESTED;
+			}
 		}
 	}
 	} else {
@@ -5383,7 +6125,11 @@ int __rtl8192cd_firetx(struct rtl8192cd_priv *priv, struct tx_insn* txcfg)
 		SetPrivacy(txcfg->phdr);
 
 	// log tx statistics...
+#ifdef CONFIG_RTL8672
+	tx_sum_up(priv, txcfg->pstat, txcfg->fr_len+txcfg->hdr_len+txcfg->iv+txcfg->llc+txcfg->mic+txcfg->icv, txcfg);
+#else
 	tx_sum_up(priv, txcfg->pstat, txcfg->fr_len+txcfg->hdr_len+txcfg->iv+txcfg->llc+txcfg->mic+txcfg->icv);
+#endif
 	SNMP_MIB_INC(dot11TransmittedFragmentCount, 1);
 
 	// for SW LED
@@ -5405,7 +6151,7 @@ int __rtl8192cd_firetx(struct rtl8192cd_priv *priv, struct tx_insn* txcfg)
 #ifdef SUPPORT_TX_AMSDU
 	if (txcfg->aggre_en == FG_AGGRE_MSDU_MIDDLE || txcfg->aggre_en == FG_AGGRE_MSDU_LAST) {
 #if defined(RESERVE_TXDESC_FOR_EACH_IF) && (defined(UNIVERSAL_REPEATER) || defined(MBSSID))
-		if (priv->pmib->miscEntry.rsv_txdesc) {
+		if (GET_ROOT(priv)->pmib->miscEntry.rsv_txdesc) {
 			priv->use_txdesc_cnt[q_num] += 1;
 			if (rtl8192cd_signin_txdesc_amsdu(priv, txcfg))
 				priv->use_txdesc_cnt[q_num] -= 1;
@@ -5420,8 +6166,9 @@ int __rtl8192cd_firetx(struct rtl8192cd_priv *priv, struct tx_insn* txcfg)
 #ifdef _11s_TEST_MODE_
 		signin_txdesc_galileo(priv, txcfg);
 #else
-#if defined(RESERVE_TXDESC_FOR_EACH_IF) && (defined(UNIVERSAL_REPEATER) || defined(MBSSID))
-		if (priv->pmib->miscEntry.rsv_txdesc) {
+#if defined(RESERVE_TXDESC_FOR_EACH_IF)
+#if (defined(UNIVERSAL_REPEATER) || defined(MBSSID))
+		if (GET_ROOT(priv)->pmib->miscEntry.rsv_txdesc) {
 			priv->use_txdesc_cnt[q_num] += txdesc_need;
 			if ((ret_txdesc = rtl8192cd_signin_txdesc(priv, txcfg)) != 0 ) {
 				if (
@@ -5435,8 +6182,13 @@ int __rtl8192cd_firetx(struct rtl8192cd_priv *priv, struct tx_insn* txcfg)
 			}
 		} else
 #endif
+#endif
 		{
+#ifdef CONFIG_RTK_MESH
+		rtl8192cd_signin_txdesc(priv, txcfg, pethhdr);
+#else
 		rtl8192cd_signin_txdesc(priv, txcfg);
+#endif
 		}
 #endif
 	}
@@ -5538,7 +6290,7 @@ static int rtl8192cd_tx_recycle(struct rtl8192cd_priv *priv, unsigned int txRing
 	pdescH		= get_txdesc(phw, txRingIdx);
 	pdescinfoH	= get_txdesc_info(priv->pshare->pdesc_info, txRingIdx);
 
-	while (CIRC_CNT_RTK(head, tail, NUM_TX_DESC))
+	while (CIRC_CNT_RTK(head, tail, CURRENT_NUM_TX_DESC))
 	{
 		pdesc = pdescH + (tail);
 		pdescinfo = pdescinfoH + (tail);
@@ -5550,7 +6302,7 @@ static int rtl8192cd_tx_recycle(struct rtl8192cd_priv *priv, unsigned int txRing
 		if (!pdesc || (get_desc(pdesc->Dword0) & TX_OWN))
 			break;
 
-#ifdef CONFIG_NET_PCI
+#if defined(CONFIG_NET_PCI) && !defined(USE_RTL8186_SDK)
 		if (IS_PCIBIOS_TYPE)
 			//use the paddr and flen of pdesc field for icv, mic case which doesn't fill the pdescinfo
 			pci_unmap_single(priv->pshare->pdev,
@@ -5623,10 +6375,10 @@ static int rtl8192cd_tx_recycle(struct rtl8192cd_priv *priv, unsigned int txRing
 
 		recycleCnt ++;
 
-		tail = (tail + 1) % NUM_TX_DESC;
+		tail = (tail + 1) % CURRENT_NUM_TX_DESC;
 
 #if defined(RESERVE_TXDESC_FOR_EACH_IF) && (defined(UNIVERSAL_REPEATER) || defined(MBSSID))
-		if (priv->pmib->miscEntry.rsv_txdesc)
+		if (GET_ROOT(priv)->pmib->miscEntry.rsv_txdesc)
 			pdescinfo->priv->use_txdesc_cnt[txRingIdx]--;
 #endif
 	}
@@ -5681,13 +6433,19 @@ void rtl8192cd_tx_dsr(unsigned long task_priv)
 		rtl8192cd_tx_restartQueue(priv);
 
 #ifdef MP_TEST
-	if ((OPMODE & (WIFI_MP_STATE|WIFI_MP_CTX_BACKGROUND))==(WIFI_MP_STATE|WIFI_MP_CTX_BACKGROUND)) {
+#if 1//def CONFIG_RTL8672
+	if ((OPMODE & (WIFI_MP_STATE|WIFI_MP_CTX_BACKGROUND|WIFI_MP_CTX_BACKGROUND_STOPPING))
+			==(WIFI_MP_STATE|WIFI_MP_CTX_BACKGROUND))
+#else //CONFIG_RTL8672
+	if ((OPMODE & (WIFI_MP_STATE|WIFI_MP_CTX_BACKGROUND))==(WIFI_MP_STATE|WIFI_MP_CTX_BACKGROUND)) 
+#endif //CONFIG_RTL8672
+	{
 		int *tx_head, *tx_tail;
 		RESTORE_INT(flags);
 		SMP_UNLOCK(flags);
 		tx_head = get_txhead_addr(phw, BE_QUEUE);
 		tx_tail = get_txtail_addr(phw, BE_QUEUE);
-		if (CIRC_SPACE_RTK(*tx_head, *tx_tail, NUM_TX_DESC) > (NUM_TX_DESC/2))
+		if (CIRC_SPACE_RTK(*tx_head, *tx_tail, CURRENT_NUM_TX_DESC) > (CURRENT_NUM_TX_DESC/2))
 			mp_ctx(priv, (unsigned char *)"tx-isr");
 		SAVE_INT_AND_CLI(flags);
 		SMP_LOCK(flags);
@@ -5696,6 +6454,39 @@ void rtl8192cd_tx_dsr(unsigned long task_priv)
 
 	refill_skb_queue(priv);
 
+#ifdef USE_TXQUEUE
+	if (GET_ROOT(priv)->pmib->miscEntry.use_txq && !priv->pshare->txq_isr && priv->pshare->txq_check)
+	{
+		int q_num, send_cnt = 0;
+		priv->pshare->txq_isr = 1;
+		
+		for (q_num=6; q_num>=0; q_num--)
+		{
+			priv->pshare->txq_stop = 0;
+			while ( txq_len(&priv->pshare->txq_list[q_num]) > 0 )
+			{
+				struct sk_buff *tmp_skb = NULL;
+				struct net_device *dev = NULL;
+				remove_skb_from_txq(&priv->pshare->txq_list[q_num], &tmp_skb, &dev, &priv->pshare->txq_pool);
+				if (tmp_skb && dev) {
+#if defined(RESERVE_TXDESC_FOR_EACH_IF) && (defined(UNIVERSAL_REPEATER) || defined(MBSSID))
+					if (GET_ROOT(priv)->pmib->miscEntry.rsv_txdesc)
+						((struct rtl8192cd_priv*)(dev->priv))->use_txq_cnt[q_num]--;
+#endif
+					__rtl8192cd_start_xmit(tmp_skb, dev, TX_NORMAL);
+					send_cnt++;
+					if (priv->pshare->txq_stop) break;
+				}
+			}
+		}
+		
+		priv->pshare->txq_isr = 0;
+
+		if (send_cnt == 0)
+			priv->pshare->txq_check = 0;
+	}
+#endif
+
 	priv->pshare->has_triggered_tx_tasklet = 0;
 
 	RESTORE_INT(flags);
diff --git a/drivers/net/wireless/rtl8192cd/8192cd_tx.h b/drivers/net/wireless/rtl8192cd/8192cd_tx.h
index eac90db..b9951ff 100644
--- a/drivers/net/wireless/rtl8192cd/8192cd_tx.h
+++ b/drivers/net/wireless/rtl8192cd/8192cd_tx.h
@@ -38,7 +38,7 @@ enum _TX_QUEUE_ {
 static __inline__ void init_txdesc(struct rtl8192cd_priv *priv, struct tx_desc *pdesc,
 				unsigned long ringaddr, unsigned int i)
 {
-	if (i == (NUM_TX_DESC - 1))
+	if (i == (CURRENT_NUM_TX_DESC - 1))
 		(pdesc + i)->Dword10 = set_desc(ringaddr); // NextDescAddress
 	else
 		(pdesc + i)->Dword10 = set_desc(ringaddr + (i+1) * sizeof(struct tx_desc)); // NextDescAddress
@@ -49,9 +49,9 @@ static __inline__ unsigned int get_mpdu_len(struct tx_insn *txcfg, unsigned int
 	return (txcfg->hdr_len + txcfg->llc + txcfg->iv + txcfg->icv + txcfg->mic + _CRCLNG_ + fr_len);
 }
 
-#define txdesc_rollover(ptxdesc, ptxhead)	(*ptxhead = (*ptxhead + 1) % NUM_TX_DESC)
+#define txdesc_rollover(ptxdesc, ptxhead)	(*ptxhead = (*ptxhead + 1) % CURRENT_NUM_TX_DESC)
 
-#define txdesc_rollback(ptxhead)			(*ptxhead = (*ptxhead == 0)? (NUM_TX_DESC - 1) : (*ptxhead - 1))
+#define txdesc_rollback(ptxhead)			(*ptxhead = (*ptxhead == 0)? (CURRENT_NUM_TX_DESC - 1) : (*ptxhead - 1))
 
 static __inline__ void tx_poll(struct rtl8192cd_priv *priv, int q_num)
 {
diff --git a/drivers/net/wireless/rtl8192cd/8192cd_util.c b/drivers/net/wireless/rtl8192cd/8192cd_util.c
index 230ae32..3b56c4c 100644
--- a/drivers/net/wireless/rtl8192cd/8192cd_util.c
+++ b/drivers/net/wireless/rtl8192cd/8192cd_util.c
@@ -29,6 +29,9 @@
 #if defined(CONFIG_RTL_CUSTOM_PASSTHRU)
 #include <linux/if_vlan.h>
 #endif
+#if defined(CONFIG_RTL_FASTBRIDGE)
+#include <net/rtl/features/fast_bridge.h>
+#endif
 
 #if defined(USE_PID_NOTIFY) && defined(LINUX_2_6_27_)
 struct pid *_wlanapp_pid;
@@ -867,11 +870,56 @@ void init_stainfo(struct rtl8192cd_priv *priv, struct stat_info *pstat)
 #endif
 }
 
-void free_sta_tx_skb(struct rtl8192cd_priv *priv, struct stat_info *pstat)
+#if defined(CONFIG_RTL_ETH_PRIV_SKB_DEBUG)
+void dump_sta_dz_queue_num(struct rtl8192cd_priv *priv, struct stat_info *pstat)
 {
 #if defined(WIFI_WMM) && defined(WMM_APSD)
 	int				hd, tl;
 #endif
+
+	// free all skb in dz_queue
+	
+	printk("---------------------------------------\n");
+	printk("pstat->dz_queue:%d\n",skb_queue_len(&pstat->dz_queue));
+
+#ifdef SW_TX_QUEUE
+	printk("swq.be_queue:%d\n",skb_queue_len(&pstat->swq.be_queue));
+	printk("swq.bk_queue:%d\n",skb_queue_len(&pstat->swq.bk_queue));
+	printk("swq.vi_queue:%d\n",skb_queue_len(&pstat->swq.vi_queue));
+	printk("swq.vo_queue:%d\n",skb_queue_len(&pstat->swq.vo_queue));
+#endif
+
+#if defined(WIFI_WMM) && defined(WMM_APSD)
+	hd = pstat->VO_dz_queue->head;
+	tl = pstat->VO_dz_queue->tail;
+	printk("VO_dz_queue:%d\n",CIRC_CNT(hd, tl, NUM_APSD_TXPKT_QUEUE));
+	hd = pstat->VI_dz_queue->head;
+	tl = pstat->VI_dz_queue->tail;
+	printk("VI_dz_queue:%d\n",CIRC_CNT(hd, tl, NUM_APSD_TXPKT_QUEUE));
+	hd = pstat->BE_dz_queue->head;
+	tl = pstat->BE_dz_queue->tail;
+	printk("BE_dz_queue:%d\n",CIRC_CNT(hd, tl, NUM_APSD_TXPKT_QUEUE));
+	hd = pstat->BK_dz_queue->head;
+	tl = pstat->BK_dz_queue->tail;
+	printk("BK_dz_queue:%d\n",CIRC_CNT(hd, tl, NUM_APSD_TXPKT_QUEUE));
+#endif
+
+#if defined(WIFI_WMM)
+	hd = pstat->MGT_dz_queue->head;
+	tl = pstat->MGT_dz_queue->tail;
+	printk("BK_dz_queue:%d\n",CIRC_CNT(hd, tl, NUM_DZ_MGT_QUEUE));
+#endif
+	
+	return;
+
+}
+#endif
+
+void free_sta_tx_skb(struct rtl8192cd_priv *priv, struct stat_info *pstat)
+{
+#ifdef WIFI_WMM
+	int				hd, tl;
+#endif
 	struct sk_buff	*pskb;
 
 	// free all skb in dz_queue
@@ -1006,19 +1054,28 @@ void release_stainfo(struct rtl8192cd_priv *priv, struct stat_info *pstat)
 			priv->pshare->marvellMapBitExt &= ~BIT(pstat->aid - FW_NUM_STAT - 1);
 		else
 #endif
+#ifdef CONFIG_RTL_88E_SUPPORT
+		if ((GET_CHIP_VER(priv) == VERSION_8188E) && (pstat->aid > 32))
+			priv->pshare->marvellMapBit_88e_hw_ext &= ~BIT(pstat->aid - 32 - 1);
+		else
+#endif
 			priv->pshare->marvellMapBit &= ~BIT(pstat->aid - 1);
 
 #ifdef STA_EXT
 		if ( (priv->pshare->marvellMapBit == 0 && priv->pshare->marvellMapBitExt == 0) && (priv->pshare->Reg_RRSR_2 != 0) && (priv->pshare->Reg_81b != 0))
 #else
-			if ( (priv->pshare->marvellMapBit == 0) && (priv->pshare->Reg_RRSR_2 != 0) && (priv->pshare->Reg_81b != 0))
+		if (((priv->pshare->marvellMapBit == 0)
+#ifdef CONFIG_RTL_88E_SUPPORT
+			&& (GET_CHIP_VER(priv) == VERSION_8188E)?(priv->pshare->marvellMapBit_88e_hw_ext == 0):(1)
 #endif
-			{
-				RTL_W8(RRSR+2, priv->pshare->Reg_RRSR_2);
-				RTL_W8(0x81b, priv->pshare->Reg_81b);
-				priv->pshare->Reg_RRSR_2 = 0;
-				priv->pshare->Reg_81b = 0;
-			}
+			) && (priv->pshare->Reg_RRSR_2 != 0) && (priv->pshare->Reg_81b != 0))
+#endif
+		{
+			RTL_W8(RRSR+2, priv->pshare->Reg_RRSR_2);
+			RTL_W8(0x81b, priv->pshare->Reg_81b);
+			priv->pshare->Reg_RRSR_2 = 0;
+			priv->pshare->Reg_81b = 0;
+		}
 	}
 
 #ifdef SMART_CONCURRENT_92D
@@ -1154,6 +1211,9 @@ void release_stainfo(struct rtl8192cd_priv *priv, struct stat_info *pstat)
 		cached_br_sta_dev = NULL;
 	}
 #endif
+#if defined(CONFIG_RTL_FASTBRIDGE)
+		rtl_fb_del_entry(pstat->hwaddr);
+#endif
 #else
 #ifdef BR_SHORTCUT
 	clear_shortcut_cache();
@@ -1209,6 +1269,12 @@ struct	stat_info *alloc_stainfo(struct rtl8192cd_priv *priv, unsigned char *hwad
 				pstat = &(priv->pshare->aidarray[i]->station);
 				memcpy(pstat->hwaddr, hwaddr, MACADDRLEN);
 				init_stainfo(priv, pstat);
+#if defined(CONFIG_RTL_88E_SUPPORT) && defined(TXREPORT)
+				if (GET_CHIP_VER(priv)==VERSION_8188E) {
+					priv->pshare->RaInfo[pstat->aid].pstat = pstat;
+					RateAdaptiveInfoInit(&priv->pshare->RaInfo[pstat->aid]);
+				}
+#endif
 
 				// insert to hash list
 				index = wifi_mac_hash(hwaddr);
@@ -1318,6 +1384,12 @@ struct	stat_info *alloc_stainfo(struct rtl8192cd_priv *priv, unsigned char *hwad
 			priv->pshare->aidarray[i]->station.aid = i + 1; //aid 0 is reserved for AP
 			priv->pshare->aidarray[i]->used = TRUE;
 			pstat = &(priv->pshare->aidarray[i]->station);
+#if defined(CONFIG_RTL_88E_SUPPORT) && defined(TXREPORT)
+			if (GET_CHIP_VER(priv)==VERSION_8188E) {
+				priv->pshare->RaInfo[i + 1].pstat = pstat;
+				RateAdaptiveInfoInit(&priv->pshare->RaInfo[i + 1]);
+			}
+#endif
 
 #if defined(CONFIG_RTL_WAPI_SUPPORT)
 			{
@@ -1373,6 +1445,10 @@ struct	stat_info *alloc_stainfo(struct rtl8192cd_priv *priv, unsigned char *hwad
 #endif
 			memcpy(pstat->hwaddr, hwaddr, MACADDRLEN);
 			init_stainfo(priv, pstat);
+#if defined(CONFIG_RTL_88E_SUPPORT) && defined(TXREPORT)
+			if (GET_CHIP_VER(priv)==VERSION_8188E)
+				RateAdaptiveInfoInit(&priv->pshare->RaInfo[pstat->aid]);
+#endif
 
 			// insert to hash list
 			index = wifi_mac_hash(hwaddr);
@@ -1490,6 +1566,10 @@ int	free_stainfo(struct rtl8192cd_priv *priv, struct stat_info *pstat)
 				// remove from hash_list
 				if (!list_empty(&(pstat->hash_list)))
 					list_del_init(&(pstat->hash_list));
+#if defined(CONFIG_RTL_88E_SUPPORT) && defined(TXREPORT)
+				if (GET_CHIP_VER(priv)==VERSION_8188E)
+					priv->pshare->RaInfo[pstat->aid].pstat = NULL;
+#endif
 			}
 
 			release_stainfo(priv, pstat);
@@ -1567,7 +1647,7 @@ struct stat_info *get_aidinfo(struct rtl8192cd_priv *priv, unsigned int aid)
 	return (struct stat_info *)NULL;
 }
 
-#ifdef TXREPORT
+#if defined(TXREPORT) && (defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT))
 struct stat_info *get_macidinfo(struct rtl8192cd_priv *priv, unsigned int aid)
 {
 	struct list_head	*plist, *phead;
@@ -1774,6 +1854,8 @@ int skb_p80211_to_ether(struct net_device *dev, int wep_mode, struct rx_frinfo *
 	int wlan_pkt_format;
 	struct sk_buff *skb = get_pskb(pfrinfo);
 
+	
+
 #if defined(RX_SHORTCUT)
 #ifndef MESH_AMSDU
 	struct stat_info 	*pstat = get_stainfo(priv, GetAddr2Ptr(skb->data));
@@ -2561,7 +2643,11 @@ unsigned char *get_wlanhdr_from_poll(struct rtl8192cd_priv *priv)
 	unsigned long flags;
 
 	SAVE_INT_AND_CLI(flags);
+
 	pbuf = get_buf_from_poll(priv, &priv->pshare->wlan_hdrlist, (unsigned int *)&priv->pshare->pwlan_hdr_poll->count);
+#ifdef TX_EARLY_MODE
+	pbuf += 8;
+#endif
 
 	RESTORE_INT(flags);
 	return pbuf;
@@ -2574,6 +2660,9 @@ void release_wlanhdr_to_poll(struct rtl8192cd_priv *priv, unsigned char *pbuf)
 
 	SAVE_INT_AND_CLI(flags);
 
+#ifdef TX_EARLY_MODE
+	pbuf -= 8;
+#endif
 	release_buf_to_poll(priv, pbuf, &priv->pshare->wlan_hdrlist, (unsigned int *)&priv->pshare->pwlan_hdr_poll->count);
 
 	RESTORE_INT(flags);
@@ -2590,6 +2679,9 @@ unsigned char *get_wlanllchdr_from_poll(struct rtl8192cd_priv *priv)
 	SAVE_INT_AND_CLI(flags);
 
 	pbuf = get_buf_from_poll(priv, &priv->pshare->wlanllc_hdrlist, (unsigned int *)&priv->pshare->pwlanllc_hdr_poll->count);
+#ifdef TX_EARLY_MODE
+	pbuf += 8;
+#endif
 
 	RESTORE_INT(flags);
 	return pbuf;
@@ -2602,6 +2694,9 @@ void release_wlanllchdr_to_poll(struct rtl8192cd_priv *priv, unsigned char *pbuf
 
 	SAVE_INT_AND_CLI(flags);
 
+#ifdef TX_EARLY_MODE
+	pbuf -= 8;
+#endif
 	release_buf_to_poll(priv, pbuf, &priv->pshare->wlanllc_hdrlist, (unsigned int *)&priv->pshare->pwlanllc_hdr_poll->count);
 
 	RESTORE_INT(flags);
@@ -2840,6 +2935,9 @@ int should_forbid_Nmode(struct rtl8192cd_priv *priv)
 	if (!(priv->pmib->dot11BssType.net_work_type & WIRELESS_11N))
 		return 0;
 
+	if (priv->pmib->dot1180211AuthEntry.dot11PrivacyAlgrthm == _NO_PRIVACY_)
+		return 0;
+
 	if (!(priv->pmib->dot11nConfigEntry.dot11nLgyEncRstrct & BIT(3)))
 		return 0;
 
@@ -3185,7 +3283,16 @@ int get_bssrate_set(struct rtl8192cd_priv *priv, int bssrate_ie, unsigned char *
 	if (priv->pshare->curr_band == BAND_5G)
 #endif
 	{
-		if (bssrate_ie == _SUPPORTEDRATES_IE_)
+
+#ifdef P2P_SUPPORT			
+		if(bssrate_ie == _SUPPORTED_RATES_NO_CCK_ ){
+				*pbssrate = &dot11_rate_table[4];
+				*bssrate_len = 4;
+				return TRUE;
+		}
+#endif			
+	
+		if (bssrate_ie == _SUPPORTEDRATES_IE_ 	)
 		{
 			for(i=0; i<AP_BSSRATE_LEN; i++)
 				if (!is_CCK_rate(AP_BSSRATE[i] & 0x7f))
@@ -3213,6 +3320,13 @@ int get_bssrate_set(struct rtl8192cd_priv *priv, int bssrate_ie, unsigned char *
 				*bssrate_len = AP_BSSRATE_LEN;
 			return TRUE;
 		}
+#ifdef P2P_SUPPORT
+		else if( bssrate_ie == _SUPPORTED_RATES_NO_CCK_){
+				*pbssrate = &dot11_rate_table[4];
+				*bssrate_len = 4;
+				return TRUE;
+		}
+#endif		
 		else
 		{
 			if (AP_BSSRATE_LEN > 8) {
@@ -3243,51 +3357,59 @@ static struct channel_list reg_channel_2_4g[] = {
 	/* MKK2 */		{{1,2,3,4,5,6,7,8,9,10,11,12,13,14},14},
 	/* MKK3 */		{{1,2,3,4,5,6,7,8,9,10,11,12,13,14},14},
 	/* NCC (Taiwan) */	{{1,2,3,4,5,6,7,8,9,10,11},11},
+	/* RUSSIAN */	{{1,2,3,4,5,6,7,8,9,10,11,12,13},13},
+	/* CN */		{{1,2,3,4,5,6,7,8,9,10,11},11},
 };
-#if 0
-static struct channel_list reg_channel_5g_low_band[] = {
-	/* FCC */		{{36,40,44,48,52,56,60,64},8},
-	/* IC */		{{36,40,44,48,52,56,60,64},8},
-	/* ETSI */		{{36,40,44,48,52,56,60,64},8},
-	/* SPAIN */		{{36,40,44,48,52,56,60,64},8},
-	/* FRANCE */	{{36,40,44,48,52,56,60,64},8},
-	/* MKK */		{{34,36,38,40,42,44,46,48,52,56,60,64},12},
-	/* ISRAEL */	{{36,40,44,48,52,56,60,64},8},
-	/* MKK1 */		{{34,38,42,46},4},
-	/* MKK2 */		{{36,40,44,48},4},
-	/* MKK3 */		{{36,40,44,48,52,56,60,64},8},
-};
-#endif
 
 #ifdef DFS
 static struct channel_list reg_channel_5g_full_band[] = {
 	/* FCC */		{{36,40,44,48,52,56,60,64,100,104,108,112,116,136,140,149,153,157,161,165},20},
-	/* IC */			{{36,40,44,48,52,56,60,64,149,153,157,161},12},
+	/* IC */		{{36,40,44,48,52,56,60,64,149,153,157,161},12},
 	/* ETSI */		{{36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140},19},
 	/* SPAIN */		{{36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140},19},
-	/* FRANCE */		{{36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140},19},
+	/* FRANCE */	{{36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140},19},
 	/* MKK */		{{36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140},19},
-	/* ISRAEL */		{{36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140},19},
+	/* ISRAEL */	{{36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140},19},
 	/* MKK1 */		{{34,38,42,46},4},
 	/* MKK2 */		{{36,40,44,48},4},
 	/* MKK3 */		{{36,40,44,48,52,56,60,64},8},
-	/* NCC (Taiwan) */		{{56,60,64,100,104,108,112,116,136,140,149,153,157,161,165},15},
+	/* NCC (Taiwan) */	{{56,60,64,100,104,108,112,116,136,140,149,153,157,161,165},15},
+	/* RUSSIAN */	{{36,40,44,48},4},
+	/* CN */		{{149,153,157,161,165},5},
+};
+
+struct channel_list reg_channel_5g_not_dfs_band[] = {
+	/* FCC */		{{36,40,44,48,149,153,157,161,165},9},
+	/* IC */		{{36,40,44,48,149,153,157,161},8},
+	/* ETSI */		{{36,40,44,48},4},
+	/* SPAIN */		{{36,40,44,48},4},
+	/* FRANCE */	{{36,40,44,48},4},
+	/* MKK */		{{36,40,44,48},4},
+	/* ISRAEL */	{{36,40,44,48},4},
+	/* MKK1 */		{{34,38,42,46},4},
+	/* MKK2 */		{{36,40,44,48},4},
+	/* MKK3 */		{{36,40,44,48},4},
+	/* NCC (Taiwan) */	{{56,60,64,149,153,157,161,165},8},
+	/* RUSSIAN */	{{36,40,44,48},4},
+	/* CN */		{{149,153,157,161,165},5},
 };
 #else
 
 // Exclude DFS channels
 static struct channel_list reg_channel_5g_full_band[] = {
 	/* FCC */		{{36,40,44,48,149,153,157,161,165},9},
-	/* IC */			{{36,40,44,48,149,153,157,161},8},
+	/* IC */		{{36,40,44,48,149,153,157,161},8},
 	/* ETSI */		{{36,40,44,48},4},
 	/* SPAIN */		{{36,40,44,48},4},
-	/* FRANCE */		{{36,40,44,48},4},
+	/* FRANCE */	{{36,40,44,48},4},
 	/* MKK */		{{36,40,44,48},4},
-	/* ISRAEL */		{{36,40,44,48},4},
+	/* ISRAEL */	{{36,40,44,48},4},
 	/* MKK1 */		{{34,38,42,46},4},
 	/* MKK2 */		{{36,40,44,48},4},
 	/* MKK3 */		{{36,40,44,48},4},
-	/* NCC (Taiwan) */		{{56,60,64,149,153,157,161,165},8},
+	/* NCC (Taiwan) */	{{56,60,64,149,153,157,161,165},8},
+	/* RUSSIAN */	{{36,40,44,48},4},
+	/* CN */		{{149,153,157,161,165},5},
 };
 #endif
 
@@ -3302,7 +3424,9 @@ int get_available_channel(struct rtl8192cd_priv *priv)
 	if ((reg < DOMAIN_FCC) || (reg >= DOMAIN_MAX))
 		return FAIL;
 
-	if (priv->pmib->dot11BssType.net_work_type & (WIRELESS_11B | WIRELESS_11G)) {
+	if (priv->pmib->dot11BssType.net_work_type & (WIRELESS_11B | WIRELESS_11G) || 
+		((priv->pmib->dot11BssType.net_work_type & WIRELESS_11N) &&
+			!(priv->pmib->dot11BssType.net_work_type & WIRELESS_11A))) {
 		for (i=0; i<reg_channel_2_4g[reg-1].len; i++)
 			priv->available_chnl[i] = reg_channel_2_4g[reg-1].channel[i];
 		priv->available_chnl_num += reg_channel_2_4g[reg-1].len;
@@ -3320,6 +3444,10 @@ int get_available_channel(struct rtl8192cd_priv *priv)
 		if (priv->NOP_chnl_num)
 			for (i=0; i<priv->NOP_chnl_num; i++)
 				RemoveChannel(priv->available_chnl, &priv->available_chnl_num, priv->NOP_chnl[i]);
+
+		for (i=0; i<reg_channel_5g_not_dfs_band[reg-1].len; i++)
+			priv->Not_DFS_chnl[i] = reg_channel_5g_not_dfs_band[reg-1].channel[i];
+		priv->Not_DFS_chnl_num = reg_channel_5g_not_dfs_band[reg-1].len;
 #endif
 	}
 
@@ -3353,6 +3481,20 @@ void cnt_assoc_num(struct rtl8192cd_priv *priv, struct stat_info *pstat, int act
 	if (act == INCREASE) {
 		if (priv->assoc_num <= NUM_STAT) {
 			priv->assoc_num++;
+#ifdef TLN_STATS
+			if (priv->assoc_num > priv->wifi_stats.max_sta) {
+				priv->wifi_stats.max_sta = priv->assoc_num;
+				priv->wifi_stats.max_sta_timestamp = priv->up_time;
+			}
+#endif
+#if defined(CONFIG_RTL_88E_SUPPORT) && defined(TXREPORT)
+			if (GET_CHIP_VER(priv) == VERSION_8188E) {
+				priv->pshare->total_assoc_num++;
+				RTL8188E_AssignTxReportMacId(priv);
+				if (priv->pshare->total_assoc_num == 1)
+					RTL8188E_ResumeTxReport(priv);
+			}
+#endif
 #ifdef SMART_CONCURRENT_92D
 			if (priv->pmib->dot11RFEntry.smcc==1 && priv->pmib->dot11RFEntry.macPhyMode != SINGLEMAC_SINGLEPHY) {
 				if (priv->assoc_num == 1 && priv->smcc_state == 0) {
@@ -3362,13 +3504,15 @@ void cnt_assoc_num(struct rtl8192cd_priv *priv, struct stat_info *pstat, int act
 				}
 			}
 #endif
-
+#if 0
 #if defined(UNIVERSAL_REPEATER) || defined(MBSSID)
 			if (IS_ROOT_INTERFACE(priv))
 #endif
+			{
 				if (priv->assoc_num > 1)
 					check_DIG_by_rssi(priv, 0);	// force DIG temporary off for association after the fist one
-
+			}
+#endif
 			if (pstat->ht_cap_len) {
 				priv->pshare->ht_sta_num++;
 				if (priv->pshare->iot_mode_enable && (priv->pshare->ht_sta_num == 1)
@@ -3389,7 +3533,17 @@ void cnt_assoc_num(struct rtl8192cd_priv *priv, struct stat_info *pstat, int act
 							else
 								priv->force_20_sta_ext |= BIT(pstat->aid - 1 - FW_NUM_STAT);
 #else
-							priv->force_20_sta |= BIT(pstat->aid -1);
+#ifdef CONFIG_RTL_88E_SUPPORT
+							if (GET_CHIP_VER(priv) == VERSION_8188E) {
+								if (pstat->aid <= 32)
+									priv->force_20_sta |= BIT(pstat->aid -1);
+								else
+									priv->force_20_sta_88e_hw_ext |= BIT(pstat->aid - 1 - 32);
+							} else
+#endif
+							{
+								priv->force_20_sta |= BIT(pstat->aid -1);
+							}
 #endif
 						} 
 					}
@@ -3398,13 +3552,22 @@ void cnt_assoc_num(struct rtl8192cd_priv *priv, struct stat_info *pstat, int act
 
 				check_NAV_prot_len(priv, pstat, 0);
 			}
-		}
-		else
+		} else {
 			DEBUG_ERR("Association Number Error (%d)!\n", NUM_STAT);
+		}
 	}
 	else {
 		if (priv->assoc_num > 0) {
 			priv->assoc_num--;
+#if defined(CONFIG_RTL_88E_SUPPORT) && defined(TXREPORT)
+			if (GET_CHIP_VER(priv) == VERSION_8188E) {
+				priv->pshare->total_assoc_num--;
+				if (!priv->pshare->total_assoc_num)
+					RTL8188E_SuspendTxReport(priv);
+				else
+					RTL8188E_AssignTxReportMacId(priv);
+			}
+#endif
 #ifdef SMART_CONCURRENT_92D
 			if (priv->pmib->dot11RFEntry.smcc==1 && priv->pmib->dot11RFEntry.macPhyMode != SINGLEMAC_SINGLEPHY) {
 				if (priv->assoc_num == 0 && priv->smcc_state == 1) {
@@ -3418,13 +3581,19 @@ void cnt_assoc_num(struct rtl8192cd_priv *priv, struct stat_info *pstat, int act
 #if defined(UNIVERSAL_REPEATER) || defined(MBSSID)
 			if (IS_ROOT_INTERFACE(priv))
 #endif
-				if (!priv->assoc_num)
+				if (!priv->assoc_num) {
+#ifdef INTERFERENCE_CONTROL
+					if (priv->pshare->rf_ft_var.nbi_filter_enable)
+						check_NBI_by_rssi(priv, 0xFF);	// force NBI on while no station associated
+#else
 					check_DIG_by_rssi(priv, 0);	// force DIG off while no station associated
+#endif
+				}
 
 			if (pstat->ht_cap_len) {
-				if (--priv->pshare->ht_sta_num < 0)
+				if (--priv->pshare->ht_sta_num < 0) {
 					printk("ht_sta_num error\n");  // this should not happen
-				else{
+				} else {
 					if (priv->pshare->iot_mode_enable && !priv->pshare->ht_sta_num
 #ifdef RTL_MANUAL_EDCA
 							&& (priv->pmib->dot11QosEntry.ManualEDCA == 0)
@@ -3443,7 +3612,17 @@ void cnt_assoc_num(struct rtl8192cd_priv *priv, struct stat_info *pstat, int act
 								else
 									priv->force_20_sta_ext &= ~BIT(pstat->aid - 1 - FW_NUM_STAT);
 #else
-								priv->force_20_sta &= ~BIT(pstat->aid -1);
+#ifdef CONFIG_RTL_88E_SUPPORT
+								if (GET_CHIP_VER(priv) == VERSION_8188E) {
+									if (pstat->aid <= 32)
+										priv->force_20_sta &= ~BIT(pstat->aid -1);
+									else
+										priv->force_20_sta_88e_hw_ext &= ~BIT(pstat->aid - 1 - 32);
+								} else
+#endif
+								{
+									priv->force_20_sta &= ~BIT(pstat->aid -1);
+								}
 #endif
 							}
 						}
@@ -3453,9 +3632,9 @@ void cnt_assoc_num(struct rtl8192cd_priv *priv, struct stat_info *pstat, int act
 					check_NAV_prot_len(priv, pstat, 1);
 				}
 			}
-		}
-		else
+		} else {
 			DEBUG_ERR("Association Number Error (0)!\n");
+		}
 	}
 
 #ifdef CONFIG_RTL_92D_SUPPORT
@@ -3467,8 +3646,8 @@ void cnt_assoc_num(struct rtl8192cd_priv *priv, struct stat_info *pstat, int act
 			}
 		}
 		priv->pshare->max_fw_macid = priv->pshare->aidarray[i]->station.aid+1; // fw check macid num from 1~32, so we add 1 to index.
-		if (priv->pshare->max_fw_macid > NUM_STAT)
-			priv->pshare->max_fw_macid = NUM_STAT;
+		if (priv->pshare->max_fw_macid > (NUM_STAT+1))
+			priv->pshare->max_fw_macid = (NUM_STAT+1);
 	}
 #endif
 
@@ -3725,7 +3904,16 @@ void disable_vxd_ap(struct rtl8192cd_priv *priv)
 
 	SAVE_INT_AND_CLI(flags);
 
-	RTL_W32(HIMR, RTL_R32(HIMR) & ~(HIMR_BCNDOK0));
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv)==VERSION_8188E) {
+		priv->pshare->InterruptMask &= ~(HIMR_88E_BcnInt | HIMR_88E_TBDOK | HIMR_88E_TBDER);
+		RTL_W32(REG_88E_HIMR, priv->pshare->InterruptMask);
+	} else
+#endif
+	{
+		RTL_W32(HIMR, RTL_R32(HIMR) & ~(HIMR_BCNDOK0));
+	}
+
 	//RTL_W16(ATIMWND, 2);
 	RTL_W32(CR, (RTL_R32(CR) & ~(NETYPE_Mask << NETYPE_SHIFT)) | ((NETYPE_NOLINK & NETYPE_Mask) << NETYPE_SHIFT));
 
@@ -3772,10 +3960,22 @@ void enable_vxd_ap(struct rtl8192cd_priv *priv)
 	priv->ht_cap_len = 0;
 	init_beacon(priv);
 
-	RTL_W32(HIMR, RTL_R32(HIMR) | HIMR_BCNDOK0);
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv)==VERSION_8188E) {
+		priv->pshare->InterruptMask |= HIMR_88E_BcnInt | HIMR_88E_TBDOK | HIMR_88E_TBDER;
+		RTL_W32(REG_88E_HIMR, priv->pshare->InterruptMask);
+	} else
+#endif
+	{
+		RTL_W32(HIMR, RTL_R32(HIMR) | HIMR_BCNDOK0);
+	}
+
 	//RTL_W16(ATIMWND, 0x0030);
 	RTL_W32(CR, (RTL_R32(CR) & ~(NETYPE_Mask << NETYPE_SHIFT)) | ((NETYPE_AP & NETYPE_Mask) << NETYPE_SHIFT));
-	if (!IS_TEST_CHIP(priv)) {
+#ifdef CONFIG_RTL_92C_SUPPORT
+	if (!IS_TEST_CHIP(priv))
+#endif
+	{
 		RTL_W8(0x422, RTL_R8(0x422) | BIT(6));
 		RTL_W8(BCN_CTRL, 0); 
 		RTL_W8(0x553, 1); 
@@ -3820,7 +4020,7 @@ void rtl8192cd_GBWC_timer(unsigned long task_priv)
 		rtl_atomic_dec(&priv->rtl_tx_skb_cnt);
 #endif
 
-		if (rtl8192cd_start_xmit(pskb, priv->dev))
+		if (rtl8192cd_start_xmit_noM2U(pskb, pskb->dev))
 			rtl_kfree_skb(priv, pskb, _SKB_TX_);
 	}
 
@@ -3859,7 +4059,11 @@ unsigned char fw_was_full(struct rtl8192cd_priv *priv)
         while (plist != phead) {
 			pstat = list_entry(plist, struct stat_info, asoc_list);
 			plist = plist->next;
-			if(pstat->remapped_aid == FW_NUM_STAT-1)
+			if(
+#ifdef CONFIG_RTL_88E_SUPPORT
+				(GET_CHIP_VER(priv)==VERSION_8188E)?(pstat->remapped_aid == RTL8188E_NUM_STAT-1):
+#endif
+				(pstat->remapped_aid == FW_NUM_STAT-1))
 				return 1;
 	}
 	return 0;
@@ -3885,7 +4089,11 @@ unsigned int find_reampped_aid(struct rtl8192cd_priv *priv, unsigned int rateid)
 	if ((i == NUM_STAT) && (j == NUM_STAT))
 		return 0; //ERROR! this should not happen
 
-	if ((i < (FW_NUM_STAT-1)) || (j == NUM_STAT) || (i <= j))
+	if ((
+#ifdef CONFIG_RTL_88E_SUPPORT
+		(GET_CHIP_VER(priv)==VERSION_8188E)?(i < (RTL8188E_NUM_STAT-1)):
+#endif
+		(i < (FW_NUM_STAT-1))) || (j == NUM_STAT) || (i <= j))
 		return i;
 	else
 		return j;
@@ -3911,7 +4119,11 @@ int realloc_RATid(struct rtl8192cd_priv *priv)
 		pstat = list_entry(plist, struct stat_info, asoc_list);
 		plist = plist->next;
 
-		if (pstat->remapped_aid < FW_NUM_STAT-1)// STA has rate adaptive
+		if (
+#ifdef CONFIG_RTL_88E_SUPPORT
+			(GET_CHIP_VER(priv)==VERSION_8188E)?(pstat->remapped_aid < RTL8188E_NUM_STAT-1):
+#endif
+			(pstat->remapped_aid < FW_NUM_STAT-1))// STA has rate adaptive
 			continue;
 
 		temp_through_put =  pstat->tx_avarage + pstat->rx_avarage;
@@ -3933,7 +4145,16 @@ int realloc_RATid(struct rtl8192cd_priv *priv)
 	release_remapAid(priv,pstat_chosen);
 #endif
 
-	add_update_RATid(priv, pstat_chosen);
+#ifdef CONFIG_RTL_88E_SUPPORT
+	if (GET_CHIP_VER(priv)==VERSION_8188E) {
+#ifdef TXREPORT
+		add_RATid(priv, pstat);
+#endif
+	} else
+#endif
+	{
+		add_update_RATid(priv, pstat_chosen);
+	}
 
 	return 1;
 }
@@ -3944,7 +4165,10 @@ unsigned int is_h2c_buf_occupy(struct rtl8192cd_priv *priv)
 {
 	 unsigned int occupied = 0;
 
-	if ((IS_TEST_CHIP(priv) && RTL_R8(0x1c0+priv->pshare->fw_q_fifo_count)) ||
+	if (
+#ifdef CONFIG_RTL_92C_SUPPORT
+		(IS_TEST_CHIP(priv) && RTL_R8(0x1c0+priv->pshare->fw_q_fifo_count)) ||
+#endif
 		(RTL_R8(0x1cc) & BIT(priv->pshare->fw_q_fifo_count)))
 		occupied++;
 
@@ -3983,7 +4207,7 @@ short signin_h2c_cmd(struct rtl8192cd_priv *priv, unsigned int content, unsigned
 
 	//printk("(smcc) sign in h2c %x\n", HMEBOX_0+(priv->pshare->fw_q_fifo_count*4));
 
-#ifdef TESTCHIP_SUPPORT
+#if defined(TESTCHIP_SUPPORT) && defined(CONFIG_RTL_92C_SUPPORT)
 	/*
 	 * set own bit
 	 */
@@ -4088,34 +4312,6 @@ void add_ps_timer(unsigned long task_priv)
 }
 
 
-#if defined(CONFIG_RTL_92D_SUPPORT) && defined(CONFIG_RTL_NOISE_CONTROL)
-void dnc_timer(unsigned long task_priv)
-{
-	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *)task_priv;
-	struct stat_info *pstat = NULL;
-	unsigned int set_timer = 0;
-	unsigned long flags;
-
-	if (!(priv->drv_state & DRV_STATE_OPEN))
-		return;
-
-	if (timer_pending(&priv->dnc_timer))
-		del_timer_sync(&priv->dnc_timer);
-
-#ifdef PCIE_POWER_SAVING
-	if ((priv->pwr_state == L2) || (priv->pwr_state == L1))
-			return;
-#endif
-
-	if (priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_5G) {
-		//PHY_SetBBReg(priv, 0xb30, bMaskDWord, 0x00a00000);
-		PHY_SetBBReg(priv, 0x870, bMaskDWord, 0x07600760);
-		PHY_SetBBReg(priv, 0xc50, bMaskByte0, 0x20);
-		PHY_SetBBReg(priv, 0xc58, bMaskByte0, 0x20);
-	}
-}
-#endif
-
 #ifdef SMART_CONCURRENT_92D
 void smcc_prb_timer(unsigned long task_priv)
 {
@@ -4164,55 +4360,30 @@ void add_update_ps(struct rtl8192cd_priv *priv, struct stat_info *pstat)
 }
 }
 
-
-void set_rssi_cmd(struct rtl8192cd_priv *priv, struct stat_info *pstat)
+#ifdef STA_EXT
+void release_remapAid(struct rtl8192cd_priv *priv, struct stat_info *pstat)
 {
-	unsigned long flags;
-	unsigned int content = 0;
-
-	int rssi = pstat->rssi;
-
-#ifdef HIGH_POWER_EXT_PA
-	if( priv->pshare->rf_ft_var.use_ext_pa ) 
-		rssi += RSSI_DIFF_PA;
-	if( rssi > 100)
-		rssi = 100;
+	if (
+#ifdef CONFIG_RTL_88E_SUPPORT
+		(GET_CHIP_VER(priv)==VERSION_8188E)?(pstat->remapped_aid != RTL8188E_NUM_STAT-1):
 #endif
-
-	
-	SAVE_INT_AND_CLI(flags);
-
-	/*
-	 * set rssi
-	 */
-	 content = rssi<< 24;
-	
-#ifdef CONFIG_RTL_92D_SUPPORT
-	/*
-	 * set max macid
-	 */
-	if (GET_CHIP_VER(priv) == VERSION_8192D){
-		 content |= priv->pshare->max_fw_macid << 16;
+		(pstat->remapped_aid != FW_NUM_STAT-1)) {
+		int i;
+		for(i = 1; i < NUM_STAT; i++)
+			if(priv->pshare->remapped_aidarray[i] == pstat->aid){
+				priv->pshare->remapped_aidarray[i] = 0;
+				priv->pshare->fw_free_space ++;
+				break;
+			}
 	}
-#endif
-
-	/*
-	 * set macid
-	 */
-	 content |= pstat->aid << 8;
-
-	/*
-	 * set cmd id
-	 */
-	 content |= H2C_CMD_RSSI;
-
-	signin_h2c_cmd(priv, content, 0);
+	pstat->sta_in_firmware = -1;
 
-	RESTORE_INT(flags);
+	DEBUG_INFO("Remove id %d from ratr\n", pstat->aid);
 }
+#endif
 
 
-void add_rssi_timer(unsigned long task_priv)
+void add_RATid_timer(unsigned long task_priv)
 {
 	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *)task_priv;
 	struct stat_info *pstat = NULL;
@@ -4222,30 +4393,30 @@ void add_rssi_timer(unsigned long task_priv)
 	if (!(priv->drv_state & DRV_STATE_OPEN))
 		return;
 
-	if (timer_pending(&priv->add_rssi_timer))
-		del_timer_sync(&priv->add_rssi_timer);
+	if (timer_pending(&priv->add_RATid_timer))
+		del_timer_sync(&priv->add_RATid_timer);
 
 #ifdef PCIE_POWER_SAVING
 	if ((priv->pwr_state == L2) || (priv->pwr_state == L1))
 			return;
 #endif
 
-	if (!list_empty(&priv->addrssi_list)) {
-		pstat = list_entry(priv->addrssi_list.next, struct stat_info, addrssi_list);
+	if (!list_empty(&priv->addRAtid_list)) {
+		pstat = list_entry(priv->addRAtid_list.next, struct stat_info, addRAtid_list);
 		if (!pstat)
 			return;
 
 		if (!is_h2c_buf_occupy(priv)) {
-			set_rssi_cmd(priv, pstat);
-			if (!list_empty(&pstat->addrssi_list)) {
+			add_RATid(priv, pstat);
+			if (!list_empty(&pstat->addRAtid_list)) {
 				SAVE_INT_AND_CLI(flags);
 				SMP_LOCK(flags);
-				list_del_init(&pstat->addrssi_list);
+				list_del_init(&pstat->addRAtid_list);
 				RESTORE_INT(flags);
 				SMP_UNLOCK(flags);
 			}
 
-			if (!list_empty(&priv->addrssi_list))
+			if (!list_empty(&priv->addRAtid_list))
 				set_timer++;
 		} else {
 			set_timer++;
@@ -4253,422 +4424,48 @@ void add_rssi_timer(unsigned long task_priv)
 	}
 
 	if (set_timer)
-		mod_timer(&priv->add_rssi_timer, jiffies + RTL_MILISECONDS_TO_JIFFIES(50));	// 50 ms
+		mod_timer(&priv->add_RATid_timer, jiffies + RTL_MILISECONDS_TO_JIFFIES(50));	// 50 ms
 }
 
 
-void add_update_rssi(struct rtl8192cd_priv *priv, struct stat_info *pstat)
+void add_update_RATid(struct rtl8192cd_priv *priv, struct stat_info *pstat)
 {
 	unsigned long flags;
 
 	if (is_h2c_buf_occupy(priv)) {
-	if (list_empty(&pstat->addrssi_list)) {
-		SAVE_INT_AND_CLI(flags);
-		list_add_tail(&(pstat->addrssi_list), &(priv->addrssi_list));
-		RESTORE_INT(flags);
+		if (list_empty(&pstat->addRAtid_list)) {
+			SAVE_INT_AND_CLI(flags);
+			list_add_tail(&(pstat->addRAtid_list), &(priv->addRAtid_list));
+			RESTORE_INT(flags);
 
-		if (!timer_pending(&priv->add_rssi_timer))
-			mod_timer(&priv->add_rssi_timer, jiffies + RTL_MILISECONDS_TO_JIFFIES(50));	// 50 ms
-	}
+			if (!timer_pending(&priv->add_RATid_timer))
+				mod_timer(&priv->add_RATid_timer, jiffies + RTL_MILISECONDS_TO_JIFFIES(50));	// 50 ms
+		}
 	} else {
-		set_rssi_cmd(priv, pstat);
-}
+			add_RATid(priv, pstat);
+	}
 }
 
 
-void set_RATid_cmd(struct rtl8192cd_priv *priv, unsigned int macid, unsigned int rateid, unsigned int ratemask)
+#ifdef RTK_QUE
+void rtk_queue_init(struct ring_que *que)
 {
-	unsigned int content = 0;
-	unsigned short ext_content = 0;
-
-	/*
-	 * set ratemask
-	 */
-	ext_content = ratemask & 0xffff;
-	content = ((ratemask & 0xfff0000) >> 16) << 8;
-
-	/*
-	 * set short GI
-	 */
-	if (ratemask & BIT(28))
-		content |= BIT(29);
-
-	/*
-	 * set macid (station aid)
-	 */
-	content |= (macid & 0x1f) << 24;
-
-	/*
-	 * set rateid (ARFR table)
-	 */
-	content |= (rateid & 0xf) << 20;
-
-	/*
-	 * set ext_content used
-	 */
-	content |= BIT(7);
-
-	/*
-	 * set cmd id
-	 */
-	content |= H2C_CMD_MACID;
-
-	signin_h2c_cmd(priv, content, ext_content);
+	memset(que, '\0', sizeof(struct ring_que));
+	que->qmax = MAX_PRE_ALLOC_SKB_NUM;
 }
 
-
-void add_RATid(struct rtl8192cd_priv *priv, struct stat_info *pstat)
+static int rtk_queue_tail(struct rtl8192cd_priv *priv, struct ring_que *que, struct sk_buff *skb)
 {
-	unsigned char limit=16;
-	int i;
-	unsigned long flags;
-	unsigned int update_reg=0;
-
-	SAVE_INT_AND_CLI(flags);
+	int next;
+	unsigned long x;
 
-	pstat->tx_ra_bitmap = 0;
+	SAVE_INT_AND_CLI(x);
+	SMP_LOCK_SKB(x);
 
-	for (i=0; i<32; i++) {
-		if (pstat->bssrateset[i])
-			pstat->tx_ra_bitmap |= get_bit_value_from_ieee_value(pstat->bssrateset[i]&0x7f);
-	}
-
-	if (pstat->ht_cap_len) {
-		if ((pstat->MIMO_ps & _HT_MIMO_PS_STATIC_) ||
-			(get_rf_mimo_mode(priv)== MIMO_1T2R) ||
-			(get_rf_mimo_mode(priv)== MIMO_1T1R))
-			limit=8;
-
-		for (i=0; i<limit; i++) {
-			if (pstat->ht_cap_buf.support_mcs[i/8] & BIT(i%8))
-				pstat->tx_ra_bitmap |= BIT(i+12);
-		}
-	}
-
-	if (pstat->ht_cap_len) {
-		unsigned int set_sgi = 0;
-		if (priv->pshare->is_40m_bw && (pstat->tx_bw == HT_CHANNEL_WIDTH_20_40)
-#ifdef WIFI_11N_2040_COEXIST
-			&& !((OPMODE & WIFI_AP_STATE) && priv->pmib->dot11nConfigEntry.dot11nCoexist &&
-			(priv->bg_ap_timeout || priv->force_20_sta || priv->switch_20_sta
-#ifdef STA_EXT
-			|| priv->force_20_sta_ext || priv->switch_20_sta_ext
-#endif
-			))
-#endif
-			) {
-			if (pstat->ht_cap_buf.ht_cap_info & cpu_to_le16(_HTCAP_SHORTGI_40M_)
-				&& priv->pmib->dot11nConfigEntry.dot11nShortGIfor40M)
-				set_sgi++;
-		} else if (pstat->ht_cap_buf.ht_cap_info & cpu_to_le16(_HTCAP_SHORTGI_20M_) &&
-			priv->pmib->dot11nConfigEntry.dot11nShortGIfor20M) {
-			set_sgi++;
-		}
-
-		if (set_sgi)
-			pstat->tx_ra_bitmap |= BIT(28);
-	}
-
-	if ((pstat->rssi_level < 1) || (pstat->rssi_level > 3)) {
-		if (pstat->rssi >= priv->pshare->rf_ft_var.raGoDownUpper)
-			pstat->rssi_level = 1;
-		else if ((pstat->rssi >= priv->pshare->rf_ft_var.raGoDown20MLower) ||
-			((priv->pshare->is_40m_bw) && (pstat->ht_cap_len) &&
-			(pstat->rssi >= priv->pshare->rf_ft_var.raGoDown40MLower) &&
-			(pstat->ht_cap_buf.ht_cap_info & cpu_to_le16(_HTCAP_SUPPORT_CH_WDTH_))))
-			pstat->rssi_level = 2;
-		else
-			pstat->rssi_level = 3;
-	}
-
-	if (priv->pmib->dot11BssType.net_work_type & WIRELESS_11A)
-		pstat->tx_ra_bitmap &= 0xfffffff0; //disable cck rate
-
-	// rate adaptive by rssi
-	if ((priv->pmib->dot11BssType.net_work_type & WIRELESS_11N) && pstat->ht_cap_len && (!should_restrict_Nrate(priv, pstat))) {
-		if ((get_rf_mimo_mode(priv) == MIMO_1T2R) || (get_rf_mimo_mode(priv) == MIMO_1T1R)) {
-			switch (pstat->rssi_level) {
-				case 1:
-					pstat->tx_ra_bitmap &= 0x100f0000;
-					break;
-				case 2:
-					pstat->tx_ra_bitmap &= 0x100ff000;
-					break;
-				case 3:
-					if (priv->pshare->is_40m_bw)
-						pstat->tx_ra_bitmap &= 0x100ff005;
-					else
-						pstat->tx_ra_bitmap &= 0x100ff001;
-					break;
-			}
-		} else {
-			switch (pstat->rssi_level) {
-				case 1:
-					pstat->tx_ra_bitmap &= 0x1f8f0000;
-					break;
-				case 2:
-					pstat->tx_ra_bitmap &= 0x1f8ff000;
-					break;
-				case 3:
-					if (priv->pshare->is_40m_bw)
-						pstat->tx_ra_bitmap &= 0x010ff005;
-					else
-						pstat->tx_ra_bitmap &= 0x010ff001;
-					break;
-			}
-
-			// Don't need to mask high rates due to new rate adaptive parameters
-			//if (pstat->is_broadcom_sta)		// use MCS12 as the highest rate vs. Broadcom sta
-			//	pstat->tx_ra_bitmap &= 0x81ffffff;
-
-			// NIC driver will report not supporting MCS15 and MCS14 in asoc req
-			//if (pstat->is_rtl8190_sta && !pstat->is_2t_mimo_sta)
-			//	pstat->tx_ra_bitmap &= 0x83ffffff;		// if Realtek 1x2 sta, don't use MCS15 and MCS14
-		}
-	}
-	else if (((priv->pmib->dot11BssType.net_work_type & WIRELESS_11G) && isErpSta(pstat)) ||
-			(priv->pmib->dot11BssType.net_work_type & WIRELESS_11A)) 
-	{
-		switch (pstat->rssi_level) {
-			case 1:
-				pstat->tx_ra_bitmap &= 0x00000f00;
-				break;
-			case 2:
-				pstat->tx_ra_bitmap &= 0x00000ff0;
-				break;
-			case 3:
-				pstat->tx_ra_bitmap &= 0x00000ff5;
-				break;
-		}
-	} else {
-		pstat->tx_ra_bitmap &= 0x0000000d;
-	}
-
-// Client mode IOT issue, Button 2009.07.17
-#ifdef CLIENT_MODE
-	if(OPMODE & WIFI_STATION_STATE) {
-		if(!pstat->is_rtl8192s_sta && pstat->is_realtek_sta && pstat->is_legacy_encrpt)
-			pstat->tx_ra_bitmap &= 0x0001ffff;					// up to MCS4
-	}
-#endif
-#if defined(CONFIG_RTL_92D_SUPPORT) && defined (USB_POWER_SUPPORT)
-	if ((GET_CHIP_VER(priv)==VERSION_8192D) &&	(priv->pmib->dot11RFEntry.phyBandSelect & PHY_BAND_5G))
-		pstat->tx_ra_bitmap &= USB_RA_MASK;
-#endif
-
-#ifdef STA_EXT
-	//update STA_map
-	{
-		int remapped_aid = 0;
-		remapped_aid = find_reampped_aid(priv, pstat->aid);
-		if(remapped_aid == 0){
-			/*WARNING:  THIS SHOULD NOT HAPPEN*/
-			printk("add AID fail!!\n");
-			BUG();
-		}
-		if(remapped_aid >= (FW_NUM_STAT-1)){// no room for the STA
-//			priv->STA_map |= (1<< pstat->aid) ;
-			pstat->remapped_aid = FW_NUM_STAT-1;
-			pstat->sta_in_firmware = 0; // this value will updated in expire_timer
-		} else if(priv->pshare->remapped_aidarray[remapped_aid]  == 0) { // if not 0, it should have been added before
-			//we got a room
-			//clear STA_map
-//			priv->STA_map &= ~(BIT(pstat->aid));
-			pstat->remapped_aid = remapped_aid;
-			priv->pshare->remapped_aidarray[remapped_aid] = pstat->aid;
-			pstat->sta_in_firmware = 1; // this value will updated in expire_timer
-			priv->pshare->fw_free_space --;
-		}else{// added before
-			pstat->sta_in_firmware = 1;
-		}
-	}
-#endif// STA_EXT
-
-#ifdef STA_EXT
-	if (REMAP_AID(pstat) < FW_NUM_STAT-1)
-#else
-	if (REMAP_AID(pstat) < 32)
-#endif
-	{
-#ifdef CONFIG_RTL_92D_SUPPORT
-		if (priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_5G) 
-		{
-			pstat->tx_ra_bitmap &= 0xfffffff0;
-			if (pstat->tx_ra_bitmap & 0xff00000) {
-				if (priv->pshare->is_40m_bw)
-					set_RATid_cmd(priv, REMAP_AID(pstat), ARFR_2T_Band_A_40M, pstat->tx_ra_bitmap);
-				else
-					set_RATid_cmd(priv, REMAP_AID(pstat), ARFR_2T_Band_A_20M, pstat->tx_ra_bitmap);
-				update_reg++;
-			} else if (pstat->tx_ra_bitmap & 0xff000) {
-				if (priv->pshare->is_40m_bw)
-					set_RATid_cmd(priv, REMAP_AID(pstat), ARFR_2T_Band_A_40M, pstat->tx_ra_bitmap);
-				else
-					set_RATid_cmd(priv, REMAP_AID(pstat), ARFR_2T_Band_A_20M, pstat->tx_ra_bitmap);
-			} else if (pstat->tx_ra_bitmap & 0xff0) {
-				set_RATid_cmd(priv, REMAP_AID(pstat), ARFR_Band_A_BMC, pstat->tx_ra_bitmap);
-			} else {
-				set_RATid_cmd(priv, REMAP_AID(pstat), ARFR_Band_A_BMC, pstat->tx_ra_bitmap);
-			}
-		} else 
-#endif
-		{
-			if (pstat->tx_ra_bitmap & 0xff00000) {
-				if (priv->pshare->is_40m_bw)
-					set_RATid_cmd(priv, REMAP_AID(pstat), ARFR_2T_40M, pstat->tx_ra_bitmap);
-				else
-					set_RATid_cmd(priv, REMAP_AID(pstat), ARFR_2T_20M, pstat->tx_ra_bitmap);
-				update_reg++;
-			} else if (pstat->tx_ra_bitmap & 0xff000) {
-				if (priv->pshare->is_40m_bw)
-					set_RATid_cmd(priv, REMAP_AID(pstat), ARFR_1T_40M, pstat->tx_ra_bitmap);
-				else
-					set_RATid_cmd(priv, REMAP_AID(pstat), ARFR_1T_20M, pstat->tx_ra_bitmap);
-			} else if (pstat->tx_ra_bitmap & 0xff0) {
-				set_RATid_cmd(priv, REMAP_AID(pstat), ARFR_BG_MIX, pstat->tx_ra_bitmap);
-			} else {
-				set_RATid_cmd(priv, REMAP_AID(pstat), ARFR_B_ONLY, pstat->tx_ra_bitmap);
-			}
-		}
-
-		/*
-		 * Rate adaptive algorithm.
-		 * If the STA is 2R, we set the inti rate to MCS 15
-		 */
-		if (update_reg) {
-			if (!pstat->check_init_tx_rate && (pstat->rssi > 55)) {
-				RTL_W8(INIDATA_RATE_SEL + REMAP_AID(pstat), 0x1b);
-				pstat->check_init_tx_rate = 1;
-			}
-		}
-		DEBUG_INFO("Add id %d val %08x to ratr\n", pstat->aid, pstat->tx_ra_bitmap);
-	} else {
-#ifdef STA_EXT
-#ifdef CONFIG_RTL_92D_SUPPORT
-		if (priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_5G) {
-			if (priv->pshare->is_40m_bw)
-				set_RATid_cmd(priv, (FW_NUM_STAT-1), ARFR_2T_Band_A_40M, 0x1ffffff0);
-			else
-				set_RATid_cmd(priv, (FW_NUM_STAT-1), ARFR_2T_Band_A_20M, 0x1ffffff0);
-		}else
-#endif
-		{
-			if (priv->pshare->is_40m_bw)
-				set_RATid_cmd(priv, (FW_NUM_STAT-1), ARFR_2T_40M, 0x1fffffff);
-			else
-				set_RATid_cmd(priv, (FW_NUM_STAT-1), ARFR_2T_20M, 0x1fffffff);
-		}
-#else
-		DEBUG_ERR("station aid %d exceed the max number\n", pstat->aid);
-#endif
-	}
-
-	RESTORE_INT(flags);
-}
-
-
-#ifdef STA_EXT
-void release_remapAid(struct rtl8192cd_priv *priv, struct stat_info *pstat)
-{
-	if(pstat->remapped_aid != FW_NUM_STAT-1){
-		int i;
-		for(i = 1; i < NUM_STAT; i++)
-			if(priv->pshare->remapped_aidarray[i] == pstat->aid){
-				priv->pshare->remapped_aidarray[i] = 0;
-				priv->pshare->fw_free_space ++;
-				break;
-			}
-	}
-	pstat->sta_in_firmware = -1;
-
-	DEBUG_INFO("Remove id %d from ratr\n", pstat->aid);
-}
-#endif
-
-
-void add_RATid_timer(unsigned long task_priv)
-{
-	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *)task_priv;
-	struct stat_info *pstat = NULL;
-	unsigned int set_timer = 0;
-	unsigned long flags;
-
-	if (!(priv->drv_state & DRV_STATE_OPEN))
-		return;
-
-	if (timer_pending(&priv->add_RATid_timer))
-		del_timer_sync(&priv->add_RATid_timer);
-
-#ifdef PCIE_POWER_SAVING
-	if ((priv->pwr_state == L2) || (priv->pwr_state == L1))
-			return;
-#endif
-
-	if (!list_empty(&priv->addRAtid_list)) {
-		pstat = list_entry(priv->addRAtid_list.next, struct stat_info, addRAtid_list);
-		if (!pstat)
-			return;
-
-		if (!is_h2c_buf_occupy(priv)) {
-			add_RATid(priv, pstat);
-			if (!list_empty(&pstat->addRAtid_list)) {
-				SAVE_INT_AND_CLI(flags);
-				SMP_LOCK(flags);
-				list_del_init(&pstat->addRAtid_list);
-				RESTORE_INT(flags);
-				SMP_UNLOCK(flags);
-			}
-
-			if (!list_empty(&priv->addRAtid_list))
-				set_timer++;
-		} else {
-			set_timer++;
-		}
-	}
-
-	if (set_timer)
-		mod_timer(&priv->add_RATid_timer, jiffies + RTL_MILISECONDS_TO_JIFFIES(50));	// 50 ms
-}
-
-
-void add_update_RATid(struct rtl8192cd_priv *priv, struct stat_info *pstat)
-{
-	unsigned long flags;
-
-	if (is_h2c_buf_occupy(priv)) {
-	if (list_empty(&pstat->addRAtid_list)) {
-		SAVE_INT_AND_CLI(flags);
-		list_add_tail(&(pstat->addRAtid_list), &(priv->addRAtid_list));
-		RESTORE_INT(flags);
-
-		if (!timer_pending(&priv->add_RATid_timer))
-			mod_timer(&priv->add_RATid_timer, jiffies + RTL_MILISECONDS_TO_JIFFIES(50));	// 50 ms
-	}
-	} else {
-		add_RATid(priv, pstat);
-}
-}
-
-
-#ifdef RTK_QUE
-void rtk_queue_init(struct ring_que *que)
-{
-	memset(que, '\0', sizeof(struct ring_que));
-	que->qmax = MAX_PRE_ALLOC_SKB_NUM;
-}
-
-static int rtk_queue_tail(struct rtl8192cd_priv *priv, struct ring_que *que, struct sk_buff *skb)
-{
-	int next;
-	unsigned long x;
-
-	SAVE_INT_AND_CLI(x);
-	SMP_LOCK_SKB(x);
-
-	if (que->head == que->qmax)
-		next = 0;
-	else
-		next = que->head + 1;
+	if (que->head == que->qmax)
+		next = 0;
+	else
+		next = que->head + 1;
 
 	if (que->qlen >= que->qmax || next == que->tail) {
 		printk("%s: ring-queue full!\n", __FUNCTION__);
@@ -4924,7 +4721,10 @@ void restore_backup_sta(struct rtl8192cd_priv *priv, void *pInfo)
 				|| (pstat->state & WIFI_WDS)
 #endif
 			) {
-			check_sta_characteristic(priv, pstat, INCREASE);
+#ifdef CONFIG_RTL_88E_SUPPORT
+			if (GET_CHIP_VER(priv)!=VERSION_8188E) 
+#endif
+				check_sta_characteristic(priv, pstat, INCREASE);
 			if (priv->pmib->dot11BssType.net_work_type & WIRELESS_11N)
 				construct_ht_ie(priv, priv->pshare->is_40m_bw, priv->pshare->offset_2nd_chan);
 
@@ -4945,7 +4745,16 @@ void restore_backup_sta(struct rtl8192cd_priv *priv, void *pInfo)
 			}
 			}
 			// to avoid add RAtid fail
-			add_update_RATid(priv, pstat);
+#ifdef CONFIG_RTL_88E_SUPPORT
+			if (GET_CHIP_VER(priv)==VERSION_8188E) {
+#ifdef TXREPORT
+				add_RATid(priv, pstat);
+#endif
+			} else
+#endif
+			{
+				add_update_RATid(priv, pstat);
+			}
 			kfree(pBackup->sta[i]);
 
 			if ( priv->pshare->is_40m_bw && pstat->is_marvell_sta){
@@ -4954,6 +4763,11 @@ void restore_backup_sta(struct rtl8192cd_priv *priv, void *pInfo)
 					priv->pshare->marvellMapBitExt |= BIT(pstat->aid - FW_NUM_STAT - 1);
 				else
 #endif
+#ifdef CONFIG_RTL_88E_SUPPORT
+				if ((GET_CHIP_VER(priv) == VERSION_8188E) && (pstat->aid > 32))
+					priv->pshare->marvellMapBit_88e_hw_ext |= BIT(pstat->aid - 32 - 1);
+				else
+#endif
 					priv->pshare->marvellMapBit |= BIT(pstat->aid - 1);
 
 				if (priv->pshare->Reg_RRSR_2 == 0 && priv->pshare->Reg_81b == 0){
@@ -5033,9 +4847,9 @@ void restore_backup_sta(struct rtl8192cd_priv *priv, void *pInfo)
 				#define MAX_SKB_NUM		160
 			#endif
 			
-			#if defined(CONFIG_RTL_8198_GW) || defined(CONFIG_RTL_8198_AP_ROOT)
+			#if defined(CONFIG_RTL_8198_GW) || defined(CONFIG_RTL_8198_AP_ROOT) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 			 #undef  MAX_SKB_NUM
-			 #define MAX_SKB_NUM		300
+			 #define MAX_SKB_NUM	480
 			#endif			
 		#else
 			#define MAX_SKB_NUM		580
@@ -5335,190 +5149,6 @@ void free_rtl8190_priv_buf(unsigned char *head)
 #endif //CONFIG_RTL8190_PRIV_SKB
 
 
-void choose_IOT_main_sta(struct rtl8192cd_priv *priv, struct stat_info *pstat)
-{
-	if ((GET_ROOT(priv)->up_time % 2) == 0) {
-		unsigned int tx_2s_avg = 0;
-		unsigned int rx_2s_avg = 0;
-		unsigned long total_sum = (priv->pshare->current_tx_bytes+priv->pshare->current_rx_bytes);
-
-		pstat->current_tx_bytes += pstat->tx_byte_cnt;
-		pstat->current_rx_bytes += pstat->rx_byte_cnt;
-
-		if (total_sum != 0) {
-			if (total_sum <= 100) {
-				tx_2s_avg = (unsigned int)((pstat->current_tx_bytes*100) / total_sum);
-				rx_2s_avg = (unsigned int)((pstat->current_rx_bytes*100) / total_sum);
-			} else {
-				tx_2s_avg = (unsigned int)(pstat->current_tx_bytes / (total_sum / 100));
-				rx_2s_avg = (unsigned int)(pstat->current_rx_bytes / (total_sum / 100));
-			}
-		}
-
-		if (pstat->ht_cap_len) {
-			if ((tx_2s_avg + rx_2s_avg >= 50) && (pstat->tx_avarage + pstat->rx_avarage > 10*1024*1024/8)) {
-				priv->pshare->highTP_found_pstat = pstat;
-			}
-		}
-	}
-	else {
-		pstat->current_tx_bytes = pstat->tx_byte_cnt;
-		pstat->current_rx_bytes = pstat->rx_byte_cnt;
-	}
-}
-
-
-void rxBB_dm(struct rtl8192cd_priv *priv)
-{
-	if ((priv->up_time % 3) == 1) {
-		if (priv->pshare->rssi_min != 0xff) {
-			if (priv->pshare->rf_ft_var.dig_enable) {
-				// for DIG checking
-				check_DIG_by_rssi(priv, priv->pshare->rssi_min);
-			}
-		}
-
-		check_EDCCA(priv, priv->pshare->rssi_min);
-
-#ifdef MP_TEST
-		if (!((OPMODE & WIFI_MP_STATE) || priv->pshare->rf_ft_var.mp_specific))
-#endif
-		{
-			if (!priv->pshare->rf_ft_var.use_ext_lna)
-				CCK_CCA_dynamic_enhance(priv, priv->pshare->rssi_min);
-		}		
-	}
-}
-
-
-/*
- * IOT related functions
- */
-void IOT_engine(struct rtl8192cd_priv *priv)
-{
-#ifdef WIFI_WMM
-	unsigned int switch_turbo = 0;
-#endif
-	struct stat_info *pstat = priv->pshare->highTP_found_pstat;
-
-#if defined(RTL_MANUAL_EDCA) && defined(WIFI_WMM)
-	if(priv->pmib->dot11QosEntry.ManualEDCA)
-		return ;
-#endif
-	
-
-
-#ifdef WIFI_WMM
-	if (QOS_ENABLE) {
-		if (!priv->pmib->dot11OperationEntry.wifi_specific || 
-			((OPMODE & WIFI_AP_STATE) && (priv->pmib->dot11OperationEntry.wifi_specific == 2))) {
-			if (priv->pshare->iot_mode_enable &&
-				((priv->pshare->phw->VO_pkt_count > 50) ||
-				(priv->pshare->phw->VI_pkt_count > 50) ||
-				(priv->pshare->phw->BK_pkt_count > 50))) {
-				priv->pshare->iot_mode_enable = 0;
-				switch_turbo++;
-			} else if ((!priv->pshare->iot_mode_enable) &&
-				((priv->pshare->phw->VO_pkt_count < 50) &&
-				(priv->pshare->phw->VI_pkt_count < 50) &&
-				(priv->pshare->phw->BK_pkt_count < 50))) {
-					priv->pshare->iot_mode_enable++;
-					switch_turbo++;
-			}
-		}
-
-		if ((OPMODE & WIFI_AP_STATE) && priv->pmib->dot11OperationEntry.wifi_specific) {
-			if (!priv->pshare->iot_mode_VO_exist && (priv->pshare->phw->VO_pkt_count > 50)) {
-				priv->pshare->iot_mode_VO_exist++;
-				switch_turbo++;
-			} else if (priv->pshare->iot_mode_VO_exist && (priv->pshare->phw->VO_pkt_count < 50)) {
-				priv->pshare->iot_mode_VO_exist = 0;
-				switch_turbo++;
-			}
-		}
-
-		priv->pshare->phw->VO_pkt_count = 0;
-		priv->pshare->phw->VI_pkt_count = 0;
-		priv->pshare->phw->BK_pkt_count = 0;
-	}
-#endif
-
-		if ((priv->up_time % 2) == 0) {
-			/*
-			 * decide EDCA content for different chip vendor
-			 */
-#ifdef WIFI_WMM
-		if (QOS_ENABLE && (!priv->pmib->dot11OperationEntry.wifi_specific || 
-			((OPMODE & WIFI_AP_STATE) && (priv->pmib->dot11OperationEntry.wifi_specific == 2)))) {
-			if (pstat && pstat->rssi >= priv->pshare->rf_ft_var.txop_enlarge_upper) {
-				if (priv->pshare->txop_enlarge != 2) {
-					if (pstat->is_intel_sta)
-						priv->pshare->txop_enlarge = 0xe;						
-					else if (pstat->is_ralink_sta)
-						priv->pshare->txop_enlarge = 0xd;						
-					else
-						priv->pshare->txop_enlarge = 2;
-
-					if (priv->pshare->iot_mode_enable)
-						switch_turbo++;
-				}
-			} else if (!pstat || pstat->rssi < priv->pshare->rf_ft_var.txop_enlarge_lower) {
-				if (priv->pshare->txop_enlarge) {
-					priv->pshare->txop_enlarge = 0;
-					if (priv->pshare->iot_mode_enable)
-						switch_turbo++;
-				}
-			}
-		}
-#endif
-
-			priv->pshare->current_tx_bytes = 0;
-			priv->pshare->current_rx_bytes = 0;
-		}
-
-#ifdef SW_TX_QUEUE
-		if ((priv->assoc_num > 1) && (AMPDU_ENABLE))
-        	{
-                	if (priv->swq_txmac_chg >= priv->pshare->rf_ft_var.swq_en_highthd)
-	                {
-        	                if ((priv->swq_en == 0))
-				{
-                        	        switch_turbo++;
-                                	if (priv->pshare->txop_enlarge == 0)
-	                                        priv->pshare->txop_enlarge = 2;
-        	                        priv->swq_en = 1;
-                	        }
-                        	else
-	                        {
-        	                        if ((switch_turbo > 0) && (priv->pshare->txop_enlarge == 0) && (priv->pshare->iot_mode_enable != 0))
-                	                {
-                        	                priv->pshare->txop_enlarge = 2;
-                                	        switch_turbo--;
-	                                }
-        	                }
-                	}
-	                else if(priv->swq_txmac_chg <= priv->pshare->rf_ft_var.swq_dis_lowthd)
-        	        {
-                	        priv->swq_en = 0;
-	                }
-        	        else if ((priv->swq_en == 1) && (switch_turbo > 0) && (priv->pshare->txop_enlarge == 0) && (priv->pshare->iot_mode_enable != 0))
-                	{
-                        	priv->pshare->txop_enlarge = 2;
-	                        switch_turbo--;
-        	        }
-		
-			//debug msg	
-			//printk("swq=%d,sw=%d,en=%d,mode=%d\n", priv->swq_en, switch_turbo, priv->pshare->txop_enlarge, priv->pshare->iot_mode_enable);
-        	}
-#endif
-
-#ifdef WIFI_WMM
-		if (switch_turbo)
-		IOT_EDCA_switch(priv, priv->pmib->dot11BssType.net_work_type, priv->pshare->iot_mode_enable);
-#endif
-	}
-
-
 
 /*
 unsigned int set_fw_reg(struct rtl8192cd_priv *priv, unsigned int cmd, unsigned int val, unsigned int with_val)
@@ -5576,7 +5206,7 @@ void set_fw_A2_entry(struct rtl8192cd_priv *priv, unsigned int cmd, unsigned cha
 }
 */
 
-#if defined(TXREPORT) || defined(SW_ANT_SWITCH)
+#if (defined(TXREPORT) && (defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT))) || defined(SW_ANT_SWITCH)
 
 struct stat_info* findNextSTA(struct rtl8192cd_priv *priv, int *idx)
 {
@@ -5585,9 +5215,18 @@ struct stat_info* findNextSTA(struct rtl8192cd_priv *priv, int *idx)
 		if (priv->pshare->aidarray[i] && priv->pshare->aidarray[i]->used == TRUE) {
 			*idx = (i+1);
 #ifdef STA_EXT
-			if(priv->pshare->aidarray[i]->station.remapped_aid == FW_NUM_STAT-1)
+			if (
+#ifdef CONFIG_RTL_88E_SUPPORT
+				(GET_CHIP_VER(priv)==VERSION_8188E)?
+				(priv->pshare->aidarray[i]->station.remapped_aid == RTL8188E_NUM_STAT-1):
+#endif
+				(priv->pshare->aidarray[i]->station.remapped_aid == FW_NUM_STAT-1))
 #else
-			if(priv->pshare->aidarray[i]->station.aid == FW_NUM_STAT)
+			if (
+#ifdef CONFIG_RTL_88E_SUPPORT
+				(GET_CHIP_VER(priv)==VERSION_8188E)?(priv->pshare->aidarray[i]->station.aid == RTL8188E_NUM_STAT):
+#endif
+				(priv->pshare->aidarray[i]->station.aid == FW_NUM_STAT))
 #endif
 				continue;
 
@@ -5597,7 +5236,7 @@ struct stat_info* findNextSTA(struct rtl8192cd_priv *priv, int *idx)
 	return NULL;
 }
 #endif
-#ifdef TXREPORT
+#if defined(TXREPORT) && (defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT))
 void requestTxReport(struct rtl8192cd_priv *priv)
 {
 	int h2ccmd, counter=20;
@@ -5715,149 +5354,7 @@ void C2H_isr(struct rtl8192cd_priv *priv)
 	RESTORE_INT(flags);
 }
 
-#ifdef DETECT_STA_EXISTANCE
-// Check for STA existance. If STA disappears, disconnect it. Added by Annie, 2010-08-10.
-void DetectSTAExistance(struct rtl8192cd_priv *priv, struct tx_rpt *report, struct stat_info *pstat)
-{
-	unsigned char tmpbuf[16];
-
-	// Parameters
-	const unsigned int		maxTxFailCnt = 300;		// MAX Tx fail packet count
-	const unsigned int		minTxFailCnt = 30;		// MIN Tx fail packet count; this value should be less than maxTxFailCnt.
-	const unsigned int		txFailSecThr= 3;			// threshold of Tx Fail Time (in second)
-
-	// Temporarily change Retry Limit when TxFail. (tfrl: TxFailRetryLimit)
-	const unsigned char	TFRL = 7;				// New Retry Limit value
-	const unsigned char	TFRL_FailCnt = 2;		// Tx Fail Count threshold to set Retry Limit
-	const unsigned char	TFRL_SetTime = 2;		// Time to set Retry Limit (in second)
-	const unsigned char	TFRL_RcvTime = 10;		// Time to recover Retry Limit (in second)
-
-	if( report->txok != 0 )
-	{ // Reset Counter
-		pstat->tx_conti_fail_cnt = 0;
-		pstat->tx_last_good_time = priv->up_time;
-		pstat->leave = 0;
-	}
-	else if( report->txfail != 0 )
-	{
-		pstat->tx_conti_fail_cnt += report->txfail;
-		DEBUG_WARN( "detect: txfail=%d, tx_conti_fail_cnt=%d\n", report->txfail, pstat->tx_conti_fail_cnt );
-
-		if(	priv->up_time >= (pstat->tx_last_good_time+TFRL_SetTime) &&
-			pstat->tx_conti_fail_cnt >= TFRL_FailCnt && 
-			//!pstat->ht_cap_len && // legacy rate only
-			!priv->pshare->bRLShortened )
-		{ // Shorten retry limit, because AP spending too much time to send out g mode STA pending packets in HW queue.
-			RTL_W16(RL, (TFRL&SRL_Mask)<<SRL_SHIFT|(TFRL&LRL_Mask)<<LRL_SHIFT);
-			priv->pshare->bRLShortened = TRUE;
-			DEBUG_WARN( "== Shorten RetryLimit to 0x%04X ==\n", RTL_R16(RL) );
-		}
-
-		if( 	(pstat->tx_conti_fail_cnt >= maxTxFailCnt) ||
-			(pstat->tx_conti_fail_cnt >= minTxFailCnt && priv->up_time >= (pstat->tx_last_good_time+txFailSecThr) )
-			)
-		{ // This STA is considered as disappeared, so delete it.
-			DEBUG_WARN( "** tx_conti_fail_cnt=%d (min=%d,max=%d)\n", pstat->tx_conti_fail_cnt, minTxFailCnt, maxTxFailCnt);
-			DEBUG_WARN( "** tx_last_good_time=%d, up_time=%d (Thr:%d)\n", (int)pstat->tx_last_good_time, (int)priv->up_time, txFailSecThr );
-			DEBUG_WARN( "AP is going to del_sta %02X:%02X:%02X:%02X:%02X:%02X\n", pstat->hwaddr[0],pstat->hwaddr[1],pstat->hwaddr[2],pstat->hwaddr[3],pstat->hwaddr[4],pstat->hwaddr[5] );
-
-			sprintf((char *)tmpbuf, "%02x%02x%02x%02x%02x%02x", pstat->hwaddr[0],pstat->hwaddr[1],pstat->hwaddr[2],pstat->hwaddr[3],pstat->hwaddr[4],pstat->hwaddr[5]);
-		
-//			del_sta(priv, tmpbuf);
-			++(pstat->leave);
-
-			if (timer_pending(&priv->pshare->rl_recover_timer))
-				del_timer_sync (&priv->pshare->rl_recover_timer);
-			mod_timer(&priv->pshare->rl_recover_timer, jiffies + EXPIRE_TO*TFRL_RcvTime);
-
-			// Reset Counter
-			pstat->tx_conti_fail_cnt = 0;
-			pstat->tx_last_good_time = priv->up_time;
-		}
-	}
-}
-
-// Timer callback function to recover hardware retry limit register. Added by Annie, 2010-08-10.
-void RetryLimitRecovery(unsigned long task_priv)
-{
-	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *)task_priv;
-	if( priv->pshare->bRLShortened )
-	{
-		RTL_W16(RL, (priv->pshare->RLShort&SRL_Mask)<<SRL_SHIFT|(priv->pshare->RLLong&LRL_Mask)<<LRL_SHIFT);
-		priv->pshare->bRLShortened = FALSE;
-		DEBUG_WARN( "== Recover RetryLimit to 0x%04X ==\n", RTL_R16(RL) );
-	}
-}
-
-// Chack STA leaving status; per interface. Added by Annie, 2010-08-10.
-unsigned char NoLeavingSTA(struct rtl8192cd_priv *priv)
-{
-	unsigned char bStaAllOK = TRUE;
-	struct list_head *phead, *plist;
-	struct stat_info *pstat;
-
-	phead = &priv->asoc_list;
-	if (!netif_running(priv->dev) || list_empty(phead))
-		return bStaAllOK;
-
-	plist = phead->next;
-	while (plist != phead)  {
-		pstat = list_entry(plist, struct stat_info, asoc_list);
-		if( pstat->tx_conti_fail_cnt != 0 ) {
-			bStaAllOK = FALSE;
-			break;
-		}
-		plist = plist->next;
-	}
-
-	return bStaAllOK;
-}
-
-// Chack STA leaving status for all active interface and recover retry limit register value. Added by Annie, 2010-08-10.
-void LeavingSTA_RLCheck(struct rtl8192cd_priv *priv)
-{
-	unsigned char bIfAllOK = TRUE;
-	static int AllOKTimes = 0;
-#ifdef MBSSID
-	int i;
-#endif
-	// Parameter
-	const unsigned char	TFRL_RcvTime = 10;		// Time to recover Retry Limit (in second)
-
-	if( !NoLeavingSTA(priv) )
-		bIfAllOK = FALSE;
-
-#ifdef UNIVERSAL_REPEATER
-	if (IS_ROOT_INTERFACE(priv) && GET_VXD_PRIV(priv) ) {
-		if( !NoLeavingSTA(GET_VXD_PRIV(priv)) )
-			bIfAllOK = FALSE;
-	}
-#endif
 
-#ifdef MBSSID
-	if (IS_ROOT_INTERFACE(priv)) {
-		if (GET_ROOT(priv)->pmib->miscEntry.vap_enable) {
-			for (i=0; i<RTL8192CD_NUM_VWLAN; i++) {
-				if (IS_DRV_OPEN(priv->pvap_priv[i])) {
-					if( !NoLeavingSTA(priv->pvap_priv[i]) )
-						bIfAllOK = FALSE;
-				}
-			}
-		}
-	}
-#endif
-
-	if( bIfAllOK ) {
-		AllOKTimes ++;
-
-		if( AllOKTimes >= TFRL_RcvTime )
-			RetryLimitRecovery((unsigned long)priv);
-	}
-	else {
-		AllOKTimes = 0;
-	}
-}
-#endif
 #endif
 
 #ifdef CONFIG_RTL_WAPI_SUPPORT
@@ -5918,3 +5415,242 @@ INT32 rtl_isPassthruFrame(UINT8 *data)
 }
 #endif
 
+#ifdef USE_TXQUEUE
+int init_txq_pool(struct list_head *head, unsigned char **ppool)
+{
+	unsigned char *ptr;
+	unsigned int i;
+	struct txq_node *pnode;
+
+	INIT_LIST_HEAD(head);
+	
+	ptr = kmalloc(TXQUEUE_SIZE * sizeof(struct txq_node), GFP_ATOMIC);
+	if (!ptr) {
+		printk("ERRORL: %s failed\n", __FUNCTION__);
+		*ppool = NULL;
+		return -1;
+	}
+
+	pnode = (struct txq_node *)ptr;
+	for (i=0; i<TXQUEUE_SIZE; i++)
+	{
+		pnode[i].skb = NULL;
+		pnode[i].dev = NULL;
+		list_add_tail(&(pnode[i].list), head);
+	}
+
+	*ppool = ptr;
+	return 0;
+}
+
+void free_txq_pool(struct list_head *head, unsigned char *ppool)
+{
+	if (ppool)
+		kfree(ppool);
+	INIT_LIST_HEAD(head);
+}
+
+void append_skb_to_txq_head(struct txq_list_head *head, struct rtl8192cd_priv *priv, struct sk_buff *skb, struct net_device *dev, struct list_head *pool)
+{
+	struct txq_node *pnode = NULL;
+
+	if (list_empty(pool))
+	{
+		DEBUG_ERR("%s: No unused node in pool, this should not happend, fix me.\n", __FUNCTION__);
+		rtl_kfree_skb(priv, skb, _SKB_TX_);
+		DEBUG_ERR("TX DROP: exceed the tx queue!\n");
+		priv->ext_stats.tx_drops++;		
+		return;
+	}
+
+	pnode = (struct txq_node *)pool->next;
+	list_del(pool->next);
+	pnode->skb = skb;
+	pnode->dev = dev;
+	
+	add_txq_head(head, pnode);
+}
+
+void append_skb_to_txq_tail(struct txq_list_head *head, struct rtl8192cd_priv *priv, struct sk_buff *skb, struct net_device *dev, struct list_head *pool)
+{
+	struct txq_node *pnode = NULL;
+
+	if (list_empty(pool))
+	{
+		DEBUG_ERR("%s: No unused node in pool, this should not happend, fix me.\n", __FUNCTION__);
+		rtl_kfree_skb(priv, skb, _SKB_TX_);
+		DEBUG_ERR("TX DROP: exceed the tx queue!\n");
+		priv->ext_stats.tx_drops++;		
+		return;
+	}
+
+	pnode = (struct txq_node *)pool->next;
+	list_del(pool->next);
+	pnode->skb = skb;
+	pnode->dev = dev;
+	
+	add_txq_tail(head, pnode);
+}
+
+void remove_skb_from_txq(struct txq_list_head *head, struct sk_buff **pskb, struct net_device **pdev, struct list_head *pool)
+{
+	struct txq_node *pnode = NULL;
+
+	if (is_txq_empty(head))
+	{
+		*pskb = NULL;
+		*pdev = NULL;
+		return;
+	}
+
+	pnode = deq_txq(head);
+	*pskb = pnode->skb;
+	*pdev = pnode->dev;
+	pnode->skb = NULL;
+	pnode->dev = NULL;
+
+	list_add_tail(&pnode->list, pool);
+}
+
+#endif
+
+
+#ifdef TLN_STATS
+void stats_conn_rson_counts(struct rtl8192cd_priv *priv, unsigned int reason)
+{
+	switch (reason) {
+	case _RSON_UNSPECIFIED_:
+		priv->ext_wifi_stats.rson_UNSPECIFIED_1++;
+		break;
+	case _RSON_AUTH_NO_LONGER_VALID_:
+		priv->ext_wifi_stats.rson_AUTH_INVALID_2++;
+		break;
+	case _RSON_DEAUTH_STA_LEAVING_:
+		priv->ext_wifi_stats.rson_DEAUTH_STA_LEAVING_3++;
+		break;
+	case _RSON_INACTIVITY_:
+		priv->ext_wifi_stats.rson_INACTIVITY_4++;
+		break;
+	case _RSON_UNABLE_HANDLE_:
+		priv->ext_wifi_stats.rson_RESOURCE_INSUFFICIENT_5++;
+		break;
+	case _RSON_CLS2_:
+		priv->ext_wifi_stats.rson_UNAUTH_CLS2FRAME_6++;
+		break;
+	case _RSON_CLS3_:
+		priv->ext_wifi_stats.rson_UNAUTH_CLS3FRAME_7++;
+		break;
+	case _RSON_DISAOC_STA_LEAVING_:
+		priv->ext_wifi_stats.rson_DISASSOC_STA_LEAVING_8++;
+		break;
+	case _RSON_ASOC_NOT_AUTH_:
+		priv->ext_wifi_stats.rson_ASSOC_BEFORE_AUTH_9++;
+		break;
+	case _RSON_INVALID_IE_:
+		priv->ext_wifi_stats.rson_INVALID_IE_13++;
+		break;
+	case _RSON_MIC_FAILURE_:
+		priv->ext_wifi_stats.rson_MIC_FAILURE_14++;
+		break;
+	case _RSON_4WAY_HNDSHK_TIMEOUT_:
+		priv->ext_wifi_stats.rson_4WAY_TIMEOUT_15++;
+		break;
+	case _RSON_GROUP_KEY_UPDATE_TIMEOUT_:
+		priv->ext_wifi_stats.rson_GROUP_KEY_TIMEOUT_16++;
+		break;
+	case _RSON_DIFF_IE_:
+		priv->ext_wifi_stats.rson_DIFF_IE_17++;
+		break;
+	case _RSON_MLTCST_CIPHER_NOT_VALID_:
+		priv->ext_wifi_stats.rson_MCAST_CIPHER_INVALID_18++;
+		break;
+	case _RSON_UNICST_CIPHER_NOT_VALID_:
+		priv->ext_wifi_stats.rson_UCAST_CIPHER_INVALID_19++;
+		break;
+	case _RSON_AKMP_NOT_VALID_:
+		priv->ext_wifi_stats.rson_AKMP_INVALID_20++;
+		break;
+	case _RSON_UNSUPPORT_RSNE_VER_:
+		priv->ext_wifi_stats.rson_UNSUPPORT_RSNIE_VER_21++;
+		break;
+	case _RSON_INVALID_RSNE_CAP_:
+		priv->ext_wifi_stats.rson_RSNIE_CAP_INVALID_22++;
+		break;
+	case _RSON_IEEE_802DOT1X_AUTH_FAIL_:
+		priv->ext_wifi_stats.rson_802_1X_AUTH_FAIL_23++;
+		break;
+	default:
+		priv->ext_wifi_stats.rson_OUT_OF_SCOPE++;
+		/*panic_printk("incorrect reason(%d) for statistics\n", reason);*/
+		break;
+	}
+
+	priv->wifi_stats.rejected_sta++;
+}
+
+
+void stats_conn_status_counts(struct rtl8192cd_priv *priv, unsigned int status)
+{
+	switch (status) {
+	case _STATS_SUCCESSFUL_:
+		priv->wifi_stats.connected_sta++;
+		break;
+	case _STATS_FAILURE_:
+		priv->ext_wifi_stats.status_FAILURE_1++;
+		break;
+	case _STATS_CAP_FAIL_:
+		priv->ext_wifi_stats.status_CAP_FAIL_10++;
+		break;
+	case _STATS_NO_ASOC_:
+		priv->ext_wifi_stats.status_NO_ASSOC_11++;
+		break;
+	case _STATS_OTHER_:
+		priv->ext_wifi_stats.status_OTHER_12++;
+		break;
+	case _STATS_NO_SUPP_ALG_:
+		priv->ext_wifi_stats.status_NOT_SUPPORT_ALG_13++;
+		break;
+	case _STATS_OUT_OF_AUTH_SEQ_:
+		priv->ext_wifi_stats.status_OUT_OF_AUTH_SEQ_14++;
+		break;
+	case _STATS_CHALLENGE_FAIL_:
+		priv->ext_wifi_stats.status_CHALLENGE_FAIL_15++;
+		break;
+	case _STATS_AUTH_TIMEOUT_:
+		priv->ext_wifi_stats.status_AUTH_TIMEOUT_16++;
+		break;
+	case _STATS_UNABLE_HANDLE_STA_:
+		priv->ext_wifi_stats.status_RESOURCE_INSUFFICIENT_17++;
+		break;
+	case _STATS_RATE_FAIL_:
+		priv->ext_wifi_stats.status_RATE_FAIL_18++;
+		break;
+	default:
+		priv->ext_wifi_stats.status_OUT_OF_SCOPE++;
+		/*panic_printk("incorrect status(%d) for statistics\n", status);*/
+		break;
+	}
+
+	if (status != _STATS_SUCCESSFUL_)
+		priv->wifi_stats.rejected_sta++;
+}
+#endif
+
+#ifdef CONFIG_RTL_ULINKER
+void enable_sys_LED(struct rtl8192cd_priv *priv)
+{
+	RTL_W32(GPIO_PIN_CTRL, (RTL_R32(GPIO_PIN_CTRL) | 0x10100000));
+	RTL_W32(GPIO_PIN_CTRL, (RTL_R32(GPIO_PIN_CTRL) | 0x00001000));
+}
+
+void set_sys_LED(int on)
+{
+	struct rtl8192cd_priv *priv = root_priv;
+
+	if (on)
+		RTL_W32(GPIO_PIN_CTRL, (RTL_R32(GPIO_PIN_CTRL) & ~(0x00001000)));
+	else
+		RTL_W32(GPIO_PIN_CTRL, (RTL_R32(GPIO_PIN_CTRL) | 0x00001000));
+}
+#endif
+
diff --git a/drivers/net/wireless/rtl8192cd/8192cd_util.h b/drivers/net/wireless/rtl8192cd/8192cd_util.h
index 16d764a..9282505 100644
--- a/drivers/net/wireless/rtl8192cd/8192cd_util.h
+++ b/drivers/net/wireless/rtl8192cd/8192cd_util.h
@@ -26,7 +26,7 @@
 #include "./8192cd_hw.h"
 
 #ifdef CONFIG_RTK_MESH
-#include "./mesh_ext/mesh_util.h"
+#include "../mesh_ext/mesh_util.h"
 #endif
 
 #ifdef GREEN_HILL
@@ -87,14 +87,21 @@
 #define RTL_MILISECONDS_TO_JIFFIES(x) ((x*HZ)/1000)
 #define RTL_10MILISECONDS_TO_JIFFIES(x) ((x*HZ)/100)
 #define RTL_JIFFIES_TO_MICROSECOND ((1000*1000)/HZ)
+#define RTL_JIFFIES_TO_MILISECONDS(x) ((x*1000)/HZ)
 
 #define GET_CHIP_VER(priv)		((priv->pshare->version_id&VERSION_MASK))
+#if defined(CONFIG_RTL_92C_SUPPORT) || defined(SUPPORT_RTL8188E_TC)
 #define IS_TEST_CHIP(priv)		((priv->pshare->version_id&0x100))
+#endif
+#ifdef CONFIG_RTL_92C_SUPPORT
 #define IS_88RE(priv)			((priv->pshare->version_id&0x200))
+#endif
 #define IS_UMC_A_CUT(priv)		((priv->pshare->version_id&0x4f0)==0x400)
 #define IS_UMC_B_CUT(priv)		((priv->pshare->version_id&0x4f0)==0x410)
+#ifdef CONFIG_RTL_92C_SUPPORT
 #define IS_UMC_A_CUT_88C(priv)	(IS_UMC_A_CUT(priv) && (GET_CHIP_VER(priv) == VERSION_8188C))
 #define IS_UMC_B_CUT_88C(priv)	(IS_UMC_B_CUT(priv) && (GET_CHIP_VER(priv) == VERSION_8188C))
+#endif
 
 #define RTL_SET_MASK(reg,mask,val,shift) (((reg)&(~(mask)))|((val)<<(shift)))
 
@@ -475,13 +482,14 @@ enum _skb_flag_ {
 };
 
 // Allocate net device socket buffer
-extern __MIPS16 __IRAM_IN_865X struct sk_buff *alloc_skb_from_queue(struct rtl8192cd_priv *priv);
 static __inline__ struct sk_buff *rtl_dev_alloc_skb(struct rtl8192cd_priv *priv,
 				unsigned int length, int flag, int could_alloc_from_kerenl)
 {
 	struct sk_buff *skb = NULL;
 
 //	skb = dev_alloc_skb(length);
+ __MIPS16 __IRAM_IN_865X 	extern  struct sk_buff *alloc_skb_from_queue(struct rtl8192cd_priv *priv);
+
 	skb = alloc_skb_from_queue(priv);
 
 	if (skb == NULL && could_alloc_from_kerenl)
@@ -556,7 +564,7 @@ static __inline__ void rtl_cache_sync_wback(struct rtl8192cd_priv *priv, unsigne
 #ifdef __LINUX_2_6__
 		start = CPHYSADDR(start);
 #endif
-#ifdef CONFIG_NET_PCI
+#if defined(CONFIG_NET_PCI) && !defined(USE_RTL8186_SDK)
 		if (IS_PCIBIOS_TYPE) {
 #ifdef __LINUX_2_6__
 			pci_dma_sync_single_for_cpu(priv->pshare->pdev, start, size, direction);
@@ -623,7 +631,11 @@ static __inline__ unsigned int get_supported_mcs(struct rtl8192cd_priv *priv)
 		return (priv->pmib->dot11nConfigEntry.dot11nSupportedMCS & 0xffff);
 }
 
+#ifdef CONFIG_RTL8672
+static __inline__ void tx_sum_up(struct rtl8192cd_priv *priv, struct stat_info *pstat, int pktlen, struct tx_insn* txcfg)
+#else
 static __inline__ void tx_sum_up(struct rtl8192cd_priv *priv, struct stat_info *pstat, int pktlen)
+#endif
 {
 	struct net_device_stats *pnet_stats;
 
@@ -640,8 +652,8 @@ static __inline__ void tx_sum_up(struct rtl8192cd_priv *priv, struct stat_info *
 
 	if (pstat) {
 
-#ifdef TXREPORT
-#ifdef TESTCHIP_SUPPORT
+#if defined(TXREPORT) && (defined(CONFIG_RTL_92C_SUPPORT) || defined(CONFIG_RTL_92D_SUPPORT))
+#if defined(TESTCHIP_SUPPORT) && defined(CONFIG_RTL_92C_SUPPORT)
 		if (IS_TEST_CHIP(priv))
 			pstat->tx_pkts++;
 		else
@@ -652,6 +664,13 @@ static __inline__ void tx_sum_up(struct rtl8192cd_priv *priv, struct stat_info *
 		if (pstat->aid == FW_NUM_STAT)	
 #endif			
 #endif
+#ifdef CONFIG_RTL8672
+		if (txcfg->fr_type == _SKB_FRAME_TYPE_
+#ifdef SUPPORT_TX_MCAST2UNI
+			&& !txcfg->isMC2UC
+#endif		
+		)
+#endif
 		pstat->tx_pkts++;
 		pstat->tx_bytes += pktlen;
 		pstat->tx_byte_cnt += pktlen;
@@ -722,5 +741,14 @@ extern struct pid *_wlanapp_pid;
 INT32 rtl_isPassthruFrame(UINT8 *data);
 #endif
 
+#ifdef USE_TXQUEUE
+int init_txq_pool(struct list_head *head, unsigned char **ppool);
+void free_txq_pool(struct list_head *head, unsigned char *ppool);
+void append_skb_to_txq_head(struct txq_list_head *head, struct rtl8192cd_priv *priv, struct sk_buff *skb, struct net_device *dev, struct list_head *pool);
+void append_skb_to_txq_tail(struct txq_list_head *head, struct rtl8192cd_priv *priv, struct sk_buff *skb, struct net_device *dev, struct list_head *pool);
+void remove_skb_from_txq(struct txq_list_head *head, struct sk_buff **pskb, struct net_device **pdev, struct list_head *pool);
+#endif
+void mem_dump(unsigned char *ptitle, unsigned char *pbuf, int len);
+
 #endif // _8192CD_UTIL_H_
 
diff --git a/drivers/net/wireless/rtl8192cd/8192d_hw.c b/drivers/net/wireless/rtl8192cd/8192d_hw.c
index 4aa4e8c..65a9ca8 100644
--- a/drivers/net/wireless/rtl8192cd/8192d_hw.c
+++ b/drivers/net/wireless/rtl8192cd/8192d_hw.c
@@ -1,3982 +1,4878 @@
-
-#define _8192D_HW_C_
-
-#ifdef __KERNEL__
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <asm/uaccess.h>
-#include <asm/unistd.h>
-#include <linux/synclink.h>
-#endif
-
-#include "./8192cd_cfg.h"
-#include "./8192cd.h"
-#include "./8192cd_hw.h"
-#include "./8192cd_headers.h"
-#include "./8192cd_debug.h"
-
-
-#ifdef CONFIG_RTL_92D_SUPPORT
-
-#if defined(CONFIG_RTL_819X) && defined(USE_RLX_BSP)
-#include <bsp/bspchip.h>
-#endif
-
-#ifndef REG32
-	#define REG32(reg)	 		(*(volatile unsigned int *)(reg))
-#endif
-
-#ifdef CONFIG_NET_PCI
-        #define BSP_WDTCNR 0xB800311C
-#endif
-
-
-#define IQK_ADDA_REG_NUM 16
-
-
-static unsigned int OFDMSwingTable_92D[] = {
-	0x7f8001fe, // 0, +6.0dB
-	0x788001e2, // 1, +5.5dB
-	0x71c001c7, // 2, +5.0dB
-	0x6b8001ae, // 3, +4.5dB
-	0x65400195, // 4, +4.0dB
-	0x5fc0017f, // 5, +3.5dB
-	0x5a400169, // 6, +3.0dB
-	0x55400155, // 7, +2.5dB
-	0x50800142, // 8, +2.0dB
-	0x4c000130, // 9, +1.5dB
-	0x47c0011f, // 10, +1.0dB
-	0x43c0010f, // 11, +0.5dB
-	0x40000100, // 12, +0dB
-	0x3c8000f2, // 13, -0.5dB
-	0x390000e4, // 14, -1.0dB
-	0x35c000d7, // 15, -1.5dB
-	0x32c000cb, // 16, -2.0dB
-	0x300000c0, // 17, -2.5dB
-	0x2d4000b5, // 18, -3.0dB
-	0x2ac000ab, // 19, -3.5dB
-	0x288000a2, // 20, -4.0dB
-	0x26000098, // 21, -4.5dB
-	0x24000090, // 22, -5.0dB
-	0x22000088, // 23, -5.5dB
-	0x20000080, // 24, -6.0dB
-	0x1e400079, // 25, -6.5dB
-	0x1c800072, // 26, -7.0dB
-	0x1b00006c, // 27. -7.5dB
-	0x19800066, // 28, -8.0dB
-	0x18000060, // 29, -8.5dB
-	0x16c0005b, // 30, -9.0dB
-	0x15800056, // 31, -9.5dB
-	0x14400051, // 32, -10.0dB
-	0x1300004c, // 33, -10.5dB
-	0x12000048, // 34, -11.0dB
-	0x11000044, // 35, -11.5dB
-	0x10000040, // 36, -12.0dB
-	0x0f00003c,// 37, -12.5dB
-	0x0e400039,// 38, -13.0dB
-	0x0d800036,// 39, -13.5dB
-    0x0cc00033,// 40, -14.0dB
-	0x0c000030,// 41, -14.5dB
-	0x0b40002d,// 42, -15.0dB
-};
-
-
-#ifdef CONFIG_RTL_92D_DMDP
-
-extern u32 if_priv[];
-
-__inline__ unsigned char DMDP_RTL_R8(unsigned int phy, unsigned int reg)
-{
-	struct rtl8192cd_priv *priv;
-	//printk("++++++++++++++++++++++++++%s(%x)++++++++++++++++++++++++++\n", __FUNCTION__, reg);
-	if (phy >= NUM_WLAN_IFACE || phy < 0) {
-		printk("%s: phy index[%d] out of bound !!\n", __FUNCTION__, phy);
-		return -1;
-	}
-	priv = (struct rtl8192cd_priv *)if_priv[phy];
-	return RTL_R8(reg);
-}
-
-__inline__ void DMDP_RTL_W8(unsigned int phy, unsigned int reg, unsigned char val8)
-{
-	struct rtl8192cd_priv *priv;
-	//printk("++++++++++++++++++++++++++%s(%x,%x)++++++++++++++++++++++++++\n", __FUNCTION__, reg, val8);
-	if (phy >= NUM_WLAN_IFACE || phy < 0) {
-		printk("%s: phy index[%d] out of bound !!\n", __FUNCTION__, phy);
-		return;
-	}
-	priv = (struct rtl8192cd_priv *)if_priv[phy];
-	RTL_W8(reg, val8);
-}
-
-__inline__ unsigned short DMDP_RTL_R16(unsigned int phy, unsigned int reg)
-{
-	struct rtl8192cd_priv *priv;
-	//printk("++++++++++++++++++++++++++%s++++++++++++++++++++++++++\n", __FUNCTION__);
-	if (phy >= NUM_WLAN_IFACE || phy < 0) {
-		printk("%s: phy index[%d] out of bound !!\n", __FUNCTION__, phy);
-		return -1;
-	}
-	priv = (struct rtl8192cd_priv *)if_priv[phy];
-	return RTL_R16(reg);
-}
-
-__inline__ void DMDP_RTL_W16(unsigned int phy, unsigned int reg, unsigned short val16)
-{
-	struct rtl8192cd_priv *priv;
-	//printk("++++++++++++++++++++++++++%s++++++++++++++++++++++++++\n", __FUNCTION__);
-	if (phy >= NUM_WLAN_IFACE || phy < 0) {
-		printk("%s: phy index[%d] out of bound !!\n", __FUNCTION__, phy);
-		return;
-	}
-	priv = (struct rtl8192cd_priv *)if_priv[phy];
-	RTL_W16(reg, val16);
-}
-
-__inline__ unsigned int DMDP_RTL_R32(unsigned int phy, unsigned int reg)
-{
-	struct rtl8192cd_priv *priv;
-	//printk("++++++++++++++++++++++++++%s(%x)++++++++++++++++++++++++++\n", __FUNCTION__, reg);
-	if (phy >= NUM_WLAN_IFACE || phy < 0) {
-		printk("%s: phy index[%d] out of bound !!\n", __FUNCTION__, phy);
-		return -1;
-	}
-	priv = (struct rtl8192cd_priv *)if_priv[phy];
-	return RTL_R32(reg);
-}
-
-__inline__ void DMDP_RTL_W32(unsigned int phy, unsigned int reg, unsigned int val32)
-{
-	struct rtl8192cd_priv *priv;
-	//printk("++++++++++++++++++++++++++%s(%x, %x)++++++++++++++++++++++++++\n", __FUNCTION__, reg, val32);
-	if (phy >= NUM_WLAN_IFACE || phy < 0) {
-		printk("%s: phy index[%d] out of bound !!\n", __FUNCTION__, phy);
-		return;
-	}
-	priv = (struct rtl8192cd_priv *)if_priv[phy];
-	RTL_W32(reg, val32);
-}
-
-unsigned int DMDP_PHY_QueryBBReg(unsigned int phy, unsigned int RegAddr, unsigned int BitMask)
-{
-	//printk("++++++++++++++++++++++++++%s++++++++++++++++++++++++++\n", __FUNCTION__);
-	if (phy >= NUM_WLAN_IFACE || phy < 0) {
-		printk("%s: phy index[%d] out of bound !!\n", __FUNCTION__, phy);
-		return -1;
-	}
-	return PHY_QueryBBReg((struct rtl8192cd_priv *)if_priv[phy], RegAddr, BitMask);
-}
-
-void DMDP_PHY_SetBBReg(unsigned int phy, unsigned int RegAddr, unsigned int BitMask, unsigned int Data)
-{
-	//printk("++++++++++++++++++++++++++%s++++++++++++++++++++++++++\n", __FUNCTION__);
-	if (phy >= NUM_WLAN_IFACE || phy < 0) {
-		printk("%s: phy index[%d] out of bound !!\n", __FUNCTION__, phy);
-		return;
-	}
-	PHY_SetBBReg((struct rtl8192cd_priv *)if_priv[phy], RegAddr, BitMask, Data);
-}
-
-unsigned int DMDP_PHY_QueryRFReg(unsigned int phy, RF92CD_RADIO_PATH_E eRFPath,
-				unsigned int RegAddr, unsigned int BitMask, unsigned int dbg_avoid)
-{
-	//printk("++++++++++++++++++++++++++%s++++++++++++++++++++++++++\n", __FUNCTION__);
-	if (phy >= NUM_WLAN_IFACE || phy < 0) {
-		printk("%s: phy index[%d] out of bound !!\n", __FUNCTION__, phy);
-		return -1;
-	}
-	return PHY_QueryRFReg((struct rtl8192cd_priv *)if_priv[phy], eRFPath, RegAddr, BitMask, dbg_avoid);
-}
-
-void DMDP_PHY_SetRFReg(unsigned int phy, RF92CD_RADIO_PATH_E eRFPath, unsigned int RegAddr,
-				unsigned int BitMask, unsigned int Data)
-{
-	//printk("++++++++++++++++++++++++++%s++++++++++++++++++++++++++\n", __FUNCTION__);
-	if (phy >= NUM_WLAN_IFACE || phy < 0) {
-		printk("%s: phy index[%d] out of bound !!\n", __FUNCTION__, phy);
-		return;
-	}
-	PHY_SetRFReg((struct rtl8192cd_priv *)if_priv[phy], eRFPath, RegAddr, BitMask, Data);
-}
-
-#endif //CONFIG_RTL_92D_DMDP
-
-void SetSYN_para(struct rtl8192cd_priv *priv, unsigned char channel)
-{
-	unsigned int eRFPath, tmp=0;
-	unsigned int idx=-1, i;
-	unsigned int SYN_PARA[8][8] = {
-		{0xe43be, 0xfc638, 0x77c0a, 0xde471, 0xd7110, 0x8cb04, 0x00000, 0x00000},	// CH36-140 20MHz
-		{0xe43be, 0xfc078, 0xf7c1a, 0xe0c71, 0xd7550, 0xacb04, 0x00000, 0x00000},	// CH36-140 40MHz
-		{0xe43bf, 0xff038, 0xf7c0a, 0xde471, 0xe5550, 0xacb04, 0x00000, 0x00000},	// CH149, 155, 161
-		{0xe43bf, 0xff079, 0xf7c1a, 0xde471, 0xe5550, 0xacb04, 0x00000, 0x00000},	// CH151, 153, 163, 165
-		{0xe43bf, 0xff038, 0xf7c1a, 0xde471, 0xd7550, 0xacb04, 0x00000, 0x00000},	// CH157, 159
-#ifdef SW_LCK_92D
-		{0x643bc, 0xfc038, 0x77c1a, 0x00000, 0x00000, 0x00000, 0x61289, 0x01840},	// CH1,2,4,9,10,11,12
-		{0x643bc, 0xfc038, 0x07c1a, 0x00000, 0x00000, 0x00000, 0x61289, 0x01840},	// CH3,13,14
-		{0x243bc, 0xfc438, 0x07c1a, 0x00000, 0x00000, 0x00000, 0x6128b, 0x0fc41}	// CH5-8
-#else
-		{0x643bc, 0xfc038, 0x77c1a, 0x00000, 0x00000, 0x00000, 0x41289, 0x01840},	// CH1,2,4,9,10,11,12
-		{0x643bc, 0xfc038, 0x07c1a, 0x00000, 0x00000, 0x00000, 0x41289, 0x01840},	// CH3,13,14
-		{0x243bc, 0xfc438, 0x07c1a, 0x00000, 0x00000, 0x00000, 0x4128b, 0x0fc41}	// CH5-8
-#endif
-	};
-
-
-	if (priv->pmib->dot11RFEntry.phyBandSelect==PHY_BAND_2G)
-		eRFPath = RF92CD_PATH_B;
-	else
-		eRFPath = RF92CD_PATH_A;
-
-	if (priv->pmib->dot11RFEntry.phyBandSelect==PHY_BAND_5G){
-		if (channel >=36 && channel <=140){
-			if (!priv->pshare->CurrentChannelBW)
-				idx = 0;
-			else
-				idx = 1;
-		}
-		else if (channel==149 || channel==155 || channel==161)
-			idx = 2;
-		else if (channel==151 || channel==153 || channel==163 || channel==165)
-			idx = 3;
-		else if (channel==157 || channel==159)
-			idx = 4;
-	} else {
-		if (channel==1 || channel==2 || channel==4 || channel==9 || channel==10 || channel==11 || channel==12)
-			idx = 5;
-		else if (channel==3 || channel==13 || channel==14)
-			idx = 6;
-		else if (channel>=5 && channel<=8)
-			idx = 7;
-	}
-
-	if (idx==-1){
-		DEBUG_ERR("No suitable channel (%d) for setting synthersizer parameter!\n", channel);
-		return;
-	}
-
-	for (i=0;i<8;i++){
-#ifdef CONFIG_RTL_92D_DMDP
-		if (i==0 && (idx>=0 && idx <=4) &&
-			(priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY))
-			tmp = 0xe439d;
-		else
-#endif
-			tmp = SYN_PARA[idx][i];
-
-		if (tmp!=0) {
-
-#ifdef CONFIG_RTL_92D_DMDP
-			if (priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY && eRFPath == RF92CD_PATH_B) {
-				DMDP_PHY_SetRFReg(1, RF92CD_PATH_A, (0x25+i), bMask20Bits, tmp);
-				DEBUG_INFO("DMDP_PHY_SetRFReg(1, %d, 0x%x, bMask20Bits, 0x%x)\n", eRFPath, (0x25+i), tmp);
-			} else
-#endif
-			{
-				PHY_SetRFReg(priv, eRFPath, (0x25+i), bMask20Bits, tmp);
-				DEBUG_INFO("PHY_SetRFReg(priv, %d, 0x%x, bMask20Bits, 0x%x)\n", eRFPath, (0x25+i), tmp);
-			}
-			if (i==3)
-				priv->pshare->RegRF28[eRFPath] = tmp;
-		}
-	}
-}
-
-unsigned int IMR_SET_N[3][11] = {
-  {0x00ff0, 0x4400f, 0x00ff0, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x64888, 0xe266c, 0x00090}, //G-mode
-  {0x22880, 0x4470f, 0x55880, 0x00070, 0x88000, 0x00000, 0x88080, 0x70000, 0x64a82, 0xe466c, 0x00090}, //36-64
-  {0x44880, 0x4477f, 0x77880, 0x00070, 0x88000, 0x00000, 0x880b0, 0x00000, 0x64b82, 0xe466c, 0x00090}, // 100-165
-};
-
-void SetIMR_n(struct rtl8192cd_priv *priv, unsigned char channel)
-{
-	unsigned int eRFPath, curMaxRFPath;
-	int imr_idx = -1;
-	unsigned char temp_800;
-
-#ifdef CONFIG_RTL_92D_DMDP
-	if (priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY)
-		curMaxRFPath = RF92CD_PATH_B;
-	else
-#endif
-		curMaxRFPath = RF92CD_PATH_MAX;
-
-	if (priv->pmib->dot11RFEntry.phyBandSelect==PHY_BAND_2G)
-		imr_idx = 0;
-	else {
-		if (channel>=36 && channel <=64)
-			imr_idx = 1;
-		else
-			imr_idx = 2;
-	}
-	PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0x00f00000, 0xf);
-	temp_800 = PHY_QueryBBReg(priv, rFPGA0_RFMOD, 0x0f000000);
-	PHY_SetBBReg(priv, rFPGA0_RFMOD, 0x0f000000, 0);
-
-	for(eRFPath = RF92CD_PATH_A; eRFPath < curMaxRFPath; eRFPath++) {
-		int i;
-
-		PHY_SetRFReg(priv, eRFPath, 0x00, bMask20Bits, 0x70000);
-		DEBUG_INFO("IMR [0x00] %05x\n", PHY_QueryRFReg(priv, eRFPath, 0x00, bMask20Bits,1));
-		//delay_us(5);
-
-		for (i=0;i<11;i++) {
-			PHY_SetRFReg(priv, eRFPath, (0x2f+i), bMask20Bits, IMR_SET_N[imr_idx][i]);
-			DEBUG_INFO("IMR [0x%x] %05x\n", (0x2f+i), PHY_QueryRFReg(priv, eRFPath, (0x2f+i), bMask20Bits,1));
-			//delay_us(5);
-		}
-
-		if (priv->pmib->dot11RFEntry.phyBandSelect==PHY_BAND_2G)
-			PHY_SetRFReg(priv, eRFPath, 0x00, bMask20Bits, 0x32fff);
-		else
-			PHY_SetRFReg(priv, eRFPath, 0x00, bMask20Bits, 0x32c9a);
-
-		DEBUG_INFO("IMR [0x00] %05x\n", PHY_QueryRFReg(priv, eRFPath, 0x00, bMask20Bits,1));
-		//delay_us(5);
-	}
-
-	PHY_SetBBReg(priv, rFPGA0_RFMOD, 0x0f000000, temp_800);
-	PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0x00f00000, 0x0);
-}
-
-
-/*
- *  Follow WS-20101228-Willis-xxxx dynamic parameter-R00
- */
-void Update92DRFbyChannel(struct rtl8192cd_priv *priv, unsigned char channel)
-{
-#ifdef RTL8192D_INT_PA
-	u8	eRFPath = 0, curMaxRFPath;
-	if (priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY)
-		curMaxRFPath = RF92CD_PATH_B;
-	else
-		curMaxRFPath = RF92CD_PATH_MAX;
-
-	if (priv->pshare->rf_ft_var.use_intpa92d){
-		for(eRFPath = RF92CD_PATH_A; eRFPath <curMaxRFPath; eRFPath++) {
-			if (priv->pmib->dot11RFEntry.phyBandSelect==PHY_BAND_5G){
-				if (channel>=36 && channel<=64){
-					PHY_SetRFReg(priv, eRFPath, 0x0b, bMask20Bits, 0x01a00);
-					PHY_SetRFReg(priv, eRFPath, 0x48, bMask20Bits, 0x40443);
-					PHY_SetRFReg(priv, eRFPath, 0x49, bMask20Bits, 0x00eb5);
-					//PHY_SetRFReg(priv, eRFPath, 0x4a, bMask20Bits, 0x50f0f);
-					PHY_SetRFReg(priv, eRFPath, 0x4b, bMask20Bits, 0x89bec);
-					//PHY_SetRFReg(priv, eRFPath, 0x4c, bMask20Bits, 0x0dded);
-					PHY_SetRFReg(priv, eRFPath, 0x03, bMask20Bits, 0x94a12);
-					PHY_SetRFReg(priv, eRFPath, 0x04, bMask20Bits, 0x94a12);
-					PHY_SetRFReg(priv, eRFPath, 0x0e, bMask20Bits, 0x94a12);
-				}else if (channel>=100 && channel<=140){
-					PHY_SetRFReg(priv, eRFPath, 0x0b, bMask20Bits, 0x01800);
-					PHY_SetRFReg(priv, eRFPath, 0x48, bMask20Bits, 0xc0443);
-					PHY_SetRFReg(priv, eRFPath, 0x49, bMask20Bits, 0x00730);
-					//PHY_SetRFReg(priv, eRFPath, 0x4a, bMask20Bits, 0x50f0f);
-					PHY_SetRFReg(priv, eRFPath, 0x4b, bMask20Bits, 0x896ee);
-					//PHY_SetRFReg(priv, eRFPath, 0x4c, bMask20Bits, 0x0dded);
-					PHY_SetRFReg(priv, eRFPath, 0x03, bMask20Bits, 0x94a52);
-					PHY_SetRFReg(priv, eRFPath, 0x04, bMask20Bits, 0x94a52);
-					PHY_SetRFReg(priv, eRFPath, 0x0e, bMask20Bits, 0x94a52);
-				}else if (channel>=149 && channel<=165){
-					PHY_SetRFReg(priv, eRFPath, 0x0b, bMask20Bits, 0x01800);
-					PHY_SetRFReg(priv, eRFPath, 0x48, bMask20Bits, 0xc0443);
-					PHY_SetRFReg(priv, eRFPath, 0x49, bMask20Bits, 0x00730);
-					//PHY_SetRFReg(priv, eRFPath, 0x4a, bMask20Bits, 0x50f0f);
-					PHY_SetRFReg(priv, eRFPath, 0x4b, bMask20Bits, 0x896ee);
-					//PHY_SetRFReg(priv, eRFPath, 0x4c, bMask20Bits, 0x0dded);
-					PHY_SetRFReg(priv, eRFPath, 0x03, bMask20Bits, 0x94a12);
-					PHY_SetRFReg(priv, eRFPath, 0x04, bMask20Bits, 0x94a12);
-					PHY_SetRFReg(priv, eRFPath, 0x0e, bMask20Bits, 0x94a12);
-				}
-			}else{
-					PHY_SetRFReg(priv, eRFPath, 0x0b, bMask20Bits, 0x1c000);
-					PHY_SetRFReg(priv, eRFPath, 0x03, bMask20Bits, 0x18c63);
-					PHY_SetRFReg(priv, eRFPath, 0x04, bMask20Bits, 0x18c63);
-					PHY_SetRFReg(priv, eRFPath, 0x0e, bMask20Bits, 0x18c67);
-			}
-		}
-	}
-#endif
-
-	if (priv->pmib->dot11RFEntry.phyBandSelect==PHY_BAND_5G){
-		//update fc_area
-		if (priv->pmib->dot11RFEntry.dot11channel<149)
-			PHY_SetBBReg(priv, rOFDM1_CFOTracking, BIT(14) | BIT(13), 1);
-		else
-			PHY_SetBBReg(priv, rOFDM1_CFOTracking, BIT(14) | BIT(13), 2);
-		// VCO_BF_LDO= 1.12V->1.27V for  40M spur issue
-		PHY_SetRFReg(priv, RF92CD_PATH_A, 0x2A, BIT(13)|BIT(12), 2);
-		// RX Ch36 40M spurs
-		if (channel==36){
-			priv->pshare->RegRF28[RF92CD_PATH_A] &= (~BIT(6));
-			priv->pshare->RegRF28[RF92CD_PATH_A] |= BIT(5);
-			PHY_SetRFReg(priv, RF92CD_PATH_A, 0x28, bMask20Bits, priv->pshare->RegRF28[RF92CD_PATH_A]);
-			//PHY_SetRFReg(priv, RF92CD_PATH_A, 0x28, BIT(6)|BIT(5), 0);
-		}
-	} else {
-		//update fc_area
-		PHY_SetBBReg(priv, rOFDM1_CFOTracking, BIT(14) | BIT(13), 0);
-	}
-
-}
-
-int Load_92D_Firmware(struct rtl8192cd_priv *priv)
-{
-	int fw_len, wait_cnt=0;
-	unsigned int CurPtr=0;
-	unsigned int WriteAddr;
-	unsigned int Temp;
-	unsigned char *ptmp;
-	unsigned long flags = 0;
-
-#ifdef CONFIG_RTL8672
-	printk("val=%x\n",RTL_R8(0x80));
-#endif
-
-#ifdef MP_TEST
-	if (priv->pshare->rf_ft_var.mp_specific)
-		return TRUE;
-#endif
-
-	printk("===> %s\n", __FUNCTION__);
-
-	SAVE_INT_AND_CLI(flags);
-
-	printk("Firmware check %x(%x)\n", RTL_R32(MCUFWDL), (RTL_R8(MCUFWDL) & MCUFWDL_RDY));
-	if (RTL_R8(MCUFWDL) & MCUFWDL_RDY){
-		printk("<=== Firmware Downloaded\n");
-		goto check_fwdl_rdy;
-	}
-
-	wait_cnt=0;
-	while(RTL_R8(RF_CTRL) & FW_DL_INPROC){
-		wait_cnt++;
-		delay_ms(50);
-	}
-
-#ifdef CONFIG_RTL_92D_DMDP
-	if (wait_cnt==0) {
-		if (priv->pshare->wlandev_idx == 0)
-			RTL_W8(RF_CTRL, RTL_R8(RF_CTRL)|FW_DL_INPROC);
-		else {
-			if (RTL_R8(RSV_MAC0_CTRL) & MAC0_EN)
-				goto check_fwdl_rdy;
-			else
-				RTL_W8(RF_CTRL, RTL_R8(RF_CTRL)|FW_DL_INPROC);
-		}
-	} else {
-		if (RTL_R8(MCUFWDL) & MCUFWDL_RDY){
-			printk("<=== Firmware Downloaded\n");
-			RESTORE_INT(flags);
-			return TRUE;
-		}else{
-			RTL_W8(RF_CTRL, RTL_R8(RF_CTRL)|FW_DL_INPROC);
-		}
-	}
-#else
-	if (wait_cnt==0) {
-		RTL_W8(RF_CTRL, RTL_R8(RF_CTRL)|FW_DL_INPROC);
-	} else {
-		if (RTL_R8(MCUFWDL) & MCUFWDL_RDY){
-			printk("<=== Firmware Downloaded\n");
-			RESTORE_INT(flags);
-			return TRUE;
-		}else{
-			RTL_W8(RF_CTRL, RTL_R8(RF_CTRL)|FW_DL_INPROC);
-		}
-	}
-
-#endif
-
-	if ((priv->pshare->fw_signature & 0xfff0 ) == 0x92D0)
-		ptmp = data_rtl8192dfw_n_start + RT_8192CD_FIRMWARE_HDR_SIZE;
-	else
-		ptmp = data_rtl8192dfw_n_start;
-
-	fw_len = (int)(data_rtl8192dfw_n_end - ptmp);
-	printk("[%s][rtl8192dfw_n]\n",__FUNCTION__);
-
-	// Disable SIC
-	RTL_W16(GPIO_MUXCFG, (RTL_R16(GPIO_MUXCFG) & 0xff) | HTP_EN);
-	delay_ms(1);
-
-	// Enable MCU
-	RTL_W16(SYS_FUNC_EN, (RTL_R16(SYS_FUNC_EN) & 0x0ff) | FEN_MREGEN
-		| FEN_HWPDN | FEN_DIO_RF | FEN_ELDR | FEN_DCORE |FEN_CPUEN | FEN_PCIED);
-	delay_ms(1);
-
-#ifdef CONFIG_RTL8672
-	RTL_W8(APS_FSMCO, RTL_R8(APS_FSMCO) | PFM_ALDN);
-	delay_ms(1);  //czyao
-#endif
-
-	// Load SRAM
-	WriteAddr = 0x1000;
-	RTL_W8(MCUFWDL, RTL_R8(MCUFWDL) | MCUFWDL_EN);
-	delay_ms(1);
-
-	RTL_W32(MCUFWDL, RTL_R32(MCUFWDL) & 0xfff0ffff);
-
-	delay_ms(1);
-
-	while (CurPtr < fw_len) {
-		if ((CurPtr+4) > fw_len) {
-			// Reach the end of file.
-			while (CurPtr < fw_len) {
-				Temp = *(ptmp + CurPtr);
-				RTL_W8(WriteAddr, (unsigned char)Temp);
-				WriteAddr++;
-				CurPtr++;
-			}
-		} else {
-			// Write FW content to memory.
-			Temp = *((unsigned int *)(ptmp + CurPtr));
-			Temp = cpu_to_le32(Temp);
-			RTL_W32(WriteAddr, Temp);
-			WriteAddr += 4;
-
-			if(WriteAddr == 0x2000) {
-				unsigned char tmp = RTL_R8(MCUFWDL+2);
-				tmp += 1;
-				WriteAddr = 0x1000;
-				RTL_W8(MCUFWDL+2, tmp) ;
-				delay_ms(10);
-//				printk("\n[CurPtr=%x, 0x82=%x]\n", CurPtr, RTL_R8(0x82));
-			}
-			CurPtr += 4;
-		}
-	}
-
-#if defined(CONFIG_RTL_8198)
-	REG32(BSP_WDTCNR) |=  1 << 23;
-#endif
-
-	RTL_W8(TCR+3, 0x7f);
-	RTL_W8(MCUFWDL, (RTL_R8(MCUFWDL) & 0xfe) | MCUFWDL_RDY);
-	delay_ms(1);
-	//RTL_W8(RF_CTRL, RTL_R8(RF_CTRL) | BIT(6));
-	RTL_W8(RF_CTRL, RTL_R8(RF_CTRL) & (~FW_DL_INPROC));
-	delay_ms(1);
-
-check_fwdl_rdy:
-
-	printk("<=== %s\n", __FUNCTION__);
-	// check if firmware is ready
-	wait_cnt = 0;
-#ifdef CONFIG_RTL_92D_DMDP
-	if (priv->pshare->wlandev_idx == 0)
-#endif
-	{
-		while (!(RTL_R8(RSV_MAC0_FWCTRL) & MAC0_WINTINI_RDY)) {
-			if (++wait_cnt > 10) {
-				RTL_W8(MCUFWDL, RTL_R8(MCUFWDL) & (~MCUFWDL_RDY));
-				RESTORE_INT(flags);
-				DEBUG_ERR("8192d mac0 firmware not ready\n");
-				return FALSE;
-			}
-			delay_ms(2*wait_cnt);
-		}
-	}
-#ifdef CONFIG_RTL_92D_DMDP
-	else {
-		while (!(RTL_R8(RSV_MAC1_FWCTRL) & MAC1_WINTINI_RDY)) {
-			if (++wait_cnt > 10) {
-				RTL_W8(MCUFWDL, RTL_R8(MCUFWDL) & (~MCUFWDL_RDY));
-				RESTORE_INT(flags);
-				DEBUG_ERR("8192d mac1 firmware not ready\n");
-				return FALSE;
-			}
-			delay_ms(2*wait_cnt);
-
-		}
-	}
-#endif
-	RESTORE_INT(flags);
-#ifdef CONFIG_RTL8672
-	printk("val=%x\n",RTL_R8(MCUFWDL));
-#endif
-	return TRUE;
-}
-
-
-/*
- *	92DE Operation Mode
- */
-void UpdateBBRFVal8192DE(struct rtl8192cd_priv *priv)
-{
-	u8	eRFPath = 0, curMaxRFPath;
-	//u32	u4RegValue=0;
-
-	//Update BB
-	if (priv->pmib->dot11RFEntry.phyBandSelect & PHY_BAND_5G) {
-		/*
-		 *	5G
-		 */
-		//r_select_5G for path_A/B
-		if (priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY)
-			PHY_SetBBReg(priv, rFPGA0_XAB_RFParameter, BIT(16), 0x1);
-		PHY_SetBBReg(priv, rFPGA0_XAB_RFParameter, BIT(0), 0x1);
-		//rssi_table_select:index 0 for 2.4G.1~3 for 5G
-		PHY_SetBBReg(priv, rOFDM0_AGCRSSITable, BIT(7) | BIT(6), 0x01);
-		//5G PA power on
-		if (priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY)
-			PHY_SetBBReg(priv, rFPGA0_XAB_RFParameter, BIT(31), (priv->pmib->dot11RFEntry.trsw_pape_CC & BIT(6))>>6);
-		PHY_SetBBReg(priv, rFPGA0_XAB_RFParameter, BIT(15), (priv->pmib->dot11RFEntry.trsw_pape_CC & BIT(4))>>4);
-
-		//TRSW.TRSWB and PAPE2G mode table
-		if (priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY){
-			// TRSW_2, TRSWB_2
-			PHY_SetBBReg(priv, 0x870, BIT(22)|BIT(21), 0);
-			// PAPE2G_2
-			PHY_SetBBReg(priv, 0x870, BIT(26), (priv->pmib->dot11RFEntry.trsw_pape_CC & BIT(7))>>7);
-			PHY_SetBBReg(priv, 0x864, BIT(10), (priv->pmib->dot11RFEntry.trsw_pape_CC & BIT(6))>>6);
-		}
-		// TRSW_1, TRSWB_1
-		PHY_SetBBReg(priv, 0x870, BIT(6)|BIT(5), 0);
-		// PAPE2G_1
-		PHY_SetBBReg(priv, 0x870, BIT(10), (priv->pmib->dot11RFEntry.trsw_pape_CC & BIT(5))>>5);
-		PHY_SetBBReg(priv, 0x860, BIT(10), (priv->pmib->dot11RFEntry.trsw_pape_CC & BIT(4))>>4);
-#ifdef RTL8192D_INT_PA
-		if (!priv->pshare->rf_ft_var.use_intpa92d)
-#endif
-		{
-			//5G PA power on
-			if (priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY)
-				PHY_SetBBReg(priv, rFPGA0_XAB_RFParameter, BIT(31), 0x1);
-			PHY_SetBBReg(priv, rFPGA0_XAB_RFParameter, BIT(15), 0x1);
-		}
-		// 5G LNA on
-		PHY_SetBBReg(priv, 0xb30, 0x00f00000, 0x0);
-		//fc_area
-		if (priv->pmib->dot11RFEntry.dot11channel<149)
-			PHY_SetBBReg(priv, rOFDM1_CFOTracking, BIT(14) | BIT(13), 1);
-		else
-			PHY_SetBBReg(priv, rOFDM1_CFOTracking, BIT(14) | BIT(13), 2);
-		//cck_disable
-		PHY_SetBBReg(priv, rFPGA0_RFMOD, bCCKEn, 0x0);
-		//TX BB gain shift
-#ifdef RTL8192D_INT_PA
-		if (priv->pshare->rf_ft_var.use_intpa92d){
-			PHY_SetBBReg(priv, rOFDM0_XATxIQImbalance, bMaskDWord, 0x2d4000b5);
-			if (priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY)
-				PHY_SetBBReg(priv, rOFDM0_XBTxIQImbalance, bMaskDWord, 0x2d4000b5);
-		} else
-#endif
-		{
-			PHY_SetBBReg(priv, rOFDM0_XATxIQImbalance, bMaskDWord, 0x20000080);
-			if (priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY)
-				PHY_SetBBReg(priv, rOFDM0_XBTxIQImbalance, bMaskDWord, 0x20000080);
-		}
-		// Reset IQC
-		PHY_SetBBReg(priv, 0xc94, 0xF0000000, 0);
-		if (priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY)
-			PHY_SetBBReg(priv, 0xc9c, 0xF0000000, 0);
-		//BB/DP IQC
-		PHY_SetBBReg(priv, 0xb00, bMaskDWord, 0x010170b8);
-		if (priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY)
-			PHY_SetBBReg(priv, 0xb70, bMaskDWord, 0x010170b8);
-
- 	} else {
-		/*
-		 *	2.4G
-		 */
-		// r_select_5G for path_A/B
-		if (priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY)
-			PHY_SetBBReg(priv, rFPGA0_XAB_RFParameter, BIT(16), 0x0);
-		PHY_SetBBReg(priv, rFPGA0_XAB_RFParameter, BIT(0), 0);
-		//rssi_table_select:index 0 for 2.4G.1~3 for 5G
-		PHY_SetBBReg(priv, rOFDM0_AGCRSSITable, BIT(7) | BIT(6), 0x00);
-		//5G PA power on
-		if (priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY)
-			PHY_SetBBReg(priv, rFPGA0_XAB_RFParameter, BIT(31), 0x0);
-		PHY_SetBBReg(priv, rFPGA0_XAB_RFParameter, BIT(15), 0x0);
-
-		//TRSW.TRSWB and PAPE2G mode table
-		if (priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY){
-			// TRSW_2
-			PHY_SetBBReg(priv, 0x870, BIT(21), (priv->pmib->dot11RFEntry.trsw_pape_C9 & BIT(7))>>7);
-			PHY_SetBBReg(priv, 0x864, BIT(5), (priv->pmib->dot11RFEntry.trsw_pape_C9 & BIT(6))>>6);
-			// TRSWB_2
-			PHY_SetBBReg(priv, 0x870, BIT(22), (priv->pmib->dot11RFEntry.trsw_pape_C9 & BIT(5))>>5);
-			PHY_SetBBReg(priv, 0x864, BIT(6), (priv->pmib->dot11RFEntry.trsw_pape_C9 & BIT(4))>>4);
-			// PAPE2G_2
-			PHY_SetBBReg(priv, 0x870, BIT(26), (priv->pmib->dot11RFEntry.trsw_pape_CC & BIT(3))>>3);
-			PHY_SetBBReg(priv, 0x864, BIT(10), (priv->pmib->dot11RFEntry.trsw_pape_CC & BIT(2))>>2);
-		}
-		// TRSW_1
-		PHY_SetBBReg(priv, 0x870, BIT(5), (priv->pmib->dot11RFEntry.trsw_pape_C9 & BIT(3))>>3);
-		PHY_SetBBReg(priv, 0x860, BIT(5), (priv->pmib->dot11RFEntry.trsw_pape_C9 & BIT(2))>>2);
-		// TRSWB_1
-		PHY_SetBBReg(priv, 0x870, BIT(6), (priv->pmib->dot11RFEntry.trsw_pape_C9 & BIT(1))>>1);
-		PHY_SetBBReg(priv, 0x860, BIT(6), (priv->pmib->dot11RFEntry.trsw_pape_C9 & BIT(0))>>0);
-		// PAPE2G_1
-		PHY_SetBBReg(priv, 0x870, BIT(10), (priv->pmib->dot11RFEntry.trsw_pape_CC & BIT(1))>>1);
-		PHY_SetBBReg(priv, 0x860, BIT(10), (priv->pmib->dot11RFEntry.trsw_pape_CC & BIT(0))>>0);
-
-		// 5G LNA on
-		PHY_SetBBReg(priv, 0xb30, 0x00f00000, 0xa);
-		//fc_area
-		PHY_SetBBReg(priv, rOFDM1_CFOTracking, BIT(14) | BIT(13), 0x00);
-		//cck_enable
-		PHY_SetBBReg(priv, rFPGA0_RFMOD, bCCKEn, 0x1);
-		//TX BB gain shift
-		PHY_SetBBReg(priv, rOFDM0_XATxIQImbalance, bMaskDWord, 0x40000100);
-		if (priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY)
-			PHY_SetBBReg(priv, rOFDM0_XBTxIQImbalance, bMaskDWord, 0x40000100);
-		// Reset IQC
-		PHY_SetBBReg(priv, 0xc94, 0xF0000000, 0);
-		if (priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY)
-			PHY_SetBBReg(priv, 0xc9c, 0xF0000000, 0);
-		//BB/DP IQC
-		PHY_SetBBReg(priv, 0xb00, bMaskDWord, 0x01017038);
-		if (priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY)
-			PHY_SetBBReg(priv, 0xb70, bMaskDWord, 0x01017038);
-	}
-
-	//Update RF
-	if (priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY)
-		curMaxRFPath = RF92CD_PATH_B;
-	else
-		curMaxRFPath = RF92CD_PATH_MAX;
-
-	for(eRFPath = RF92CD_PATH_A; eRFPath <curMaxRFPath; eRFPath++) {
-		if(priv->pmib->dot11RFEntry.phyBandSelect & PHY_BAND_5G) {
-			/*
-			 *	5G
-			 */
-			priv->pshare->RegRF18[eRFPath] &= 0xffffff00;
-			priv->pshare->RegRF18[eRFPath] |= (BIT(16)|BIT(8)|0x24); //set channel 36
-			PHY_SetRFReg(priv,eRFPath, rRfChannel,bMask20Bits, priv->pshare->RegRF18[eRFPath]);
-			delay_ms(1);
-			// LDO_DIV
-			priv->pshare->RegRF28[eRFPath] = RTL_SET_MASK(priv->pshare->RegRF28[eRFPath],BIT(7)|BIT(6),1,6);
-			//PHY_SetRFReg(priv,eRFPath, 0x28, BIT(7)|BIT(6), 0x01);
-			PHY_SetRFReg(priv,eRFPath, 0x28, bMask20Bits, priv->pshare->RegRF28[eRFPath]);
-
-			delay_ms(30);
-		} else {
-			/*
-			 *	2.4G
-			 */
-			priv->pshare->RegRF18[eRFPath] &=  ~(BIT(16)|BIT(8)|0xFF);
-			priv->pshare->RegRF18[eRFPath] |= 1; //set channel 1.
-			PHY_SetRFReg(priv,eRFPath, rRfChannel,bMask20Bits, priv->pshare->RegRF18[eRFPath]);
-			delay_ms(1);
-			// LDO_DIV
-			priv->pshare->RegRF28[eRFPath] &= (~(BIT(7)|BIT(6)));
-			//PHY_SetRFReg(priv,eRFPath, 0x28, BIT(7)|BIT(6), 0x00);
-			PHY_SetRFReg(priv,eRFPath, 0x28, bMask20Bits, priv->pshare->RegRF28[eRFPath]);
-
-			delay_ms(30);
-		}
-	}
-
-#ifdef CONFIG_RTL_92D_DMDP
-	if (priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY) {
-		//Use antenna 0 & 1
-		PHY_SetBBReg(priv, rOFDM0_TRxPathEnable, bMaskByte0, 0x11);
-		PHY_SetBBReg(priv, rOFDM1_TRxPathEnable, bDWord, 0x1);
-
-		//disable ad/da clock1
-		if (!(DMDP_RTL_R8(0,SYS_FUNC_EN)&(FEN_BB_GLB_RST|FEN_BBRSTB))){
-			DMDP_RTL_W8(0, SYS_FUNC_EN, (DMDP_RTL_R8(0,SYS_FUNC_EN)|FEN_BB_GLB_RST|FEN_BBRSTB));
-		}
-		DMDP_PHY_SetBBReg(0, rFPGA0_AdDaClockEn, BIT(13)|BIT(12), 3);
-	} else
-#endif
-	{
-		//Use antenna 0 & 1
-		PHY_SetBBReg(priv, rOFDM0_TRxPathEnable, bMaskByte0, 0x33);
-		PHY_SetBBReg(priv, rOFDM1_TRxPathEnable, bDWord, 0x3);
-
-		//disable ad/da clock1
-		PHY_SetBBReg(priv, rFPGA0_AdDaClockEn, BIT(13) | BIT(12), 0);
-	}
-
-	// TX Beamforming
-	if (priv->pmib->dot11RFEntry.txbf)
-		PHY_SetBBReg(priv, 0x90C, BIT(30), 1);
-	else
-		PHY_SetBBReg(priv, 0x90C, BIT(30), 0);
-
-}
-
-
-#if 0 //def CLIENT_MODE
-void clnt_save_IQK_res(struct rtl8192cd_priv *priv)
-{
-	priv->site_survey.bk_iqc[0] = PHY_QueryBBReg(priv,0xc80, bMaskDWord);
-	priv->site_survey.bk_iqc[1] = PHY_QueryBBReg(priv,0xc94, bMaskByte3);
-	priv->site_survey.bk_iqc[2] = PHY_QueryBBReg(priv,0xc4c, bMaskByte3);
-	priv->site_survey.bk_iqc[3] = PHY_QueryBBReg(priv,0xc88, bMaskDWord);
-	priv->site_survey.bk_iqc[4] = PHY_QueryBBReg(priv,0xc9c, bMaskByte3);
-	priv->site_survey.bk_iqc[5] = PHY_QueryBBReg(priv,0xc14, bMaskDWord);
-	priv->site_survey.bk_iqc[6] = PHY_QueryBBReg(priv,0xca0, bMaskByte3);
-	priv->site_survey.bk_iqc[7] = PHY_QueryBBReg(priv,0xc1c, bMaskDWord);
-	priv->site_survey.bk_iqc[8] = PHY_QueryBBReg(priv,0xc78, bMaskByte1);
-	priv->site_survey.bk_iqc[9] = PHY_QueryRFReg(priv, RF92CD_PATH_A, 0x08, bMask20Bits, 1);
-	priv->site_survey.bk_iqc[10] = PHY_QueryRFReg(priv, RF92CD_PATH_B, 0x08, bMask20Bits, 1);
-}
-
-
-void clnt_load_IQK_res(struct rtl8192cd_priv *priv)
-{
-	PHY_SetBBReg(priv,0xc80, bMaskDWord, priv->site_survey.bk_iqc[0]);
-	PHY_SetBBReg(priv,0xc94, bMaskByte3, priv->site_survey.bk_iqc[1]);
-	PHY_SetBBReg(priv,0xc4c, bMaskByte3, priv->site_survey.bk_iqc[2]);
-	PHY_SetBBReg(priv,0xc88, bMaskDWord, priv->site_survey.bk_iqc[3]);
-	PHY_SetBBReg(priv,0xc9c, bMaskByte3, priv->site_survey.bk_iqc[4]);
-	PHY_SetBBReg(priv,0xc14, bMaskDWord, priv->site_survey.bk_iqc[5]);
-	PHY_SetBBReg(priv,0xca0, bMaskByte3, priv->site_survey.bk_iqc[6]);
-	PHY_SetBBReg(priv,0xc1c, bMaskDWord, priv->site_survey.bk_iqc[7]);
-	PHY_SetBBReg(priv,0xc78, bMaskByte1, priv->site_survey.bk_iqc[8]);
-	PHY_SetRFReg(priv,RF92CD_PATH_A, 0x08, bMask20Bits, priv->site_survey.bk_iqc[9]);
-	PHY_SetRFReg(priv,RF92CD_PATH_B, 0x08, bMask20Bits, priv->site_survey.bk_iqc[10]);
-}
-
-#endif
-
-void IQK_92D_2G(struct rtl8192cd_priv *priv)
-{
-	unsigned int cal_num=0, cal_retry=0, Oldval=0, temp_c04=0, temp_c08=0, temp_874=0, temp_eac;
-	unsigned int cal_e94, cal_e9c, cal_ea4, cal_eac, cal_eb4, cal_ebc, cal_ec4, cal_ecc;
-	unsigned int X, Y, val_e94[3], val_e9c[3], val_ea4[3], val_eac[3], val_eb4[3], val_ebc[3], val_ec4[3], val_ecc[3];
-	unsigned int ADDA_REG[IQK_ADDA_REG_NUM] = {0x85c, 0xe6c, 0xe70, 0xe74,	0xe78, 0xe7c, 0xe80, 0xe84,
-												0xe88, 0xe8c, 0xed0, 0xed4, 0xed8, 0xedc, 0xee0, 0xeec};
-	unsigned int ADDA_backup[IQK_ADDA_REG_NUM], i;
-	u8 temp_522, temp_550, temp_551;
-	u32 temp_040, temp_800, temp_870, temp_860, temp_864, temp_88c;
-	u8 switch2PI = 0;
-
-#ifdef CONFIG_RTL_92D_DMDP
-	if (priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY)
-		return IQK_92D_2G_phy1(priv);
-#endif
-
-	printk(">> %s \n",__FUNCTION__);
-
-	// Save ADDA power saving parameters
-	for( i = 0 ; i < IQK_ADDA_REG_NUM ; i++)
-		ADDA_backup[i] = RTL_R32(ADDA_REG[i]);
-
-	/*
-	 * Save MAC default value
-	 */
-	temp_522 = RTL_R8(0x522);
-	temp_550 = RTL_R8(0x550);
-	temp_551 = RTL_R8(0x551);
-	temp_040 = RTL_R32(0x40);
-
-	// Save BB default
-	temp_800 = RTL_R32(0x800);
-	temp_870 = RTL_R32(0x870);
-	temp_860 = RTL_R32(0x860);
-	temp_864 = RTL_R32(0x864);
-	temp_88c = RTL_R32(0x88c);
-
-	// Path-A ADDA all on
-	for( i = 0 ; i < IQK_ADDA_REG_NUM ; i++)
-		RTL_W32(ADDA_REG[i], 0x04db25a4);
-
-	// IQ&LO calibration Setting
-	//IQK must be done in PI mode
-	if (!PHY_QueryBBReg(priv, 0x820, BIT(8)) || !PHY_QueryBBReg(priv, 0x828, BIT(8))) {
-		PHY_SetBBReg(priv, 0x820, bMaskDWord, 0x01000100);
-		PHY_SetBBReg(priv, 0x828, bMaskDWord, 0x01000100);
-		switch2PI++;
-	}
-
-	//BB setting
-	temp_c04 = RTL_R32(0xc04);
-	temp_c08 = RTL_R32(0xc08);
-	temp_874 = RTL_R32(0x874);
-	PHY_SetBBReg(priv,0x800,BIT(24),0);
-	RTL_W32(0xc04, 0x03a05600);
-	RTL_W32(0xc08, 0x000800e4);
-	RTL_W32(0x874, 0x22204000);
-
-	PHY_SetBBReg(priv, 0x870, BIT(10), 1);
-	PHY_SetBBReg(priv, 0x870, BIT(26), 1);
-	PHY_SetBBReg(priv, 0x860, BIT(10), 0);
-	PHY_SetBBReg(priv, 0x864, BIT(10), 0);
-
-	PHY_SetBBReg(priv,0x88c,0x00f00000,0xf);
-	RTL_W32(0x840, 0x00010000);
-	RTL_W32(0x844, 0x00010000);
-
-	//MAC register setting
-	RTL_W8(0x522, 0x3f);
-	RTL_W8(0x550, RTL_R8(0x550)& (~BIT(3)));
-	RTL_W8(0x551, RTL_R8(0x551)& (~BIT(3)));
-	RTL_W32(0x40, 0);
-
-	//AP or IQK
-	RTL_W32(0xb68 , 0x0f600000);
-	RTL_W32(0xb6c , 0x0f600000);
-
-	// IQK setting
-	RTL_W32(0xe28, 0x80800000);
-	RTL_W32(0xe40, 0x01007c00);
-	RTL_W32(0xe44, 0x01004800);
-	// path-A IQK setting
-	RTL_W32(0xe30, 0x10008c1f);
-	RTL_W32(0xe34, 0x10008c1f);
-	RTL_W32(0xe38, 0x82140102);
-	RTL_W32(0xe3c, 0x28160206);
-	// path-B IQK setting
-	RTL_W32(0xe50, 0x10008c22);
-	RTL_W32(0xe54, 0x10008c22);
-	RTL_W32(0xe58, 0x82140102);
-	RTL_W32(0xe5c, 0x28160206);
-	// LO calibration setting
-	RTL_W32(0xe4c, 0x00462911);
-
-	// delay to ensure Path-A IQK success
-	delay_ms(10);
-
-	// step 4: One shot, path A LOK & IQK
-	while (cal_num < 3) {
-		// One shot, path A LOK & IQK
-		RTL_W32(0xe48, 0xf9000000);
-		RTL_W32(0xe48, 0xf8000000);
-		// delay 1ms
-		delay_ms(1);
-
-		// check fail bit and check abnormal condition, then fill BB IQ matrix
-		cal_e94 = (RTL_R32(0xe94) >> 16) & 0x3ff;
-		cal_e9c = (RTL_R32(0xe9c) >> 16) & 0x3ff;
-		cal_ea4 = (RTL_R32(0xea4) >> 16) & 0x3ff;
-		temp_eac = RTL_R32(0xeac);
-		cal_eac = (temp_eac >> 16) & 0x3ff;
-		if (!(temp_eac & BIT(28)) && !(temp_eac & BIT(27)) &&
-			(cal_e94 != 0x142) && (cal_e9c != 0x42) &&
-			(cal_ea4 != 0x132) && (cal_eac != 0x36)) {
-			val_e94[cal_num] = cal_e94;
-			val_e9c[cal_num] = cal_e9c;
-			val_ea4[cal_num] = cal_ea4;
-			val_eac[cal_num] = cal_eac;
-			cal_num++;
-		} else {
-			if (++cal_retry >= 10) {
-				printk("%s Path-A Check\n",__FUNCTION__);
-				break;
-			}
-		}
-	}
-
-	if (cal_num == 3) {
-		cal_e94 = get_mean_of_2_close_value(val_e94);
-		cal_e9c = get_mean_of_2_close_value(val_e9c);
-		cal_ea4 = get_mean_of_2_close_value(val_ea4);
-		cal_eac = get_mean_of_2_close_value(val_eac);
-
-		priv->pshare->RegE94=cal_e94;
-		priv->pshare->RegE9C=cal_e9c;
-
-		Oldval = (RTL_R32(0xc80) >> 22) & 0x3ff;
-
-		X = cal_e94;
-		PHY_SetBBReg(priv, 0xc80, 0x3ff, (X * Oldval)>>8);
-		PHY_SetBBReg(priv, 0xc4c, BIT(24), ((X * Oldval) >> 7) & 0x1);
-
-		Y = cal_e9c;
-		if ((Y & 0x00000200) != 0)
-			Y = Y | 0xFFFFFC00;
-		PHY_SetBBReg(priv, 0xc94, 0xf0000000, (((Y * Oldval) >> 8) >> 6) & 0xf);
-		PHY_SetBBReg(priv, 0xc80, 0x003f0000, ((Y * Oldval) >> 8) & 0x3f);
-		PHY_SetBBReg(priv, 0xc4c, BIT(26), ((Y * Oldval) >> 7) & 0x1);
-
-		PHY_SetBBReg(priv, 0xc14, 0x3ff, cal_ea4);
-
-		PHY_SetBBReg(priv, 0xc14, 0xfc00, cal_eac & 0x3f);
-
-		PHY_SetBBReg(priv, 0xca0, 0xf0000000, (cal_eac >> 6) & 0xf);
-	}else {
-		priv->pshare->RegE94=0x100;
-		priv->pshare->RegE9C=0x00;
-	}
-
-	// step 5: Path-A standby mode
-	RTL_W32(0xe28, 0);
-	RTL_W32(0x840, 0x00010000);
-	RTL_W32(0xe28, 0x80800000);
-
-	// step 6: Path-B ADDA all on
-	for( i = 0 ; i < IQK_ADDA_REG_NUM ; i++)
-		RTL_W32(ADDA_REG[i], 0x0b1b25a4);
-
-	// step 7: One shot, path B LOK & IQK
-	cal_num = 0;
-	cal_retry = 0;
-	while (cal_num < 3) {
-			// One shot, path B LOK & IQK
-		RTL_W32(0xe60, 2);
-		RTL_W32(0xe60, 0);
-		// delay 1ms
-		delay_ms(1);
-
-		// check fail bit and check abnormal condition, then fill BB IQ matrix
-		cal_eb4 = (RTL_R32(0xeb4) >> 16) & 0x3ff;
-		cal_ebc = (RTL_R32(0xebc) >> 16) & 0x3ff;
-		cal_ec4 = (RTL_R32(0xec4) >> 16) & 0x3ff;
-		cal_ecc = (RTL_R32(0xecc) >> 16) & 0x3ff;
-		temp_eac = RTL_R32(0xeac);
-		if (!(temp_eac & BIT(31)) && !(temp_eac & BIT(30)) &&
-			(cal_eb4 != 0x142) && (cal_ebc != 0x42) &&
-			(cal_ec4 != 0x132) && (cal_ecc != 0x36)) {
-			val_eb4[cal_num] = cal_eb4;
-			val_ebc[cal_num] = cal_ebc;
-			val_ec4[cal_num] = cal_ec4;
-			val_ecc[cal_num] = cal_ecc;
-			cal_num++;
-		} else {
-			if (++cal_retry >= 10) {
-				printk("%s Path-B Check\n",__FUNCTION__);
-				break;
-			}
-		}
-	}
-
-	if (cal_num == 3) {
-		cal_eb4 = get_mean_of_2_close_value(val_eb4);
-		cal_ebc = get_mean_of_2_close_value(val_ebc);
-		cal_ec4 = get_mean_of_2_close_value(val_ec4);
-		cal_ecc = get_mean_of_2_close_value(val_ecc);
-
-		priv->pshare->RegEB4=cal_eb4;
-		priv->pshare->RegEBC=cal_ebc;
-
-		Oldval = (RTL_R32(0xc88) >> 22) & 0x3ff;
-
-		X = cal_eb4;
-		PHY_SetBBReg(priv, 0xc88, 0x3ff, (X * Oldval) >> 8 );
-		PHY_SetBBReg(priv, 0xc4c, BIT(28), ((X * Oldval) >> 7) & 0x1);
-
-		Y = cal_ebc;
-		if ((Y & 0x00000200) != 0)
-			Y = Y | 0xFFFFFC00;
-		PHY_SetBBReg(priv, 0xc9c, 0xf0000000, (((Y * Oldval) >> 8 ) >> 6) & 0xf);
-		PHY_SetBBReg(priv, 0xc88, 0x003f0000, ((Y * Oldval) >> 8 ) & 0x3f);
-		PHY_SetBBReg(priv, 0xc4c, BIT(30), ((Y * Oldval) >> 7) & 0x1);
-
-		PHY_SetBBReg(priv, 0xc1c, 0x3ff, cal_ec4);
-
-		PHY_SetBBReg(priv, 0xc1c, 0xfc00, cal_ecc & 0x3f);
-
-		PHY_SetBBReg(priv, 0xc78, 0xf000, (cal_ecc >> 6) & 0xf);
-	}else {
-		priv->pshare->RegEB4=0x100;
-		priv->pshare->RegEBC=0x00;
-	}
-
-	// step 8: back to BB mode, load original values
-	RTL_W32(0xe28, 0);
-	RTL_W32(0xc04, temp_c04);
-	RTL_W32(0xc08, temp_c08);
-	RTL_W32(0x874, temp_874);
-	RTL_W32(0x800, temp_800);
-	RTL_W32(0x88c, temp_88c);
-	RTL_W32(0x840, 0x32fff);
-	RTL_W32(0x844, 0x32fff);
-	RTL_W32(0x870, temp_870);
-	RTL_W32(0x860, temp_860);
-	RTL_W32(0x864, temp_864);
-
-	/*
-	 *	Switch back to SI if needed, after IQK
-	 */
-	if (switch2PI) {
-		PHY_SetBBReg(priv, 0x820, bMaskDWord, 0x01000000);
-		PHY_SetBBReg(priv, 0x828, bMaskDWord, 0x01000000);
-	}
-
-#if defined(CONFIG_RTL_8198)
-	REG32(BSP_WDTCNR) |=  1 << 23;
-#endif
-
-	/*
-	 *	Reload ADDA power saving parameters
-	 */
-	for(i = 0 ; i < IQK_ADDA_REG_NUM ; i++)
-		PHY_SetBBReg(priv, ADDA_REG[i], bMaskDWord, ADDA_backup[i]);
-
-	/*
-	 *	Reload MAC default value
-	 */
-	RTL_W8(0x550, temp_550);
-	RTL_W8(0x551, temp_551);
-	RTL_W32(0x40, temp_040);
-	RTL_W8(0x522, temp_522);
-
-
-#if 0 //def CLIENT_MODE
-	clnt_save_IQK_res(priv);
-#endif
-
-}
-
-void IQK_92D_5G_n(struct rtl8192cd_priv *priv)
-{
-	unsigned int temp_800, temp_c04, temp_874, temp_c08, temp_870,
-				temp_860, temp_864, temp_88c, temp_c50, temp_c58, temp_b30,
-				switch2PI=0, X, reg; //Oldval_0, Oldval_1, TX0_A, TX1_A;
-	u8 temp_522, temp_550, temp_551;
-	unsigned int cal_num=0, cal_retry=0, ADDA_backup[IQK_ADDA_REG_NUM];
-	int Y, result[8][3], result_final[8]; //TX0_C, TX1_C;
-
-	unsigned int i, RX0REG0xe40[3], RX0REG0xe40_final=0, REG0xe40, REG0xe94, REG0xe9c;
-	unsigned int REG0xeac, RX1REG0xe40[3], RX1REG0xe40_final=0, REG0xeb4, REG0xea4,REG0xec4;
-	unsigned char TX0IQKOK = FALSE, TX1IQKOK = FALSE;
-	unsigned int TX_X0, TX_Y0, TX_X1, TX_Y1, RX_X0, RX_Y0, RX_X1, RX_Y1;
-	unsigned int ADDA_REG[IQK_ADDA_REG_NUM] = {0x85c, 0xe6c, 0xe70, 0xe74,	0xe78, 0xe7c, 0xe80, 0xe84,
-												0xe88, 0xe8c, 0xed0, 0xed4, 0xed8, 0xedc, 0xee0, 0xeec};
-#ifdef CONFIG_RTL_92D_DMDP
-	if (priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY)
-		return IQK_92D_5G_phy0_n(priv);
-#endif
-
-	printk(">> %s \n",__FUNCTION__);
-#ifdef CONFIG_RTL_8198
-	REG32(BSP_WDTCNR) |=  1 << 23;
-#endif
-	/*
-	 * Save MAC default value
-	 */
-	temp_522 = RTL_R8(0x522);
-	temp_550 = RTL_R8(0x550);
-	temp_551 = RTL_R8(0x551);
-
-	/*
-	 *	Save BB Parameter
-	 */
-	temp_800 = RTL_R32(0x800);
-	temp_c04 = RTL_R32(0xc04);
-	temp_874 = RTL_R32(0x874);
-	temp_c08 = RTL_R32(0xc08);
-	temp_870 = RTL_R32(0x870);
-	temp_860 = RTL_R32(0x860);
-	temp_864 = RTL_R32(0x864);
-	temp_88c = RTL_R32(0x88c);
-	temp_c50 = RTL_R32(0xc50);	// 01/11/2011 update
-	temp_c58 = RTL_R32(0xc58);	// 01/11/2011 update
-	temp_b30 = RTL_R32(0xb30);	// 03/03/2011 update
-
-	/*
-	*	Save AFE Parameters
-	*/
-	for( i = 0 ; i < IQK_ADDA_REG_NUM ; i++)
-		ADDA_backup[i] = RTL_R32(ADDA_REG[i]);
-
-	/*
-	 *	==============
-	 *	Path-A TX/RX IQK
-	 *	==============
-	 */
-	while (cal_num < 3) {
-		/*
-		 *	Path-A AFE all on
-		 */
-		for( i = 0 ; i < IQK_ADDA_REG_NUM ; i++)
-			RTL_W32(ADDA_REG[i], 0x04db25a4);
-
-		/*
-		 *	MAC register setting
-		 */
-		RTL_W8(0x522, 0x3f);
-		RTL_W8(0x550, RTL_R8(0x550)& (~BIT(3)));
-		RTL_W8(0x551, RTL_R8(0x551)& (~BIT(3)));
-
-		/*
-		 *	IQK must be done in PI mode
-		 */
-		if (!PHY_QueryBBReg(priv, 0x820, BIT(8)) || !PHY_QueryBBReg(priv, 0x828, BIT(8))) {
-			PHY_SetBBReg(priv, 0x820, bMaskDWord, 0x01000100);
-			PHY_SetBBReg(priv, 0x828, bMaskDWord, 0x01000100);
-			switch2PI++;
-		}
-
-		/*
-		 *	BB setting
-		 */
-		PHY_SetBBReg(priv, 0x800, BIT(24), 0);
-		PHY_SetBBReg(priv, 0xc04, bMaskDWord, 0x03a05600);
-		PHY_SetBBReg(priv, 0xc08, bMaskDWord, 0x000800e4);
-		PHY_SetBBReg(priv, 0x874, bMaskDWord, 0x22208000);
-		PHY_SetBBReg(priv, 0x88c, BIT(23)|BIT(22)|BIT(21)|BIT(20), 0xf);
-		PHY_SetBBReg(priv, 0xb30, bMaskDWord, 0x00a00000);	// 03/03/2011 update
-
-		/*
-		 *	AP or IQK
-		 */
-		//PHY_SetBBReg(priv, 0xb68, bMaskDWord, 0x0f600000);
-		//PHY_SetBBReg(priv, 0xb6c, bMaskDWord, 0x0f600000);
-
-		// IQK-R03 2011/02/16 update
-
-		//path A AP setting for IQK
-		PHY_SetBBReg(priv, 0xb00, bMaskDWord, 0);
-		PHY_SetBBReg(priv, 0xb68, bMaskDWord, 0x20000000);
-		//path B AP setting for IQK
-		PHY_SetBBReg(priv, 0xb70, bMaskDWord, 0);
-		PHY_SetBBReg(priv, 0xb6c, bMaskDWord, 0x20000000);
-
-		/*
-		 *	IQK global setting
-		 */
-		PHY_SetBBReg(priv, 0xe28, bMaskDWord, 0x80800000);
-		PHY_SetBBReg(priv, 0xe40, bMaskDWord, 0x10007c00);
-		PHY_SetBBReg(priv, 0xe44, bMaskDWord, 0x01004800);
-
-		/*
-		 *	path-A IQK setting
-		 */
-		PHY_SetBBReg(priv, 0xe30, bMaskDWord, 0x18008c1f);
-		PHY_SetBBReg(priv, 0xe34, bMaskDWord, 0x18008c1f);
-		PHY_SetBBReg(priv, 0xe38, bMaskDWord, 0x82140307);	// 01/11/2011 update
-#ifdef USB_POWER_SUPPORT
-		PHY_SetBBReg(priv, 0xe3c, bMaskDWord, 0x68160c66);
-#else
-		PHY_SetBBReg(priv, 0xe3c, bMaskDWord, 0x68160960);	// 01/11/2011 update
-#endif
-
-		/*
-		 *	path-B IQK setting
-		 */
-		PHY_SetBBReg(priv, 0xe50, bMaskDWord, 0x18008c2f);
-		PHY_SetBBReg(priv, 0xe54, bMaskDWord, 0x18008c2f);
-		PHY_SetBBReg(priv, 0xe58, bMaskDWord, 0x82110000);
-		PHY_SetBBReg(priv, 0xe5c, bMaskDWord, 0x68110000);
-
-		/*
-		 *	LO calibration setting
-		 */
-		PHY_SetBBReg(priv, 0xe4c, bMaskDWord, 0x00462911);
-
-#ifdef USB_POWER_SUPPORT
-		//	path-A TRSW setting
-		PHY_SetBBReg(priv, 0x870, BIT(6)|BIT(5), 3);
-		PHY_SetBBReg(priv, 0x860, BIT(6)|BIT(5), 3);
-#else
-		/*
-		 *	path-A PA on
-		 */
-		/*
-		PHY_SetBBReg(priv, 0x870, BIT(11)|BIT(10), 3);
-		PHY_SetBBReg(priv, 0x870, BIT(6)|BIT(5), 3);
-		PHY_SetBBReg(priv, 0x860, BIT(11)|BIT(10), 3);
-		 */
-		PHY_SetBBReg(priv, 0x870, bMaskDWord, 0x07000f60);	// 01/11/2011 update
-		PHY_SetBBReg(priv, 0x860, bMaskDWord, 0x66e60e30);	// 01/11/2011 update
-#endif
-		/*
-		 *	One shot, path A LOK & IQK
-		 */
-		PHY_SetBBReg(priv, 0xe48, bMaskDWord, 0xf9000000);
-		PHY_SetBBReg(priv, 0xe48, bMaskDWord, 0xf8000000);
-
-		/*
-		 *	Delay 10 ms
-		 */
-		delay_ms(10);
-		/*
-		 *	Check_TX_IQK_A_result
-		 */
-		REG0xe40 = PHY_QueryBBReg(priv, 0xe40, bMaskDWord);
-		REG0xeac = PHY_QueryBBReg(priv, 0xeac, bMaskDWord);
-		REG0xe94 = PHY_QueryBBReg(priv, 0xe94, bMaskDWord);
-		if(((REG0xeac&BIT(28)) == 0) && (((REG0xe94&0x3FF0000)>>16)!=0x142)) {
-			TX0IQKOK = TRUE;
-			REG0xe9c = PHY_QueryBBReg(priv, 0xe9c, bMaskDWord);
-			TX_X0 = (PHY_QueryBBReg(priv, 0xe94, bMaskDWord)&0x3FF0000)>>16;
-			TX_Y0 = (PHY_QueryBBReg(priv, 0xe9c, bMaskDWord)&0x3FF0000)>>16;
-			RX0REG0xe40[cal_num] =	(REG0xe40 & 0xfc00fc00) | (TX_X0<<16) | TX_Y0;
-			DEBUG_INFO("TX_X0 %08x TX_Y0 %08x RX0REG0xe40 %08x\n", TX_X0, TX_Y0, RX0REG0xe40[cal_num]);
-			result[0][cal_num] = TX_X0;
-			result[1][cal_num] = TX_Y0;
-		} else {
-			TX0IQKOK = FALSE;
-			if (++cal_retry >= 10) {
-				printk("%s Path-A Tx/Rx Check\n",__FUNCTION__);
-				break;
-			}
-		}
-
-		/*
-		 *	Check_RX_IQK_A_result
-		 */
-		if(TX0IQKOK == TRUE) {
-			REG0xeac = PHY_QueryBBReg(priv, 0xeac, bMaskDWord);
-			REG0xea4 = PHY_QueryBBReg(priv, 0xea4, bMaskDWord);
-			if(((REG0xeac&BIT(27)) == 0) && (((REG0xea4&0x3FF0000)>>16)!=0x132)) {
-				RX_X0 =  (PHY_QueryBBReg(priv, 0xea4, bMaskDWord)&0x3FF0000)>>16;
-				RX_Y0 =  (PHY_QueryBBReg(priv, 0xeac, bMaskDWord)&0x3FF0000)>>16;
-				DEBUG_INFO("RX_X0 %08x RX_Y0 %08x\n", RX_X0, RX_Y0);
-				result[2][cal_num] = RX_X0;
-				result[3][cal_num] = RX_Y0;
-				cal_num++;
-			} else {
-				if (++cal_retry >= 10) {
-					printk("%s Path-A Tx/Rx Check\n",__FUNCTION__);
-					break;
-				}
-			}
-		}
-	}
-
-	if (cal_num == 3) {
-		result_final[0] = get_mean_of_2_close_value(result[0]);
-		result_final[1] = get_mean_of_2_close_value(result[1]);
-		result_final[2] = get_mean_of_2_close_value(result[2]);
-		result_final[3] = get_mean_of_2_close_value(result[3]);
-		RX0REG0xe40_final = 0x80000000 | get_mean_of_2_close_value(RX0REG0xe40);
-
-		priv->pshare->RegE94=result_final[0];
-		priv->pshare->RegE9C=result_final[1];
-	} else {
-		priv->pshare->RegE94=0x100;
-		priv->pshare->RegE9C=0x00;
-	}
-
-	/*
-	 *	Path-A PA off
-	 */
-	PHY_SetBBReg(priv, 0x870, bMaskDWord, temp_870);
-	PHY_SetBBReg(priv, 0x860, bMaskDWord, temp_860);
-
-
-	/*
-	 *	==============
-	 *	Path-B TX/RX IQK
-	 *	==============
-	 */
-	cal_num = cal_retry = 0;
-	while (cal_num < 3) {
-		/*
-		 *	Path-B AFE all on
-		 */
-		for( i = 0 ; i < IQK_ADDA_REG_NUM ; i++)
-			PHY_SetBBReg(priv, ADDA_REG[i], bMaskDWord, 0x0b1b25a4);
-
-		/*
-		 *	path-A IQK setting
-		 */
-		PHY_SetBBReg(priv, 0xe30, bMaskDWord, 0x18008c1f);
-		PHY_SetBBReg(priv, 0xe34, bMaskDWord, 0x18008c1f);
-		PHY_SetBBReg(priv, 0xe38, bMaskDWord, 0x82110000);
-		PHY_SetBBReg(priv, 0xe3c, bMaskDWord, 0x68110000);
-
-		/*
-		 *	path-B IQK setting
-		 */
-		PHY_SetBBReg(priv, 0xe50, bMaskDWord, 0x18008c22);
-		PHY_SetBBReg(priv, 0xe54, bMaskDWord, 0x18008c22);
-		PHY_SetBBReg(priv, 0xe58, bMaskDWord, 0x82140307);	// 01/11/2011 update
-
-		// 01/11/2011 update
-#ifdef USB_POWER_SUPPORT
-		PHY_SetBBReg(priv, 0xe5c, bMaskDWord, 0x68160c66);
-#else
-		PHY_SetBBReg(priv, 0xe5c, bMaskDWord, 0x68160960);	// 01/11/2011 update
-#endif
-
-		/*
-		 *	LO calibration setting
-		 */
-		PHY_SetBBReg(priv, 0xe4c, bMaskDWord, 0x00462911);
-
-#ifdef USB_POWER_SUPPORT
-		PHY_SetBBReg(priv, 0x870, BIT(22)|BIT(21), 3);
-		PHY_SetBBReg(priv, 0x864, BIT(6)|BIT(5), 3);
-#else
-		/*
-		 *	path-B PA on
-		 */
-		/*
-		PHY_SetBBReg(priv, 0x870, BIT(27)|BIT(26), 3);
-		PHY_SetBBReg(priv, 0x870, BIT(22)|BIT(21), 3);
-		PHY_SetBBReg(priv, 0x864, BIT(11)|BIT(10), 3);
-		*/
-		PHY_SetBBReg(priv, 0x870, bMaskDWord, 0x0f600700);
-		PHY_SetBBReg(priv, 0x864, bMaskDWord, 0x061f0d30);
-#endif
-
-		/*
-		 *	One shot, path A LOK & IQK
-		 */
-		PHY_SetBBReg(priv, 0xe60, bMaskDWord, 0x00000002);
-		PHY_SetBBReg(priv, 0xe60, bMaskDWord, 0x00000000);
-
-		/*
-		 *	Delay 10 ms
-		 */
-		delay_ms(10);
-
-		/*
-		 *	Check_TX_IQK_B_result
-		 */
-		REG0xe40 = PHY_QueryBBReg(priv, 0xe40, bMaskDWord);
-		REG0xeac = PHY_QueryBBReg(priv, 0xeac, bMaskDWord);
-		REG0xeb4 = PHY_QueryBBReg(priv, 0xeb4, bMaskDWord);
-		if(((REG0xeac&BIT(31)) == 0) && ((REG0xeb4&0x3FF0000)!=0x142)) {
-			TX1IQKOK = TRUE;
-			TX_X1 = (PHY_QueryBBReg(priv, 0xeb4, bMaskDWord)&0x3FF0000)>>16;
-			TX_Y1 = (PHY_QueryBBReg(priv, 0xebc, bMaskDWord)&0x3FF0000)>>16;
-			RX1REG0xe40[cal_num] = (REG0xe40 & 0xfc00fc00) | (TX_X1<<16) | TX_Y1;
-			DEBUG_INFO("TX_X1 %08x TX_Y1 %08x RX1REG0xe40 %08x\n", TX_X1, TX_Y1, RX1REG0xe40[cal_num]);
-			result[4][cal_num] = TX_X1;
-			result[5][cal_num] = TX_Y1;
-		} else {
-			TX1IQKOK = FALSE;
-			if (++cal_retry >= 10) {
-				printk("%s Path-B Tx/Rx Check\n",__FUNCTION__);
-				break;
-			}
-		}
-
-		/*
-		 *	Check_RX_IQK_B_result
-		 */
-		if(TX1IQKOK == TRUE) {
-			REG0xeac = PHY_QueryBBReg(priv, 0xeac, bMaskDWord);
-			REG0xec4 = PHY_QueryBBReg(priv, 0xec4, bMaskDWord);
-			if(((REG0xeac&BIT(30)) == 0) && (((REG0xec4&0x3FF0000)>>16)!=0x132)) {
-				RX_X1 =  (PHY_QueryBBReg(priv, 0xec4, bMaskDWord)&0x3FF0000)>>16;
-				RX_Y1 =  (PHY_QueryBBReg(priv, 0xecc, bMaskDWord)&0x3FF0000)>>16;
-				DEBUG_INFO("RX_X1 %08x RX_Y1 %08x\n", RX_X1, RX_Y1);
-				result[6][cal_num] = RX_X1;
-				result[7][cal_num] = RX_Y1;
-				cal_num++;
-			} else {
-				if (++cal_retry >= 10) {
-					printk("%s Path-B Tx/Rx Check\n",__FUNCTION__);
-					break;
-				}
-			}
-		}
-	}
-
-	if (cal_num == 3) {
-		result_final[4] = get_mean_of_2_close_value(result[4]);
-		result_final[5] = get_mean_of_2_close_value(result[5]);
-		result_final[6] = get_mean_of_2_close_value(result[6]);
-		result_final[7] = get_mean_of_2_close_value(result[7]);
-		RX1REG0xe40_final = 0x80000000 | get_mean_of_2_close_value(RX1REG0xe40);
-
-		priv->pshare->RegEB4=result_final[4];
-		priv->pshare->RegEBC=result_final[5];
-	} else {
-		priv->pshare->RegEB4=0x100;
-		priv->pshare->RegEBC=0x00;
-	}
-
-	/*
-	 *	Fill IQK result for Path A
-	 */
-	if (result_final[0]) {
-		/*
-		Oldval_0 = (PHY_QueryBBReg(priv, 0xc80, bMaskDWord) >> 22) & 0x3FF;
-		X = result_final[0];
-		if ((X & 0x00000200) != 0)
-			X = X | 0xFFFFFC00;
-		TX0_A = (X * Oldval_0) >> 8;
-		PHY_SetBBReg(priv, 0xc80, 0x3FF, TX0_A);
-		PHY_SetBBReg(priv, 0xc4c, BIT(24), ((X* Oldval_0>>7) & 0x1));
-
-		Y = result_final[1];
-		if ((Y & 0x00000200) != 0)
-			Y = Y | 0xFFFFFC00;
-		TX0_C = (Y * Oldval_0) >> 8;
-		PHY_SetBBReg(priv, 0xc94, 0xF0000000, ((TX0_C&0x3C0)>>6));
-		PHY_SetBBReg(priv, 0xc80, 0x003F0000, (TX0_C&0x3F));
-		PHY_SetBBReg(priv, 0xc4c, BIT(26), ((Y* Oldval_0>>7) & 0x1));
-		*/
-
-		// IQK-R03 2011/02/16 update
-		X = result_final[0];
-		Y = result_final[1];
-		//printk("X=%x Y=%x\n",X,Y);
-		//Path-A OFDM_A
-		PHY_SetBBReg(priv, 0xe30, 0x03FF0000, X);
-		PHY_SetBBReg(priv, 0xc4c, BIT(24), 0);
-		//Path-A OFDM_C
-		PHY_SetBBReg(priv, 0xe30, 0x000003FF, Y);
-		PHY_SetBBReg(priv, 0xc4c, BIT(26), 0);
-
-		if(result_final[2]) {
-			reg = result_final[2];
-			PHY_SetBBReg(priv, 0xc14, 0x3FF, reg);
-
-			reg = result_final[3] & 0x3F;
-			PHY_SetBBReg(priv, 0xc14, 0xFC00, reg);
-
-			reg = (result_final[3] >> 6) & 0xF;
-			PHY_SetBBReg(priv, 0xca0, 0xF0000000, reg);
-		}
-	}
-
-	/*
-	 *	Fill IQK result for Path B
-	 */
-	if (result_final[4]) {
-		/*
-		Oldval_1 = (PHY_QueryBBReg(priv, 0xc88, bMaskDWord) >> 22) & 0x3FF;
-
-		X = result_final[4];
-		if ((X & 0x00000200) != 0)
-			X = X | 0xFFFFFC00;
-		TX1_A = (X * Oldval_1) >> 8;
-		PHY_SetBBReg(priv, 0xc88, 0x3FF, TX1_A);
-		PHY_SetBBReg(priv, 0xc4c, BIT(28), ((X* Oldval_1>>7) & 0x1));
-
-		Y = result_final[5];
-		if ((Y & 0x00000200) != 0)
-			Y = Y | 0xFFFFFC00;
-		TX1_C = (Y * Oldval_1) >> 8;
-		PHY_SetBBReg(priv, 0xc9c, 0xF0000000, ((TX1_C&0x3C0)>>6));
-		PHY_SetBBReg(priv, 0xc88, 0x003F0000, (TX1_C&0x3F));
-		PHY_SetBBReg(priv, 0xc4c, BIT(30), ((Y* Oldval_1>>7) & 0x1));
-		*/
-
-		// IQK-R03 2011/02/16 update
-		X = result_final[4];
-		Y = result_final[5];
-		//printk("X=%x Y=%x\n",X,Y);
-		//Path-A OFDM_A
-		PHY_SetBBReg(priv, 0xe50, 0x03FF0000, X);
-		PHY_SetBBReg(priv, 0xc4c, BIT(28), 0);
-		//Path-A OFDM_C
-		PHY_SetBBReg(priv, 0xe50, 0x000003FF, Y);
-		PHY_SetBBReg(priv, 0xc4c, BIT(30), 0);
-
-		if(result_final[6]) {
-			reg = result_final[6];
-			PHY_SetBBReg(priv, 0xc1c, 0x3FF, reg);
-
-			reg = result_final[7] & 0x3F;
-			PHY_SetBBReg(priv, 0xc1c, 0xFC00, reg);
-
-			reg = (result_final[7] >> 6) & 0xF;
-			PHY_SetBBReg(priv, 0xc78, 0x0000F000, reg);
-		}
-	}
-
-	/*
-	 *	Path B PA off
-	 */
-	PHY_SetBBReg(priv, 0x870, bMaskDWord, temp_870);
-	PHY_SetBBReg(priv, 0x864, bMaskDWord, temp_864);
-
-	/*
-	 *	Exit IQK mode
-	 */
-	PHY_SetBBReg(priv, 0xe28, bMaskDWord, 0);
-	PHY_SetBBReg(priv, 0xc04, bMaskDWord, temp_c04);
-	PHY_SetBBReg(priv, 0xc08, bMaskDWord, temp_c08);
-	PHY_SetBBReg(priv, 0x874, bMaskDWord, temp_874);
-	PHY_SetBBReg(priv, 0x800, bMaskDWord, temp_800);
-	PHY_SetBBReg(priv, 0x88c, bMaskDWord, temp_88c);
-	PHY_SetBBReg(priv, 0xb30, bMaskDWord, temp_b30);	// 03/03/2011 update
-	//PHY_SetBBReg(priv, 0x840, bMaskDWord, 0x00032fff);		// 01/11/2011 update
-	//PHY_SetBBReg(priv, 0x844, bMaskDWord, 0x00032fff);		// 01/11/2011 update
-
-	// IQK-R03 2011/02/16 update
-	//path A IQ path to DP block
-	PHY_SetBBReg(priv, 0xb00, bMaskDWord, 0x010170b8);
-	//path B IQ path to DP block
-	PHY_SetBBReg(priv, 0xb70, bMaskDWord, 0x010170b8);
-
-	//path AB to initial gain
-	PHY_SetBBReg(priv, 0xc50, bMaskDWord, 0x50);		// 01/11/2011 update
-	PHY_SetBBReg(priv, 0xc50, bMaskDWord, temp_c50);	// 01/11/2011 update
-	PHY_SetBBReg(priv, 0xc58, bMaskDWord, 0x50);		// 01/11/2011 update
-	PHY_SetBBReg(priv, 0xc58, bMaskDWord, temp_c58);	// 01/11/2011 update
-
-
-	/*
-	 *	Reload MAC default value
-	 */
-	RTL_W8(0x550, temp_550);
-	RTL_W8(0x551, temp_551);
-	RTL_W8(0x522, temp_522);
-
-	/*
-	 *	Switch back to SI if needed, after IQK
-	 */
-	if (switch2PI) {
-		PHY_SetBBReg(priv, 0x820, bMaskDWord, 0x01000000);
-		PHY_SetBBReg(priv, 0x828, bMaskDWord, 0x01000000);
-	}
-
-	/*
-	 *	Reload ADDA power saving parameters
-	 */
-	for(i = 0 ; i < IQK_ADDA_REG_NUM ; i++)
-		PHY_SetBBReg(priv, ADDA_REG[i], bMaskDWord, ADDA_backup[i]);
-
-
-#if 0 //def CLIENT_MODE
-		clnt_save_IQK_res(priv);
-#endif
-
-
-}
-
-
-void getDeltaValue(struct rtl8192cd_priv *priv)
-{
-	unsigned int tempval[2];
-
-	tempval[0] = priv->pmib->dot11RFEntry.deltaIQK;
-	tempval[1] = priv->pmib->dot11RFEntry.deltaLCK;
-
-	switch(tempval[0])
-	{
-		case 0:
-			tempval[0] = 5;
-			break;
-
-		case 1:
-			tempval[0] = 4;
-			break;
-
-		case 2:
-			tempval[0] = 3;
-			break;
-
-		case 3:
-		default:
-			tempval[0] = 0;
-			break;
-	}
-
-	switch(tempval[1])
-	{
-		case 0:
-			tempval[1] = 4;
-			break;
-
-		case 1:
-			tempval[1] = 3;
-			break;
-
-		case 2:
-			tempval[1] = 2;
-			break;
-
-		case 3:
-		default:
-			tempval[1] = 0;
-			break;
-	}
-
-	priv->pshare->Delta_IQK = tempval[0];
-	priv->pshare->Delta_LCK = tempval[1];
-}
-
-
-#ifdef SW_LCK_92D
-
-#define TARGET_CHNL_NUM_5G 221
-#define TARGET_CHNL_NUM_2G 14
-#define CV_CURVE_CNT 64
-
-unsigned int CurveIndex_5G[TARGET_CHNL_NUM_5G]={0};
-unsigned int CurveIndex_2G[TARGET_CHNL_NUM_2G]={0};
-
-static unsigned int TargetChnl_5G[TARGET_CHNL_NUM_5G] = {
-25141,	25116,	25091,	25066,	25041,
-25016,	24991,	24966,	24941,	24917,
-24892,	24867,	24843,	24818,	24794,
-24770,	24765,	24721,	24697,	24672,
-24648,	24624,	24600,	24576,	24552,
-24528,	24504,	24480,	24457,	24433,
-24409,	24385,	24362,	24338,	24315,
-24291,	24268,	24245,	24221,	24198,
-24175,	24151,	24128,	24105,	24082,
-24059,	24036,	24013,	23990,	23967,
-23945,	23922,	23899,	23876,	23854,
-23831,	23809,	23786,	23764,	23741,
-23719,	23697,	23674,	23652,	23630,
-23608,	23586,	23564,	23541,	23519,
-23498,	23476,	23454,	23432,	23410,
-23388,	23367,	23345,	23323,	23302,
-23280,	23259,	23237,	23216,	23194,
-23173,	23152,	23130,	23109,	23088,
-23067,	23046,	23025,	23003,	22982,
-22962,	22941,	22920,	22899,	22878,
-22857,	22837,	22816,	22795,	22775,
-22754,	22733,	22713,	22692,	22672,
-22652,	22631,	22611,	22591,	22570,
-22550,	22530,	22510,	22490,	22469,
-22449,	22429,	22409,	22390,	22370,
-22350,	22336,	22310,	22290,	22271,
-22251,	22231,	22212,	22192,	22173,
-22153,	22134,	22114,	22095,	22075,
-22056,	22037,	22017,	21998,	21979,
-21960,	21941,	21921,	21902,	21883,
-21864,	21845,	21826,	21807,	21789,
-21770,	21751,	21732,	21713,	21695,
-21676,	21657,	21639,	21620,	21602,
-21583,	21565,	21546,	21528,	21509,
-21491,	21473,	21454,	21436,	21418,
-21400,	21381,	21363,	21345,	21327,
-21309,	21291,	21273,	21255,	21237,
-21219,	21201,	21183,	21166,	21148,
-21130,	21112,	21095,	21077,	21059,
-21042,	21024,	21007,	20989,	20972,
-25679,	25653,	25627,	25601,	25575,
-25549,	25523,	25497,	25471,	25446,
-25420,	25394,	25369,	25343,	25318,
-25292,	25267,	25242,	25216,	25191,
-25166	};
-
-static unsigned int TargetChnl_2G[TARGET_CHNL_NUM_2G] = {	// channel 1~14
-26084, 26030, 25976, 25923, 25869, 25816, 25764,
-25711, 25658, 25606, 25554, 25502, 25451, 25328
-};
-
-void _PHY_CalcCurvIndex(struct rtl8192cd_priv *priv, unsigned int *TargetChnl,
-								unsigned int *CurveCountVal, char is5G,  unsigned int *CurveIndex)
-{
-	unsigned int	smallestABSVal = 0xffffffff, u4tmp;
-	unsigned char	i, j;
-	unsigned char	chnl_num = is5G?(TARGET_CHNL_NUM_5G) : (TARGET_CHNL_NUM_2G);
-
-
-	for(i=0; i<chnl_num; i++)
-	{
-		//if(is5G && !IsLegal5GChannel(pAdapter, i+1))
-			//continue;
-
-		CurveIndex[i] = 0;
-		for(j=0; j<(CV_CURVE_CNT*2); j++)
-		{
-			u4tmp = RTL_ABS(TargetChnl[i], CurveCountVal[j]);
-			//if (i==115)
-				//printk("cv[%d]=%x\n", j, u4tmp);
-			if(u4tmp < smallestABSVal)
-			{
-				CurveIndex[i] = j;
-				smallestABSVal = u4tmp;
-			}
-		}
-
-		smallestABSVal = 0xffffffff;
-	}
-}
-
-void phy_ReloadLCKSetting(struct rtl8192cd_priv *priv)
-{
-	unsigned int	eRFPath = priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_5G? RF92CD_PATH_A:(priv->pmib->dot11RFEntry.macPhyMode==SINGLEMAC_SINGLEPHY?RF92CD_PATH_B:RF92CD_PATH_A);
-	unsigned int 	u4tmp = 0;
-//	unsigned char	bNeedPowerDownRadio = FALSE;
-	unsigned int 	channel = priv->pshare->RegRF18[eRFPath]&0xff;
-	//unsigned int 	channel =  PHY_QueryRFReg(priv, eRFPath, rRfChannel, 0xff, 1);
-
-	DEBUG_INFO("====>phy_ReloadLCKSetting interface %d path %d ch %d [0x%05x]\n", priv->pshare->wlandev_idx, eRFPath, channel, priv->pshare->RegRF28[eRFPath]);
-
-	//only for 92D C-cut SMSP
-#if 1
-	if(GET_CHIP_VER(priv)!=VERSION_8192D || IS_TEST_CHIP(priv))
-		return;
-#endif
-
-	if(priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_5G)
-	{
-		//Path-A for 5G
-		u4tmp = CurveIndex_5G[channel-1];
-		//printk("%s ver 1 set RF-A, 5G,	0x28 = 0x%x !!\n",__FUNCTION__, u4tmp);
-#ifdef CONFIG_RTL_92D_DMDP
-		if(priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY && priv->pshare->wlandev_idx == 1)
-		{
-			priv->pshare->RegRF28[RF92CD_PATH_A] = RTL_SET_MASK(priv->pshare->RegRF28[RF92CD_PATH_A],0x3f800,u4tmp,11);	 //DMDP_PHY_SetRFReg(0,  RF92CD_PATH_A, 0x28, 0x3f800, u4tmp);
-			DMDP_PHY_SetRFReg(0,  RF92CD_PATH_A, 0x28, bMask20Bits, priv->pshare->RegRF28[RF92CD_PATH_A]);
-		}else
-#endif
-		{
-			priv->pshare->RegRF28[eRFPath] = RTL_SET_MASK(priv->pshare->RegRF28[eRFPath],0x3f800,u4tmp,11);	//PHY_SetRFReg(priv, eRFPath, 0x28, 0x3f800, u4tmp);
-			PHY_SetRFReg(priv, eRFPath, 0x28, bMask20Bits, priv->pshare->RegRF28[eRFPath]);
-		}
-		DEBUG_INFO("%s ver 3 set RF-B, 2G, 0x28 = 0x%05x [0x%05x]!!\n", __FUNCTION__, PHY_QueryRFReg(priv, eRFPath, 0x28, bMask20Bits, 1), priv->pshare->RegRF28[eRFPath]);
-	}
-	else if(priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_2G)
-	{
-		u4tmp = CurveIndex_2G[channel-1];
-		//printk("%s ver 3 set RF-B, 2G, 0x28 = 0x%x !!\n", __FUNCTION__, u4tmp);
-#ifdef CONFIG_RTL_92D_DMDP
-		if(priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY && priv->pshare->wlandev_idx == 0)
-		{
-			priv->pshare->RegRF28[RF92CD_PATH_A] = RTL_SET_MASK(priv->pshare->RegRF28[RF92CD_PATH_A],0x3f800,u4tmp,11);	 //DMDP_PHY_SetRFReg(1,  RF92CD_PATH_A, 0x28, 0x3f800, u4tmp);
-			DMDP_PHY_SetRFReg(1,  RF92CD_PATH_A, 0x28, bMask20Bits, priv->pshare->RegRF28[RF92CD_PATH_A]);
-		}else
-#endif
-		{
-			priv->pshare->RegRF28[eRFPath] = RTL_SET_MASK(priv->pshare->RegRF28[eRFPath],0x3f800,u4tmp,11); // PHY_SetRFReg(priv, eRFPath, 0x28, 0x3f800, u4tmp);
-			PHY_SetRFReg(priv, eRFPath, 0x28, bMask20Bits, priv->pshare->RegRF28[eRFPath]);
-		}
-		DEBUG_INFO("%s ver 3 set RF-B, 2G, 0x28 = 0x%05x [0x%05x]!!\n", __FUNCTION__, PHY_QueryRFReg(priv, eRFPath, 0x28, bMask20Bits, 1), priv->pshare->RegRF28[eRFPath]);
-	}
-
-}
-
-/* Software LCK */
-void PHY_LCCalibrate_92D(struct rtl8192cd_priv *priv)
-{
-	unsigned char	tmpReg;
-	unsigned int 	RF_mode[2];
-	unsigned int	eRFPath, curMaxRFPath;
-	unsigned int	i;
-	unsigned int	curveCountVal[CV_CURVE_CNT*2]={0};
-	unsigned short	timeout = 800, timecount = 0;
-
-	if (priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY)
-		curMaxRFPath = RF92CD_PATH_B;
-	else
-		curMaxRFPath = RF92CD_PATH_MAX;
-
-	//Check continuous TX and Packet TX
-	tmpReg = RTL_R8(0xd03);
-
-	if ((tmpReg & 0x70) != 0)				// Deal with contisuous TX case
-		RTL_W8(0xd03, tmpReg&0x8F);	// disable all continuous TX
-	else									// Deal with Packet TX case
-		RTL_W8(TXPAUSE, 0xFF);			// block all queues
-
-	PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0xF00000, 0x0F);
-
-	for(eRFPath = RF92CD_PATH_A; eRFPath < curMaxRFPath; eRFPath++) {
-		// 1. Read original RF mode
-		RF_mode[eRFPath] = PHY_QueryRFReg(priv, eRFPath, 0x00, bMask20Bits, 1);
-
-		// 2. Set RF mode = standby mode
-		PHY_SetRFReg(priv, eRFPath, 0x00, 0x70000, 0x01);
-
-		// switch CV-curve control by LC-calibration
-		PHY_SetRFReg(priv, eRFPath, 0x2B, BIT(17), 0x0);
-
-		// jenyu suggest
-		PHY_SetRFReg(priv, eRFPath, 0x28, BIT(8), 0x1);
-
-		//4. Set LC calibration begin
-		PHY_SetRFReg(priv, eRFPath, 0x18, BIT(15), 0x01);
-
-		while(!(PHY_QueryRFReg(priv, eRFPath, 0x2A, BIT(11), 1) &&
-				timecount <= timeout)){
-			//DEBUG_INFO("PHY_LCK delay for %d ms=2\n", timecount);
-			delay_ms(50);
-			timecount+=50;
-		}
-
-		//u4tmp = PHY_QueryRFReg(priv, eRFPath, 0x28, bMask20Bits, 1);
-
-		memset((void *)curveCountVal, 0, CV_CURVE_CNT*2);
-
-		//Set LC calibration off
-		PHY_SetRFReg(priv, eRFPath, 0x18, BIT(15), 0x00);
-
-		// jenyu suggest
-		PHY_SetRFReg(priv, eRFPath, 0x28, BIT(8), 0x0);
-
-		//save Curve-counting number
-		for(i=0; i<CV_CURVE_CNT; i++)
-		{
-			unsigned int readVal=0, readVal2=0;
-
-			PHY_SetRFReg(priv, eRFPath, 0x3F, 0x7f, i);
-
-			PHY_SetRFReg(priv, eRFPath, 0x4D, bMask20Bits, 0);
-
-			readVal = PHY_QueryRFReg(priv, eRFPath, 0x4F, bMask20Bits, 1);
-
-			curveCountVal[2*i+1] = (readVal & 0xfffe0) >> 5;
-
-			readVal2 = PHY_QueryRFReg(priv, eRFPath, 0x50, 0xffc00, 1);
-
-			curveCountVal[2*i] = (((readVal & 0x1F) << 10) | readVal2);
-		}
-
-		if(eRFPath == RF92CD_PATH_A
-#ifdef CONFIG_RTL_92D_DMDP
-			&& priv->pshare->wlandev_idx == 0
-#endif
-			)
-			_PHY_CalcCurvIndex(priv, TargetChnl_5G, curveCountVal, TRUE, CurveIndex_5G);
-		else
-			_PHY_CalcCurvIndex(priv, TargetChnl_2G, curveCountVal, FALSE, CurveIndex_2G);
-
-		// switch CV-curve control mode
-		PHY_SetRFReg(priv, eRFPath, 0x2B, BIT(17), 0x1);
-
-		// store 0x28 for Reload_LCK
-		priv->pshare->RegRF28[eRFPath] = PHY_QueryRFReg(priv, eRFPath, 0x28, bMask20Bits, 1);
-	}
-
-	//Restore original situation
-	for(eRFPath = RF92CD_PATH_A; eRFPath < curMaxRFPath; eRFPath++)
-	{
-		PHY_SetRFReg(priv, eRFPath, 0x00, bMask20Bits, RF_mode[eRFPath]);
-	}
-
-	if((tmpReg&0x70) != 0)
-	{
-		//Path-A
-		RTL_W8(0xd03, tmpReg);
-	}
-	else // Deal with Packet TX case
-	{
-		RTL_W8(TXPAUSE, 0x00);
-	}
-
-	PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0xF00000, 0x00);
-
-	phy_ReloadLCKSetting(priv);
-
-}
-
-#else
-/* Hardware LCK */
-static void PHY_LCCalibrate_92D(struct rtl8192cd_priv *priv)
-{
-	unsigned char tmpReg;
-	unsigned int RF_mode[2], tmpu4Byte[2];
-
-	unsigned int eRFPath, curMaxRFPath;
-	unsigned char	timeout = 800, timecount = 0;
-
-	if (priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY)
-		curMaxRFPath = RF92CD_PATH_B;
-	else
-		curMaxRFPath = RF92CD_PATH_MAX;
-
-
-	// Check continuous TX and Packet TX
-	tmpReg = RTL_R8(0xd03);
-
-	if ((tmpReg & 0x70) != 0)				// Deal with contisuous TX case
-		RTL_W8(0xd03, tmpReg&0x8F);	// disable all continuous TX
-	else									// Deal with Packet TX case
-		RTL_W8(TXPAUSE, 0xFF);			// block all queues
-
-	PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0xF00000, 0x0F);
-
-	for(eRFPath = RF92CD_PATH_A; eRFPath < curMaxRFPath; eRFPath++) {
-		// 1. Read original RF mode
-		RF_mode[eRFPath] = PHY_QueryRFReg(priv, eRFPath, 0x00, bMask20Bits, 1);
-
-		// 2. Set RF mode = standby mode
-		PHY_SetRFReg(priv, eRFPath, 0x00, 0x70000, 0x01);
-
-		tmpu4Byte[eRFPath] = PHY_QueryRFReg(priv, eRFPath, 0x28, bMask20Bits, 1);
-		PHY_SetRFReg(priv, eRFPath, 0x28, 0x700, 0x07);
-
-		//4. Set LC calibration begin
-		PHY_SetRFReg(priv, eRFPath, 0x18, 0x08000, 0x01);
-	}
-
-#if defined(CONFIG_RTL_8198) && defined(CONFIG_RTL_92D_SUPPORT)
-	REG32(BSP_WDTCNR) |=  1 << 23;
-#endif
-
-	for(eRFPath = RF92CD_PATH_A; eRFPath < curMaxRFPath; eRFPath++) {
-		while(!(PHY_QueryRFReg(priv, eRFPath, 0x2A, BIT(11), 1) &&
-				timecount <= timeout)){
-			DEBUG_INFO("PHY_LCK delay for %d ms=2\n", timecount);
-			delay_ms(50);
-			timecount+=50;
-		}
-	}
-
-	for(eRFPath = RF92CD_PATH_A; eRFPath < curMaxRFPath; eRFPath++) {
-		PHY_SetRFReg(priv, eRFPath, 0x28, bMask20Bits, tmpu4Byte[eRFPath]);
-		priv->pshare->RegRF28[eRFPath] = tmpu4Byte[eRFPath];
-		PHY_SetRFReg(priv, eRFPath, 0x00, bMask20Bits, RF_mode[eRFPath]);
-	}
-
-	// Restore original situation
-	if ((tmpReg & 0x70) != 0)	// Deal with contisuous TX case
-		RTL_W8(0xd03, tmpReg);
-	else 						// Deal with Packet TX case
-		RTL_W8(TXPAUSE, 0x00);
-
-	PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0xF00000, 0x0);
-
-}
-
-
-#endif //LCK_SW
-
-#ifdef RX_GAIN_TRACK_92D
-static void rx_gain_tracking_92D(struct rtl8192cd_priv *priv)
-{
-	u8	index_mapping[Rx_index_mapping_NUM] = {
-						0x0f,	0x0f,	0x0d,	0x0c,	0x0b,
-						0x0a,	0x09,	0x08,	0x07,	0x06,
-						0x05,	0x04,	0x04,	0x03,	0x02
-					};
-
-	u8	eRFPath, curMaxRFPath;
-	u32	u4tmp;
-
-	u4tmp = (index_mapping[(priv->pmib->dot11RFEntry.ther - priv->pshare->ThermalValue_RxGain)]) << 12;
-
-	DEBUG_INFO("===>%s interface %d  Rx Gain %x\n", __FUNCTION__, priv->pshare->wlandev_idx, u4tmp);
-
-	if (priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY)
-		curMaxRFPath = RF92CD_PATH_B;
-	else
-		curMaxRFPath = RF92CD_PATH_MAX;
-
-	for(eRFPath = RF92CD_PATH_A; eRFPath < curMaxRFPath; eRFPath++)
-		PHY_SetRFReg(priv, eRFPath, 0x3C, bMask20Bits, (priv->pshare->RegRF3C[eRFPath]&(~(0xF000)))|u4tmp);
-
-};
-
-#endif
-
-#if 0
-
-void tx_power_tracking_92D(struct rtl8192cd_priv *priv)
-{
-	return;
-}
-
-#else
-
-
-void tx_power_tracking_92D(struct rtl8192cd_priv *priv)
-{
-	u8		ThermalValue = 0, delta, delta_LCK, delta_IQK, delta_RxGain, index[2], offset, ThermalValue_AVG_count = 0;
-	u32		ThermalValue_AVG = 0;
-	int 	ele_A, ele_D, /*TempCCk,*/ X, value32, Y, ele_C;
-	int		OFDM_index[2], CCK_index=0;
-	int	   	i = 0;
-	char	is2T = ((priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY) ?1 :0);
-	u8 		OFDM_min_index = 6, OFDM_min_index_internalPA = 5, rf=1, channel; //OFDM BB Swing should be less than +3.0dB, which is required by Arthur	u1Byte			OFDM_min_index = 6, rf; //OFDM BB Swing should be less than +3.0dB, which is required by Arthur
-
-	u8		index_mapping[5][index_mapping_NUM] = {
-					{0,	1,	3,	6,	8,	9,				//5G, path A/MAC 0, decrease power
-					11,	13,	14,	16,	17,	18, 18},
-					{0,	2,	4,	5,	7,	10,				//5G, path A/MAC 0, increase power
-					12,	14,	16,	18,	18,	18,	18},
-					{0,	2,	3,	6,	8,	9,				//5G, path B/MAC 1, decrease power
-					11,	13,	14,	16,	17,	18,	18},
-					{0,	2,	4,	5,	7,	10,				//5G, path B/MAC 1, increase power
-					13,	16,	16,	18,	18,	18,	18},
-					{0,	1,	2,	3,	4,	5,				//2.4G, for decreas power
-					6,	7,	7,	8,	9,	10,	10},
-					};
-
-#if defined(RTL8192D_INT_PA)
-
-	u8		index_mapping_internalPA[8][index_mapping_NUM] = {
-					 {0,  1, 3, 4, 6, 7,	//5G, path A/MAC 0, ch36-64, decrease power
-					 9,  11,  13,  15,	16,  16,  16},
-					 {0,  1, 3, 4, 6, 7,	 //5G, path A/MAC 0, ch36-64, increase power
-					 9,  11,  13,  15,	16,  18,  20},
-					 {0,  1, 3, 4, 6, 7,	//5G, path A/MAC 0, ch100-165, decrease power
-					 9, 11,  13,  15,  16,	16,  16},
-					 {0,  1, 3, 4, 6, 7,	 //5G, path A/MAC 0, ch100-165, increase power
-					 9,  11,  13,  15,	16,  18,  20},
-					 {0,  1, 3, 4, 6, 7,	//5G, path B/MAC 1, ch36-64, decrease power
-					 9, 11,  13,  15,  16,	16,  16},
-					 {0,  1, 3, 4, 6, 7,	 //5G, path B/MAC 1, ch36-64, increase power
-					 9,  11,  13,  15,	16,  18,  20},
-					 {0,  1, 3, 4, 6, 7,	//5G, path B/MAC 1, ch100-165, decrease power
-					 9, 11, 13,  15,  16,  16,	16},
-					 {0,  1, 3, 4, 6, 7,	 //5G, path B/MAC 1, ch100-165, increase power
-					 9,  11,  13,  15,	16,  18,  20},
-					};	
-
-	u8			bInteralPA[2];	
-				
-#endif
-
-#ifdef DPK_92D
-	short	index_mapping_DPK[4][index_mapping_DPK_NUM]={
-				{0, 0,	1,	2,	2,				//path A current thermal > PG thermal
-				3,	4,	5,	5,	6,		
-				7,	7,	8,	9,	9},
-				{0, 0,	-1, -2, -3, 			//path A current thermal < PG thermal
-				-3, -4, -5, -6, -6, 	
-				-7, -8, -9, -9, -10},
-				{0, 0,	1,	2,	2,				//path B current thermal > PG thermal
-				3,	4,	5,	5,	6,		
-				7,	7,	8,	9,	9},
-				{0, 0,	-1, -2, -3, 			//path B current thermal < PG thermal
-				-3, -4, -5, -6, -6, 	
-				-7, -8, -9, -9, -10}					
-				};
-
-	u8		delta_DPK;
-	short	index_DPK[2] = { 0xb68,	0xb6c }, value_DPK, value_DPK_shift;
-	int j;
-
-	if(priv->pshare->bDPKworking) {
-		DEBUG_INFO("DPK in progress abort tx power tracking \n");
-		return; 
-	}
-
-#endif
-
-#ifdef MP_TEST
-	if ((OPMODE & WIFI_MP_STATE) || priv->pshare->rf_ft_var.mp_specific) {
-		channel=priv->pshare->working_channel;
-		if(priv->pshare->mp_txpwr_tracking == FALSE)
-			return;
-	} else
-#endif
-	{
-		channel = (priv->pmib->dot11RFEntry.dot11channel);
-	}
-
-	if (priv->pshare->pwr_trk_ongoing==0) {
-		PHY_SetRFReg(priv, RF92CD_PATH_A, RF_T_METER_92D, bMask20Bits, 0x30000);
-		priv->pshare->pwr_trk_ongoing = 1;
-		return;
-	}else{
-		ThermalValue =(unsigned char)PHY_QueryRFReg(priv, RF92CD_PATH_A, RF_T_METER_92D, 0xf800, 1);
-		priv->pshare->pwr_trk_ongoing = 0;
-#ifdef DPK_92D
-		priv->pshare->ThermalValue_DPKtrack = ThermalValue;
-#endif
-	}
-	DEBUG_INFO("Readback Thermal Meter = 0x%lx pre thermal meter 0x%lx EEPROMthermalmeter 0x%lx\n", ThermalValue,
-				priv->pshare->ThermalValue, priv->pmib->dot11RFEntry.ther);
-
-	if(is2T)
-		rf = 2;
-	else
-		rf = 1;
-
-	if (ThermalValue) {
-
-		//Query OFDM path A default setting
-		ele_D = PHY_QueryBBReg(priv, rOFDM0_XATxIQImbalance, bMaskDWord)&bMaskOFDM_D;
-		for(i=0; i<OFDM_TABLE_SIZE_92D; i++) {	//find the index
-			if(ele_D == (OFDMSwingTable_92D[i]&bMaskOFDM_D))	{
-				priv->pshare->OFDM_index0[0] = i;
-				DEBUG_INFO("Initial pathA ele_D reg0x%x = 0x%lx, OFDM_index=0x%x\n",
-						rOFDM0_XATxIQImbalance, ele_D, priv->pshare->OFDM_index0[0]);
-				break;
-			}
-		}
-
-		//Query OFDM path B default setting
-		if(is2T)	{
-			ele_D = PHY_QueryBBReg(priv, rOFDM0_XBTxIQImbalance, bMaskDWord)&bMaskOFDM_D;
-			for(i=0; i<OFDM_TABLE_SIZE_92D; i++)			{
-				if(ele_D == (OFDMSwingTable_92D[i]&bMaskOFDM_D))	{
-					priv->pshare->OFDM_index0[1] = i;
-					DEBUG_INFO("Initial pathB ele_D reg0x%x = 0x%lx, OFDM_index=0x%x\n",
-							rOFDM0_XBTxIQImbalance, ele_D, priv->pshare->OFDM_index0[1]);
-					break;
-				}
-			}
-		}
-
-		if(priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_2G) {
-			priv->pshare->CCK_index0 = get_CCK_swing_index(priv);
-		} else {
-			priv->pshare->CCK_index0 = 12;
-		}
-
-		if(!priv->pshare->ThermalValue)	{
-			priv->pshare->ThermalValue = priv->pmib->dot11RFEntry.ther;
-			priv->pshare->ThermalValue_LCK = ThermalValue;
-			priv->pshare->ThermalValue_IQK = ThermalValue;
-#ifdef RX_GAIN_TRACK_92D
-			priv->pshare->ThermalValue_RxGain = priv->pmib->dot11RFEntry.ther;
-#endif
-#ifdef DPK_92D
-			priv->pshare->ThermalValue_DPK = ThermalValue;
-#endif
-			for(i = 0; i < rf; i++)
-				priv->pshare->OFDM_index[i] = priv->pshare->OFDM_index0[i];
-			priv->pshare->CCK_index = priv->pshare->CCK_index0;
-		}
-
-
-		//calculate average thermal meter
-		{
-			priv->pshare->Thermal_log[priv->pshare->Thermal_idx] = ThermalValue;
-			priv->pshare->Thermal_idx = (priv->pshare->Thermal_idx+1)%8;
-
-			for(i=0; i<8; i++) {
-				if(priv->pshare->Thermal_log[i]) {
-					ThermalValue_AVG += priv->pshare->Thermal_log[i];
-					ThermalValue_AVG_count++;
-				}
-			}
-
-			if(ThermalValue_AVG_count)
-				ThermalValue = (u8)(ThermalValue_AVG / ThermalValue_AVG_count);
-		}
-
-
-		delta     = RTL_ABS(ThermalValue, priv->pshare->ThermalValue);
-		delta_LCK = RTL_ABS(ThermalValue, priv->pshare->ThermalValue_LCK);
-		delta_IQK = RTL_ABS(ThermalValue, priv->pshare->ThermalValue_IQK);
-#ifdef RX_GAIN_TRACK_92D
-		delta_RxGain = RTL_ABS(ThermalValue, priv->pshare->ThermalValue_RxGain);
-#endif
-
-//		printk("Readback Thermal Meter = 0x%lx pre thermal meter 0x%lx EEPROMthermalmeter 0x%lx delta 0x%lx delta_LCK 0x%lx delta_IQK 0x%lx\n",
-//			ThermalValue, priv->pshare->ThermalValue, priv->pmib->dot11RFEntry.ther, delta, delta_LCK, delta_IQK);
-
-		getDeltaValue(priv);
-
-#ifdef DPK_92D
-
-		if(priv->pshare->bDPKstore)	{
-
-			priv->pshare->ThermalValue_DPK = ThermalValue;
-			delta_DPK = 0;
-
-			for(j = 0; j < rf; j++)	{
-
-				if(priv->pshare->ThermalValue_DPKstore > priv->pmib->dot11RFEntry.ther)
-					value_DPK_shift = index_mapping_DPK[j*2][priv->pshare->ThermalValue_DPKstore- priv->pmib->dot11RFEntry.ther];
-				else
-					value_DPK_shift = index_mapping_DPK[j*2+1][priv->pmib->dot11RFEntry.ther- priv->pshare->ThermalValue_DPKstore];
-
-				for(i = 0; i < index_mapping_DPK_NUM; i++) 	{
-					priv->pshare->index_mapping_DPK_current[j*2][i] = 
-						index_mapping_DPK[j*2][i]-value_DPK_shift;
-					priv->pshare->index_mapping_DPK_current[j*2+1][i] = 
-						index_mapping_DPK[j*2+1][i]-value_DPK_shift;										
-				}				
-			}		
-		}
-		else
-		{
-			delta_DPK = RTL_ABS(ThermalValue, priv->pshare->ThermalValue_DPK);
-		}
-
-		for(j = 0; j < rf; j++)			{
-			if(!priv->pshare->bDPKdone[j])
-				priv->pshare->OFDM_min_index_internalPA_DPK[j] = 0;
-		}
-
-#endif
-
-#if 1
-		if ((delta_LCK > priv->pshare->Delta_LCK) && (priv->pshare->Delta_LCK != 0)) {
-			priv->pshare->ThermalValue_LCK = ThermalValue;
-			PHY_LCCalibrate_92D(priv);
-		}
-#endif
-		if(delta > 0
-#ifdef DPK_92D
-			||(priv->pshare->bDPKstore)			
-#endif
-		){
-			if(delta == 0 && priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_2G)
-				goto TxPowerDPK;
-#ifdef DPK_92D
-			if(priv->pshare->bDPKstore)
-				priv->pshare->bDPKstore = FALSE;
-#endif
-			delta	= RTL_ABS(ThermalValue, priv->pmib->dot11RFEntry.ther);
-
-			//calculate new OFDM / CCK offset
-			{
-
-				if (priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_2G){
-					offset = 4;
-
-					if(delta > index_mapping_NUM-1)
-						index[0] = index_mapping[offset][index_mapping_NUM-1];
-					else
-						index[0] = index_mapping[offset][delta];
-
-					if(ThermalValue > priv->pmib->dot11RFEntry.ther)	{
-						for(i = 0; i < rf; i++)
-						 	OFDM_index[i] = priv->pshare->OFDM_index[i] - delta;
-						CCK_index = priv->pshare->CCK_index - delta;
-					}
-					else	{
-						for(i = 0; i < rf; i++)
-							OFDM_index[i] = priv->pshare->OFDM_index[i] + index[0];
-						CCK_index = priv->pshare->CCK_index + index[0];
-					}
-				} else if (priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_5G) {
-					for(i = 0; i < rf; i++){
-
-#if defined(RTL8192D_INT_PA)
-
-						if (priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY && priv->pshare->wlandev_idx==1)		//MAC 1 5G
-							bInteralPA[i] = priv->pshare->phw->InternalPA5G[1];
-						else
-							bInteralPA[i] = priv->pshare->phw->InternalPA5G[i];	
-
-						if(bInteralPA[i]) {
-							if(priv->pshare->wlandev_idx == 1 || i == 1/*rf*/)
-								offset = 4;
-							else
-								offset = 0;
-							if(channel >= 100 && channel <= 165)
-								offset += 2;													
-						}
-						else
-#endif
-						{
-							if(priv->pshare->wlandev_idx == 1 || i == 1)
-								offset = 2;
-							else
-								offset = 0;
-						}
-
-						if(ThermalValue > priv->pmib->dot11RFEntry.ther) //set larger Tx power
-							offset++;
-#if defined(RTL8192D_INT_PA)
-						if(bInteralPA[i]) {
-							if(delta > index_mapping_NUM-1)
-								index[i] = index_mapping_internalPA[offset][index_mapping_NUM-1];
-							else
-								index[i] = index_mapping_internalPA[offset][delta];
-						} else
-#endif
-						{
-							if(delta > index_mapping_NUM-1)
-								index[i] = index_mapping[offset][index_mapping_NUM-1];
-							else
-								index[i] = index_mapping[offset][delta];
-						}
-
-						if(ThermalValue > priv->pmib->dot11RFEntry.ther) //set larger Tx power
-						{
-#if 0						
-							if(bInteralPA[i] && ThermalValue > 0x12)
-								index[i] = ((delta/2)*3+(delta%2));	
-#endif							
-							OFDM_index[i] = priv->pshare->OFDM_index[i] -index[i];
-						}
-						else
-						{
-							OFDM_index[i] = priv->pshare->OFDM_index[i] + index[i];
-						}
-					}
-				}
-
-				if(is2T)
-				{
-					DEBUG_INFO("temp OFDM_A_index=0x%x, OFDM_B_index=0x%x, CCK_index=0x%x\n",
-						priv->pshare->OFDM_index[0], priv->pshare->OFDM_index[1], priv->pshare->CCK_index);
-				}
-				else
-				{
-					DEBUG_INFO("temp OFDM_A_index=0x%x, CCK_index=0x%x\n",
-						priv->pshare->OFDM_index[0], priv->pshare->CCK_index);
-				}
-
-				for(i = 0; i < rf; i++)
-				{
-					if(OFDM_index[i] > OFDM_TABLE_SIZE_92D-1) {
-						OFDM_index[i] = OFDM_TABLE_SIZE_92D-1;
-					}
-					else if(priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_2G) {
-						if (OFDM_index[i] < (OFDM_min_index_internalPA))
-							OFDM_index[i] = (OFDM_min_index_internalPA);
-					} else if(bInteralPA[i]) {
-#ifdef DPK_92D
-						if (OFDM_index[i] < (OFDM_min_index_internalPA+ priv->pshare->OFDM_min_index_internalPA_DPK[i]))
-						{
-							priv->pshare->TxPowerLevelDPK[i] = OFDM_min_index_internalPA+ priv->pshare->OFDM_min_index_internalPA_DPK[i]-OFDM_index[i];
-							OFDM_index[i] = (OFDM_min_index_internalPA+ priv->pshare->OFDM_min_index_internalPA_DPK[i]);				
-						}
-						else
-						{
-							priv->pshare->TxPowerLevelDPK[i] = 0;
-						}
-#else
-                                                if (OFDM_index[i] < (OFDM_min_index_internalPA))
-                                                {
-                                                        OFDM_index[i] = (OFDM_min_index_internalPA);                   
-                                                }
-#endif				
-					} else if(OFDM_index[i] < OFDM_min_index) {
-						OFDM_index[i] = OFDM_min_index;
-					}
-				}
-
-				if (priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_2G){
-					if(CCK_index > CCK_TABLE_SIZE_92D-1)
-						CCK_index = CCK_TABLE_SIZE_92D-1;
-					else if (CCK_index < 0)
-						CCK_index = 0;
-				}
-
-				if(is2T) {
-					DEBUG_INFO("new OFDM_A_index=0x%x, OFDM_B_index=0x%x, CCK_index=0x%x\n",
-							OFDM_index[0], OFDM_index[1], CCK_index);
-				}
-				else
-				{
-					DEBUG_INFO("new OFDM_A_index=0x%x, CCK_index=0x%x\n",
-							OFDM_index[0], CCK_index);
-				}
-			}
-
-			//Config by SwingTable
-			{
-				//Adujst OFDM Ant_A according to IQK result
-				ele_D = (OFDMSwingTable_92D[OFDM_index[0]] & 0xFFC00000)>>22;
-				X = priv->pshare->RegE94;
-				Y = priv->pshare->RegE9C;
-
-				if(X != 0 && (priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_2G)){
-					if ((X & 0x00000200) != 0)
-						X = X | 0xFFFFFC00;
-					ele_A = ((X * ele_D)>>8)&0x000003FF;
-
-					//new element C = element D x Y
-					if ((Y & 0x00000200) != 0)
-						Y = Y | 0xFFFFFC00;
-					ele_C = ((Y * ele_D)>>8)&0x000003FF;
-
-					//wirte new elements A, C, D to regC80 and regC94, element B is always 0
-					value32 = (ele_D<<22)|((ele_C&0x3F)<<16)|ele_A;
-					PHY_SetBBReg(priv, rOFDM0_XATxIQImbalance, bMaskDWord, value32);
-
-					value32 = (ele_C&0x000003C0)>>6;
-					PHY_SetBBReg(priv, rOFDM0_XCTxAFE, bMaskH4Bits, value32);
-
-					value32 = ((X * ele_D)>>7)&0x01;
-					PHY_SetBBReg(priv, rOFDM0_ECCAThreshold, BIT(24), value32);
-
-				}
-				else
-				{
-					PHY_SetBBReg(priv, rOFDM0_XATxIQImbalance, bMaskDWord, OFDMSwingTable_92D[OFDM_index[0]]);
-					PHY_SetBBReg(priv, rOFDM0_XCTxAFE, bMaskH4Bits, 0x00);
-					PHY_SetBBReg(priv, rOFDM0_ECCAThreshold, BIT(24), 0x00);
-#ifdef MP_TEST
-					if ((priv->pshare->rf_ft_var.mp_specific) && (!is2T)) {
-						unsigned char str[50];
-						sprintf(str, "patha=%d,pathb=%d", priv->pshare->mp_txpwr_patha, priv->pshare->mp_txpwr_pathb);
-						mp_set_tx_power(priv, str);
-					}
-#endif
-				}
-				DEBUG_INFO("TxPwrTracking for interface %d path A: X = 0x%x, Y = 0x%x ele_A = 0x%x ele_C = 0x%x ele_D = 0x%x\n",
-							priv->pshare->wlandev_idx, X, Y, ele_A, ele_C, ele_D);
-
-
-				if(priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_2G)
-				{
-					//Adjust CCK according to IQK result
-					set_CCK_swing_index(priv, CCK_index);
-				}
-
-				if(is2T)
-				{
-					ele_D = (OFDMSwingTable_92D[OFDM_index[1]] & 0xFFC00000)>>22;
-
-					//new element A = element D x X
-					X = priv->pshare->RegEB4;
-					Y = priv->pshare->RegEBC;
-
-					if(X != 0 && (priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_2G)){
-						if ((X & 0x00000200) != 0)	//consider minus
-							X = X | 0xFFFFFC00;
-						ele_A = ((X * ele_D)>>8)&0x000003FF;
-
-						//new element C = element D x Y
-						if ((Y & 0x00000200) != 0)
-							Y = Y | 0xFFFFFC00;
-						ele_C = ((Y * ele_D)>>8)&0x00003FF;
-
-						//wirte new elements A, C, D to regC88 and regC9C, element B is always 0
-						value32=(ele_D<<22)|((ele_C&0x3F)<<16) |ele_A;
-						PHY_SetBBReg(priv, rOFDM0_XBTxIQImbalance, bMaskDWord, value32);
-
-						value32 = (ele_C&0x000003C0)>>6;
-						PHY_SetBBReg(priv, rOFDM0_XDTxAFE, bMaskH4Bits, value32);
-
-						value32 = ((X * ele_D)>>7)&0x01;
-						PHY_SetBBReg(priv, rOFDM0_ECCAThreshold, BIT(28), value32);
-
-					}
-					else{
-						PHY_SetBBReg(priv, rOFDM0_XBTxIQImbalance, bMaskDWord, OFDMSwingTable_92D[OFDM_index[1]]);
-						PHY_SetBBReg(priv, rOFDM0_XDTxAFE, bMaskH4Bits, 0x00);
-						PHY_SetBBReg(priv, rOFDM0_ECCAThreshold, BIT(28), 0x00);
-#ifdef MP_TEST
-					if ((priv->pshare->rf_ft_var.mp_specific) ) {
-						unsigned char str[50];
-						sprintf(str, "patha=%d,pathb=%d", priv->pshare->mp_txpwr_patha, priv->pshare->mp_txpwr_pathb);
-						mp_set_tx_power(priv, str);
-
-					}
-#endif				
-					}
-
-					DEBUG_INFO("TxPwrTracking path B: X = 0x%x, Y = 0x%x ele_A = 0x%x ele_C = 0x%x ele_D = 0x%x\n",
-									X, Y, ele_A, ele_C, ele_D);
-				}
-
-				DEBUG_INFO("TxPwrTracking 0xc80 = 0x%x, 0xc94 = 0x%x RF 0x24 = 0x%x\n", PHY_QueryBBReg(priv, 0xc80, bMaskDWord),
-						PHY_QueryBBReg(priv, 0xc94, bMaskDWord), PHY_QueryRFReg(priv, RF92CD_PATH_A, 0x24, bMask20Bits,1));
-			}
-		}
-
-TxPowerDPK:
-#ifdef DPK_92D
-		{
-			char bNOPG = FALSE;
-			unsigned char pwrlevelHT40_1S_A = priv->pmib->dot11RFEntry.pwrlevelHT40_1S_A[channel-1];
-			if (priv->pmib->dot11RFEntry.phyBandSelect & PHY_BAND_5G)
-				pwrlevelHT40_1S_A = priv->pmib->dot11RFEntry.pwrlevel5GHT40_1S_A[channel-1];
-#ifdef CONFIG_RTL_92D_DMDP			
-			if ((priv->pmib->dot11RFEntry.macPhyMode==DUALMAC_DUALPHY) &&
-				(priv->pshare->wlandev_idx == 1) && (priv->pmib->dot11RFEntry.phyBandSelect & PHY_BAND_5G))
-					pwrlevelHT40_1S_A = priv->pmib->dot11RFEntry.pwrlevel5GHT40_1S_B[channel-1];
-			if (pwrlevelHT40_1S_A == 0)
-				bNOPG = TRUE;
-#endif
-
-			//for DPK
-			if(delta_DPK > 0 && !bNOPG /*&& pHalData->bDPKdone*/) {
-				for(i = 0; i < rf; i++) {
-					if(bInteralPA[i] && priv->pshare->bDPKdone[i]) {				
-						if(ThermalValue > priv->pmib->dot11RFEntry.ther) 	
-							value_DPK = priv->pshare->index_mapping_DPK_current[i*2][ThermalValue-priv->pmib->dot11RFEntry.ther];
-						else
-							value_DPK = priv->pshare->index_mapping_DPK_current[i*2+1][priv->pmib->dot11RFEntry.ther-ThermalValue];
-						
-						PHY_SetBBReg(priv, index_DPK[i], 0x7c00, value_DPK);						
-					}
-				}				
-				priv->pshare->ThermalValue_DPK = ThermalValue;
-			}
-		}
-#endif
-		priv->pshare->pwr_trk_ongoing = 0;
-#if 1
-		if ((delta_IQK > priv->pshare->Delta_IQK) && (priv->pshare->Delta_IQK != 0)) {
-			priv->pshare->ThermalValue_IQK = ThermalValue;
-			PHY_IQCalibrate(priv);
-		}
-#endif
-
-#ifdef RX_GAIN_TRACK_92D
-		if(delta_RxGain > 0 && priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_5G
-			&& priv->pmib->dot11RFEntry.ther) {
-			priv->pshare->ThermalValue_RxGain = ThermalValue;
-			rx_gain_tracking_92D(priv);
-		}
-#endif
-
-		//update thermal meter value
-		priv->pshare->ThermalValue = ThermalValue;
-	}
-}
-
-#endif
-
-#ifdef CONFIG_RTL_92D_DMDP
-
-void IQK_92D_2G_phy1(struct rtl8192cd_priv *priv)
-{
-	unsigned int cal_num=0, cal_retry=0, Oldval=0, temp_c04=0, temp_c08=0, temp_874=0, temp_eac;
-	unsigned int cal_e94, cal_e9c, cal_ea4, cal_eac;
-	unsigned int X, Y, val_e94[3], val_e9c[3], val_ea4[3], val_eac[3];
-	unsigned int ADDA_REG[IQK_ADDA_REG_NUM] = {0x85c, 0xe6c, 0xe70, 0xe74, 	0xe78, 0xe7c, 0xe80, 0xe84,
-												0xe88, 0xe8c, 0xed0, 0xed4, 0xed8, 0xedc, 0xee0, 0xeec};
-	unsigned int ADDA_backup[IQK_ADDA_REG_NUM], i;
-	u8 temp_522, temp_550, temp_551;
-	u32 temp_040, temp_870, temp_860, temp_864, temp_800, temp_88c;
-	u8 switch2PI = 0;
-
-	printk(">> %s \n",__FUNCTION__);
-
-	// Save ADDA power saving parameters
-	for( i = 0 ; i < IQK_ADDA_REG_NUM ; i++)
-		ADDA_backup[i] = RTL_R32(ADDA_REG[i]);
-
-	/*
-	 * Save MAC default value
-	 */
-	temp_522 = RTL_R8(0x522);
-	temp_550 = RTL_R8(0x550);
-	temp_551 = RTL_R8(0x551);
-	temp_040 = RTL_R32(0x40);
-
-	// Save BB default
-	temp_800 = RTL_R32(0x800);
-	temp_870 = RTL_R32(0x870);
-	temp_860 = RTL_R32(0x860);
-	temp_864 = RTL_R32(0x864);
-	temp_88c = RTL_R32(0x88c);
-
-	// Path-A ADDA all on
-	for( i = 0 ; i < IQK_ADDA_REG_NUM ; i++) {
-#ifdef NON_INTR_ANTDIV
-		if (DMDP_PHY_QueryBBReg(0, 0xb30,BIT(27)))
-			RTL_W32(ADDA_REG[i], 0x04db25a4);
-		else
-#endif
-		RTL_W32(ADDA_REG[i], 0x0b1b25a4);
-	}
-
-
-	// IQ&LO calibration Setting
-
-	/*
-	 *	IQK must be done in PI mode
-	 */
-	if (!PHY_QueryBBReg(priv, 0x820, BIT(8)) || !PHY_QueryBBReg(priv, 0x828, BIT(8))) {
-		PHY_SetBBReg(priv, 0x820, bMaskDWord, 0x01000100);
-		PHY_SetBBReg(priv, 0x828, bMaskDWord, 0x01000100);
-		switch2PI++;
-	}
-
-	//BB setting
-	temp_c04 = RTL_R32(0xc04);
-	temp_c08 = RTL_R32(0xc08);
-	temp_874 = RTL_R32(0x874);
-	PHY_SetBBReg(priv, 0x800, BIT(24), 0);
-	RTL_W32(0xc04, 0x03a05600);
-	RTL_W32(0xc08, 0x000800e4);
-	RTL_W32(0x874, 0x22204000);
-
-	PHY_SetBBReg(priv, 0x870, BIT(10), 1);
-	PHY_SetBBReg(priv, 0x870, BIT(26), 1);
-	PHY_SetBBReg(priv, 0x860, BIT(10), 0);
-	PHY_SetBBReg(priv, 0x864, BIT(10), 0);
-
-	PHY_SetBBReg(priv,0x88c,0x00f00000,0xf);
-
-	RTL_W32(0x840, 0x00010000);
-
-	//MAC register setting
-	RTL_W8(0x522, 0x3f);
-	RTL_W8(0x550, RTL_R8(0x550)& (~BIT(3)));
-	RTL_W8(0x551, RTL_R8(0x551)& (~BIT(3)));
-	RTL_W32(0x40, 0);
-
-	//AP or IQK
-	RTL_W32(0xb68 , 0x0f600000);
-	RTL_W32(0xb6c , 0x0f600000);
-
-	// IQK setting
-	RTL_W32(0xe28, 0x80800000);
-	RTL_W32(0xe40, 0x01007c00);
-	RTL_W32(0xe44, 0x01004800);
-
-	// path-A IQK setting
-	RTL_W32(0xe30, 0x10008c22);
-	RTL_W32(0xe34, 0x10008c22);
-	RTL_W32(0xe38, 0x82140102);
-	RTL_W32(0xe3c, 0x28160206);
-
-	// LO calibration setting
-	RTL_W32(0xe4c, 0x00462911);
-
-	// delay to ensure Path-A IQK success
-	delay_ms(10);
-
-	// step 4: One shot, path A LOK & IQK
-	while (cal_num < 3) {
-			// One shot, path A LOK & IQK
-		RTL_W32(0xe48, 0xf9000000);
-		RTL_W32(0xe48, 0xf8000000);
-			// delay 1ms
-		delay_ms(1);
-
-		// check fail bit and check abnormal condition, then fill BB IQ matrix
-		cal_e94 = (RTL_R32(0xe94) >> 16) & 0x3ff;
-		cal_e9c = (RTL_R32(0xe9c) >> 16) & 0x3ff;
-		cal_ea4 = (RTL_R32(0xea4) >> 16) & 0x3ff;
-		temp_eac = RTL_R32(0xeac);
-		cal_eac = (temp_eac >> 16) & 0x3ff;
-		if (!(temp_eac & BIT(28)) && !(temp_eac & BIT(27)) &&
-			(cal_e94 != 0x142) && (cal_e9c != 0x42) &&
-			(cal_ea4 != 0x132) && (cal_eac != 0x36)) {
-			val_e94[cal_num] = cal_e94;
-			val_e9c[cal_num] = cal_e9c;
-			val_ea4[cal_num] = cal_ea4;
-			val_eac[cal_num] = cal_eac;
-			cal_num++;
-		} else {
-			if (++cal_retry >= 10) {
-				printk("%s Path-A Check\n",__FUNCTION__);
-				break;
-			}
-		}
-	}
-
-	if (cal_num == 3) {
-		cal_e94 = get_mean_of_2_close_value(val_e94);
-		cal_e9c = get_mean_of_2_close_value(val_e9c);
-		cal_ea4 = get_mean_of_2_close_value(val_ea4);
-		cal_eac = get_mean_of_2_close_value(val_eac);
-
-		priv->pshare->RegE94=cal_e94;
-		priv->pshare->RegE9C=cal_e9c;
-
-		Oldval = (RTL_R32(0xc80) >> 22) & 0x3ff;
-
-		X = cal_e94;
-		PHY_SetBBReg(priv, 0xc80, 0x3ff, (X * Oldval) >> 8);
-		PHY_SetBBReg(priv, 0xc4c, BIT(24), ((X * Oldval) >> 7) & 0x1);
-
-		Y = cal_e9c;
-		if ((Y & 0x00000200) != 0)
-			Y = Y | 0xFFFFFC00;
-		PHY_SetBBReg(priv, 0xc94, 0xf0000000, (((Y * Oldval) >> 8) >> 6) & 0xf);
-		PHY_SetBBReg(priv, 0xc80, 0x003f0000, ((Y * Oldval) >> 8) & 0x3f);
-		PHY_SetBBReg(priv, 0xc4c, BIT(26), ((Y * Oldval) >> 7) & 0x1);
-
-		PHY_SetBBReg(priv, 0xc14, 0x3ff, cal_ea4);
-
-		PHY_SetBBReg(priv, 0xc14, 0xfc00, cal_eac & 0x3f);
-
-		PHY_SetBBReg(priv, 0xca0, 0xf0000000, (cal_eac >> 6) & 0xf);
-	}else {
-		priv->pshare->RegE94=0x100;
-		priv->pshare->RegE9C=0x00;
-	}
-
-	// back to BB mode, load original values
-	RTL_W32(0xe28, 0);
-	RTL_W32(0xc04, temp_c04);
-	RTL_W32(0xc08, temp_c08);
-	RTL_W32(0x874, temp_874);
-	RTL_W32(0x800, temp_800);
-
-	RTL_W32(0x88c, temp_88c);
-	RTL_W32(0x840, 0x32fff);
-	RTL_W32(0x870, temp_870);
-	RTL_W32(0x860, temp_860);
-	RTL_W32(0x864, temp_864);
-
-	// return to SI mode
-	if (switch2PI) {
-		RTL_W32(0x820, 0x01000000);
-		RTL_W32(0x828, 0x01000000);
-	}
-
-#if defined(CONFIG_RTL_8198)
-	REG32(BSP_WDTCNR) |=  1 << 23;
-#endif
-
-	/*
-	 *	Reload ADDA power saving parameters
-	 */
-	for(i = 0 ; i < IQK_ADDA_REG_NUM ; i++)
-		PHY_SetBBReg(priv, ADDA_REG[i], bMaskDWord, ADDA_backup[i]);
-
-	/*
-	 *	Reload MAC default value
-	 */
-	RTL_W8(0x550, temp_550);
-	RTL_W8(0x551, temp_551);
-	RTL_W32(0x40, temp_040);
-	RTL_W8(0x522, temp_522);
-
-}
-
-
-void IQK_92D_5G_phy0_n(struct rtl8192cd_priv *priv)
-{
-	unsigned int temp_800, temp_c04, temp_874, temp_c08, temp_870, temp_860, temp_88c, temp_c50, temp_b30,
-				switch2PI=0, X, reg; //, Oldval_0, TX0_A;
-	u8 temp_522, temp_550, temp_551;
-	unsigned int cal_num=0, cal_retry=0, ADDA_backup[IQK_ADDA_REG_NUM];
-	int Y, result[8][3], result_final[8]; //, TX0_C;
-
-	unsigned int i, RX0REG0xe40[3], RX0REG0xe40_final=0, REG0xe40, REG0xe94, REG0xe9c;
-	unsigned int REG0xeac, REG0xea4;
-	unsigned char TX0IQKOK = FALSE;
-	unsigned int TX_X0, TX_Y0, RX_X0, RX_Y0;
-	unsigned int ADDA_REG[IQK_ADDA_REG_NUM] = {0x85c, 0xe6c, 0xe70, 0xe74,	0xe78, 0xe7c, 0xe80, 0xe84,
-												0xe88, 0xe8c, 0xed0, 0xed4, 0xed8, 0xedc, 0xee0, 0xeec};
-
-//	printk(">> %s \n",__FUNCTION__);
-#ifdef CONFIG_RTL_8198
-	REG32(BSP_WDTCNR) |=  1 << 23;
-#endif
-	/*
-	 * Save MAC default value
-	 */
-	temp_522 = RTL_R8(0x522);
-	temp_550 = RTL_R8(0x550);
-	temp_551 = RTL_R8(0x551);
-
-	/*
-	 *	Save BB Parameter
-	 */
-	temp_800 = RTL_R32(0x800);
-	temp_c04 = RTL_R32(0xc04);
-	temp_874 = RTL_R32(0x874);
-	temp_c08 = RTL_R32(0xc08);
-	temp_870 = RTL_R32(0x870);
-	temp_860 = RTL_R32(0x860);
-	temp_88c = RTL_R32(0x88c);
-	temp_c50 = RTL_R32(0xc50);
-	temp_b30 = RTL_R32(0xb30);	// 03/03/2011 update
-
-	/*
-	*	Save AFE Parameters
-	*/
-	for( i = 0 ; i < IQK_ADDA_REG_NUM ; i++)
-		ADDA_backup[i] = RTL_R32(ADDA_REG[i]);
-
-	/*
-	 *	==============
-	 *	Path-A TX/RX IQK
-	 *	==============
-	 */
-	while (cal_num < 3) {
-		/*
-		 *	Path-A AFE all on
-		 */
-		for( i = 0 ; i < IQK_ADDA_REG_NUM ; i++) {
-#ifdef NON_INTR_ANTDIV
-			if (DMDP_PHY_QueryBBReg(0, 0xb30,BIT(27)))
-				RTL_W32(ADDA_REG[i], 0x0b1b25a4);
-			else
-#endif
-			RTL_W32(ADDA_REG[i], 0x04db25a4);
-		}
-
-		/*
-		 *	MAC register setting
-		 */
-		RTL_W8(0x522, 0x3f);
-		RTL_W8(0x550, RTL_R8(0x550)& (~BIT(3)));
-		RTL_W8(0x551, RTL_R8(0x551)& (~BIT(3)));
-
-		/*
-		 *	IQK must be done in PI mode
-		 */
-		if (!PHY_QueryBBReg(priv, 0x820, BIT(8)) || !PHY_QueryBBReg(priv, 0x828, BIT(8))) {
-			PHY_SetBBReg(priv, 0x820, bMaskDWord, 0x01000100);
-			PHY_SetBBReg(priv, 0x828, bMaskDWord, 0x01000100);
-			switch2PI++;
-		}
-
-		/*
-		 *	BB setting
-		 */
-		PHY_SetBBReg(priv, 0x800, BIT(24), 0);
-		PHY_SetBBReg(priv, 0xc04, bMaskDWord, 0x03a05600);
-		PHY_SetBBReg(priv, 0xc08, bMaskDWord, 0x000800e4);
-		PHY_SetBBReg(priv, 0x874, bMaskDWord, 0x22208000);
-		PHY_SetBBReg(priv, 0x88c, BIT(23)|BIT(22)|BIT(21)|BIT(20), 0xf);
-		PHY_SetBBReg(priv, 0xb30, bMaskDWord, 0x00a00000);	// 03/03/2011 update
-
-		/*
-		 *	AP or IQK
-		 */
-		//PHY_SetBBReg(priv, 0xb68, bMaskDWord, 0x0f600000);
-		//PHY_SetBBReg(priv, 0xb6c, bMaskDWord, 0x0f600000);
-
-		// IQK-R03 2011/02/16 update
-		PHY_SetBBReg(priv, 0xb00, bMaskDWord, 0);
-		PHY_SetBBReg(priv, 0xb68, bMaskDWord, 0x20000000);
-
-		/*
-		 *	IQK global setting
-		 */
-		PHY_SetBBReg(priv, 0xe28, bMaskDWord, 0x80800000);
-		PHY_SetBBReg(priv, 0xe40, bMaskDWord, 0x10007c00);
-		PHY_SetBBReg(priv, 0xe44, bMaskDWord, 0x01004800);
-
-		/*
-		 *	path-A IQK setting
-		 */
-		PHY_SetBBReg(priv, 0xe30, bMaskDWord, 0x18008c1f);
-		PHY_SetBBReg(priv, 0xe34, bMaskDWord, 0x18008c1f);
-		PHY_SetBBReg(priv, 0xe38, bMaskDWord, 0x82140307);	// 01/11/2011 update
-
-#ifdef USB_POWER_SUPPORT
-		PHY_SetBBReg(priv, 0xe3c, bMaskDWord, 0x68160c66);
-#else
-		PHY_SetBBReg(priv, 0xe3c, bMaskDWord, 0x68160960);	// 01/11/2011 update
-#endif
-		/*
-		 *	LO calibration setting
-		 */
-		PHY_SetBBReg(priv, 0xe4c, bMaskDWord, 0x00462911);
-
-#ifdef USB_POWER_SUPPORT
-		//	PHY0 TRSW seting
-		PHY_SetBBReg(priv, 0x870, BIT(6)|BIT(5), 3);
-		PHY_SetBBReg(priv, 0x860, BIT(6)|BIT(5), 3);
-#else
-		/*
-		 *	path-A PA on
-		 */
-		/*
-		PHY_SetBBReg(priv, 0x870, BIT(11)|BIT(10), 3);
-		PHY_SetBBReg(priv, 0x870, BIT(6)|BIT(5), 3);
-		PHY_SetBBReg(priv, 0x860, BIT(11)|BIT(10), 3);
-		 */
-		PHY_SetBBReg(priv, 0x870, bMaskDWord, 0x07000f60);	// 01/11/2011 update
-		PHY_SetBBReg(priv, 0x860, bMaskDWord, 0x66e60e30);	// 01/11/2011 update
-#endif
-		/*
-		 *	One shot, path A LOK & IQK
-		 */
-		PHY_SetBBReg(priv, 0xe48, bMaskDWord, 0xf9000000);
-		PHY_SetBBReg(priv, 0xe48, bMaskDWord, 0xf8000000);
-
-		/*
-		 *	Delay 10 ms
-		 */
-		delay_ms(10);
-
-		/*
-		 *	Check_TX_IQK_A_result
-		 */
-		REG0xe40 = PHY_QueryBBReg(priv, 0xe40, bMaskDWord);
-		REG0xeac = PHY_QueryBBReg(priv, 0xeac, bMaskDWord);
-		REG0xe94 = PHY_QueryBBReg(priv, 0xe94, bMaskDWord);
-		if(((REG0xeac&BIT(28)) == 0) && (((REG0xe94&0x3FF0000)>>16)!=0x142)) {
-			TX0IQKOK = TRUE;
-			REG0xe9c = PHY_QueryBBReg(priv, 0xe9c, bMaskDWord);
-			TX_X0 = (PHY_QueryBBReg(priv, 0xe94, bMaskDWord)&0x3FF0000)>>16;
-			TX_Y0 = (PHY_QueryBBReg(priv, 0xe9c, bMaskDWord)&0x3FF0000)>>16;
-			RX0REG0xe40[cal_num] =	(REG0xe40 & 0xfc00fc00) | (TX_X0<<16) | TX_Y0;
-			DEBUG_INFO("TX_X0 %08x TX_Y0 %08x RX0REG0xe40 %08x\n", TX_X0, TX_Y0, RX0REG0xe40[cal_num]);
-			result[0][cal_num] = TX_X0;
-			result[1][cal_num] = TX_Y0;
-		} else {
-			TX0IQKOK = FALSE;
-			if (++cal_retry >= 10) {
-				printk("%s Path-A Tx/Rx Check\n",__FUNCTION__);
-				break;
-			}
-		}
-
-		/*
-		 *	Check_RX_IQK_A_result
-		 */
-		if(TX0IQKOK == TRUE) {
-			REG0xeac = PHY_QueryBBReg(priv, 0xeac, bMaskDWord);
-			REG0xea4 = PHY_QueryBBReg(priv, 0xea4, bMaskDWord);
-			if(((REG0xeac&BIT(27)) == 0) && (((REG0xea4&0x3FF0000)>>16)!=0x132)) {
-				RX_X0 =  (PHY_QueryBBReg(priv, 0xea4, bMaskDWord)&0x3FF0000)>>16;
-				RX_Y0 =  (PHY_QueryBBReg(priv, 0xeac, bMaskDWord)&0x3FF0000)>>16;
-				DEBUG_INFO("RX_X0 %08x RX_Y0 %08x\n", RX_X0, RX_Y0);
-				result[2][cal_num] = RX_X0;
-				result[3][cal_num] = RX_Y0;
-				cal_num++;
-			} else {
-				if (++cal_retry >= 10) {
-					printk("%s Path-A Tx/Rx Check\n",__FUNCTION__);
-					break;
-				}
-			}
-		}
-	}
-
-	if (cal_num == 3) {
-		result_final[0] = get_mean_of_2_close_value(result[0]);
-		result_final[1] = get_mean_of_2_close_value(result[1]);
-		result_final[2] = get_mean_of_2_close_value(result[2]);
-		result_final[3] = get_mean_of_2_close_value(result[3]);
-		RX0REG0xe40_final = 0x80000000 | get_mean_of_2_close_value(RX0REG0xe40);
-
-		priv->pshare->RegE94=result_final[0];
-		priv->pshare->RegE9C=result_final[1];
-	} else {
-		priv->pshare->RegE94=0x100;
-		priv->pshare->RegE9C=0x00;
-	}
-
-	/*
-	 *	Fill IQK result for Path A
-	 */
-	if (result_final[0]) {
-		/*
-		Oldval_0 = (PHY_QueryBBReg(priv, 0xc80, bMaskDWord) >> 22) & 0x3FF;
-		X = result_final[0];
-		if ((X & 0x00000200) != 0)
-			X = X | 0xFFFFFC00;
-		TX0_A = (X * Oldval_0) >> 8;
-		PHY_SetBBReg(priv, 0xc80, 0x3FF, TX0_A);
-		PHY_SetBBReg(priv, 0xc4c, BIT(24), ((X* Oldval_0>>7) & 0x1));
-
-		Y = result_final[1];
-		if ((Y & 0x00000200) != 0)
-			Y = Y | 0xFFFFFC00;
-		TX0_C = (Y * Oldval_0) >> 8;
-		PHY_SetBBReg(priv, 0xc94, 0xF0000000, ((TX0_C&0x3C0)>>6));
-		PHY_SetBBReg(priv, 0xc80, 0x003F0000, (TX0_C&0x3F));
-		PHY_SetBBReg(priv, 0xc4c, BIT(26), ((Y* Oldval_0>>7) & 0x1));
-		*/
-
-		// IQK-R03 2011/02/16 update
-		X = result_final[0];
-		Y = result_final[1];
-		//printk("X=%x Y=%x\n",X,Y);
-		//Path-A OFDM_A
-		PHY_SetBBReg(priv, 0xe30, 0x03FF0000, X);
-		PHY_SetBBReg(priv, 0xc4c, BIT(24), 0);
-		//Path-A OFDM_C
-		PHY_SetBBReg(priv, 0xe30, 0x000003FF, Y);
-		PHY_SetBBReg(priv, 0xc4c, BIT(26), 0);
-
-
-		if(result_final[2]) {
-			reg = result_final[2];
-			PHY_SetBBReg(priv, 0xc14, 0x3FF, reg);
-
-			reg = result_final[3] & 0x3F;
-			PHY_SetBBReg(priv, 0xc14, 0xFC00, reg);
-
-			reg = (result_final[3] >> 6) & 0xF;
-			PHY_SetBBReg(priv, 0xca0, 0xF0000000, reg);
-		}
-	}
-
-	/*
-	 *	Path-A PA off
-	 */
-	PHY_SetBBReg(priv, 0x870, bMaskDWord, temp_870);
-	PHY_SetBBReg(priv, 0x860, bMaskDWord, temp_860);
-
-	/*
-	 *	Exit IQK mode
-	 */
-	PHY_SetBBReg(priv, 0xe28, bMaskDWord, 0);
-	PHY_SetBBReg(priv, 0xc04, bMaskDWord, temp_c04);
-	PHY_SetBBReg(priv, 0xc08, bMaskDWord, temp_c08);
-	PHY_SetBBReg(priv, 0x874, bMaskDWord, temp_874);
-	PHY_SetBBReg(priv, 0x800, bMaskDWord, temp_800);
-	PHY_SetBBReg(priv, 0x88c, bMaskDWord, temp_88c);
-	PHY_SetBBReg(priv, 0xb30, bMaskDWord, temp_b30);	// 03/03/2011 update
-	//PHY_SetBBReg(priv, 0x840, bMaskDWord, 0x00032fff);	// 01/11/2011 update
-
-	//PHY0 IQ path to DP block
-	PHY_SetBBReg(priv, 0xb00, bMaskDWord, 0x010170b8);
-
-	PHY_SetBBReg(priv, 0xc50, bMaskDWord, 0x50);
-	PHY_SetBBReg(priv, 0xc50, bMaskDWord, temp_c50);
-
-	/*
-	 *	Reload MAC default value
-	 */
-	RTL_W8(0x550, temp_550);
-	RTL_W8(0x551, temp_551);
-	RTL_W8(0x522, temp_522);
-
-	/*
-	 *	Switch back to SI if needed, after IQK
-	 */
-	if (switch2PI) {
-		PHY_SetBBReg(priv, 0x820, bMaskDWord, 0x01000000);
-		PHY_SetBBReg(priv, 0x828, bMaskDWord, 0x01000000);
-	}
-
-	/*
-	 *	Reload ADDA power saving parameters
-	 */
-	for(i = 0 ; i < IQK_ADDA_REG_NUM ; i++)
-		PHY_SetBBReg(priv, ADDA_REG[i], bMaskDWord, ADDA_backup[i]);
-}
-
-#if 0 //def CLIENT_MODE
-
-void clnt_92D_2T_AGSwitch(struct rtl8192cd_priv * priv, int target)
-{
-	unsigned int flags, i;
-	int rtStatus = 0;
-	unsigned char temp_0522, temp_0550, temp_0551, temp_0800;
-	unsigned char reg;
-
-	SAVE_INT_AND_CLI(flags);
-
-	/*
-	 * Save MAC default value
-	 */
-	temp_0522 = RTL_R8(0x522);
-	temp_0550 = RTL_R8(0x550);
-	temp_0551 = RTL_R8(0x551);
-
-	/*
-	 *	MAC register setting
-	 */
-	RTL_W8(0x522, 0x3f);
-	RTL_W8(0x550, temp_0550& (~BIT(3)));
-	RTL_W8(0x551, temp_0551& (~BIT(3)));
-
-	// stop BB
-	PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0x00f00000, 0xf);
-	temp_0800 = PHY_QueryBBReg(priv, rFPGA0_RFMOD, 0x0f000000);
-	PHY_SetBBReg(priv, rFPGA0_RFMOD, 0x0f000000, 0);
-
-	// 5G_PAPE Select & external PA power on
-	PHY_SetBBReg(priv, 0x878, BIT(0), 0);
-	PHY_SetBBReg(priv, 0x878, BIT(16), 0);
-	PHY_SetBBReg(priv, 0x878, BIT(15), 0);
-	PHY_SetBBReg(priv, 0x878, BIT(31), 0);
-	// RSSI Table Select
-	PHY_SetBBReg(priv, 0xc78, BIT(7)|BIT(6), 0);
-	// fc_area
-	PHY_SetBBReg(priv, 0xd2c, BIT(14)|BIT(13), 0);
-	// cck_enable
-	PHY_SetBBReg(priv, rFPGA0_RFMOD, bCCKEn, 0x1);
-	// LDO_DIV
-	PHY_SetRFReg(priv, RF92CD_PATH_A, 0x28, BIT(7)|BIT(6), 0);
-	PHY_SetRFReg(priv, RF92CD_PATH_B, 0x28, BIT(7)|BIT(6), 0);
-	// MOD_AG // Set channel number
-	PHY_SetRFReg(priv, RF92CD_PATH_A, 0x18, BIT(16), 0);
-	PHY_SetRFReg(priv, RF92CD_PATH_A, 0x18, BIT(8), 0);
-	PHY_SetRFReg(priv, RF92CD_PATH_B, 0x18, BIT(16), 0);
-	PHY_SetRFReg(priv, RF92CD_PATH_B, 0x18, BIT(8), 0);
- 	// CLOAD for path_A
-	PHY_SetRFReg(priv, RF92CD_PATH_A, 0xB, BIT(16)|BIT(15)|BIT(14), 0x7);
-	PHY_SetRFReg(priv, RF92CD_PATH_B, 0xB, BIT(16)|BIT(15)|BIT(14), 0x7);
-
-	// IMR
-	PHY_SetRFReg(priv, RF92CD_PATH_A, 0x00, bMask20Bits, 0x70000);
-	for (i=0;i<11;i++) {
-		PHY_SetRFReg(priv, RF92CD_PATH_A, (0x2f+i), bMask20Bits, IMR_SET_N[0][i]);
-	}
-	PHY_SetRFReg(priv, RF92CD_PATH_A, 0x00, bMask20Bits, 0x32fff);
-
-	// Enable BB
-	PHY_SetBBReg(priv, rFPGA0_RFMOD, 0x0f000000, temp_0800);
-	// IQK
-	PHY_SetBBReg(priv, 0xc80, bMaskDWord, 0x40000100);
-	PHY_SetBBReg(priv, 0xc94, bMaskByte3, 0);
-	PHY_SetBBReg(priv, 0xc4c, bMaskByte3, 0);
-	PHY_SetBBReg(priv, 0xc88, bMaskDWord, 0x40000100);
-	PHY_SetBBReg(priv, 0xc9c, bMaskByte3, 0);
-	PHY_SetBBReg(priv, 0xc14, bMaskDWord, 0x40000100);
-	PHY_SetBBReg(priv, 0xca0, bMaskByte3, 0);
-	PHY_SetBBReg(priv, 0xc1c, bMaskDWord, 0x40000100);
-	PHY_SetBBReg(priv, 0xc78, bMaskByte1, 0);
-	PHY_SetRFReg(priv, RF92CD_PATH_A, 0x08, bMask20Bits, 0x84000);
-	PHY_SetRFReg(priv, RF92CD_PATH_B, 0x08, bMask20Bits, 0x84000);
-
-	//Set related registers for BW config
-
-	PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0x00f00000, 0x0);
-
-	/*
-	 *	Reload MAC default value
-	 */
-	RTL_W8(0x550, temp_0550);
-	RTL_W8(0x551, temp_0551);
-	RTL_W8(0x522, temp_0522);
-
-	RESTORE_INT(flags);
-}
-
-#endif
-
-
-
-#ifdef SMART_CONCURRENT_92D
-/*
- *	mode - 	0: 2x2A0->1x1A0G1 (w. IQK)
- *			1: 2x2G1->1x1A0G1 (w/o IQK)
- */
-int smcc_92D_enable1x1_5G(struct rtl8192cd_priv * priv, int mode)
-{
-	unsigned int flags, i;
-	//int rtStatus = 0;
-	unsigned char temp_0522, temp_0550, temp_0551, temp_0800;
-	unsigned char temp_1522, temp_1550, temp_1551;
-	struct rtl8192cd_priv * priv0=(struct rtl8192cd_priv *)if_priv[0];
-	unsigned char reg;
-	reg = MAC_PHY_CTRL_MP;
-
-	SAVE_INT_AND_CLI(flags);
-
-	printk("%s\n",__FUNCTION__);
-	priv0->pmib->dot11RFEntry.macPhyMode = DUALMAC_DUALPHY;
-	if (mode==1){
-		priv->pmib->dot11RFEntry.macPhyMode = DUALMAC_DUALPHY;
-	}
-	priv0->pmib->dot11RFEntry.phyBandSelect = PHY_BAND_5G;
-	priv0->pshare->phw->MIMO_TR_hw_support = MIMO_1T1R;
-
-	/*
-	 * Save MAC default value
-	 */
-	temp_0522 = DMDP_RTL_R8(0, 0x522);
-	temp_0550 = DMDP_RTL_R8(0, 0x550);
-	temp_0551 = DMDP_RTL_R8(0, 0x551);
-	if (mode==1){
-		temp_1522 = DMDP_RTL_R8(1, 0x522);
-		temp_1550 = DMDP_RTL_R8(1, 0x550);
-		temp_1551 = DMDP_RTL_R8(1, 0x551);
-	}
-
-	/*
-	 *	MAC register setting
-	 */
-	DMDP_RTL_W8(0, 0x522, 0x3f);
-	DMDP_RTL_W8(0, 0x550, temp_0550& (~BIT(3)));
-	DMDP_RTL_W8(0, 0x551, temp_0551& (~BIT(3)));
-	if (mode==1){
-		DMDP_RTL_W8(1, 0x522, 0x3f);
-		DMDP_RTL_W8(1, 0x550, temp_1550& (~BIT(3)));
-		DMDP_RTL_W8(1, 0x551, temp_1551& (~BIT(3)));
-	}
-
-	// Set Dual-PHY mode
-	DMDP_RTL_W8(0, reg, RTL_R8(reg) | BIT(1));
-
-	// stop BB
-	DMDP_PHY_SetBBReg(0, rFPGA0_AnalogParameter4, 0x00f00000, 0xf);
-	if (mode==1){
-		DMDP_PHY_SetBBReg(1, rFPGA0_AnalogParameter4, 0x00f00000, 0xf);
-		//temp_0800 = DMDP_PHY_QueryBBReg(0, rFPGA0_RFMOD, 0x0f000000);
-		//DMDP_PHY_SetBBReg(0, rFPGA0_RFMOD, 0x0f000000, 0);
-	}
-
-	// Set as 1R
-	DMDP_PHY_SetBBReg(0, 0xc04, bMaskByte0, 0x11);
-	DMDP_PHY_SetBBReg(0, 0xd04, 0xf, 0x1);
-	// Set ad/da clock 1
-	DMDP_PHY_SetBBReg(0, 0x888, BIT(13)|BIT(12), 3);
-	// Set RF as 1T1R mode
-	if (mode==0){
-		DMDP_PHY_SetBBReg(0, 0xc80, bMaskDWord, 0x20000080);
-		DMDP_PHY_SetBBReg(0, 0xc94, 0xf0000000, 0);
-		DMDP_PHY_SetBBReg(0, 0xc4c, bMaskByte3, 0);
-		DMDP_PHY_SetBBReg(0, 0xc14, bMaskDWord, 0x40000100);
-		DMDP_PHY_SetBBReg(0, 0xca0, 0xf0000000, 0);
-		DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x08, bMask20Bits, 0x84000);
-		// IQK
-#ifdef DFS
-        if (!((priv->pshare->rf_ft_var.dfsdelayiqk) &&
-                (OPMODE & WIFI_AP_STATE) &&
-                !priv->pmib->dot11DFSEntry.disable_DFS &&
-                (timer_pending(&priv->ch_avail_chk_timer) ||
-                 priv->pmib->dot11DFSEntry.disable_tx)))
-#endif
-
-		IQK_92D_5G_phy0_n(priv);
-
-	}else{
-		// 5G_PAPE Select & extenal PA power on
-		DMDP_PHY_SetBBReg(0, 0x878, BIT(0), 1);
-		DMDP_PHY_SetBBReg(0, 0x878, BIT(15), 1);
-		DMDP_PHY_SetBBReg(0, 0x878, BIT(16), 1);
-
-		// RSSI Table Select
-		DMDP_PHY_SetBBReg(0, 0xc78, BIT(7)|BIT(6), 1);
-		// fc_area
-		DMDP_PHY_SetBBReg(0, 0xd2c, BIT(14)|BIT(13), (priv0->MAC_info->bb_reg[17]>>13)&0x03);
-		// cck_enable
-		DMDP_PHY_SetBBReg(1, rFPGA0_RFMOD, bCCKEn, 1);
-		DMDP_PHY_SetBBReg(0, rFPGA0_RFMOD, bCCKEn, 0);
-		// 5G LNA_On
-		DMDP_PHY_SetBBReg(0, 0xb30, 0x00f00000, 0);
-		// LDO_DIV
-		DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x28, BIT(7)|BIT(6), 1);
-		// MOD_AG // Set channel number
-		DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x18, bMask20Bits, priv0->MAC_info->rfA_reg[1]);
-	 	// CLOAD for path_A
-		DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0xB, bMask20Bits, priv0->MAC_info->rfA_reg[0]);
-
-		// IMR
-		DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x00, bMask20Bits, 0x70000);
-		for (i=0;i<11;i++) {
-			DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, (0x2f+i), bMask20Bits, priv0->MAC_info->imr[i]);
-		}
-		DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x00, bMask20Bits, priv0->MAC_info->imr[i]);
-		// Enable BB
-		//DMDP_PHY_SetBBReg(0, rFPGA0_RFMOD, 0x0f000000, temp_0800);
-
-		// IQC Setting
-		DMDP_PHY_SetBBReg(0, 0xc80, bMaskDWord, priv0->MAC_info->diqc_c80_b31b0);
-		DMDP_PHY_SetBBReg(0, 0xc94, bMaskByte3, priv0->MAC_info->diqc_c94_b31b24);
-		DMDP_PHY_SetBBReg(0, 0xc4c, 0xf0000000, priv0->MAC_info->diqc_c4c_b31b28);
-		DMDP_PHY_SetBBReg(0, 0xc14, bMaskDWord, priv0->MAC_info->diqc_c14_b31b0);
-		DMDP_PHY_SetBBReg(0, 0xca0, bMaskByte3, priv0->MAC_info->diqc_ca0_b31b24);
-		DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x08, bMask20Bits, priv0->MAC_info->loft_0A);
-		//Set related registers for BW config
-		DMDP_PHY_SetBBReg(0, 0x800, BIT(0), priv0->MAC_info->bb_reg[0]& BIT(0));
-		DMDP_PHY_SetBBReg(0, 0x900, BIT(0), priv0->MAC_info->bb_reg[6]& BIT(0));
-		DMDP_PHY_SetBBReg(0, 0xa00, BIT(4), (priv0->MAC_info->bb_reg[7]& BIT(4))>>4);
-		DMDP_PHY_SetBBReg(0, 0xd00, BIT(11)|BIT(10), (priv0->MAC_info->bb_reg[15]&(BIT(11)|BIT(10)))>>10);
-		DMDP_PHY_SetBBReg(0, 0x818, BIT(27)|BIT(26), (priv0->MAC_info->bb_reg[1]&(BIT(27)|BIT(26)))>>26);
-		DMDP_PHY_SetBBReg(0, 0x884, BIT(11) | BIT(10), (priv0->MAC_info->bb_reg[3]&(BIT(11) | BIT(10)))>>10);
-	}
-
-
-	if (mode==1){
-		priv0->pmib->dot11RFEntry.macPhyMode = DUALMAC_SINGLEPHY;
-		priv0->pshare->phw->MIMO_TR_hw_support = MIMO_2T2R;
-		priv->pmib->dot11RFEntry.macPhyMode = DUALMAC_SINGLEPHY;
-		priv->pshare->phw->MIMO_TR_hw_support = MIMO_2T2R;
-	}
-
-	DMDP_PHY_SetBBReg(0, rFPGA0_AnalogParameter4, 0x00f00000, 0x0);
-	if (mode==1){
-		DMDP_PHY_SetBBReg(1, rFPGA0_AnalogParameter4, 0x00f00000, 0x0);
-	}
-
-	/*
-	 *	Reload MAC default value
-	 */
-	DMDP_RTL_W8(0, 0x550, temp_0550);
-	DMDP_RTL_W8(0, 0x551, temp_0551);
-	DMDP_RTL_W8(0, 0x522, temp_0522);
-	if (mode==1){
-		DMDP_RTL_W8(1, 0x550, temp_1550);
-		DMDP_RTL_W8(1, 0x551, temp_1551);
-		DMDP_RTL_W8(1, 0x522, temp_1522);
-	}
-
-	RESTORE_INT(flags);
-	return 0;
-}
-
-
-int smcc_92D_enable2x2_2G(struct rtl8192cd_priv * priv)
-{
-	unsigned int flags, i;
-	int rtStatus = 0;
-	unsigned char temp_0522, temp_0550, temp_0551, temp_0800;
-	unsigned char temp_1522, temp_1550, temp_1551, temp_1800;
-	unsigned char reg;
-	struct rtl8192cd_priv * priv0=(struct rtl8192cd_priv *)if_priv[0];
-	reg = MAC_PHY_CTRL_MP;
-
-	SAVE_INT_AND_CLI(flags);
-
-	printk("%s\n",__FUNCTION__);
-	priv0->pmib->dot11RFEntry.macPhyMode = DUALMAC_SINGLEPHY;
-	priv->pmib->dot11RFEntry.macPhyMode = DUALMAC_SINGLEPHY;
-	priv0->pmib->dot11RFEntry.phyBandSelect = PHY_BAND_2G;
-
-	/*
-	 * Save MAC default value
-	 */
-	temp_0522 = DMDP_RTL_R8(0, 0x522);
-	temp_0550 = DMDP_RTL_R8(0, 0x550);
-	temp_0551 = DMDP_RTL_R8(0, 0x551);
-	temp_1522 = DMDP_RTL_R8(1, 0x522);
-	temp_1550 = DMDP_RTL_R8(1, 0x550);
-	temp_1551 = DMDP_RTL_R8(1, 0x551);
-
-	/*
-	 *	MAC register setting
-	 */
-	DMDP_RTL_W8(0, 0x522, 0x3f);
-	DMDP_RTL_W8(0, 0x550, temp_0550& (~BIT(3)));
-	DMDP_RTL_W8(0, 0x551, temp_0551& (~BIT(3)));
-	DMDP_RTL_W8(1, 0x522, 0x3f);
-	DMDP_RTL_W8(1, 0x550, temp_1550& (~BIT(3)));
-	DMDP_RTL_W8(1, 0x551, temp_1551& (~BIT(3)));
-
-	// stop BB
-	DMDP_PHY_SetBBReg(0, rFPGA0_AnalogParameter4, 0x00f00000, 0xf);
-	DMDP_PHY_SetBBReg(1, rFPGA0_AnalogParameter4, 0x00f00000, 0xf);
-	//temp_0800 = DMDP_PHY_QueryBBReg(0, rFPGA0_RFMOD, 0x0f000000);
-	//DMDP_PHY_SetBBReg(0, rFPGA0_RFMOD, 0x0f000000, 0);
-	//temp_1800 = DMDP_PHY_QueryBBReg(1, rFPGA0_RFMOD, 0x0f000000);
-	//DMDP_PHY_SetBBReg(1, rFPGA0_RFMOD, 0x0f000000, 0);
-
-	// Set Single-PHY mode
-	DMDP_RTL_W8(0, reg, RTL_R8(reg) & (~BIT(1)));
-	// Set as 2R
-	DMDP_PHY_SetBBReg(0, 0xc04, bMaskByte0, 0x33);
-	DMDP_PHY_SetBBReg(0, 0xd04, 0xf, 0x3);
-	// Set ad/da clock 1
-	DMDP_PHY_SetBBReg(0, 0x888, BIT(13)|BIT(12), 0);
-	// 5G_PAPE Select & external PA power on
-	DMDP_PHY_SetBBReg(0, 0x878, BIT(0), 0);
-	DMDP_PHY_SetBBReg(0, 0x878, BIT(15), 0);
-	DMDP_PHY_SetBBReg(0, 0x878, BIT(16), 0);
-	DMDP_PHY_SetBBReg(0, 0x878, BIT(31), 0);
-	// RSSI Table Select
-	DMDP_PHY_SetBBReg(0, 0xc78, BIT(7)|BIT(6), 0);
-	// fc_area
-	DMDP_PHY_SetBBReg(0, 0xd2c, BIT(14)|BIT(13), 0);
-	// cck_enable
-	DMDP_PHY_SetBBReg(1, rFPGA0_RFMOD, bCCKEn, 0);
-	DMDP_PHY_SetBBReg(0, rFPGA0_RFMOD, bCCKEn, 1);
-	// 5G LNA_On
-	DMDP_PHY_SetBBReg(0, 0xb30, 0x00f00000, 0xa);
-	// LDO_DIV
-	DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x28, BIT(7)|BIT(6), 0);
-	// MOD_AG // Set channel number
-	DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x18, bMask20Bits, priv->MAC_info->rfA_reg[1]);
- 	// CLOAD for path_A
-	DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0xB, BIT(16)|BIT(15)|BIT(14), 0x7);
-
-	// IMR
-	DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x00, bMask20Bits, 0x70000);
-	for (i=0;i<11;i++) {
-		DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, (0x2f+i), bMask20Bits, priv->MAC_info->imr[i]);
-	}
-	DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x00, bMask20Bits, priv->MAC_info->imr[i]);
-
-	// Enable BB
-	//DMDP_PHY_SetBBReg(0, rFPGA0_RFMOD, 0x0f000000, temp_0800);
-	//DMDP_PHY_SetBBReg(1, rFPGA0_RFMOD, 0x0f000000, temp_1800);
-	// IQK
-	DMDP_PHY_SetBBReg(0, 0xc80, bMaskDWord, 0x40000100);
-	DMDP_PHY_SetBBReg(0, 0xc94, bMaskByte3, 0);
-	DMDP_PHY_SetBBReg(0, 0xc4c, bMaskByte3, 0);
-	DMDP_PHY_SetBBReg(0, 0xc88, bMaskDWord, 0x40000100);
-	DMDP_PHY_SetBBReg(0, 0xc9c, bMaskByte3, 0);
-	DMDP_PHY_SetBBReg(0, 0xc14, bMaskDWord, 0x40000100);
-	DMDP_PHY_SetBBReg(0, 0xca0, bMaskByte3, 0);
-	DMDP_PHY_SetBBReg(0, 0xc1c, bMaskDWord, 0x40000100);
-	DMDP_PHY_SetBBReg(0, 0xc78, bMaskByte1, 0);
-	DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x08, bMask20Bits, 0x84000);
-	IQK_92D_2G(priv0);
-	//Set related registers for BW config
-	DMDP_PHY_SetBBReg(0, 0x800, BIT(0), priv->MAC_info->bb_reg[0]& BIT(0));
-	DMDP_PHY_SetBBReg(0, 0x900, BIT(0), priv->MAC_info->bb_reg[6]& BIT(0));
-	DMDP_PHY_SetBBReg(0, 0xa00, BIT(4), (priv->MAC_info->bb_reg[7]& BIT(4))>>4);
-	DMDP_PHY_SetBBReg(0, 0xd00, BIT(11)|BIT(10), (priv->MAC_info->bb_reg[15]&(BIT(11)|BIT(10)))>>10);
-	DMDP_PHY_SetBBReg(0, 0x818, BIT(27)|BIT(26), (priv->MAC_info->bb_reg[1]&(BIT(27)|BIT(26)))>>26);
-	DMDP_PHY_SetBBReg(0, 0x884, BIT(11) | BIT(10), (priv->MAC_info->bb_reg[3]&(BIT(11) | BIT(10)))>>10);
-
-	DMDP_PHY_SetBBReg(0, rFPGA0_AnalogParameter4, 0x00f00000, 0x0);
-	DMDP_PHY_SetBBReg(1, rFPGA0_AnalogParameter4, 0x00f00000, 0x0);
-
-	/*
-	 *	Reload MAC default value
-	 */
-	DMDP_RTL_W8(0, 0x550, temp_0550);
-	DMDP_RTL_W8(0, 0x551, temp_0551);
-	DMDP_RTL_W8(0, 0x522, temp_0522);
-	DMDP_RTL_W8(1, 0x550, temp_1550);
-	DMDP_RTL_W8(1, 0x551, temp_1551);
-	DMDP_RTL_W8(1, 0x522, temp_1522);
-
-	RESTORE_INT(flags);
-	return 0;
-}
-
-#if 0
-int smcc_92D_enable2x2_5G(struct rtl8192cd_priv * priv)
-{
-	unsigned int flags, val=0;
-	//int rtStatus = 0;
-	unsigned char temp_522, temp_550, temp_551;
-	unsigned char reg;
-	reg = MAC_PHY_CTRL_MP;
-
-	SAVE_INT_AND_CLI(flags);
-	priv->pmib->dot11RFEntry.macPhyMode = DUALMAC_SINGLEPHY;
-	priv->pshare->phw->MIMO_TR_hw_support = MIMO_2T2R;
-
-	/*
-	 * Save MAC default value
-	 */
-	temp_522 = RTL_R8(0x522);
-	temp_550 = RTL_R8(0x550);
-	temp_551 = RTL_R8(0x551);
-
-	/*
-	 *	MAC register setting
-	 */
-	RTL_W8(0x522, 0x3f);
-	RTL_W8(0x550, RTL_R8(0x550)& (~BIT(3)));
-	RTL_W8(0x551, RTL_R8(0x551)& (~BIT(3)));
-
-	// stop BB
-	PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0x00f00000, 0xf);
-
-	// Set Single-PHY mode
-	RTL_W8(reg, RTL_R8(reg) & (~BIT(1)));
-	// Set as 2R
-	PHY_SetBBReg(priv, 0xc04, bMaskByte0, 0x33);
-	PHY_SetBBReg(priv, 0xd04, 0xf, 0x3);
-	// Set ad/da clock 1
-	PHY_SetBBReg(priv, 0x888, BIT(13)|BIT(12), 0);
-	// Set RF as 2T2R mode
-	PHY_SetRFReg(priv, RF92CD_PATH_A, 0x38, BIT(12), 1);
-	// Reload AGC table
-	/*
-	rtStatus = PHY_ConfigBBWithParaFile(priv, AGCTAB);
-	if (rtStatus) {
-		printk("phy_BB8192CD_Config_ParaFile(): Write BB AGC Table Fail!!\n");
-		RESTORE_INT(flags);
-		return -1;
-	}
-	*/
-	// 5G_PAPE Select & external PA power on
-	PHY_SetBBReg(priv, 0x878, BIT(15), 1);
-	PHY_SetBBReg(priv, 0x878, BIT(31), 1);
-	// 1.5V_LDO
-	RTL_W32(0x14, ((RTL_R32(0x14)&0xff0fffff)|0x00d00000));
-	// LDO_DIV
-	PHY_SetRFReg(priv, RF92CD_PATH_B, 0x28, BIT(7)|BIT(6), 1);
-	// A/G mode LO buffer
-	PHY_SetRFReg(priv, RF92CD_PATH_B, 0x38, BIT(16)|BIT(15)|BIT(14), 3);
-	// MOD_AG
-	// Set channel number
-	val = PHY_QueryRFReg(priv, RF92CD_PATH_A, 0x18, bMask20Bits, 1);
-	PHY_SetRFReg(priv, RF92CD_PATH_B, 0x18, bMask20Bits, val);
-	// IMR parameter for path_A/B
-	SetIMR(priv, priv->pmib->dot11RFEntry.dot11channel);
-	PHY_SetBBReg(priv, 0xc80, bMaskDWord, 0x20000080);
-	PHY_SetBBReg(priv, 0xc94, 0xf0000000, 0);
-	PHY_SetBBReg(priv, 0xc4c, bMaskByte3, 0);
-	PHY_SetBBReg(priv, 0xc14, bMaskDWord, 0x40000100);
-	PHY_SetBBReg(priv, 0xca0, 0xf0000000, 0);
-	PHY_SetBBReg(priv, 0xc88, bMaskDWord, 0x20000080);
-	PHY_SetBBReg(priv, 0xc9c, 0xf0000000, 0);
-	PHY_SetBBReg(priv, 0xc1c, bMaskDWord, 0x40000100);
-	PHY_SetBBReg(priv, 0xc78, 0x0000f000, 0);
-	PHY_SetBBReg(priv, 0xc78, BIT(7)|BIT(6), 1);
-	PHY_SetRFReg(priv, RF92CD_PATH_A, 0x08, bMask20Bits, 0x84000);
-	PHY_SetRFReg(priv, RF92CD_PATH_B, 0x08, bMask20Bits, 0x84000);
-
-	// IQK
-	IQK_92D_5G_n(priv);
-	//Set related registers for BW config
-	SwBWMode(priv, priv->pshare->CurrentChannelBW, priv->pshare->offset_2nd_chan);
-
-	// Enable BB
-	PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0x00f00000, 0x0);
-
-	/*
-	 *	Reload MAC default value
-	 */
-	RTL_W8(0x550, temp_550);
-	RTL_W8(0x551, temp_551);
-	RTL_W8(0x522, temp_522);
-
-	RESTORE_INT(flags);
-	return 0;
-}
-
-int smcc_92D_enable2x2_2G(struct rtl8192cd_priv * priv)
-{
-	unsigned int flags;
-	int rtStatus = 0;
-	unsigned char temp_522, temp_550, temp_551;
-	unsigned char reg;
-	reg = MAC_PHY_CTRL_MP;
-
-	SAVE_INT_AND_CLI(flags);
-	priv->pmib->dot11RFEntry.macPhyMode = DUALMAC_SINGLEPHY;
-
-	/*
-	 * Save MAC default value
-	 */
-	temp_522 = RTL_R8(0x522);
-	temp_550 = RTL_R8(0x550);
-	temp_551 = RTL_R8(0x551);
-
-	/*
-	 *	MAC register setting
-	 */
-	RTL_W8(0x522, 0x3f);
-	RTL_W8(0x550, RTL_R8(0x550)& (~BIT(3)));
-	RTL_W8(0x551, RTL_R8(0x551)& (~BIT(3)));
-
-	// stop BB
-	PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0x00f00000, 0xf);
-
-	// Set Single-PHY mode
-	RTL_W8(reg, RTL_R8(reg) & (~BIT(1)));
-	// Set as 2R
-	PHY_SetBBReg(priv, 0xc04, bMaskByte0, 0x33);
-	PHY_SetBBReg(priv, 0xd04, 0xf, 0x3);
-	// Set ad/da clock 1
-	PHY_SetBBReg(priv, 0x888, BIT(13)|BIT(12), 0);
-	// Set RF as 2T2R mode
-	PHY_SetRFReg(priv, RF92CD_PATH_A, 0x38, BIT(12), 1);
-	// Reload AGC table
-	rtStatus = PHY_ConfigBBWithParaFile(priv, AGCTAB);
-	if (rtStatus) {
-		printk("phy_BB8192CD_Config_ParaFile(): Write BB AGC Table Fail!!\n");
-		RESTORE_INT(flags);
-		return -1;
-	}
-	// 5G_PAPE Select & external PA power on
-	PHY_SetBBReg(priv, 0x878, BIT(0), 0);
-	PHY_SetBBReg(priv, 0x878, BIT(15), 0);
-	PHY_SetBBReg(priv, 0x878, BIT(16), 0);
-	PHY_SetBBReg(priv, 0x878, BIT(31), 0);
-	// RSSI Table Select
-	PHY_SetBBReg(priv, 0xc78, BIT(7)|BIT(6), 0);
-	// fc_area
-	PHY_SetBBReg(priv, 0xd2c, BIT(14)|BIT(13), 0);
-	// cck_enable
-	PHY_SetBBReg(priv, rFPGA0_RFMOD, bCCKEn, 0x1);;
-	//AGC trsw threshold
-	PHY_SetBBReg(priv, 0xc70, 0x007F0000, 0x7f);
-	// 1.5V_LDO
-	RTL_W32(0x14, ((RTL_R32(0x14)&0xff0fffff)|0x00700000));
-	// LDO_DIV
-	PHY_SetRFReg(priv, RF92CD_PATH_B, 0x28, BIT(7)|BIT(6), 1);
-	// A/G mode LO buffer
-	PHY_SetRFReg(priv, RF92CD_PATH_B, 0x38, BIT(16)|BIT(15)|BIT(14), 4);
-	// MOD_AG
-	// Set channel number
-	SwBWMode(priv, priv->pshare->CurrentChannelBW, priv->pshare->offset_2nd_chan);
-	SwChnl(priv, priv->pmib->dot11RFEntry.dot11channel, priv->pshare->offset_2nd_chan);
-	// IQK
-	IQK_92D_2G(priv);
-	//Set related registers for BW config
-
-
-	// Enable BB
-	PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0x00f00000, 0x0);
-
-	/*
-	 *	Reload MAC default value
-	 */
-	RTL_W8(0x550, temp_550);
-	RTL_W8(0x551, temp_551);
-	RTL_W8(0x522, temp_522);
-
-	RESTORE_INT(flags);
-	return 0;
-}
-
-int smcc_92D_enable1x1_2G(struct rtl8192cd_priv * priv)
-{
-	struct rtl8192cd_priv *priv_phy0 = (struct rtl8192cd_priv *)if_priv[0];
-	unsigned int flags;
-	int rtStatus = 0;
-	unsigned char temp_522, temp_550, temp_551;
-	int i;
-	unsigned char reg;
-	reg = MAC_PHY_CTRL_MP;
-
-	SAVE_INT_AND_CLI(flags);
-	printk("%s %d %x\n",__FUNCTION__, __LINE__, PHY_QueryRFReg(priv, RF92CD_PATH_A, 0x18, bMask20Bits,1));
-	priv->pmib->dot11RFEntry.macPhyMode = DUALMAC_DUALPHY;
-	priv->pshare->phw->MIMO_TR_hw_support = MIMO_1T1R;
-
-	/*
-	 * Save MAC default value
-	 */
-	temp_522 = RTL_R8(0x522);
-	temp_550 = RTL_R8(0x550);
-	temp_551 = RTL_R8(0x551);
-
-	/*
-	 *	MAC register setting
-	 */
-	RTL_W8(0x522, 0x3f);
-	RTL_W8(0x550, RTL_R8(0x550)& (~BIT(3)));
-	RTL_W8(0x551, RTL_R8(0x551)& (~BIT(3)));
-
-	// stop BB
-	PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0x00f00000, 0xf);
-
-	// Set Dual-PHY mode
-	RTL_W8(reg, RTL_R8(reg) | BIT(1));
-	// Set as 1R
-	DMDP_PHY_SetBBReg(0, 0xc04, bMaskByte0, 0x11);
-	DMDP_PHY_SetBBReg(0, 0xd04, 0xf, 0x1);
-	// Set ad/da clock 1
-	DMDP_PHY_SetBBReg(0, 0x888, BIT(13)|BIT(12), 3);
-	// Set RF as 2T2R mode
-	DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x38, BIT(12), 0);
-	// Reload AGC table
-	rtStatus = PHY_ConfigBBWithParaFile(priv_phy0, AGCTAB);
-	if (rtStatus) {
-		printk("phy_BB8192CD_Config_ParaFile(): Write BB AGC Table Fail!!\n");
-		RESTORE_INT(flags);
-		return -1;
-	}
-	// 5G_PAPE Select & extenal PA power on
-	DMDP_PHY_SetBBReg(0, 0x878, BIT(0), 1);
-	DMDP_PHY_SetBBReg(0, 0x878, BIT(15), 1);
-	// RSSI Table Select
-	DMDP_PHY_SetBBReg(0, 0xc78, BIT(7)|BIT(6), 1);
-	// fc_area
-	DMDP_PHY_SetBBReg(0, 0xd2c, BIT(14)|BIT(13), 1);
-	// cck_enable
-	DMDP_PHY_SetBBReg(0, rFPGA0_RFMOD, bCCKEn, 0);
-	// AGC trsw threshold
-	DMDP_PHY_SetBBReg(0, 0xc70, 0x007F0000, 0x4e);
-	// 1.5V_LDO
-	DMDP_RTL_W32(0, 0x14, (DMDP_RTL_R32(0, 0x14)&0xff0fffff)|0x00d00000);
-	// LDO_DIV
-	DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x28, BIT(7)|BIT(6), 1);
-	PHY_SetRFReg(priv, RF92CD_PATH_A, 0x28, BIT(7)|BIT(6), 0);
-	// A/G mode LO buffer
-	DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x38, BIT(16)|BIT(15)|BIT(14), 3);
-	PHY_SetRFReg(priv, RF92CD_PATH_A, 0x38, BIT(16)|BIT(15)|BIT(14), 4);
-	// PHY0 MOD_AG //Set channel number
-	DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, rRfChannel, bMask20Bits, priv_phy0->MAC_info->rfA_reg[0]);
-	// PHY1 MOD_AG //Set channel number
-	// PHY_SetRFReg(priv, RF92CD_PATH_A, rRfChannel, bMask20Bits, priv->MAC_info->rfA_reg[0]);
-	// PHY0 IMR Path A
-	DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x00, bMask20Bits, 0x72c15);
-	for (i=0; i<10; i++) {
-		if (i==8){
-			DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, (0x30+i), bMask12Bits, priv_phy0->MAC_info->imr_rfA[i]);
-		} else if (i==9) {
-			DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, (0x30+i), bMask20Bits, priv_phy0->MAC_info->imr_rfA[i]);
-		} else {
-			DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, (0x2f+i), bMask20Bits, priv_phy0->MAC_info->imr_rfA[i]);
-		}
-	}
-	DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x00, bMask20Bits, 0x32c15);
-	// PHY1 IMR Path A
-	//PHY_SetRFReg(priv, RF92CD_PATH_A, 0x00, bMask20Bits, 0x72c15);
-	//for (i=0; i<10; i++) {
-	//	PHY_SetRFReg(priv, RF92CD_PATH_A, (0x2f+i), bMask20Bits, priv->MAC_info->imr_rfA[i]);
-	//}
-	//PHY_SetRFReg(priv, RF92CD_PATH_A, 0x00, bMask20Bits, 0x32c15);
-	// PHY0 IQC
-	DMDP_PHY_SetBBReg(0, 0xc80, bMaskDWord, priv_phy0->MAC_info->diqc_c80_b31b0);
-	DMDP_PHY_SetBBReg(0, 0xc94, 0xf0000000, priv_phy0->MAC_info->diqc_c94_b31b24);
-	DMDP_PHY_SetBBReg(0, 0xc4c, bMaskByte3, priv_phy0->MAC_info->diqc_c4c_b31b28);
-	DMDP_PHY_SetBBReg(0, 0xc14, bMaskDWord, priv_phy0->MAC_info->diqc_c14_b31b0);
-	DMDP_PHY_SetBBReg(0, 0xca0, 0xf0000000, priv_phy0->MAC_info->diqc_ca0_b31b24);
-	DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x08, bMask20Bits, priv_phy0->MAC_info->loft_0A);
-	//  PHY0 BB Enable
-	DMDP_PHY_SetBBReg(0, rFPGA0_AnalogParameter4, 0x00f00000, 0x0);
-	/*
-	 *	Reload PHY0 MAC default value
-	 */
-	DMDP_RTL_W8(0, 0x550, temp_550);
-	DMDP_RTL_W8(0, 0x551, temp_551);
-	DMDP_RTL_W8(0, 0x522, temp_522);
-
-	// PHY1 IQK
-	PHY_SetBBReg(priv, 0xc80, bMaskDWord, 0x40000100);
-	PHY_SetBBReg(priv, 0xc94, 0xf0000000, 0);
-	PHY_SetBBReg(priv, 0xc4c, bMaskByte3, 0);
-	PHY_SetBBReg(priv, 0xc14, bMaskDWord, 0x40000100);
-	PHY_SetBBReg(priv, 0xca0, 0xf0000000, 0);
-	PHY_SetRFReg(priv, RF92CD_PATH_A, 0x08, bMask20Bits, 0x84000);
-
-	IQK_92D_2G_phy1(priv);
-
-	PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0x00f00000, 0x0);
-
-	/*
-	 *	Reload MAC default value
-	 */
-	RTL_W8(0x550, temp_550);
-	RTL_W8(0x551, temp_551);
-	RTL_W8(0x522, temp_522);
-
-	printk("%s %d %x\n",__FUNCTION__, __LINE__, PHY_QueryRFReg(priv, RF92CD_PATH_A, 0x18, bMask20Bits,1));
-
-	RESTORE_INT(flags);
-	return 0;
-}
-
-#endif
-
-void smcc_92D_fill_MAC_info(struct rtl8192cd_priv * priv, struct SMCC_MAC_Info_Tbl *info_tbl)
-{
-	int i, val, imr_idx = 0;
-
-	unsigned int BB_IDX[18] = {0x800, 0x818, 0x878, 0x884, 0x888, 0x88C, 0x900, 0xA00, 0xC04,
-								0xC4C, 0xC70, 0xC78, 0xC94, 0xC9C, 0xCA0, 0xD00, 0xD04, 0xD2C};
-	unsigned int RF_IDX[3] = {0x0B, 0x18, 0x28};
-
-	info_tbl->channel = PHY_QueryRFReg(priv, RF92CD_PATH_A, 0x18, bMaskByte0, 1);;
-	info_tbl->bandwidth = priv->pshare->CurrentChannelBW;
-	if (priv->pshare->CurrentChannelBW == HT_CHANNEL_WIDTH_20_40) {
-		if (priv->pshare->offset_2nd_chan == 1)
-			info_tbl->bandwidth |= BIT(2); // control upper, 2nd below
-		else
-			info_tbl->bandwidth |= BIT(1); // control lower, 2nd upper
-	}
-	if (priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY) {
-		// Single PHY IQC 		Byte 2~22
-		info_tbl->siqc_c80_b31b0 = DMDP_PHY_QueryBBReg(0, 0xc80, bMaskDWord);
-		info_tbl->siqc_c94_b31b24 = DMDP_PHY_QueryBBReg(0, 0xc94, bMaskByte3);
-		info_tbl->siqc_c4c_b31b24 = DMDP_PHY_QueryBBReg(0, 0xc4c, bMaskByte3);
-		info_tbl->siqc_c88_b31b0 = DMDP_PHY_QueryBBReg(0, 0xc88, bMaskDWord);
-		info_tbl->siqc_c9c_b31b24 = DMDP_PHY_QueryBBReg(0, 0xc9c, bMaskByte3);
-		info_tbl->siqc_c14_b31b0 = DMDP_PHY_QueryBBReg(0, 0xc14, bMaskDWord);
-		info_tbl->siqc_ca0_b31b24 = DMDP_PHY_QueryBBReg(0, 0xca0, bMaskByte3);
-		info_tbl->siqc_c1c_b31b0 = DMDP_PHY_QueryBBReg(0, 0xc1c, bMaskDWord);
-		info_tbl->siqc_c78_b15b8 = DMDP_PHY_QueryBBReg(0, 0xc78, bMaskByte1);
-	}else{
-		// Dual PHY IQC		Byte 23~33
-		info_tbl->diqc_c80_b31b0 = PHY_QueryBBReg(priv, 0xc80, bMaskDWord);
-		info_tbl->diqc_c94_b31b24 = PHY_QueryBBReg(priv, 0xc94, bMaskByte3);
-		info_tbl->diqc_c4c_b31b28 = PHY_QueryBBReg(priv, 0xc4c, 0xf0000000);
-		info_tbl->diqc_c14_b31b0 = PHY_QueryBBReg(priv, 0xc14, bMaskDWord);
-		info_tbl->diqc_ca0_b31b24 = PHY_QueryBBReg(priv, 0xca0, bMaskByte3);
-	}
-
-	if (priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY) {
-		// 0_B LOFT			Byte 115
-		info_tbl->loft_0B = DMDP_PHY_QueryRFReg(0, RF92CD_PATH_B, 0x08, bMask20Bits, 1);
-		// RF_reg			Byte 206~217
-		for (i = 0; i<3; i++)
-			info_tbl->rfB_reg[i] = DMDP_PHY_QueryRFReg(0, RF92CD_PATH_B, RF_IDX[i], bMask20Bits, 1);
-		//
-	}	else {
-		val = info_tbl->channel;
-		if (priv->pmib->dot11RFEntry.phyBandSelect==PHY_BAND_2G)
-			imr_idx = 0;
-		else {
-			if (val>=36 && val <=64)
-				imr_idx = 1;
-			else
-				imr_idx = 2;
-		}
-		// IMR				Byte 34~73
-		for (i = 0; i<11; i++)
-			info_tbl->imr[i] = IMR_SET_N[imr_idx][i];
-		if (imr_idx==0)
-			info_tbl->imr[11] = 0x32fff;
-		else
-			info_tbl->imr[11] = 0x32c9a;
-
-		// 0_A LOFT			Byte 114
-		info_tbl->loft_0A = PHY_QueryRFReg(priv, RF92CD_PATH_A, 0x08, bMask20Bits, 1);
-		// BB_reg			Byte 122~193
-		for (i = 0; i<18; i++)
-			info_tbl->bb_reg[i] = PHY_QueryBBReg(priv, BB_IDX[i], bMaskDWord);
-		// RF_reg			Byte 194~205
-		for (i = 0; i<3; i++)
-			info_tbl->rfA_reg[i] = PHY_QueryRFReg(priv, RF92CD_PATH_A, RF_IDX[i], bMask20Bits, 1);
-	}
-}
-
-void smcc_dump_MAC_info(struct rtl8192cd_priv * priv, struct SMCC_MAC_Info_Tbl *info_tbl)
-{
-	int i, flags;
-
-	unsigned int BB_IDX[18] = {0x800, 0x818, 0x878, 0x884, 0x888, 0x88C, 0x900, 0xA00, 0xC04,
-								0xC4C, 0xC70, 0xC78, 0xC94, 0xC9C, 0xCA0, 0xD00, 0xD04, 0xD2C};
-	unsigned int RF_IDX[3] = {0x0B, 0x18, 0x28};
-
-	SAVE_INT_AND_CLI(flags);
-
-	printk("info_tbl->channel = %d \n", info_tbl->channel);
-	printk("info_tbl->bandwidth = %x \n", info_tbl->bandwidth);
-	printk("info_tbl->siqc_c80_b31b0 = %x \n", info_tbl->siqc_c80_b31b0);
-	printk("info_tbl->siqc_c94_b31b24 = %x \n", info_tbl->siqc_c94_b31b24);
-	printk("info_tbl->siqc_c4c_b31b24 = %x \n", info_tbl->siqc_c4c_b31b24);
-	printk("info_tbl->siqc_c88_b31b0 = %x \n", info_tbl->siqc_c88_b31b0);
-	printk("info_tbl->siqc_c9c_b31b24 = %x \n", info_tbl->siqc_c9c_b31b24);
-	printk("info_tbl->siqc_c14_b31b0 = %x \n", info_tbl->siqc_c14_b31b0);
-	printk("info_tbl->siqc_ca0_b31b24 = %x \n", info_tbl->siqc_ca0_b31b24);
-	printk("info_tbl->siqc_c1c_b31b0 = %x \n", info_tbl->siqc_c1c_b31b0);
-	printk("info_tbl->siqc_c78_b15b8 = %x \n", info_tbl->siqc_c78_b15b8);
-	printk("info_tbl->diqc_c80_b31b0 = %x \n", info_tbl->diqc_c80_b31b0);
-	printk("info_tbl->diqc_c94_b31b24 = %x \n", info_tbl->diqc_c94_b31b24);
-	printk("info_tbl->diqc_c4c_b31b28 = %x \n", info_tbl->diqc_c4c_b31b28);
-	printk("info_tbl->diqc_c14_b31b0 = %x \n", info_tbl->diqc_c14_b31b0);
-	printk("info_tbl->diqc_ca0_b31b24 = %x \n", info_tbl->diqc_ca0_b31b24);
-
-	for (i = 0; i<12; i++)
-		printk("info_tbl->imr[%d] = %x \n", i, info_tbl->imr[i]);
-
-	printk("info_tbl->loft_0A = %x \n", info_tbl->loft_0A);
-	printk("info_tbl->loft_0B = %x \n", info_tbl->loft_0B);
-
-	for (i = 0; i<18; i++)
-		printk("info_tbl->bb_reg[%d](0x%2x) = %x \n", i, BB_IDX[i], info_tbl->bb_reg[i]);
-	for (i = 0; i<3; i++)
-		printk("info_tbl->rfA_reg[%d](0x%2x) = %x \n", i, RF_IDX[i], info_tbl->rfA_reg[i]);
-	for (i = 0; i<3; i++)
-		printk("info_tbl->rfB_reg[%d](0x%2x) = %x \n", i, RF_IDX[i], info_tbl->rfB_reg[i]);
-
-
-	RESTORE_INT(flags);
-}
-
-void smcc_signin_MAC_info(struct rtl8192cd_priv * priv, struct SMCC_MAC_Info_Tbl *info_tbl)
-{
-	unsigned long flags;
-	unsigned int content = 0, info_idx;
-	int count = 10;
-
-	SAVE_INT_AND_CLI(flags);
-
-	RTL_W8(0x422, RTL_R8(0x422)&(~BIT(6)));
-	RTL_W8(0x662, RTL_R8(0x662)&(~BIT(0)));
-
-	signin_beacon_desc(priv, (unsigned int *)info_tbl, sizeof(struct SMCC_MAC_Info_Tbl));
-
-	/*
-	 * BCN_HEAD
-	 */
-	content |= (RTL_R16(TDECTRL)>>8)<<16;
-
-	/*
-	 * Info_idx: Test chip = 0; MP chip = 1
-	 */
- 	info_idx = 0;
-	content |= info_idx << 8;
-
-	/*
-	 * set cmd id
-	 */
-	content |= H2C_CMD_INFO_PKT;
-
-	signin_h2c_cmd(priv, content, 0);
-
-	while (count > 0){
-		if (RTL_R8(0x662) & BIT(0)) {
-			RTL_W8(0x422, RTL_R8(0x422)|BIT(6));
-			printk("SMCC signin MAC info success!\n");
-			break;
-		}
-		count--;
-		delay_ms(5);
-	}
-
-	if (count <= 0)
-		printk("SMCC signin MAC info FAIL!\n");
-
-	#if 0
-		/*
-		 *	MAC register setting
-		 */
-		RTL_W8(0x522, 0x3f);
-		RTL_W8(0x550, RTL_R8(0x550)& (~BIT(3)));
-		RTL_W8(0x551, RTL_R8(0x551)& (~BIT(3)));
-
-		// stop BB
-		PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0x00f00000, 0xf);
-	#endif
-
-	RESTORE_INT(flags);
-}
-
-/*
- En : 1 for enable, 0 for disable
- DMDP_Duration : valid while Mode = 1. The unit is 4ms.
- MODE : 00b for static mode , 01b for preserve mode, 10b and 11b are reserved
- PSV : valid while mode = 1. set 1 for RF resource preservation request
- AP / STA : 0 for AP, 1 for STA
- LINK_STATE : valid while Mode = 0.  0 for no any link, 1 for link exist
- */
-void smcc_signin_linkstate(struct rtl8192cd_priv * priv, unsigned char enable, unsigned char duration, unsigned char link_state)
-{
-	unsigned long flags;
-	unsigned int content = 0;
-
-	printk(">>>> [wlan-%d] %s en=%d, du=%d, st=%d.\n", priv->pshare->wlandev_idx, __FUNCTION__, enable, duration, link_state);
-
-	SAVE_INT_AND_CLI(flags);
-
-	// Link State
-	content |= (link_state & BIT(0))<< 21;
-
-	// Enable
-	content |= (enable & BIT(0)) << 16;
-
-	// DMDP_Duration
-	content |= duration << 8;
-	// set cmd id
-	content |= H2C_CMD_SMCC;
-
-	signin_h2c_cmd(priv, content, 0);
-
-	RESTORE_INT(flags);
-}
-
-#endif // SMART_CONCURRENT_92D
-#endif //CONFIG_RTL_92D_DMDP
-
-#endif // CONFIG_RTL_92D_SUPPORT
-
-
-
+
+#define _8192D_HW_C_
+
+#ifdef __KERNEL__
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+#include <asm/unistd.h>
+#include <linux/synclink.h>
+#endif
+
+#include "./8192cd_cfg.h"
+#include "./8192cd.h"
+#include "./8192cd_hw.h"
+#include "./8192cd_headers.h"
+#include "./8192cd_debug.h"
+
+
+#ifdef CONFIG_RTL_92D_SUPPORT
+
+#if defined(CONFIG_RTL_819X) && defined(USE_RLX_BSP)
+#include <bsp/bspchip.h>
+#endif
+
+#ifndef REG32
+	#define REG32(reg)	 		(*(volatile unsigned int *)(reg))
+#endif
+
+#ifdef CONFIG_NET_PCI
+        #define BSP_WDTCNR 0xB800311C
+#endif
+
+
+#define IQK_ADDA_REG_NUM 16
+
+
+#ifdef CONFIG_RTL_92D_DMDP
+
+extern u32 if_priv[];
+
+__inline__ unsigned char DMDP_RTL_R8(unsigned int phy, unsigned int reg)
+{
+	struct rtl8192cd_priv *priv;
+	//printk("++++++++++++++++++++++++++%s(%x)++++++++++++++++++++++++++\n", __FUNCTION__, reg);
+	if (phy >= NUM_WLAN_IFACE || phy < 0) {
+		printk("%s: phy index[%d] out of bound !!\n", __FUNCTION__, phy);
+		return -1;
+	}
+	priv = (struct rtl8192cd_priv *)if_priv[phy];
+	return RTL_R8(reg);
+}
+
+__inline__ void DMDP_RTL_W8(unsigned int phy, unsigned int reg, unsigned char val8)
+{
+	struct rtl8192cd_priv *priv;
+	//printk("++++++++++++++++++++++++++%s(%x,%x)++++++++++++++++++++++++++\n", __FUNCTION__, reg, val8);
+	if (phy >= NUM_WLAN_IFACE || phy < 0) {
+		printk("%s: phy index[%d] out of bound !!\n", __FUNCTION__, phy);
+		return;
+	}
+	priv = (struct rtl8192cd_priv *)if_priv[phy];
+	RTL_W8(reg, val8);
+}
+
+__inline__ unsigned short DMDP_RTL_R16(unsigned int phy, unsigned int reg)
+{
+	struct rtl8192cd_priv *priv;
+	//printk("++++++++++++++++++++++++++%s++++++++++++++++++++++++++\n", __FUNCTION__);
+	if (phy >= NUM_WLAN_IFACE || phy < 0) {
+		printk("%s: phy index[%d] out of bound !!\n", __FUNCTION__, phy);
+		return -1;
+	}
+	priv = (struct rtl8192cd_priv *)if_priv[phy];
+	return RTL_R16(reg);
+}
+
+__inline__ void DMDP_RTL_W16(unsigned int phy, unsigned int reg, unsigned short val16)
+{
+	struct rtl8192cd_priv *priv;
+	//printk("++++++++++++++++++++++++++%s++++++++++++++++++++++++++\n", __FUNCTION__);
+	if (phy >= NUM_WLAN_IFACE || phy < 0) {
+		printk("%s: phy index[%d] out of bound !!\n", __FUNCTION__, phy);
+		return;
+	}
+	priv = (struct rtl8192cd_priv *)if_priv[phy];
+	RTL_W16(reg, val16);
+}
+
+__inline__ unsigned int DMDP_RTL_R32(unsigned int phy, unsigned int reg)
+{
+	struct rtl8192cd_priv *priv;
+	//printk("++++++++++++++++++++++++++%s(%x)++++++++++++++++++++++++++\n", __FUNCTION__, reg);
+	if (phy >= NUM_WLAN_IFACE || phy < 0) {
+		printk("%s: phy index[%d] out of bound !!\n", __FUNCTION__, phy);
+		return -1;
+	}
+	priv = (struct rtl8192cd_priv *)if_priv[phy];
+	return RTL_R32(reg);
+}
+
+__inline__ void DMDP_RTL_W32(unsigned int phy, unsigned int reg, unsigned int val32)
+{
+	struct rtl8192cd_priv *priv;
+	//printk("++++++++++++++++++++++++++%s(%x, %x)++++++++++++++++++++++++++\n", __FUNCTION__, reg, val32);
+	if (phy >= NUM_WLAN_IFACE || phy < 0) {
+		printk("%s: phy index[%d] out of bound !!\n", __FUNCTION__, phy);
+		return;
+	}
+	priv = (struct rtl8192cd_priv *)if_priv[phy];
+	RTL_W32(reg, val32);
+}
+
+unsigned int DMDP_PHY_QueryBBReg(unsigned int phy, unsigned int RegAddr, unsigned int BitMask)
+{
+	//printk("++++++++++++++++++++++++++%s++++++++++++++++++++++++++\n", __FUNCTION__);
+	if (phy >= NUM_WLAN_IFACE || phy < 0) {
+		printk("%s: phy index[%d] out of bound !!\n", __FUNCTION__, phy);
+		return -1;
+	}
+	return PHY_QueryBBReg((struct rtl8192cd_priv *)if_priv[phy], RegAddr, BitMask);
+}
+
+void DMDP_PHY_SetBBReg(unsigned int phy, unsigned int RegAddr, unsigned int BitMask, unsigned int Data)
+{
+	//printk("++++++++++++++++++++++++++%s++++++++++++++++++++++++++\n", __FUNCTION__);
+	if (phy >= NUM_WLAN_IFACE || phy < 0) {
+		printk("%s: phy index[%d] out of bound !!\n", __FUNCTION__, phy);
+		return;
+	}
+	PHY_SetBBReg((struct rtl8192cd_priv *)if_priv[phy], RegAddr, BitMask, Data);
+}
+
+unsigned int DMDP_PHY_QueryRFReg(unsigned int phy, RF92CD_RADIO_PATH_E eRFPath,
+				unsigned int RegAddr, unsigned int BitMask, unsigned int dbg_avoid)
+{
+	//printk("++++++++++++++++++++++++++%s++++++++++++++++++++++++++\n", __FUNCTION__);
+	if (phy >= NUM_WLAN_IFACE || phy < 0) {
+		printk("%s: phy index[%d] out of bound !!\n", __FUNCTION__, phy);
+		return -1;
+	}
+	return PHY_QueryRFReg((struct rtl8192cd_priv *)if_priv[phy], eRFPath, RegAddr, BitMask, dbg_avoid);
+}
+
+void DMDP_PHY_SetRFReg(unsigned int phy, RF92CD_RADIO_PATH_E eRFPath, unsigned int RegAddr,
+				unsigned int BitMask, unsigned int Data)
+{
+	//printk("++++++++++++++++++++++++++%s++++++++++++++++++++++++++\n", __FUNCTION__);
+	if (phy >= NUM_WLAN_IFACE || phy < 0) {
+		printk("%s: phy index[%d] out of bound !!\n", __FUNCTION__, phy);
+		return;
+	}
+	PHY_SetRFReg((struct rtl8192cd_priv *)if_priv[phy], eRFPath, RegAddr, BitMask, Data);
+}
+
+#endif //CONFIG_RTL_92D_DMDP
+
+void SetSYN_para(struct rtl8192cd_priv *priv, unsigned char channel)
+{
+	unsigned int eRFPath, tmp=0;
+	unsigned int idx=-1, i;
+	unsigned int SYN_PARA[8][8] = {
+		{0xe43be, 0xfc638, 0x77c0a, 0xde471, 0xd7110, 0x8cb04, 0x00000, 0x00000},	// CH36-140 20MHz
+		{0xe43be, 0xfc078, 0xf7c1a, 0xe0c71, 0xd7550, 0xacb04, 0x00000, 0x00000},	// CH36-140 40MHz
+		{0xe43bf, 0xff038, 0xf7c0a, 0xde471, 0xe5550, 0xacb04, 0x00000, 0x00000},	// CH149, 155, 161
+		{0xe43bf, 0xff079, 0xf7c1a, 0xde471, 0xe5550, 0xacb04, 0x00000, 0x00000},	// CH151, 153, 163, 165
+		{0xe43bf, 0xff038, 0xf7c1a, 0xde471, 0xd7550, 0xacb04, 0x00000, 0x00000},	// CH157, 159
+#ifdef SW_LCK_92D
+		{0x643bc, 0xfc038, 0x77c1a, 0x00000, 0x00000, 0x00000, 0x61289, 0x01840},	// CH1,2,4,9,10,11,12
+		{0x643bc, 0xfc038, 0x07c1a, 0x00000, 0x00000, 0x00000, 0x61289, 0x01840},	// CH3,13,14
+		{0x243bc, 0xfc438, 0x07c1a, 0x00000, 0x00000, 0x00000, 0x6128b, 0x0fc41}	// CH5-8
+#else
+		{0x643bc, 0xfc038, 0x77c1a, 0x00000, 0x00000, 0x00000, 0x41289, 0x01840},	// CH1,2,4,9,10,11,12
+		{0x643bc, 0xfc038, 0x07c1a, 0x00000, 0x00000, 0x00000, 0x41289, 0x01840},	// CH3,13,14
+		{0x243bc, 0xfc438, 0x07c1a, 0x00000, 0x00000, 0x00000, 0x4128b, 0x0fc41}	// CH5-8
+#endif
+	};
+
+
+	if (priv->pmib->dot11RFEntry.phyBandSelect==PHY_BAND_2G)
+		eRFPath = RF92CD_PATH_B;
+	else
+		eRFPath = RF92CD_PATH_A;
+
+	if (priv->pmib->dot11RFEntry.phyBandSelect==PHY_BAND_5G){
+		if (channel >=36 && channel <=140){
+			if (!priv->pshare->CurrentChannelBW)
+				idx = 0;
+			else
+				idx = 1;
+		}
+		else if (channel==149 || channel==155 || channel==161)
+			idx = 2;
+		else if (channel==151 || channel==153 || channel==163 || channel==165)
+			idx = 3;
+		else if (channel==157 || channel==159)
+			idx = 4;
+	} else {
+		if (channel==1 || channel==2 || channel==4 || channel==9 || channel==10 || channel==11 || channel==12)
+			idx = 5;
+		else if (channel==3 || channel==13 || channel==14)
+			idx = 6;
+		else if (channel>=5 && channel<=8)
+			idx = 7;
+	}
+
+	if (idx==-1){
+		DEBUG_ERR("No suitable channel (%d) for setting synthersizer parameter!\n", channel);
+		return;
+	}
+
+	for (i=0;i<8;i++){
+#ifdef CONFIG_RTL_92D_DMDP
+		if (i==0 && (idx>=0 && idx <=4) &&
+			(priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY))
+			tmp = 0xe439d;
+		else
+#endif
+			tmp = SYN_PARA[idx][i];
+
+		if (tmp!=0) {
+
+#ifdef CONFIG_RTL_92D_DMDP
+			if (priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY && eRFPath == RF92CD_PATH_B) {
+				DMDP_PHY_SetRFReg(1, RF92CD_PATH_A, (0x25+i), bMask20Bits, tmp);
+				//DEBUG_TRACE("DMDP_PHY_SetRFReg(1, %d, 0x%x, bMask20Bits, 0x%x)\n", eRFPath, (0x25+i), tmp);
+			} else
+#endif
+			{
+				PHY_SetRFReg(priv, eRFPath, (0x25+i), bMask20Bits, tmp);
+				//DEBUG_TRACE("PHY_SetRFReg(priv, %d, 0x%x, bMask20Bits, 0x%x)\n", eRFPath, (0x25+i), tmp);
+			}
+			if (i==3)
+				priv->pshare->RegRF28[eRFPath] = tmp;
+		}
+	}
+}
+
+unsigned int IMR_SET_N[3][11] = {
+  {0x00ff0, 0x4400f, 0x00ff0, 0x00000, 0x00000, 0x00000, 0x00000, 0x00000, 0x64888, 0xe266c, 0x00090}, //G-mode
+  {0x22880, 0x4470f, 0x55880, 0x00070, 0x88000, 0x00000, 0x88080, 0x70000, 0x64a82, 0xe466c, 0x00090}, //36-64
+  {0x44880, 0x4477f, 0x77880, 0x00070, 0x88000, 0x00000, 0x880b0, 0x00000, 0x64b82, 0xe466c, 0x00090}, // 100-165
+};
+
+void SetIMR_n(struct rtl8192cd_priv *priv, unsigned char channel)
+{
+	unsigned int eRFPath, curMaxRFPath;
+	int imr_idx = -1;
+	unsigned char temp_800;
+
+#ifdef CONFIG_RTL_92D_DMDP
+	if (priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY)
+		curMaxRFPath = RF92CD_PATH_B;
+	else
+#endif
+		curMaxRFPath = RF92CD_PATH_MAX;
+
+	if (priv->pmib->dot11RFEntry.phyBandSelect==PHY_BAND_2G)
+		imr_idx = 0;
+	else {
+		if (channel>=36 && channel <=64)
+			imr_idx = 1;
+		else
+			imr_idx = 2;
+	}
+	PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0x00f00000, 0xf);
+	temp_800 = PHY_QueryBBReg(priv, rFPGA0_RFMOD, 0x0f000000);
+	PHY_SetBBReg(priv, rFPGA0_RFMOD, 0x0f000000, 0);
+
+	for(eRFPath = RF92CD_PATH_A; eRFPath < curMaxRFPath; eRFPath++) {
+		int i;
+
+		PHY_SetRFReg(priv, eRFPath, 0x00, bMask20Bits, 0x70000);
+		//DEBUG_TRACE("IMR [0x00] %05x\n", PHY_QueryRFReg(priv, eRFPath, 0x00, bMask20Bits,1));
+		//delay_us(5);
+
+		for (i=0;i<11;i++) {
+			PHY_SetRFReg(priv, eRFPath, (0x2f+i), bMask20Bits, IMR_SET_N[imr_idx][i]);
+			//DEBUG_TRACE("IMR [0x%x] %05x\n", (0x2f+i), PHY_QueryRFReg(priv, eRFPath, (0x2f+i), bMask20Bits,1));
+			//delay_us(5);
+		}
+
+		if (priv->pmib->dot11RFEntry.phyBandSelect==PHY_BAND_2G)
+			PHY_SetRFReg(priv, eRFPath, 0x00, bMask20Bits, 0x32fff);
+		else
+			PHY_SetRFReg(priv, eRFPath, 0x00, bMask20Bits, 0x32c9a);
+
+		//DEBUG_TRACE("IMR [0x00] %05x\n", PHY_QueryRFReg(priv, eRFPath, 0x00, bMask20Bits,1));
+		//delay_us(5);
+	}
+
+	PHY_SetBBReg(priv, rFPGA0_RFMOD, 0x0f000000, temp_800);
+	PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0x00f00000, 0x0);
+}
+
+
+/*
+ *  Follow WS-20101228-Willis-xxxx dynamic parameter-R00
+ */
+void Update92DRFbyChannel(struct rtl8192cd_priv *priv, unsigned char channel)
+{
+#ifdef RTL8192D_INT_PA
+	u8	eRFPath = 0, curMaxRFPath;
+	if (priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY)
+		curMaxRFPath = RF92CD_PATH_B;
+	else
+		curMaxRFPath = RF92CD_PATH_MAX;
+
+	if (priv->pshare->rf_ft_var.use_intpa92d){
+		for(eRFPath = RF92CD_PATH_A; eRFPath <curMaxRFPath; eRFPath++) {
+			if (priv->pmib->dot11RFEntry.phyBandSelect==PHY_BAND_5G){
+				if (channel>=36 && channel<=64){
+					PHY_SetRFReg(priv, eRFPath, 0x0b, bMask20Bits, 0x01a00);
+					PHY_SetRFReg(priv, eRFPath, 0x48, bMask20Bits, 0x40443);
+					PHY_SetRFReg(priv, eRFPath, 0x49, bMask20Bits, 0x00eb5);
+					//PHY_SetRFReg(priv, eRFPath, 0x4a, bMask20Bits, 0x50f0f);
+					PHY_SetRFReg(priv, eRFPath, 0x4b, bMask20Bits, 0x89bec);
+					//PHY_SetRFReg(priv, eRFPath, 0x4c, bMask20Bits, 0x0dded);
+					PHY_SetRFReg(priv, eRFPath, 0x03, bMask20Bits, 0x94a12);
+					PHY_SetRFReg(priv, eRFPath, 0x04, bMask20Bits, 0x94a12);
+					PHY_SetRFReg(priv, eRFPath, 0x0e, bMask20Bits, 0x94a12);
+				}else if (channel>=100 && channel<=140){
+					PHY_SetRFReg(priv, eRFPath, 0x0b, bMask20Bits, 0x01800);
+					PHY_SetRFReg(priv, eRFPath, 0x48, bMask20Bits, 0xc0443);
+					PHY_SetRFReg(priv, eRFPath, 0x49, bMask20Bits, 0x00730);
+					//PHY_SetRFReg(priv, eRFPath, 0x4a, bMask20Bits, 0x50f0f);
+					PHY_SetRFReg(priv, eRFPath, 0x4b, bMask20Bits, 0x896ee);
+					//PHY_SetRFReg(priv, eRFPath, 0x4c, bMask20Bits, 0x0dded);
+					PHY_SetRFReg(priv, eRFPath, 0x03, bMask20Bits, 0x94a52);
+					PHY_SetRFReg(priv, eRFPath, 0x04, bMask20Bits, 0x94a52);
+					PHY_SetRFReg(priv, eRFPath, 0x0e, bMask20Bits, 0x94a52);
+				}else if (channel>=149 && channel<=165){
+					PHY_SetRFReg(priv, eRFPath, 0x0b, bMask20Bits, 0x01800);
+					PHY_SetRFReg(priv, eRFPath, 0x48, bMask20Bits, 0xc0443);
+					PHY_SetRFReg(priv, eRFPath, 0x49, bMask20Bits, 0x00730);
+					//PHY_SetRFReg(priv, eRFPath, 0x4a, bMask20Bits, 0x50f0f);
+					PHY_SetRFReg(priv, eRFPath, 0x4b, bMask20Bits, 0x896ee);
+					//PHY_SetRFReg(priv, eRFPath, 0x4c, bMask20Bits, 0x0dded);
+					PHY_SetRFReg(priv, eRFPath, 0x03, bMask20Bits, 0x94a12);
+					PHY_SetRFReg(priv, eRFPath, 0x04, bMask20Bits, 0x94a12);
+					PHY_SetRFReg(priv, eRFPath, 0x0e, bMask20Bits, 0x94a12);
+				}
+			}else{
+					PHY_SetRFReg(priv, eRFPath, 0x0b, bMask20Bits, 0x1c000);
+					PHY_SetRFReg(priv, eRFPath, 0x03, bMask20Bits, 0x18c63);
+					PHY_SetRFReg(priv, eRFPath, 0x04, bMask20Bits, 0x18c63);
+					PHY_SetRFReg(priv, eRFPath, 0x0e, bMask20Bits, 0x18c67);
+			}
+		}
+	}
+#endif
+
+	if (priv->pmib->dot11RFEntry.phyBandSelect==PHY_BAND_5G){
+		//update fc_area
+		if (priv->pmib->dot11RFEntry.dot11channel<149)
+			PHY_SetBBReg(priv, rOFDM1_CFOTracking, BIT(14) | BIT(13), 1);
+		else
+			PHY_SetBBReg(priv, rOFDM1_CFOTracking, BIT(14) | BIT(13), 2);
+		// VCO_BF_LDO= 1.12V->1.27V for  40M spur issue
+		PHY_SetRFReg(priv, RF92CD_PATH_A, 0x2A, BIT(13)|BIT(12), 2);
+		// RX Ch36 40M spurs
+		if (channel==36){
+			priv->pshare->RegRF28[RF92CD_PATH_A] &= (~BIT(6));
+			priv->pshare->RegRF28[RF92CD_PATH_A] |= BIT(5);
+			PHY_SetRFReg(priv, RF92CD_PATH_A, 0x28, bMask20Bits, priv->pshare->RegRF28[RF92CD_PATH_A]);
+			//PHY_SetRFReg(priv, RF92CD_PATH_A, 0x28, BIT(6)|BIT(5), 0);
+		}
+	} else {
+		//update fc_area
+		PHY_SetBBReg(priv, rOFDM1_CFOTracking, BIT(14) | BIT(13), 0);
+	}
+
+}
+
+int Load_92D_Firmware(struct rtl8192cd_priv *priv)
+{
+	int fw_len, wait_cnt=0;
+	unsigned int CurPtr=0;
+	unsigned int WriteAddr;
+	unsigned int Temp;
+	unsigned char *ptmp;
+	unsigned long flags = 0;
+
+#ifdef CONFIG_RTL8672
+	printk("val=%x\n",RTL_R8(0x80));
+#endif
+
+#ifdef MP_TEST
+	if (priv->pshare->rf_ft_var.mp_specific)
+		return TRUE;
+#endif
+
+	printk("===> %s\n", __FUNCTION__);
+
+	SAVE_INT_AND_CLI(flags);
+
+	printk("Firmware check %x(%x)\n", RTL_R32(MCUFWDL), (RTL_R8(MCUFWDL) & MCUFWDL_RDY));
+	if (RTL_R8(MCUFWDL) & MCUFWDL_RDY){
+		printk("<=== Firmware Downloaded\n");
+		goto check_fwdl_rdy;
+	}
+
+	wait_cnt=0;
+	while(RTL_R8(RF_CTRL) & FW_DL_INPROC){
+		wait_cnt++;
+		delay_ms(50);
+	}
+
+#ifdef CONFIG_RTL_92D_DMDP
+	if (wait_cnt==0) {
+		if (priv->pshare->wlandev_idx == 0)
+			RTL_W8(RF_CTRL, RTL_R8(RF_CTRL)|FW_DL_INPROC);
+		else {
+			if (RTL_R8(RSV_MAC0_CTRL) & MAC0_EN)
+				goto check_fwdl_rdy;
+			else
+				RTL_W8(RF_CTRL, RTL_R8(RF_CTRL)|FW_DL_INPROC);
+		}
+	} else {
+		if (RTL_R8(MCUFWDL) & MCUFWDL_RDY){
+			printk("<=== Firmware Downloaded\n");
+			RESTORE_INT(flags);
+			return TRUE;
+		}else{
+			RTL_W8(RF_CTRL, RTL_R8(RF_CTRL)|FW_DL_INPROC);
+		}
+	}
+#else
+	if (wait_cnt==0) {
+		RTL_W8(RF_CTRL, RTL_R8(RF_CTRL)|FW_DL_INPROC);
+	} else {
+		if (RTL_R8(MCUFWDL) & MCUFWDL_RDY){
+			printk("<=== Firmware Downloaded\n");
+			RESTORE_INT(flags);
+			return TRUE;
+		}else{
+			RTL_W8(RF_CTRL, RTL_R8(RF_CTRL)|FW_DL_INPROC);
+		}
+	}
+
+#endif
+
+	if ((priv->pshare->fw_signature & 0xfff0 ) == 0x92D0)
+		ptmp = data_rtl8192dfw_n_start + RT_8192CD_FIRMWARE_HDR_SIZE;
+	else
+		ptmp = data_rtl8192dfw_n_start;
+
+	fw_len = (int)(data_rtl8192dfw_n_end - ptmp);
+	printk("[%s][rtl8192dfw_n]\n",__FUNCTION__);
+
+	// Disable SIC
+	RTL_W16(GPIO_MUXCFG, (RTL_R16(GPIO_MUXCFG) & 0xff) | HTP_EN);
+	delay_ms(1);
+
+	// Enable MCU
+	RTL_W16(SYS_FUNC_EN, (RTL_R16(SYS_FUNC_EN) & 0x0ff) | FEN_MREGEN
+		| FEN_HWPDN | FEN_DIO_RF | FEN_ELDR | FEN_DCORE |FEN_CPUEN | FEN_PCIED);
+	delay_ms(1);
+
+#ifdef CONFIG_RTL8672
+	RTL_W8(APS_FSMCO, RTL_R8(APS_FSMCO) | PFM_ALDN);
+	delay_ms(1);  //czyao
+#endif
+
+	// Load SRAM
+	WriteAddr = 0x1000;
+	RTL_W8(MCUFWDL, RTL_R8(MCUFWDL) | MCUFWDL_EN);
+	delay_ms(1);
+
+	RTL_W32(MCUFWDL, RTL_R32(MCUFWDL) & 0xfff0ffff);
+
+	delay_ms(1);
+
+	while (CurPtr < fw_len) {
+		if ((CurPtr+4) > fw_len) {
+			// Reach the end of file.
+			while (CurPtr < fw_len) {
+				Temp = *(ptmp + CurPtr);
+				RTL_W8(WriteAddr, (unsigned char)Temp);
+				WriteAddr++;
+				CurPtr++;
+			}
+		} else {
+			// Write FW content to memory.
+			Temp = *((unsigned int *)(ptmp + CurPtr));
+			Temp = cpu_to_le32(Temp);
+			RTL_W32(WriteAddr, Temp);
+			WriteAddr += 4;
+
+			if(WriteAddr == 0x2000) {
+				unsigned char tmp = RTL_R8(MCUFWDL+2);
+				tmp += 1;
+				WriteAddr = 0x1000;
+				RTL_W8(MCUFWDL+2, tmp) ;
+				delay_ms(10);
+//				printk("\n[CurPtr=%x, 0x82=%x]\n", CurPtr, RTL_R8(0x82));
+			}
+			CurPtr += 4;
+		}
+	}
+
+#if defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+	REG32(BSP_WDTCNR) |=  1 << 23;
+#endif
+
+	RTL_W8(TCR+3, 0x7f);
+	RTL_W8(MCUFWDL, (RTL_R8(MCUFWDL) & 0xfe) | MCUFWDL_RDY);
+	delay_ms(1);
+	//RTL_W8(RF_CTRL, RTL_R8(RF_CTRL) | BIT(6));
+	RTL_W8(RF_CTRL, RTL_R8(RF_CTRL) & (~FW_DL_INPROC));
+	delay_ms(1);
+
+check_fwdl_rdy:
+
+	printk("<=== %s\n", __FUNCTION__);
+	// check if firmware is ready
+	wait_cnt = 0;
+#ifdef CONFIG_RTL_92D_DMDP
+	if (priv->pshare->wlandev_idx == 0)
+#endif
+	{
+		while (!(RTL_R8(RSV_MAC0_FWCTRL) & MAC0_WINTINI_RDY)) {
+			if (++wait_cnt > 10) {
+				RTL_W8(MCUFWDL, RTL_R8(MCUFWDL) & (~MCUFWDL_RDY));
+				RESTORE_INT(flags);
+				DEBUG_ERR("8192d mac0 firmware not ready\n");
+				return FALSE;
+			}
+			delay_ms(2*wait_cnt);
+		}
+	}
+#ifdef CONFIG_RTL_92D_DMDP
+	else {
+		while (!(RTL_R8(RSV_MAC1_FWCTRL) & MAC1_WINTINI_RDY)) {
+			if (++wait_cnt > 10) {
+				RTL_W8(MCUFWDL, RTL_R8(MCUFWDL) & (~MCUFWDL_RDY));
+				RESTORE_INT(flags);
+				DEBUG_ERR("8192d mac1 firmware not ready\n");
+				return FALSE;
+			}
+			delay_ms(2*wait_cnt);
+
+		}
+	}
+#endif
+	RESTORE_INT(flags);
+#ifdef CONFIG_RTL8672
+	printk("val=%x\n",RTL_R8(MCUFWDL));
+#endif
+	return TRUE;
+}
+
+
+/*
+ *	92DE Operation Mode
+ */
+void UpdateBBRFVal8192DE(struct rtl8192cd_priv *priv)
+{
+	u8	eRFPath = 0, curMaxRFPath;
+	//u32	u4RegValue=0;
+
+	//Update BB
+	if (priv->pmib->dot11RFEntry.phyBandSelect & PHY_BAND_5G) {
+		/*
+		 *	5G
+		 */
+		//r_select_5G for path_A/B
+		if (priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY)
+			PHY_SetBBReg(priv, rFPGA0_XAB_RFParameter, BIT(16), 0x1);
+		PHY_SetBBReg(priv, rFPGA0_XAB_RFParameter, BIT(0), 0x1);
+		//rssi_table_select:index 0 for 2.4G.1~3 for 5G
+		PHY_SetBBReg(priv, rOFDM0_AGCRSSITable, BIT(7) | BIT(6), 0x01);
+		//5G PA power on
+		if (priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY)
+			PHY_SetBBReg(priv, rFPGA0_XAB_RFParameter, BIT(31), (priv->pmib->dot11RFEntry.trsw_pape_CC & BIT(6))>>6);
+		PHY_SetBBReg(priv, rFPGA0_XAB_RFParameter, BIT(15), (priv->pmib->dot11RFEntry.trsw_pape_CC & BIT(4))>>4);
+
+		//TRSW.TRSWB and PAPE2G mode table
+		if (priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY){
+			// TRSW_2, TRSWB_2
+			PHY_SetBBReg(priv, 0x870, BIT(22)|BIT(21), 0);
+			// PAPE2G_2
+			PHY_SetBBReg(priv, 0x870, BIT(26), (priv->pmib->dot11RFEntry.trsw_pape_CC & BIT(7))>>7);
+			PHY_SetBBReg(priv, 0x864, BIT(10), (priv->pmib->dot11RFEntry.trsw_pape_CC & BIT(6))>>6);
+		}
+		// TRSW_1, TRSWB_1
+		PHY_SetBBReg(priv, 0x870, BIT(6)|BIT(5), 0);
+		// PAPE2G_1
+		PHY_SetBBReg(priv, 0x870, BIT(10), (priv->pmib->dot11RFEntry.trsw_pape_CC & BIT(5))>>5);
+		PHY_SetBBReg(priv, 0x860, BIT(10), (priv->pmib->dot11RFEntry.trsw_pape_CC & BIT(4))>>4);
+#ifdef RTL8192D_INT_PA
+		if (!priv->pshare->rf_ft_var.use_intpa92d)
+#endif
+		{
+			//5G PA power on
+			if (priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY)
+				PHY_SetBBReg(priv, rFPGA0_XAB_RFParameter, BIT(31), 0x1);
+			PHY_SetBBReg(priv, rFPGA0_XAB_RFParameter, BIT(15), 0x1);
+		}
+		// 5G LNA on
+		PHY_SetBBReg(priv, 0xb30, 0x00f00000, 0x0);
+		//fc_area
+		if (priv->pmib->dot11RFEntry.dot11channel<149)
+			PHY_SetBBReg(priv, rOFDM1_CFOTracking, BIT(14) | BIT(13), 1);
+		else
+			PHY_SetBBReg(priv, rOFDM1_CFOTracking, BIT(14) | BIT(13), 2);
+		//cck_disable
+		PHY_SetBBReg(priv, rFPGA0_RFMOD, bCCKEn, 0x0);
+		//TX BB gain shift
+#ifdef RTL8192D_INT_PA
+		if (priv->pshare->rf_ft_var.use_intpa92d){
+			PHY_SetBBReg(priv, rOFDM0_XATxIQImbalance, bMaskDWord, 0x2d4000b5);
+			if (priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY)
+				PHY_SetBBReg(priv, rOFDM0_XBTxIQImbalance, bMaskDWord, 0x2d4000b5);
+		} else
+#endif
+		{
+			PHY_SetBBReg(priv, rOFDM0_XATxIQImbalance, bMaskDWord, 0x20000080);
+			if (priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY)
+				PHY_SetBBReg(priv, rOFDM0_XBTxIQImbalance, bMaskDWord, 0x20000080);
+		}
+		// Reset IQC
+		PHY_SetBBReg(priv, 0xc94, 0xF0000000, 0);
+		if (priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY)
+			PHY_SetBBReg(priv, 0xc9c, 0xF0000000, 0);
+		//BB/DP IQC
+		PHY_SetBBReg(priv, 0xb00, bMaskDWord, 0x010170b8);
+		if (priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY)
+			PHY_SetBBReg(priv, 0xb70, bMaskDWord, 0x010170b8);
+
+ 	} else {
+		/*
+		 *	2.4G
+		 */
+		// r_select_5G for path_A/B
+		if (priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY)
+			PHY_SetBBReg(priv, rFPGA0_XAB_RFParameter, BIT(16), 0x0);
+		PHY_SetBBReg(priv, rFPGA0_XAB_RFParameter, BIT(0), 0);
+		//rssi_table_select:index 0 for 2.4G.1~3 for 5G
+		PHY_SetBBReg(priv, rOFDM0_AGCRSSITable, BIT(7) | BIT(6), 0x00);
+		//5G PA power on
+		if (priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY)
+			PHY_SetBBReg(priv, rFPGA0_XAB_RFParameter, BIT(31), 0x0);
+		PHY_SetBBReg(priv, rFPGA0_XAB_RFParameter, BIT(15), 0x0);
+
+		//TRSW.TRSWB and PAPE2G mode table
+		if (priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY){
+			// TRSW_2
+			PHY_SetBBReg(priv, 0x870, BIT(21), (priv->pmib->dot11RFEntry.trsw_pape_C9 & BIT(7))>>7);
+			PHY_SetBBReg(priv, 0x864, BIT(5), (priv->pmib->dot11RFEntry.trsw_pape_C9 & BIT(6))>>6);
+			// TRSWB_2
+			PHY_SetBBReg(priv, 0x870, BIT(22), (priv->pmib->dot11RFEntry.trsw_pape_C9 & BIT(5))>>5);
+			PHY_SetBBReg(priv, 0x864, BIT(6), (priv->pmib->dot11RFEntry.trsw_pape_C9 & BIT(4))>>4);
+			// PAPE2G_2
+			PHY_SetBBReg(priv, 0x870, BIT(26), (priv->pmib->dot11RFEntry.trsw_pape_CC & BIT(3))>>3);
+			PHY_SetBBReg(priv, 0x864, BIT(10), (priv->pmib->dot11RFEntry.trsw_pape_CC & BIT(2))>>2);
+		}
+		// TRSW_1
+		PHY_SetBBReg(priv, 0x870, BIT(5), (priv->pmib->dot11RFEntry.trsw_pape_C9 & BIT(3))>>3);
+		PHY_SetBBReg(priv, 0x860, BIT(5), (priv->pmib->dot11RFEntry.trsw_pape_C9 & BIT(2))>>2);
+		// TRSWB_1
+		PHY_SetBBReg(priv, 0x870, BIT(6), (priv->pmib->dot11RFEntry.trsw_pape_C9 & BIT(1))>>1);
+		PHY_SetBBReg(priv, 0x860, BIT(6), (priv->pmib->dot11RFEntry.trsw_pape_C9 & BIT(0))>>0);
+		// PAPE2G_1
+		PHY_SetBBReg(priv, 0x870, BIT(10), (priv->pmib->dot11RFEntry.trsw_pape_CC & BIT(1))>>1);
+		PHY_SetBBReg(priv, 0x860, BIT(10), (priv->pmib->dot11RFEntry.trsw_pape_CC & BIT(0))>>0);
+
+		// 5G LNA on
+		PHY_SetBBReg(priv, 0xb30, 0x00f00000, 0xa);
+		//fc_area
+		PHY_SetBBReg(priv, rOFDM1_CFOTracking, BIT(14) | BIT(13), 0x00);
+		//cck_enable
+		PHY_SetBBReg(priv, rFPGA0_RFMOD, bCCKEn, 0x1);
+		//TX BB gain shift
+		PHY_SetBBReg(priv, rOFDM0_XATxIQImbalance, bMaskDWord, 0x40000100);
+		if (priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY)
+			PHY_SetBBReg(priv, rOFDM0_XBTxIQImbalance, bMaskDWord, 0x40000100);
+		// Reset IQC
+		PHY_SetBBReg(priv, 0xc94, 0xF0000000, 0);
+		if (priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY)
+			PHY_SetBBReg(priv, 0xc9c, 0xF0000000, 0);
+		//BB/DP IQC
+		PHY_SetBBReg(priv, 0xb00, bMaskDWord, 0x01017038);
+		if (priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY)
+			PHY_SetBBReg(priv, 0xb70, bMaskDWord, 0x01017038);
+	}
+
+	//Update RF
+	if (priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY)
+		curMaxRFPath = RF92CD_PATH_B;
+	else
+		curMaxRFPath = RF92CD_PATH_MAX;
+
+	for(eRFPath = RF92CD_PATH_A; eRFPath <curMaxRFPath; eRFPath++) {
+		if(priv->pmib->dot11RFEntry.phyBandSelect & PHY_BAND_5G) {
+			/*
+			 *	5G
+			 */
+			priv->pshare->RegRF18[eRFPath] &= 0xffffff00;
+			priv->pshare->RegRF18[eRFPath] |= (BIT(16)|BIT(8)|0x24); //set channel 36
+			PHY_SetRFReg(priv,eRFPath, rRfChannel,bMask20Bits, priv->pshare->RegRF18[eRFPath]);
+			delay_ms(1);
+			// LDO_DIV
+			priv->pshare->RegRF28[eRFPath] = RTL_SET_MASK(priv->pshare->RegRF28[eRFPath],BIT(7)|BIT(6),1,6);
+			//PHY_SetRFReg(priv,eRFPath, 0x28, BIT(7)|BIT(6), 0x01);
+			PHY_SetRFReg(priv,eRFPath, 0x28, bMask20Bits, priv->pshare->RegRF28[eRFPath]);
+
+			delay_ms(30);
+		} else {
+			/*
+			 *	2.4G
+			 */
+			priv->pshare->RegRF18[eRFPath] &=  ~(BIT(16)|BIT(8)|0xFF);
+			priv->pshare->RegRF18[eRFPath] |= 1; //set channel 1.
+			PHY_SetRFReg(priv,eRFPath, rRfChannel,bMask20Bits, priv->pshare->RegRF18[eRFPath]);
+			delay_ms(1);
+			// LDO_DIV
+			priv->pshare->RegRF28[eRFPath] &= (~(BIT(7)|BIT(6)));
+			//PHY_SetRFReg(priv,eRFPath, 0x28, BIT(7)|BIT(6), 0x00);
+			PHY_SetRFReg(priv,eRFPath, 0x28, bMask20Bits, priv->pshare->RegRF28[eRFPath]);
+
+			delay_ms(30);
+		}
+	}
+
+#ifdef CONFIG_RTL_92D_DMDP
+	if (priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY) {
+		//Use antenna 0 & 1
+		PHY_SetBBReg(priv, rOFDM0_TRxPathEnable, bMaskByte0, 0x11);
+		PHY_SetBBReg(priv, rOFDM1_TRxPathEnable, bDWord, 0x1);
+
+		//disable ad/da clock1
+		if (!(DMDP_RTL_R8(0,SYS_FUNC_EN)&(FEN_BB_GLB_RST|FEN_BBRSTB))){
+			DMDP_RTL_W8(0, SYS_FUNC_EN, (DMDP_RTL_R8(0,SYS_FUNC_EN)|FEN_BB_GLB_RST|FEN_BBRSTB));
+		}
+		DMDP_PHY_SetBBReg(0, rFPGA0_AdDaClockEn, BIT(13)|BIT(12), 3);
+	} else
+#endif
+	{
+		//Use antenna 0 & 1
+		PHY_SetBBReg(priv, rOFDM0_TRxPathEnable, bMaskByte0, 0x33);
+		PHY_SetBBReg(priv, rOFDM1_TRxPathEnable, bDWord, 0x3);
+
+		//disable ad/da clock1
+		PHY_SetBBReg(priv, rFPGA0_AdDaClockEn, BIT(13) | BIT(12), 0);
+	}
+}
+
+
+#if 0 //def CLIENT_MODE
+void clnt_save_IQK_res(struct rtl8192cd_priv *priv)
+{
+	priv->site_survey.bk_iqc[0] = PHY_QueryBBReg(priv,0xc80, bMaskDWord);
+	priv->site_survey.bk_iqc[1] = PHY_QueryBBReg(priv,0xc94, bMaskByte3);
+	priv->site_survey.bk_iqc[2] = PHY_QueryBBReg(priv,0xc4c, bMaskByte3);
+	priv->site_survey.bk_iqc[3] = PHY_QueryBBReg(priv,0xc88, bMaskDWord);
+	priv->site_survey.bk_iqc[4] = PHY_QueryBBReg(priv,0xc9c, bMaskByte3);
+	priv->site_survey.bk_iqc[5] = PHY_QueryBBReg(priv,0xc14, bMaskDWord);
+	priv->site_survey.bk_iqc[6] = PHY_QueryBBReg(priv,0xca0, bMaskByte3);
+	priv->site_survey.bk_iqc[7] = PHY_QueryBBReg(priv,0xc1c, bMaskDWord);
+	priv->site_survey.bk_iqc[8] = PHY_QueryBBReg(priv,0xc78, bMaskByte1);
+	priv->site_survey.bk_iqc[9] = PHY_QueryRFReg(priv, RF92CD_PATH_A, 0x08, bMask20Bits, 1);
+	priv->site_survey.bk_iqc[10] = PHY_QueryRFReg(priv, RF92CD_PATH_B, 0x08, bMask20Bits, 1);
+}
+
+
+void clnt_load_IQK_res(struct rtl8192cd_priv *priv)
+{
+	PHY_SetBBReg(priv,0xc80, bMaskDWord, priv->site_survey.bk_iqc[0]);
+	PHY_SetBBReg(priv,0xc94, bMaskByte3, priv->site_survey.bk_iqc[1]);
+	PHY_SetBBReg(priv,0xc4c, bMaskByte3, priv->site_survey.bk_iqc[2]);
+	PHY_SetBBReg(priv,0xc88, bMaskDWord, priv->site_survey.bk_iqc[3]);
+	PHY_SetBBReg(priv,0xc9c, bMaskByte3, priv->site_survey.bk_iqc[4]);
+	PHY_SetBBReg(priv,0xc14, bMaskDWord, priv->site_survey.bk_iqc[5]);
+	PHY_SetBBReg(priv,0xca0, bMaskByte3, priv->site_survey.bk_iqc[6]);
+	PHY_SetBBReg(priv,0xc1c, bMaskDWord, priv->site_survey.bk_iqc[7]);
+	PHY_SetBBReg(priv,0xc78, bMaskByte1, priv->site_survey.bk_iqc[8]);
+	PHY_SetRFReg(priv,RF92CD_PATH_A, 0x08, bMask20Bits, priv->site_survey.bk_iqc[9]);
+	PHY_SetRFReg(priv,RF92CD_PATH_B, 0x08, bMask20Bits, priv->site_survey.bk_iqc[10]);
+}
+
+#endif
+
+void IQK_92D_2G(struct rtl8192cd_priv *priv)
+{
+	unsigned int cal_num=0, cal_retry=0, Oldval=0, temp_c04=0, temp_c08=0, temp_874=0, temp_eac;
+	unsigned int cal_e94, cal_e9c, cal_ea4, cal_eac, cal_eb4, cal_ebc, cal_ec4, cal_ecc;
+	unsigned int X, Y, val_e94[3], val_e9c[3], val_ea4[3], val_eac[3], val_eb4[3], val_ebc[3], val_ec4[3], val_ecc[3];
+	unsigned int ADDA_REG[IQK_ADDA_REG_NUM] = {0x85c, 0xe6c, 0xe70, 0xe74,	0xe78, 0xe7c, 0xe80, 0xe84,
+												0xe88, 0xe8c, 0xed0, 0xed4, 0xed8, 0xedc, 0xee0, 0xeec};
+	unsigned int ADDA_backup[IQK_ADDA_REG_NUM], i;
+	u8 temp_522, temp_550, temp_551;
+	u32 temp_040, temp_800, temp_870, temp_860, temp_864, temp_88c;
+	u8 switch2PI = 0;
+
+#ifdef CONFIG_RTL_92D_DMDP
+	if (priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY)
+		return IQK_92D_2G_phy1(priv);
+#endif
+
+	 //always do IQK for MP mode
+#ifdef MP_TEST
+	if (!priv->pshare->rf_ft_var.mp_specific)
+#endif
+	{
+		if (priv->pmib->dot11RFEntry.macPhyMode == SINGLEMAC_SINGLEPHY) {
+			if (priv->pshare->iqk_2g_done)
+				return;
+			priv->pshare->iqk_2g_done = 1;
+		}
+	}
+
+	printk(">> %s \n",__FUNCTION__);
+
+	// Save ADDA power saving parameters
+	for( i = 0 ; i < IQK_ADDA_REG_NUM ; i++)
+		ADDA_backup[i] = RTL_R32(ADDA_REG[i]);
+
+	/*
+	 * Save MAC default value
+	 */
+	temp_522 = RTL_R8(0x522);
+	temp_550 = RTL_R8(0x550);
+	temp_551 = RTL_R8(0x551);
+	temp_040 = RTL_R32(0x40);
+
+	// Save BB default
+	temp_800 = RTL_R32(0x800);
+	temp_870 = RTL_R32(0x870);
+	temp_860 = RTL_R32(0x860);
+	temp_864 = RTL_R32(0x864);
+	temp_88c = RTL_R32(0x88c);
+
+	// Path-A ADDA all on
+	for( i = 0 ; i < IQK_ADDA_REG_NUM ; i++)
+		RTL_W32(ADDA_REG[i], 0x04db25a4);
+
+	// IQ&LO calibration Setting
+	//IQK must be done in PI mode
+	if (!PHY_QueryBBReg(priv, 0x820, BIT(8)) || !PHY_QueryBBReg(priv, 0x828, BIT(8))) {
+		PHY_SetBBReg(priv, 0x820, bMaskDWord, 0x01000100);
+		PHY_SetBBReg(priv, 0x828, bMaskDWord, 0x01000100);
+		switch2PI++;
+	}
+
+	//BB setting
+	temp_c04 = RTL_R32(0xc04);
+	temp_c08 = RTL_R32(0xc08);
+	temp_874 = RTL_R32(0x874);
+	PHY_SetBBReg(priv,0x800,BIT(24),0);
+	RTL_W32(0xc04, 0x03a05600);
+	RTL_W32(0xc08, 0x000800e4);
+	RTL_W32(0x874, 0x22204000);
+
+	PHY_SetBBReg(priv, 0x870, BIT(10), 1);
+	PHY_SetBBReg(priv, 0x870, BIT(26), 1);
+	PHY_SetBBReg(priv, 0x860, BIT(10), 0);
+	PHY_SetBBReg(priv, 0x864, BIT(10), 0);
+
+	PHY_SetBBReg(priv,0x88c,0x00f00000,0xf);
+	RTL_W32(0x840, 0x00010000);
+	RTL_W32(0x844, 0x00010000);
+
+	//MAC register setting
+	RTL_W8(0x522, 0x3f);
+	RTL_W8(0x550, RTL_R8(0x550)& (~BIT(3)));
+	RTL_W8(0x551, RTL_R8(0x551)& (~BIT(3)));
+	RTL_W32(0x40, 0);
+
+	//AP or IQK
+	RTL_W32(0xb68 , 0x0f600000);
+	RTL_W32(0xb6c , 0x0f600000);
+
+	// IQK setting
+	RTL_W32(0xe28, 0x80800000);
+	RTL_W32(0xe40, 0x01007c00);
+	RTL_W32(0xe44, 0x01004800);
+	// path-A IQK setting
+	RTL_W32(0xe30, 0x10008c1f);
+	RTL_W32(0xe34, 0x10008c1f);
+	RTL_W32(0xe38, 0x82140102);
+	RTL_W32(0xe3c, 0x28160206);
+	// path-B IQK setting
+	RTL_W32(0xe50, 0x10008c22);
+	RTL_W32(0xe54, 0x10008c22);
+	RTL_W32(0xe58, 0x82140102);
+	RTL_W32(0xe5c, 0x28160206);
+	// LO calibration setting
+	RTL_W32(0xe4c, 0x00462911);
+
+	// delay to ensure Path-A IQK success
+	delay_ms(10);
+
+	// step 4: One shot, path A LOK & IQK
+	while (cal_num < 3) {
+		// One shot, path A LOK & IQK
+		RTL_W32(0xe48, 0xf9000000);
+		RTL_W32(0xe48, 0xf8000000);
+		// delay 1ms
+		delay_ms(1);
+
+		// check fail bit and check abnormal condition, then fill BB IQ matrix
+		cal_e94 = (RTL_R32(0xe94) >> 16) & 0x3ff;
+		cal_e9c = (RTL_R32(0xe9c) >> 16) & 0x3ff;
+		cal_ea4 = (RTL_R32(0xea4) >> 16) & 0x3ff;
+		temp_eac = RTL_R32(0xeac);
+		cal_eac = (temp_eac >> 16) & 0x3ff;
+		if (!(temp_eac & BIT(28)) && !(temp_eac & BIT(27)) &&
+			(cal_e94 != 0x142) && (cal_e9c != 0x42) &&
+			(cal_ea4 != 0x132) && (cal_eac != 0x36)) {
+			val_e94[cal_num] = cal_e94;
+			val_e9c[cal_num] = cal_e9c;
+			val_ea4[cal_num] = cal_ea4;
+			val_eac[cal_num] = cal_eac;
+			cal_num++;
+		} else {
+			if (++cal_retry >= 10) {
+				printk("%s Path-A Check\n",__FUNCTION__);
+				break;
+			}
+		}
+	}
+
+	if (cal_num == 3) {
+		cal_e94 = get_mean_of_2_close_value(val_e94);
+		cal_e9c = get_mean_of_2_close_value(val_e9c);
+		cal_ea4 = get_mean_of_2_close_value(val_ea4);
+		cal_eac = get_mean_of_2_close_value(val_eac);
+
+		priv->pshare->RegE94=cal_e94;
+		priv->pshare->RegE9C=cal_e9c;
+
+		Oldval = (RTL_R32(0xc80) >> 22) & 0x3ff;
+
+		X = cal_e94;
+		PHY_SetBBReg(priv, 0xc80, 0x3ff, (X * Oldval)>>8);
+		PHY_SetBBReg(priv, 0xc4c, BIT(24), ((X * Oldval) >> 7) & 0x1);
+
+		Y = cal_e9c;
+		if ((Y & 0x00000200) != 0)
+			Y = Y | 0xFFFFFC00;
+		PHY_SetBBReg(priv, 0xc94, 0xf0000000, (((Y * Oldval) >> 8) >> 6) & 0xf);
+		PHY_SetBBReg(priv, 0xc80, 0x003f0000, ((Y * Oldval) >> 8) & 0x3f);
+		PHY_SetBBReg(priv, 0xc4c, BIT(26), ((Y * Oldval) >> 7) & 0x1);
+
+		PHY_SetBBReg(priv, 0xc14, 0x3ff, cal_ea4);
+
+		PHY_SetBBReg(priv, 0xc14, 0xfc00, cal_eac & 0x3f);
+
+		PHY_SetBBReg(priv, 0xca0, 0xf0000000, (cal_eac >> 6) & 0xf);
+	}else {
+		priv->pshare->RegE94=0x100;
+		priv->pshare->RegE9C=0x00;
+	}
+
+	// step 5: Path-A standby mode
+	RTL_W32(0xe28, 0);
+	RTL_W32(0x840, 0x00010000);
+	RTL_W32(0xe28, 0x80800000);
+
+	// step 6: Path-B ADDA all on
+	for( i = 0 ; i < IQK_ADDA_REG_NUM ; i++)
+		RTL_W32(ADDA_REG[i], 0x0b1b25a4);
+
+	// step 7: One shot, path B LOK & IQK
+	cal_num = 0;
+	cal_retry = 0;
+	while (cal_num < 3) {
+			// One shot, path B LOK & IQK
+		RTL_W32(0xe60, 2);
+		RTL_W32(0xe60, 0);
+		// delay 1ms
+		delay_ms(1);
+
+		// check fail bit and check abnormal condition, then fill BB IQ matrix
+		cal_eb4 = (RTL_R32(0xeb4) >> 16) & 0x3ff;
+		cal_ebc = (RTL_R32(0xebc) >> 16) & 0x3ff;
+		cal_ec4 = (RTL_R32(0xec4) >> 16) & 0x3ff;
+		cal_ecc = (RTL_R32(0xecc) >> 16) & 0x3ff;
+		temp_eac = RTL_R32(0xeac);
+		if (!(temp_eac & BIT(31)) && !(temp_eac & BIT(30)) &&
+			(cal_eb4 != 0x142) && (cal_ebc != 0x42) &&
+			(cal_ec4 != 0x132) && (cal_ecc != 0x36)) {
+			val_eb4[cal_num] = cal_eb4;
+			val_ebc[cal_num] = cal_ebc;
+			val_ec4[cal_num] = cal_ec4;
+			val_ecc[cal_num] = cal_ecc;
+			cal_num++;
+		} else {
+			if (++cal_retry >= 10) {
+				printk("%s Path-B Check\n",__FUNCTION__);
+				break;
+			}
+		}
+	}
+
+	if (cal_num == 3) {
+		cal_eb4 = get_mean_of_2_close_value(val_eb4);
+		cal_ebc = get_mean_of_2_close_value(val_ebc);
+		cal_ec4 = get_mean_of_2_close_value(val_ec4);
+		cal_ecc = get_mean_of_2_close_value(val_ecc);
+
+		priv->pshare->RegEB4=cal_eb4;
+		priv->pshare->RegEBC=cal_ebc;
+
+		Oldval = (RTL_R32(0xc88) >> 22) & 0x3ff;
+
+		X = cal_eb4;
+		PHY_SetBBReg(priv, 0xc88, 0x3ff, (X * Oldval) >> 8 );
+		PHY_SetBBReg(priv, 0xc4c, BIT(28), ((X * Oldval) >> 7) & 0x1);
+
+		Y = cal_ebc;
+		if ((Y & 0x00000200) != 0)
+			Y = Y | 0xFFFFFC00;
+		PHY_SetBBReg(priv, 0xc9c, 0xf0000000, (((Y * Oldval) >> 8 ) >> 6) & 0xf);
+		PHY_SetBBReg(priv, 0xc88, 0x003f0000, ((Y * Oldval) >> 8 ) & 0x3f);
+		PHY_SetBBReg(priv, 0xc4c, BIT(30), ((Y * Oldval) >> 7) & 0x1);
+
+		PHY_SetBBReg(priv, 0xc1c, 0x3ff, cal_ec4);
+
+		PHY_SetBBReg(priv, 0xc1c, 0xfc00, cal_ecc & 0x3f);
+
+		PHY_SetBBReg(priv, 0xc78, 0xf000, (cal_ecc >> 6) & 0xf);
+	}else {
+		priv->pshare->RegEB4=0x100;
+		priv->pshare->RegEBC=0x00;
+	}
+
+	// step 8: back to BB mode, load original values
+	RTL_W32(0xe28, 0);
+	RTL_W32(0xc04, temp_c04);
+	RTL_W32(0xc08, temp_c08);
+	RTL_W32(0x874, temp_874);
+	RTL_W32(0x800, temp_800);
+	RTL_W32(0x88c, temp_88c);
+	RTL_W32(0x840, 0x32fff);
+	RTL_W32(0x844, 0x32fff);
+	RTL_W32(0x870, temp_870);
+	RTL_W32(0x860, temp_860);
+	RTL_W32(0x864, temp_864);
+
+	/*
+	 *	Switch back to SI if needed, after IQK
+	 */
+	if (switch2PI) {
+		PHY_SetBBReg(priv, 0x820, bMaskDWord, 0x01000000);
+		PHY_SetBBReg(priv, 0x828, bMaskDWord, 0x01000000);
+	}
+
+#if defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+	REG32(BSP_WDTCNR) |=  1 << 23;
+#endif
+
+	/*
+	 *	Reload ADDA power saving parameters
+	 */
+	for(i = 0 ; i < IQK_ADDA_REG_NUM ; i++)
+		PHY_SetBBReg(priv, ADDA_REG[i], bMaskDWord, ADDA_backup[i]);
+
+	/*
+	 *	Reload MAC default value
+	 */
+	RTL_W8(0x550, temp_550);
+	RTL_W8(0x551, temp_551);
+	RTL_W32(0x40, temp_040);
+	RTL_W8(0x522, temp_522);
+
+
+#if 0 //def CLIENT_MODE
+	clnt_save_IQK_res(priv);
+#endif
+
+}
+
+void IQK_92D_5G_n(struct rtl8192cd_priv *priv)
+{
+	unsigned int temp_800, temp_c04, temp_874, temp_c08, temp_870,
+				temp_860, temp_864, temp_88c, temp_c50, temp_c58, temp_b30,
+				switch2PI=0, X, reg; //Oldval_0, Oldval_1, TX0_A, TX1_A;
+	u8 temp_522, temp_550, temp_551;
+	unsigned int cal_num=0, cal_retry=0, ADDA_backup[IQK_ADDA_REG_NUM];
+	int Y, result[8][3], result_final[8]; //TX0_C, TX1_C;
+
+	unsigned int i, RX0REG0xe40[3], RX0REG0xe40_final=0, REG0xe40, REG0xe94, REG0xe9c, delay_count;
+	unsigned int REG0xeac, RX1REG0xe40[3], RX1REG0xe40_final=0, REG0xeb4, REG0xea4,REG0xec4;
+	unsigned char TX0IQKOK = FALSE, TX1IQKOK = FALSE;
+	unsigned int TX_X0, TX_Y0, TX_X1, TX_Y1, RX_X0, RX_Y0, RX_X1, RX_Y1;
+	unsigned int ADDA_REG[IQK_ADDA_REG_NUM] = {0x85c, 0xe6c, 0xe70, 0xe74,	0xe78, 0xe7c, 0xe80, 0xe84,
+												0xe88, 0xe8c, 0xed0, 0xed4, 0xed8, 0xedc, 0xee0, 0xeec};
+#ifdef CONFIG_RTL_92D_DMDP
+	if (priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY)
+		return IQK_92D_5G_phy0_n(priv);
+#endif
+
+	 //always do IQK for MP mode
+#ifdef MP_TEST
+	if (!priv->pshare->rf_ft_var.mp_specific)
+#endif
+	{
+		if (priv->pmib->dot11RFEntry.macPhyMode == SINGLEMAC_SINGLEPHY) {
+			if (priv->pshare->iqk_5g_done)
+				return;
+			priv->pshare->iqk_5g_done = 1;
+		}
+	}
+
+	printk(">> %s \n",__FUNCTION__);
+#if defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+	REG32(BSP_WDTCNR) |=  1 << 23;
+#endif
+	/*
+	 * Save MAC default value
+	 */
+	temp_522 = RTL_R8(0x522);
+	temp_550 = RTL_R8(0x550);
+	temp_551 = RTL_R8(0x551);
+
+	/*
+	 *	Save BB Parameter
+	 */
+	temp_800 = RTL_R32(0x800);
+	temp_c04 = RTL_R32(0xc04);
+	temp_874 = RTL_R32(0x874);
+	temp_c08 = RTL_R32(0xc08);
+	temp_870 = RTL_R32(0x870);
+	temp_860 = RTL_R32(0x860);
+	temp_864 = RTL_R32(0x864);
+	temp_88c = RTL_R32(0x88c);
+	temp_c50 = RTL_R32(0xc50);	// 01/11/2011 update
+	temp_c58 = RTL_R32(0xc58);	// 01/11/2011 update
+	temp_b30 = RTL_R32(0xb30);	// 03/03/2011 update
+
+	/*
+	*	Save AFE Parameters
+	*/
+	for( i = 0 ; i < IQK_ADDA_REG_NUM ; i++)
+		ADDA_backup[i] = RTL_R32(ADDA_REG[i]);
+
+	/*
+	 *	==============
+	 *	Path-A TX/RX IQK
+	 *	==============
+	 */
+	while (cal_num < 3) {
+		/*
+		 *	Path-A AFE all on
+		 */
+		for( i = 0 ; i < IQK_ADDA_REG_NUM ; i++)
+			RTL_W32(ADDA_REG[i], 0x04db25a4);
+
+		/*
+		 *	MAC register setting
+		 */
+		RTL_W8(0x522, 0x3f);
+		RTL_W8(0x550, RTL_R8(0x550)& (~BIT(3)));
+		RTL_W8(0x551, RTL_R8(0x551)& (~BIT(3)));
+
+		/*
+		 *	IQK must be done in PI mode
+		 */
+		if (!PHY_QueryBBReg(priv, 0x820, BIT(8)) || !PHY_QueryBBReg(priv, 0x828, BIT(8))) {
+			PHY_SetBBReg(priv, 0x820, bMaskDWord, 0x01000100);
+			PHY_SetBBReg(priv, 0x828, bMaskDWord, 0x01000100);
+			switch2PI++;
+		}
+
+		/*
+		 *	BB setting
+		 */
+		PHY_SetBBReg(priv, 0x800, BIT(24), 0);
+		PHY_SetBBReg(priv, 0xc04, bMaskDWord, 0x03a05600);
+		PHY_SetBBReg(priv, 0xc08, bMaskDWord, 0x000800e4);
+		PHY_SetBBReg(priv, 0x874, bMaskDWord, 0x22208000);
+		PHY_SetBBReg(priv, 0x88c, BIT(23)|BIT(22)|BIT(21)|BIT(20), 0xf);
+		PHY_SetBBReg(priv, 0xb30, bMaskDWord, 0x00a00000);	// 03/03/2011 update
+
+		/*
+		 *	AP or IQK
+		 */
+		//PHY_SetBBReg(priv, 0xb68, bMaskDWord, 0x0f600000);
+		//PHY_SetBBReg(priv, 0xb6c, bMaskDWord, 0x0f600000);
+
+		// IQK-R03 2011/02/16 update
+
+		//path A AP setting for IQK
+		PHY_SetBBReg(priv, 0xb00, bMaskDWord, 0);
+		PHY_SetBBReg(priv, 0xb68, bMaskDWord, 0x20000000);
+		//path B AP setting for IQK
+		PHY_SetBBReg(priv, 0xb70, bMaskDWord, 0);
+		PHY_SetBBReg(priv, 0xb6c, bMaskDWord, 0x20000000);
+
+		/*
+		 *	IQK global setting
+		 */
+		PHY_SetBBReg(priv, 0xe28, bMaskDWord, 0x80800000);
+		PHY_SetBBReg(priv, 0xe40, bMaskDWord, 0x10007c00);
+		PHY_SetBBReg(priv, 0xe44, bMaskDWord, 0x01004800);
+
+		/*
+		 *	path-A IQK setting
+		 */
+		PHY_SetBBReg(priv, 0xe30, bMaskDWord, 0x18008c1f);
+		PHY_SetBBReg(priv, 0xe34, bMaskDWord, 0x18008c1f);
+		PHY_SetBBReg(priv, 0xe38, bMaskDWord, 0x82140307);	// 01/11/2011 update
+#ifdef USB_POWER_SUPPORT
+		PHY_SetBBReg(priv, 0xe3c, bMaskDWord, 0x68160c66);
+#else
+		PHY_SetBBReg(priv, 0xe3c, bMaskDWord, 0x68160960);	// 01/11/2011 update
+#endif
+
+		/*
+		 *	path-B IQK setting
+		 */
+		PHY_SetBBReg(priv, 0xe50, bMaskDWord, 0x18008c2f);
+		PHY_SetBBReg(priv, 0xe54, bMaskDWord, 0x18008c2f);
+		PHY_SetBBReg(priv, 0xe58, bMaskDWord, 0x82110000);
+		PHY_SetBBReg(priv, 0xe5c, bMaskDWord, 0x68110000);
+
+		/*
+		 *	LO calibration setting
+		 */
+		PHY_SetBBReg(priv, 0xe4c, bMaskDWord, 0x00462911);
+
+#ifdef USB_POWER_SUPPORT
+		//	path-A TRSW setting
+		PHY_SetBBReg(priv, 0x870, BIT(6)|BIT(5), 3);
+		PHY_SetBBReg(priv, 0x860, BIT(6)|BIT(5), 3);
+#else
+		/*
+		 *	path-A PA on
+		 */
+		/*
+		PHY_SetBBReg(priv, 0x870, BIT(11)|BIT(10), 3);
+		PHY_SetBBReg(priv, 0x870, BIT(6)|BIT(5), 3);
+		PHY_SetBBReg(priv, 0x860, BIT(11)|BIT(10), 3);
+		 */
+		PHY_SetBBReg(priv, 0x870, bMaskDWord, 0x07000f60);	// 01/11/2011 update
+		PHY_SetBBReg(priv, 0x860, bMaskDWord, 0x66e60e30);	// 01/11/2011 update
+#endif
+		/*
+		 *	One shot, path A LOK & IQK
+		 */
+		PHY_SetBBReg(priv, 0xe48, bMaskDWord, 0xf9000000);
+		PHY_SetBBReg(priv, 0xe48, bMaskDWord, 0xf8000000);
+
+		/*
+		 *	Delay 10 ms
+		 */
+		delay_ms(10);
+
+		delay_count = 0;
+		while (1){
+			REG0xeac = PHY_QueryBBReg(priv, 0xeac, bMaskDWord);
+			if ((REG0xeac&BIT(26))||(delay_count>20)){
+				break;
+			}else {
+				delay_ms(1);
+				delay_count++;
+			}
+		}
+		/*
+		 *	Check_TX_IQK_A_result
+		 */
+		REG0xe40 = PHY_QueryBBReg(priv, 0xe40, bMaskDWord);
+		REG0xe94 = PHY_QueryBBReg(priv, 0xe94, bMaskDWord);
+		if(((REG0xeac&BIT(28)) == 0) && (((REG0xe94&0x3FF0000)>>16)!=0x142)) {
+			TX0IQKOK = TRUE;
+			REG0xe9c = PHY_QueryBBReg(priv, 0xe9c, bMaskDWord);
+			TX_X0 = (PHY_QueryBBReg(priv, 0xe94, bMaskDWord)&0x3FF0000)>>16;
+			TX_Y0 = (PHY_QueryBBReg(priv, 0xe9c, bMaskDWord)&0x3FF0000)>>16;
+			RX0REG0xe40[cal_num] =	(REG0xe40 & 0xfc00fc00) | (TX_X0<<16) | TX_Y0;
+			DEBUG_INFO("TX_X0 %08x TX_Y0 %08x RX0REG0xe40 %08x\n", TX_X0, TX_Y0, RX0REG0xe40[cal_num]);
+			result[0][cal_num] = TX_X0;
+			result[1][cal_num] = TX_Y0;
+		} else {
+			TX0IQKOK = FALSE;
+			if (++cal_retry >= 10) {
+				printk("%s Path-A Tx/Rx Check\n",__FUNCTION__);
+				break;
+			}
+		}
+
+		/*
+		 *	Check_RX_IQK_A_result
+		 */
+		if(TX0IQKOK == TRUE) {
+			REG0xeac = PHY_QueryBBReg(priv, 0xeac, bMaskDWord);
+			REG0xea4 = PHY_QueryBBReg(priv, 0xea4, bMaskDWord);
+			if(((REG0xeac&BIT(27)) == 0) && (((REG0xea4&0x3FF0000)>>16)!=0x132)) {
+				RX_X0 =  (PHY_QueryBBReg(priv, 0xea4, bMaskDWord)&0x3FF0000)>>16;
+				RX_Y0 =  (PHY_QueryBBReg(priv, 0xeac, bMaskDWord)&0x3FF0000)>>16;
+				DEBUG_INFO("RX_X0 %08x RX_Y0 %08x\n", RX_X0, RX_Y0);
+				result[2][cal_num] = RX_X0;
+				result[3][cal_num] = RX_Y0;
+				cal_num++;
+			} else {
+				PHY_SetBBReg(priv, 0xc14, bMaskDWord, 0x40000100);
+				PHY_SetBBReg(priv, 0xe34, bMaskDWord, 0x19008c00);
+				if (++cal_retry >= 10) {
+					printk("%s Path-A Tx/Rx Check\n",__FUNCTION__);
+					break;
+				}
+			}
+		}
+	}
+
+	if (cal_num == 3) {
+		result_final[0] = get_mean_of_2_close_value(result[0]);
+		result_final[1] = get_mean_of_2_close_value(result[1]);
+		result_final[2] = get_mean_of_2_close_value(result[2]);
+		result_final[3] = get_mean_of_2_close_value(result[3]);
+		RX0REG0xe40_final = 0x80000000 | get_mean_of_2_close_value(RX0REG0xe40);
+
+		priv->pshare->RegE94=result_final[0];
+		priv->pshare->RegE9C=result_final[1];
+	} else {
+		priv->pshare->RegE94=0x100;
+		priv->pshare->RegE9C=0x00;
+	}
+
+	/*
+	 *	Path-A PA off
+	 */
+	PHY_SetBBReg(priv, 0x870, bMaskDWord, temp_870);
+	PHY_SetBBReg(priv, 0x860, bMaskDWord, temp_860);
+
+
+	/*
+	 *	==============
+	 *	Path-B TX/RX IQK
+	 *	==============
+	 */
+	cal_num = cal_retry = 0;
+	while (cal_num < 3) {
+		/*
+		 *	Path-B AFE all on
+		 */
+		for( i = 0 ; i < IQK_ADDA_REG_NUM ; i++)
+			PHY_SetBBReg(priv, ADDA_REG[i], bMaskDWord, 0x0b1b25a4);
+
+		/*
+		 *	path-A IQK setting
+		 */
+		PHY_SetBBReg(priv, 0xe30, bMaskDWord, 0x18008c1f);
+		PHY_SetBBReg(priv, 0xe34, bMaskDWord, 0x18008c1f);
+		PHY_SetBBReg(priv, 0xe38, bMaskDWord, 0x82110000);
+		PHY_SetBBReg(priv, 0xe3c, bMaskDWord, 0x68110000);
+
+		/*
+		 *	path-B IQK setting
+		 */
+		PHY_SetBBReg(priv, 0xe50, bMaskDWord, 0x18008c22);
+		PHY_SetBBReg(priv, 0xe54, bMaskDWord, 0x18008c22);
+		PHY_SetBBReg(priv, 0xe58, bMaskDWord, 0x82140307);	// 01/11/2011 update
+
+		// 01/11/2011 update
+#ifdef USB_POWER_SUPPORT
+		PHY_SetBBReg(priv, 0xe5c, bMaskDWord, 0x68160c66);
+#else
+		PHY_SetBBReg(priv, 0xe5c, bMaskDWord, 0x68160960);	// 01/11/2011 update
+#endif
+
+		/*
+		 *	LO calibration setting
+		 */
+		PHY_SetBBReg(priv, 0xe4c, bMaskDWord, 0x00462911);
+
+#ifdef USB_POWER_SUPPORT
+		PHY_SetBBReg(priv, 0x870, BIT(22)|BIT(21), 3);
+		PHY_SetBBReg(priv, 0x864, BIT(6)|BIT(5), 3);
+#else
+		/*
+		 *	path-B PA on
+		 */
+		/*
+		PHY_SetBBReg(priv, 0x870, BIT(27)|BIT(26), 3);
+		PHY_SetBBReg(priv, 0x870, BIT(22)|BIT(21), 3);
+		PHY_SetBBReg(priv, 0x864, BIT(11)|BIT(10), 3);
+		*/
+		PHY_SetBBReg(priv, 0x870, bMaskDWord, 0x0f600700);
+		PHY_SetBBReg(priv, 0x864, bMaskDWord, 0x061f0d30);
+#endif
+
+		/*
+		 *	One shot, path A LOK & IQK
+		 */
+		PHY_SetBBReg(priv, 0xe60, bMaskDWord, 0x00000002);
+		PHY_SetBBReg(priv, 0xe60, bMaskDWord, 0x00000000);
+
+		/*
+		 *	Delay 10 ms
+		 */
+		delay_ms(10);
+
+		delay_count = 0;
+		while (1){
+			REG0xeac = PHY_QueryBBReg(priv, 0xeac, bMaskDWord);
+			if ((REG0xeac&BIT(29))||(delay_count>20)){
+				break;
+			}else {
+				delay_ms(1);
+				delay_count++;
+			}
+		}
+		/*
+		 *	Check_TX_IQK_B_result
+		 */
+		REG0xe40 = PHY_QueryBBReg(priv, 0xe40, bMaskDWord);
+		REG0xeac = PHY_QueryBBReg(priv, 0xeac, bMaskDWord);
+		REG0xeb4 = PHY_QueryBBReg(priv, 0xeb4, bMaskDWord);
+		if(((REG0xeac&BIT(31)) == 0) && ((REG0xeb4&0x3FF0000)!=0x142)) {
+			TX1IQKOK = TRUE;
+			TX_X1 = (PHY_QueryBBReg(priv, 0xeb4, bMaskDWord)&0x3FF0000)>>16;
+			TX_Y1 = (PHY_QueryBBReg(priv, 0xebc, bMaskDWord)&0x3FF0000)>>16;
+			RX1REG0xe40[cal_num] = (REG0xe40 & 0xfc00fc00) | (TX_X1<<16) | TX_Y1;
+			DEBUG_INFO("TX_X1 %08x TX_Y1 %08x RX1REG0xe40 %08x\n", TX_X1, TX_Y1, RX1REG0xe40[cal_num]);
+			result[4][cal_num] = TX_X1;
+			result[5][cal_num] = TX_Y1;
+		} else {
+			TX1IQKOK = FALSE;
+			if (++cal_retry >= 10) {
+				printk("%s Path-B Tx/Rx Check\n",__FUNCTION__);
+				break;
+			}
+		}
+
+		/*
+		 *	Check_RX_IQK_B_result
+		 */
+		if(TX1IQKOK == TRUE) {
+			REG0xeac = PHY_QueryBBReg(priv, 0xeac, bMaskDWord);
+			REG0xec4 = PHY_QueryBBReg(priv, 0xec4, bMaskDWord);
+			if(((REG0xeac&BIT(30)) == 0) && (((REG0xec4&0x3FF0000)>>16)!=0x132)) {
+				RX_X1 =  (PHY_QueryBBReg(priv, 0xec4, bMaskDWord)&0x3FF0000)>>16;
+				RX_Y1 =  (PHY_QueryBBReg(priv, 0xecc, bMaskDWord)&0x3FF0000)>>16;
+				DEBUG_INFO("RX_X1 %08x RX_Y1 %08x\n", RX_X1, RX_Y1);
+				result[6][cal_num] = RX_X1;
+				result[7][cal_num] = RX_Y1;
+				cal_num++;
+			} else {
+				PHY_SetBBReg(priv, 0xc1c, bMaskDWord, 0x40000100);
+				PHY_SetBBReg(priv, 0xe54, bMaskDWord, 0x19008c00);
+				if (++cal_retry >= 10) {
+					printk("%s Path-B Tx/Rx Check\n",__FUNCTION__);
+					break;
+				}
+			}
+		}
+	}
+
+	if (cal_num == 3) {
+		result_final[4] = get_mean_of_2_close_value(result[4]);
+		result_final[5] = get_mean_of_2_close_value(result[5]);
+		result_final[6] = get_mean_of_2_close_value(result[6]);
+		result_final[7] = get_mean_of_2_close_value(result[7]);
+		RX1REG0xe40_final = 0x80000000 | get_mean_of_2_close_value(RX1REG0xe40);
+
+		priv->pshare->RegEB4=result_final[4];
+		priv->pshare->RegEBC=result_final[5];
+	} else {
+		priv->pshare->RegEB4=0x100;
+		priv->pshare->RegEBC=0x00;
+	}
+
+	/*
+	 *	Fill IQK result for Path A
+	 */
+	if (result_final[0]) {
+		/*
+		Oldval_0 = (PHY_QueryBBReg(priv, 0xc80, bMaskDWord) >> 22) & 0x3FF;
+		X = result_final[0];
+		if ((X & 0x00000200) != 0)
+			X = X | 0xFFFFFC00;
+		TX0_A = (X * Oldval_0) >> 8;
+		PHY_SetBBReg(priv, 0xc80, 0x3FF, TX0_A);
+		PHY_SetBBReg(priv, 0xc4c, BIT(24), ((X* Oldval_0>>7) & 0x1));
+
+		Y = result_final[1];
+		if ((Y & 0x00000200) != 0)
+			Y = Y | 0xFFFFFC00;
+		TX0_C = (Y * Oldval_0) >> 8;
+		PHY_SetBBReg(priv, 0xc94, 0xF0000000, ((TX0_C&0x3C0)>>6));
+		PHY_SetBBReg(priv, 0xc80, 0x003F0000, (TX0_C&0x3F));
+		PHY_SetBBReg(priv, 0xc4c, BIT(26), ((Y* Oldval_0>>7) & 0x1));
+		*/
+
+		// IQK-R03 2011/02/16 update
+		X = result_final[0];
+		Y = result_final[1];
+		//printk("X=%x Y=%x\n",X,Y);
+		//Path-A OFDM_A
+		PHY_SetBBReg(priv, 0xe30, 0x03FF0000, X);
+		PHY_SetBBReg(priv, 0xc4c, BIT(24), 0);
+		//Path-A OFDM_C
+		PHY_SetBBReg(priv, 0xe30, 0x000003FF, Y);
+		PHY_SetBBReg(priv, 0xc4c, BIT(26), 0);
+
+		if(result_final[2]) {
+			reg = result_final[2];
+			PHY_SetBBReg(priv, 0xc14, 0x3FF, reg);
+			reg = result_final[3] & 0x3F;
+			PHY_SetBBReg(priv, 0xc14, 0xFC00, reg);
+
+			reg = (result_final[3] >> 6) & 0xF;
+			PHY_SetBBReg(priv, 0xca0, 0xF0000000, reg);
+		
+			PHY_SetBBReg(priv, 0xe34, 0x03FF0000, result_final[2]); // X
+			PHY_SetBBReg(priv, 0xe34, 0x3FF, result_final[3]);  //Y			
+		}
+	}
+
+	/*
+	 *	Fill IQK result for Path B
+	 */
+	if (result_final[4]) {
+		/*
+		Oldval_1 = (PHY_QueryBBReg(priv, 0xc88, bMaskDWord) >> 22) & 0x3FF;
+
+		X = result_final[4];
+		if ((X & 0x00000200) != 0)
+			X = X | 0xFFFFFC00;
+		TX1_A = (X * Oldval_1) >> 8;
+		PHY_SetBBReg(priv, 0xc88, 0x3FF, TX1_A);
+		PHY_SetBBReg(priv, 0xc4c, BIT(28), ((X* Oldval_1>>7) & 0x1));
+
+		Y = result_final[5];
+		if ((Y & 0x00000200) != 0)
+			Y = Y | 0xFFFFFC00;
+		TX1_C = (Y * Oldval_1) >> 8;
+		PHY_SetBBReg(priv, 0xc9c, 0xF0000000, ((TX1_C&0x3C0)>>6));
+		PHY_SetBBReg(priv, 0xc88, 0x003F0000, (TX1_C&0x3F));
+		PHY_SetBBReg(priv, 0xc4c, BIT(30), ((Y* Oldval_1>>7) & 0x1));
+		*/
+
+		// IQK-R03 2011/02/16 update
+		X = result_final[4];
+		Y = result_final[5];
+		//printk("X=%x Y=%x\n",X,Y);
+		//Path-A OFDM_A
+		PHY_SetBBReg(priv, 0xe50, 0x03FF0000, X);
+		PHY_SetBBReg(priv, 0xc4c, BIT(28), 0);
+		//Path-A OFDM_C
+		PHY_SetBBReg(priv, 0xe50, 0x000003FF, Y);
+		PHY_SetBBReg(priv, 0xc4c, BIT(30), 0);
+
+		if(result_final[6]) {
+			reg = result_final[6];
+			PHY_SetBBReg(priv, 0xc1c, 0x3FF, reg);
+
+			reg = result_final[7] & 0x3F;
+			PHY_SetBBReg(priv, 0xc1c, 0xFC00, reg);
+
+			reg = (result_final[7] >> 6) & 0xF;
+			PHY_SetBBReg(priv, 0xc78, 0x0000F000, reg);
+			
+			PHY_SetBBReg(priv, 0xe54, 0x03FF0000, result_final[6]); // X
+			PHY_SetBBReg(priv, 0xe54, 0x3FF, result_final[7]);  //Y		
+		}
+	}
+
+	/*
+	 *	Path B PA off
+	 */
+	PHY_SetBBReg(priv, 0x870, bMaskDWord, temp_870);
+	PHY_SetBBReg(priv, 0x864, bMaskDWord, temp_864);
+
+	/*
+	 *	Exit IQK mode
+	 */
+	PHY_SetBBReg(priv, 0xe28, bMaskDWord, 0);
+	PHY_SetBBReg(priv, 0xc04, bMaskDWord, temp_c04);
+	PHY_SetBBReg(priv, 0xc08, bMaskDWord, temp_c08);
+	PHY_SetBBReg(priv, 0x874, bMaskDWord, temp_874);
+	PHY_SetBBReg(priv, 0x800, bMaskDWord, temp_800);
+	PHY_SetBBReg(priv, 0x88c, bMaskDWord, temp_88c);
+	PHY_SetBBReg(priv, 0xb30, bMaskDWord, temp_b30);	// 03/03/2011 update
+	//PHY_SetBBReg(priv, 0x840, bMaskDWord, 0x00032fff);		// 01/11/2011 update
+	//PHY_SetBBReg(priv, 0x844, bMaskDWord, 0x00032fff);		// 01/11/2011 update
+
+	// IQK-R03 2011/02/16 update
+	//path A IQ path to DP block
+	PHY_SetBBReg(priv, 0xb00, bMaskDWord, 0x010170b8);
+	//path B IQ path to DP block
+	PHY_SetBBReg(priv, 0xb70, bMaskDWord, 0x010170b8);
+
+	//path AB to initial gain
+	PHY_SetBBReg(priv, 0xc50, bMaskDWord, 0x50);		// 01/11/2011 update
+	PHY_SetBBReg(priv, 0xc50, bMaskDWord, temp_c50);	// 01/11/2011 update
+	PHY_SetBBReg(priv, 0xc58, bMaskDWord, 0x50);		// 01/11/2011 update
+	PHY_SetBBReg(priv, 0xc58, bMaskDWord, temp_c58);	// 01/11/2011 update
+
+
+	/*
+	 *	Reload MAC default value
+	 */
+	RTL_W8(0x550, temp_550);
+	RTL_W8(0x551, temp_551);
+	RTL_W8(0x522, temp_522);
+
+	/*
+	 *	Switch back to SI if needed, after IQK
+	 */
+	if (switch2PI) {
+		PHY_SetBBReg(priv, 0x820, bMaskDWord, 0x01000000);
+		PHY_SetBBReg(priv, 0x828, bMaskDWord, 0x01000000);
+	}
+
+	/*
+	 *	Reload ADDA power saving parameters
+	 */
+	for(i = 0 ; i < IQK_ADDA_REG_NUM ; i++)
+		PHY_SetBBReg(priv, ADDA_REG[i], bMaskDWord, ADDA_backup[i]);
+
+
+#if 0 //def CLIENT_MODE
+		clnt_save_IQK_res(priv);
+#endif
+
+
+}
+
+#ifdef SW_LCK_92D
+
+#define TARGET_CHNL_NUM_5G 221
+#define TARGET_CHNL_NUM_2G 14
+#define CV_CURVE_CNT 64
+
+unsigned int CurveIndex_5G[TARGET_CHNL_NUM_5G]={0};
+unsigned int CurveIndex_2G[TARGET_CHNL_NUM_2G]={0};
+
+static unsigned int TargetChnl_5G[TARGET_CHNL_NUM_5G] = {
+25141,	25116,	25091,	25066,	25041,
+25016,	24991,	24966,	24941,	24917,
+24892,	24867,	24843,	24818,	24794,
+24770,	24765,	24721,	24697,	24672,
+24648,	24624,	24600,	24576,	24552,
+24528,	24504,	24480,	24457,	24433,
+24409,	24385,	24362,	24338,	24315,
+24291,	24268,	24245,	24221,	24198,
+24175,	24151,	24128,	24105,	24082,
+24059,	24036,	24013,	23990,	23967,
+23945,	23922,	23899,	23876,	23854,
+23831,	23809,	23786,	23764,	23741,
+23719,	23697,	23674,	23652,	23630,
+23608,	23586,	23564,	23541,	23519,
+23498,	23476,	23454,	23432,	23410,
+23388,	23367,	23345,	23323,	23302,
+23280,	23259,	23237,	23216,	23194,
+23173,	23152,	23130,	23109,	23088,
+23067,	23046,	23025,	23003,	22982,
+22962,	22941,	22920,	22899,	22878,
+22857,	22837,	22816,	22795,	22775,
+22754,	22733,	22713,	22692,	22672,
+22652,	22631,	22611,	22591,	22570,
+22550,	22530,	22510,	22490,	22469,
+22449,	22429,	22409,	22390,	22370,
+22350,	22336,	22310,	22290,	22271,
+22251,	22231,	22212,	22192,	22173,
+22153,	22134,	22114,	22095,	22075,
+22056,	22037,	22017,	21998,	21979,
+21960,	21941,	21921,	21902,	21883,
+21864,	21845,	21826,	21807,	21789,
+21770,	21751,	21732,	21713,	21695,
+21676,	21657,	21639,	21620,	21602,
+21583,	21565,	21546,	21528,	21509,
+21491,	21473,	21454,	21436,	21418,
+21400,	21381,	21363,	21345,	21327,
+21309,	21291,	21273,	21255,	21237,
+21219,	21201,	21183,	21166,	21148,
+21130,	21112,	21095,	21077,	21059,
+21042,	21024,	21007,	20989,	20972,
+25679,	25653,	25627,	25601,	25575,
+25549,	25523,	25497,	25471,	25446,
+25420,	25394,	25369,	25343,	25318,
+25292,	25267,	25242,	25216,	25191,
+25166	};
+
+static unsigned int TargetChnl_2G[TARGET_CHNL_NUM_2G] = {	// channel 1~14
+26084, 26030, 25976, 25923, 25869, 25816, 25764,
+25711, 25658, 25606, 25554, 25502, 25451, 25328
+};
+
+void _PHY_CalcCurvIndex(struct rtl8192cd_priv *priv, unsigned int *TargetChnl,
+								unsigned int *CurveCountVal, char is5G,  unsigned int *CurveIndex)
+{
+	unsigned int	smallestABSVal = 0xffffffff, u4tmp;
+	unsigned char	i, j;
+	unsigned char	chnl_num = is5G?(TARGET_CHNL_NUM_5G) : (TARGET_CHNL_NUM_2G);
+
+
+	for(i=0; i<chnl_num; i++)
+	{
+		//if(is5G && !IsLegal5GChannel(pAdapter, i+1))
+			//continue;
+
+		CurveIndex[i] = 0;
+		for(j=0; j<(CV_CURVE_CNT*2); j++)
+		{
+			u4tmp = RTL_ABS(TargetChnl[i], CurveCountVal[j]);
+			//if (i==115)
+				//printk("cv[%d]=%x\n", j, u4tmp);
+			if(u4tmp < smallestABSVal)
+			{
+				CurveIndex[i] = j;
+				smallestABSVal = u4tmp;
+			}
+		}
+
+		smallestABSVal = 0xffffffff;
+	}
+}
+
+void phy_ReloadLCKSetting(struct rtl8192cd_priv *priv)
+{
+	unsigned int	eRFPath = priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_5G? RF92CD_PATH_A:(priv->pmib->dot11RFEntry.macPhyMode==SINGLEMAC_SINGLEPHY?RF92CD_PATH_B:RF92CD_PATH_A);
+	unsigned int 	u4tmp = 0;
+//	unsigned char	bNeedPowerDownRadio = FALSE;
+	unsigned int 	channel = priv->pshare->RegRF18[eRFPath]&0xff;
+	//unsigned int 	channel =  PHY_QueryRFReg(priv, eRFPath, rRfChannel, 0xff, 1);
+
+	DEBUG_INFO("====>phy_ReloadLCKSetting interface %d path %d ch %d [0x%05x]\n", priv->pshare->wlandev_idx, eRFPath, channel, priv->pshare->RegRF28[eRFPath]);
+
+	//only for 92D C-cut SMSP
+	if(GET_CHIP_VER(priv)!=VERSION_8192D
+#ifdef CONFIG_RTL_92C_SUPPORT
+		|| IS_TEST_CHIP(priv)
+#endif
+		)
+		return;
+
+	if(priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_5G)
+	{
+		//Path-A for 5G
+		u4tmp = CurveIndex_5G[channel-1];
+		//printk("%s ver 1 set RF-A, 5G,	0x28 = 0x%x !!\n",__FUNCTION__, u4tmp);
+#ifdef CONFIG_RTL_92D_DMDP
+		if(priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY && priv->pshare->wlandev_idx == 1)
+		{
+			priv->pshare->RegRF28[RF92CD_PATH_A] = RTL_SET_MASK(priv->pshare->RegRF28[RF92CD_PATH_A],0x3f800,u4tmp,11);	 //DMDP_PHY_SetRFReg(0,  RF92CD_PATH_A, 0x28, 0x3f800, u4tmp);
+			DMDP_PHY_SetRFReg(0,  RF92CD_PATH_A, 0x28, bMask20Bits, priv->pshare->RegRF28[RF92CD_PATH_A]);
+		}else
+#endif
+		{
+			priv->pshare->RegRF28[eRFPath] = RTL_SET_MASK(priv->pshare->RegRF28[eRFPath],0x3f800,u4tmp,11);	//PHY_SetRFReg(priv, eRFPath, 0x28, 0x3f800, u4tmp);
+			PHY_SetRFReg(priv, eRFPath, 0x28, bMask20Bits, priv->pshare->RegRF28[eRFPath]);
+		}
+		DEBUG_INFO("%s ver 3 set RF-B, 2G, 0x28 = 0x%05x [0x%05x]!!\n", __FUNCTION__, PHY_QueryRFReg(priv, eRFPath, 0x28, bMask20Bits, 1), priv->pshare->RegRF28[eRFPath]);
+	}
+	else if(priv->pmib->dot11RFEntry.phyBandSelect == PHY_BAND_2G)
+	{
+		u4tmp = CurveIndex_2G[channel-1];
+		//printk("%s ver 3 set RF-B, 2G, 0x28 = 0x%x !!\n", __FUNCTION__, u4tmp);
+#ifdef CONFIG_RTL_92D_DMDP
+		if(priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY && priv->pshare->wlandev_idx == 0)
+		{
+			priv->pshare->RegRF28[RF92CD_PATH_A] = RTL_SET_MASK(priv->pshare->RegRF28[RF92CD_PATH_A],0x3f800,u4tmp,11);	 //DMDP_PHY_SetRFReg(1,  RF92CD_PATH_A, 0x28, 0x3f800, u4tmp);
+			DMDP_PHY_SetRFReg(1,  RF92CD_PATH_A, 0x28, bMask20Bits, priv->pshare->RegRF28[RF92CD_PATH_A]);
+		}else
+#endif
+		{
+			priv->pshare->RegRF28[eRFPath] = RTL_SET_MASK(priv->pshare->RegRF28[eRFPath],0x3f800,u4tmp,11); // PHY_SetRFReg(priv, eRFPath, 0x28, 0x3f800, u4tmp);
+			PHY_SetRFReg(priv, eRFPath, 0x28, bMask20Bits, priv->pshare->RegRF28[eRFPath]);
+		}
+		DEBUG_INFO("%s ver 3 set RF-B, 2G, 0x28 = 0x%05x [0x%05x]!!\n", __FUNCTION__, PHY_QueryRFReg(priv, eRFPath, 0x28, bMask20Bits, 1), priv->pshare->RegRF28[eRFPath]);
+	}
+
+}
+
+/* Software LCK */
+void PHY_LCCalibrate_92D(struct rtl8192cd_priv *priv)
+{
+	unsigned char	tmpReg;
+	unsigned int 	RF_mode[2];
+	unsigned int	eRFPath, curMaxRFPath;
+	unsigned int	i;
+	unsigned int	curveCountVal[CV_CURVE_CNT*2]={0};
+	unsigned short	timeout = 800, timecount = 0;
+
+	if (priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY)
+		curMaxRFPath = RF92CD_PATH_B;
+	else
+		curMaxRFPath = RF92CD_PATH_MAX;
+
+	//Check continuous TX and Packet TX
+	tmpReg = RTL_R8(0xd03);
+
+	if ((tmpReg & 0x70) != 0)				// Deal with contisuous TX case
+		RTL_W8(0xd03, tmpReg&0x8F);	// disable all continuous TX
+	else									// Deal with Packet TX case
+		RTL_W8(TXPAUSE, 0xFF);			// block all queues
+
+	PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0xF00000, 0x0F);
+
+	for(eRFPath = RF92CD_PATH_A; eRFPath < curMaxRFPath; eRFPath++) {
+		// 1. Read original RF mode
+		RF_mode[eRFPath] = PHY_QueryRFReg(priv, eRFPath, 0x00, bMask20Bits, 1);
+
+		// 2. Set RF mode = standby mode
+		PHY_SetRFReg(priv, eRFPath, 0x00, 0x70000, 0x01);
+
+		// switch CV-curve control by LC-calibration
+		PHY_SetRFReg(priv, eRFPath, 0x2B, BIT(17), 0x0);
+
+		// jenyu suggest
+		PHY_SetRFReg(priv, eRFPath, 0x28, BIT(8), 0x1);
+
+		//4. Set LC calibration begin
+		PHY_SetRFReg(priv, eRFPath, 0x18, BIT(15), 0x01);
+
+		while(!(PHY_QueryRFReg(priv, eRFPath, 0x2A, BIT(11), 1) &&
+				timecount <= timeout)){
+			//DEBUG_INFO("PHY_LCK delay for %d ms=2\n", timecount);
+			delay_ms(50);
+			timecount+=50;
+		}
+
+		//u4tmp = PHY_QueryRFReg(priv, eRFPath, 0x28, bMask20Bits, 1);
+
+		memset((void *)curveCountVal, 0, CV_CURVE_CNT*2);
+
+		//Set LC calibration off
+		PHY_SetRFReg(priv, eRFPath, 0x18, BIT(15), 0x00);
+
+		// jenyu suggest
+		PHY_SetRFReg(priv, eRFPath, 0x28, BIT(8), 0x0);
+
+		//save Curve-counting number
+		for(i=0; i<CV_CURVE_CNT; i++)
+		{
+			unsigned int readVal=0, readVal2=0;
+
+			PHY_SetRFReg(priv, eRFPath, 0x3F, 0x7f, i);
+
+			PHY_SetRFReg(priv, eRFPath, 0x4D, bMask20Bits, 0);
+
+			readVal = PHY_QueryRFReg(priv, eRFPath, 0x4F, bMask20Bits, 1);
+
+			curveCountVal[2*i+1] = (readVal & 0xfffe0) >> 5;
+
+			readVal2 = PHY_QueryRFReg(priv, eRFPath, 0x50, 0xffc00, 1);
+
+			curveCountVal[2*i] = (((readVal & 0x1F) << 10) | readVal2);
+		}
+
+		if(eRFPath == RF92CD_PATH_A
+#ifdef CONFIG_RTL_92D_DMDP
+			&& priv->pshare->wlandev_idx == 0
+#endif
+			)
+			_PHY_CalcCurvIndex(priv, TargetChnl_5G, curveCountVal, TRUE, CurveIndex_5G);
+		else
+			_PHY_CalcCurvIndex(priv, TargetChnl_2G, curveCountVal, FALSE, CurveIndex_2G);
+
+		// switch CV-curve control mode
+		PHY_SetRFReg(priv, eRFPath, 0x2B, BIT(17), 0x1);
+
+		// store 0x28 for Reload_LCK
+		priv->pshare->RegRF28[eRFPath] = PHY_QueryRFReg(priv, eRFPath, 0x28, bMask20Bits, 1);
+	}
+
+	//Restore original situation
+	for(eRFPath = RF92CD_PATH_A; eRFPath < curMaxRFPath; eRFPath++)
+	{
+		PHY_SetRFReg(priv, eRFPath, 0x00, bMask20Bits, RF_mode[eRFPath]);
+	}
+
+	if((tmpReg&0x70) != 0)
+	{
+		//Path-A
+		RTL_W8(0xd03, tmpReg);
+	}
+	else // Deal with Packet TX case
+	{
+		RTL_W8(TXPAUSE, 0x00);
+	}
+
+	PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0xF00000, 0x00);
+
+	phy_ReloadLCKSetting(priv);
+
+}
+
+#else
+/* Hardware LCK */
+static void PHY_LCCalibrate_92D(struct rtl8192cd_priv *priv)
+{
+	unsigned char tmpReg;
+	unsigned int RF_mode[2], tmpu4Byte[2];
+
+	unsigned int eRFPath, curMaxRFPath;
+	unsigned char	timeout = 800, timecount = 0;
+
+	if (priv->pmib->dot11RFEntry.macPhyMode == DUALMAC_DUALPHY)
+		curMaxRFPath = RF92CD_PATH_B;
+	else
+		curMaxRFPath = RF92CD_PATH_MAX;
+
+
+	// Check continuous TX and Packet TX
+	tmpReg = RTL_R8(0xd03);
+
+	if ((tmpReg & 0x70) != 0)				// Deal with contisuous TX case
+		RTL_W8(0xd03, tmpReg&0x8F);	// disable all continuous TX
+	else									// Deal with Packet TX case
+		RTL_W8(TXPAUSE, 0xFF);			// block all queues
+
+	PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0xF00000, 0x0F);
+
+	for(eRFPath = RF92CD_PATH_A; eRFPath < curMaxRFPath; eRFPath++) {
+		// 1. Read original RF mode
+		RF_mode[eRFPath] = PHY_QueryRFReg(priv, eRFPath, 0x00, bMask20Bits, 1);
+
+		// 2. Set RF mode = standby mode
+		PHY_SetRFReg(priv, eRFPath, 0x00, 0x70000, 0x01);
+
+		tmpu4Byte[eRFPath] = PHY_QueryRFReg(priv, eRFPath, 0x28, bMask20Bits, 1);
+		PHY_SetRFReg(priv, eRFPath, 0x28, 0x700, 0x07);
+
+		//4. Set LC calibration begin
+		PHY_SetRFReg(priv, eRFPath, 0x18, 0x08000, 0x01);
+	}
+
+#if (defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)) && defined(CONFIG_RTL_92D_SUPPORT)
+	REG32(BSP_WDTCNR) |=  1 << 23;
+#endif
+
+	for(eRFPath = RF92CD_PATH_A; eRFPath < curMaxRFPath; eRFPath++) {
+		while(!(PHY_QueryRFReg(priv, eRFPath, 0x2A, BIT(11), 1) &&
+				timecount <= timeout)){
+			DEBUG_INFO("PHY_LCK delay for %d ms=2\n", timecount);
+			delay_ms(50);
+			timecount+=50;
+		}
+	}
+
+	for(eRFPath = RF92CD_PATH_A; eRFPath < curMaxRFPath; eRFPath++) {
+		PHY_SetRFReg(priv, eRFPath, 0x28, bMask20Bits, tmpu4Byte[eRFPath]);
+		priv->pshare->RegRF28[eRFPath] = tmpu4Byte[eRFPath];
+		PHY_SetRFReg(priv, eRFPath, 0x00, bMask20Bits, RF_mode[eRFPath]);
+	}
+
+	// Restore original situation
+	if ((tmpReg & 0x70) != 0)	// Deal with contisuous TX case
+		RTL_W8(0xd03, tmpReg);
+	else 						// Deal with Packet TX case
+		RTL_W8(TXPAUSE, 0x00);
+
+	PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0xF00000, 0x0);
+
+}
+
+
+#endif //LCK_SW
+
+
+#ifdef DPK_92D
+
+#if 1 //copy from driver of station team
+#define		RF_AC						0x00	
+
+#define		rPdp_AntA      				0xb00  
+#define		rBndA						0xb30
+#define		rPdp_AntB 					0xb70
+#define		rBndB						0xba0
+
+#define		RF_MODE1					0x10	 
+#define		RF_MODE2					0x11	
+
+#define		rTxAGC_B_CCK11_A_CCK2_11	0x86c
+
+#define		RF_TX_G3					0x22
+
+#define		RF_TXPA_G1					0x31	// RF TX PA control
+#define		RF_TXPA_G2					0x32	// RF TX PA control
+#define		RF_TXPA_G3					0x33	// RF TX PA control
+#define		RF_LOBF_9					0x38
+#define		RF_RXRF_A3					0x3C	
+#define		RF_TRSW						0x3F
+
+#define		RF_TXPA_G1					0x31	// RF TX PA control
+#define		RF_TXPA_G2					0x32	// RF TX PA control
+#define		RF_TXPA_G3					0x33	// RF TX PA control
+#define		RF_LOBF_9					0x38
+#define		RF_RXRF_A3					0x3C	
+#define		RF_TRSW						0x3F
+
+#define		RF_TXRF_A2					0x41
+#define		RF_TXPA_G4					0x46	
+#define		RF_TXPA_A4					0x4B	
+
+#define		RF_IQADJ_G1					0x01
+#define		RF_IQADJ_G2					0x02
+#define		RF_BS_PA_APSET_G1_G4		0x03
+#define		RF_BS_PA_APSET_G5_G8		0x04
+#define		RF_POW_TRSW					0x05
+
+#define		DP_OFFSET_NUM				9
+#define		DP_AP_CUREVE_SELECT_NUM		3
+#define		DP_gain_loss				1
+#define		DP_PA_BIAS_NUM				4
+
+#define		rTxAGC_B_CCK1_55_Mcs32		0x838
+
+#define		RF_TXBIAS					0x16
+#endif
+
+#define DPK_DEBUG(fmt,args...) 
+
+#define		DP_BB_REG_NUM		7
+//#define		DP_BB_REG_NUM_A	11
+//#define		DP_BB_REG_NUM_B	10
+#define		DP_BB_REG_NUM_A	10
+#define		DP_BB_REG_NUM_B	9
+
+#define		DP_BB_REG_NUM_settings	6
+#define		DP_BB_REG_NUM_loop	30
+#define		DP_BB_REG_NUM_loop_tx	12
+#define		DP_BB_REG_NUM_loop_rx	8
+#define		DP_BB_REG_NUM_loop_pa	4
+#define		DP_RF_REG_NUM		4
+#define		DP_SRAM_NUM		16
+//#define		DP_SRAM_NUM_db		22
+#define		DP_SRAM_NUM_db		86
+
+#define		DP_PATH_NUM		2
+#define		DP_PA_MODEL_NUM	32
+#define		DP_PA_MODEL_RUN_NUM	8
+#define		DP_PA_MODEL_PER_RUN_NUM	4
+#define		DP_RETRY_LIMIT		10
+#define		DP_DPK_NUM			3
+#define		DP_DPK_VALUE_NUM	2
+#if 1
+#define		DP_GAIN_LOSS_BOUND_NUM	14
+#else
+#define		DP_GAIN_LOSS_BOUND_NUM	8
+#endif
+#define		DP_OFFSET_NUM		9
+#define		DP_AP_CUREVE_SELECT_NUM		2	// 3
+#define		DP_gain_loss	1
+
+
+void rtl8192cd_DPK_timer(unsigned long task_priv)
+{
+	struct rtl8192cd_priv *priv = (struct rtl8192cd_priv *)task_priv;
+
+	if (!(priv->drv_state & DRV_STATE_OPEN))
+		return;
+
+	if (priv->pshare->pwr_trk_ongoing){
+		DPK_DEBUG("==>_PHY_DigitalPredistortion() TxPowerTrackingInProgress() delay 100ms\n"); 	
+		mod_timer(&priv->pshare->DPKTimer, jiffies + RTL_MILISECONDS_TO_JIFFIES(100));
+	}else{
+		PHY_DPCalibrate(priv);
+	}
+}
+
+void _PHY_DPK_polling(struct rtl8192cd_priv *priv)
+{
+	unsigned int	delaycount = 0, delaybound = 30, delay = 800;
+	unsigned int	u4tmp;
+
+	delaycount = 0;
+
+	do{
+		delay_us(delay);
+		
+		u4tmp = PHY_QueryBBReg(priv, 0xdf4, bMaskDWord);		
+		//RTPRINT(FINIT, INIT_IQK, ("0xdf4 = 0x%x, delay %d us\n", u4tmp, delaycount*delay+800));			
+		delaycount++;		
+		delay = 100;
+		u4tmp = (u4tmp & BIT(26)) >> 26;
+	}while(u4tmp == 0x01 && delaycount < delaybound);
+
+}
+
+// if AP curve check fail return FALSE
+int _PHY_DPK_AP_curve_check(struct rtl8192cd_priv *priv, unsigned int *PA_power, unsigned int RegiesterNum)
+{
+	unsigned int 	PA_power_temp[DP_PA_MODEL_NUM], i = 0, index = 5, 
+			base = 532, ref1, ref2;
+	int	power_I, power_Q;
+
+	//store I, Q 
+
+	for(i = 0; i < DP_PA_MODEL_NUM; i++){
+		power_I = (PA_power[i] >> 8);
+		if(power_I & BIT(7))
+			power_I |= bMaskH3Bytes;
+
+		power_Q = PA_power[i] & bMaskByte0;
+		if(power_Q & BIT(7))
+			power_Q |= bMaskH3Bytes;
+
+		PA_power_temp[i] = power_I*power_I+power_Q*power_Q;
+	}
+
+	ref1 = PA_power_temp[0];
+	for(i = 0; i < index; i++)
+		ref1 = (ref1 > PA_power_temp[i])?ref1:PA_power_temp[i];
+
+	ref2 = PA_power_temp[index];
+	for(i = index; i < index*2; i++)
+		ref2 = (ref2 > PA_power_temp[i])?ref2:PA_power_temp[i];
+		
+	DPK_DEBUG("==>_PHY_DPK_AP_cureve_check ref1 =  0x%x ref2 =  0x%x\n", ref1, ref2);
+
+	if(ref1 == 0)
+		return FALSE;
+
+	return	((ref2 << 9)/ref1) < base;
+}
+
+// if DPK fail return FALSE
+int _PHY_DPK_check(struct rtl8192cd_priv *priv, unsigned int *PA_power, unsigned int RegiesterNum)
+{
+	unsigned int base = 407, PA_power_temp[2], i = 0;
+	int	power_I, power_Q;
+
+	while(i ==0 || i == (RegiesterNum-1))
+	{
+		power_I = (PA_power[i] >> 8);
+		if(power_I & BIT(7))
+			power_I |= bMaskH3Bytes;
+
+		power_Q = PA_power[i] & bMaskByte0;
+		if(power_Q & BIT(7))
+			power_Q |= bMaskH3Bytes;
+		
+		PA_power_temp[i==0?0:1] = power_I*power_I+ power_Q*power_Q;
+
+		DPK_DEBUG("==>_PHY_DPK_check pa_power_temp[%d] 0x%x\n", i, PA_power_temp[i==0?0:1]);								
+		
+		if(i == 0)
+			i = RegiesterNum -1;
+		else if (i == RegiesterNum -1)
+			break;
+	}	
+
+	//normalization
+	if(PA_power_temp[0] == 0)
+		return TRUE;
+	else
+		return (((PA_power_temp[1] << 9) /PA_power_temp[0]) <= base);
+
+}
+
+int _PHY_Find_Tx_Power_Index(struct rtl8192cd_priv *priv, unsigned int *PA_power, unsigned char path, unsigned char bPlus3db, char bDecreaseTxIndex, unsigned char *tx_index_out)
+{
+	unsigned char	i,  tx_index = bDecreaseTxIndex?0x0f:0x15;
+	unsigned int	tmpReg[11], tmpBase, RegNum = 11, base = /*323*/256;
+	unsigned int	PA_power_normal[11];
+//	unsigned int	check_base =bPlus3db?(400-base):(323-base);
+	unsigned int	check_base =bPlus3db?400:323;
+
+	int	power_I, power_Q;
+	int	index = -1;	
+
+	DPK_DEBUG("==>tx_index minus %d bplus3db %d\n", base, bPlus3db);
+
+	_PHY_DPK_polling(priv);
+
+	if(path == RF92CD_PATH_A)	
+	{
+		PHY_SetBBReg(priv, 0xb00, bMaskDWord, 0x01017018);
+		tmpReg[0] = PHY_QueryBBReg(priv, 0xbdc, bMaskDWord);		
+		tmpReg[1] = PHY_QueryBBReg(priv, 0xbe8, bMaskDWord);
+
+		PHY_SetBBReg(priv, 0xb00, bMaskDWord, 0x01017019);
+		tmpReg[2] = PHY_QueryBBReg(priv, 0xbdc, bMaskDWord);		
+		tmpReg[3] = PHY_QueryBBReg(priv, 0xbe0, bMaskDWord);		
+		tmpReg[4] = PHY_QueryBBReg(priv, 0xbe8, bMaskDWord);
+
+		PHY_SetBBReg(priv, 0xb00, bMaskDWord, 0x0101701a);
+		tmpReg[5] = PHY_QueryBBReg(priv, 0xbe0, bMaskDWord);		
+
+		PHY_SetBBReg(priv, 0xb00, bMaskDWord, 0x0101701b);
+		tmpReg[6] = PHY_QueryBBReg(priv, 0xbdc, bMaskDWord);		
+		tmpReg[7] = PHY_QueryBBReg(priv, 0xbe8, bMaskDWord);
+
+		PHY_SetBBReg(priv, 0xb00, bMaskDWord, 0x0101701c);
+		tmpReg[8] = PHY_QueryBBReg(priv, 0xbe8, bMaskDWord);
+
+		PHY_SetBBReg(priv, 0xb00, bMaskDWord, 0x0101701e);
+		tmpReg[9] = PHY_QueryBBReg(priv, 0xbdc, bMaskDWord);		
+
+		PHY_SetBBReg(priv, 0xb00, bMaskDWord, 0x0101701f);
+		tmpReg[10] = PHY_QueryBBReg(priv, 0xbe8, bMaskDWord);
+
+		//RTPRINT(FINIT, INIT_IQK, ("==>_PHY_Find_Tx_Power_Index path A\n")); 						
+		
+	}
+	else if(path == RF92CD_PATH_B)
+	{
+		PHY_SetBBReg(priv, 0xb70, bMaskDWord, 0x01017018);
+		tmpReg[0] = PHY_QueryBBReg(priv, 0xbec, bMaskDWord);		
+		tmpReg[1] = PHY_QueryBBReg(priv, 0xbf8, bMaskDWord);
+
+		PHY_SetBBReg(priv, 0xb70, bMaskDWord, 0x01017019);
+		tmpReg[2] = PHY_QueryBBReg(priv, 0xbec, bMaskDWord);		
+		tmpReg[3] = PHY_QueryBBReg(priv, 0xbf0, bMaskDWord);		
+		tmpReg[4] = PHY_QueryBBReg(priv, 0xbf8, bMaskDWord);
+
+		PHY_SetBBReg(priv, 0xb70, bMaskDWord, 0x0101701a);
+		tmpReg[5] = PHY_QueryBBReg(priv, 0xbf4, bMaskDWord);		
+
+		PHY_SetBBReg(priv, 0xb70, bMaskDWord, 0x0101701b);
+		tmpReg[6] = PHY_QueryBBReg(priv, 0xbec, bMaskDWord);		
+		tmpReg[7] = PHY_QueryBBReg(priv, 0xbf8, bMaskDWord);
+
+		PHY_SetBBReg(priv, 0xb70, bMaskDWord, 0x0101701c);
+		tmpReg[8] = PHY_QueryBBReg(priv, 0xbf8, bMaskDWord);
+
+		PHY_SetBBReg(priv, 0xb70, bMaskDWord, 0x0101701e);
+		tmpReg[9] = PHY_QueryBBReg(priv, 0xbec, bMaskDWord);		
+
+		PHY_SetBBReg(priv, 0xb70, bMaskDWord, 0x0101701f);
+		tmpReg[10] = PHY_QueryBBReg(priv, 0xbf8, bMaskDWord);
+
+		//RTPRINT(FINIT, INIT_IQK, ("==>_PHY_Find_Tx_Power_Index path B\n")); 						
+		
+	}	
+	
+	for(i = 0; i < RegNum; i++)
+	{
+		power_I = (tmpReg[i] >> 8);
+		if(power_I & BIT(7))
+			power_I |= bMaskH3Bytes;
+
+		power_Q = tmpReg[i] & bMaskByte0;
+		if(power_Q & BIT(7))
+			power_Q |= bMaskH3Bytes;
+
+		PA_power[i] = power_I*power_I+ power_Q*power_Q;
+	}	
+
+	//normalization
+	tmpBase = PA_power[0];
+	//RTPRINT(FINIT, INIT_IQK, ("==>PA_power START normalized\n")); 						
+
+	if(tmpBase == 0)
+		DPK_DEBUG("==>PA_power[0] is ZERO !!!!!\n");
+
+	for(i = 0; i < RegNum; i++)
+	{
+		if(tmpBase != 0)			
+			PA_power[i] = (PA_power[i] << 9) /tmpBase;
+		else
+			PA_power[i] = (PA_power[i] << 9) ;		
+		PA_power_normal[i] = PA_power[i];
+		PA_power[i] = (PA_power[i] > base)?(PA_power[i] - base):(base - PA_power[i]);
+		DPK_DEBUG("==>PA_power normalized index %d value 0x%x\n", i, PA_power[i]);							
+	}
+
+	//choose min for TX index to do DPK
+	base = bMaskDWord;
+	for(i = 0; i < RegNum; i++)
+	{
+		if(PA_power[i] < base)
+		{
+			base = PA_power[i];
+			index = i;		
+		}
+	}
+
+	if(index == -1)
+	{
+		tx_index = 0x1c;
+		index = 0x1f - tx_index;
+	}
+	else
+	{
+		tx_index += index;
+	}	
+
+	DPK_DEBUG("==>tx_index result 0x%x  PA_power[%d] = 0x%x\n", tx_index, index, PA_power[index]);
+
+	*tx_index_out = tx_index;
+
+	//Check pattern reliability
+	if(((PA_power_normal[index] > check_base) && (tx_index == 0x1f)) ||
+		((PA_power_normal[10] > base) && (!bPlus3db)) ||
+		((tx_index < 0x1a) && (!bPlus3db)) ||
+		((tx_index < 0x13) && (bDecreaseTxIndex))
+		)
+		return FALSE;
+	else
+		return TRUE;
+//	return tx_index;
+
+}
+
+unsigned char _PHY_Find_Rx_Power_Index(struct rtl8192cd_priv *priv, unsigned char tx_index, unsigned char rx_index, unsigned char	path, char *bDecreaseTxIndex)
+{
+//	u1Byte	rx_index = 0x04;
+	unsigned int	tmpReg;
+	int	power_I, power_Q, tmp;
+	unsigned char	bPlus = FALSE, bMinus = FALSE;
+	unsigned short	offset[2][2] = {{	//path, offset
+			0xb28,	0xbe8},{
+			0xb98,	0xbf8}};
+	
+	while (TRUE){
+		tmpReg = 0x52000 | tx_index | (rx_index << 5);
+		PHY_SetRFReg(priv, path, RF_AC, bMask20Bits, tmpReg);
+		//RTPRINT(FINIT, INIT_IQK, ("==>RF 0ffset 0 = 0x%x readback = 0x%x\n", tmpReg, 
+			//PHY_QueryRFReg(pAdapter, path, RF_AC, bRFRegOffsetMask)));	
+	
+		//----send one shot signal----//
+		PHY_SetBBReg(priv, offset[path][0], bMaskDWord, 0x80080000);	//0xb28, 0xb98
+		PHY_SetBBReg(priv, offset[path][0], bMaskDWord, 0x00080000);
+				
+		_PHY_DPK_polling(priv);
+		
+		tmpReg = PHY_QueryBBReg(priv, offset[path][1], bMaskDWord);
+		power_I = ((tmpReg & bMaskByte1) >> 8);
+		power_Q = tmpReg & bMaskByte0;
+
+		if(power_I & BIT(7))
+		{
+			power_I |= bMaskH3Bytes; 
+			power_I = 0-power_I;	//absolute value
+		}
+
+		if(power_Q & BIT(7))
+		{
+			power_Q |= bMaskH3Bytes;
+			power_Q = 0-power_Q;
+		}
+		//RTPRINT(FINIT, INIT_IQK, ("==>rx_index 0x%x I = 0x%x Q = 0x%x offset 0xbe8 = 0x%x\n", rx_index, power_I, power_Q, tmpReg));	
+
+		tmp = (power_I > power_Q)? power_I:power_Q;
+
+#if 0
+		if((rx_index == 0 && tmp > 0x6f)||(rx_index == 31 && tmp < 0x50))
+			break;
+#endif
+
+		if((tmp<= 0x6f && tmp >= 0x50) )
+		{
+			break;
+		}
+		else if(tmp < 0x50)
+		{
+			bPlus = TRUE;
+			if(bMinus)
+			{
+				rx_index++;
+				break;
+			}
+//			rx_index++;
+			rx_index += 2;
+		}
+		else if (tmp > 0x6f)
+		{
+			bMinus = TRUE;
+			if(bPlus)
+			{
+				rx_index--;
+				break;
+			}
+//			rx_index--;
+			rx_index -= 2;
+		}
+
+		if(rx_index == 0 || rx_index == 31)
+			break;
+		
+	}
+	if(rx_index == 0 && tmp > 0x6f)
+		*bDecreaseTxIndex = TRUE;
+	
+	DPK_DEBUG("==>rx_index FINAL 0x%x I = 0x%x Q = 0x%x\n", rx_index, power_I, power_Q);	
+
+	return	rx_index;
+
+}
+
+void PHY_DPCalibrate(struct rtl8192cd_priv *priv)
+{
+	char	is2T = ((priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY) ?1 :0);
+
+	unsigned int	tmpReg, value32, checkbit;					
+	unsigned int	AFE_backup[IQK_ADDA_REG_NUM];
+	unsigned int	AFE_REG[IQK_ADDA_REG_NUM] = {	
+						rFPGA0_XCD_SwitchControl, 0xe6c, 0xe70, 0xe74, 0xe78, 
+						0xe7c, 0xe80, 0xe84, 0xe88, 0xe8c, 
+						0xed0, 0xed4, 0xed8, 0xedc, 0xee0,
+						0xeec};
+
+	unsigned int	BB_backup[DP_BB_REG_NUM];	
+	unsigned int	BB_REG[DP_BB_REG_NUM] = {
+						rOFDM0_TRxPathEnable, rFPGA0_RFMOD, 
+						rOFDM0_TRMuxPar, rFPGA0_XCD_RFInterfaceSW,
+						rFPGA0_AnalogParameter4, rFPGA0_XAB_RFInterfaceSW, 
+						rTxAGC_B_CCK11_A_CCK2_11
+						};
+
+	unsigned int	BB_backup_A[DP_BB_REG_NUM_A];	
+	unsigned int	BB_REG_A[DP_BB_REG_NUM_A] = {
+						rFPGA0_XA_RFInterfaceOE,	rTxAGC_A_Rate18_06, 
+						rTxAGC_A_Rate54_24,		rTxAGC_A_CCK1_Mcs32, 
+						0xe0c, 					rTxAGC_A_Mcs03_Mcs00, 
+						rTxAGC_A_Mcs07_Mcs04, 	rTxAGC_A_Mcs11_Mcs08, 
+						rTxAGC_A_Mcs15_Mcs12,	rOFDM0_XAAGCCore1/*,
+						rBndA*/
+						};
+
+	
+	unsigned int	BB_backup_B[DP_BB_REG_NUM_B];	
+	unsigned int	BB_REG_B[DP_BB_REG_NUM_B] = {
+						rFPGA0_XB_RFInterfaceOE,	rTxAGC_B_Rate18_06, 
+						rTxAGC_B_Rate54_24,		rTxAGC_B_CCK1_55_Mcs32, 
+						rTxAGC_B_Mcs03_Mcs00, 	rTxAGC_B_Mcs07_Mcs04, 
+						rTxAGC_B_Mcs11_Mcs08,	rTxAGC_B_Mcs15_Mcs12,
+						rOFDM0_XBAGCCore1 /*, rBndB*/
+						};
+	
+	unsigned int	BB_settings[DP_BB_REG_NUM_settings] = {
+						0x00a05430, 0x02040000, 0x000800e4, 0x22208000, 
+						0xccf000c0/*,	0x07600760*/};
+						
+	unsigned int	BB_REG_loop[DP_PATH_NUM][DP_BB_REG_NUM_loop] = {
+						{0xb00, 0xb04, 0xb28, 0xb68, 
+						0xb08, 0xb0c, 0xb10, 0xb14, 
+						0xb18, 0xb1c, 0xb20, 0xb24,   
+						0xe28, 0xb00, 0xb04, 0xb08, 
+						0xb0c, 0xb10, 0xb14, 0xb18,
+						0xb1c, 0xb20, 0xb24, 0xb28,
+						0xb2c, rBndA, 0xb34, 0xb38, 
+						0xb3c, 0xe28},
+						{0xb70, 0xb74, 0xb98, 0xb6C, 
+						0xb78, 0xb7c, 0xb80, 0xb84, 
+						0xb88, 0xb8c, 0xb90, 0xb94,   
+						0xe28, 0xb60, 0xb64, 0xb68, 
+						0xb6c, 0xb70, 0xb74, 0xb78,
+						0xb7c, 0xb80, 0xb84, 0xb88,
+						0xb8c, 0xb90, 0xb94, 0xb98, 
+						0xb9c, 0xe28} 						
+						};			
+
+	unsigned int	BB_settings_loop[DP_BB_REG_NUM_loop] = {
+						0x01017e18, 0xf76d9f84, 0x00080000, 0x11880000, 
+						0x41382e21,	0x5b554f48, 0x6f6b6661, 0x817d7874,
+						0x908c8884, 0x9d9a9793, 0xaaa7a4a1, 0xb6b3b0ad,
+						0x40000000, 0x7d327c18, 0x7e057db3, 0x7e5f7e37,
+						0x7e967e7c, 0x7ebe7eac, 0x7ed77ecc, 0x7eee7ee4,
+						0x7f017ef9, 0x7f0e7f07, 0x7f1c7f15, 0x7f267f20,
+						0x7f2f7f2a, 0x7f377f34, 0x7f3e7f3b, 0x7f457f42,
+						0x7f4b7f48, 0x00000000 
+						};
+
+	unsigned int	BB_settings_loop_3db[DP_BB_REG_NUM_loop] = {
+						0x01017e18, 0xf76d9f84, 0x00080000, 0x11880000, 
+						0x5b4e402e,	0x7f776f65, 0x9c968f88, 0xb5afa8a3,
+						0xcac4bfb9, 0xdcd8d4ce, 0xeeeae6e2, 0xfffbf7f2,
+						0x40000000, 0x7dfe7d32, 0x7e967e59, 0x7ed77eba,
+						0x7efd7eeb, 0x7f1a7f0e, 0x7f2d7f25, 0x7f3c7f36,
+						0x7f4a7f44, 0x7f547f4e, 0x7f5d7f58, 0x7f657f60,
+						0x7f6a7f68, 0x7f717f6e, 0x7f767f73, 0x7f7b7f78,
+						0x7f7f7f7d, 0x00000000 
+						};	
+	
+	unsigned int	BB_settings_loop_tx[DP_BB_REG_NUM_loop] = {	
+						0x01017e18, 0xf76d9f84, 0x00080000, 0x11880000, 
+						0x21212121, 0x21212121, 0x21212121, 0x21212121,
+						0x21212121, 0x21212121, 0x21212121, 0x21212121,
+						0x40000000,	0x7c187c18, 0x7c187c18, 0x7c187c18, 
+						0x7c187c18, 	0x7c187c18,	0x7c187c18, 0x7c187c18, 
+						0x7c187c18,	0x7c187c18, 0x7c187c18, 0x7c187c18, 
+						0x7c187c18,	0x7c187c18, 0x7c187c18, 0x7c187c18, 
+						0x7c187c18, 0x00000000 
+						};	
+
+	unsigned int	BB_settings_loop_tx_3db[DP_BB_REG_NUM_loop] = { 
+						0x01017e18, 0xf76d9f84, 0x00080000, 0x11880000, 
+						0x2e2e2e2e, 0x2e2e2e2e, 0x2e2e2e2e, 0x2e2e2e2e,
+						0x2e2e2e2e, 0x2e2e2e2e, 0x2e2e2e2e, 0x2e2e2e2e,
+						0x40000000, 0x7d327d32, 0x7d327d32, 0x7d327d32, 
+						0x7d327d32, 	0x7d327d32, 0x7d327d32, 0x7d327d32, 
+						0x7d327d32, 0x7d327d32, 0x7d327d32, 0x7d327d32, 
+						0x7d327d32, 0x7d327d32, 0x7d327d32, 0x7d327d32, 
+						0x7d327d32, 0x00000000 
+						};
+
+
+					//for find 2dB loss point
+	unsigned int	BB_settings_loop_tx_2[DP_BB_REG_NUM_loop] = { 
+						0x01017e18, 0xf76d9f84, 0x00080000, 0x11880000, 
+						0x41382e21, 0x5b554f48, 0x6f6b6661, 0x817d7874,
+						0x908c8884, 0x9d9a9793, 0xaaa7a4a1, 0xb6b3b0ad,
+						0x40000000, 0x7d327c18, 0x7e057db3, 0x7e5f7e37, 
+						0x7e967e7c, 0x7ebe7eac, 0x7ed77ecc, 0x7eee7ee4, 
+						0x7f017ef9, 0x7f0e7f07, 0x7f1c7f15, 0x7f267f20, 
+						0x7f2f7f2a, 0x7f377f34, 0x7f3e7f3b, 0x7f457f42, 
+						0x7f4b7f48, 0x00000000 
+						};
+
+					//for find 2dB loss point
+	unsigned int	BB_settings_loop_tx_2_3db[DP_BB_REG_NUM_loop] = { 
+						0x01017e18, 0xf76d9f84, 0x00080000, 0x11880000, 
+						0x5b4e402e, 0x7f776f65, 0x9c968f88, 0xb5afa8a3,
+						0xcac4bfb9, 0xdcd8d4ce, 0xeeeae6e2, 0xfffbf7f2,
+						0x40000000, 0x7dfe7d32, 0x7e967e59, 0x7ed77eba, 
+						0x7efd7eeb, 0x7f1a7f0e, 0x7f2d7f25, 0x7f3c7f36, 
+						0x7f4a7f44, 0x7f547f4e, 0x7f5d7f58, 0x7f657f60, 
+						0x7f6a7f68, 0x7f717f6e, 0x7f767f73, 0x7f7b7f78, 
+						0x7f7f7f7d, 0x00000000 
+						};					
+
+
+	unsigned int	BB_settings_loop_rx[DP_BB_REG_NUM_loop_rx] = {
+						0x01017e18, 0xf76d9f84, 0x00080000, 0x11880000, 
+						0x21212121,	0x40000000, 0x7c187c18, 0x00000000
+						};	
+
+	unsigned int	BB_settings_loop_rx_3db[DP_BB_REG_NUM_loop_rx] = {
+						0x01017e18, 0xf76d9f84, 0x00080000, 0x11880000, 
+						0x2e2e2e2e,	0x40000000, 0x7d327d32, 0x00000000
+						};	
+
+	unsigned int	BB_settings_loop_pa[DP_BB_REG_NUM_loop_pa] = {
+						0x02096eb8, 0xf76d9f84, 0x00044499, 0x02880140  
+						};	
+
+	unsigned int	BB_settings_loop_dp[DP_BB_REG_NUM_loop_pa] = {
+						0x01017098, 0x776d9f84, 0x00000000, 0x08080000  
+						};	
+
+	unsigned int	*BB_settings_temp;
+
+	unsigned char	Sram_db_settings[DP_SRAM_NUM_db] = {
+						0xfe,	0xf0,	0xe3,	0xd6,	0xca,	
+						0xbf,	0xb4,	0xaa,	0xa0,	0x97,
+						0x8f,	0x87,	0x7f,	0x78,	0x71,
+						0x6b,	0x65,	0x5f,	0x5a,	0x55,
+						0x50,	0x4c,	0x47,	0x43,	0x40,	
+						0x3c,	0x39,	0x35,	0x32,	0x2f,
+						0x2d,	0x2a,	0x28,	0x26,	0x23,
+						0x21,	0x20,	0x1e,	0x1c,	0x1a,
+						0x19,	0x18,	0x16,	0x16,	0x14,	
+						0x13,	0x12,	0x11,	0x10,	0x0f,
+						0x0e,	0x0d,	0x0c,	0x0c,	0x0b,	
+						0x0a,	0x0a,	0x09,	0x09,	0x08,	
+						0x08,	0x07,	0x07,	0x06,	0x06,	
+						0x06,	0x05,	0x05,	0x05,	0x04,	
+						0x04,	0x04,	0x04,	0x03,	0x03,	
+						0x03,	0x03,	0x03,	0x02,	0x02,	
+						0x02,	0x02,	0x02,	0x02,	0x02,	
+						0x01
+					};
+
+	//unsigned int	pwsf[DP_SRAM_NUM];
+
+	unsigned int	offset[2][DP_OFFSET_NUM] = {{		//path, offset
+						0xe34,	0xb28, 	0xb00,	0xbdc,	0xbc0,
+						0xbe8,	rOFDM0_XATxIQImbalance,	rBndA,	
+						0xb68},{
+						0xe54,	0xb98,	0xb70,	0xbec,	0xbc4,
+						0xbf8,	rOFDM0_XBTxIQImbalance,	rBndB,
+						0xb6c}};
+						
+	unsigned char	OFDM_min_index = 6, OFDM_min_index_internalPA = 3;
+	unsigned char	OFDM_index[2];
+	unsigned char	retrycount = 0, retrybound = 1;
+
+	unsigned int	RF_backup[DP_PATH_NUM][DP_RF_REG_NUM];
+	unsigned int	RF_REG[DP_RF_REG_NUM] = {
+						RF_TX_G3,	RF_TXPA_A4,	RF_RXRF_A3,	
+						RF_BS_PA_APSET_G1_G4/*,	RF_BS_PA_APSET_G5_G8,
+						RF_BS_PA_APSET_G9_G11*/};
+
+	unsigned int	RF_AP_curve_select[DP_AP_CUREVE_SELECT_NUM] = {
+						0x7bdef,	0x94a52,	0xa5294/*,	0xb5ad6*/	};	
+
+	unsigned int	RF_PA_BIAS[3][DP_PA_BIAS_NUM] = {{	//40MHz / 20MHz, original
+						0xe189f,	0xa189f,	0x6189f,	0x2189f	},{
+						0xe087f,	0xa087f,	0x6087f,	0x2087f	},{
+						0xe1874,	0xa1874,	0x61874,	0x21874}};
+
+	unsigned int	PA_model_backup[DP_PATH_NUM][DP_PA_MODEL_NUM];
+
+	unsigned int	PA_power[DP_PATH_NUM][DP_PA_MODEL_RUN_NUM*2];
+
+#if DP_gain_loss == 1
+
+	int				power_I, power_Q, coef;
+
+	int				gain_loss_backup[DP_PATH_NUM][DP_PA_MODEL_NUM];	//I,Q
+
+	unsigned int	gain_loss_bound[DP_GAIN_LOSS_BOUND_NUM] = {						
+						63676,	60114 ,	56751 ,	53577 ,	49145,	
+						47750, 	45079 ,	42557 ,	40177 ,	37929 ,
+						35807 ,	33804 ,	31913,	30128  		
+					};	
+
+	int				gain_loss_coef[DP_GAIN_LOSS_BOUND_NUM+1] = { 					
+						512,	527,	543, 	558, 	573, 	
+						589,	609,	625, 	645, 	666, 	
+						681,	701, 	722, 	742,	768
+					};
+
+//	BOOLEAN			bNegative = FALSE;
+//	unsigned char	index_for_zero_db = 24, AP_curve_index = 0;
+	unsigned char	GainLossIndex = 0; //0db, 0x40
+	char			SramIndex = 24;
+	unsigned char	index_for_zero_db = 6, AP_curve_index = 0;
+
+#else
+
+	unsigned char	index_for_zero_db = 6, AP_curve_index = 0;
+	int				power_I, power_Q;
+	unsigned int	gain_loss_bound[DP_GAIN_LOSS_BOUND_NUM] = {						
+						61870,	55142,	49145,	43801,	39037,
+						34792,	31008,	27636		
+					};		
+#endif
+	
+	unsigned int	MAC_backup[IQK_MAC_REG_NUM];
+	unsigned int	MAC_REG[IQK_MAC_REG_NUM] = {
+						0x522,	0x550, 	0x551, 	0x040};		
+
+	unsigned int	AFE_on_off[PATH_NUM] = {
+					0x04db25a4, 0x0b1b25a4};	//path A on path B path A off path B on
+
+	unsigned char	path_num, path_bound, path = RF92CD_PATH_A, i, j, tx_index, rx_index;
+	int				index, index_1, index_repeat;
+
+	char			bInternalPA = FALSE, SkipStep5 = FALSE;
+	char			bPlus3db = FALSE, bDecreaseTxIndex = FALSE, bDecreaseTxIndexWithRx = FALSE;
+
+	
+	DPK_DEBUG("==>_PHY_DigitalPredistortion() interface index %d is2T = %d\n", priv->pshare->wlandev_idx, is2T); //anchin
+	
+	DPK_DEBUG("_PHY_DigitalPredistortion for %s\n", (is2T ? "2T2R" : "1T1R"));
+
+	DPK_DEBUG("==>_PHY_DigitalPredistortion() current thermal meter = 0x%x PG thermal meter = 0x%x bPlus3db %d\n", 
+		priv->pshare->ThermalValue_DPKtrack, priv->pmib->dot11RFEntry.ther, bPlus3db);
+	
+	if ((priv->pmib->dot11RFEntry.phyBandSelect!= PHY_BAND_5G)||(GET_CHIP_VER(priv)!=VERSION_8192D))
+		return;
+	
+	bInternalPA = priv->pshare->rf_ft_var.use_intpa92d;
+
+	if(!is2T)
+		path_num = 1;
+	else 
+		path_num = 2;
+	
+	if(!bInternalPA) {
+		DPK_DEBUG("==>_PHY_DigitalPredistortion() NOT internal5G\n");	
+		return;	
+	}
+
+	if(priv->pshare->pwr_trk_ongoing){
+		DPK_DEBUG("==>_PHY_DigitalPredistortion() TxPowerTrackingInProgress() delay 100ms\n"); 	
+		mod_timer(&priv->pshare->DPKTimer, jiffies + RTL_MILISECONDS_TO_JIFFIES(100));
+		return;
+	}	
+	
+	OFDM_index[RF92CD_PATH_A] = priv->pshare->OFDM_index[RF92CD_PATH_A];
+	OFDM_index[RF92CD_PATH_B] = priv->pshare->OFDM_index[RF92CD_PATH_B];
+
+	DPK_DEBUG("original index 0x%x \n", priv->pshare->OFDM_index[0]);		
+	
+	priv->pshare->bDPKworking = TRUE;
+	
+	//save global setting
+	//save BB default value
+	_PHY_SaveADDARegisters(priv, BB_REG, BB_backup, DP_BB_REG_NUM);
+
+	//save MAC default value
+	_PHY_SaveMACRegisters(priv, MAC_REG, MAC_backup);
+
+	//save AFE default value
+	_PHY_SaveADDARegisters(priv, AFE_REG, AFE_backup, IQK_ADDA_REG_NUM);
+
+	//save path A default value
+	//save path A BB default value
+	_PHY_SaveADDARegisters(priv, BB_REG_A, BB_backup_A, DP_BB_REG_NUM_A);
+
+	//save path B BB default value	
+	if(is2T)
+		_PHY_SaveADDARegisters(priv, BB_REG_B, BB_backup_B, DP_BB_REG_NUM_B);
+	
+	//save pathA/B RF default value
+	for(path=0; path<path_num; path++){
+		for(index=0; index<DP_RF_REG_NUM; index++)
+			RF_backup[path][index] = PHY_QueryRFReg(priv, path, RF_REG[index], bMaskDWord, 1);	
+	}	
+	
+	//BB register setting
+	for(index = 0; index < DP_BB_REG_NUM_settings; index++)
+		PHY_SetBBReg(priv, BB_REG[index], bMaskDWord, BB_settings[index]);
+
+	//BB path A debug setting
+	PHY_SetBBReg(priv, rFPGA1_DebugSelect, bMaskDWord, 0x00000302);
+
+	//BB pah A register setting: fix TRSW to TX, external PA on, external LAN off
+	if(!bInternalPA)
+	{
+		PHY_SetBBReg(priv, rFPGA0_XAB_RFInterfaceSW, bMaskDWord, 0x07600f60);			
+		PHY_SetBBReg(priv, rFPGA0_XA_RFInterfaceOE, ~(BIT8|BIT9), 0x66e60a30);		
+	}
+	else
+	{
+		PHY_SetBBReg(priv, rFPGA0_XAB_RFInterfaceSW, bMaskDWord, 0x07600760);			
+		PHY_SetBBReg(priv, rFPGA0_XA_RFInterfaceOE, ~(BIT8|BIT9), 0x66e60230);		
+	}
+	PHY_SetBBReg(priv, rBndA, 0xF00000, 0x0a);
+
+	//BB pah B register setting: fix TRSW to TX, external PA off, external LNA off
+	if(is2T)
+	{
+		if(!bInternalPA)
+		{
+			PHY_SetBBReg(priv, rFPGA0_XAB_RFInterfaceSW, bMaskDWord, 0x0f600f60);					
+		PHY_SetBBReg(priv, rFPGA0_XB_RFInterfaceOE, bMaskDWord, 0x061f0130);
+		}
+		else
+		{
+			PHY_SetBBReg(priv, rFPGA0_XAB_RFInterfaceSW, bMaskDWord, 0x07600760);						
+			PHY_SetBBReg(priv, rFPGA0_XB_RFInterfaceOE, bMaskDWord, 0x061f0130);
+		}
+		PHY_SetBBReg(priv, rBndB, 0xF00000, 0x0a);		
+	}
+
+	//MAC register setting
+	_PHY_MACSettingCalibration(priv, MAC_REG, MAC_backup);
+
+	//path A/B DPK
+	//Path-A/B AFE all on
+	for(path=0; path<path_num; path++)	
+	{
+
+		//if(is2T && !pHalData->InternalPA5G[path])		
+			//continue;
+
+		if(path == RF92CD_PATH_B)
+		{
+			//BB pah A register setting:fix TRSW to TX;external LNA off
+			if(!bInternalPA)
+			{
+				PHY_SetBBReg(priv, rFPGA0_XAB_RFInterfaceSW, bMaskDWord, 0x0f600f60);			
+				PHY_SetBBReg(priv, rFPGA0_XA_RFInterfaceOE, ~(BIT8|BIT9), 0x66e60230);		
+			}
+			else
+			{
+				PHY_SetBBReg(priv, rFPGA0_XAB_RFInterfaceSW, bMaskDWord, 0x07600760);			
+				PHY_SetBBReg(priv, rFPGA0_XA_RFInterfaceOE, ~(BIT8|BIT9), 0x66e60230);		
+			}
+			PHY_SetBBReg(priv, rBndA, 0xF00000, 0x0a);
+
+			//BB pah B register setting:fix TRSW to TX;external LNA off
+			if(is2T)
+			{
+				if(!bInternalPA)
+				{
+					PHY_SetBBReg(priv, rFPGA0_XAB_RFInterfaceSW, bMaskDWord, 0x0f600f60);					
+					PHY_SetBBReg(priv, rFPGA0_XB_RFInterfaceOE, bMaskDWord, 0x061f0930);			
+				}
+				else
+				{
+					PHY_SetBBReg(priv, rFPGA0_XAB_RFInterfaceSW, bMaskDWord, 0x07600760);						
+					PHY_SetBBReg(priv, rFPGA0_XB_RFInterfaceOE, bMaskDWord, 0x061f0130);
+				}
+				PHY_SetBBReg(priv, rBndB, 0xF00000, 0x0a);		
+			}			
+		}
+
+		AP_curve_index = 1;
+		rx_index = 0x06;		
+		bPlus3db = FALSE;
+		bDecreaseTxIndex = FALSE;
+	
+		if(path == RF92CD_PATH_A)
+		{
+			_PHY_PathADDAOn(priv, AFE_REG, TRUE, is2T);
+		}
+		else
+		{
+			_PHY_PathADDAOn(priv, AFE_REG, FALSE, is2T);
+		}
+
+		if(path == RF92CD_PATH_B)
+			PHY_SetBBReg(priv, rFPGA1_DebugSelect, bMaskDWord, 0x00000303); 		
+
+		//path A/B RF setting
+		//internal lopback off	
+		if(path == RF92CD_PATH_A && !bInternalPA)
+		{
+			PHY_SetRFReg(priv, RF92CD_PATH_A, RF_MODE1, bMask20Bits, 0x5007f);					
+			PHY_SetRFReg(priv, RF92CD_PATH_A, RF_MODE2, bMask20Bits, 0x6f1f9);								
+		}		
+		else if(path == RF92CD_PATH_B)
+		{
+			PHY_SetRFReg(priv, RF92CD_PATH_A, RF_MODE1, bMask20Bits, 0x1000f);					
+			PHY_SetRFReg(priv, RF92CD_PATH_A, RF_MODE2, bMask20Bits, 0x60103);								
+		}
+
+		PHY_SetRFReg(priv, path, RF_RXRF_A3, bMask20Bits, 0xef456);
+
+		//Path A/B to standby mode
+		PHY_SetRFReg(priv, path==RF92CD_PATH_A?RF92CD_PATH_B:RF92CD_PATH_A, 
+			RF_AC, bMask20Bits, 0x10000);
+
+		//set DPK PA bias table
+		index = priv->pshare->CurrentChannelBW == HT_CHANNEL_WIDTH_20_40?0:1;		
+		if(path == RF92CD_PATH_A)
+		{
+			for(i = 0; i < path_num; i++)
+		{
+				for(j = 0; j < DP_PA_BIAS_NUM; j++)
+					PHY_SetRFReg(priv, i, RF_TXBIAS, bMask20Bits, RF_PA_BIAS[index][j]);	
+			}
+		}
+		
+Step1:
+
+		DPK_DEBUG("==>AP curve select 0x%x bplus3db %d path%s!!\n", RF_AP_curve_select[AP_curve_index], bPlus3db, path==RF92CD_PATH_A?"A":"B");				
+	
+		//RF setting for AP curve selection
+		//default AP curve = 15	
+		PHY_SetRFReg(priv, path, RF_BS_PA_APSET_G1_G4, bMask20Bits, RF_AP_curve_select[AP_curve_index]);	
+
+		//////////////////////////////////////////////////
+		// step 1: find RF TX/RX index
+		/////////////////////////////////////////////////
+		//find RF TX index
+		//=============================
+		// PAGE_B for Path-A PM setting
+		//=============================
+		// open inner loopback @ b00[19]:od 0xb00 0x01097018
+		if(bPlus3db)
+			BB_settings_temp = &(BB_settings_loop_tx_3db[0]);
+		else
+			BB_settings_temp = &(BB_settings_loop_tx[0]);
+		_PHY_SetADDARegisters(priv, BB_REG_loop[path], BB_settings_temp, DP_BB_REG_NUM_loop);
+
+		if(bDecreaseTxIndex)
+			tx_index = 0x19;
+		else
+			tx_index = 0x1f;
+		bDecreaseTxIndexWithRx = FALSE;
+
+		//Set Tx GAC = 0x1f, than find Rx AGC
+		rx_index = _PHY_Find_Rx_Power_Index(priv, tx_index, rx_index, path, &bDecreaseTxIndexWithRx);
+		if(bDecreaseTxIndexWithRx)
+		{
+			if(bDecreaseTxIndex)
+			{
+				PHY_SetBBReg(priv, offset[path][2], bMaskDWord, 0x01017098);	//0xb00, 0xb70				
+				PHY_SetBBReg(priv, offset[path][8], bMaskDWord, 0x28080000);	//0xb68, 0xb6c
+				
+				for(i = 3; i < DP_RF_REG_NUM; i++)
+					PHY_SetRFReg(priv, path, RF_REG[i], bMask20Bits, RF_backup[path][i]);
+
+				//set original DPK bias table
+				for(j = 0; j < DP_PA_BIAS_NUM; j++)
+					PHY_SetRFReg(priv, path, RF_TXBIAS, bMask20Bits, RF_PA_BIAS[2][j]);
+				continue;														
+			}
+			else
+			{
+				bDecreaseTxIndex = TRUE;
+				goto Step1;
+			}
+		}
+
+		//find 2dB loss point
+		//=============================
+		// PAGE_B for Path-A PM setting
+		//=============================
+		// open inner loopback @ b00[19]:od 0xb00 0x01097018
+		if(bPlus3db)
+			BB_settings_temp = &(BB_settings_loop_tx_2_3db[0]);
+		else
+			BB_settings_temp = &(BB_settings_loop_tx_2[0]);
+		_PHY_SetADDARegisters(priv, BB_REG_loop[path], BB_settings_temp, DP_BB_REG_NUM_loop);
+
+		//RF setting
+		PHY_SetRFReg(priv, path, RF_AC, bMask20Bits, 0x52000 | tx_index | (rx_index << 5));
+
+		//----send one shot signal----//
+		PHY_SetBBReg(priv, offset[path][1], bMaskDWord, 0x80080000);	//0xb28, 0xb98
+		PHY_SetBBReg(priv, offset[path][1], bMaskDWord, 0x00080000);
+		
+		//get power
+		if(!_PHY_Find_Tx_Power_Index(priv, PA_power[path], path, bPlus3db, bDecreaseTxIndex, &tx_index))
+		{
+			if(/*tx_index == 0x1f &&*/ !bPlus3db)
+			{
+				if(bDecreaseTxIndex)
+				{
+					if(tx_index < 0x11)
+					{
+						PHY_SetBBReg(priv, offset[path][2], bMaskDWord, 0x01017098);	//0xb00, 0xb70				
+						PHY_SetBBReg(priv, offset[path][8], bMaskDWord, 0x28080000);	//0xb68, 0xb6c
+						
+						for(i = 3; i < DP_RF_REG_NUM; i++)
+							PHY_SetRFReg(priv, path, RF_REG[i], bMask20Bits, RF_backup[path][i]);
+
+						//set original DPK bias table
+						for(j = 0; j < DP_PA_BIAS_NUM; j++)
+							PHY_SetRFReg(priv, path, RF_TXBIAS, bMask20Bits, RF_PA_BIAS[2][j]);
+
+						continue;											
+					}	
+					else
+					{
+						//RTPRINT(FINIT, INIT_IQK, ("==>Check pattern reliability path%s SUCCESS tx_index = 0x1b!!!!\n", path==RF90_PATH_A?"A":"B")); 										
+					}
+				}
+				else if(tx_index < 0x1a)
+				{
+					bDecreaseTxIndex = TRUE;
+					goto Step1; 				
+				}
+				else
+				{
+					bPlus3db = TRUE;
+					goto Step1; 				
+				}
+			}
+			else if(tx_index == 0x1f) 
+			{
+				DPK_DEBUG("==>Check pattern reliability path%s FAIL!!!!\n", path==RF92CD_PATH_A?"A":"B");
+				PHY_SetBBReg(priv, offset[path][2], bMaskDWord, 0x01017098);	//0xb00, 0xb70
+				PHY_SetBBReg(priv, offset[path][8], bMaskDWord, 0x28080000);	//0xb68, 0xb6c
+				
+				for(i = 3; i < DP_RF_REG_NUM; i++)
+					PHY_SetRFReg(priv, path, RF_REG[i], bMask20Bits, RF_backup[path][i]);
+
+				//set original DPK bias table
+				for(j = 0; j < DP_PA_BIAS_NUM; j++)
+					PHY_SetRFReg(priv, path, RF_TXBIAS, bMask20Bits, RF_PA_BIAS[2][j]);
+
+				continue;							
+			}		
+
+		
+		}
+		else
+		{
+			DPK_DEBUG("==>Check pattern reliability path%s SUCCESS!!!!\n", path==RF92CD_PATH_A?"A":"B"); 					
+		}
+
+		//find RF RX index
+		//=============================
+		// PAGE_B for Path-A PM setting
+		//=============================
+		// open inner loopback @ b00[19]:od 0xb00 0x01097018
+		if(bPlus3db)
+			BB_settings_temp = &(BB_settings_loop_rx_3db[0]);
+		else
+			BB_settings_temp = &(BB_settings_loop_rx[0]);
+
+		for(i = 0; i < 4; i++)
+			PHY_SetBBReg(priv, BB_REG_loop[path][i], bMaskDWord, BB_settings_temp[i]);
+		for(; i < 12; i++)
+			PHY_SetBBReg(priv, BB_REG_loop[path][i], bMaskDWord, BB_settings_temp[4]);
+		PHY_SetBBReg(priv, BB_REG_loop[path][i], bMaskDWord, BB_settings_temp[5]);
+		for(; i < 29; i++)
+			PHY_SetBBReg(priv, BB_REG_loop[path][i], bMaskDWord, BB_settings_temp[6]);
+		PHY_SetBBReg(priv, BB_REG_loop[path][i], bMaskDWord, BB_settings_temp[7]);
+		
+		rx_index = _PHY_Find_Rx_Power_Index(priv, tx_index, rx_index, path, &bDecreaseTxIndex);
+
+		//////////////////////////////////////
+		//2.measure PA model
+		//////////////////////////////////////
+		//=========================================
+		//PAGE_B for Path-A PAS setting //=========================================
+		// open inner loopback @ b00[19]:10 od 0xb00 0x01097018
+		if(bPlus3db)
+			BB_settings_temp = &(BB_settings_loop_3db[0]);
+		else
+			BB_settings_temp = &(BB_settings_loop[0]);
+		_PHY_SetADDARegisters(priv, BB_REG_loop[path], BB_settings_temp, DP_BB_REG_NUM_loop);
+
+		//LNA VDD to gnd
+		PHY_SetRFReg(priv,path, RF_AC, bMask20Bits, 0x52000 | tx_index | (rx_index << 5));
+			
+		//----send one shot signal----//
+		// Path A
+		PHY_SetBBReg(priv, offset[path][1], bMaskDWord, 0x80080000);	//0xb28, 0xb98
+		PHY_SetBBReg(priv, offset[path][1], bMaskDWord, 0x00080000);
+		
+		PHY_SetRFReg(priv, RF92CD_PATH_A, RF_T_METER, BIT17|BIT16, 0x03);
+	
+		_PHY_DPK_polling(priv);
+
+		priv->pshare->ThermalValue_DPKstore = (unsigned char)PHY_QueryRFReg(priv, RF92CD_PATH_A, RF_T_METER, 0xf800, 1);	//0x42: RF Reg[15:11] 92D
+		
+		// read PA model and save to PA_model_A[32]
+		for(i = 0; i < DP_PA_MODEL_RUN_NUM; i++)
+		{
+			PHY_SetBBReg(priv, offset[path][2], bMaskDWord, 0x01017018+i);	//0xb00, 0xb70
+			for(index = 0; index < DP_PA_MODEL_PER_RUN_NUM; index++)
+			{
+				PA_model_backup[path][i*4+index] = PHY_QueryBBReg(priv, offset[path][3]+index*4, bMaskDWord);	//0xbdc, 0xbec
+				DPK_DEBUG("==>PA_model_backup index %d value 0x%x()\n", i*4+index, PA_model_backup[path][i*4+index]);			
+			}
+		}
+
+#if 0
+		//find appropriate AP curve
+		if(AP_curve_index != (DP_AP_CUREVE_SELECT_NUM-1))
+		{
+			if(!_PHY_DPK_AP_curve_check(priv, PA_model_backup[path], DP_PA_MODEL_NUM))
+			{
+				DPK_DEBUG("==>find appropriate AP curve 0x%x path%s FAIL!!!!\n", RF_AP_curve_select[AP_curve_index], path==RF92CD_PATH_A?"A":"B");			
+				AP_curve_index++;
+				if(AP_curve_index < DP_AP_CUREVE_SELECT_NUM)
+					goto Step1; 		
+			}
+			else
+			{
+				DPK_DEBUG("==>find appropriate AP curve path%s SUCCESS!!!!\n", path==RF92CD_PATH_A?"A":"B"); 					
+			}
+		}
+#endif
+
+		//check PA model		
+		if(!_PHY_DPK_check(priv, PA_model_backup[path], DP_PA_MODEL_NUM))
+		{
+			PHY_SetBBReg(priv, offset[path][2], bMaskDWord, 0x01017098);	// add in 2011-06-02
+			PHY_SetBBReg(priv, offset[path][8], bMaskDWord, 0x28080000);	//0xb68, 0xb6c
+
+			for(i = 3; i < DP_RF_REG_NUM; i++)
+				PHY_SetRFReg(priv, path, RF_REG[i], bMaskDWord, RF_backup[path][i]);
+			DPK_DEBUG("==>PA model path%s FAIL!!!!\n", path==RF92CD_PATH_A?"A":"B"); 	
+			priv->pshare->bDPKdone[path] = FALSE;							
+			//set original DPK bias table
+			for(j = 0; j < DP_PA_BIAS_NUM; j++)
+				PHY_SetRFReg(priv, path, RF_TXBIAS, bMask20Bits, RF_PA_BIAS[2][j]);
+												
+			continue;
+		}
+		else
+		{
+			DPK_DEBUG("==>PA model path%s SUCCESS!!!!\n", path==RF92CD_PATH_A?"A":"B");			
+//			priv->pshare->bDPKdone[path] = TRUE;	
+//			priv->pshare->bDPKstore = TRUE; 		
+		}
+
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		// step 3: fill PA model to DP Calibration
+		/////////////////////////////////////////////////////////////////////////////////////////////////////
+		//fill BB TX index for the DPK reference 
+		DPK_DEBUG("==>fill PA model to DP Calibration\n"); 		
+
+		if(path == RF92CD_PATH_A){
+			for(index = 0; index < DP_PA_MODEL_RUN_NUM; index++){
+				if(index != 3){
+					PHY_SetBBReg(priv, 0xe00+index*4, bMaskDWord, 0x3c3c3c3c);	
+				} else {
+					PHY_SetBBReg(priv, 0xe00+index*4, bMaskDWord, 0x03903c3c);						
+				}
+			}
+			PHY_SetBBReg(priv, 0x86c, bMaskDWord, 0x3c3c3c3c);	
+		}else if (path == RF92CD_PATH_B){
+			for(index = 0; index < 4; index++) {
+				PHY_SetBBReg(priv, 0x830+index*4, bMaskDWord, 0x3c3c3c3c);			
+			}
+			for(index = 0; index < 2; index++) {
+				PHY_SetBBReg(priv, 0x848+index*4, bMaskDWord, 0x3c3c3c3c);	
+			}
+			for(index = 0; index < 2; index++) {
+				PHY_SetBBReg(priv, 0x868+index*4, bMaskDWord, 0x3c3c3c3c);										
+			}
+		}		
+
+		// SRAM boundary setting
+		PHY_SetBBReg(priv, 0xe28, bMaskDWord, 0x40000000);	
+
+		if(priv->pshare->phw->bNewTxGainTable)
+			PHY_SetBBReg(priv, offset[path][4], bMaskDWord, 0x0008421f);	//0xbc0, 0xbc4	
+		else	
+			PHY_SetBBReg(priv, offset[path][4], bMaskDWord, 0x0009ce7f);	//0xbc0, 0xbc4	
+
+		PHY_SetBBReg(priv, 0xe28, bMaskDWord, 0x00000000);	
+
+		_PHY_SetADDARegisters(priv, BB_REG_loop[path], BB_settings_loop_pa, DP_BB_REG_NUM_loop_pa);
+		
+		// fill PA model to page B1 registers
+		PHY_SetBBReg(priv, 0xe28, bMaskDWord, 0x40000000);	
+		for(index = 0; index < (DP_PA_MODEL_NUM/2); index++){	//path A = 0xb00, path B = 0xb60
+			PHY_SetBBReg(priv, 0xb00+index*4+path*0x60, bMaskDWord, 
+			(PA_model_backup[path][index*2+1] << 16) | PA_model_backup[path][index*2]); 
+		}
+		PHY_SetBBReg(priv, 0xe28, bMaskDWord, 0x00000000);	
+
+		//one shot	
+		PHY_SetBBReg(priv, offset[path][1], bMaskDWord, 0x80044499);	//0xb28, 0xb98
+		PHY_SetBBReg(priv, offset[path][1], bMaskDWord, 0x00044499);
+
+		_PHY_DPK_polling(priv);
+
+#if 1
+		//////////////////////////////////////////////////////
+		// step 4: calculate gain loss caused by DP
+		//////////////////////////////////////////////////////
+		PHY_SetBBReg(priv, offset[path][2], bMaskDWord, 0x0029701f);	//0xb00, 0xb70
+		tmpReg = PHY_QueryBBReg(priv, offset[path][5], bMaskDWord); 	//0xbe8, 0xbf8
+
+		power_I = (tmpReg >> 16);
+		if(power_I & BIT(15))
+			power_I |= bMaskLWord; ////////ZZZZZZZZZZZZZZZZZZ
+		
+		power_Q = tmpReg & bMaskLWord;
+		if(power_Q & BIT(15))
+			power_Q |= bMaskHWord;
+
+		DPK_DEBUG("0x%x =  0x%x power_I = 0x%x power_Q = 0x%x\n", offset[path][5], tmpReg, power_I, power_Q);
+
+		tmpReg = power_I*power_I + power_Q*power_Q;
+
+		DPK_DEBUG("gain loss =	0x%x \n", tmpReg); 					
+
+		if(tmpReg < 26090)
+		{
+			PHY_SetBBReg(priv, offset[path][2], bMaskDWord, 0x01017098);	//0xb00, 0xb70						
+			PHY_SetBBReg(priv, offset[path][8], bMaskDWord, 0x28080000);	//0xb68, 0xb6c
+
+			for(i = 3; i < DP_RF_REG_NUM; i++)
+				PHY_SetRFReg(priv, path, RF_REG[i], bMask20Bits, RF_backup[path][i]);
+			priv->pshare->bDPKdone[path] = FALSE;							
+			//set original DPK bias table
+			for(j = 0; j < DP_PA_BIAS_NUM; j++)
+				PHY_SetRFReg(priv, path, RF_TXBIAS, bMask20Bits, RF_PA_BIAS[2][j]);					
+			
+			continue;		
+		}
+		else
+		{
+			priv->pshare->bDPKdone[path] = TRUE;	
+			priv->pshare->bDPKstore = TRUE; 		
+		}
+
+		for(i = 0; i < DP_GAIN_LOSS_BOUND_NUM; i++)
+		{
+#if DP_gain_loss == 1						
+			if(tmpReg > gain_loss_bound[i]/* || i == (DP_GAIN_LOSS_BOUND_NUM -1)*/) 	
+#else				
+			if(tmpReg > gain_loss_bound[i] || i == (DP_GAIN_LOSS_BOUND_NUM -1))
+#endif				
+			{
+#if DP_gain_loss == 0
+				if(i == 0)
+					break;
+	
+				index = OFDM_index[path] > i?OFDM_index[path]-i:0;
+				if(index < OFDM_min_index_internalPA)
+					index = OFDM_min_index_internalPA;
+				PHY_SetBBReg(priv, offset[path][6], bMaskDWord, OFDMSwingTable[index]); //0xc80, 0xc88							
+				DPK_DEBUG("original index 0x%x gain_loss minus index 0x%x\n", priv->pshare->OFDM_index[0], i); 					
+#endif
+				break;
+			}
+		}
+	
+#if DP_gain_loss == 1
+	
+		DPK_DEBUG("gain_loss Compensated coefficient %d\n", gain_loss_coef[i]);					
+		coef = gain_loss_coef[i];
+		GainLossIndex = i;
+		priv->pshare->OFDM_min_index_internalPA_DPK[path] = GainLossIndex == 0?0:(GainLossIndex/2+GainLossIndex%2);		
+		
+		//read DP LUT value from register
+		for(i = 0; i < DP_PA_MODEL_RUN_NUM; i++)
+		{
+			PHY_SetBBReg(priv, offset[path][2], bMaskDWord, 0x00297018+i);	//0xb00, 0xb70
+			for(index = 0; index < DP_PA_MODEL_PER_RUN_NUM; index++)
+			{
+				tmpReg = (i == 0 && index==0)?0x01000000:PHY_QueryBBReg(priv, offset[path][3]+index*4, bMaskDWord); //0xbdc, 0xbec		
+
+				gain_loss_backup[1][i*4+index] = (tmpReg >> 16);			//I
+				if(gain_loss_backup[1][i*4+index] & BIT(15))
+					gain_loss_backup[1][i*4+index] |= bMaskHWord;			
+				
+				gain_loss_backup[0][i*4+index] = (tmpReg & bMaskLWord); //Q
+				if(gain_loss_backup[0][i*4+index] & BIT(15))
+					gain_loss_backup[0][i*4+index] |= bMaskHWord;				
+				DPK_DEBUG("==>DP LUT index %d value 0x%x() I = 0x%x, Q = 0x%x\n", i*4+index, tmpReg, gain_loss_backup[1][i*4+index], gain_loss_backup[0][i*4+index]);												
+	
+				//gain * LUT			
+				for(j = 0; j < 2; j++)
+				{
+	//				RTPRINT(FINIT, INIT_IQK, ("==>0DP LUT sram %s index %d value %d()\n", j == 0?"Q":"I", i*4+index, gain_loss_backup[j][i*4+index]));												
+				
+					gain_loss_backup[j][i*4+index] = (gain_loss_backup[j][i*4+index] * coef) / (int)(512);
+	//				RTPRINT(FINIT, INIT_IQK, ("==>1DP LUT sram %s index %d value 0x%x()\n", j == 0?"Q":"I", i*4+index, gain_loss_backup[j][i*4+index]));												
+					
+					gain_loss_backup[j][i*4+index] = gain_loss_backup[j][i*4+index] >= (int)(512)?(int)(511):gain_loss_backup[j][i*4+index] < (int)(-512)?(int)(-512):gain_loss_backup[j][i*4+index];
+	//				RTPRINT(FINIT, INIT_IQK, ("==>2DP LUT sram %s index %d value 0x%x()\n", j == 0?"Q":"I", i*4+index, gain_loss_backup[j][i*4+index]));												
+					
+					gain_loss_backup[j][i*4+index] = gain_loss_backup[j][i*4+index] >> 2;
+	//				RTPRINT(FINIT, INIT_IQK, ("==>3DP LUT sram %s index %d value 0x%x()\n", j == 0?"Q":"I", i*4+index, gain_loss_backup[j][i*4+index]));												
+					
+				}
+				tmpReg = ((gain_loss_backup[1][i*4+index] & bMaskByte0) << 8 ) | ((gain_loss_backup[0][i*4+index] & bMaskByte0));
+				gain_loss_backup[0][i*4+index] = tmpReg & bMaskLWord;
+				DPK_DEBUG("==>DP LUT sram index %d value 0x%x()\n", i*4+index, tmpReg);												
+			}
+		}
+	
+		//write DP LUT into sram
+		for(i = 0; i < DP_PA_MODEL_NUM; i++)
+		{
+			value32 =  (path==RF92CD_PATH_A?((i%2 == 0)?0x01000000:0x02000000):
+				((i%2 == 0)?0x04000000:0x08000000)) | 
+				gain_loss_backup[0][(DP_PA_MODEL_NUM-1)-i] |( (i/2) << 16); 	
+			DPK_DEBUG("0xb2c value = 0x%x\n",  value32);									
+			PHY_SetBBReg(priv, 0xb2c , bMaskDWord, value32);		
+		}
+//		PHY_SetBBReg(priv, 0xb2c , bMaskDWord, 0x00000000); 		
+			
+#endif
+			
+#endif
+	
+		///////////////////////////////////////////////////////////////
+		// step 5: Enable Digital Predistortion
+		///////////////////////////////////////////////////////////////
+		// LUT from sram
+#if DP_gain_loss == 1
+		{
+			_PHY_SetADDARegisters(priv, BB_REG_loop[path], BB_settings_loop_dp, DP_BB_REG_NUM_loop_pa);
+
+			// pwsf boundary
+			PHY_SetBBReg(priv, offset[path][7], bMaskDWord, 0x000fffff);	//0xb30, 0xba0
+
+			// write pwsf to sram				
+			//find tx_index index value
+			SramIndex = 24; //restore default value
+			SramIndex -= GainLossIndex;
+			if(bPlus3db)
+				SramIndex += 3*4;			
+
+			SramIndex = SramIndex >= DP_SRAM_NUM_db?DP_SRAM_NUM_db-1:(SramIndex<0?0:SramIndex);
+			
+			DPK_DEBUG("tx_index = 0x%x, sram value 0x%x gainloss index %d bPlus3db %d\n",  tx_index, Sram_db_settings[SramIndex], GainLossIndex, bPlus3db);						
+
+			index = 0x1f - tx_index;			
+			if(SramIndex >= index*4)
+			{
+				index = SramIndex - index*4;
+				index_repeat = -2;
+				SramIndex = -2;
+			}
+			else
+			{
+				index_repeat = index - SramIndex/4;
+				SramIndex %= 4;
+				index = 0;				
+			}
+
+			index = index >= DP_SRAM_NUM_db?DP_SRAM_NUM_db-1:index;
+			if(index_repeat == 1)
+				index_1 = SramIndex;
+			else
+				index_1 = index < (DP_SRAM_NUM_db-1)?(index_repeat==-2?index+1*4:index):index;
+
+			DPK_DEBUG("0x1f value = 0x%x, index 0x%x repeat %d SramIndex %d\n",  Sram_db_settings[index], index, index_repeat, SramIndex); 					
+			
+			for(i = 0; i < DP_SRAM_NUM; i++)
+			{								
+				value32 = (path==RF92CD_PATH_A?0x10000000:0x20000000) | (i << 16) | 
+					(Sram_db_settings[index_1] << 8 )| Sram_db_settings[index]; 	
+				DPK_DEBUG("0xb2c value = 0x%x\n",  value32);					
+				
+				PHY_SetBBReg(priv, 0xb2c , bMaskDWord, value32);
+				if(index_repeat >= 0)
+					index_repeat -= 2;
+				else if(index_repeat == -1)
+					index_repeat = -2;
+					
+				if((index < (DP_SRAM_NUM_db-1)-1))
+				{
+					if(index_repeat == -2)
+					{						
+						index+=2*4;
+						index_1 = index < (DP_SRAM_NUM_db-1)?index+1*4:index;		
+					}
+					if(index_repeat == 0)
+					{
+						index = SramIndex;
+						index_1 = index < (DP_SRAM_NUM_db-1)?index+1*4:index;		
+					}	
+					else if(index_repeat == 1)
+					{						
+						index_1 = SramIndex;
+					}
+					else if(index_repeat == -1)
+					{
+						index = index_1+1*4;
+						index_1 = index < (DP_SRAM_NUM_db-1)?index+1*4:index;								
+					}
+				}
+				else
+				{
+					index = index_1 = (DP_SRAM_NUM_db-1);
+				}
+
+				index = index < DP_SRAM_NUM_db?index:DP_SRAM_NUM_db-1;
+				index_1 = index_1 < DP_SRAM_NUM_db?index_1:DP_SRAM_NUM_db-1;
+			}
+		}		
+#else		
+		if(!SkipStep5)
+		{
+			_PHY_SetADDARegisters(priv, BB_REG_loop[path], BB_settings_loop_dp, DP_BB_REG_NUM_loop_pa);
+
+			// pwsf boundary
+			PHY_SetBBReg(priv, offset[path][7], bMaskDWord, 0x000fffff);	//0xb30, 0xba0
+
+			// write pwsf to sram				
+			//find RF0x1f index value
+			if(bPlus3db)
+				tx_index += 3;
+
+//			tx_index = 0x21;
+			
+			index = 0x1f - tx_index;
+			if(index_for_zero_db >= index)
+			{
+				index = index_for_zero_db - index;
+				index_repeat = -2;
+			}
+			else
+			{
+				index_repeat = index - index_for_zero_db;
+				index = 0;				
+			}
+
+			index = index >= DP_SRAM_NUM_db?DP_SRAM_NUM_db-1:index;
+			index_1 = index < (DP_SRAM_NUM_db-1)?(index_repeat==-2?index+1:index):index;
+
+			DPK_DEBUG("0x1f value = 0x%x, index 0x%x repeat %d\n",	Sram_db_settings[index], index, index_repeat); 					
+			
+			for(i = 0; i < DP_SRAM_NUM; i++)
+			{								
+				value32 = (path==RF92CD_PATH_A?0x10000000:0x20000000) | (i << 16) | 
+					(Sram_db_settings[index_1] << 8 )| Sram_db_settings[index]; 	
+				DPK_DEBUG("0xb2c value = 0x%x\n",  value32);					
+				
+				PHY_SetBBReg(priv, 0xb2c , bMaskDWord, value32);
+				if(index_repeat >= 0)
+					index_repeat -= 2;
+				else if(index_repeat == -1)
+					index_repeat = -2;
+					
+				if((index < (DP_SRAM_NUM_db-1)-1))
+				{
+					if(index_repeat == -2)
+					{
+						index += 2;
+						index_1 = index < (DP_SRAM_NUM_db-1)?index+1:index; 	
+					}
+					if(index_repeat == 0)
+					{
+						index_1 = index < (DP_SRAM_NUM_db-1)?index+1:index; 	
+					}					
+					else if(index_repeat == -1)
+					{
+						index++;
+						index_1 = index < (DP_SRAM_NUM_db-1)?index+1:index; 							
+					}
+				}
+				else
+				{
+					index = index_1 = (DP_SRAM_NUM_db-1);
+				}
+			}
+		}
+#endif		
+	}
+
+	//reload RF default value
+	for(path = 0; path<path_num; path++){
+		for( i = 2 ; i < 3 ; i++){
+			PHY_SetRFReg(priv, path, RF_REG[i], bMask20Bits, RF_backup[path][i]);
+		}
+	}
+
+	//Reload standby mode default value (if path B excute DPK)
+	if(is2T && priv->pshare->phw->InternalPA5G[RF92CD_PATH_B]) 	
+	{
+		PHY_SetRFReg(priv, RF92CD_PATH_A, RF_MODE1, bMask20Bits, 0x1000f);
+		PHY_SetRFReg(priv, RF92CD_PATH_A, RF_MODE2, bMask20Bits, 0x60101);		
+	}
+	
+	//reload BB default value
+	for(index=0; index<DP_BB_REG_NUM; index++)
+		PHY_SetBBReg(priv, BB_REG[index], bMaskDWord, BB_backup[index]);
+
+	//external LNA on	
+	PHY_SetBBReg(priv, rBndA, 0xF00000, 0x00);
+	
+	if(is2T)
+		PHY_SetBBReg(priv, rBndB, 0xF00000, 0x00);
+
+	//Reload path A BB default value
+	_PHY_ReloadADDARegisters(priv, BB_REG_A, BB_backup_A, DP_BB_REG_NUM_A);
+
+
+#if 1 //Return to Rx mode after dpk
+	//printk("BB_REG_A[9] 0x%x BB_backup_A[9] 0x%x\n\n", BB_REG_A[9], BB_backup_A[9]);
+	PHY_SetBBReg(priv, BB_REG_A[9], bMaskByte0, 0x50);
+	PHY_SetBBReg(priv, BB_REG_A[9], bMaskDWord, BB_backup_A[9]);
+#endif
+
+	//Reload path B default value
+	if(is2T)
+		_PHY_ReloadADDARegisters(priv, BB_REG_B, BB_backup_B, DP_BB_REG_NUM_B);
+
+#if 1 //Return to Rx mode after dpk
+	//printk("BB_REG_B[8] 0x%x BB_backup_B[8] 0x%x\n\n", BB_REG_B[8], BB_backup_B[8]);
+	PHY_SetBBReg(priv, BB_REG_B[8], bMaskByte0, 0x50);
+	PHY_SetBBReg(priv, BB_REG_B[8], bMaskDWord, BB_backup_B[8]);
+#endif
+	
+	//reload AFE default value
+	_PHY_ReloadADDARegisters(priv, AFE_REG, AFE_backup, IQK_ADDA_REG_NUM);	
+
+	//reload MAC default value	
+	_PHY_ReloadMACRegisters(priv, MAC_REG, MAC_backup);
+
+	priv->pshare->bDPKworking = FALSE;
+
+	DPK_DEBUG("<==_PHY_DigitalPredistortion()\n");
+}
+
+#endif
+
+
+#ifdef CONFIG_RTL_92D_DMDP
+
+void IQK_92D_2G_phy1(struct rtl8192cd_priv *priv)
+{
+	unsigned int cal_num=0, cal_retry=0, Oldval=0, temp_c04=0, temp_c08=0, temp_874=0, temp_eac;
+	unsigned int cal_e94, cal_e9c, cal_ea4, cal_eac;
+	unsigned int X, Y, val_e94[3], val_e9c[3], val_ea4[3], val_eac[3];
+	unsigned int ADDA_REG[IQK_ADDA_REG_NUM] = {0x85c, 0xe6c, 0xe70, 0xe74, 	0xe78, 0xe7c, 0xe80, 0xe84,
+												0xe88, 0xe8c, 0xed0, 0xed4, 0xed8, 0xedc, 0xee0, 0xeec};
+	unsigned int ADDA_backup[IQK_ADDA_REG_NUM], i;
+	u8 temp_522, temp_550, temp_551;
+	u32 temp_040, temp_870, temp_860, temp_864, temp_800, temp_88c;
+	u8 switch2PI = 0;
+
+
+#ifdef MP_TEST
+	if (!priv->pshare->rf_ft_var.mp_specific)
+#endif
+	{
+		if (priv->pshare->iqk_2g_done)
+			return;
+		priv->pshare->iqk_2g_done = 1;
+	}
+
+	printk(">> %s \n",__FUNCTION__);
+
+	// Save ADDA power saving parameters
+	for( i = 0 ; i < IQK_ADDA_REG_NUM ; i++)
+		ADDA_backup[i] = RTL_R32(ADDA_REG[i]);
+
+	/*
+	 * Save MAC default value
+	 */
+	temp_522 = RTL_R8(0x522);
+	temp_550 = RTL_R8(0x550);
+	temp_551 = RTL_R8(0x551);
+	temp_040 = RTL_R32(0x40);
+
+	// Save BB default
+	temp_800 = RTL_R32(0x800);
+	temp_870 = RTL_R32(0x870);
+	temp_860 = RTL_R32(0x860);
+	temp_864 = RTL_R32(0x864);
+	temp_88c = RTL_R32(0x88c);
+
+	// Path-A ADDA all on
+	for( i = 0 ; i < IQK_ADDA_REG_NUM ; i++) {
+#ifdef NON_INTR_ANTDIV
+		if (DMDP_PHY_QueryBBReg(0, 0xb30,BIT(27)))
+			RTL_W32(ADDA_REG[i], 0x04db25a4);
+		else
+#endif
+		RTL_W32(ADDA_REG[i], 0x0b1b25a4);
+	}
+
+
+	// IQ&LO calibration Setting
+
+	/*
+	 *	IQK must be done in PI mode
+	 */
+	if (!PHY_QueryBBReg(priv, 0x820, BIT(8)) || !PHY_QueryBBReg(priv, 0x828, BIT(8))) {
+		PHY_SetBBReg(priv, 0x820, bMaskDWord, 0x01000100);
+		PHY_SetBBReg(priv, 0x828, bMaskDWord, 0x01000100);
+		switch2PI++;
+	}
+
+	//BB setting
+	temp_c04 = RTL_R32(0xc04);
+	temp_c08 = RTL_R32(0xc08);
+	temp_874 = RTL_R32(0x874);
+	PHY_SetBBReg(priv, 0x800, BIT(24), 0);
+	RTL_W32(0xc04, 0x03a05600);
+	RTL_W32(0xc08, 0x000800e4);
+	RTL_W32(0x874, 0x22204000);
+
+	PHY_SetBBReg(priv, 0x870, BIT(10), 1);
+	PHY_SetBBReg(priv, 0x870, BIT(26), 1);
+	PHY_SetBBReg(priv, 0x860, BIT(10), 0);
+	PHY_SetBBReg(priv, 0x864, BIT(10), 0);
+
+	PHY_SetBBReg(priv,0x88c,0x00f00000,0xf);
+
+	RTL_W32(0x840, 0x00010000);
+
+	//MAC register setting
+	RTL_W8(0x522, 0x3f);
+	RTL_W8(0x550, RTL_R8(0x550)& (~BIT(3)));
+	RTL_W8(0x551, RTL_R8(0x551)& (~BIT(3)));
+	RTL_W32(0x40, 0);
+
+	//AP or IQK
+	RTL_W32(0xb68 , 0x0f600000);
+	RTL_W32(0xb6c , 0x0f600000);
+
+	// IQK setting
+	RTL_W32(0xe28, 0x80800000);
+	RTL_W32(0xe40, 0x01007c00);
+	RTL_W32(0xe44, 0x01004800);
+
+	// path-A IQK setting
+	RTL_W32(0xe30, 0x10008c22);
+	RTL_W32(0xe34, 0x10008c22);
+	RTL_W32(0xe38, 0x82140102);
+	RTL_W32(0xe3c, 0x28160206);
+
+	// LO calibration setting
+	RTL_W32(0xe4c, 0x00462911);
+
+	// delay to ensure Path-A IQK success
+	delay_ms(10);
+
+	// step 4: One shot, path A LOK & IQK
+	while (cal_num < 3) {
+			// One shot, path A LOK & IQK
+		RTL_W32(0xe48, 0xf9000000);
+		RTL_W32(0xe48, 0xf8000000);
+			// delay 1ms
+		delay_ms(1);
+
+		// check fail bit and check abnormal condition, then fill BB IQ matrix
+		cal_e94 = (RTL_R32(0xe94) >> 16) & 0x3ff;
+		cal_e9c = (RTL_R32(0xe9c) >> 16) & 0x3ff;
+		cal_ea4 = (RTL_R32(0xea4) >> 16) & 0x3ff;
+		temp_eac = RTL_R32(0xeac);
+		cal_eac = (temp_eac >> 16) & 0x3ff;
+		if (!(temp_eac & BIT(28)) && !(temp_eac & BIT(27)) &&
+			(cal_e94 != 0x142) && (cal_e9c != 0x42) &&
+			(cal_ea4 != 0x132) && (cal_eac != 0x36)) {
+			val_e94[cal_num] = cal_e94;
+			val_e9c[cal_num] = cal_e9c;
+			val_ea4[cal_num] = cal_ea4;
+			val_eac[cal_num] = cal_eac;
+			cal_num++;
+		} else {
+			if (++cal_retry >= 10) {
+				printk("%s Path-A Check\n",__FUNCTION__);
+				break;
+			}
+		}
+	}
+
+	if (cal_num == 3) {
+		cal_e94 = get_mean_of_2_close_value(val_e94);
+		cal_e9c = get_mean_of_2_close_value(val_e9c);
+		cal_ea4 = get_mean_of_2_close_value(val_ea4);
+		cal_eac = get_mean_of_2_close_value(val_eac);
+
+		priv->pshare->RegE94=cal_e94;
+		priv->pshare->RegE9C=cal_e9c;
+
+		Oldval = (RTL_R32(0xc80) >> 22) & 0x3ff;
+
+		X = cal_e94;
+		PHY_SetBBReg(priv, 0xc80, 0x3ff, (X * Oldval) >> 8);
+		PHY_SetBBReg(priv, 0xc4c, BIT(24), ((X * Oldval) >> 7) & 0x1);
+
+		Y = cal_e9c;
+		if ((Y & 0x00000200) != 0)
+			Y = Y | 0xFFFFFC00;
+		PHY_SetBBReg(priv, 0xc94, 0xf0000000, (((Y * Oldval) >> 8) >> 6) & 0xf);
+		PHY_SetBBReg(priv, 0xc80, 0x003f0000, ((Y * Oldval) >> 8) & 0x3f);
+		PHY_SetBBReg(priv, 0xc4c, BIT(26), ((Y * Oldval) >> 7) & 0x1);
+
+		PHY_SetBBReg(priv, 0xc14, 0x3ff, cal_ea4);
+
+		PHY_SetBBReg(priv, 0xc14, 0xfc00, cal_eac & 0x3f);
+
+		PHY_SetBBReg(priv, 0xca0, 0xf0000000, (cal_eac >> 6) & 0xf);
+	}else {
+		priv->pshare->RegE94=0x100;
+		priv->pshare->RegE9C=0x00;
+	}
+
+	// back to BB mode, load original values
+	RTL_W32(0xe28, 0);
+	RTL_W32(0xc04, temp_c04);
+	RTL_W32(0xc08, temp_c08);
+	RTL_W32(0x874, temp_874);
+	RTL_W32(0x800, temp_800);
+
+	RTL_W32(0x88c, temp_88c);
+	RTL_W32(0x840, 0x32fff);
+	RTL_W32(0x870, temp_870);
+	RTL_W32(0x860, temp_860);
+	RTL_W32(0x864, temp_864);
+
+	// return to SI mode
+	if (switch2PI) {
+		RTL_W32(0x820, 0x01000000);
+		RTL_W32(0x828, 0x01000000);
+	}
+
+#if defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+	REG32(BSP_WDTCNR) |=  1 << 23;
+#endif
+
+	/*
+	 *	Reload ADDA power saving parameters
+	 */
+	for(i = 0 ; i < IQK_ADDA_REG_NUM ; i++)
+		PHY_SetBBReg(priv, ADDA_REG[i], bMaskDWord, ADDA_backup[i]);
+
+	/*
+	 *	Reload MAC default value
+	 */
+	RTL_W8(0x550, temp_550);
+	RTL_W8(0x551, temp_551);
+	RTL_W32(0x40, temp_040);
+	RTL_W8(0x522, temp_522);
+
+}
+
+
+void IQK_92D_5G_phy0_n(struct rtl8192cd_priv *priv)
+{
+	unsigned int temp_800, temp_c04, temp_874, temp_c08, temp_870, temp_860, temp_88c, temp_c50, temp_b30,
+				switch2PI=0, X, reg; //, Oldval_0, TX0_A;
+	u8 temp_522, temp_550, temp_551;
+	unsigned int cal_num=0, cal_retry=0, ADDA_backup[IQK_ADDA_REG_NUM];
+	int Y, result[8][3], result_final[8]; //, TX0_C;
+
+	unsigned int i, RX0REG0xe40[3], RX0REG0xe40_final=0, REG0xe40, REG0xe94, REG0xe9c, delay_count;
+	unsigned int REG0xeac, REG0xea4;
+	unsigned char TX0IQKOK = FALSE;
+	unsigned int TX_X0, TX_Y0, RX_X0, RX_Y0;
+	unsigned int ADDA_REG[IQK_ADDA_REG_NUM] = {0x85c, 0xe6c, 0xe70, 0xe74,	0xe78, 0xe7c, 0xe80, 0xe84,
+												0xe88, 0xe8c, 0xed0, 0xed4, 0xed8, 0xedc, 0xee0, 0xeec};
+
+#ifdef MP_TEST
+	if (!priv->pshare->rf_ft_var.mp_specific)
+#endif
+	{
+		if (priv->pshare->iqk_5g_done)
+			return;
+		priv->pshare->iqk_5g_done = 1;
+	}
+
+	printk(">> %s \n",__FUNCTION__);
+#if defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+	REG32(BSP_WDTCNR) |=  1 << 23;
+#endif
+	/*
+	 * Save MAC default value
+	 */
+	temp_522 = RTL_R8(0x522);
+	temp_550 = RTL_R8(0x550);
+	temp_551 = RTL_R8(0x551);
+
+	/*
+	 *	Save BB Parameter
+	 */
+	temp_800 = RTL_R32(0x800);
+	temp_c04 = RTL_R32(0xc04);
+	temp_874 = RTL_R32(0x874);
+	temp_c08 = RTL_R32(0xc08);
+	temp_870 = RTL_R32(0x870);
+	temp_860 = RTL_R32(0x860);
+	temp_88c = RTL_R32(0x88c);
+	temp_c50 = RTL_R32(0xc50);
+	temp_b30 = RTL_R32(0xb30);	// 03/03/2011 update
+
+	/*
+	*	Save AFE Parameters
+	*/
+	for( i = 0 ; i < IQK_ADDA_REG_NUM ; i++)
+		ADDA_backup[i] = RTL_R32(ADDA_REG[i]);
+
+	/*
+	 *	==============
+	 *	Path-A TX/RX IQK
+	 *	==============
+	 */
+	while (cal_num < 3) {
+		/*
+		 *	Path-A AFE all on
+		 */
+		for( i = 0 ; i < IQK_ADDA_REG_NUM ; i++) {
+#ifdef NON_INTR_ANTDIV
+			if (DMDP_PHY_QueryBBReg(0, 0xb30,BIT(27)))
+				RTL_W32(ADDA_REG[i], 0x0b1b25a4);
+			else
+#endif
+			RTL_W32(ADDA_REG[i], 0x04db25a4);
+		}
+
+		/*
+		 *	MAC register setting
+		 */
+		RTL_W8(0x522, 0x3f);
+		RTL_W8(0x550, RTL_R8(0x550)& (~BIT(3)));
+		RTL_W8(0x551, RTL_R8(0x551)& (~BIT(3)));
+
+		/*
+		 *	IQK must be done in PI mode
+		 */
+		if (!PHY_QueryBBReg(priv, 0x820, BIT(8)) || !PHY_QueryBBReg(priv, 0x828, BIT(8))) {
+			PHY_SetBBReg(priv, 0x820, bMaskDWord, 0x01000100);
+			PHY_SetBBReg(priv, 0x828, bMaskDWord, 0x01000100);
+			switch2PI++;
+		}
+
+		/*
+		 *	BB setting
+		 */
+		PHY_SetBBReg(priv, 0x800, BIT(24), 0);
+		PHY_SetBBReg(priv, 0xc04, bMaskDWord, 0x03a05600);
+		PHY_SetBBReg(priv, 0xc08, bMaskDWord, 0x000800e4);
+		PHY_SetBBReg(priv, 0x874, bMaskDWord, 0x22208000);
+		PHY_SetBBReg(priv, 0x88c, BIT(23)|BIT(22)|BIT(21)|BIT(20), 0xf);
+		PHY_SetBBReg(priv, 0xb30, bMaskDWord, 0x00a00000);	// 03/03/2011 update
+
+		/*
+		 *	AP or IQK
+		 */
+		//PHY_SetBBReg(priv, 0xb68, bMaskDWord, 0x0f600000);
+		//PHY_SetBBReg(priv, 0xb6c, bMaskDWord, 0x0f600000);
+
+		// IQK-R03 2011/02/16 update
+		PHY_SetBBReg(priv, 0xb00, bMaskDWord, 0);
+		PHY_SetBBReg(priv, 0xb68, bMaskDWord, 0x20000000);
+
+		/*
+		 *	IQK global setting
+		 */
+		PHY_SetBBReg(priv, 0xe28, bMaskDWord, 0x80800000);
+		PHY_SetBBReg(priv, 0xe40, bMaskDWord, 0x10007c00);
+		PHY_SetBBReg(priv, 0xe44, bMaskDWord, 0x01004800);
+
+		/*
+		 *	path-A IQK setting
+		 */
+		PHY_SetBBReg(priv, 0xe30, bMaskDWord, 0x18008c1f);
+		PHY_SetBBReg(priv, 0xe34, bMaskDWord, 0x18008c1f);
+		PHY_SetBBReg(priv, 0xe38, bMaskDWord, 0x82140307);	// 01/11/2011 update
+
+#ifdef USB_POWER_SUPPORT
+		PHY_SetBBReg(priv, 0xe3c, bMaskDWord, 0x68160c66);
+#else
+		PHY_SetBBReg(priv, 0xe3c, bMaskDWord, 0x68160960);	// 01/11/2011 update
+#endif
+		/*
+		 *	LO calibration setting
+		 */
+		PHY_SetBBReg(priv, 0xe4c, bMaskDWord, 0x00462911);
+
+#ifdef USB_POWER_SUPPORT
+		//	PHY0 TRSW seting
+		PHY_SetBBReg(priv, 0x870, BIT(6)|BIT(5), 3);
+		PHY_SetBBReg(priv, 0x860, BIT(6)|BIT(5), 3);
+#else
+		/*
+		 *	path-A PA on
+		 */
+		/*
+		PHY_SetBBReg(priv, 0x870, BIT(11)|BIT(10), 3);
+		PHY_SetBBReg(priv, 0x870, BIT(6)|BIT(5), 3);
+		PHY_SetBBReg(priv, 0x860, BIT(11)|BIT(10), 3);
+		 */
+		PHY_SetBBReg(priv, 0x870, bMaskDWord, 0x07000f60);	// 01/11/2011 update
+		PHY_SetBBReg(priv, 0x860, bMaskDWord, 0x66e60e30);	// 01/11/2011 update
+#endif
+		/*
+		 *	One shot, path A LOK & IQK
+		 */
+		PHY_SetBBReg(priv, 0xe48, bMaskDWord, 0xf9000000);
+		PHY_SetBBReg(priv, 0xe48, bMaskDWord, 0xf8000000);
+
+		/*
+		 *	Delay 10 ms
+		 */
+		delay_ms(10);
+
+		delay_count = 0;
+		while (1){
+			REG0xeac = PHY_QueryBBReg(priv, 0xeac, bMaskDWord);
+			if ((REG0xeac&BIT(26))||(delay_count>20)){
+				break;
+			}else {
+				delay_ms(1);
+				delay_count++;
+			}
+		}
+
+		/*
+		 *	Check_TX_IQK_A_result
+		 */
+		REG0xe40 = PHY_QueryBBReg(priv, 0xe40, bMaskDWord);
+		REG0xeac = PHY_QueryBBReg(priv, 0xeac, bMaskDWord);
+		REG0xe94 = PHY_QueryBBReg(priv, 0xe94, bMaskDWord);
+		if(((REG0xeac&BIT(28)) == 0) && (((REG0xe94&0x3FF0000)>>16)!=0x142)) {
+			TX0IQKOK = TRUE;
+			REG0xe9c = PHY_QueryBBReg(priv, 0xe9c, bMaskDWord);
+			TX_X0 = (PHY_QueryBBReg(priv, 0xe94, bMaskDWord)&0x3FF0000)>>16;
+			TX_Y0 = (PHY_QueryBBReg(priv, 0xe9c, bMaskDWord)&0x3FF0000)>>16;
+			RX0REG0xe40[cal_num] =	(REG0xe40 & 0xfc00fc00) | (TX_X0<<16) | TX_Y0;
+			DEBUG_INFO("TX_X0 %08x TX_Y0 %08x RX0REG0xe40 %08x\n", TX_X0, TX_Y0, RX0REG0xe40[cal_num]);
+			result[0][cal_num] = TX_X0;
+			result[1][cal_num] = TX_Y0;
+		} else {
+			TX0IQKOK = FALSE;
+			if (++cal_retry >= 10) {
+				printk("%s Path-A Tx/Rx Check\n",__FUNCTION__);
+				break;
+			}
+		}
+
+		/*
+		 *	Check_RX_IQK_A_result
+		 */
+		if(TX0IQKOK == TRUE) {
+			REG0xeac = PHY_QueryBBReg(priv, 0xeac, bMaskDWord);
+			REG0xea4 = PHY_QueryBBReg(priv, 0xea4, bMaskDWord);
+			if(((REG0xeac&BIT(27)) == 0) && (((REG0xea4&0x3FF0000)>>16)!=0x132)) {
+				RX_X0 =  (PHY_QueryBBReg(priv, 0xea4, bMaskDWord)&0x3FF0000)>>16;
+				RX_Y0 =  (PHY_QueryBBReg(priv, 0xeac, bMaskDWord)&0x3FF0000)>>16;
+				DEBUG_INFO("RX_X0 %08x RX_Y0 %08x\n", RX_X0, RX_Y0);
+				result[2][cal_num] = RX_X0;
+				result[3][cal_num] = RX_Y0;
+				cal_num++;
+			} else {
+				PHY_SetBBReg(priv, 0xc14, bMaskDWord, 0x40000100);
+				PHY_SetBBReg(priv, 0xe34, bMaskDWord, 0x19008c00);
+				if (++cal_retry >= 10) {
+					printk("%s Path-A Tx/Rx Check\n",__FUNCTION__);
+					break;
+				}
+			}
+		}
+	}
+
+	if (cal_num == 3) {
+		result_final[0] = get_mean_of_2_close_value(result[0]);
+		result_final[1] = get_mean_of_2_close_value(result[1]);
+		result_final[2] = get_mean_of_2_close_value(result[2]);
+		result_final[3] = get_mean_of_2_close_value(result[3]);
+		RX0REG0xe40_final = 0x80000000 | get_mean_of_2_close_value(RX0REG0xe40);
+
+		priv->pshare->RegE94=result_final[0];
+		priv->pshare->RegE9C=result_final[1];
+	} else {
+		priv->pshare->RegE94=0x100;
+		priv->pshare->RegE9C=0x00;
+	}
+
+	/*
+	 *	Fill IQK result for Path A
+	 */
+	if (result_final[0]) {
+		/*
+		Oldval_0 = (PHY_QueryBBReg(priv, 0xc80, bMaskDWord) >> 22) & 0x3FF;
+		X = result_final[0];
+		if ((X & 0x00000200) != 0)
+			X = X | 0xFFFFFC00;
+		TX0_A = (X * Oldval_0) >> 8;
+		PHY_SetBBReg(priv, 0xc80, 0x3FF, TX0_A);
+		PHY_SetBBReg(priv, 0xc4c, BIT(24), ((X* Oldval_0>>7) & 0x1));
+
+		Y = result_final[1];
+		if ((Y & 0x00000200) != 0)
+			Y = Y | 0xFFFFFC00;
+		TX0_C = (Y * Oldval_0) >> 8;
+		PHY_SetBBReg(priv, 0xc94, 0xF0000000, ((TX0_C&0x3C0)>>6));
+		PHY_SetBBReg(priv, 0xc80, 0x003F0000, (TX0_C&0x3F));
+		PHY_SetBBReg(priv, 0xc4c, BIT(26), ((Y* Oldval_0>>7) & 0x1));
+		*/
+
+		// IQK-R03 2011/02/16 update
+		X = result_final[0];
+		Y = result_final[1];
+		//printk("X=%x Y=%x\n",X,Y);
+		//Path-A OFDM_A
+		PHY_SetBBReg(priv, 0xe30, 0x03FF0000, X);
+		PHY_SetBBReg(priv, 0xc4c, BIT(24), 0);
+		//Path-A OFDM_C
+		PHY_SetBBReg(priv, 0xe30, 0x000003FF, Y);
+		PHY_SetBBReg(priv, 0xc4c, BIT(26), 0);
+
+
+		if(result_final[2]) {
+			reg = result_final[2];
+			PHY_SetBBReg(priv, 0xc14, 0x3FF, reg);
+
+			reg = result_final[3] & 0x3F;
+			PHY_SetBBReg(priv, 0xc14, 0xFC00, reg);
+
+			reg = (result_final[3] >> 6) & 0xF;
+			PHY_SetBBReg(priv, 0xca0, 0xF0000000, reg);
+			
+			PHY_SetBBReg(priv, 0xe34, 0x03FF0000, result_final[2]); // X
+			PHY_SetBBReg(priv, 0xe34, 0x3FF, result_final[3]);  //Y		
+		}
+	}
+
+	/*
+	 *	Path-A PA off
+	 */
+	PHY_SetBBReg(priv, 0x870, bMaskDWord, temp_870);
+	PHY_SetBBReg(priv, 0x860, bMaskDWord, temp_860);
+
+	/*
+	 *	Exit IQK mode
+	 */
+	PHY_SetBBReg(priv, 0xe28, bMaskDWord, 0);
+	PHY_SetBBReg(priv, 0xc04, bMaskDWord, temp_c04);
+	PHY_SetBBReg(priv, 0xc08, bMaskDWord, temp_c08);
+	PHY_SetBBReg(priv, 0x874, bMaskDWord, temp_874);
+	PHY_SetBBReg(priv, 0x800, bMaskDWord, temp_800);
+	PHY_SetBBReg(priv, 0x88c, bMaskDWord, temp_88c);
+	PHY_SetBBReg(priv, 0xb30, bMaskDWord, temp_b30);	// 03/03/2011 update
+	//PHY_SetBBReg(priv, 0x840, bMaskDWord, 0x00032fff);	// 01/11/2011 update
+
+	//PHY0 IQ path to DP block
+	PHY_SetBBReg(priv, 0xb00, bMaskDWord, 0x010170b8);
+
+	PHY_SetBBReg(priv, 0xc50, bMaskDWord, 0x50);
+	PHY_SetBBReg(priv, 0xc50, bMaskDWord, temp_c50);
+
+	/*
+	 *	Reload MAC default value
+	 */
+	RTL_W8(0x550, temp_550);
+	RTL_W8(0x551, temp_551);
+	RTL_W8(0x522, temp_522);
+
+	/*
+	 *	Switch back to SI if needed, after IQK
+	 */
+	if (switch2PI) {
+		PHY_SetBBReg(priv, 0x820, bMaskDWord, 0x01000000);
+		PHY_SetBBReg(priv, 0x828, bMaskDWord, 0x01000000);
+	}
+
+	/*
+	 *	Reload ADDA power saving parameters
+	 */
+	for(i = 0 ; i < IQK_ADDA_REG_NUM ; i++)
+		PHY_SetBBReg(priv, ADDA_REG[i], bMaskDWord, ADDA_backup[i]);
+}
+
+#if 0 //def CLIENT_MODE
+
+void clnt_92D_2T_AGSwitch(struct rtl8192cd_priv * priv, int target)
+{
+	unsigned int flags, i;
+	int rtStatus = 0;
+	unsigned char temp_0522, temp_0550, temp_0551, temp_0800;
+	unsigned char reg;
+
+	SAVE_INT_AND_CLI(flags);
+
+	/*
+	 * Save MAC default value
+	 */
+	temp_0522 = RTL_R8(0x522);
+	temp_0550 = RTL_R8(0x550);
+	temp_0551 = RTL_R8(0x551);
+
+	/*
+	 *	MAC register setting
+	 */
+	RTL_W8(0x522, 0x3f);
+	RTL_W8(0x550, temp_0550& (~BIT(3)));
+	RTL_W8(0x551, temp_0551& (~BIT(3)));
+
+	// stop BB
+	PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0x00f00000, 0xf);
+	temp_0800 = PHY_QueryBBReg(priv, rFPGA0_RFMOD, 0x0f000000);
+	PHY_SetBBReg(priv, rFPGA0_RFMOD, 0x0f000000, 0);
+
+	// 5G_PAPE Select & external PA power on
+	PHY_SetBBReg(priv, 0x878, BIT(0), 0);
+	PHY_SetBBReg(priv, 0x878, BIT(16), 0);
+	PHY_SetBBReg(priv, 0x878, BIT(15), 0);
+	PHY_SetBBReg(priv, 0x878, BIT(31), 0);
+	// RSSI Table Select
+	PHY_SetBBReg(priv, 0xc78, BIT(7)|BIT(6), 0);
+	// fc_area
+	PHY_SetBBReg(priv, 0xd2c, BIT(14)|BIT(13), 0);
+	// cck_enable
+	PHY_SetBBReg(priv, rFPGA0_RFMOD, bCCKEn, 0x1);
+	// LDO_DIV
+	PHY_SetRFReg(priv, RF92CD_PATH_A, 0x28, BIT(7)|BIT(6), 0);
+	PHY_SetRFReg(priv, RF92CD_PATH_B, 0x28, BIT(7)|BIT(6), 0);
+	// MOD_AG // Set channel number
+	PHY_SetRFReg(priv, RF92CD_PATH_A, 0x18, BIT(16), 0);
+	PHY_SetRFReg(priv, RF92CD_PATH_A, 0x18, BIT(8), 0);
+	PHY_SetRFReg(priv, RF92CD_PATH_B, 0x18, BIT(16), 0);
+	PHY_SetRFReg(priv, RF92CD_PATH_B, 0x18, BIT(8), 0);
+ 	// CLOAD for path_A
+	PHY_SetRFReg(priv, RF92CD_PATH_A, 0xB, BIT(16)|BIT(15)|BIT(14), 0x7);
+	PHY_SetRFReg(priv, RF92CD_PATH_B, 0xB, BIT(16)|BIT(15)|BIT(14), 0x7);
+
+	// IMR
+	PHY_SetRFReg(priv, RF92CD_PATH_A, 0x00, bMask20Bits, 0x70000);
+	for (i=0;i<11;i++) {
+		PHY_SetRFReg(priv, RF92CD_PATH_A, (0x2f+i), bMask20Bits, IMR_SET_N[0][i]);
+	}
+	PHY_SetRFReg(priv, RF92CD_PATH_A, 0x00, bMask20Bits, 0x32fff);
+
+	// Enable BB
+	PHY_SetBBReg(priv, rFPGA0_RFMOD, 0x0f000000, temp_0800);
+	// IQK
+	PHY_SetBBReg(priv, 0xc80, bMaskDWord, 0x40000100);
+	PHY_SetBBReg(priv, 0xc94, bMaskByte3, 0);
+	PHY_SetBBReg(priv, 0xc4c, bMaskByte3, 0);
+	PHY_SetBBReg(priv, 0xc88, bMaskDWord, 0x40000100);
+	PHY_SetBBReg(priv, 0xc9c, bMaskByte3, 0);
+	PHY_SetBBReg(priv, 0xc14, bMaskDWord, 0x40000100);
+	PHY_SetBBReg(priv, 0xca0, bMaskByte3, 0);
+	PHY_SetBBReg(priv, 0xc1c, bMaskDWord, 0x40000100);
+	PHY_SetBBReg(priv, 0xc78, bMaskByte1, 0);
+	PHY_SetRFReg(priv, RF92CD_PATH_A, 0x08, bMask20Bits, 0x84000);
+	PHY_SetRFReg(priv, RF92CD_PATH_B, 0x08, bMask20Bits, 0x84000);
+
+	//Set related registers for BW config
+
+	PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0x00f00000, 0x0);
+
+	/*
+	 *	Reload MAC default value
+	 */
+	RTL_W8(0x550, temp_0550);
+	RTL_W8(0x551, temp_0551);
+	RTL_W8(0x522, temp_0522);
+
+	RESTORE_INT(flags);
+}
+
+#endif
+
+
+
+#ifdef SMART_CONCURRENT_92D
+/*
+ *	mode - 	0: 2x2A0->1x1A0G1 (w. IQK)
+ *			1: 2x2G1->1x1A0G1 (w/o IQK)
+ */
+int smcc_92D_enable1x1_5G(struct rtl8192cd_priv * priv, int mode)
+{
+	unsigned int flags, i;
+	//int rtStatus = 0;
+	unsigned char temp_0522, temp_0550, temp_0551, temp_0800;
+	unsigned char temp_1522, temp_1550, temp_1551;
+	struct rtl8192cd_priv * priv0=(struct rtl8192cd_priv *)if_priv[0];
+	unsigned char reg;
+	reg = MAC_PHY_CTRL_MP;
+
+	SAVE_INT_AND_CLI(flags);
+
+	printk("%s\n",__FUNCTION__);
+	priv0->pmib->dot11RFEntry.macPhyMode = DUALMAC_DUALPHY;
+	if (mode==1){
+		priv->pmib->dot11RFEntry.macPhyMode = DUALMAC_DUALPHY;
+	}
+	priv0->pmib->dot11RFEntry.phyBandSelect = PHY_BAND_5G;
+	priv0->pshare->phw->MIMO_TR_hw_support = MIMO_1T1R;
+
+	/*
+	 * Save MAC default value
+	 */
+	temp_0522 = DMDP_RTL_R8(0, 0x522);
+	temp_0550 = DMDP_RTL_R8(0, 0x550);
+	temp_0551 = DMDP_RTL_R8(0, 0x551);
+	if (mode==1){
+		temp_1522 = DMDP_RTL_R8(1, 0x522);
+		temp_1550 = DMDP_RTL_R8(1, 0x550);
+		temp_1551 = DMDP_RTL_R8(1, 0x551);
+	}
+
+	/*
+	 *	MAC register setting
+	 */
+	DMDP_RTL_W8(0, 0x522, 0x3f);
+	DMDP_RTL_W8(0, 0x550, temp_0550& (~BIT(3)));
+	DMDP_RTL_W8(0, 0x551, temp_0551& (~BIT(3)));
+	if (mode==1){
+		DMDP_RTL_W8(1, 0x522, 0x3f);
+		DMDP_RTL_W8(1, 0x550, temp_1550& (~BIT(3)));
+		DMDP_RTL_W8(1, 0x551, temp_1551& (~BIT(3)));
+	}
+
+	// Set Dual-PHY mode
+	DMDP_RTL_W8(0, reg, RTL_R8(reg) | BIT(1));
+
+	// stop BB
+	DMDP_PHY_SetBBReg(0, rFPGA0_AnalogParameter4, 0x00f00000, 0xf);
+	if (mode==1){
+		DMDP_PHY_SetBBReg(1, rFPGA0_AnalogParameter4, 0x00f00000, 0xf);
+		//temp_0800 = DMDP_PHY_QueryBBReg(0, rFPGA0_RFMOD, 0x0f000000);
+		//DMDP_PHY_SetBBReg(0, rFPGA0_RFMOD, 0x0f000000, 0);
+	}
+
+	// Set as 1R
+	DMDP_PHY_SetBBReg(0, 0xc04, bMaskByte0, 0x11);
+	DMDP_PHY_SetBBReg(0, 0xd04, 0xf, 0x1);
+	// Set ad/da clock 1
+	DMDP_PHY_SetBBReg(0, 0x888, BIT(13)|BIT(12), 3);
+	// Set RF as 1T1R mode
+	if (mode==0){
+		DMDP_PHY_SetBBReg(0, 0xc80, bMaskDWord, 0x20000080);
+		DMDP_PHY_SetBBReg(0, 0xc94, 0xf0000000, 0);
+		DMDP_PHY_SetBBReg(0, 0xc4c, bMaskByte3, 0);
+		DMDP_PHY_SetBBReg(0, 0xc14, bMaskDWord, 0x40000100);
+		DMDP_PHY_SetBBReg(0, 0xca0, 0xf0000000, 0);
+		DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x08, bMask20Bits, 0x84000);
+		// IQK
+#ifdef DFS
+        if (!((priv->pshare->rf_ft_var.dfsdelayiqk) &&
+                (OPMODE & WIFI_AP_STATE) &&
+                !priv->pmib->dot11DFSEntry.disable_DFS &&
+                (timer_pending(&priv->ch_avail_chk_timer) ||
+                 priv->pmib->dot11DFSEntry.disable_tx)))
+#endif
+
+		IQK_92D_5G_phy0_n(priv);
+
+	}else{
+		// 5G_PAPE Select & extenal PA power on
+		DMDP_PHY_SetBBReg(0, 0x878, BIT(0), 1);
+		DMDP_PHY_SetBBReg(0, 0x878, BIT(15), 1);
+		DMDP_PHY_SetBBReg(0, 0x878, BIT(16), 1);
+
+		// RSSI Table Select
+		DMDP_PHY_SetBBReg(0, 0xc78, BIT(7)|BIT(6), 1);
+		// fc_area
+		DMDP_PHY_SetBBReg(0, 0xd2c, BIT(14)|BIT(13), (priv0->MAC_info->bb_reg[17]>>13)&0x03);
+		// cck_enable
+		DMDP_PHY_SetBBReg(1, rFPGA0_RFMOD, bCCKEn, 1);
+		DMDP_PHY_SetBBReg(0, rFPGA0_RFMOD, bCCKEn, 0);
+		// 5G LNA_On
+		DMDP_PHY_SetBBReg(0, 0xb30, 0x00f00000, 0);
+		// LDO_DIV
+		DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x28, BIT(7)|BIT(6), 1);
+		// MOD_AG // Set channel number
+		DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x18, bMask20Bits, priv0->MAC_info->rfA_reg[1]);
+	 	// CLOAD for path_A
+		DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0xB, bMask20Bits, priv0->MAC_info->rfA_reg[0]);
+
+		// IMR
+		DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x00, bMask20Bits, 0x70000);
+		for (i=0;i<11;i++) {
+			DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, (0x2f+i), bMask20Bits, priv0->MAC_info->imr[i]);
+		}
+		DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x00, bMask20Bits, priv0->MAC_info->imr[i]);
+		// Enable BB
+		//DMDP_PHY_SetBBReg(0, rFPGA0_RFMOD, 0x0f000000, temp_0800);
+
+		// IQC Setting
+		DMDP_PHY_SetBBReg(0, 0xc80, bMaskDWord, priv0->MAC_info->diqc_c80_b31b0);
+		DMDP_PHY_SetBBReg(0, 0xc94, bMaskByte3, priv0->MAC_info->diqc_c94_b31b24);
+		DMDP_PHY_SetBBReg(0, 0xc4c, 0xf0000000, priv0->MAC_info->diqc_c4c_b31b28);
+		DMDP_PHY_SetBBReg(0, 0xc14, bMaskDWord, priv0->MAC_info->diqc_c14_b31b0);
+		DMDP_PHY_SetBBReg(0, 0xca0, bMaskByte3, priv0->MAC_info->diqc_ca0_b31b24);
+		DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x08, bMask20Bits, priv0->MAC_info->loft_0A);
+		//Set related registers for BW config
+		DMDP_PHY_SetBBReg(0, 0x800, BIT(0), priv0->MAC_info->bb_reg[0]& BIT(0));
+		DMDP_PHY_SetBBReg(0, 0x900, BIT(0), priv0->MAC_info->bb_reg[6]& BIT(0));
+		DMDP_PHY_SetBBReg(0, 0xa00, BIT(4), (priv0->MAC_info->bb_reg[7]& BIT(4))>>4);
+		DMDP_PHY_SetBBReg(0, 0xd00, BIT(11)|BIT(10), (priv0->MAC_info->bb_reg[15]&(BIT(11)|BIT(10)))>>10);
+		DMDP_PHY_SetBBReg(0, 0x818, BIT(27)|BIT(26), (priv0->MAC_info->bb_reg[1]&(BIT(27)|BIT(26)))>>26);
+		DMDP_PHY_SetBBReg(0, 0x884, BIT(11) | BIT(10), (priv0->MAC_info->bb_reg[3]&(BIT(11) | BIT(10)))>>10);
+	}
+
+
+	if (mode==1){
+		priv0->pmib->dot11RFEntry.macPhyMode = DUALMAC_SINGLEPHY;
+		priv0->pshare->phw->MIMO_TR_hw_support = MIMO_2T2R;
+		priv->pmib->dot11RFEntry.macPhyMode = DUALMAC_SINGLEPHY;
+		priv->pshare->phw->MIMO_TR_hw_support = MIMO_2T2R;
+	}
+
+	DMDP_PHY_SetBBReg(0, rFPGA0_AnalogParameter4, 0x00f00000, 0x0);
+	if (mode==1){
+		DMDP_PHY_SetBBReg(1, rFPGA0_AnalogParameter4, 0x00f00000, 0x0);
+	}
+
+	/*
+	 *	Reload MAC default value
+	 */
+	DMDP_RTL_W8(0, 0x550, temp_0550);
+	DMDP_RTL_W8(0, 0x551, temp_0551);
+	DMDP_RTL_W8(0, 0x522, temp_0522);
+	if (mode==1){
+		DMDP_RTL_W8(1, 0x550, temp_1550);
+		DMDP_RTL_W8(1, 0x551, temp_1551);
+		DMDP_RTL_W8(1, 0x522, temp_1522);
+	}
+
+	RESTORE_INT(flags);
+	return 0;
+}
+
+
+int smcc_92D_enable2x2_2G(struct rtl8192cd_priv * priv)
+{
+	unsigned int flags, i;
+	int rtStatus = 0;
+	unsigned char temp_0522, temp_0550, temp_0551, temp_0800;
+	unsigned char temp_1522, temp_1550, temp_1551, temp_1800;
+	unsigned char reg;
+	struct rtl8192cd_priv * priv0=(struct rtl8192cd_priv *)if_priv[0];
+	reg = MAC_PHY_CTRL_MP;
+
+	SAVE_INT_AND_CLI(flags);
+
+	printk("%s\n",__FUNCTION__);
+	priv0->pmib->dot11RFEntry.macPhyMode = DUALMAC_SINGLEPHY;
+	priv->pmib->dot11RFEntry.macPhyMode = DUALMAC_SINGLEPHY;
+	priv0->pmib->dot11RFEntry.phyBandSelect = PHY_BAND_2G;
+
+	/*
+	 * Save MAC default value
+	 */
+	temp_0522 = DMDP_RTL_R8(0, 0x522);
+	temp_0550 = DMDP_RTL_R8(0, 0x550);
+	temp_0551 = DMDP_RTL_R8(0, 0x551);
+	temp_1522 = DMDP_RTL_R8(1, 0x522);
+	temp_1550 = DMDP_RTL_R8(1, 0x550);
+	temp_1551 = DMDP_RTL_R8(1, 0x551);
+
+	/*
+	 *	MAC register setting
+	 */
+	DMDP_RTL_W8(0, 0x522, 0x3f);
+	DMDP_RTL_W8(0, 0x550, temp_0550& (~BIT(3)));
+	DMDP_RTL_W8(0, 0x551, temp_0551& (~BIT(3)));
+	DMDP_RTL_W8(1, 0x522, 0x3f);
+	DMDP_RTL_W8(1, 0x550, temp_1550& (~BIT(3)));
+	DMDP_RTL_W8(1, 0x551, temp_1551& (~BIT(3)));
+
+	// stop BB
+	DMDP_PHY_SetBBReg(0, rFPGA0_AnalogParameter4, 0x00f00000, 0xf);
+	DMDP_PHY_SetBBReg(1, rFPGA0_AnalogParameter4, 0x00f00000, 0xf);
+	//temp_0800 = DMDP_PHY_QueryBBReg(0, rFPGA0_RFMOD, 0x0f000000);
+	//DMDP_PHY_SetBBReg(0, rFPGA0_RFMOD, 0x0f000000, 0);
+	//temp_1800 = DMDP_PHY_QueryBBReg(1, rFPGA0_RFMOD, 0x0f000000);
+	//DMDP_PHY_SetBBReg(1, rFPGA0_RFMOD, 0x0f000000, 0);
+
+	// Set Single-PHY mode
+	DMDP_RTL_W8(0, reg, RTL_R8(reg) & (~BIT(1)));
+	// Set as 2R
+	DMDP_PHY_SetBBReg(0, 0xc04, bMaskByte0, 0x33);
+	DMDP_PHY_SetBBReg(0, 0xd04, 0xf, 0x3);
+	// Set ad/da clock 1
+	DMDP_PHY_SetBBReg(0, 0x888, BIT(13)|BIT(12), 0);
+	// 5G_PAPE Select & external PA power on
+	DMDP_PHY_SetBBReg(0, 0x878, BIT(0), 0);
+	DMDP_PHY_SetBBReg(0, 0x878, BIT(15), 0);
+	DMDP_PHY_SetBBReg(0, 0x878, BIT(16), 0);
+	DMDP_PHY_SetBBReg(0, 0x878, BIT(31), 0);
+	// RSSI Table Select
+	DMDP_PHY_SetBBReg(0, 0xc78, BIT(7)|BIT(6), 0);
+	// fc_area
+	DMDP_PHY_SetBBReg(0, 0xd2c, BIT(14)|BIT(13), 0);
+	// cck_enable
+	DMDP_PHY_SetBBReg(1, rFPGA0_RFMOD, bCCKEn, 0);
+	DMDP_PHY_SetBBReg(0, rFPGA0_RFMOD, bCCKEn, 1);
+	// 5G LNA_On
+	DMDP_PHY_SetBBReg(0, 0xb30, 0x00f00000, 0xa);
+	// LDO_DIV
+	DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x28, BIT(7)|BIT(6), 0);
+	// MOD_AG // Set channel number
+	DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x18, bMask20Bits, priv->MAC_info->rfA_reg[1]);
+ 	// CLOAD for path_A
+	DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0xB, BIT(16)|BIT(15)|BIT(14), 0x7);
+
+	// IMR
+	DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x00, bMask20Bits, 0x70000);
+	for (i=0;i<11;i++) {
+		DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, (0x2f+i), bMask20Bits, priv->MAC_info->imr[i]);
+	}
+	DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x00, bMask20Bits, priv->MAC_info->imr[i]);
+
+	// Enable BB
+	//DMDP_PHY_SetBBReg(0, rFPGA0_RFMOD, 0x0f000000, temp_0800);
+	//DMDP_PHY_SetBBReg(1, rFPGA0_RFMOD, 0x0f000000, temp_1800);
+	// IQK
+	DMDP_PHY_SetBBReg(0, 0xc80, bMaskDWord, 0x40000100);
+	DMDP_PHY_SetBBReg(0, 0xc94, bMaskByte3, 0);
+	DMDP_PHY_SetBBReg(0, 0xc4c, bMaskByte3, 0);
+	DMDP_PHY_SetBBReg(0, 0xc88, bMaskDWord, 0x40000100);
+	DMDP_PHY_SetBBReg(0, 0xc9c, bMaskByte3, 0);
+	DMDP_PHY_SetBBReg(0, 0xc14, bMaskDWord, 0x40000100);
+	DMDP_PHY_SetBBReg(0, 0xca0, bMaskByte3, 0);
+	DMDP_PHY_SetBBReg(0, 0xc1c, bMaskDWord, 0x40000100);
+	DMDP_PHY_SetBBReg(0, 0xc78, bMaskByte1, 0);
+	DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x08, bMask20Bits, 0x84000);
+	IQK_92D_2G(priv0);
+	//Set related registers for BW config
+	DMDP_PHY_SetBBReg(0, 0x800, BIT(0), priv->MAC_info->bb_reg[0]& BIT(0));
+	DMDP_PHY_SetBBReg(0, 0x900, BIT(0), priv->MAC_info->bb_reg[6]& BIT(0));
+	DMDP_PHY_SetBBReg(0, 0xa00, BIT(4), (priv->MAC_info->bb_reg[7]& BIT(4))>>4);
+	DMDP_PHY_SetBBReg(0, 0xd00, BIT(11)|BIT(10), (priv->MAC_info->bb_reg[15]&(BIT(11)|BIT(10)))>>10);
+	DMDP_PHY_SetBBReg(0, 0x818, BIT(27)|BIT(26), (priv->MAC_info->bb_reg[1]&(BIT(27)|BIT(26)))>>26);
+	DMDP_PHY_SetBBReg(0, 0x884, BIT(11) | BIT(10), (priv->MAC_info->bb_reg[3]&(BIT(11) | BIT(10)))>>10);
+
+	DMDP_PHY_SetBBReg(0, rFPGA0_AnalogParameter4, 0x00f00000, 0x0);
+	DMDP_PHY_SetBBReg(1, rFPGA0_AnalogParameter4, 0x00f00000, 0x0);
+
+	/*
+	 *	Reload MAC default value
+	 */
+	DMDP_RTL_W8(0, 0x550, temp_0550);
+	DMDP_RTL_W8(0, 0x551, temp_0551);
+	DMDP_RTL_W8(0, 0x522, temp_0522);
+	DMDP_RTL_W8(1, 0x550, temp_1550);
+	DMDP_RTL_W8(1, 0x551, temp_1551);
+	DMDP_RTL_W8(1, 0x522, temp_1522);
+
+	RESTORE_INT(flags);
+	return 0;
+}
+
+#if 0
+int smcc_92D_enable2x2_5G(struct rtl8192cd_priv * priv)
+{
+	unsigned int flags, val=0;
+	//int rtStatus = 0;
+	unsigned char temp_522, temp_550, temp_551;
+	unsigned char reg;
+	reg = MAC_PHY_CTRL_MP;
+
+	SAVE_INT_AND_CLI(flags);
+	priv->pmib->dot11RFEntry.macPhyMode = DUALMAC_SINGLEPHY;
+	priv->pshare->phw->MIMO_TR_hw_support = MIMO_2T2R;
+
+	/*
+	 * Save MAC default value
+	 */
+	temp_522 = RTL_R8(0x522);
+	temp_550 = RTL_R8(0x550);
+	temp_551 = RTL_R8(0x551);
+
+	/*
+	 *	MAC register setting
+	 */
+	RTL_W8(0x522, 0x3f);
+	RTL_W8(0x550, RTL_R8(0x550)& (~BIT(3)));
+	RTL_W8(0x551, RTL_R8(0x551)& (~BIT(3)));
+
+	// stop BB
+	PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0x00f00000, 0xf);
+
+	// Set Single-PHY mode
+	RTL_W8(reg, RTL_R8(reg) & (~BIT(1)));
+	// Set as 2R
+	PHY_SetBBReg(priv, 0xc04, bMaskByte0, 0x33);
+	PHY_SetBBReg(priv, 0xd04, 0xf, 0x3);
+	// Set ad/da clock 1
+	PHY_SetBBReg(priv, 0x888, BIT(13)|BIT(12), 0);
+	// Set RF as 2T2R mode
+	PHY_SetRFReg(priv, RF92CD_PATH_A, 0x38, BIT(12), 1);
+	// Reload AGC table
+	/*
+	rtStatus = PHY_ConfigBBWithParaFile(priv, AGCTAB);
+	if (rtStatus) {
+		printk("phy_BB8192CD_Config_ParaFile(): Write BB AGC Table Fail!!\n");
+		RESTORE_INT(flags);
+		return -1;
+	}
+	*/
+	// 5G_PAPE Select & external PA power on
+	PHY_SetBBReg(priv, 0x878, BIT(15), 1);
+	PHY_SetBBReg(priv, 0x878, BIT(31), 1);
+	// 1.5V_LDO
+	RTL_W32(0x14, ((RTL_R32(0x14)&0xff0fffff)|0x00d00000));
+	// LDO_DIV
+	PHY_SetRFReg(priv, RF92CD_PATH_B, 0x28, BIT(7)|BIT(6), 1);
+	// A/G mode LO buffer
+	PHY_SetRFReg(priv, RF92CD_PATH_B, 0x38, BIT(16)|BIT(15)|BIT(14), 3);
+	// MOD_AG
+	// Set channel number
+	val = PHY_QueryRFReg(priv, RF92CD_PATH_A, 0x18, bMask20Bits, 1);
+	PHY_SetRFReg(priv, RF92CD_PATH_B, 0x18, bMask20Bits, val);
+	// IMR parameter for path_A/B
+	SetIMR(priv, priv->pmib->dot11RFEntry.dot11channel);
+	PHY_SetBBReg(priv, 0xc80, bMaskDWord, 0x20000080);
+	PHY_SetBBReg(priv, 0xc94, 0xf0000000, 0);
+	PHY_SetBBReg(priv, 0xc4c, bMaskByte3, 0);
+	PHY_SetBBReg(priv, 0xc14, bMaskDWord, 0x40000100);
+	PHY_SetBBReg(priv, 0xca0, 0xf0000000, 0);
+	PHY_SetBBReg(priv, 0xc88, bMaskDWord, 0x20000080);
+	PHY_SetBBReg(priv, 0xc9c, 0xf0000000, 0);
+	PHY_SetBBReg(priv, 0xc1c, bMaskDWord, 0x40000100);
+	PHY_SetBBReg(priv, 0xc78, 0x0000f000, 0);
+	PHY_SetBBReg(priv, 0xc78, BIT(7)|BIT(6), 1);
+	PHY_SetRFReg(priv, RF92CD_PATH_A, 0x08, bMask20Bits, 0x84000);
+	PHY_SetRFReg(priv, RF92CD_PATH_B, 0x08, bMask20Bits, 0x84000);
+
+	// IQK
+	IQK_92D_5G_n(priv);
+	//Set related registers for BW config
+	SwBWMode(priv, priv->pshare->CurrentChannelBW, priv->pshare->offset_2nd_chan);
+
+	// Enable BB
+	PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0x00f00000, 0x0);
+
+	/*
+	 *	Reload MAC default value
+	 */
+	RTL_W8(0x550, temp_550);
+	RTL_W8(0x551, temp_551);
+	RTL_W8(0x522, temp_522);
+
+	RESTORE_INT(flags);
+	return 0;
+}
+
+int smcc_92D_enable2x2_2G(struct rtl8192cd_priv * priv)
+{
+	unsigned int flags;
+	int rtStatus = 0;
+	unsigned char temp_522, temp_550, temp_551;
+	unsigned char reg;
+	reg = MAC_PHY_CTRL_MP;
+
+	SAVE_INT_AND_CLI(flags);
+	priv->pmib->dot11RFEntry.macPhyMode = DUALMAC_SINGLEPHY;
+
+	/*
+	 * Save MAC default value
+	 */
+	temp_522 = RTL_R8(0x522);
+	temp_550 = RTL_R8(0x550);
+	temp_551 = RTL_R8(0x551);
+
+	/*
+	 *	MAC register setting
+	 */
+	RTL_W8(0x522, 0x3f);
+	RTL_W8(0x550, RTL_R8(0x550)& (~BIT(3)));
+	RTL_W8(0x551, RTL_R8(0x551)& (~BIT(3)));
+
+	// stop BB
+	PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0x00f00000, 0xf);
+
+	// Set Single-PHY mode
+	RTL_W8(reg, RTL_R8(reg) & (~BIT(1)));
+	// Set as 2R
+	PHY_SetBBReg(priv, 0xc04, bMaskByte0, 0x33);
+	PHY_SetBBReg(priv, 0xd04, 0xf, 0x3);
+	// Set ad/da clock 1
+	PHY_SetBBReg(priv, 0x888, BIT(13)|BIT(12), 0);
+	// Set RF as 2T2R mode
+	PHY_SetRFReg(priv, RF92CD_PATH_A, 0x38, BIT(12), 1);
+	// Reload AGC table
+	rtStatus = PHY_ConfigBBWithParaFile(priv, AGCTAB);
+	if (rtStatus) {
+		printk("phy_BB8192CD_Config_ParaFile(): Write BB AGC Table Fail!!\n");
+		RESTORE_INT(flags);
+		return -1;
+	}
+	// 5G_PAPE Select & external PA power on
+	PHY_SetBBReg(priv, 0x878, BIT(0), 0);
+	PHY_SetBBReg(priv, 0x878, BIT(15), 0);
+	PHY_SetBBReg(priv, 0x878, BIT(16), 0);
+	PHY_SetBBReg(priv, 0x878, BIT(31), 0);
+	// RSSI Table Select
+	PHY_SetBBReg(priv, 0xc78, BIT(7)|BIT(6), 0);
+	// fc_area
+	PHY_SetBBReg(priv, 0xd2c, BIT(14)|BIT(13), 0);
+	// cck_enable
+	PHY_SetBBReg(priv, rFPGA0_RFMOD, bCCKEn, 0x1);;
+	//AGC trsw threshold
+	PHY_SetBBReg(priv, 0xc70, 0x007F0000, 0x7f);
+	// 1.5V_LDO
+	RTL_W32(0x14, ((RTL_R32(0x14)&0xff0fffff)|0x00700000));
+	// LDO_DIV
+	PHY_SetRFReg(priv, RF92CD_PATH_B, 0x28, BIT(7)|BIT(6), 1);
+	// A/G mode LO buffer
+	PHY_SetRFReg(priv, RF92CD_PATH_B, 0x38, BIT(16)|BIT(15)|BIT(14), 4);
+	// MOD_AG
+	// Set channel number
+	SwBWMode(priv, priv->pshare->CurrentChannelBW, priv->pshare->offset_2nd_chan);
+	SwChnl(priv, priv->pmib->dot11RFEntry.dot11channel, priv->pshare->offset_2nd_chan);
+	// IQK
+	IQK_92D_2G(priv);
+	//Set related registers for BW config
+
+
+	// Enable BB
+	PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0x00f00000, 0x0);
+
+	/*
+	 *	Reload MAC default value
+	 */
+	RTL_W8(0x550, temp_550);
+	RTL_W8(0x551, temp_551);
+	RTL_W8(0x522, temp_522);
+
+	RESTORE_INT(flags);
+	return 0;
+}
+
+int smcc_92D_enable1x1_2G(struct rtl8192cd_priv * priv)
+{
+	struct rtl8192cd_priv *priv_phy0 = (struct rtl8192cd_priv *)if_priv[0];
+	unsigned int flags;
+	int rtStatus = 0;
+	unsigned char temp_522, temp_550, temp_551;
+	int i;
+	unsigned char reg;
+	reg = MAC_PHY_CTRL_MP;
+
+	SAVE_INT_AND_CLI(flags);
+	printk("%s %d %x\n",__FUNCTION__, __LINE__, PHY_QueryRFReg(priv, RF92CD_PATH_A, 0x18, bMask20Bits,1));
+	priv->pmib->dot11RFEntry.macPhyMode = DUALMAC_DUALPHY;
+	priv->pshare->phw->MIMO_TR_hw_support = MIMO_1T1R;
+
+	/*
+	 * Save MAC default value
+	 */
+	temp_522 = RTL_R8(0x522);
+	temp_550 = RTL_R8(0x550);
+	temp_551 = RTL_R8(0x551);
+
+	/*
+	 *	MAC register setting
+	 */
+	RTL_W8(0x522, 0x3f);
+	RTL_W8(0x550, RTL_R8(0x550)& (~BIT(3)));
+	RTL_W8(0x551, RTL_R8(0x551)& (~BIT(3)));
+
+	// stop BB
+	PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0x00f00000, 0xf);
+
+	// Set Dual-PHY mode
+	RTL_W8(reg, RTL_R8(reg) | BIT(1));
+	// Set as 1R
+	DMDP_PHY_SetBBReg(0, 0xc04, bMaskByte0, 0x11);
+	DMDP_PHY_SetBBReg(0, 0xd04, 0xf, 0x1);
+	// Set ad/da clock 1
+	DMDP_PHY_SetBBReg(0, 0x888, BIT(13)|BIT(12), 3);
+	// Set RF as 2T2R mode
+	DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x38, BIT(12), 0);
+	// Reload AGC table
+	rtStatus = PHY_ConfigBBWithParaFile(priv_phy0, AGCTAB);
+	if (rtStatus) {
+		printk("phy_BB8192CD_Config_ParaFile(): Write BB AGC Table Fail!!\n");
+		RESTORE_INT(flags);
+		return -1;
+	}
+	// 5G_PAPE Select & extenal PA power on
+	DMDP_PHY_SetBBReg(0, 0x878, BIT(0), 1);
+	DMDP_PHY_SetBBReg(0, 0x878, BIT(15), 1);
+	// RSSI Table Select
+	DMDP_PHY_SetBBReg(0, 0xc78, BIT(7)|BIT(6), 1);
+	// fc_area
+	DMDP_PHY_SetBBReg(0, 0xd2c, BIT(14)|BIT(13), 1);
+	// cck_enable
+	DMDP_PHY_SetBBReg(0, rFPGA0_RFMOD, bCCKEn, 0);
+	// AGC trsw threshold
+	DMDP_PHY_SetBBReg(0, 0xc70, 0x007F0000, 0x4e);
+	// 1.5V_LDO
+	DMDP_RTL_W32(0, 0x14, (DMDP_RTL_R32(0, 0x14)&0xff0fffff)|0x00d00000);
+	// LDO_DIV
+	DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x28, BIT(7)|BIT(6), 1);
+	PHY_SetRFReg(priv, RF92CD_PATH_A, 0x28, BIT(7)|BIT(6), 0);
+	// A/G mode LO buffer
+	DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x38, BIT(16)|BIT(15)|BIT(14), 3);
+	PHY_SetRFReg(priv, RF92CD_PATH_A, 0x38, BIT(16)|BIT(15)|BIT(14), 4);
+	// PHY0 MOD_AG //Set channel number
+	DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, rRfChannel, bMask20Bits, priv_phy0->MAC_info->rfA_reg[0]);
+	// PHY1 MOD_AG //Set channel number
+	// PHY_SetRFReg(priv, RF92CD_PATH_A, rRfChannel, bMask20Bits, priv->MAC_info->rfA_reg[0]);
+	// PHY0 IMR Path A
+	DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x00, bMask20Bits, 0x72c15);
+	for (i=0; i<10; i++) {
+		if (i==8){
+			DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, (0x30+i), bMask12Bits, priv_phy0->MAC_info->imr_rfA[i]);
+		} else if (i==9) {
+			DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, (0x30+i), bMask20Bits, priv_phy0->MAC_info->imr_rfA[i]);
+		} else {
+			DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, (0x2f+i), bMask20Bits, priv_phy0->MAC_info->imr_rfA[i]);
+		}
+	}
+	DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x00, bMask20Bits, 0x32c15);
+	// PHY1 IMR Path A
+	//PHY_SetRFReg(priv, RF92CD_PATH_A, 0x00, bMask20Bits, 0x72c15);
+	//for (i=0; i<10; i++) {
+	//	PHY_SetRFReg(priv, RF92CD_PATH_A, (0x2f+i), bMask20Bits, priv->MAC_info->imr_rfA[i]);
+	//}
+	//PHY_SetRFReg(priv, RF92CD_PATH_A, 0x00, bMask20Bits, 0x32c15);
+	// PHY0 IQC
+	DMDP_PHY_SetBBReg(0, 0xc80, bMaskDWord, priv_phy0->MAC_info->diqc_c80_b31b0);
+	DMDP_PHY_SetBBReg(0, 0xc94, 0xf0000000, priv_phy0->MAC_info->diqc_c94_b31b24);
+	DMDP_PHY_SetBBReg(0, 0xc4c, bMaskByte3, priv_phy0->MAC_info->diqc_c4c_b31b28);
+	DMDP_PHY_SetBBReg(0, 0xc14, bMaskDWord, priv_phy0->MAC_info->diqc_c14_b31b0);
+	DMDP_PHY_SetBBReg(0, 0xca0, 0xf0000000, priv_phy0->MAC_info->diqc_ca0_b31b24);
+	DMDP_PHY_SetRFReg(0, RF92CD_PATH_A, 0x08, bMask20Bits, priv_phy0->MAC_info->loft_0A);
+	//  PHY0 BB Enable
+	DMDP_PHY_SetBBReg(0, rFPGA0_AnalogParameter4, 0x00f00000, 0x0);
+	/*
+	 *	Reload PHY0 MAC default value
+	 */
+	DMDP_RTL_W8(0, 0x550, temp_550);
+	DMDP_RTL_W8(0, 0x551, temp_551);
+	DMDP_RTL_W8(0, 0x522, temp_522);
+
+	// PHY1 IQK
+	PHY_SetBBReg(priv, 0xc80, bMaskDWord, 0x40000100);
+	PHY_SetBBReg(priv, 0xc94, 0xf0000000, 0);
+	PHY_SetBBReg(priv, 0xc4c, bMaskByte3, 0);
+	PHY_SetBBReg(priv, 0xc14, bMaskDWord, 0x40000100);
+	PHY_SetBBReg(priv, 0xca0, 0xf0000000, 0);
+	PHY_SetRFReg(priv, RF92CD_PATH_A, 0x08, bMask20Bits, 0x84000);
+
+	IQK_92D_2G_phy1(priv);
+
+	PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0x00f00000, 0x0);
+
+	/*
+	 *	Reload MAC default value
+	 */
+	RTL_W8(0x550, temp_550);
+	RTL_W8(0x551, temp_551);
+	RTL_W8(0x522, temp_522);
+
+	printk("%s %d %x\n",__FUNCTION__, __LINE__, PHY_QueryRFReg(priv, RF92CD_PATH_A, 0x18, bMask20Bits,1));
+
+	RESTORE_INT(flags);
+	return 0;
+}
+
+#endif
+
+void smcc_92D_fill_MAC_info(struct rtl8192cd_priv * priv, struct SMCC_MAC_Info_Tbl *info_tbl)
+{
+	int i, val, imr_idx = 0;
+
+	unsigned int BB_IDX[18] = {0x800, 0x818, 0x878, 0x884, 0x888, 0x88C, 0x900, 0xA00, 0xC04,
+								0xC4C, 0xC70, 0xC78, 0xC94, 0xC9C, 0xCA0, 0xD00, 0xD04, 0xD2C};
+	unsigned int RF_IDX[3] = {0x0B, 0x18, 0x28};
+
+	info_tbl->channel = PHY_QueryRFReg(priv, RF92CD_PATH_A, 0x18, bMaskByte0, 1);;
+	info_tbl->bandwidth = priv->pshare->CurrentChannelBW;
+	if (priv->pshare->CurrentChannelBW == HT_CHANNEL_WIDTH_20_40) {
+		if (priv->pshare->offset_2nd_chan == 1)
+			info_tbl->bandwidth |= BIT(2); // control upper, 2nd below
+		else
+			info_tbl->bandwidth |= BIT(1); // control lower, 2nd upper
+	}
+	if (priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY) {
+		// Single PHY IQC 		Byte 2~22
+		info_tbl->siqc_c80_b31b0 = DMDP_PHY_QueryBBReg(0, 0xc80, bMaskDWord);
+		info_tbl->siqc_c94_b31b24 = DMDP_PHY_QueryBBReg(0, 0xc94, bMaskByte3);
+		info_tbl->siqc_c4c_b31b24 = DMDP_PHY_QueryBBReg(0, 0xc4c, bMaskByte3);
+		info_tbl->siqc_c88_b31b0 = DMDP_PHY_QueryBBReg(0, 0xc88, bMaskDWord);
+		info_tbl->siqc_c9c_b31b24 = DMDP_PHY_QueryBBReg(0, 0xc9c, bMaskByte3);
+		info_tbl->siqc_c14_b31b0 = DMDP_PHY_QueryBBReg(0, 0xc14, bMaskDWord);
+		info_tbl->siqc_ca0_b31b24 = DMDP_PHY_QueryBBReg(0, 0xca0, bMaskByte3);
+		info_tbl->siqc_c1c_b31b0 = DMDP_PHY_QueryBBReg(0, 0xc1c, bMaskDWord);
+		info_tbl->siqc_c78_b15b8 = DMDP_PHY_QueryBBReg(0, 0xc78, bMaskByte1);
+	}else{
+		// Dual PHY IQC		Byte 23~33
+		info_tbl->diqc_c80_b31b0 = PHY_QueryBBReg(priv, 0xc80, bMaskDWord);
+		info_tbl->diqc_c94_b31b24 = PHY_QueryBBReg(priv, 0xc94, bMaskByte3);
+		info_tbl->diqc_c4c_b31b28 = PHY_QueryBBReg(priv, 0xc4c, 0xf0000000);
+		info_tbl->diqc_c14_b31b0 = PHY_QueryBBReg(priv, 0xc14, bMaskDWord);
+		info_tbl->diqc_ca0_b31b24 = PHY_QueryBBReg(priv, 0xca0, bMaskByte3);
+	}
+
+	if (priv->pmib->dot11RFEntry.macPhyMode != DUALMAC_DUALPHY) {
+		// 0_B LOFT			Byte 115
+		info_tbl->loft_0B = DMDP_PHY_QueryRFReg(0, RF92CD_PATH_B, 0x08, bMask20Bits, 1);
+		// RF_reg			Byte 206~217
+		for (i = 0; i<3; i++)
+			info_tbl->rfB_reg[i] = DMDP_PHY_QueryRFReg(0, RF92CD_PATH_B, RF_IDX[i], bMask20Bits, 1);
+		//
+	}	else {
+		val = info_tbl->channel;
+		if (priv->pmib->dot11RFEntry.phyBandSelect==PHY_BAND_2G)
+			imr_idx = 0;
+		else {
+			if (val>=36 && val <=64)
+				imr_idx = 1;
+			else
+				imr_idx = 2;
+		}
+		// IMR				Byte 34~73
+		for (i = 0; i<11; i++)
+			info_tbl->imr[i] = IMR_SET_N[imr_idx][i];
+		if (imr_idx==0)
+			info_tbl->imr[11] = 0x32fff;
+		else
+			info_tbl->imr[11] = 0x32c9a;
+
+		// 0_A LOFT			Byte 114
+		info_tbl->loft_0A = PHY_QueryRFReg(priv, RF92CD_PATH_A, 0x08, bMask20Bits, 1);
+		// BB_reg			Byte 122~193
+		for (i = 0; i<18; i++)
+			info_tbl->bb_reg[i] = PHY_QueryBBReg(priv, BB_IDX[i], bMaskDWord);
+		// RF_reg			Byte 194~205
+		for (i = 0; i<3; i++)
+			info_tbl->rfA_reg[i] = PHY_QueryRFReg(priv, RF92CD_PATH_A, RF_IDX[i], bMask20Bits, 1);
+	}
+}
+
+void smcc_dump_MAC_info(struct rtl8192cd_priv * priv, struct SMCC_MAC_Info_Tbl *info_tbl)
+{
+	int i, flags;
+
+	unsigned int BB_IDX[18] = {0x800, 0x818, 0x878, 0x884, 0x888, 0x88C, 0x900, 0xA00, 0xC04,
+								0xC4C, 0xC70, 0xC78, 0xC94, 0xC9C, 0xCA0, 0xD00, 0xD04, 0xD2C};
+	unsigned int RF_IDX[3] = {0x0B, 0x18, 0x28};
+
+	SAVE_INT_AND_CLI(flags);
+
+	printk("info_tbl->channel = %d \n", info_tbl->channel);
+	printk("info_tbl->bandwidth = %x \n", info_tbl->bandwidth);
+	printk("info_tbl->siqc_c80_b31b0 = %x \n", info_tbl->siqc_c80_b31b0);
+	printk("info_tbl->siqc_c94_b31b24 = %x \n", info_tbl->siqc_c94_b31b24);
+	printk("info_tbl->siqc_c4c_b31b24 = %x \n", info_tbl->siqc_c4c_b31b24);
+	printk("info_tbl->siqc_c88_b31b0 = %x \n", info_tbl->siqc_c88_b31b0);
+	printk("info_tbl->siqc_c9c_b31b24 = %x \n", info_tbl->siqc_c9c_b31b24);
+	printk("info_tbl->siqc_c14_b31b0 = %x \n", info_tbl->siqc_c14_b31b0);
+	printk("info_tbl->siqc_ca0_b31b24 = %x \n", info_tbl->siqc_ca0_b31b24);
+	printk("info_tbl->siqc_c1c_b31b0 = %x \n", info_tbl->siqc_c1c_b31b0);
+	printk("info_tbl->siqc_c78_b15b8 = %x \n", info_tbl->siqc_c78_b15b8);
+	printk("info_tbl->diqc_c80_b31b0 = %x \n", info_tbl->diqc_c80_b31b0);
+	printk("info_tbl->diqc_c94_b31b24 = %x \n", info_tbl->diqc_c94_b31b24);
+	printk("info_tbl->diqc_c4c_b31b28 = %x \n", info_tbl->diqc_c4c_b31b28);
+	printk("info_tbl->diqc_c14_b31b0 = %x \n", info_tbl->diqc_c14_b31b0);
+	printk("info_tbl->diqc_ca0_b31b24 = %x \n", info_tbl->diqc_ca0_b31b24);
+
+	for (i = 0; i<12; i++)
+		printk("info_tbl->imr[%d] = %x \n", i, info_tbl->imr[i]);
+
+	printk("info_tbl->loft_0A = %x \n", info_tbl->loft_0A);
+	printk("info_tbl->loft_0B = %x \n", info_tbl->loft_0B);
+
+	for (i = 0; i<18; i++)
+		printk("info_tbl->bb_reg[%d](0x%2x) = %x \n", i, BB_IDX[i], info_tbl->bb_reg[i]);
+	for (i = 0; i<3; i++)
+		printk("info_tbl->rfA_reg[%d](0x%2x) = %x \n", i, RF_IDX[i], info_tbl->rfA_reg[i]);
+	for (i = 0; i<3; i++)
+		printk("info_tbl->rfB_reg[%d](0x%2x) = %x \n", i, RF_IDX[i], info_tbl->rfB_reg[i]);
+
+
+	RESTORE_INT(flags);
+}
+
+void smcc_signin_MAC_info(struct rtl8192cd_priv * priv, struct SMCC_MAC_Info_Tbl *info_tbl)
+{
+	unsigned long flags;
+	unsigned int content = 0, info_idx;
+	int count = 10;
+
+	SAVE_INT_AND_CLI(flags);
+
+	RTL_W8(0x422, RTL_R8(0x422)&(~BIT(6)));
+	RTL_W8(0x662, RTL_R8(0x662)&(~BIT(0)));
+
+	signin_beacon_desc(priv, (unsigned int *)info_tbl, sizeof(struct SMCC_MAC_Info_Tbl));
+
+	/*
+	 * BCN_HEAD
+	 */
+	content |= (RTL_R16(TDECTRL)>>8)<<16;
+
+	/*
+	 * Info_idx: Test chip = 0; MP chip = 1
+	 */
+ 	info_idx = 0;
+	content |= info_idx << 8;
+
+	/*
+	 * set cmd id
+	 */
+	content |= H2C_CMD_INFO_PKT;
+
+	signin_h2c_cmd(priv, content, 0);
+
+	while (count > 0){
+		if (RTL_R8(0x662) & BIT(0)) {
+			RTL_W8(0x422, RTL_R8(0x422)|BIT(6));
+			printk("SMCC signin MAC info success!\n");
+			break;
+		}
+		count--;
+		delay_ms(5);
+	}
+
+	if (count <= 0)
+		printk("SMCC signin MAC info FAIL!\n");
+
+	#if 0
+		/*
+		 *	MAC register setting
+		 */
+		RTL_W8(0x522, 0x3f);
+		RTL_W8(0x550, RTL_R8(0x550)& (~BIT(3)));
+		RTL_W8(0x551, RTL_R8(0x551)& (~BIT(3)));
+
+		// stop BB
+		PHY_SetBBReg(priv, rFPGA0_AnalogParameter4, 0x00f00000, 0xf);
+	#endif
+
+	RESTORE_INT(flags);
+}
+
+/*
+ En : 1 for enable, 0 for disable
+ DMDP_Duration : valid while Mode = 1. The unit is 4ms.
+ MODE : 00b for static mode , 01b for preserve mode, 10b and 11b are reserved
+ PSV : valid while mode = 1. set 1 for RF resource preservation request
+ AP / STA : 0 for AP, 1 for STA
+ LINK_STATE : valid while Mode = 0.  0 for no any link, 1 for link exist
+ */
+void smcc_signin_linkstate(struct rtl8192cd_priv * priv, unsigned char enable, unsigned char duration, unsigned char link_state)
+{
+	unsigned long flags;
+	unsigned int content = 0;
+
+	printk(">>>> [wlan-%d] %s en=%d, du=%d, st=%d.\n", priv->pshare->wlandev_idx, __FUNCTION__, enable, duration, link_state);
+
+	SAVE_INT_AND_CLI(flags);
+
+	// Link State
+	content |= (link_state & BIT(0))<< 21;
+
+	// Enable
+	content |= (enable & BIT(0)) << 16;
+
+	// DMDP_Duration
+	content |= duration << 8;
+	// set cmd id
+	content |= H2C_CMD_SMCC;
+
+	signin_h2c_cmd(priv, content, 0);
+
+	RESTORE_INT(flags);
+}
+
+#endif // SMART_CONCURRENT_92D
+#endif //CONFIG_RTL_92D_DMDP
+
+#endif // CONFIG_RTL_92D_SUPPORT
+
+
+
diff --git a/drivers/net/wireless/rtl8192cd/Kconfig b/drivers/net/wireless/rtl8192cd/Kconfig
index d1cf757..0b01607 100644
--- a/drivers/net/wireless/rtl8192cd/Kconfig
+++ b/drivers/net/wireless/rtl8192cd/Kconfig
@@ -6,9 +6,14 @@ config RTL8192CD
 
 config RTL_92C_SUPPORT
         bool "Realtek 8192C wireless support "
-        depends on RTL8192CD && !RTL_92D_SUPPORT 
+        depends on RTL8192CD && !RTL_92D_SUPPORT && !RTL_88E_SUPPORT
         default y
 
+config RTL_88E_SUPPORT
+        bool "Realtek 8188E wireless support"
+        depends on RTL8192CD
+        default n
+
 config RTL_HOSTAPD_SUPPORT
 	bool "Realtek hostapd support"
 	depends on RTL8192CD && RTL_92C_SUPPORT
@@ -16,33 +21,33 @@ config RTL_HOSTAPD_SUPPORT
 
 config HIGH_POWER_EXT_PA
 	bool "Enable external high power PA"
-	depends on RTL8192CD
+	depends on RTL8192CD && !RTL_88E_SUPPORT
 	default n
 
 config HIGH_POWER_EXT_LNA
 	bool "Enable external LNA"
-	depends on RTL8192CD && RTL_92C_SUPPORT && !RTL_DUAL_PCIESLOT_BIWLAN_D
+	depends on RTL8192CD && RTL_92C_SUPPORT
 	default n
 
 config 	ANT_SWITCH
 	bool "Enable Antenna Diversity"
-	depends on RTL8192CD && RTL_92C_SUPPORT && !RTL_DUAL_PCIESLOT_BIWLAN_D
+	depends on RTL8192CD && !RTL_88E_SUPPORT
 	default n
 
 config RTL_DUAL_PCIESLOT_BIWLAN
 	bool "Enable both of the 2 pcie slot for bi-8192C support"
-	depends on RTL8192CD && RTL_8198 && !RTL_92D_SUPPORT
+	depends on RTL8192CD && RTL_8198 && !RTL_92D_SUPPORT && !RTL_88E_SUPPORT
 	default n
 
 config RTL_92D_SUPPORT
 	bool "Realtek 8192D wireless support " 
-	depends on RTL8192CD
+	depends on RTL8192CD && !RTL_88E_SUPPORT
 	default n
 
 config PCIE_POWER_SAVING
-        bool "Enable PCIE power saving support"
-        depends on RTL8192CD && !RTL_DUAL_PCIESLOT_BIWLAN_D
-        default y
+	bool "Enable PCIE power saving support"
+	depends on RTL8192CD && !RTL_88E_SUPPORT
+	default y if CONFIG_RTL8196C
 
 config RTL_92D_DMDP
 	bool "RTL8192D dual-MAC-dual-PHY mode"
@@ -58,9 +63,15 @@ config RTL_DFS_SUPPORT
 	bool "DFS Support"
         depends on RTL8192CD && RTL_92D_SUPPORT
         default n
-	
+
+config RTL_TX_EARLY_MODE_SUPPORT
+	bool "Tx Early Mode Support"
+        depends on RTL8192CD && RTL_92D_SUPPORT
+        default n
+
 config RTL_DUAL_PCIESLOT_BIWLAN_D
          bool "Support Dual card:92C+92D"
+         depends on RTL8192CD && !RTL_88E_SUPPORT
          select RTL_92C_SUPPORT
          select RTL_92D_SUPPORT
          default n
@@ -96,11 +107,11 @@ config RTL_WDS_SUPPORT
         default y
 config ENABLE_EFUSE
 	bool "Efuse Support"
-	depends on RTL8192CD
+	depends on RTL8192CD && !RTL_88E_SUPPORT
 	default n
 config RTL_WAPI_SUPPORT
 	bool "WAPI Support"
-	depends on RTL8192CD
+	depends on RTL8192CD && !RTL_88E_SUPPORT
 	default n
 config  RTL_WAPI_LOCAL_AS_SUPPORT
         bool "support local AS"
@@ -118,7 +129,15 @@ config RTL_COMAPI_WLTOOLS
 config WIRELESS_LAN_MODULE
 	bool
 	default y if RTL8192CD=m
+config MP_PSD_SUPPORT
+        bool "MP quick PSD support"
+        depends on RTL8192CD && !RTL_88E_SUPPORT
+        default n
 
+config RTL_P2P_SUPPORT
+	bool "Realtek P2P support " 
+	depends on RTL8192CD && !RTL_88E_SUPPORT
+	default n
 config RTL_WPS2_SUPPORT
 	bool "Realtek wps2.0 support " 
 	default y
@@ -131,3 +150,14 @@ config TXPWR_LMT
 	bool "Band Edge Limit support"
 	depends on RTL8192CD && RTL_92D_SUPPORT
 	default n
+
+config RTL_MESH_SUPPORT
+	bool "RTL Mesh Support"
+	depends on RTL8192CD && !RTL_88E_SUPPORT
+	default n
+
+config RTL_WLAN_DOS_FILTER
+	bool "Enable WLAN DoS Filter"
+	depends on RTL8192CD && !RTL_88E_SUPPORT
+	default n
+
diff --git a/drivers/net/wireless/rtl8192cd/Makefile b/drivers/net/wireless/rtl8192cd/Makefile
index 0cd61c7..33ef469 100644
--- a/drivers/net/wireless/rtl8192cd/Makefile
+++ b/drivers/net/wireless/rtl8192cd/Makefile
@@ -10,20 +10,48 @@ ifeq ($(CONFIG_RTL_92D_SUPPORT),y)
   endif
   RTL_WLAN_DATA_DIR_D := data_92d
 else
+  ifeq ($(CONFIG_RTL_92C_SUPPORT),y)
   RTL_WLAN_DATA_DIR := data
+  endif
 #  RTL_WLAN_DATA_DIR_D := data_92d
 endif
+ifeq ($(CONFIG_RTL_88E_SUPPORT),y)
+  RTL_WLAN_DATA_DIR_E := data_88e
+endif
+
+ifeq ($(CONFIG_RTL_MESH_SUPPORT),y)
+        EXTRA_CFLAGS += -DCONFIG_RTK_MESH #-DMESH_USE_METRICOP
+#        ifeq ($(CONFIG_11S_TEST_MODE),y)
+#        EXTRA_CFLAGS += -D_11s_TEST_MODE_
+#        endif
+        obj-mesh = ../mesh_ext/mesh_proc.o\
+        ../mesh_ext/mesh_route.o\
+        ../mesh_ext/mesh_rx.o\
+        ../mesh_ext/mesh_sme.o\
+        ../mesh_ext/mesh_security.o\
+        ../mesh_ext/mesh_tx.o\
+        ../mesh_ext/mesh_util.o\
+        ../mesh_ext/mesh_11kv.o\
+        ../mesh_ext/hash_table.o
+endif
 
 SRCS_TXT = $(addprefix $(src)/data_,$(notdir $(patsubst %.txt,%.c,$(wildcard $(src)/$(RTL_WLAN_DATA_DIR)/*.txt))))
 SRCS_BIN = $(addprefix $(src)/data_,$(notdir $(patsubst %.bin,%.c,$(wildcard $(src)/$(RTL_WLAN_DATA_DIR)/*.bin))))
 SRCS_TXT += $(addprefix $(src)/data_,$(notdir $(patsubst %.txt,%.c,$(wildcard $(src)/$(RTL_WLAN_DATA_DIR_D)/*.txt))))
 SRCS_BIN += $(addprefix $(src)/data_,$(notdir $(patsubst %.bin,%.c,$(wildcard $(src)/$(RTL_WLAN_DATA_DIR_D)/*.bin))))
-
+SRCS_TXT += $(addprefix $(src)/data_,$(notdir $(patsubst %.txt,%.c,$(wildcard $(src)/$(RTL_WLAN_DATA_DIR_E)/*.txt))))
+SRCS_BIN += $(addprefix $(src)/data_,$(notdir $(patsubst %.bin,%.c,$(wildcard $(src)/$(RTL_WLAN_DATA_DIR_E)/*.bin))))
 
 
 obj-$(CONFIG_RTL_WAPI_SUPPORT) += wapi_wai.o wapiCrypto.o
 obj-$(CONFIG_RTL8192CD) += rtl8192cd.o
 
+ifeq ($(CONFIG_RTL_88E_SUPPORT),y)
+rtl8192cd-objs += HalPwrSeqCmd.o\
+	Hal8188EPwrSeq.o\
+	RateAdaptive.o\
+	8188e_hw.o
+endif
 rtl8192cd-objs +=\
 	8192cd_tx.o\
 	8192cd_rx.o\
@@ -47,10 +75,16 @@ rtl8192cd-objs +=\
 	1x_rc4.o\
 	8192cd_mib.o\
 	8192cd_dmem.o\
-	romeperf.o
+	romeperf.o\
+	Hal8192CDMOutSrc.o\
+	$(obj-mesh)
+	
 ifeq ($(CONFIG_RTL_COMAPI_CFGFILE),y)
 obj-y += 8192cd_comapi.o
 endif
+ifeq ($(CONFIG_RTL_P2P_SUPPORT),y)	
+obj-y += 8192cd_p2p.o
+endif
 ifeq ($(CONFIG_RTL_COMAPI_WLTOOLS),y)
 obj-y += 8192cd_comapi.o
 endif
@@ -60,11 +94,19 @@ obj-y += 8192cd_comapi.o
 obj-y += 8192cd_net80211.o
 obj-y += 8192cd_psk_hapd.o
 endif
+ifeq ($(CONFIG_RTL8672),y)
+obj-y += rtl8672_port.o
+endif
+
+ifeq ($(CONFIG_RTL8672),y)
+EXTRA_CFLAGS += -DCONFIG_RTL8196B -DCONFIG_RTL8196C -DCONFIG_RTL8196B_GW -DCONFIG_RTL8196C_TESTCHIP_PATCH -D_MP_TELNET_SUPPORT_
+EXTRA_CFLAGS += -DCONFIG_COMPAT_NET_DEV_OPS
+endif
 
 #CONFIG_SINUX_SUPPORT=1
 ifeq ($(CONFIG_SINUX_SUPPORT),1)
 EXTRA_CFLAGS  += -DOPENSSL_FIPS -D__linux__ -DRSDK_BUILT -DOPENSSL_NO_SPEED -DOPENSSL_THREADS -D_REENTRANT \
-                        -DDSO_DLFCN -DHAVE_DLFCN_H -DOPENSSL_NO_KRB5 -DB_ENDIAN -DTERMIO -DSUPPORT_SNMP_MIB \
+                        -DDSO_DLFCN -DHAVE_DLFCN_H -DOPENSSL_NO_KRB5 -DB_ENDIAN -DTERMIO \
 			-fomit-frame-pointer 
 # -save-temps                      
                         
@@ -102,3 +144,8 @@ $(obj)/data_%.c: $(src)/$(RTL_WLAN_DATA_DIR_D)/%.txt FORCE
 	$(obj)/bin2c.pl $(notdir $(basename $@)) < $< > $@
 $(obj)/data_%.c: $(src)/$(RTL_WLAN_DATA_DIR_D)/%.bin FORCE
 	$(obj)/bin2c.pl $(notdir $(basename $@)) < $< > $@
+$(obj)/data_%.c: $(src)/$(RTL_WLAN_DATA_DIR_E)/%.txt FORCE
+	$(obj)/bin2c.pl $(notdir $(basename $@)) < $< > $@
+$(obj)/data_%.c: $(src)/$(RTL_WLAN_DATA_DIR_E)/%.bin FORCE
+	$(obj)/bin2c.pl $(notdir $(basename $@)) < $< > $@
+
diff --git a/drivers/net/wireless/rtl8192cd/data/MACPHY_REG_92C.txt b/drivers/net/wireless/rtl8192cd/data/MACPHY_REG_92C.txt
index 927e8af..6381fea 100644
--- a/drivers/net/wireless/rtl8192cd/data/MACPHY_REG_92C.txt
+++ b/drivers/net/wireless/rtl8192cd/data/MACPHY_REG_92C.txt
@@ -1,111 +1,111 @@
-//version 09 modify:
-//1. set port 2 MACID and BSSID initial value
-//2. set NAV upper limit
-//3. disable TX ACQ over beacon time
-
-//TX and RX packet buffer init, this is done before MAC TRX register init, the following 
-//  register setting is done in Power on flow
-
-//0x200	0x29		//RQPN
-//0x201	0x29
-//0x202	0xA3
-//0x203	0x80
-//0x10C 0x71		// for normal chip setting
-//0x10D	0xF7		//HPQ_SEL mapping for Normal chip
-//0x114	0xF6		//TXRKTBUG_PG_BNDY
-//0x209	0xF6		//Beacon Head Page
-//0x115	0x00
-//0x116	0xFF
-//0x117	0x27
-//0x424	0xF6		//BCNQ_PGBNDY
-//0x45D	0xF6		//WMAC_LBK_BF_HD
-//0x60F 0x04		//enable PHY status RCR[28] = 1, 0x60F = 0x04
-
-//EDCA and WMAC related
-0x420	0x80		//0x420[7] = 1 BK_AMPDU_RTY_NEW
-0x423	0x00
-0x430	0x00		//DARFRC, AS 92S
-0x431	0x00
-0x432	0x00
-0x433	0x01
-0x434	0x04		//DARFRC, AS 92S
-0x435	0x05
-0x436	0x06
-0x437	0x07
-0x438	0x00		//RARFRC, AS 92S
-0x439	0x00
-0x43A	0x00
-0x43B	0x01
-0x43C	0x04		//RARFRC, AS 92S
-0x43D	0x05
-0x43E	0x06
-0x43F	0x07
-0x440	0x5F		//RRSR
-0x441	0x01
-0x442	0x00
-0x444	0x15		//
-0x445	0xF0
-0x446	0x0F
-0x447	0x00
-0x458	0x41		//AGG_LMT
-0x459	0xa8		//a8
-0x45A	0x72		//82
-0x45B	0xb9		//b9
-0x460	0x66
-0x461	0x66
-0x462	0x08
-0x463	0x03
-0x4C8	0xff		//PROT_MODE_CTRL	need tuning
-0x4C9	0x08
-0x4CC	0xff		//Disable BAR retry 		need tuning
-0x4CD	0xff
-0x4CE	0x01
-0x500	0x26		//VO EDCA
-0x501	0xA2
-0x502	0x2f
-0x503	0x00
-0x504	0x28		//VI EDCA
-0x505	0xA3
-0x506	0x5E
-0x507	0x00
-0x508	0x2B		//BE
-0x509	0xA4
-0x50A	0x5E
-0x50B	0x00
-0x50c	0x4f		//BK EDCA
-0x50D	0xA4
-0x50E	0x00
-0x50F	0x00
-0x512	0x1C		//PIFS
-0x514	0x0a
-0x515	0x10
-0x516	0x0a
-0x517	0x10
-0x51A	0x16		//AGGR_BK_TIME
-0x524	0x0F
-0x525	0x4F		//disable CFE
-0x546   0x20            // NAC_PROT_LEN
-0x547	0x00
-0x550	0x10		// disable auto sync, and initially disable all beacon function, disable beacon update
-0x551	0x10
-0x559	0x02		//BCNDMATIM
-0x55A	0x02		//ATIMWND
-0x55D	0xFF		//disable BCN MAX threshold
-0x605	0x30		// enable TX deadlock
-0x608	0x0E		//RCR
-0x609	0x2A		//RCR+1
-0x652	0xC8		// enable NAV update upper bound
-0x63C	0x08
-0x63D	0x08
-0x63E	0x0E
-0x63F	0x0E
-0x66E	0x05		// RX BAR IOT issue for Atheros NIC, where atheros BAR has bug
-0x700	0x21
-0x701	0x43
-0x702	0x65
-0x703	0x87
-0x708	0x21
-0x709	0x43
-0x70a	0x65
-0x70b	0x87
-
+//version 09 modify:
+//1. set port 2 MACID and BSSID initial value
+//2. set NAV upper limit
+//3. disable TX ACQ over beacon time
+
+//TX and RX packet buffer init, this is done before MAC TRX register init, the following 
+//  register setting is done in Power on flow
+
+//0x200	0x29		//RQPN
+//0x201	0x29
+//0x202	0xA3
+//0x203	0x80
+//0x10C 0x71		// for normal chip setting
+//0x10D	0xF7		//HPQ_SEL mapping for Normal chip
+//0x114	0xF6		//TXRKTBUG_PG_BNDY
+//0x209	0xF6		//Beacon Head Page
+//0x115	0x00
+//0x116	0xFF
+//0x117	0x27
+//0x424	0xF6		//BCNQ_PGBNDY
+//0x45D	0xF6		//WMAC_LBK_BF_HD
+//0x60F 0x04		//enable PHY status RCR[28] = 1, 0x60F = 0x04
+
+//EDCA and WMAC related
+0x420	0x80		//0x420[7] = 1 BK_AMPDU_RTY_NEW
+0x423	0x00
+0x430	0x00		//DARFRC, AS 92S
+0x431	0x00
+0x432	0x00
+0x433	0x01
+0x434	0x04		//DARFRC, AS 92S
+0x435	0x05
+0x436	0x06
+0x437	0x07
+0x438	0x00		//RARFRC, AS 92S
+0x439	0x00
+0x43A	0x00
+0x43B	0x01
+0x43C	0x04		//RARFRC, AS 92S
+0x43D	0x05
+0x43E	0x06
+0x43F	0x07
+0x440	0x5F		//RRSR
+0x441	0x01
+0x442	0x00
+0x444	0x15		//
+0x445	0xF0
+0x446	0x0F
+0x447	0x00
+0x458	0x41		//AGG_LMT
+0x459	0xa8		//a8
+0x45A	0x72		//82
+0x45B	0xb9		//b9
+0x460	0x66
+0x461	0x66
+0x462	0x08
+0x463	0x03
+0x4C8	0xff		//PROT_MODE_CTRL	need tuning
+0x4C9	0x08
+0x4CC	0xff		//Disable BAR retry 		need tuning
+0x4CD	0xff
+0x4CE	0x01
+0x500	0x26		//VO EDCA
+0x501	0xA2
+0x502	0x2f
+0x503	0x00
+0x504	0x28		//VI EDCA
+0x505	0xA3
+0x506	0x5E
+0x507	0x00
+0x508	0x2B		//BE
+0x509	0xA4
+0x50A	0x5E
+0x50B	0x00
+0x50c	0x4f		//BK EDCA
+0x50D	0xA4
+0x50E	0x00
+0x50F	0x00
+0x512	0x1C		//PIFS
+0x514	0x0a
+0x515	0x10
+0x516	0x0a
+0x517	0x10
+0x51A	0x16		//AGGR_BK_TIME
+0x524	0x0F
+0x525	0x4F		//disable CFE
+0x546   0x20            // NAC_PROT_LEN
+0x547	0x00
+0x550	0x10		// disable auto sync, and initially disable all beacon function, disable beacon update
+0x551	0x10
+0x559	0x02		//BCNDMATIM
+0x55A	0x02		//ATIMWND
+0x55D	0xFF		//disable BCN MAX threshold
+0x605	0x30		// enable TX deadlock
+0x608	0x0E		//RCR
+0x609	0x2A		//RCR+1
+0x652	0xC8		// enable NAV update upper bound
+0x63C	0x08
+0x63D	0x08
+0x63E	0x0C
+0x63F	0x0C
+0x66E	0x05		// RX BAR IOT issue for Atheros NIC, where atheros BAR has bug
+0x700	0x21
+0x701	0x43
+0x702	0x65
+0x703	0x87
+0x708	0x21
+0x709	0x43
+0x70a	0x65
+0x70b	0x87
+
diff --git a/drivers/net/wireless/rtl8192cd/data/PHY_REG_1T.txt b/drivers/net/wireless/rtl8192cd/data/PHY_REG_1T.txt
index c07f90c..c012284 100644
--- a/drivers/net/wireless/rtl8192cd/data/PHY_REG_1T.txt
+++ b/drivers/net/wireless/rtl8192cd/data/PHY_REG_1T.txt
@@ -1,244 +1,244 @@
-//091204
-//0x024 0x11800f	//syn CLK enable // tmp 40MHz solution
-//0x028 0xffdb83	//320MHz CLK enable, medium BB clock driving // tmp 40MHz solution
-0x028 0xffff83		//320MHz CLK enable, strong BB clock driving // tmp 40MHz solution
-//=======================
-// PAGE_8 ( FPGA_PHY0 )
-//=======================
-0x800 0x80040000 
-0x804 0x00000001
-0x808 0x0000fc00 
-0x80c 0x0000000A  
-0x810 0x10005388
-0x814 0x020c3d10 
-0x818 0x02200385 // [30:29] is DTR, Set off now. turn off RIFS: 0x00200185, turn on RIFS: 0x00200385
-0x81c 0x00000000 
-0x820 0x01000100 // 0x01000000 (SI), 0x01000100 (PI) 
-0x824 0x00390004 
-0x828 0x00000000
-0x82c 0x00000000 
-0x830 0x00000000
-0x834 0x00000000
-0x838 0x00000000
-0x83c 0x00000000
-0x840 0x00010000  //RF to standby mode
-0x844 0x00000000   
-0x848 0x00000000
-0x84c 0x00000000
-0x850 0x00000000  // RF wakeup, TBD    
-0x854 0x00000000  // RF sleep, TBD
-0x858 0x65a965a9
-0x85c 0x0c1b25a4  // AFE ctrl reg (ASIC)  RX AD3 CCA mode
-0x860 0x0f7f0230  //88CE default left anatenna
-0x864 0x0f7f0130 
-0x868 0x00000000
-0x86c 0x00323232  //Path-A 2M/5.5M/11M TX AGC codeword
-0x870 0x07000700  // z2: 0x03000300, 92C RF: 0x07000700 (2 internal PA), 92S RF: 0x03000700 (one internal PA)
-0x874 0x00004000  // 
-0x878 0x00000808  // RF mode for standby & rx_low_power codeword
-0x87c 0x00000000   // TST mode
-0x880 0xc0083070  // AFE ctrl reg (ASIC) 
-0x884 0x000004d5  // AFE ctrl reg (ASIC) 
-0x888 0x00000000  // AFE ctrl reg (ASIC) 
-0x88c 0xccc00004  // [10:1] is r_rdy_cnt for sleep/standby mode, [27],[31] are MCS_IND
-0x890 0x00000000
-0x894 0xfffffffe 
-0x898 0x40302010 
-0x89c 0x00706050 
-//
-//=======================
-// PAGE_9 ( FPGA_PHY1 )
-//=======================
-0x900 0x00000000
-0x904 0x00000023 
-0x908 0x00000000  
-0x90c 0x81121111 // tx antenna by contorl register
-//
-//=======================
-// PAGE_A ( CCK_PHY0 )
-//=======================
-0xa00 0x00d047c8
-0xa04 0xc1ff000c
-0xa08 0x8c038300 // MP: 0x88838300, driver: 0x8ccd8300
-0xa0c 0x2e62120f
-0xa10 0x95009b78 // 
-0xa14 0x11144028
-0xa18 0x00881117
-0xa1c 0x89140f00
-0xa20 0x1a1b0000 
-0xa24 0x090e1317 
-0xa28 0x00000204
-0xa2c 0x00d30000
-0xa70 0x101fbf80
-0xa74 0x00000007
-//
-//=======================
-// PAGE_B
-//=======================
-0xb00 0x01017018
-0xb04 0xf7ed8f84
-0xb08 0x40372d20
-0xb0c 0x5b554e48
-0xb10 0x6f6a6560
-0xb14 0x807c7873
-0xb18 0x8f8b8884
-0xb1c 0x9d999693
-0xb20 0xa9a6a3a0
-0xb24 0xb5b2afac
-0xb28 0x00810100
-0xb2c 0x00400056
-0xb30 0x002b0032
-0xb34 0x001f0024
-0xb38 0x0019001c
-0xb3c 0x00150017
-0xb40 0x00120013
-0xb44 0x00100011
-0xb48 0x000e000f
-0xb4c 0x000c000d
-0xb50 0x000b000c
-0xb54 0x000a000b
-0xb58 0x0009000a
-0xb5c 0x00090009
-0xb60 0x00080008
-0xb64 0x00080008
-0xb68 0x0fe00000
-//
-//=======================
-// PAGE_C ( OFDM_PHY0 )
-//=======================
-0xc00 0x48071d40 
-0xc04 0x03a05611  
-0xc08 0x000000e4  // [8:4] is about DBG_GPIO selection 
-0xc0c 0x6c6c6c6c 
-0xc10 0x08800000 
-0xc14 0x40000100
-0xc18 0x08800000
-0xc1c 0x40000100
-0xc20 0x00000000  // DTR TH
-0xc24 0x00000000  // DTR TH
-0xc28 0x00000000  // DTR TH
-0xc2c 0x00000000  // DTR TH
-0xc30 0x69e9ac4a  // PWED_TH option2=0x69e9bb44, 0x69e9ab44, 0x69e9ac44
-0xc34 0x469652cf   
-0xc38 0x49795994   
-0xc3c 0x0a979718  
-0xc40 0x1f7c403f  
-0xc44 0x000100b7  
-0xc48 0xec020107 //[1]=1:enable L1_SBD 
-0xc4c 0x007f037f // turn off edcca 
-0xc50 0x6954341e // AAGC=1,0x68043420, AAGC=2,0x69543420 
-0xc54 0x433c0094 
-0xc58 0x6954341e // AAGC=1,0x68043420, AAGC=2,0x69543420   
-0xc5c 0x433c0094
-0xc60 0x00000000 // DTR TH
-0xc64 0x5116848b //L1-SBD  //31168a8b for 6M sen. 0x5116828b, 0x5116848b
-0xc68 0x47c00bff //L1-SBD
-0xc6c 0x00000036 //L1-SBD
-0xc70 0x2c7f000d // disable AGC flow-1 
-0xc74 0x018610db // AGC RSSI setting time = 600nS.//0x0186109b=>RRSI=500ns,BBP=300ns for PI used, 0x0186175b
-0xc78 0x0000001f
-0xc7c 0x00b91612  
-0xc80 0x40000100 
-0xc84 0x20f60000 
-0xc88 0x40000100 
-0xc8c 0xa0e40000 //for MRC weighting function 
-0xc90 0x00000000 // TX Power Training for path-A	
-0xc94 0x00000000 	
-0xc98 0x00000000 // TX Power Training for path-B
-0xc9c 0x00007f7f // turn off pre-cca
-0xca0 0x00000000 
-0xca4 0x00000000 // reserved
-0xca8 0x00000000 // reserved
-0xcac 0x00000000 // reserved
-0xcb0 0x00000000 // reserved
-0xcb4 0x00000000 // reserved
-0xcb8 0x00000000 // reserved
-0xcbc 0x28000000
-0xcc0 0x00000000 // reserved
-0xcc4 0x00000000 // reserved
-0xcc8 0x00000000 // reserved
-0xccc 0x00000000 // reserved
-0xcd0 0x00000000 // reserved
-0xcd4 0x00000000 // reserved
-0xcd8 0x64b22427 // reserved
-0xcdc 0x00766932 // reserved
-0xce0 0x00222222  
-0xce4 0x00000000
-0xce8 0x37644302
-0xcec 0x2f97d40c
-//
-//=======================
-// PAGE_D ( OFDM_PHY1 )
-//=======================
-0xd00 0x00080740 
-0xd04 0x00020401  
-0xd08 0x0000907f  
-0xd0c 0x20010201 
-0xd10 0xa0633333  
-0xd14 0x3333bc43  
-0xd18 0x7a8f5b6b
-0xd2c 0xcc979975  
-0xd30 0x00000000
-0xd34 0x80608000
-0xd38 0x00000000
-0xd3c 0x00027293
-0xd40 0x00000000
-0xd44 0x00000000
-0xd48 0x00000000
-0xd4c 0x00000000
-0xd50 0x6437140a 
-0xd54 0x00000000 
-0xd58 0x00000000
-0xd5c 0x30032064 
-0xd60 0x4653de68
-0xd64 0x04518a3c //[26]=1:enable L1-SBD//
-0xd68 0x00002101
-0xd6c 0x2a201c16  // DTR
-0xd70 0x1812362e  // DTR
-0xd74 0x322c2220  // DTR
-0xd78 0x000e3c24  // DTR
-//=======================
-// PAGE_E
-//=======================
-0xe00 0x2a2a2a2a	// Path-A TX AGC codewod, 6M, 9M, 12M, 18M 
-0xe04 0x2a2a2a2a	// Path-A TX AGC codewod, 24M, 36M, 48M, 54M 
-0xe08 0x03002a2a	// Path-A TX AGC codewod, MCS32, 1M 
-0xe10 0x2a2a2a2a	// Path-A TX AGC codewod, MCS0, MCS1, MCS2, MCS3 
-0xe14 0x2a2a2a2a	// Path-A TX AGC codewod, MCS4, MCS5, MCS6, MCS7 
-0xe18 0x2a2a2a2a	// Path-A TX AGC codewod, MCS8, MCS9, MCS10, MCS11 
-0xe1c 0x2a2a2a2a	// Path-A TX AGC codewod, MCS12, MCS13, MCS14, MCS15 
-0xe28 0x00000000        
-0xe30 0x1000dc1f	// 0xe30~0xe60: IQK
-0xe34 0x10008c1f
-0xe38 0x02140102
-0xe3C 0x681604c2
-0xe40 0x01007c00
-0xe44 0x01004800
-0xe48 0xfb000000
-0xe4c 0x000028d1
-0xe50 0x1000dc1f
-0xe54 0x10008c1f
-0xe58 0x02140102
-0xe5C 0x28160d05
-//0xe60 0x021400a0
-//0xe64 0x281600a0	// Reserved in 92C/88C
-0xe6c 0x631b25a0	// AFE ctrl reg (ASIC)  Blue-Tooth   
-0xe70 0x631b25a0	// AFE ctrl reg (ASIC)  RX_WAIT_CCA 
-0xe74 0x081b25a0	// AFE ctrl reg (ASIC)  TX_CCK_RFON
-0xe78 0x081b25a0	// AFE ctrl reg (ASIC)  TX_CCK_BBON
-0xe7c 0x081b25a0	// AFE ctrl reg (ASIC)  TX_OFDM_RFON
-0xe80 0x081b25a0	// AFE ctrl reg (ASIC)  TX_OFDM_BBON
-0xe84 0x631b25a0	// AFE ctrl reg (ASIC)  TX_TO_RX
-0xe88 0x081b25a0	// AFE ctrl reg (ASIC)  TX_TO_TX 
-0xe8c 0x631b25a0	// AFE ctrl reg (ASIC)  RX_CCK 
-0xed0 0x631b25a0	// AFE ctrl reg (ASIC)  RX_OFDM 
-0xed4 0x631b25a0	// AFE ctrl reg (ASIC)  RX_WAIT_RIFS 
-0xed8 0x631b25a0	// AFE ctrl reg (ASIC)  RX_TO_RX
-0xedc 0x001b25a0	// AFE ctrl reg (ASIC)  Standby 
-0xee0 0x001b25a0	// AFE ctrl reg (ASIC)  Sleep
-0xeec 0x6b1b25a0	// AFE ctrl reg (ASIC)  PMPD_ANAEN 
-//
-0xf14 0x00000003 // debug port selection. 0x0~0x3: PHY DBG, 0x4~0x5: MAC DBG
-0xf4c 0x00000000 // Only for FPGA PMAC
-0xf00 0x00000300 // enable BBRSTB, bcz HSSI use clk_bb
-0xff
+//091204
+//0x024 0x11800f	//syn CLK enable // tmp 40MHz solution
+//0x028 0xffdb83	//320MHz CLK enable, medium BB clock driving // tmp 40MHz solution
+0x028 0xffff83		//320MHz CLK enable, strong BB clock driving // tmp 40MHz solution
+//=======================
+// PAGE_8 ( FPGA_PHY0 )
+//=======================
+0x800 0x80040000 
+0x804 0x00000001
+0x808 0x0000fc00 
+0x80c 0x0000000A  
+0x810 0x10000330
+0x814 0x020c3d10 
+0x818 0x02200385 // [30:29] is DTR, Set off now. turn off RIFS: 0x00200185, turn on RIFS: 0x00200385
+0x81c 0x00000000 
+0x820 0x01000100 // 0x01000000 (SI), 0x01000100 (PI) 
+0x824 0x00390004 
+0x828 0x00000000
+0x82c 0x00000000 
+0x830 0x00000000
+0x834 0x00000000
+0x838 0x00000000
+0x83c 0x00000000
+0x840 0x00010000  //RF to standby mode
+0x844 0x00000000   
+0x848 0x00000000
+0x84c 0x00000000
+0x850 0x00000000  // RF wakeup, TBD    
+0x854 0x00000000  // RF sleep, TBD
+0x858 0x65a965a9
+0x85c 0x0c1b25a4  // AFE ctrl reg (ASIC)  RX AD3 CCA mode
+0x860 0x0f7f0230  //88CE default left anatenna
+0x864 0x0f7f0130 
+0x868 0x00000000
+0x86c 0x00323232  //Path-A 2M/5.5M/11M TX AGC codeword
+0x870 0x07000700  // z2: 0x03000300, 92C RF: 0x07000700 (2 internal PA), 92S RF: 0x03000700 (one internal PA)
+0x874 0x00004000  // 
+0x878 0x00000808  // RF mode for standby & rx_low_power codeword
+0x87c 0x00000000   // TST mode
+0x880 0xc0083070  // AFE ctrl reg (ASIC) 
+0x884 0x000004d5  // AFE ctrl reg (ASIC) 
+0x888 0x00000000  // AFE ctrl reg (ASIC) 
+0x88c 0xccc00004  // [10:1] is r_rdy_cnt for sleep/standby mode, [27],[31] are MCS_IND
+0x890 0x00000000
+0x894 0xfffffffe 
+0x898 0x40302010 
+0x89c 0x00706050 
+//
+//=======================
+// PAGE_9 ( FPGA_PHY1 )
+//=======================
+0x900 0x00000000
+0x904 0x00000023 
+0x908 0x00000000  
+0x90c 0x81121111 // tx antenna by contorl register
+//
+//=======================
+// PAGE_A ( CCK_PHY0 )
+//=======================
+0xa00 0x00d047c8
+0xa04 0xc1ff000c
+0xa08 0x8c038300 // MP: 0x88838300, driver: 0x8ccd8300
+0xa0c 0x2e62120f
+0xa10 0x95009b78 // 
+0xa14 0x11144028
+0xa18 0x00881117
+0xa1c 0x89140f00
+0xa20 0x1a1b0000 
+0xa24 0x090e1317 
+0xa28 0x00000204
+0xa2c 0x00d30000
+0xa70 0x101fbf80
+0xa74 0x00000007
+//
+//=======================
+// PAGE_B
+//=======================
+0xb00 0x01017018
+0xb04 0xf7ed8f84
+0xb08 0x40372d20
+0xb0c 0x5b554e48
+0xb10 0x6f6a6560
+0xb14 0x807c7873
+0xb18 0x8f8b8884
+0xb1c 0x9d999693
+0xb20 0xa9a6a3a0
+0xb24 0xb5b2afac
+0xb28 0x00810100
+0xb2c 0x00400056
+0xb30 0x002b0032
+0xb34 0x001f0024
+0xb38 0x0019001c
+0xb3c 0x00150017
+0xb40 0x00120013
+0xb44 0x00100011
+0xb48 0x000e000f
+0xb4c 0x000c000d
+0xb50 0x000b000c
+0xb54 0x000a000b
+0xb58 0x0009000a
+0xb5c 0x00090009
+0xb60 0x00080008
+0xb64 0x00080008
+0xb68 0x0fe00000
+//
+//=======================
+// PAGE_C ( OFDM_PHY0 )
+//=======================
+0xc00 0x48071d40 
+0xc04 0x03a05611  
+0xc08 0x000000e4  // [8:4] is about DBG_GPIO selection 
+0xc0c 0x6c6c6c6c 
+0xc10 0x08800000 
+0xc14 0x40000100
+0xc18 0x08800000
+0xc1c 0x40000100
+0xc20 0x00000000  // DTR TH
+0xc24 0x00000000  // DTR TH
+0xc28 0x00000000  // DTR TH
+0xc2c 0x00000000  // DTR TH
+0xc30 0x69e9ac4a  // PWED_TH option2=0x69e9bb44, 0x69e9ab44, 0x69e9ac44
+0xc34 0x469652cf   
+0xc38 0x49795994   
+0xc3c 0x0a979718  
+0xc40 0x1f7c403f  
+0xc44 0x000100b7  
+0xc48 0xec020107 //[1]=1:enable L1_SBD 
+0xc4c 0x007f037f // turn off edcca 
+0xc50 0x6954341e // AAGC=1,0x68043420, AAGC=2,0x69543420 
+0xc54 0x433c0094 
+0xc58 0x6954341e // AAGC=1,0x68043420, AAGC=2,0x69543420   
+0xc5c 0x433c0094
+0xc60 0x00000000 // DTR TH
+0xc64 0x5116848b //L1-SBD  //31168a8b for 6M sen. 0x5116828b, 0x5116848b
+0xc68 0x47c00bff //L1-SBD
+0xc6c 0x00000036 //L1-SBD
+0xc70 0x2c7f000d // disable AGC flow-1 
+0xc74 0x018610db // AGC RSSI setting time = 600nS.//0x0186109b=>RRSI=500ns,BBP=300ns for PI used, 0x0186175b
+0xc78 0x0000001f
+0xc7c 0x00b91612  
+0xc80 0x40000100 
+0xc84 0x20f60000 
+0xc88 0x40000100 
+0xc8c 0xa0e40000 // for MRC weighting function 
+0xc90 0x00000000 // TX Power Training for path-A	
+0xc94 0x00000000 	
+0xc98 0x00000000 // TX Power Training for path-B
+0xc9c 0x00007f7f // turn off pre-cca
+0xca0 0x00000000 
+0xca4 0x00000000 // reserved
+0xca8 0x00000000 // reserved
+0xcac 0x00000000 // reserved
+0xcb0 0x00000000 // reserved
+0xcb4 0x00000000 // reserved
+0xcb8 0x00000000 // reserved
+0xcbc 0x28000000
+0xcc0 0x00000000 // reserved
+0xcc4 0x00000000 // reserved
+0xcc8 0x00000000 // reserved
+0xccc 0x00000000 // reserved
+0xcd0 0x00000000 // reserved
+0xcd4 0x00000000 // reserved
+0xcd8 0x64b22427 // reserved
+0xcdc 0x00766932 // reserved
+0xce0 0x00222222  
+0xce4 0x00000000
+0xce8 0x37644302
+0xcec 0x2f97d40c
+//
+//=======================
+// PAGE_D ( OFDM_PHY1 )
+//=======================
+0xd00 0x00080740 
+0xd04 0x00020401  
+0xd08 0x0000907f  
+0xd0c 0x20010201 
+0xd10 0xa0633333  
+0xd14 0x3333bc43  
+0xd18 0x7a8f5b6b
+0xd2c 0xcc979975  
+0xd30 0x00000000
+0xd34 0x80608000
+0xd38 0x00000000
+0xd3c 0x00027293
+0xd40 0x00000000
+0xd44 0x00000000
+0xd48 0x00000000
+0xd4c 0x00000000
+0xd50 0x6437140a 
+0xd54 0x00000000 
+0xd58 0x00000000
+0xd5c 0x30032064 
+0xd60 0x4653de68
+0xd64 0x04518a3c //[26]=1:enable L1-SBD//
+0xd68 0x00002101
+0xd6c 0x2a201c16  // DTR
+0xd70 0x1812362e  // DTR
+0xd74 0x322c2220  // DTR
+0xd78 0x000e3c24  // DTR
+//=======================
+// PAGE_E
+//=======================
+0xe00 0x2a2a2a2a	// Path-A TX AGC codewod, 6M, 9M, 12M, 18M 
+0xe04 0x2a2a2a2a	// Path-A TX AGC codewod, 24M, 36M, 48M, 54M 
+0xe08 0x03002a2a	// Path-A TX AGC codewod, MCS32, 1M 
+0xe10 0x2a2a2a2a	// Path-A TX AGC codewod, MCS0, MCS1, MCS2, MCS3 
+0xe14 0x2a2a2a2a	// Path-A TX AGC codewod, MCS4, MCS5, MCS6, MCS7 
+0xe18 0x2a2a2a2a	// Path-A TX AGC codewod, MCS8, MCS9, MCS10, MCS11 
+0xe1c 0x2a2a2a2a	// Path-A TX AGC codewod, MCS12, MCS13, MCS14, MCS15 
+0xe28 0x00000000        
+0xe30 0x1000dc1f	// 0xe30~0xe60: IQK
+0xe34 0x10008c1f
+0xe38 0x02140102
+0xe3C 0x681604c2
+0xe40 0x01007c00
+0xe44 0x01004800
+0xe48 0xfb000000
+0xe4c 0x000028d1
+0xe50 0x1000dc1f
+0xe54 0x10008c1f
+0xe58 0x02140102
+0xe5C 0x28160d05
+//0xe60 0x021400a0
+//0xe64 0x281600a0	// Reserved in 92C/88C
+0xe6c 0x631b25a0	// AFE ctrl reg (ASIC)  Blue-Tooth   
+0xe70 0x631b25a0	// AFE ctrl reg (ASIC)  RX_WAIT_CCA 
+0xe74 0x081b25a0	// AFE ctrl reg (ASIC)  TX_CCK_RFON
+0xe78 0x081b25a0	// AFE ctrl reg (ASIC)  TX_CCK_BBON
+0xe7c 0x081b25a0	// AFE ctrl reg (ASIC)  TX_OFDM_RFON
+0xe80 0x081b25a0	// AFE ctrl reg (ASIC)  TX_OFDM_BBON
+0xe84 0x631b25a0	// AFE ctrl reg (ASIC)  TX_TO_RX
+0xe88 0x081b25a0	// AFE ctrl reg (ASIC)  TX_TO_TX 
+0xe8c 0x631b25a0	// AFE ctrl reg (ASIC)  RX_CCK 
+0xed0 0x631b25a0	// AFE ctrl reg (ASIC)  RX_OFDM 
+0xed4 0x631b25a0	// AFE ctrl reg (ASIC)  RX_WAIT_RIFS 
+0xed8 0x631b25a0	// AFE ctrl reg (ASIC)  RX_TO_RX
+0xedc 0x001b25a0	// AFE ctrl reg (ASIC)  Standby 
+0xee0 0x001b25a0	// AFE ctrl reg (ASIC)  Sleep
+0xeec 0x6b1b25a0	// AFE ctrl reg (ASIC)  PMPD_ANAEN 
+//
+0xf14 0x00000003 // debug port selection. 0x0~0x3: PHY DBG, 0x4~0x5: MAC DBG
+0xf4c 0x00000000 // Only for FPGA PMAC
+0xf00 0x00000300 // enable BBRSTB, bcz HSSI use clk_bb
+0xff
diff --git a/drivers/net/wireless/rtl8192cd/data/PHY_REG_1T_n.txt b/drivers/net/wireless/rtl8192cd/data/PHY_REG_1T_n.txt
index 38ebe04..fa83cac 100644
--- a/drivers/net/wireless/rtl8192cd/data/PHY_REG_1T_n.txt
+++ b/drivers/net/wireless/rtl8192cd/data/PHY_REG_1T_n.txt
@@ -1,221 +1,221 @@
-//100311
-//0x024 0x11800f	//syn CLK enable // tmp 40MHz solution
-//0x028 0xffdb83	//320MHz CLK enable, medium BB clock driving // tmp 40MHz solution
-0x028 0xffff83		//320MHz CLK enable, strong BB clock driving // tmp 40MHz solution
-
-
-//=======================
-// PAGE_8 ( FPGA_PHY0 )
-//=======================
-0x800 0x80040000 
-0x804 0x00000001
-0x808 0x0000fc00 
-0x80c 0x0000000A  
-0x810 0x10005388
-0x814 0x020c3d10 
-0x818 0x02200385 // [30:29] is DTR, Set off now. turn off RIFS: 0x00200185, turn on RIFS: 0x00200385
-0x81c 0x00000000 
-0x820 0x01000100 // 0x01000000 (SI), 0x01000100 (PI) 
-0x824 0x00390004 
-0x828 0x00000000
-0x82c 0x00000000 
-0x830 0x00000000
-0x834 0x00000000
-0x838 0x00000000
-0x83c 0x00000000
-0x840 0x00010000  //RF to standby mode
-0x844 0x00000000   
-0x848 0x00000000
-0x84c 0x00000000
-0x850 0x00000000  // RF wakeup, TBD    
-0x854 0x00000000  // RF sleep, TBD
-0x858 0x569a569a 
-0x85c 0x001b25a4   // AFE ctrl reg (ASIC)  RX AD3 CCA mode
-0x860 0x66e60230  //88CE default left anatenna
-0x864 0x061f0130 
-0x868 0x00000000
-0x86c 0x32323200  //Path-A 11M/5.5M/2M TX AGC codeword
-0x870 0x07000700  // z2: 0x03000300, 92C RF: 0x07000700 (2 internal PA), 92S RF: 0x03000700 (one internal PA)
-0x874 0x22004000  // 
-0x878 0x00000808  // RF mode for standby & rx_low_power codeword
-0x87c 0x00000000   // TST mode
-0x880 0xc0083070  // AFE ctrl reg (ASIC) 
-0x884 0x000004d5  // AFE ctrl reg (ASIC) 
-0x888 0x00000000  // AFE ctrl reg (ASIC) 
-0x88c 0xccc000c0  // [10:1] is r_rdy_cnt for sleep/standby mode, [27],[31] are MCS_IND
-0x890 0x00000800
-0x894 0xfffffffe 
-0x898 0x40302010 
-0x89c 0x00706050 
-//
-//=======================
-// PAGE_9 ( FPGA_PHY1 )
-//=======================
-0x900 0x00000000
-0x904 0x00000023 
-0x908 0x00000000  
-0x90c 0x81121111 // tx antenna by contorl register
-//
-//=======================
-// PAGE_A ( CCK_PHY0 )
-//=======================
-0xa00 0x00d047c8
-0xa04 0x80ff000c
-0xa08 0x8c838300 // MP: 0x88838300, driver: 0x8ccd8300
-0xa0c 0x2e68120f
-0xa10 0x9500bb78 // 
-0xa14 0x11144028
-0xa18 0x00881117
-0xa1c 0x89140f00
-0xa20 0x1a1b0000 
-0xa24 0x090e1317 
-0xa28 0x00000204
-0xa2c 0x00d30000
-0xa70 0x101fbf00
-0xa74 0x00000007
-//
-//=======================
-// PAGE_B
-//=======================
-//
-//
-//=======================
-// PAGE_C ( OFDM_PHY0 )
-//=======================
-0xc00 0x48071d40 
-0xc04 0x03a05611  
-0xc08 0x000000e4  // [8:4] is about DBG_GPIO selection 
-0xc0c 0x6c6c6c6c 
-0xc10 0x08800000 
-0xc14 0x40000100
-0xc18 0x08800000
-0xc1c 0x40000100
-0xc20 0x00000000  // DTR TH
-0xc24 0x00000000  // DTR TH
-0xc28 0x00000000  // DTR TH
-0xc2c 0x00000000  // DTR TH
-0xc30 0x69e9ac44  // PWED_TH option2=0x69e9bb44, 0x69e9ab44, 0x69e9ac44
-0xc34 0x469652cf   
-0xc38 0x49795994   
-0xc3c 0x0a97971c  
-0xc40 0x1f7c403f  
-0xc44 0x000100b7  
-0xc48 0xec020107 //[1]=1:enable L1_SBD 
-0xc4c 0x007f037f // turn off edcca 
-0xc50 0x69543420 // AAGC=1,0x68043420, AAGC=2,0x69543420 
-0xc54 0x43bc0094 
-0xc58 0x69543420 // AAGC=1,0x68043420, AAGC=2,0x69543420   
-0xc5c 0x433c0094
-0xc60 0x00000000 // DTR TH
-0xc64 0x5116848b //L1-SBD  //31168a8b for 6M sen. 0x5116828b, 0x5116848b
-0xc68 0x47c00bff //L1-SBD
-0xc6c 0x00000036 //L1-SBD
-0xc70 0x2c7f000d // disable AGC flow-1 
-0xc74 0x018610db // AGC RSSI setting time = 600nS.//0x0186109b=>RRSI=500ns,BBP=300ns for PI used, 0x0186175b
-0xc78 0x0000001f
-0xc7c 0x00b91612  
-0xc80 0x40000100 
-0xc84 0x20f60000 
-0xc88 0x40000100 
-0xc8c 0xa0e40000 //for MRC weighting function 
-0xc90 0x00121820 // TX Power Training for path-A	
-0xc94 0x00000000 	
-0xc98 0x00121820// TX Power Training for path-B
-0xc9c 0x00007f7f // turn off pre-cca
-0xca0 0x00000000 
-0xca4 0x00000080 // reserved
-0xca8 0x00000000 // reserved
-0xcac 0x00000000 // reserved
-0xcb0 0x00000000 // reserved
-0xcb4 0x00000000 // reserved
-0xcb8 0x00000000 // reserved
-0xcbc 0x28000000
-0xcc0 0x00000000 // reserved
-0xcc4 0x00000000 // reserved
-0xcc8 0x00000000 // reserved
-0xccc 0x00000000 // reserved
-0xcd0 0x00000000 // reserved
-0xcd4 0x00000000 // reserved
-0xcd8 0x64b22427 // reserved
-0xcdc 0x00766932 // reserved
-0xce0 0x00222222  
-0xce4 0x00000000
-0xce8 0x37644302
-0xcec 0x2f97d40c
-//
-//=======================
-// PAGE_D ( OFDM_PHY1 )
-//=======================
-0xd00 0x00080740 
-0xd04 0x00020401  
-0xd08 0x0000907f  
-0xd0c 0x20010201 
-0xd10 0xa0633333  
-0xd14 0x3333bc43  
-0xd18 0x7a8f5b6b
-0xd2c 0xcc979975  
-0xd30 0x00000000
-0xd34 0x80608000
-0xd38 0x00000000
-0xd3c 0x00027293
-0xd40 0x00000000
-0xd44 0x00000000
-0xd48 0x00000000
-0xd4c 0x00000000
-0xd50 0x6437140a 
-0xd54 0x00000000 
-0xd58 0x00000000
-0xd5c 0x30032064 
-0xd60 0x4653de68
-0xd64 0x04518a3c //[26]=1:enable L1-SBD//
-0xd68 0x00002101
-0xd6c 0x2a201c16  // DTR
-0xd70 0x1812362e  // DTR
-0xd74 0x322c2220  // DTR
-0xd78 0x000e3c24  // DTR
-//=======================
-// PAGE_E
-//=======================
-0xe00 0x2a2a2a2a	// Path-A TX AGC codewod, 6M, 9M, 12M, 18M 
-0xe04 0x2a2a2a2a	// Path-A TX AGC codewod, 24M, 36M, 48M, 54M 
-0xe08 0x03902a2a	// Path-A TX AGC codewod, MCS32, 1M 
-0xe10 0x2a2a2a2a	// Path-A TX AGC codewod, MCS0, MCS1, MCS2, MCS3 
-0xe14 0x2a2a2a2a	// Path-A TX AGC codewod, MCS4, MCS5, MCS6, MCS7 
-0xe18 0x2a2a2a2a	// Path-A TX AGC codewod, MCS8, MCS9, MCS10, MCS11 
-0xe1c 0x2a2a2a2a	// Path-A TX AGC codewod, MCS12, MCS13, MCS14, MCS15 
-0xe28 0x00000000        
-0xe30 0x1000dc1f	// 0xe30~0xe60: IQK
-0xe34 0x10008c1f
-0xe38 0x02140102
-0xe3C 0x681604c2
-0xe40 0x01007c00
-0xe44 0x01004800
-0xe48 0xfb000000
-0xe4c 0x000028d1
-0xe50 0x1000dc1f
-0xe54 0x10008c1f
-0xe58 0x02140102
-0xe5C 0x28160d05
-0xe60 0x00000010
-//0xe64 0x281600a0	// Reserved in 92C/88C
-0xe68 0x001b25a4
-0xe6c 0x631b25a0	// AFE ctrl reg (ASIC)  Blue-Tooth   
-0xe70 0x631b25a0	// AFE ctrl reg (ASIC)  RX_WAIT_CCA 
-0xe74 0x081b25a0	// AFE ctrl reg (ASIC)  TX_CCK_RFON
-0xe78 0x081b25a0	// AFE ctrl reg (ASIC)  TX_CCK_BBON
-0xe7c 0x081b25a0	// AFE ctrl reg (ASIC)  TX_OFDM_RFON
-0xe80 0x081b25a0	// AFE ctrl reg (ASIC)  TX_OFDM_BBON
-0xe84 0x631b25a0	// AFE ctrl reg (ASIC)  TX_TO_RX
-0xe88 0x081b25a0	// AFE ctrl reg (ASIC)  TX_TO_TX 
-0xe8c 0x631b25a0	// AFE ctrl reg (ASIC)  RX_CCK 
-0xed0 0x631b25a0	// AFE ctrl reg (ASIC)  RX_OFDM 
-0xed4 0x631b25a0	// AFE ctrl reg (ASIC)  RX_WAIT_RIFS 
-0xed8 0x631b25a0	// AFE ctrl reg (ASIC)  RX_TO_RX
-0xedc 0x001b25a0	// AFE ctrl reg (ASIC)  Standby 
-0xee0 0x001b25a0	// AFE ctrl reg (ASIC)  Sleep
-0xeec 0x6b1b25a0	// AFE ctrl reg (ASIC)  PMPD_ANAEN 
-//
-0xf14 0x00000003 // debug port selection. 0x0~0x3: PHY DBG, 0x4~0x5: MAC DBG
-0xf4c 0x00000000 // Only for FPGA PMAC
-0xf00 0x00000300 // enable BBRSTB, bcz HSSI use clk_bb
-0xff
+//100311
+//0x024 0x11800f	//syn CLK enable // tmp 40MHz solution
+//0x028 0xffdb83	//320MHz CLK enable, medium BB clock driving // tmp 40MHz solution
+0x028 0xffff83		//320MHz CLK enable, strong BB clock driving // tmp 40MHz solution
+
+
+//=======================
+// PAGE_8 ( FPGA_PHY0 )
+//=======================
+0x800 0x80040000 
+0x804 0x00000001
+0x808 0x0000fc00 
+0x80c 0x0000000A  
+0x810 0x10000330
+0x814 0x020c3d10 
+0x818 0x02200385 // [30:29] is DTR, Set off now. turn off RIFS: 0x00200185, turn on RIFS: 0x00200385
+0x81c 0x00000000 
+0x820 0x01000100 // 0x01000000 (SI), 0x01000100 (PI) 
+0x824 0x00390004 
+0x828 0x00000000
+0x82c 0x00000000 
+0x830 0x00000000
+0x834 0x00000000
+0x838 0x00000000
+0x83c 0x00000000
+0x840 0x00010000  //RF to standby mode
+0x844 0x00000000   
+0x848 0x00000000
+0x84c 0x00000000
+0x850 0x00000000  // RF wakeup, TBD    
+0x854 0x00000000  // RF sleep, TBD
+0x858 0x569a569a 
+0x85c 0x001b25a4   // AFE ctrl reg (ASIC)  RX AD3 CCA mode
+0x860 0x66e60230  //88CE default left anatenna
+0x864 0x061f0130 
+0x868 0x00000000
+0x86c 0x32323200  //Path-A 11M/5.5M/2M TX AGC codeword
+0x870 0x07000700  // z2: 0x03000300, 92C RF: 0x07000700 (2 internal PA), 92S RF: 0x03000700 (one internal PA)
+0x874 0x22004000  // 
+0x878 0x00000808  // RF mode for standby & rx_low_power codeword
+0x87c 0x00000000   // TST mode
+0x880 0xc0083070  // AFE ctrl reg (ASIC) 
+0x884 0x000004d5  // AFE ctrl reg (ASIC) 
+0x888 0x00000000  // AFE ctrl reg (ASIC) 
+0x88c 0xccc000c0  // [10:1] is r_rdy_cnt for sleep/standby mode, [27],[31] are MCS_IND
+0x890 0x00000800
+0x894 0xfffffffe 
+0x898 0x40302010 
+0x89c 0x00706050 
+//
+//=======================
+// PAGE_9 ( FPGA_PHY1 )
+//=======================
+0x900 0x00000000
+0x904 0x00000023 
+0x908 0x00000000  
+0x90c 0x81121111 // tx antenna by contorl register
+//
+//=======================
+// PAGE_A ( CCK_PHY0 )
+//=======================
+0xa00 0x00d047c8
+0xa04 0x80ff000c
+0xa08 0x8c838300 // MP: 0x88838300, driver: 0x8ccd8300
+0xa0c 0x2e68120f
+0xa10 0x9500bb78 // 
+0xa14 0x11144028
+0xa18 0x00881117
+0xa1c 0x89140f00
+0xa20 0x1a1b0000 
+0xa24 0x090e1317 
+0xa28 0x00000204
+0xa2c 0x00d30000
+0xa70 0x101fbf00
+0xa74 0x00000007
+//
+//=======================
+// PAGE_B
+//=======================
+//
+//
+//=======================
+// PAGE_C ( OFDM_PHY0 )
+//=======================
+0xc00 0x48071d40 
+0xc04 0x03a05611  
+0xc08 0x000000e4  // [8:4] is about DBG_GPIO selection 
+0xc0c 0x6c6c6c6c 
+0xc10 0x08800000 
+0xc14 0x40000100
+0xc18 0x08800000
+0xc1c 0x40000100
+0xc20 0x00000000  // DTR TH
+0xc24 0x00000000  // DTR TH
+0xc28 0x00000000  // DTR TH
+0xc2c 0x00000000  // DTR TH
+0xc30 0x69e9ac44  // PWED_TH option2=0x69e9bb44, 0x69e9ab44, 0x69e9ac44
+0xc34 0x469652cf   
+0xc38 0x49795994   
+0xc3c 0x0a97971c  
+0xc40 0x1f7c403f  
+0xc44 0x000100b7  
+0xc48 0xec020107 //[1]=1:enable L1_SBD 
+0xc4c 0x007f037f // turn off edcca 
+0xc50 0x69543420 // AAGC=1,0x68043420, AAGC=2,0x69543420 
+0xc54 0x43bc0094 
+0xc58 0x69543420 // AAGC=1,0x68043420, AAGC=2,0x69543420   
+0xc5c 0x433c0094
+0xc60 0x00000000 // DTR TH
+0xc64 0x5116848b //L1-SBD  //31168a8b for 6M sen. 0x5116828b, 0x5116848b
+0xc68 0x47c00bff //L1-SBD
+0xc6c 0x00000036 //L1-SBD
+0xc70 0x2c7f000d // disable AGC flow-1 
+0xc74 0x018610db // AGC RSSI setting time = 600nS.//0x0186109b=>RRSI=500ns,BBP=300ns for PI used, 0x0186175b
+0xc78 0x0000001f
+0xc7c 0x00b91612  
+0xc80 0x40000100 
+0xc84 0x20f60000 
+0xc88 0x40000100 
+0xc8c 0xa0e40000 // for MRC weighting function 
+0xc90 0x00121820 // TX Power Training for path-A	
+0xc94 0x00000000 	
+0xc98 0x00121820// TX Power Training for path-B
+0xc9c 0x00007f7f // turn off pre-cca
+0xca0 0x00000000 
+0xca4 0x00000080 // reserved
+0xca8 0x00000000 // reserved
+0xcac 0x00000000 // reserved
+0xcb0 0x00000000 // reserved
+0xcb4 0x00000000 // reserved
+0xcb8 0x00000000 // reserved
+0xcbc 0x28000000
+0xcc0 0x00000000 // reserved
+0xcc4 0x00000000 // reserved
+0xcc8 0x00000000 // reserved
+0xccc 0x00000000 // reserved
+0xcd0 0x00000000 // reserved
+0xcd4 0x00000000 // reserved
+0xcd8 0x64b22427 // reserved
+0xcdc 0x00766932 // reserved
+0xce0 0x00222222  
+0xce4 0x00000000
+0xce8 0x37644302
+0xcec 0x2f97d40c
+//
+//=======================
+// PAGE_D ( OFDM_PHY1 )
+//=======================
+0xd00 0x00080740 
+0xd04 0x00020401  
+0xd08 0x0000907f  
+0xd0c 0x20010201 
+0xd10 0xa0633333  
+0xd14 0x3333bc43  
+0xd18 0x7a8f5b6b
+0xd2c 0xcc979975  
+0xd30 0x00000000
+0xd34 0x80608000
+0xd38 0x00000000
+0xd3c 0x00027293
+0xd40 0x00000000
+0xd44 0x00000000
+0xd48 0x00000000
+0xd4c 0x00000000
+0xd50 0x6437140a 
+0xd54 0x00000000 
+0xd58 0x00000000
+0xd5c 0x30032064 
+0xd60 0x4653de68
+0xd64 0x04518a3c //[26]=1:enable L1-SBD//
+0xd68 0x00002101
+0xd6c 0x2a201c16  // DTR
+0xd70 0x1812362e  // DTR
+0xd74 0x322c2220  // DTR
+0xd78 0x000e3c24  // DTR
+//=======================
+// PAGE_E
+//=======================
+0xe00 0x2a2a2a2a	// Path-A TX AGC codewod, 6M, 9M, 12M, 18M 
+0xe04 0x2a2a2a2a	// Path-A TX AGC codewod, 24M, 36M, 48M, 54M 
+0xe08 0x03902a2a	// Path-A TX AGC codewod, MCS32, 1M 
+0xe10 0x2a2a2a2a	// Path-A TX AGC codewod, MCS0, MCS1, MCS2, MCS3 
+0xe14 0x2a2a2a2a	// Path-A TX AGC codewod, MCS4, MCS5, MCS6, MCS7 
+0xe18 0x2a2a2a2a	// Path-A TX AGC codewod, MCS8, MCS9, MCS10, MCS11 
+0xe1c 0x2a2a2a2a	// Path-A TX AGC codewod, MCS12, MCS13, MCS14, MCS15 
+0xe28 0x00000000        
+0xe30 0x1000dc1f	// 0xe30~0xe60: IQK
+0xe34 0x10008c1f
+0xe38 0x02140102
+0xe3C 0x681604c2
+0xe40 0x01007c00
+0xe44 0x01004800
+0xe48 0xfb000000
+0xe4c 0x000028d1
+0xe50 0x1000dc1f
+0xe54 0x10008c1f
+0xe58 0x02140102
+0xe5C 0x28160d05
+0xe60 0x00000010
+//0xe64 0x281600a0	// Reserved in 92C/88C
+0xe68 0x001b25a4
+0xe6c 0x631b25a0	// AFE ctrl reg (ASIC)  Blue-Tooth   
+0xe70 0x631b25a0	// AFE ctrl reg (ASIC)  RX_WAIT_CCA 
+0xe74 0x081b25a0	// AFE ctrl reg (ASIC)  TX_CCK_RFON
+0xe78 0x081b25a0	// AFE ctrl reg (ASIC)  TX_CCK_BBON
+0xe7c 0x081b25a0	// AFE ctrl reg (ASIC)  TX_OFDM_RFON
+0xe80 0x081b25a0	// AFE ctrl reg (ASIC)  TX_OFDM_BBON
+0xe84 0x631b25a0	// AFE ctrl reg (ASIC)  TX_TO_RX
+0xe88 0x081b25a0	// AFE ctrl reg (ASIC)  TX_TO_TX 
+0xe8c 0x631b25a0	// AFE ctrl reg (ASIC)  RX_CCK 
+0xed0 0x631b25a0	// AFE ctrl reg (ASIC)  RX_OFDM 
+0xed4 0x631b25a0	// AFE ctrl reg (ASIC)  RX_WAIT_RIFS 
+0xed8 0x631b25a0	// AFE ctrl reg (ASIC)  RX_TO_RX
+0xedc 0x001b25a0	// AFE ctrl reg (ASIC)  Standby 
+0xee0 0x001b25a0	// AFE ctrl reg (ASIC)  Sleep
+0xeec 0x6b1b25a0	// AFE ctrl reg (ASIC)  PMPD_ANAEN 
+//
+0xf14 0x00000003 // debug port selection. 0x0~0x3: PHY DBG, 0x4~0x5: MAC DBG
+0xf4c 0x00000000 // Only for FPGA PMAC
+0xf00 0x00000300 // enable BBRSTB, bcz HSSI use clk_bb
+0xff
diff --git a/drivers/net/wireless/rtl8192cd/data/PHY_REG_1T_n_hp.txt b/drivers/net/wireless/rtl8192cd/data/PHY_REG_1T_n_hp.txt
index 325b374..320ed6a 100644
--- a/drivers/net/wireless/rtl8192cd/data/PHY_REG_1T_n_hp.txt
+++ b/drivers/net/wireless/rtl8192cd/data/PHY_REG_1T_n_hp.txt
@@ -1,222 +1,222 @@
-//100311
-//0x024 0x11800f	//syn CLK enable // tmp 40MHz solution
-//0x028 0xffdb83	//320MHz CLK enable, medium BB clock driving // tmp 40MHz solution
-0x028 0xffff83		//320MHz CLK enable, strong BB clock driving // tmp 40MHz solution
-0x040 0x000C0004        //Arthur-enable path 0 TR switch
-//=======================
-// PAGE_8 ( FPGA_PHY0 )
-//=======================
-0x800 0x80040000 
-0x804 0x00000001
-0x808 0x0000fc00 
-0x80c 0x0000000A  
-0x810 0x10005388
-0x814 0x020c3d10 
-0x818 0x02200385 // [30:29] is DTR, Set off now. turn off RIFS: 0x00200185, turn on RIFS: 0x00200385
-0x81c 0x00000000 
-0x820 0x01000100 // 0x01000000 (SI), 0x01000100 (PI) 
-0x824 0x00390204 // jerry- for CCK Rx path A dynamic range
-0x828 0x00000000
-0x82c 0x00000000 
-0x830 0x00000000
-0x834 0x00000000
-0x838 0x00000000
-0x83c 0x00000000
-0x840 0x00010000  //RF to standby mode
-0x844 0x00000000   
-0x848 0x00000000
-0x84c 0x00000000
-0x850 0x00000000  // RF wakeup, TBD    
-0x854 0x00000000  // RF sleep, TBD
-0x858 0x569a569a 
-0x85c 0x001b25a4   // AFE ctrl reg (ASIC)  RX AD3 CCA mode
-0x860 0x66e60230  //88CE default left anatenna
-0x864 0x061f0130 
-0x868 0x00000000
-0x86c 0x20202020  // Path-A 11M/5.5M/2M TX AGC codeword, Path-B 11M TX AGC codeword
-0x870 0x03000300  // z2: 0x03000300, 92C RF: 0x07000700 (2 internal PA), 92S RF: 0x03000700 (one internal PA)
-0x874 0x22004000  // 
-0x878 0x00000808  // RF mode for standby & rx_low_power codeword
-0x87c 0x00000000   // TST mode
-0x880 0xc0083070  // AFE ctrl reg (ASIC) 
-0x884 0x000004d5  // AFE ctrl reg (ASIC) 
-0x888 0x00000000  // AFE ctrl reg (ASIC) 
-0x88c 0xccc000c0  // [10:1] is r_rdy_cnt for sleep/standby mode, [27],[31] are MCS_IND
-0x890 0x00000800
-0x894 0xfffffffe 
-0x898 0x40302010 
-0x89c 0x00706050 
-//
-//=======================
-// PAGE_9 ( FPGA_PHY1 )
-//=======================
-0x900 0x00000000
-0x904 0x00000023 
-0x908 0x00000000  
-0x90c 0x81121111 // tx antenna by contorl register
-//
-//=======================
-// PAGE_A ( CCK_PHY0 )
-//=======================
-0xa00 0x00d047c8
-0xa04 0x80ff000c
-0xa08 0x8c838300 // MP: 0x88838300, driver: 0x8ccd8300
-0xa0c 0x2e68120f
-0xa10 0x9500bb78 // 
-0xa14 0x11144028
-0xa18 0x00881117
-0xa1c 0x89140f00
-0xa20 0x15160000 //Arthur-power tracking for high-power
-0xa24 0x070b0f12 //Arthur-power tracking for high-power
-0xa28 0x00000104 //Arthur-power tracking for high-power
-0xa2c 0x00d30000
-0xa70 0x101fbf00
-0xa74 0x00000007
-//
-//=======================
-// PAGE_B
-//=======================
-//
-//
-//=======================
-// PAGE_C ( OFDM_PHY0 )
-//=======================
-0xc00 0x48071d40 
-0xc04 0x03a05611  
-0xc08 0x000000e4  // [8:4] is about DBG_GPIO selection 
-0xc0c 0x6c6c6c6c 
-0xc10 0x08800000 
-0xc14 0x40000100
-0xc18 0x08800000
-0xc1c 0x40000100
-0xc20 0x00000000  // DTR TH
-0xc24 0x00000000  // DTR TH
-0xc28 0x00000000  // DTR TH
-0xc2c 0x00000000  // DTR TH
-0xc30 0x69e9ac44  // PWED_TH option2=0x69e9bb44, 0x69e9ab44, 0x69e9ac44
-0xc34 0x469652cf   
-0xc38 0x49795994   
-0xc3c 0x0a97971c  
-0xc40 0x1f7c403f  
-0xc44 0x000100b7  
-0xc48 0xec020107 //[1]=1:enable L1_SBD 
-0xc4c 0x007f037f // turn off edcca 
-0xc50 0x6954342e // AAGC=1,0x68043420, AAGC=2,0x69543420, 0x6954342e for external LNA
-0xc54 0x43bc0094 
-0xc58 0x6954342e // AAGC=1,0x68043420, AAGC=2,0x69543420, 0x6954342e for external LNA      
-0xc5c 0x433c0094
-0xc60 0x00000000 // DTR TH
-0xc64 0x5116848b //L1-SBD  //31168a8b for 6M sen. 0x5116828b, 0x5116848b
-0xc68 0x47c00bff //L1-SBD
-0xc6c 0x00000036 //L1-SBD
-0xc70 0x2c56000d // disable AGC flow-1, 0x2c56000d for external LAN during high input power 
-0xc74 0x018610db // AGC RSSI setting time = 600nS.//0x0186109b=>RRSI=500ns,BBP=300ns for PI used, 0x0186175b
-0xc78 0x0000001f
-0xc7c 0x00b91612  
-0xc80 0x24000090 //Arthur-power tracking for high-power
-0xc84 0x20f60000 
-0xc88 0x24000090 //Arthur-power tracking for high-power
-0xc8c 0xa0e40000 //for MRC weighting function 
-0xc90 0x00121820 // TX Power Training for path-A	
-0xc94 0x00000000 	
-0xc98 0x00121820// TX Power Training for path-B
-0xc9c 0x00007f7f // turn off pre-cca
-0xca0 0x00000000 
-0xca4 0x00000080 // reserved
-0xca8 0x00000000 // reserved
-0xcac 0x00000000 // reserved
-0xcb0 0x00000000 // reserved
-0xcb4 0x00000000 // reserved
-0xcb8 0x00000000 // reserved
-0xcbc 0x28000000
-0xcc0 0x00000000 // reserved
-0xcc4 0x00000000 // reserved
-0xcc8 0x00000000 // reserved
-0xccc 0x00000000 // reserved
-0xcd0 0x00000000 // reserved
-0xcd4 0x00000000 // reserved
-0xcd8 0x64b22427 // reserved
-0xcdc 0x00766932 // reserved
-0xce0 0x00222222  
-0xce4 0x00000000
-0xce8 0x37644302
-0xcec 0x2f97d40c
-//
-//=======================
-// PAGE_D ( OFDM_PHY1 )
-//=======================
-0xd00 0x00080740 
-0xd04 0x00020401  
-0xd08 0x0000907f  
-0xd0c 0x20010201 
-0xd10 0xa0633333  
-0xd14 0x3333bc43  
-0xd18 0x7a8f5b6b
-0xd2c 0xcc979975  
-0xd30 0x00000000
-0xd34 0x80608000
-0xd38 0x00000000
-0xd3c 0x00027293
-0xd40 0x00000000
-0xd44 0x00000000
-0xd48 0x00000000
-0xd4c 0x00000000
-0xd50 0x6437140a 
-0xd54 0x00000000 
-0xd58 0x00000000
-0xd5c 0x30032064 
-0xd60 0x4653de68
-0xd64 0x04518a3c //[26]=1:enable L1-SBD//
-0xd68 0x00002101
-0xd6c 0x2a201c16  // DTR
-0xd70 0x1812362e  // DTR
-0xd74 0x322c2220  // DTR
-0xd78 0x000e3c24  // DTR
-//=======================
-// PAGE_E
-//=======================
-0xe00 0x24242424	// Path-A TX AGC codewod, 6M, 9M, 12M, 18M 
-0xe04 0x24242424	// Path-A TX AGC codewod, 24M, 36M, 48M, 54M 
-0xe08 0x03902024	// Path-A TX AGC codewod, MCS32, 1M 
-0xe10 0x24242424	// Path-A TX AGC codewod, MCS0, MCS1, MCS2, MCS3 
-0xe14 0x24242424	// Path-A TX AGC codewod, MCS4, MCS5, MCS6, MCS7 
-0xe18 0x24242424	// Path-A TX AGC codewod, MCS8, MCS9, MCS10, MCS11 
-0xe1c 0x24242424	// Path-A TX AGC codewod, MCS12, MCS13, MCS14, MCS15 
-0xe28 0x00000000        
-0xe30 0x1000dc1f	// 0xe30~0xe60: IQK
-0xe34 0x10008c1f
-0xe38 0x02140102
-0xe3C 0x681604c2
-0xe40 0x01007c00
-0xe44 0x01004800
-0xe48 0xfb000000
-0xe4c 0x000028d1
-0xe50 0x1000dc1f
-0xe54 0x10008c1f
-0xe58 0x02140102
-0xe5C 0x28160d05
-0xe60 0x00000010
-//0xe64 0x281600a0	// Reserved in 92C/88C
-0xe68 0x001b25a4
-0xe6c 0x631b25a0	// AFE ctrl reg (ASIC)  Blue-Tooth   
-0xe70 0x631b25a0	// AFE ctrl reg (ASIC)  RX_WAIT_CCA 
-0xe74 0x081b25a0	// AFE ctrl reg (ASIC)  TX_CCK_RFON
-0xe78 0x081b25a0	// AFE ctrl reg (ASIC)  TX_CCK_BBON
-0xe7c 0x081b25a0	// AFE ctrl reg (ASIC)  TX_OFDM_RFON
-0xe80 0x081b25a0	// AFE ctrl reg (ASIC)  TX_OFDM_BBON
-0xe84 0x631b25a0	// AFE ctrl reg (ASIC)  TX_TO_RX
-0xe88 0x081b25a0	// AFE ctrl reg (ASIC)  TX_TO_TX 
-0xe8c 0x631b25a0	// AFE ctrl reg (ASIC)  RX_CCK 
-0xed0 0x631b25a0	// AFE ctrl reg (ASIC)  RX_OFDM 
-0xed4 0x631b25a0	// AFE ctrl reg (ASIC)  RX_WAIT_RIFS 
-0xed8 0x631b25a0	// AFE ctrl reg (ASIC)  RX_TO_RX
-0xedc 0x001b25a0	// AFE ctrl reg (ASIC)  Standby 
-0xee0 0x001b25a0	// AFE ctrl reg (ASIC)  Sleep
-0xeec 0x6b1b25a0	// AFE ctrl reg (ASIC)  PMPD_ANAEN
-0xee8 0x31555448        // Authur-enable PAPE
-//
-0xf14 0x00000003 // debug port selection. 0x0~0x3: PHY DBG, 0x4~0x5: MAC DBG
-0xf4c 0x00000000 // Only for FPGA PMAC
-0xf00 0x00000300 // enable BBRSTB, bcz HSSI use clk_bb
-0xff
-
+//100311
+//0x024 0x11800f	//syn CLK enable // tmp 40MHz solution
+//0x028 0xffdb83	//320MHz CLK enable, medium BB clock driving // tmp 40MHz solution
+0x028 0xffff83		//320MHz CLK enable, strong BB clock driving // tmp 40MHz solution
+0x040 0x000C0004        //Arthur-enable path 0 TR switch
+//=======================
+// PAGE_8 ( FPGA_PHY0 )
+//=======================
+0x800 0x80040000 
+0x804 0x00000001
+0x808 0x0000fc00 
+0x80c 0x0000000A  
+0x810 0x10005388
+0x814 0x020c3d10 
+0x818 0x02200385 // [30:29] is DTR, Set off now. turn off RIFS: 0x00200185, turn on RIFS: 0x00200385
+0x81c 0x00000000 
+0x820 0x01000100 // 0x01000000 (SI), 0x01000100 (PI) 
+0x824 0x00390204 // jerry- for CCK Rx path A dynamic range
+0x828 0x00000000
+0x82c 0x00000000 
+0x830 0x00000000
+0x834 0x00000000
+0x838 0x00000000
+0x83c 0x00000000
+0x840 0x00010000  //RF to standby mode
+0x844 0x00000000   
+0x848 0x00000000
+0x84c 0x00000000
+0x850 0x00000000  // RF wakeup, TBD    
+0x854 0x00000000  // RF sleep, TBD
+0x858 0x569a569a 
+0x85c 0x001b25a4   // AFE ctrl reg (ASIC)  RX AD3 CCA mode
+0x860 0x66e60230  //88CE default left anatenna
+0x864 0x061f0130 
+0x868 0x00000000
+0x86c 0x20202020  // Path-A 11M/5.5M/2M TX AGC codeword, Path-B 11M TX AGC codeword
+0x870 0x03000300  // z2: 0x03000300, 92C RF: 0x07000700 (2 internal PA), 92S RF: 0x03000700 (one internal PA)
+0x874 0x22004000  // 
+0x878 0x00000808  // RF mode for standby & rx_low_power codeword
+0x87c 0x00000000   // TST mode
+0x880 0xc0083070  // AFE ctrl reg (ASIC) 
+0x884 0x000004d5  // AFE ctrl reg (ASIC) 
+0x888 0x00000000  // AFE ctrl reg (ASIC) 
+0x88c 0xccc000c0  // [10:1] is r_rdy_cnt for sleep/standby mode, [27],[31] are MCS_IND
+0x890 0x00000800
+0x894 0xfffffffe 
+0x898 0x40302010 
+0x89c 0x00706050 
+//
+//=======================
+// PAGE_9 ( FPGA_PHY1 )
+//=======================
+0x900 0x00000000
+0x904 0x00000023 
+0x908 0x00000000  
+0x90c 0x81121111 // tx antenna by contorl register
+//
+//=======================
+// PAGE_A ( CCK_PHY0 )
+//=======================
+0xa00 0x00d047c8
+0xa04 0x80ff000c
+0xa08 0x8c838300 // MP: 0x88838300, driver: 0x8ccd8300
+0xa0c 0x2e68120f
+0xa10 0x9500bb78 // 
+0xa14 0x11144028
+0xa18 0x00881117
+0xa1c 0x89140f00
+0xa20 0x15160000 //Arthur-power tracking for high-power
+0xa24 0x070b0f12 //Arthur-power tracking for high-power
+0xa28 0x00000104 //Arthur-power tracking for high-power
+0xa2c 0x00d30000
+0xa70 0x101fbf00
+0xa74 0x00000007
+//
+//=======================
+// PAGE_B
+//=======================
+//
+//
+//=======================
+// PAGE_C ( OFDM_PHY0 )
+//=======================
+0xc00 0x48071d40 
+0xc04 0x03a05611  
+0xc08 0x000000e4  // [8:4] is about DBG_GPIO selection 
+0xc0c 0x6c6c6c6c 
+0xc10 0x08800000 
+0xc14 0x40000100
+0xc18 0x08800000
+0xc1c 0x40000100
+0xc20 0x00000000  // DTR TH
+0xc24 0x00000000  // DTR TH
+0xc28 0x00000000  // DTR TH
+0xc2c 0x00000000  // DTR TH
+0xc30 0x69e9ac44  // PWED_TH option2=0x69e9bb44, 0x69e9ab44, 0x69e9ac44
+0xc34 0x469652cf   
+0xc38 0x49795994   
+0xc3c 0x0a97971c  
+0xc40 0x1f7c403f  
+0xc44 0x000100b7  
+0xc48 0xec020107 //[1]=1:enable L1_SBD 
+0xc4c 0x007f037f // turn off edcca 
+0xc50 0x6954342e // AAGC=1,0x68043420, AAGC=2,0x69543420, 0x6954342e for external LNA
+0xc54 0x43bc0094 
+0xc58 0x6954342e // AAGC=1,0x68043420, AAGC=2,0x69543420, 0x6954342e for external LNA      
+0xc5c 0x433c0094
+0xc60 0x00000000 // DTR TH
+0xc64 0x5116848b //L1-SBD  //31168a8b for 6M sen. 0x5116828b, 0x5116848b
+0xc68 0x47c00bff //L1-SBD
+0xc6c 0x00000036 //L1-SBD
+0xc70 0x2c56000d // disable AGC flow-1, 0x2c56000d for external LAN during high input power 
+0xc74 0x018610db // AGC RSSI setting time = 600nS.//0x0186109b=>RRSI=500ns,BBP=300ns for PI used, 0x0186175b
+0xc78 0x0000001f
+0xc7c 0x00b91612  
+0xc80 0x24000090 //Arthur-power tracking for high-power
+0xc84 0x20f60000 
+0xc88 0x24000090 //Arthur-power tracking for high-power
+0xc8c 0xa0e40000 // for MRC weighting function 
+0xc90 0x00121820 // TX Power Training for path-A	
+0xc94 0x00000000 	
+0xc98 0x00121820// TX Power Training for path-B
+0xc9c 0x00007f7f // turn off pre-cca
+0xca0 0x00000000 
+0xca4 0x00000080 // reserved
+0xca8 0x00000000 // reserved
+0xcac 0x00000000 // reserved
+0xcb0 0x00000000 // reserved
+0xcb4 0x00000000 // reserved
+0xcb8 0x00000000 // reserved
+0xcbc 0x28000000
+0xcc0 0x00000000 // reserved
+0xcc4 0x00000000 // reserved
+0xcc8 0x00000000 // reserved
+0xccc 0x00000000 // reserved
+0xcd0 0x00000000 // reserved
+0xcd4 0x00000000 // reserved
+0xcd8 0x64b22427 // reserved
+0xcdc 0x00766932 // reserved
+0xce0 0x00222222  
+0xce4 0x00000000
+0xce8 0x37644302
+0xcec 0x2f97d40c
+//
+//=======================
+// PAGE_D ( OFDM_PHY1 )
+//=======================
+0xd00 0x00080740 
+0xd04 0x00020401  
+0xd08 0x0000907f  
+0xd0c 0x20010201 
+0xd10 0xa0633333  
+0xd14 0x3333bc43  
+0xd18 0x7a8f5b6b
+0xd2c 0xcc979975  
+0xd30 0x00000000
+0xd34 0x80608000
+0xd38 0x00000000
+0xd3c 0x00027293
+0xd40 0x00000000
+0xd44 0x00000000
+0xd48 0x00000000
+0xd4c 0x00000000
+0xd50 0x6437140a 
+0xd54 0x00000000 
+0xd58 0x00000000
+0xd5c 0x30032064 
+0xd60 0x4653de68
+0xd64 0x04518a3c //[26]=1:enable L1-SBD//
+0xd68 0x00002101
+0xd6c 0x2a201c16  // DTR
+0xd70 0x1812362e  // DTR
+0xd74 0x322c2220  // DTR
+0xd78 0x000e3c24  // DTR
+//=======================
+// PAGE_E
+//=======================
+0xe00 0x24242424	// Path-A TX AGC codewod, 6M, 9M, 12M, 18M 
+0xe04 0x24242424	// Path-A TX AGC codewod, 24M, 36M, 48M, 54M 
+0xe08 0x03902024	// Path-A TX AGC codewod, MCS32, 1M 
+0xe10 0x24242424	// Path-A TX AGC codewod, MCS0, MCS1, MCS2, MCS3 
+0xe14 0x24242424	// Path-A TX AGC codewod, MCS4, MCS5, MCS6, MCS7 
+0xe18 0x24242424	// Path-A TX AGC codewod, MCS8, MCS9, MCS10, MCS11 
+0xe1c 0x24242424	// Path-A TX AGC codewod, MCS12, MCS13, MCS14, MCS15 
+0xe28 0x00000000        
+0xe30 0x1000dc1f	// 0xe30~0xe60: IQK
+0xe34 0x10008c1f
+0xe38 0x02140102
+0xe3C 0x681604c2
+0xe40 0x01007c00
+0xe44 0x01004800
+0xe48 0xfb000000
+0xe4c 0x000028d1
+0xe50 0x1000dc1f
+0xe54 0x10008c1f
+0xe58 0x02140102
+0xe5C 0x28160d05
+0xe60 0x00000010
+//0xe64 0x281600a0	// Reserved in 92C/88C
+0xe68 0x001b25a4
+0xe6c 0x631b25a0	// AFE ctrl reg (ASIC)  Blue-Tooth   
+0xe70 0x631b25a0	// AFE ctrl reg (ASIC)  RX_WAIT_CCA 
+0xe74 0x081b25a0	// AFE ctrl reg (ASIC)  TX_CCK_RFON
+0xe78 0x081b25a0	// AFE ctrl reg (ASIC)  TX_CCK_BBON
+0xe7c 0x081b25a0	// AFE ctrl reg (ASIC)  TX_OFDM_RFON
+0xe80 0x081b25a0	// AFE ctrl reg (ASIC)  TX_OFDM_BBON
+0xe84 0x631b25a0	// AFE ctrl reg (ASIC)  TX_TO_RX
+0xe88 0x081b25a0	// AFE ctrl reg (ASIC)  TX_TO_TX 
+0xe8c 0x631b25a0	// AFE ctrl reg (ASIC)  RX_CCK 
+0xed0 0x631b25a0	// AFE ctrl reg (ASIC)  RX_OFDM 
+0xed4 0x631b25a0	// AFE ctrl reg (ASIC)  RX_WAIT_RIFS 
+0xed8 0x631b25a0	// AFE ctrl reg (ASIC)  RX_TO_RX
+0xedc 0x001b25a0	// AFE ctrl reg (ASIC)  Standby 
+0xee0 0x001b25a0	// AFE ctrl reg (ASIC)  Sleep
+0xeec 0x6b1b25a0	// AFE ctrl reg (ASIC)  PMPD_ANAEN
+0xee8 0x31555448        // Authur-enable PAPE
+//
+0xf14 0x00000003 // debug port selection. 0x0~0x3: PHY DBG, 0x4~0x5: MAC DBG
+0xf4c 0x00000000 // Only for FPGA PMAC
+0xf00 0x00000300 // enable BBRSTB, bcz HSSI use clk_bb
+0xff
+
diff --git a/drivers/net/wireless/rtl8192cd/data/PHY_REG_2T.txt b/drivers/net/wireless/rtl8192cd/data/PHY_REG_2T.txt
index d0ee428..c02d20f 100644
--- a/drivers/net/wireless/rtl8192cd/data/PHY_REG_2T.txt
+++ b/drivers/net/wireless/rtl8192cd/data/PHY_REG_2T.txt
@@ -1,271 +1,271 @@
-//091204
-//0x024 0x0011800f	//syn CLK enable
-//0x028 0x00ffdb83	//320MHz CLK enable
-0x028 0xffff83          //320MHz CLK enable, strong BB clock driving // tmp 40MHz solution
-//=======================
-// PAGE_8 ( FPGA_PHY0 )
-//=======================
-0x800 0x80040002 // turn off RF when 1R CCA 
-0x804 0x00000003
-0x808 0x0000fc00 
-0x80c 0x0000000A  
-0x810 0x10005388
-0x814 0x020c3d10 
-0x818 0x02200385 // [30:29] is DTR, Set off now. turn off RIFS: 0x00200185, turn on RIFS: 0x00200385
-0x81c 0x00000000 
-0x820 0x01000100 // 0x01000000 (SI), 0x01000100 (PI) 
-0x824 0x00390004 
-0x828 0x01000100 // 0x01000000 (SI), 0x01000100 (PI) 
-0x82c 0x00390004 
-0x830 0x27272727 // Path-B TX AGC codewod, 6M, 9M, 12M, 18M
-0x834 0x27272727  // Path-B TX AGC codewod, 24M, 36M, 48M, 54M
-0x838 0x27272727  // Path-B TX AGC codewod, MCS32, 1M, 2M, 5.5M
-0x83c 0x27272727  // Path-B TX AGC codewod, MCS0, MCS1, MCS2, MCS3
-0x840 0x00010000  //RF to standby mode
-0x844 0x00010000  //RF to standby mode 
-0x848 0x27272727  // Path-B TX AGC codewod, MCS4, MCS5, MCS6, MCS7
-0x84c 0x27272727  // Path-B TX AGC codewod, MCS8, MCS9, MCS10, MCS11
-0x850 0x00000000  // RF wakeup, TBD    
-0x854 0x00000000  // RF sleep, TBD
-0x858 0x65a965a9
-0x85c 0x0c1b25a4  // AFE ctrl reg (ASIC)  RX AD3 CCA mode
-0x860 0x0f7f0130 
-0x864 0x0f7f0130 
-0x868 0x27272727  // Path-B TX AGC codewod, MCS12, MCS13, MCS14, MCS15
-0x86c 0x272b2b2b  // Path-B 11M TX AGC codeword, Path-A 2M/5.5M/11M TX AGC codeword
-0x870 0x07000700  // z2: 0x03000300, 92C RF: 0x07000700 (2 internal PA), 92S RF: 0x03000700 (one internal PA)
-0x874 0x00004000  // 
-0x878 0x08080808  // RF mode for standby & rx_low_power codeword
-0x87c 0x00000000   // TST mode
-0x880 0xc0083070  // AFE ctrl reg (ASIC) 
-0x884 0x000004d5  // AFE ctrl reg (ASIC) 
-0x888 0x00000000  // AFE ctrl reg (ASIC) 
-0x88c 0xcc000004  // [10:1] is r_rdy_cnt for sleep/standby mode, [27],[31] are MCS_IND
-0x890 0x00000000
-0x894 0xfffffffe 
-0x898 0x40302010 
-0x89c 0x00706050 
-//
-//=======================
-// PAGE_9 ( FPGA_PHY1 )
-//=======================
-0x900 0x00000000
-0x904 0x00000023 
-0x908 0x00000000  
-0x90c 0x81121313 // tx antenna by contorl register
-//
-//=======================
-// PAGE_A ( CCK_PHY0 )
-//=======================
-0xa00 0x00d047c8
-0xa04 0xc1ff000c
-0xa08 0x8c038300 // MP: 0x88838300, driver: 0x8ccd8300
-0xa0c 0x2e62120f
-0xa10 0x95009b78 // 
-0xa14 0x11144028
-0xa18 0x00881117
-0xa1c 0x89140f00
-0xa20 0x1a1b0000 
-0xa24 0x090e1317 
-0xa28 0x00000204
-0xa2c 0x00d30000
-0xa70 0x101fbf80
-0xa74 0x00000007
-//
-//=======================
-// PAGE_B
-//=======================
-0xb00 0x01017018
-0xb04 0xf7ed8f84
-0xb08 0x40372d20
-0xb0c 0x5b554e48
-0xb10 0x6f6a6560
-0xb14 0x807c7873
-0xb18 0x8f8b8884
-0xb1c 0x9d999693
-0xb20 0xa9a6a3a0
-0xb24 0xb5b2afac
-0xb28 0x00810100
-0xb2c 0x00400056
-0xb30 0x002b0032
-0xb34 0x001f0024
-0xb38 0x0019001c
-0xb3c 0x00150017
-0xb40 0x00120013
-0xb44 0x00100011
-0xb48 0x000e000f
-0xb4c 0x000c000d
-0xb50 0x000b000c
-0xb54 0x000a000b
-0xb58 0x0009000a
-0xb5c 0x00090009
-0xb60 0x00080008
-0xb64 0x00080008
-0xb68 0x0fe00000
-0xb70 0x01017018
-0xb74 0xf7ed8f84
-0xb78 0x40372d20
-0xb7c 0x5b554e48
-0xb80 0x6f6a6560
-0xb84 0x807c7873
-0xb88 0x8f8b8884
-0xb8c 0x9d999693
-0xb90 0xa9a6a3a0
-0xb94 0xb5b2afac
-0xb98 0x00810100
-0xb9c 0x00400056
-0xba0 0x002b0032
-0xba4 0x001f0024
-0xba8 0x0019001c
-0xbac 0x00150017
-0xbb0 0x00120013
-0xbb4 0x00100011
-0xbb8 0x000e000f
-0xbbc 0x000c000d
-0xbc0 0x000b000c
-0xbc4 0x000a000b
-0xbc8 0x0009000a
-0xbcc 0x00090009
-0xbd0 0x00080008
-0xbd4 0x00080008
-0xb6c 0x0fe00000
-//
-//=======================
-// PAGE_C ( OFDM_PHY0 )
-//=======================
-0xc00 0x48071d40  // initial gain @ CCA negedge 
-0xc04 0x03a05633  
-0xc08 0x000000e4  // [8:4] is about DBG_GPIO selection 
-0xc0c 0x6c6c6c6c 
-0xc10 0x08800000 
-0xc14 0x40000100
-0xc18 0x08800000
-0xc1c 0x40000100
-0xc20 0x00000000  // DTR TH
-0xc24 0x00000000  // DTR TH
-0xc28 0x00000000  // DTR TH
-0xc2c 0x00000000  // DTR TH
-0xc30 0x69e9ac4a  // PWED_TH option2=0x69e9bb44, 0x69e9ab44, 0x69e9ac44
-0xc34 0x469652cf   
-0xc38 0x49795994   
-0xc3c 0x0a979718  
-0xc40 0x1f7c403f  
-0xc44 0x000100b7  
-0xc48 0xec020107 //[1]=1:enable L1_SBD 
-0xc4c 0x007f037f // turn off edcca 
-0xc50 0x6954341e // AAGC=1,0x68043420, AAGC=2,0x69543420 
-0xc54 0x433c0094 
-0xc58 0x6954341e // AAGC=1,0x68043420, AAGC=2,0x69543420   
-0xc5c 0x433c0094
-0xc60 0x00000000 // DTR TH
-0xc64 0x5116848b //L1-SBD  //31168a8b for 6M sen. 0x5116828b, 0x5116848b
-0xc68 0x47c00bff //L1-SBD
-0xc6c 0x00000036 //L1-SBD
-0xc70 0x2c7f000d // disable AGC flow-1 
-0xc74 0x018610db // AGC RSSI setting time = 600nS.//0x0186109b=>RRSI=500ns,BBP=300ns for PI used, 0x0186175b
-0xc78 0x0000001f
-0xc7c 0x00b91612  
-0xc80 0x40000100 
-0xc84 0x20f60000 
-0xc88 0x40000100 
-0xc8c 0xa0e40000 //for MRC weighting function 
-0xc90 0x00000000 // TX Power Training for path-A	
-0xc94 0x00000000 	
-0xc98 0x00000000 // TX Power Training for path-B
-0xc9c 0x00007f7f // turn off pre-cca
-0xca0 0x00000000 
-0xca4 0x00000000 // reserved
-0xca8 0x00000000 // reserved
-0xcac 0x00000000 // reserved
-0xcb0 0x00000000 // reserved
-0xcb4 0x00000000 // reserved
-0xcb8 0x00000000 // reserved
-0xcbc 0x28000000
-0xcc0 0x00000000 // reserved
-0xcc4 0x00000000 // reserved
-0xcc8 0x00000000 // reserved
-0xccc 0x00000000 // reserved
-0xcd0 0x00000000 // reserved
-0xcd4 0x00000000 // reserved
-0xcd8 0x64b22427 // reserved
-0xcdc 0x00766932 // reserved
-0xce0 0x00222222  
-0xce4 0x00000000
-0xce8 0x37644302
-0xcec 0x2f97d40c
-//
-//=======================
-// PAGE_D ( OFDM_PHY1 )
-//=======================
-0xd00 0x00080740 
-0xd04 0x00020403  
-0xd08 0x0000907f  
-0xd0c 0x20010201 
-0xd10 0xa0633333  
-0xd14 0x3333bc43  
-0xd18 0x7a8f5b6b
-0xd2c 0xcc979975  
-0xd30 0x00000000
-0xd34 0x80608000
-0xd38 0x00000000
-0xd3c 0x00027293
-0xd40 0x00000000
-0xd44 0x00000000
-0xd48 0x00000000
-0xd4c 0x00000000
-0xd50 0x6437140a 
-0xd54 0x00000000 
-0xd58 0x00000000
-0xd5c 0x30032064 
-0xd60 0x4653de68
-0xd64 0x04518a3c //[26]=1:enable L1-SBD//
-0xd68 0x00002101
-0xd6c 0x2a201c16  // DTR
-0xd70 0x1812362e  // DTR
-0xd74 0x322c2220  // DTR
-0xd78 0x000e3c24  // DTR
-//=======================
-// PAGE_E
-//=======================
-0xe00 0x2b2b2b2b	// Path-A TX AGC codewod, 6M, 9M, 12M, 18M 
-0xe04 0x2b2b2b2b	// Path-A TX AGC codewod, 24M, 36M, 48M, 54M 
-0xe08 0x2b2b2b2b	// Path-A TX AGC codewod, MCS32, 1M 
-0xe10 0x2b2b2b2b	// Path-A TX AGC codewod, MCS0, MCS1, MCS2, MCS3 
-0xe14 0x2b2b2b2b	// Path-A TX AGC codewod, MCS4, MCS5, MCS6, MCS7 
-0xe18 0x2b2b2b2b	// Path-A TX AGC codewod, MCS8, MCS9, MCS10, MCS11 
-0xe1c 0x2b2b2b2b	// Path-A TX AGC codewod, MCS12, MCS13, MCS14, MCS15 
-0xe28 0x00000000        
-0xe30 0x1000dc1f	// 0xe30~0xe60: IQK
-0xe34 0x10008c1f
-0xe38 0x02140102
-0xe3C 0x681604c2
-0xe40 0x01007c00
-0xe44 0x01004800
-0xe48 0xfb000000
-0xe4c 0x000028d1
-0xe50 0x1000dc1f
-0xe54 0x10008c1f
-0xe58 0x02140102
-0xe5C 0x28160d05
-//0xe60 0x021400a0
-//0xe64 0x281600a0	// Reserved in 92C/88C
-0xe6c 0x63db25a4	// AFE ctrl reg (ASIC)  Blue-Tooth   
-0xe70 0x63db25a4	// AFE ctrl reg (ASIC)  RX_WAIT_CCA 
-0xe74 0x0c1b25a4	// AFE ctrl reg (ASIC)  TX_CCK_RFON
-0xe78 0x0c1b25a4	// AFE ctrl reg (ASIC)  TX_CCK_BBON
-0xe7c 0x0c1b25a4	// AFE ctrl reg (ASIC)  TX_OFDM_RFON
-0xe80 0x0c1b25a4	// AFE ctrl reg (ASIC)  TX_OFDM_BBON
-0xe84 0x63db25a4	// AFE ctrl reg (ASIC)  TX_TO_RX
-0xe88 0x0c1b25a4	// AFE ctrl reg (ASIC)  TX_TO_TX 
-0xe8c 0x63db25a4	// AFE ctrl reg (ASIC)  RX_CCK 
-0xed0 0x63db25a4	// AFE ctrl reg (ASIC)  RX_OFDM 
-0xed4 0x63db25a4	// AFE ctrl reg (ASIC)  RX_WAIT_RIFS 
-0xed8 0x63db25a4	// AFE ctrl reg (ASIC)  RX_TO_RX
-0xedc 0x001b25a4	// AFE ctrl reg (ASIC)  Standby 
-0xee0 0x001b25a4	// AFE ctrl reg (ASIC)  Sleep
-0xeec 0x6fdb25a4	// AFE ctrl reg (ASIC)  PMPD_ANAEN 
-//
-0xf14 0x00000003 // debug port selection. 0x0~0x3: PHY DBG, 0x4~0x5: MAC DBG
-0xf4c 0x00000000 // Only for FPGA PMAC
-0xf00 0x00000300 // enable BBRSTB, bcz HSSI use clk_bb
-0xff
+//091204
+//0x024 0x0011800f	//syn CLK enable
+//0x028 0x00ffdb83	//320MHz CLK enable
+0x028 0xffff83          //320MHz CLK enable, strong BB clock driving // tmp 40MHz solution
+//=======================
+// PAGE_8 ( FPGA_PHY0 )
+//=======================
+0x800 0x80040002 // turn off RF when 1R CCA 
+0x804 0x00000003
+0x808 0x0000fc00 
+0x80c 0x0000000A  
+0x810 0x10000330
+0x814 0x020c3d10 
+0x818 0x02200385 // [30:29] is DTR, Set off now. turn off RIFS: 0x00200185, turn on RIFS: 0x00200385
+0x81c 0x00000000 
+0x820 0x01000100 // 0x01000000 (SI), 0x01000100 (PI) 
+0x824 0x00390004 
+0x828 0x01000100 // 0x01000000 (SI), 0x01000100 (PI) 
+0x82c 0x00390004 
+0x830 0x27272727 // Path-B TX AGC codewod, 6M, 9M, 12M, 18M
+0x834 0x27272727  // Path-B TX AGC codewod, 24M, 36M, 48M, 54M
+0x838 0x27272727  // Path-B TX AGC codewod, MCS32, 1M, 2M, 5.5M
+0x83c 0x27272727  // Path-B TX AGC codewod, MCS0, MCS1, MCS2, MCS3
+0x840 0x00010000  //RF to standby mode
+0x844 0x00010000  //RF to standby mode 
+0x848 0x27272727  // Path-B TX AGC codewod, MCS4, MCS5, MCS6, MCS7
+0x84c 0x27272727  // Path-B TX AGC codewod, MCS8, MCS9, MCS10, MCS11
+0x850 0x00000000  // RF wakeup, TBD    
+0x854 0x00000000  // RF sleep, TBD
+0x858 0x65a965a9
+0x85c 0x0c1b25a4  // AFE ctrl reg (ASIC)  RX AD3 CCA mode
+0x860 0x0f7f0130 
+0x864 0x0f7f0130 
+0x868 0x27272727  // Path-B TX AGC codewod, MCS12, MCS13, MCS14, MCS15
+0x86c 0x272b2b2b  // Path-B 11M TX AGC codeword, Path-A 2M/5.5M/11M TX AGC codeword
+0x870 0x07000700  // z2: 0x03000300, 92C RF: 0x07000700 (2 internal PA), 92S RF: 0x03000700 (one internal PA)
+0x874 0x00004000  // 
+0x878 0x08080808  // RF mode for standby & rx_low_power codeword
+0x87c 0x00000000   // TST mode
+0x880 0xc0083070  // AFE ctrl reg (ASIC) 
+0x884 0x000004d5  // AFE ctrl reg (ASIC) 
+0x888 0x00000000  // AFE ctrl reg (ASIC) 
+0x88c 0xcc000004  // [10:1] is r_rdy_cnt for sleep/standby mode, [27],[31] are MCS_IND
+0x890 0x00000000
+0x894 0xfffffffe 
+0x898 0x40302010 
+0x89c 0x00706050 
+//
+//=======================
+// PAGE_9 ( FPGA_PHY1 )
+//=======================
+0x900 0x00000000
+0x904 0x00000023 
+0x908 0x00000000  
+0x90c 0x81121313 // tx antenna by contorl register
+//
+//=======================
+// PAGE_A ( CCK_PHY0 )
+//=======================
+0xa00 0x00d047c8
+0xa04 0xc1ff000c
+0xa08 0x8c038300 // MP: 0x88838300, driver: 0x8ccd8300
+0xa0c 0x2e62120f
+0xa10 0x95009b78 // 
+0xa14 0x11144028
+0xa18 0x00881117
+0xa1c 0x89140f00
+0xa20 0x1a1b0000 
+0xa24 0x090e1317 
+0xa28 0x00000204
+0xa2c 0x00d30000
+0xa70 0x101fbf80
+0xa74 0x00000007
+//
+//=======================
+// PAGE_B
+//=======================
+0xb00 0x01017018
+0xb04 0xf7ed8f84
+0xb08 0x40372d20
+0xb0c 0x5b554e48
+0xb10 0x6f6a6560
+0xb14 0x807c7873
+0xb18 0x8f8b8884
+0xb1c 0x9d999693
+0xb20 0xa9a6a3a0
+0xb24 0xb5b2afac
+0xb28 0x00810100
+0xb2c 0x00400056
+0xb30 0x002b0032
+0xb34 0x001f0024
+0xb38 0x0019001c
+0xb3c 0x00150017
+0xb40 0x00120013
+0xb44 0x00100011
+0xb48 0x000e000f
+0xb4c 0x000c000d
+0xb50 0x000b000c
+0xb54 0x000a000b
+0xb58 0x0009000a
+0xb5c 0x00090009
+0xb60 0x00080008
+0xb64 0x00080008
+0xb68 0x0fe00000
+0xb70 0x01017018
+0xb74 0xf7ed8f84
+0xb78 0x40372d20
+0xb7c 0x5b554e48
+0xb80 0x6f6a6560
+0xb84 0x807c7873
+0xb88 0x8f8b8884
+0xb8c 0x9d999693
+0xb90 0xa9a6a3a0
+0xb94 0xb5b2afac
+0xb98 0x00810100
+0xb9c 0x00400056
+0xba0 0x002b0032
+0xba4 0x001f0024
+0xba8 0x0019001c
+0xbac 0x00150017
+0xbb0 0x00120013
+0xbb4 0x00100011
+0xbb8 0x000e000f
+0xbbc 0x000c000d
+0xbc0 0x000b000c
+0xbc4 0x000a000b
+0xbc8 0x0009000a
+0xbcc 0x00090009
+0xbd0 0x00080008
+0xbd4 0x00080008
+0xb6c 0x0fe00000
+//
+//=======================
+// PAGE_C ( OFDM_PHY0 )
+//=======================
+0xc00 0x48071d40  // initial gain @ CCA negedge 
+0xc04 0x03a05633  
+0xc08 0x000000e4  // [8:4] is about DBG_GPIO selection 
+0xc0c 0x6c6c6c6c 
+0xc10 0x08800000 
+0xc14 0x40000100
+0xc18 0x08800000
+0xc1c 0x40000100
+0xc20 0x00000000  // DTR TH
+0xc24 0x00000000  // DTR TH
+0xc28 0x00000000  // DTR TH
+0xc2c 0x00000000  // DTR TH
+0xc30 0x69e9ac4a  // PWED_TH option2=0x69e9bb44, 0x69e9ab44, 0x69e9ac44
+0xc34 0x469652cf   
+0xc38 0x49795994   
+0xc3c 0x0a979718  
+0xc40 0x1f7c403f  
+0xc44 0x000100b7  
+0xc48 0xec020107 //[1]=1:enable L1_SBD 
+0xc4c 0x007f037f // turn off edcca 
+0xc50 0x6954341e // AAGC=1,0x68043420, AAGC=2,0x69543420 
+0xc54 0x433c0094 
+0xc58 0x6954341e // AAGC=1,0x68043420, AAGC=2,0x69543420   
+0xc5c 0x433c0094
+0xc60 0x00000000 // DTR TH
+0xc64 0x5116848b //L1-SBD  //31168a8b for 6M sen. 0x5116828b, 0x5116848b
+0xc68 0x47c00bff //L1-SBD
+0xc6c 0x00000036 //L1-SBD
+0xc70 0x2c7f000d // disable AGC flow-1 
+0xc74 0x018610db // AGC RSSI setting time = 600nS.//0x0186109b=>RRSI=500ns,BBP=300ns for PI used, 0x0186175b
+0xc78 0x0000001f
+0xc7c 0x00b91612  
+0xc80 0x40000100 
+0xc84 0x20f60000 
+0xc88 0x40000100 
+0xc8c 0xa0e40000 //for MRC weighting function 
+0xc90 0x00000000 // TX Power Training for path-A	
+0xc94 0x00000000 	
+0xc98 0x00000000 // TX Power Training for path-B
+0xc9c 0x00007f7f // turn off pre-cca
+0xca0 0x00000000 
+0xca4 0x00000000 // reserved
+0xca8 0x00000000 // reserved
+0xcac 0x00000000 // reserved
+0xcb0 0x00000000 // reserved
+0xcb4 0x00000000 // reserved
+0xcb8 0x00000000 // reserved
+0xcbc 0x28000000
+0xcc0 0x00000000 // reserved
+0xcc4 0x00000000 // reserved
+0xcc8 0x00000000 // reserved
+0xccc 0x00000000 // reserved
+0xcd0 0x00000000 // reserved
+0xcd4 0x00000000 // reserved
+0xcd8 0x64b22427 // reserved
+0xcdc 0x00766932 // reserved
+0xce0 0x00222222  
+0xce4 0x00000000
+0xce8 0x37644302
+0xcec 0x2f97d40c
+//
+//=======================
+// PAGE_D ( OFDM_PHY1 )
+//=======================
+0xd00 0x00080740 
+0xd04 0x00020403  
+0xd08 0x0000907f  
+0xd0c 0x20010201 
+0xd10 0xa0633333  
+0xd14 0x3333bc43  
+0xd18 0x7a8f5b6b
+0xd2c 0xcc979975  
+0xd30 0x00000000
+0xd34 0x80608000
+0xd38 0x00000000
+0xd3c 0x00027293
+0xd40 0x00000000
+0xd44 0x00000000
+0xd48 0x00000000
+0xd4c 0x00000000
+0xd50 0x6437140a 
+0xd54 0x00000000 
+0xd58 0x00000000
+0xd5c 0x30032064 
+0xd60 0x4653de68
+0xd64 0x04518a3c //[26]=1:enable L1-SBD//
+0xd68 0x00002101
+0xd6c 0x2a201c16  // DTR
+0xd70 0x1812362e  // DTR
+0xd74 0x322c2220  // DTR
+0xd78 0x000e3c24  // DTR
+//=======================
+// PAGE_E
+//=======================
+0xe00 0x2b2b2b2b	// Path-A TX AGC codewod, 6M, 9M, 12M, 18M 
+0xe04 0x2b2b2b2b	// Path-A TX AGC codewod, 24M, 36M, 48M, 54M 
+0xe08 0x2b2b2b2b	// Path-A TX AGC codewod, MCS32, 1M 
+0xe10 0x2b2b2b2b	// Path-A TX AGC codewod, MCS0, MCS1, MCS2, MCS3 
+0xe14 0x2b2b2b2b	// Path-A TX AGC codewod, MCS4, MCS5, MCS6, MCS7 
+0xe18 0x2b2b2b2b	// Path-A TX AGC codewod, MCS8, MCS9, MCS10, MCS11 
+0xe1c 0x2b2b2b2b	// Path-A TX AGC codewod, MCS12, MCS13, MCS14, MCS15 
+0xe28 0x00000000        
+0xe30 0x1000dc1f	// 0xe30~0xe60: IQK
+0xe34 0x10008c1f
+0xe38 0x02140102
+0xe3C 0x681604c2
+0xe40 0x01007c00
+0xe44 0x01004800
+0xe48 0xfb000000
+0xe4c 0x000028d1
+0xe50 0x1000dc1f
+0xe54 0x10008c1f
+0xe58 0x02140102
+0xe5C 0x28160d05
+//0xe60 0x021400a0
+//0xe64 0x281600a0	// Reserved in 92C/88C
+0xe6c 0x63db25a4	// AFE ctrl reg (ASIC)  Blue-Tooth   
+0xe70 0x63db25a4	// AFE ctrl reg (ASIC)  RX_WAIT_CCA 
+0xe74 0x0c1b25a4	// AFE ctrl reg (ASIC)  TX_CCK_RFON
+0xe78 0x0c1b25a4	// AFE ctrl reg (ASIC)  TX_CCK_BBON
+0xe7c 0x0c1b25a4	// AFE ctrl reg (ASIC)  TX_OFDM_RFON
+0xe80 0x0c1b25a4	// AFE ctrl reg (ASIC)  TX_OFDM_BBON
+0xe84 0x63db25a4	// AFE ctrl reg (ASIC)  TX_TO_RX
+0xe88 0x0c1b25a4	// AFE ctrl reg (ASIC)  TX_TO_TX 
+0xe8c 0x63db25a4	// AFE ctrl reg (ASIC)  RX_CCK 
+0xed0 0x63db25a4	// AFE ctrl reg (ASIC)  RX_OFDM 
+0xed4 0x63db25a4	// AFE ctrl reg (ASIC)  RX_WAIT_RIFS 
+0xed8 0x63db25a4	// AFE ctrl reg (ASIC)  RX_TO_RX
+0xedc 0x001b25a4	// AFE ctrl reg (ASIC)  Standby 
+0xee0 0x001b25a4	// AFE ctrl reg (ASIC)  Sleep
+0xeec 0x6fdb25a4	// AFE ctrl reg (ASIC)  PMPD_ANAEN 
+//
+0xf14 0x00000003 // debug port selection. 0x0~0x3: PHY DBG, 0x4~0x5: MAC DBG
+0xf4c 0x00000000 // Only for FPGA PMAC
+0xf00 0x00000300 // enable BBRSTB, bcz HSSI use clk_bb
+0xff
diff --git a/drivers/net/wireless/rtl8192cd/data/PHY_REG_2T_n.txt b/drivers/net/wireless/rtl8192cd/data/PHY_REG_2T_n.txt
index 071ee61..fe7c6c6 100644
--- a/drivers/net/wireless/rtl8192cd/data/PHY_REG_2T_n.txt
+++ b/drivers/net/wireless/rtl8192cd/data/PHY_REG_2T_n.txt
@@ -1,219 +1,219 @@
-//100311
-//0x024 0x0011800f	//syn CLK enable
-//0x028 0x00ffdb83	//320MHz CLK enable
-0x028 0xffff83          //320MHz CLK enable, strong BB clock driving // tmp 40MHz solution
-//=======================
-// PAGE_8 ( FPGA_PHY0 )
-//=======================
-0x800 0x80040002 // turn off RF when 1R CCA 
-0x804 0x00000003
-0x808 0x0000fc00 
-0x80c 0x0000000A  
-0x810 0x10005388
-0x814 0x020c3d10 
-0x818 0x02200385 // [30:29] is DTR, Set off now. turn off RIFS: 0x00200185, turn on RIFS: 0x00200385
-0x81c 0x00000000 
-0x820 0x01000100 // 0x01000000 (SI), 0x01000100 (PI) 
-0x824 0x00390004 
-0x828 0x01000100 // 0x01000000 (SI), 0x01000100 (PI) 
-0x82c 0x00390004 
-0x830 0x27272727 // Path-B TX AGC codewod, 6M, 9M, 12M, 18M
-0x834 0x27272727  // Path-B TX AGC codewod, 24M, 36M, 48M, 54M
-0x838 0x27272727  // Path-B TX AGC codewod, MCS32, 1M, 2M, 5.5M
-0x83c 0x27272727  // Path-B TX AGC codewod, MCS0, MCS1, MCS2, MCS3
-0x840 0x00010000  //RF to standby mode
-0x844 0x00010000  //RF to standby mode   
-0x848 0x27272727  // Path-B TX AGC codewod, MCS4, MCS5, MCS6, MCS7
-0x84c 0x27272727  // Path-B TX AGC codewod, MCS8, MCS9, MCS10, MCS11
-0x850 0x00000000  // RF wakeup, TBD    
-0x854 0x00000000  // RF sleep, TBD
-0x858 0x569a569a 
-0x85c 0x0c1b25a4  // AFE ctrl reg (ASIC)  RX AD3 CCA mode
-0x860 0x66e60230  //88CE default left anatenna
-0x864 0x061f0130 
-0x868 0x27272727  // Path-B TX AGC codewod, MCS12, MCS13, MCS14, MCS15
-0x86c 0x2b2b2b27  // Path-A 11M/5.5M/2M TX AGC codeword, Path-B 11M TX AGC codeword
-0x870 0x07000700  // z2: 0x03000300, 92C RF: 0x07000700 (2 internal PA), 92S RF: 0x03000700 (one internal PA)
-0x874 0x22184000  //path B 1R RSSI off issue
-0x878 0x08080808  // RF mode for standby & rx_low_power codeword
-0x87c 0x00000000   // TST mode
-0x880 0xc0083070  // AFE ctrl reg (ASIC) 
-0x884 0x000004d5  // AFE ctrl reg (ASIC) 
-0x888 0x00000000  // AFE ctrl reg (ASIC) 
-0x88c 0xcc0000c0  // [10:1] is r_rdy_cnt for sleep/standby mode, [27],[31] are MCS_IND
-0x890 0x00000800
-0x894 0xfffffffe 
-0x898 0x40302010 
-0x89c 0x00706050 
-//
-//=======================
-// PAGE_9 ( FPGA_PHY1 )
-//=======================
-0x900 0x00000000
-0x904 0x00000023 
-0x908 0x00000000  
-0x90c 0x81121313 // tx antenna by contorl register
-//
-//=======================
-// PAGE_A ( CCK_PHY0 )
-//=======================
-0xa00 0x00d047c8
-0xa04 0x80ff000c
-0xa08 0x8c838300 // MP: 0x88838300, driver: 0x8ccd8300
-0xa0c 0x2e68120f
-0xa10 0x9500bb78 // 
-0xa14 0x11144028
-0xa18 0x00881117
-0xa1c 0x89140f00
-0xa20 0x1a1b0000 
-0xa24 0x090e1317 
-0xa28 0x00000204
-0xa2c 0x00d30000
-0xa70 0x101fbf00
-0xa74 0x00000007
-//
-//=======================
-// PAGE_B
-//=======================
-//
-//
-//=======================
-// PAGE_C ( OFDM_PHY0 )
-//=======================
-0xc00 0x48071d40
-0xc04 0x03a05633  
-0xc08 0x000000e4  // [8:4] is about DBG_GPIO selection 
-0xc0c 0x6c6c6c6c 
-0xc10 0x08800000 
-0xc14 0x40000100
-0xc18 0x08800000
-0xc1c 0x40000100
-0xc20 0x00000000  // DTR TH
-0xc24 0x00000000  // DTR TH
-0xc28 0x00000000  // DTR TH
-0xc2c 0x00000000  // DTR TH
-0xc30 0x69e9ac44  // PWED_TH option2=0x69e9bb44, 0x69e9ab44, 0x69e9ac44
-0xc34 0x469652cf   
-0xc38 0x49795994   
-0xc3c 0x0a97971c  
-0xc40 0x1f7c403f  
-0xc44 0x000100b7  
-0xc48 0xec020107 //[1]=1:enable L1_SBD 
-0xc4c 0x007f037f // turn off edcca 
-0xc50 0x69543420 // AAGC=1,0x68043420, AAGC=2,0x69543420 
-0xc54 0x43bc0094 
-0xc58 0x69543420 // AAGC=1,0x68043420, AAGC=2,0x69543420   
-0xc5c 0x433c0094
-0xc60 0x00000000 // DTR TH
-0xc64 0x5116848b //L1-SBD  //31168a8b for 6M sen. 0x5116828b, 0x5116848b
-0xc68 0x47c00bff //L1-SBD
-0xc6c 0x00000036 //L1-SBD
-0xc70 0x2c7f000d // disable AGC flow-1 
-0xc74 0x018610db // AGC RSSI setting time = 600nS.//0x0186109b=>RRSI=500ns,BBP=300ns for PI used, 0x0186175b
-0xc78 0x0000001f
-0xc7c 0x00b91612  
-0xc80 0x40000100 
-0xc84 0x20f60000 
-0xc88 0x40000100 
-0xc8c 0xa0e40000 //for MRC weighting function 
-0xc90 0x00121820 // TX Power Training for path-A	
-0xc94 0x00000000 	
-0xc98 0x00121820// TX Power Training for path-B
-0xc9c 0x00007f7f // turn off pre-cca
-0xca0 0x00000000 
-0xca4 0x00000080 // reserved
-0xca8 0x00000000 // reserved
-0xcac 0x00000000 // reserved
-0xcb0 0x00000000 // reserved
-0xcb4 0x00000000 // reserved
-0xcb8 0x00000000 // reserved
-0xcbc 0x28000000
-0xcc0 0x00000000 // reserved
-0xcc4 0x00000000 // reserved
-0xcc8 0x00000000 // reserved
-0xccc 0x00000000 // reserved
-0xcd0 0x00000000 // reserved
-0xcd4 0x00000000 // reserved
-0xcd8 0x64b22427 // reserved
-0xcdc 0x00766932 // reserved
-0xce0 0x00222222  
-0xce4 0x00000000
-0xce8 0x37644302
-0xcec 0x2f97d40c
-//
-//=======================
-// PAGE_D ( OFDM_PHY1 )
-//=======================
-0xd00 0x00080740 
-0xd04 0x00020403  
-0xd08 0x0000907f  
-0xd0c 0x20010201 
-0xd10 0xa0633333  
-0xd14 0x3333bc43  
-0xd18 0x7a8f5b6b
-0xd2c 0xcc979975  
-0xd30 0x00000000
-0xd34 0x80608000
-0xd38 0x00000000
-0xd3c 0x00027293
-0xd40 0x00000000
-0xd44 0x00000000
-0xd48 0x00000000
-0xd4c 0x00000000
-0xd50 0x6437140a 
-0xd54 0x00000000 
-0xd58 0x00000000
-0xd5c 0x30032064 
-0xd60 0x4653de68
-0xd64 0x04518a3c //[26]=1:enable L1-SBD//
-0xd68 0x00002101
-0xd6c 0x2a201c16  // DTR
-0xd70 0x1812362e  // DTR
-0xd74 0x322c2220  // DTR
-0xd78 0x000e3c24  // DTR
-//=======================
-// PAGE_E
-//=======================
-0xe00 0x2a2a2a2a	// Path-A TX AGC codewod, 6M, 9M, 12M, 18M 
-0xe04 0x2a2a2a2a	// Path-A TX AGC codewod, 24M, 36M, 48M, 54M 
-0xe08 0x03902a2a	// Path-A TX AGC codewod, MCS32, 1M 
-0xe10 0x2a2a2a2a	// Path-A TX AGC codewod, MCS0, MCS1, MCS2, MCS3 
-0xe14 0x2a2a2a2a	// Path-A TX AGC codewod, MCS4, MCS5, MCS6, MCS7 
-0xe18 0x2a2a2a2a	// Path-A TX AGC codewod, MCS8, MCS9, MCS10, MCS11 
-0xe1c 0x2a2a2a2a	// Path-A TX AGC codewod, MCS12, MCS13, MCS14, MCS15 
-0xe28 0x00000000        
-0xe30 0x1000dc1f	// 0xe30~0xe60: IQK
-0xe34 0x10008c1f
-0xe38 0x02140102
-0xe3C 0x681604c2
-0xe40 0x01007c00
-0xe44 0x01004800
-0xe48 0xfb000000
-0xe4c 0x000028d1
-0xe50 0x1000dc1f
-0xe54 0x10008c1f
-0xe58 0x02140102
-0xe5C 0x28160d05
-0xe60 0x00000010
-//0xe64 0x281600a0	// Reserved in 92C/88C
-0xe68 0x001b25a4
-0xe6c 0x63db25a4	// AFE ctrl reg (ASIC)  Blue-Tooth   
-0xe70 0x63db25a4	// AFE ctrl reg (ASIC)  RX_WAIT_CCA 
-0xe74 0x0c1b25a4	// AFE ctrl reg (ASIC)  TX_CCK_RFON
-0xe78 0x0c1b25a4	// AFE ctrl reg (ASIC)  TX_CCK_BBON
-0xe7c 0x0c1b25a4	// AFE ctrl reg (ASIC)  TX_OFDM_RFON
-0xe80 0x0c1b25a4	// AFE ctrl reg (ASIC)  TX_OFDM_BBON
-0xe84 0x63db25a4	// AFE ctrl reg (ASIC)  TX_TO_RX
-0xe88 0x0c1b25a4	// AFE ctrl reg (ASIC)  TX_TO_TX 
-0xe8c 0x63db25a4	// AFE ctrl reg (ASIC)  RX_CCK 
-0xed0 0x63db25a4	// AFE ctrl reg (ASIC)  RX_OFDM 
-0xed4 0x63db25a4	// AFE ctrl reg (ASIC)  RX_WAIT_RIFS 
-0xed8 0x63db25a4	// AFE ctrl reg (ASIC)  RX_TO_RX
-0xedc 0x001b25a4	// AFE ctrl reg (ASIC)  Standby 
-0xee0 0x001b25a4	// AFE ctrl reg (ASIC)  Sleep
-0xeec 0x6fdb25a4	// AFE ctrl reg (ASIC)  PMPD_ANAEN 
-//
-0xf14 0x00000003 // debug port selection. 0x0~0x3: PHY DBG, 0x4~0x5: MAC DBG
-0xf4c 0x00000000 // Only for FPGA PMAC
-0xf00 0x00000300 // enable BBRSTB, bcz HSSI use clk_bb
-0xff
+//100311
+//0x024 0x0011800f	//syn CLK enable
+//0x028 0x00ffdb83	//320MHz CLK enable
+0x028 0xffff83          //320MHz CLK enable, strong BB clock driving // tmp 40MHz solution
+//=======================
+// PAGE_8 ( FPGA_PHY0 )
+//=======================
+0x800 0x80040002 // turn off RF when 1R CCA 
+0x804 0x00000003
+0x808 0x0000fc00 
+0x80c 0x0000000A  
+0x810 0x10000330
+0x814 0x020c3d10 
+0x818 0x02200385 // [30:29] is DTR, Set off now. turn off RIFS: 0x00200185, turn on RIFS: 0x00200385
+0x81c 0x00000000 
+0x820 0x01000100 // 0x01000000 (SI), 0x01000100 (PI) 
+0x824 0x00390004 
+0x828 0x01000100 // 0x01000000 (SI), 0x01000100 (PI) 
+0x82c 0x00390004 
+0x830 0x27272727 // Path-B TX AGC codewod, 6M, 9M, 12M, 18M
+0x834 0x27272727  // Path-B TX AGC codewod, 24M, 36M, 48M, 54M
+0x838 0x27272727  // Path-B TX AGC codewod, MCS32, 1M, 2M, 5.5M
+0x83c 0x27272727  // Path-B TX AGC codewod, MCS0, MCS1, MCS2, MCS3
+0x840 0x00010000  //RF to standby mode
+0x844 0x00010000  //RF to standby mode   
+0x848 0x27272727  // Path-B TX AGC codewod, MCS4, MCS5, MCS6, MCS7
+0x84c 0x27272727  // Path-B TX AGC codewod, MCS8, MCS9, MCS10, MCS11
+0x850 0x00000000  // RF wakeup, TBD    
+0x854 0x00000000  // RF sleep, TBD
+0x858 0x569a569a 
+0x85c 0x0c1b25a4  // AFE ctrl reg (ASIC)  RX AD3 CCA mode
+0x860 0x66e60230  //88CE default left anatenna
+0x864 0x061f0130 
+0x868 0x27272727  // Path-B TX AGC codewod, MCS12, MCS13, MCS14, MCS15
+0x86c 0x2b2b2b27  // Path-A 11M/5.5M/2M TX AGC codeword, Path-B 11M TX AGC codeword
+0x870 0x07000700  // z2: 0x03000300, 92C RF: 0x07000700 (2 internal PA), 92S RF: 0x03000700 (one internal PA)
+0x874 0x22184000  //path B 1R RSSI off issue
+0x878 0x08080808  // RF mode for standby & rx_low_power codeword
+0x87c 0x00000000   // TST mode
+0x880 0xc0083070  // AFE ctrl reg (ASIC) 
+0x884 0x000004d5  // AFE ctrl reg (ASIC) 
+0x888 0x00000000  // AFE ctrl reg (ASIC) 
+0x88c 0xcc0000c0  // [10:1] is r_rdy_cnt for sleep/standby mode, [27],[31] are MCS_IND
+0x890 0x00000800
+0x894 0xfffffffe 
+0x898 0x40302010 
+0x89c 0x00706050 
+//
+//=======================
+// PAGE_9 ( FPGA_PHY1 )
+//=======================
+0x900 0x00000000
+0x904 0x00000023 
+0x908 0x00000000  
+0x90c 0x81121313 // tx antenna by contorl register
+//
+//=======================
+// PAGE_A ( CCK_PHY0 )
+//=======================
+0xa00 0x00d047c8
+0xa04 0x80ff000c
+0xa08 0x8c838300 // MP: 0x88838300, driver: 0x8ccd8300
+0xa0c 0x2e68120f
+0xa10 0x9500bb78 // 
+0xa14 0x11144028
+0xa18 0x00881117
+0xa1c 0x89140f00
+0xa20 0x1a1b0000 
+0xa24 0x090e1317 
+0xa28 0x00000204
+0xa2c 0x00d30000
+0xa70 0x101fbf00
+0xa74 0x00000007
+//
+//=======================
+// PAGE_B
+//=======================
+//
+//
+//=======================
+// PAGE_C ( OFDM_PHY0 )
+//=======================
+0xc00 0x48071d40
+0xc04 0x03a05633  
+0xc08 0x000000e4  // [8:4] is about DBG_GPIO selection 
+0xc0c 0x6c6c6c6c 
+0xc10 0x08800000 
+0xc14 0x40000100
+0xc18 0x08800000
+0xc1c 0x40000100
+0xc20 0x00000000  // DTR TH
+0xc24 0x00000000  // DTR TH
+0xc28 0x00000000  // DTR TH
+0xc2c 0x00000000  // DTR TH
+0xc30 0x69e9ac44  // PWED_TH option2=0x69e9bb44, 0x69e9ab44, 0x69e9ac44
+0xc34 0x469652cf   
+0xc38 0x49795994   
+0xc3c 0x0a97971c  
+0xc40 0x1f7c403f  
+0xc44 0x000100b7  
+0xc48 0xec020107 //[1]=1:enable L1_SBD 
+0xc4c 0x007f037f // turn off edcca 
+0xc50 0x69543420 // AAGC=1,0x68043420, AAGC=2,0x69543420 
+0xc54 0x43bc0094 
+0xc58 0x69543420 // AAGC=1,0x68043420, AAGC=2,0x69543420   
+0xc5c 0x433c0094
+0xc60 0x00000000 // DTR TH
+0xc64 0x5116848b //L1-SBD  //31168a8b for 6M sen. 0x5116828b, 0x5116848b
+0xc68 0x47c00bff //L1-SBD
+0xc6c 0x00000036 //L1-SBD
+0xc70 0x2c7f000d // disable AGC flow-1 
+0xc74 0x018610db // AGC RSSI setting time = 600nS.//0x0186109b=>RRSI=500ns,BBP=300ns for PI used, 0x0186175b
+0xc78 0x0000001f
+0xc7c 0x00b91612  
+0xc80 0x40000100 
+0xc84 0x20f60000 
+0xc88 0x40000100 
+0xc8c 0xa0e40000 //for MRC weighting function 
+0xc90 0x00121820 // TX Power Training for path-A	
+0xc94 0x00000000 	
+0xc98 0x00121820// TX Power Training for path-B
+0xc9c 0x00007f7f // turn off pre-cca
+0xca0 0x00000000 
+0xca4 0x00000080 // reserved
+0xca8 0x00000000 // reserved
+0xcac 0x00000000 // reserved
+0xcb0 0x00000000 // reserved
+0xcb4 0x00000000 // reserved
+0xcb8 0x00000000 // reserved
+0xcbc 0x28000000
+0xcc0 0x00000000 // reserved
+0xcc4 0x00000000 // reserved
+0xcc8 0x00000000 // reserved
+0xccc 0x00000000 // reserved
+0xcd0 0x00000000 // reserved
+0xcd4 0x00000000 // reserved
+0xcd8 0x64b22427 // reserved
+0xcdc 0x00766932 // reserved
+0xce0 0x00222222  
+0xce4 0x00000000
+0xce8 0x37644302
+0xcec 0x2f97d40c
+//
+//=======================
+// PAGE_D ( OFDM_PHY1 )
+//=======================
+0xd00 0x00080740 
+0xd04 0x00020403  
+0xd08 0x0000907f  
+0xd0c 0x20010201 
+0xd10 0xa0633333  
+0xd14 0x3333bc43  
+0xd18 0x7a8f5b6b
+0xd2c 0xcc979975  
+0xd30 0x00000000
+0xd34 0x80608000
+0xd38 0x00000000
+0xd3c 0x00027293
+0xd40 0x00000000
+0xd44 0x00000000
+0xd48 0x00000000
+0xd4c 0x00000000
+0xd50 0x6437140a 
+0xd54 0x00000000 
+0xd58 0x00000000
+0xd5c 0x30032064 
+0xd60 0x4653de68
+0xd64 0x04518a3c //[26]=1:enable L1-SBD//
+0xd68 0x00002101
+0xd6c 0x2a201c16  // DTR
+0xd70 0x1812362e  // DTR
+0xd74 0x322c2220  // DTR
+0xd78 0x000e3c24  // DTR
+//=======================
+// PAGE_E
+//=======================
+0xe00 0x2a2a2a2a	// Path-A TX AGC codewod, 6M, 9M, 12M, 18M 
+0xe04 0x2a2a2a2a	// Path-A TX AGC codewod, 24M, 36M, 48M, 54M 
+0xe08 0x03902a2a	// Path-A TX AGC codewod, MCS32, 1M 
+0xe10 0x2a2a2a2a	// Path-A TX AGC codewod, MCS0, MCS1, MCS2, MCS3 
+0xe14 0x2a2a2a2a	// Path-A TX AGC codewod, MCS4, MCS5, MCS6, MCS7 
+0xe18 0x2a2a2a2a	// Path-A TX AGC codewod, MCS8, MCS9, MCS10, MCS11 
+0xe1c 0x2a2a2a2a	// Path-A TX AGC codewod, MCS12, MCS13, MCS14, MCS15 
+0xe28 0x00000000        
+0xe30 0x1000dc1f	// 0xe30~0xe60: IQK
+0xe34 0x10008c1f
+0xe38 0x02140102
+0xe3C 0x681604c2
+0xe40 0x01007c00
+0xe44 0x01004800
+0xe48 0xfb000000
+0xe4c 0x000028d1
+0xe50 0x1000dc1f
+0xe54 0x10008c1f
+0xe58 0x02140102
+0xe5C 0x28160d05
+0xe60 0x00000010
+//0xe64 0x281600a0	// Reserved in 92C/88C
+0xe68 0x001b25a4
+0xe6c 0x63db25a4	// AFE ctrl reg (ASIC)  Blue-Tooth   
+0xe70 0x63db25a4	// AFE ctrl reg (ASIC)  RX_WAIT_CCA 
+0xe74 0x0c1b25a4	// AFE ctrl reg (ASIC)  TX_CCK_RFON
+0xe78 0x0c1b25a4	// AFE ctrl reg (ASIC)  TX_CCK_BBON
+0xe7c 0x0c1b25a4	// AFE ctrl reg (ASIC)  TX_OFDM_RFON
+0xe80 0x0c1b25a4	// AFE ctrl reg (ASIC)  TX_OFDM_BBON
+0xe84 0x63db25a4	// AFE ctrl reg (ASIC)  TX_TO_RX
+0xe88 0x0c1b25a4	// AFE ctrl reg (ASIC)  TX_TO_TX 
+0xe8c 0x63db25a4	// AFE ctrl reg (ASIC)  RX_CCK 
+0xed0 0x63db25a4	// AFE ctrl reg (ASIC)  RX_OFDM 
+0xed4 0x63db25a4	// AFE ctrl reg (ASIC)  RX_WAIT_RIFS 
+0xed8 0x63db25a4	// AFE ctrl reg (ASIC)  RX_TO_RX
+0xedc 0x001b25a4	// AFE ctrl reg (ASIC)  Standby 
+0xee0 0x001b25a4	// AFE ctrl reg (ASIC)  Sleep
+0xeec 0x6fdb25a4	// AFE ctrl reg (ASIC)  PMPD_ANAEN 
+//
+0xf14 0x00000003 // debug port selection. 0x0~0x3: PHY DBG, 0x4~0x5: MAC DBG
+0xf4c 0x00000000 // Only for FPGA PMAC
+0xf00 0x00000300 // enable BBRSTB, bcz HSSI use clk_bb
+0xff
diff --git a/drivers/net/wireless/rtl8192cd/data/PHY_REG_2T_n_hp.txt b/drivers/net/wireless/rtl8192cd/data/PHY_REG_2T_n_hp.txt
index dff75c4..3519315 100644
--- a/drivers/net/wireless/rtl8192cd/data/PHY_REG_2T_n_hp.txt
+++ b/drivers/net/wireless/rtl8192cd/data/PHY_REG_2T_n_hp.txt
@@ -1,220 +1,220 @@
-//100311
-//0x024 0x0011800f	//syn CLK enable
-//0x028 0x00ffdb83	//320MHz CLK enable
-0x028 0xffff83          //320MHz CLK enable, strong BB clock driving // tmp 40MHz solution
-//=======================
-// PAGE_8 ( FPGA_PHY0 )
-//=======================
-0x800 0x80040002 // turn off RF when 1R CCA 
-0x804 0x00000003
-0x808 0x0000fc00 
-0x80c 0x0000000A  
-0x810 0x10005388
-0x814 0x020c3d10 
-0x818 0x02200385 // [30:29] is DTR, Set off now. turn off RIFS: 0x00200185, turn on RIFS: 0x00200385
-0x81c 0x00000000 
-0x820 0x01000100 // 0x01000000 (SI), 0x01000100 (PI) 
-0x824 0x00390204 // jerry- for CCK Rx path A dynamic range
-0x828 0x01000100 // 0x01000000 (SI), 0x01000100 (PI) 
-0x82c 0x00390204 // jerry- for CCK Rx path B dynamic range
-0x830 0x24242424 // Path-B TX AGC codewod, 6M, 9M, 12M, 18M
-0x834 0x24242424  // Path-B TX AGC codewod, 24M, 36M, 48M, 54M
-0x838 0x20202024  // Path-B TX AGC codewod, MCS32, 1M, 2M, 5.5M
-0x83c 0x24242424  // Path-B TX AGC codewod, MCS0, MCS1, MCS2, MCS3
-0x840 0x00010000  //RF to standby mode
-0x844 0x00010000  //RF to standby mode   
-0x848 0x24242424  // Path-B TX AGC codewod, MCS4, MCS5, MCS6, MCS7
-0x84c 0x24242424  // Path-B TX AGC codewod, MCS8, MCS9, MCS10, MCS11
-0x850 0x00000000  // RF wakeup, TBD    
-0x854 0x00000000  // RF sleep, TBD
-0x858 0x569a569a 
-0x85c 0x0c1b25a4  // AFE ctrl reg (ASIC)  RX AD3 CCA mode
-0x860 0x66e60230  //88CE default left anatenna
-0x864 0x061f0130 
-0x868 0x24242424  // Path-B TX AGC codewod, MCS12, MCS13, MCS14, MCS15
-0x86c 0x20202020  // Path-A 11M/5.5M/2M TX AGC codeword, Path-B 11M TX AGC codeword
-0x870 0x03000300  // z2: 0x03000300, 92C RF: 0x07000700 (2 internal PA), 92S RF: 0x03000700 (one internal PA)
-0x874 0x22184000  //path B 1R RSSI off issue
-0x878 0x08080808  // RF mode for standby & rx_low_power codeword
-0x87c 0x00ffc3f1  // TST mode 0x00000000 
-0x880 0xc0083070  // AFE ctrl reg (ASIC) 
-0x884 0x000004d5  // AFE ctrl reg (ASIC) 
-0x888 0x00000000  // AFE ctrl reg (ASIC) 
-0x88c 0xcc0000c0  // [10:1] is r_rdy_cnt for sleep/standby mode, [27],[31] are MCS_IND
-0x890 0x00000800
-0x894 0xfffffffe 
-0x898 0x40302010 
-0x89c 0x00706050 
-//
-//=======================
-// PAGE_9 ( FPGA_PHY1 )
-//=======================
-0x900 0x00000000
-0x904 0x00000023 
-0x908 0x00000000  
-0x90c 0x81121313 // tx antenna by contorl register
-//
-//=======================
-// PAGE_A ( CCK_PHY0 )
-//=======================
-0xa00 0x00d047c8
-0xa04 0x80ff000c
-0xa08 0x8c838300 // MP: 0x88838300, driver: 0x8ccd8300
-0xa0c 0x2e68120f
-0xa10 0x9500bb78 // 
-0xa14 0x11144028
-0xa18 0x00881117
-0xa1c 0x89140f00
-0xa20 0x15160000 //Arthur-power tracking for high-power
-0xa24 0x070b0f12 //Arthur-power tracking for high-power
-0xa28 0x00000104 //Arthur-power tracking for high-power
-0xa2c 0x00d30000
-0xa70 0x101fbf00
-0xa74 0x00000007
-//
-//=======================
-// PAGE_B
-//=======================
-//
-//
-//=======================
-// PAGE_C ( OFDM_PHY0 )
-//=======================
-0xc00 0x48071d40
-0xc04 0x03a05633  
-0xc08 0x000000e4  // [8:4] is about DBG_GPIO selection 
-0xc0c 0x6c6c6c6c 
-0xc10 0x08800000 
-0xc14 0x40000100
-0xc18 0x08800000
-0xc1c 0x40000100
-0xc20 0x00000000  // DTR TH
-0xc24 0x00000000  // DTR TH
-0xc28 0x00000000  // DTR TH
-0xc2c 0x00000000  // DTR TH
-0xc30 0x69e9ac44  // PWED_TH option2=0x69e9bb44, 0x69e9ab44, 0x69e9ac44
-0xc34 0x469652cf   
-0xc38 0x49795994   
-0xc3c 0x0a97971c  
-0xc40 0x1f7c403f  
-0xc44 0x000100b7  
-0xc48 0xec020107 //[1]=1:enable L1_SBD 
-0xc4c 0x007f037f // turn off edcca 
-0xc50 0x6954342e // AAGC=1,0x68043420, AAGC=2,0x69543420, 0x6954342e for external LNA 
-0xc54 0x43bc0094 
-0xc58 0x6954342e // AAGC=1,0x68043420, AAGC=2,0x69543420, 0x6954342e for external LNA   
-0xc5c 0x433c0094
-0xc60 0x00000000 // DTR TH
-0xc64 0x5116848b //L1-SBD  //31168a8b for 6M sen. 0x5116828b, 0x5116848b
-0xc68 0x47c00bff //L1-SBD
-0xc6c 0x00000036 //L1-SBD
-0xc70 0x2c56000d // disable AGC flow-1, 0x2c56000d for external LAN during high input power
-0xc74 0x018610db // AGC RSSI setting time = 600nS.//0x0186109b=>RRSI=500ns,BBP=300ns for PI used, 0x0186175b
-0xc78 0x0000001f
-0xc7c 0x00b91612  
-0xc80 0x24000090 //Arthur-power tracking for high-power 
-0xc84 0x20f60000 
-0xc88 0x24000090 //Arthur-power tracking for high-power
-0xc8c 0xa0e40000 //for MRC weighting function 
-0xc90 0x00121820 // TX Power Training for path-A	
-0xc94 0x00000000 	
-0xc98 0x00121820// TX Power Training for path-B
-0xc9c 0x00007f7f // turn off pre-cca
-0xca0 0x00000000 
-0xca4 0x00000080 // reserved
-0xca8 0x00000000 // reserved
-0xcac 0x00000000 // reserved
-0xcb0 0x00000000 // reserved
-0xcb4 0x00000000 // reserved
-0xcb8 0x00000000 // reserved
-0xcbc 0x28000000
-0xcc0 0x00000000 // reserved
-0xcc4 0x00000000 // reserved
-0xcc8 0x00000000 // reserved
-0xccc 0x00000000 // reserved
-0xcd0 0x00000000 // reserved
-0xcd4 0x00000000 // reserved
-0xcd8 0x64b22427 // reserved
-0xcdc 0x00766932 // reserved
-0xce0 0x00222222  
-0xce4 0x00000000
-0xce8 0x37644302
-0xcec 0x2f97d40c
-//
-//=======================
-// PAGE_D ( OFDM_PHY1 )
-//=======================
-0xd00 0x00080740 
-0xd04 0x00020403  
-0xd08 0x0000907f  
-0xd0c 0x20010201 
-0xd10 0xa0633333  
-0xd14 0x3333bc43  
-0xd18 0x7a8f5b6b
-0xd2c 0xcc979975  
-0xd30 0x00000000
-0xd34 0x80608000
-0xd38 0x00000000
-0xd3c 0x00027293
-0xd40 0x00000000
-0xd44 0x00000000
-0xd48 0x00000000
-0xd4c 0x00000000
-0xd50 0x6437140a 
-0xd54 0x00000000 
-0xd58 0x00000000
-0xd5c 0x30032064 
-0xd60 0x4653de68
-0xd64 0x04518a3c //[26]=1:enable L1-SBD//
-0xd68 0x00002101
-0xd6c 0x2a201c16  // DTR
-0xd70 0x1812362e  // DTR
-0xd74 0x322c2220  // DTR
-0xd78 0x000e3c24  // DTR
-//=======================
-// PAGE_E
-//=======================
-0xe00 0x24242424	// Path-A TX AGC codewod, 6M, 9M, 12M, 18M 
-0xe04 0x24242424	// Path-A TX AGC codewod, 24M, 36M, 48M, 54M 
-0xe08 0x03902024	// Path-A TX AGC codewod, MCS32, 1M 
-0xe10 0x24242424	// Path-A TX AGC codewod, MCS0, MCS1, MCS2, MCS3 
-0xe14 0x24242424	// Path-A TX AGC codewod, MCS4, MCS5, MCS6, MCS7 
-0xe18 0x24242424	// Path-A TX AGC codewod, MCS8, MCS9, MCS10, MCS11 
-0xe1c 0x24242424	// Path-A TX AGC codewod, MCS12, MCS13, MCS14, MCS15 
-0xe28 0x00000000        
-0xe30 0x1000dc1f	// 0xe30~0xe60: IQK
-0xe34 0x10008c1f
-0xe38 0x02140102
-0xe3C 0x681604c2
-0xe40 0x01007c00
-0xe44 0x01004800
-0xe48 0xfb000000
-0xe4c 0x000028d1
-0xe50 0x1000dc1f
-0xe54 0x10008c1f
-0xe58 0x02140102
-0xe5C 0x28160d05
-0xe60 0x00000010
-//0xe64 0x281600a0	// Reserved in 92C/88C
-0xe68 0x001b25a4
-0xe6c 0x63db25a4	// AFE ctrl reg (ASIC)  Blue-Tooth   
-0xe70 0x63db25a4	// AFE ctrl reg (ASIC)  RX_WAIT_CCA 
-0xe74 0x0c1b25a4	// AFE ctrl reg (ASIC)  TX_CCK_RFON
-0xe78 0x0c1b25a4	// AFE ctrl reg (ASIC)  TX_CCK_BBON
-0xe7c 0x0c1b25a4	// AFE ctrl reg (ASIC)  TX_OFDM_RFON
-0xe80 0x0c1b25a4	// AFE ctrl reg (ASIC)  TX_OFDM_BBON
-0xe84 0x63db25a4	// AFE ctrl reg (ASIC)  TX_TO_RX
-0xe88 0x0c1b25a4	// AFE ctrl reg (ASIC)  TX_TO_TX 
-0xe8c 0x63db25a4	// AFE ctrl reg (ASIC)  RX_CCK 
-0xed0 0x63db25a4	// AFE ctrl reg (ASIC)  RX_OFDM 
-0xed4 0x63db25a4	// AFE ctrl reg (ASIC)  RX_WAIT_RIFS 
-0xed8 0x63db25a4	// AFE ctrl reg (ASIC)  RX_TO_RX
-0xedc 0x001b25a4	// AFE ctrl reg (ASIC)  Standby 
-0xee0 0x001b25a4	// AFE ctrl reg (ASIC)  Sleep
-0xeec 0x6fdb25a4	// AFE ctrl reg (ASIC)  PMPD_ANAEN
-0xee8 0x31555448  // Authur-enable PAPE 
-//
-0xf14 0x00000003 // debug port selection. 0x0~0x3: PHY DBG, 0x4~0x5: MAC DBG
-0xf4c 0x00000000 // Only for FPGA PMAC
-0xf00 0x00000300 // enable BBRSTB, bcz HSSI use clk_bb
-0xff
+//100311
+//0x024 0x0011800f	//syn CLK enable
+//0x028 0x00ffdb83	//320MHz CLK enable
+0x028 0xffff83          //320MHz CLK enable, strong BB clock driving // tmp 40MHz solution
+//=======================
+// PAGE_8 ( FPGA_PHY0 )
+//=======================
+0x800 0x80040002 // turn off RF when 1R CCA 
+0x804 0x00000003
+0x808 0x0000fc00 
+0x80c 0x0000000A  
+0x810 0x10005388
+0x814 0x020c3d10 
+0x818 0x02200385 // [30:29] is DTR, Set off now. turn off RIFS: 0x00200185, turn on RIFS: 0x00200385
+0x81c 0x00000000 
+0x820 0x01000100 // 0x01000000 (SI), 0x01000100 (PI) 
+0x824 0x00390204 // jerry- for CCK Rx path A dynamic range
+0x828 0x01000100 // 0x01000000 (SI), 0x01000100 (PI) 
+0x82c 0x00390204 // jerry- for CCK Rx path B dynamic range
+0x830 0x24242424 // Path-B TX AGC codewod, 6M, 9M, 12M, 18M
+0x834 0x24242424  // Path-B TX AGC codewod, 24M, 36M, 48M, 54M
+0x838 0x20202024  // Path-B TX AGC codewod, MCS32, 1M, 2M, 5.5M
+0x83c 0x24242424  // Path-B TX AGC codewod, MCS0, MCS1, MCS2, MCS3
+0x840 0x00010000  //RF to standby mode
+0x844 0x00010000  //RF to standby mode   
+0x848 0x24242424  // Path-B TX AGC codewod, MCS4, MCS5, MCS6, MCS7
+0x84c 0x24242424  // Path-B TX AGC codewod, MCS8, MCS9, MCS10, MCS11
+0x850 0x00000000  // RF wakeup, TBD    
+0x854 0x00000000  // RF sleep, TBD
+0x858 0x569a569a 
+0x85c 0x0c1b25a4  // AFE ctrl reg (ASIC)  RX AD3 CCA mode
+0x860 0x66e60230  //88CE default left anatenna
+0x864 0x061f0130 
+0x868 0x24242424  // Path-B TX AGC codewod, MCS12, MCS13, MCS14, MCS15
+0x86c 0x20202020  // Path-A 11M/5.5M/2M TX AGC codeword, Path-B 11M TX AGC codeword
+0x870 0x03000300  // z2: 0x03000300, 92C RF: 0x07000700 (2 internal PA), 92S RF: 0x03000700 (one internal PA)
+0x874 0x22184000  //path B 1R RSSI off issue
+0x878 0x08080808  // RF mode for standby & rx_low_power codeword
+0x87c 0x00ffc3f1  // TST mode 0x00000000 
+0x880 0xc0083070  // AFE ctrl reg (ASIC) 
+0x884 0x000004d5  // AFE ctrl reg (ASIC) 
+0x888 0x00000000  // AFE ctrl reg (ASIC) 
+0x88c 0xcc0000c0  // [10:1] is r_rdy_cnt for sleep/standby mode, [27],[31] are MCS_IND
+0x890 0x00000800
+0x894 0xfffffffe 
+0x898 0x40302010 
+0x89c 0x00706050 
+//
+//=======================
+// PAGE_9 ( FPGA_PHY1 )
+//=======================
+0x900 0x00000000
+0x904 0x00000023 
+0x908 0x00000000  
+0x90c 0x81121313 // tx antenna by contorl register
+//
+//=======================
+// PAGE_A ( CCK_PHY0 )
+//=======================
+0xa00 0x00d047c8
+0xa04 0x80ff000c
+0xa08 0x8c838300 // MP: 0x88838300, driver: 0x8ccd8300
+0xa0c 0x2e6b120f // Arthur+BS 11.12.20 fix, original is 0x2e68120f
+0xa10 0x9500bb78 // 
+0xa14 0x11144028
+0xa18 0x00881117
+0xa1c 0x89140f00
+0xa20 0x15160000 //Arthur-power tracking for high-power
+0xa24 0x070b0f12 //Arthur-power tracking for high-power
+0xa28 0x00000104 //Arthur-power tracking for high-power
+0xa2c 0x00d30000
+0xa70 0x101fbf00
+0xa74 0x00000007
+//
+//=======================
+// PAGE_B
+//=======================
+//
+//
+//=======================
+// PAGE_C ( OFDM_PHY0 )
+//=======================
+0xc00 0x48071d40
+0xc04 0x03a05633  
+0xc08 0x000000e4  // [8:4] is about DBG_GPIO selection 
+0xc0c 0x6c6c6c6c 
+0xc10 0x08800000 
+0xc14 0x40000100
+0xc18 0x08800000
+0xc1c 0x40000100
+0xc20 0x00000000  // DTR TH
+0xc24 0x00000000  // DTR TH
+0xc28 0x00000000  // DTR TH
+0xc2c 0x00000000  // DTR TH
+0xc30 0x69e9ac44  // PWED_TH option2=0x69e9bb44, 0x69e9ab44, 0x69e9ac44
+0xc34 0x469652cf   
+0xc38 0x49795994   
+0xc3c 0x0a97971c  
+0xc40 0x1f7c403f  
+0xc44 0x000100b7  
+0xc48 0xec020107 //[1]=1:enable L1_SBD 
+0xc4c 0x007f037f // turn off edcca 
+0xc50 0x6954342e // AAGC=1,0x68043420, AAGC=2,0x69543420, 0x6954342e for external LNA 
+0xc54 0x43bc0094 
+0xc58 0x6954342e // AAGC=1,0x68043420, AAGC=2,0x69543420, 0x6954342e for external LNA   
+0xc5c 0x433c0094
+0xc60 0x00000000 // DTR TH
+0xc64 0x5116848b //L1-SBD  //31168a8b for 6M sen. 0x5116828b, 0x5116848b
+0xc68 0x47c00bff //L1-SBD
+0xc6c 0x00000036 //L1-SBD
+0xc70 0x2c56000d // disable AGC flow-1, 0x2c56000d for external LAN during high input power
+0xc74 0x018610db // AGC RSSI setting time = 600nS.//0x0186109b=>RRSI=500ns,BBP=300ns for PI used, 0x0186175b
+0xc78 0x0000001f
+0xc7c 0x00b91612  
+0xc80 0x24000090 //Arthur-power tracking for high-power 
+0xc84 0x20f60000 
+0xc88 0x24000090 //Arthur-power tracking for high-power
+0xc8c 0xa0e40000 // for MRC weighting function 
+0xc90 0x00121820 // TX Power Training for path-A	
+0xc94 0x00000000 	
+0xc98 0x00121820// TX Power Training for path-B
+0xc9c 0x00007f7f // turn off pre-cca
+0xca0 0x00000000 
+0xca4 0x00000080 // reserved
+0xca8 0x00000000 // reserved
+0xcac 0x00000000 // reserved
+0xcb0 0x00000000 // reserved
+0xcb4 0x00000000 // reserved
+0xcb8 0x00000000 // reserved
+0xcbc 0x28000000
+0xcc0 0x00000000 // reserved
+0xcc4 0x00000000 // reserved
+0xcc8 0x00000000 // reserved
+0xccc 0x00000000 // reserved
+0xcd0 0x00000000 // reserved
+0xcd4 0x00000000 // reserved
+0xcd8 0x64b22427 // reserved
+0xcdc 0x00766932 // reserved
+0xce0 0x00222222  
+0xce4 0x00000000
+0xce8 0x37644302
+0xcec 0x2f97d40c
+//
+//=======================
+// PAGE_D ( OFDM_PHY1 )
+//=======================
+0xd00 0x00080740 
+0xd04 0x00020403  
+0xd08 0x0000907f  
+0xd0c 0x20010201 
+0xd10 0xa0633333  
+0xd14 0x3333bc43  
+0xd18 0x7a8f5b6b
+0xd2c 0xcc979975  
+0xd30 0x00000000
+0xd34 0x80608000
+0xd38 0x00000000
+0xd3c 0x00027293
+0xd40 0x00000000
+0xd44 0x00000000
+0xd48 0x00000000
+0xd4c 0x00000000
+0xd50 0x6437140a 
+0xd54 0x00000000 
+0xd58 0x00000000
+0xd5c 0x30032064 
+0xd60 0x4653de68
+0xd64 0x04518a3c //[26]=1:enable L1-SBD//
+0xd68 0x00002101
+0xd6c 0x2a201c16  // DTR
+0xd70 0x1812362e  // DTR
+0xd74 0x322c2220  // DTR
+0xd78 0x000e3c24  // DTR
+//=======================
+// PAGE_E
+//=======================
+0xe00 0x24242424	// Path-A TX AGC codewod, 6M, 9M, 12M, 18M 
+0xe04 0x24242424	// Path-A TX AGC codewod, 24M, 36M, 48M, 54M 
+0xe08 0x03902024	// Path-A TX AGC codewod, MCS32, 1M 
+0xe10 0x24242424	// Path-A TX AGC codewod, MCS0, MCS1, MCS2, MCS3 
+0xe14 0x24242424	// Path-A TX AGC codewod, MCS4, MCS5, MCS6, MCS7 
+0xe18 0x24242424	// Path-A TX AGC codewod, MCS8, MCS9, MCS10, MCS11 
+0xe1c 0x24242424	// Path-A TX AGC codewod, MCS12, MCS13, MCS14, MCS15 
+0xe28 0x00000000        
+0xe30 0x1000dc1f	// 0xe30~0xe60: IQK
+0xe34 0x10008c1f
+0xe38 0x02140102
+0xe3C 0x681604c2
+0xe40 0x01007c00
+0xe44 0x01004800
+0xe48 0xfb000000
+0xe4c 0x000028d1
+0xe50 0x1000dc1f
+0xe54 0x10008c1f
+0xe58 0x02140102
+0xe5C 0x28160d05
+0xe60 0x00000010
+//0xe64 0x281600a0	// Reserved in 92C/88C
+0xe68 0x001b25a4
+0xe6c 0x63db25a4	// AFE ctrl reg (ASIC)  Blue-Tooth   
+0xe70 0x63db25a4	// AFE ctrl reg (ASIC)  RX_WAIT_CCA 
+0xe74 0x0c1b25a4	// AFE ctrl reg (ASIC)  TX_CCK_RFON
+0xe78 0x0c1b25a4	// AFE ctrl reg (ASIC)  TX_CCK_BBON
+0xe7c 0x0c1b25a4	// AFE ctrl reg (ASIC)  TX_OFDM_RFON
+0xe80 0x0c1b25a4	// AFE ctrl reg (ASIC)  TX_OFDM_BBON
+0xe84 0x63db25a4	// AFE ctrl reg (ASIC)  TX_TO_RX
+0xe88 0x0c1b25a4	// AFE ctrl reg (ASIC)  TX_TO_TX 
+0xe8c 0x63db25a4	// AFE ctrl reg (ASIC)  RX_CCK 
+0xed0 0x63db25a4	// AFE ctrl reg (ASIC)  RX_OFDM 
+0xed4 0x63db25a4	// AFE ctrl reg (ASIC)  RX_WAIT_RIFS 
+0xed8 0x63db25a4	// AFE ctrl reg (ASIC)  RX_TO_RX
+0xedc 0x001b25a4	// AFE ctrl reg (ASIC)  Standby 
+0xee0 0x001b25a4	// AFE ctrl reg (ASIC)  Sleep
+0xeec 0x6fdb25a4	// AFE ctrl reg (ASIC)  PMPD_ANAEN
+0xee8 0x31555448  // Authur-enable PAPE 
+//
+0xf14 0x00000003 // debug port selection. 0x0~0x3: PHY DBG, 0x4~0x5: MAC DBG
+0xf4c 0x00000000 // Only for FPGA PMAC
+0xf00 0x00000300 // enable BBRSTB, bcz HSSI use clk_bb
+0xff
diff --git a/drivers/net/wireless/rtl8192cd/data/radio_a_2T_n_hp.txt b/drivers/net/wireless/rtl8192cd/data/radio_a_2T_n_hp.txt
index 55bd298..6128eb9 100644
--- a/drivers/net/wireless/rtl8192cd/data/radio_a_2T_n_hp.txt
+++ b/drivers/net/wireless/rtl8192cd/data/radio_a_2T_n_hp.txt
@@ -1,157 +1,157 @@
-//100701
-////////////////////////
-//0x26  OFDM    CCK
-//      0x4f000 0xf400
-////////////////////////
-0x00 0x30159	//RX mode
-0x01 0x31284	//TRX IQGEN Current
-0x02 0x98000	//TX IQGEN Current
-0x03 0x18c63
-0x04 0x210e7
-0X09 0X2044f
-0x0a 0x1adb1
-0x0b 0x54867
-0x0c 0x8992e
-0x0d 0x0e529  //jerry-low gain for ext.PA
-0x0e 0x39ce7
-0x0f 0x00451
-0x19 0x00000
-0x1a 0x00255    //12255 //jerry-0x00255 for high power CCK ACPR  
-0x1b 0x60a00	//RSSI
-0x1c 0xfc378	//Alex 0xfc300
-0x1d 0xa1250
-0x1e 0x4445f	//RC calibration power on
-0x1f 0x80001	//RC calibration power on
-0x20 0x0b614
-0x21 0x6c000	//idac poweron
-0x22 0x0083c  //Arthur-adjust PAPE voltage
-0x23 0x01558  
-0x24 0x00060	// enabile temp meter
-0x25 0x00483   //0x00583 //0x00483 for unlock issue
-0x26 0x4f000	
-0x27 0xec7d9  //0x27 0xcc799
-0x28 0x577c0  //0x28 0x59540
-0x29 0x04783
-0x2a 0x00001  
-0x2b 0x21334
-//Fractional-N table
-0x2a 0x00000
-0x2b 0x00054
-0x2a 0x00001
-0x2b 0x00808
-0x2b 0x53333
-0x2c 0x0000c
-0x2a 0x00002
-0x2b 0x00808
-0x2b 0x5b333
-0x2c 0x0000d
-0x2a 0x00003
-0x2b 0x00808
-0x2b 0x63333
-0x2c 0x0000d
-0x2a 0x00004
-0x2b 0x00808
-0x2b 0x6b333
-0x2c 0x0000d
-0x2a 0x00005
-0x2b 0x00808
-0x2b 0x73333
-0x2c 0x0000d
-0x2a 0x00006
-0x2b 0x00709
-0x2b 0x5b333
-0x2c 0x0000d
-0x2a 0x00007
-0x2b 0x00709
-0x2b 0x63333
-0x2c 0x0000d
-0x2a 0x00008
-0x2b 0x0060a
-0x2b 0x4b333
-0x2c 0x0000d
-0x2a 0x00009
-0x2b 0x0060a
-0x2b 0x53333
-0x2c 0x0000d
-0x2a 0x0000a
-0x2b 0x0060a
-0x2b 0x5b333
-0x2c 0x0000d
-0x2a 0x0000b
-0x2b 0x0060a
-0x2b 0x63333
-0x2c 0x0000d
-0x2a 0x0000c
-0x2b 0x0060a
-0x2b 0x6b333
-0x2c 0x0000d
-0x2a 0x0000d
-0x2b 0x0060a
-0x2b 0x73333
-0x2c 0x0000d
-0x2a 0x0000e
-0x2b 0x0050b
-0x2b 0x66666	//Alex 0x66623
-0x2c 0x0001a
-0x2a 0xe0000  //0x60000 for 1M spurs
-//RF mode table
-0x10 0x4000f	//TX IQ K 
-0x11 0xe31fc	//Alex_0x231fc	//turn on PAD2       
-0x10 0x6000f	//RX IQ K 
-0x11 0xff9f8	//Alex 0x3f9f8	//turn on RXBB BFAC  
-0x10 0x2000f	//TX Mode
-0x11 0x203f9	// turn on rf tssi
-0x10 0x3000f	//Alex RX mode
-0x11 0xff500	//Alex RX mode
-//0x10 0x1000f    //standbt mode
-//0x11 0x20103    //RF lpbk switches on if at APK mode
-0x10 0x00000	//Alex shut down mode
-0x11 0x00000	//Alex shut down mode
-0x10 0x8000f	//Alex low power RX mode
-0x11 0x3f100	// Alex low power RX mode
-0x10 0x9000f	//Alex low power idle mode
-0x11 0x23100	//Alex power idle mode
-//RXAGC_RXHP table - jerry for ACPR
-0x12 0xd8000    //0x32000; d4000
-0x12 0x90000    //0x71000; 90000
-0x12 0x51000    //0xb0000; 51000
-0x12 0x12000    //0xfc000; 12000
-//TX gain table - Arthur
-0x13 0x24fa8    //jerry-old 0x28fb4
-0x13 0x24fa8
-0x13 0x207a4
-0x13 0x1c3b0    //0x1c3b0 for 39-40 nonlinear issue
-0x13 0x183a4
-0x13 0x14398
-0x13 0x101a4
-0x13 0x0c198
-0x13 0x080a4
-0x13 0x04098
-0x13 0x00014
-//BIAS table
-0x14 0x1944c
-0x14 0x59444
-0x14 0x9944c
-0x14 0xd9444
-//IPA bias table
-0x15 0x0f424
-0x15 0x4f424
-0x15 0x8f424
-0x15 0xcf424
-//TX table II
-0x16 0xe0330 //High gain
-0x16 0xa0330 //middle gain
-0x16 0x60330 //low gain
-0x16 0x20330 //ultra low gain
-0x00 0x10159 //standby mode
-0x18 0x0f401  //LC calibration
-0xfe // delay 50ms
-0xfe // delay 50ms
-0x1f 0x80003  //RC calibration
-0xfe // delay 50ms
-0xfe // delay 50ms
-0x1e 0x44457
-0x1f 0x80000
-0x00 0x30159 //RX mode
-0xff 0xffff
-
+//100701
+////////////////////////
+//0x26  OFDM    CCK
+//      0x4f000 0xf400
+////////////////////////
+0x00 0x30159	//RX mode
+0x01 0x31284	//TRX IQGEN Current
+0x02 0x98000	//TX IQGEN Current
+0x03 0x18c63
+0x04 0x210e7
+0X09 0X2044f
+0x0a 0x1adb1
+0x0b 0x54867
+0x0c 0x8992e
+0x0d 0x0e529  //jerry-low gain for ext.PA
+0x0e 0x39ce7
+0x0f 0x00451
+0x19 0x00000
+0x1a 0x00255    //12255 //jerry-0x00255 for high power CCK ACPR  
+0x1b 0x60a00	//RSSI
+0x1c 0xfc378	//Alex 0xfc300
+0x1d 0xa1250
+0x1e 0x4445f	//RC calibration power on
+0x1f 0x80001	//RC calibration power on
+0x20 0x0b614
+0x21 0x6c000	//idac poweron
+0x22 0x0083c  //Arthur-adjust PAPE voltage
+0x23 0x01558  
+0x24 0x00060	// enabile temp meter
+0x25 0x00483   //0x00583 //0x00483 for unlock issue
+0x26 0x4f000	
+0x27 0xec7d9  //0x27 0xcc799
+0x28 0x577c0  //0x28 0x59540
+0x29 0x04783
+0x2a 0x00001  
+0x2b 0x21334
+//Fractional-N table
+0x2a 0x00000
+0x2b 0x00054
+0x2a 0x00001
+0x2b 0x00808
+0x2b 0x53333
+0x2c 0x0000c
+0x2a 0x00002
+0x2b 0x00808
+0x2b 0x5b333
+0x2c 0x0000d
+0x2a 0x00003
+0x2b 0x00808
+0x2b 0x63333
+0x2c 0x0000d
+0x2a 0x00004
+0x2b 0x00808
+0x2b 0x6b333
+0x2c 0x0000d
+0x2a 0x00005
+0x2b 0x00808
+0x2b 0x73333
+0x2c 0x0000d
+0x2a 0x00006
+0x2b 0x00709
+0x2b 0x5b333
+0x2c 0x0000d
+0x2a 0x00007
+0x2b 0x00709
+0x2b 0x63333
+0x2c 0x0000d
+0x2a 0x00008
+0x2b 0x0060a
+0x2b 0x4b333
+0x2c 0x0000d
+0x2a 0x00009
+0x2b 0x0060a
+0x2b 0x53333
+0x2c 0x0000d
+0x2a 0x0000a
+0x2b 0x0060a
+0x2b 0x5b333
+0x2c 0x0000d
+0x2a 0x0000b
+0x2b 0x0060a
+0x2b 0x63333
+0x2c 0x0000d
+0x2a 0x0000c
+0x2b 0x0060a
+0x2b 0x6b333
+0x2c 0x0000d
+0x2a 0x0000d
+0x2b 0x0060a
+0x2b 0x73333
+0x2c 0x0000d
+0x2a 0x0000e
+0x2b 0x0050b
+0x2b 0x66666	//Alex 0x66623
+0x2c 0x0001a
+0x2a 0xe0000  //0x60000 for 1M spurs
+//RF mode table
+0x10 0x4000f	//TX IQ K 
+0x11 0xe31fc	//Alex_0x231fc	//turn on PAD2       
+0x10 0x6000f	//RX IQ K 
+0x11 0xff9f8	//Alex 0x3f9f8	//turn on RXBB BFAC  
+0x10 0x2000f	//TX Mode
+0x11 0x203f9	// turn on rf tssi
+0x10 0x3000f	//Alex RX mode
+0x11 0xff500	//Alex RX mode
+//0x10 0x1000f    //standbt mode
+//0x11 0x20103    //RF lpbk switches on if at APK mode
+0x10 0x00000	//Alex shut down mode
+0x11 0x00000	//Alex shut down mode
+0x10 0x8000f	//Alex low power RX mode
+0x11 0x3f100	// Alex low power RX mode
+0x10 0x9000f	//Alex low power idle mode
+0x11 0x23100	//Alex power idle mode
+//RXAGC_RXHP table - jerry for ACPR
+0x12 0xd8000    //0x32000; d4000
+0x12 0x90000    //0x71000; 90000
+0x12 0x51000    //0xb0000; 51000
+0x12 0x12000    //0xfc000; 12000
+//TX gain table - Arthur
+0x13 0x28fa8    //Arthur+BS 2011-12-27 old:0x24fa8 //jerry-old 0x28fb4
+0x13 0x24fa8
+0x13 0x207a4
+0x13 0x1c3b0    //0x1c3b0 for 39-40 nonlinear issue
+0x13 0x183a4
+0x13 0x14398
+0x13 0x101a4
+0x13 0x0c198
+0x13 0x080a4
+0x13 0x04098
+0x13 0x00014
+//BIAS table
+0x14 0x1944c
+0x14 0x59444
+0x14 0x9944c
+0x14 0xd9444
+//IPA bias table
+0x15 0x0f424
+0x15 0x4f424
+0x15 0x8f424
+0x15 0xcf424
+//TX table II
+0x16 0xe0330 //High gain
+0x16 0xa0330 //middle gain
+0x16 0x60330 //low gain
+0x16 0x20330 //ultra low gain
+0x00 0x10159 //standby mode
+0x18 0x0f401  //LC calibration
+0xfe // delay 50ms
+0xfe // delay 50ms
+0x1f 0x80003  //RC calibration
+0xfe // delay 50ms
+0xfe // delay 50ms
+0x1e 0x44457
+0x1f 0x80000
+0x00 0x30159 //RX mode
+0xff 0xffff
+
diff --git a/drivers/net/wireless/rtl8192cd/data/radio_b_2T_n_hp.txt b/drivers/net/wireless/rtl8192cd/data/radio_b_2T_n_hp.txt
index 132b748..3d4084e 100644
--- a/drivers/net/wireless/rtl8192cd/data/radio_b_2T_n_hp.txt
+++ b/drivers/net/wireless/rtl8192cd/data/radio_b_2T_n_hp.txt
@@ -1,47 +1,47 @@
-//100701
-0x00 0x30159	//RX mode
-0x01 0x31284	//TRX IQGEN Current
-0x02 0x98000	//TX IQGEN Current
-0x03 0x18c63
-0x04 0x210e7
-0X09 0X2044f
-0x0a 0x1adb1
-0x0b 0x54867
-0x0c 0x8992e
-0x0d 0x0e529   //jerry-low gain for ext.PA
-0x0e 0x39ce7
-0x0f 0x00451
-//RXAGC_RXHP table - jerry for ACPR
-0x12 0xd8000    //0x32000; d4000
-0x12 0x90000    //0x71000; 90000
-0x12 0x51000    //0xb0000; 51000
-0x12 0x12000    //0xfc000; 12000
-//TX gain table - Arthur
-0x13 0x24fa8    //jerry-old 0x28fb4
-0x13 0x24fa8
-0x13 0x207a4
-0x13 0x1c3b0    //jerry-0x1c3b0 for 39-40 nonlinear issue
-0x13 0x183a4
-0x13 0x14398
-0x13 0x101a4
-0x13 0x0c198
-0x13 0x080a4
-0x13 0x04098
-0x13 0x00014
-//BIAS table
-0x14 0x1944c
-0x14 0x59444
-0x14 0x9944c
-0x14 0xd9444
-//IPA bias table
-0x15 0x0f424
-0x15 0x4f424
-0x15 0x8f424
-0x15 0xcf424
-//TX table II
-0x16 0xe0330 //High gain
-0x16 0xa0330 //middle gain
-0x16 0x60330 //low gain
-0x16 0x20330 //ultra low gain
-0xff 0xffff
-
+//100701
+0x00 0x30159	//RX mode
+0x01 0x31284	//TRX IQGEN Current
+0x02 0x98000	//TX IQGEN Current
+0x03 0x18c63
+0x04 0x210e7
+0X09 0X2044f
+0x0a 0x1adb1
+0x0b 0x54867
+0x0c 0x8992e
+0x0d 0x0e529   //jerry-low gain for ext.PA
+0x0e 0x39ce7
+0x0f 0x00451
+//RXAGC_RXHP table - jerry for ACPR
+0x12 0xd8000    //0x32000; d4000
+0x12 0x90000    //0x71000; 90000
+0x12 0x51000    //0xb0000; 51000
+0x12 0x12000    //0xfc000; 12000
+//TX gain table - Arthur
+0x13 0x28fa8    //Arthur+BS 2011-12-27 old:0x24fa8 //jerry-old 0x28fb4
+0x13 0x24fa8
+0x13 0x207a4
+0x13 0x1c3b0    //jerry-0x1c3b0 for 39-40 nonlinear issue
+0x13 0x183a4
+0x13 0x14398
+0x13 0x101a4
+0x13 0x0c198
+0x13 0x080a4
+0x13 0x04098
+0x13 0x00014
+//BIAS table
+0x14 0x1944c
+0x14 0x59444
+0x14 0x9944c
+0x14 0xd9444
+//IPA bias table
+0x15 0x0f424
+0x15 0x4f424
+0x15 0x8f424
+0x15 0xcf424
+//TX table II
+0x16 0xe0330 //High gain
+0x16 0xa0330 //middle gain
+0x16 0x60330 //low gain
+0x16 0x20330 //ultra low gain
+0xff 0xffff
+
diff --git a/drivers/net/wireless/rtl8192cd/data_92d/MACPHY_REG.txt b/drivers/net/wireless/rtl8192cd/data_92d/MACPHY_REG.txt
index d0e6009..19d0f6e 100644
--- a/drivers/net/wireless/rtl8192cd/data_92d/MACPHY_REG.txt
+++ b/drivers/net/wireless/rtl8192cd/data_92d/MACPHY_REG.txt
@@ -1,111 +1,111 @@
-//version 04 modify:
-//1. set Reg0x605  0x80,
-//   Reg0x605[7]: Use phytxend_ps to reset mactx state machine 
-
-
-//TX and RX packet buffer init, this is done before MAC TRX register init, the following 
-//  register setting is done in Power on flow
-
-//0x200	0x29		//RQPN
-//0x201	0x29
-//0x202	0xA3
-//0x203	0x80
-//0x10C 0x71		// for normal chip setting
-//0x10D	0xF7		//HPQ_SEL mapping for Normal chip
-//0x114	0xF6		//TXRKTBUG_PG_BNDY
-//0x209	0xF6		//Beacon Head Page
-//0x115	0x00
-//0x116	0xFF
-//0x117	0x27
-//0x424	0xF6		//BCNQ_PGBNDY
-//0x45D	0xF6		//WMAC_LBK_BF_HD
-//0x60F 0x04		//enable PHY status RCR[28] = 1, 0x60F = 0x04
-
-//EDCA and WMAC related
-0x420	0x80		//0x420[7] = 1 BK_AMPDU_RTY_NEW
-0x423	0x00
-0x430	0x00		//DARFRC, AS 92S
-0x431	0x00
-0x432	0x00
-0x433	0x01
-0x434	0x04		//DARFRC, AS 92S
-0x435	0x05
-0x436	0x06
-0x437	0x07
-0x438	0x00		//RARFRC, AS 92S
-0x439	0x00
-0x43A	0x00
-0x43B	0x01
-0x43C	0x04		//RARFRC, AS 92S
-0x43D	0x05
-0x43E	0x06
-0x43F	0x07
-//0x440	0x5D		//RRSR
-0x441	0x01
-0x442	0x00
-0x444	0x15		//
-0x445	0xF0
-0x446	0x0F
-0x447	0x00
-//0x458	0x41		//AGG_LMT
-//0x459	0xa8		//a8
-//0x45A	0x72		//82
-//0x45B	0xb9		//b9
-//0x460	0x66            //DMDP /SMSP different 
-//0x461	0x66            //DMDP /SMSP different
-0x462	0x08
-0x463	0x03
-0x4C8	0xff		//PROT_MODE_CTRL	need tuning
-0x4C9	0x08
-0x4CC	0xff		//Disable BAR retry 		need tuning
-0x4CD	0xff
-0x4CE	0x01
-0x500	0x26		//VO EDCA
-0x501	0xA2
-0x502	0x2f
-0x503	0x00
-0x504	0x28		//VI EDCA
-0x505	0xA3
-0x506	0x5E
-0x507	0x00
-0x508	0x2B		//BE
-0x509	0xA4
-0x50A	0x5E
-0x50B	0x00
-0x50c	0x4f		//BK EDCA
-0x50D	0xA4
-0x50E	0x00
-0x50F	0x00
-0x512	0x1C		//PIFS
-0x514	0x0a
-0x515	0x10
-0x516	0x0a
-0x517	0x10
-0x51A	0x16		//AGGR_BK_TIME
-0x524	0x0F
-0x525	0x4F		//disable CFE
-0x546	0x40		//NAC_PROT_LEN
-0x547	0x00
-0x550	0x10		// disable auto sync, and initially disable all beacon function, disable beacon update
-0x551	0x10
-0x559	0x02		//BCNDMATIM
-0x55A	0x02		//ATIMWND
-0x55D	0xFF		//disable BCN MAX threshold
-0x605	0x80		
-0x608	0x0E		//RCR
-0x609	0x2A		//RCR+1
-0x652	0xC8		// enable NAV update upper bound
-0x63C	0x0a
-0x63D	0x0a
-0x63E	0x0E
-0x63F	0x0E
-0x66E	0x05		// RX BAR IOT issue for Atheros NIC, where atheros BAR has bus
-0x700	0x21
-0x701	0x43
-0x702	0x65
-0x703	0x87
-0x708	0x21
-0x709	0x43
-0x70a	0x65
-0x70b	0x87
-
+//version 04 modify:
+//1. set Reg0x605  0x80,
+//   Reg0x605[7]: Use phytxend_ps to reset mactx state machine 
+
+
+//TX and RX packet buffer init, this is done before MAC TRX register init, the following 
+//  register setting is done in Power on flow
+
+//0x200	0x29		//RQPN
+//0x201	0x29
+//0x202	0xA3
+//0x203	0x80
+//0x10C 0x71		// for normal chip setting
+//0x10D	0xF7		//HPQ_SEL mapping for Normal chip
+//0x114	0xF6		//TXRKTBUG_PG_BNDY
+//0x209	0xF6		//Beacon Head Page
+//0x115	0x00
+//0x116	0xFF
+//0x117	0x27
+//0x424	0xF6		//BCNQ_PGBNDY
+//0x45D	0xF6		//WMAC_LBK_BF_HD
+//0x60F 0x04		//enable PHY status RCR[28] = 1, 0x60F = 0x04
+
+//EDCA and WMAC related
+0x420	0x80		//0x420[7] = 1 BK_AMPDU_RTY_NEW
+0x423	0x00
+0x430	0x00		//DARFRC, AS 92S
+0x431	0x00
+0x432	0x00
+0x433	0x01
+0x434	0x04		//DARFRC, AS 92S
+0x435	0x05
+0x436	0x06
+0x437	0x07
+0x438	0x00		//RARFRC, AS 92S
+0x439	0x00
+0x43A	0x00
+0x43B	0x01
+0x43C	0x04		//RARFRC, AS 92S
+0x43D	0x05
+0x43E	0x06
+0x43F	0x07
+//0x440	0x5D		//RRSR
+0x441	0x01
+0x442	0x00
+0x444	0x15		//
+0x445	0xF0
+0x446	0x0F
+0x447	0x00
+//0x458	0x41		//AGG_LMT
+//0x459	0xa8		//a8
+//0x45A	0x72		//82
+//0x45B	0xb9		//b9
+//0x460	0x66            //DMDP /SMSP different 
+//0x461	0x66            //DMDP /SMSP different
+0x462	0x08
+0x463	0x03
+0x4C8	0xff		//PROT_MODE_CTRL	need tuning
+0x4C9	0x08
+0x4CC	0xff		//Disable BAR retry 		need tuning
+0x4CD	0xff
+0x4CE	0x01
+0x500	0x26		//VO EDCA
+0x501	0xA2
+0x502	0x2f
+0x503	0x00
+0x504	0x28		//VI EDCA
+0x505	0xA3
+0x506	0x5E
+0x507	0x00
+0x508	0x2B		//BE
+0x509	0xA4
+0x50A	0x5E
+0x50B	0x00
+0x50c	0x4f		//BK EDCA
+0x50D	0xA4
+0x50E	0x00
+0x50F	0x00
+0x512	0x1C		//PIFS
+0x514	0x0a
+0x515	0x10
+0x516	0x0a
+0x517	0x10
+0x51A	0x16		//AGGR_BK_TIME
+0x524	0x0F
+0x525	0x4F		//disable CFE
+0x546	0x40		//NAC_PROT_LEN
+0x547	0x00
+0x550	0x10		// disable auto sync, and initially disable all beacon function, disable beacon update
+0x551	0x10
+0x559	0x02		//BCNDMATIM
+0x55A	0x02		//ATIMWND
+0x55D	0xFF		//disable BCN MAX threshold
+0x605	0x80		
+0x608	0x0E		//RCR
+0x609	0x2A		//RCR+1
+0x652	0xC8		// enable NAV update upper bound
+0x63C	0x08
+0x63D	0x08
+0x63E	0x0C
+0x63F	0x0C
+0x66E	0x05		// RX BAR IOT issue for Atheros NIC, where atheros BAR has bus
+0x700	0x21
+0x701	0x43
+0x702	0x65
+0x703	0x87
+0x708	0x21
+0x709	0x43
+0x70a	0x65
+0x70b	0x87
+
diff --git a/drivers/net/wireless/rtl8192cd/data_92d/PHY_REG_n.txt b/drivers/net/wireless/rtl8192cd/data_92d/PHY_REG_n.txt
index 24a3c74..bdd618a 100644
--- a/drivers/net/wireless/rtl8192cd/data_92d/PHY_REG_n.txt
+++ b/drivers/net/wireless/rtl8192cd/data_92d/PHY_REG_n.txt
@@ -1,221 +1,222 @@
-//100909
-0x024 0x0011800d	//syn CLK enable, Xtal_bsel=nand
-0x028 0x00ffdb83	//320MHz CLK enable
-0x014 0x088ba955	//SPS=1.537V
-0x010 0x49022b03
-//=======================
-// PAGE_8 ( FPGA_PHY0 )
-//=======================
-0x800 0x80040002 // turn off RF when 1R CCA 
-0x804 0x00000003
-0x808 0x0000fc00 
-0x80c 0x0000000A  
-0x810 0x80706388
-0x814 0x020c3d10 
-0x818 0x02200385 // [30:29] is DTR, Set off now. turn off RIFS: 0x00200185, turn on RIFS: 0x00200385
-0x81c 0x00000000 
-0x820 0x01000100 // 0x01000000 (SI), 0x01000100 (PI) 
-0x824 0x00390004 
-0x828 0x01000100 // 0x01000000 (SI), 0x01000100 (PI) 
-0x82c 0x00390004 
-0x830 0x27272727 // Path-B TX AGC codewod, 6M, 9M, 12M, 18M
-0x834 0x27272727  // Path-B TX AGC codewod, 24M, 36M, 48M, 54M
-0x838 0x27272727  // Path-B TX AGC codewod, MCS32, 1M, 2M, 5.5M
-0x83c 0x27272727  // Path-B TX AGC codewod, MCS0, MCS1, MCS2, MCS3
-0x840 0x00010000  //RF to standby mode
-0x844 0x00010000  //RF to standby mode 
-0x848 0x27272727  // Path-B TX AGC codewod, MCS4, MCS5, MCS6, MCS7
-0x84c 0x27272727  // Path-B TX AGC codewod, MCS8, MCS9, MCS10, MCS11
-0x850 0x00000000  // RF wakeup, TBD    
-0x854 0x00000000  // RF sleep, TBD
-0x858 0x569a569a 
-0x85c 0x0c1b25a4  // AFE ctrl reg (ASIC)  RX AD3 CCA mode
-0x860 0x66e60230  //88CE default left anatenna
-0x864 0x061f0130 
-0x868 0x27272727  // Path-B TX AGC codewod, MCS12, MCS13, MCS14, MCS15
-0x86c 0x272b2b2b  // Path-B 11M TX AGC codeword, Path-A 2M/5.5M/11M TX AGC codeword
-0x870 0x07000700  // z2: 0x03000300, 92C RF: 0x07000700 (2 internal PA), 92S RF: 0x03000700 (one internal PA)
-0x874 0x22188000  //AD3 must be off for 92D testchip 
-0x878 0x08080808  // RF mode for standby & rx_low_power codeword
-0x87c 0x00007ff8   // TST mode
-0x880 0xc0083070  // AFE ctrl reg (ASIC) 
-0x884 0x00000cd5  // AFE ctrl reg (ASIC) 
-0x888 0x00000000  // AFE ctrl reg (ASIC) 
-0x88c 0xcc0000c0  // [10:1] is r_rdy_cnt for sleep/standby mode, [27],[31] are MCS_IND
-0x890 0x00000800
-0x894 0xfffffffe 
-0x898 0x40302010 
-0x89c 0x00706050 
-//
-//=======================
-// PAGE_9 ( FPGA_PHY1 )
-//=======================
-0x900 0x00000000
-0x904 0x00000023 
-0x908 0x00000000  
-0x90c 0x81121313 // tx antenna by contorl register
-//
-//=======================
-// PAGE_A ( CCK_PHY0 )
-//=======================
-0xa00 0x00d047c8
-0xa04 0x80ff000c // CCK 1T for power saving
-0xa08 0x8c838300 // MP: 0x88838300, driver: 0x8ccd8300
-0xa0c 0x2e68120f
-0xa10 0x9500bb78 // 
-0xa14 0x11144028
-0xa18 0x00881117
-0xa1c 0x89140f00
-0xa20 0x1a1b0000 
-0xa24 0x090e1317 
-0xa28 0x00000204
-0xa2c 0x00d30000
-0xa70 0x101fbf00
-0xa74 0x00000007
-//
-//=======================
-// PAGE_B
-//=======================
-//
-//
-//=======================
-// PAGE_C ( OFDM_PHY0 )
-//=======================
-0xc00 0x40071d40  // initial gain @ CCA negedge 
-0xc04 0x03a05633  
-0xc08 0x001000e4  // [8:4] is about DBG_GPIO selection 
-0xc0c 0x6c6c6c6c 
-0xc10 0x08800000 
-0xc14 0x40000100
-0xc18 0x08800000
-0xc1c 0x40000100
-0xc20 0x00000000  // DTR TH
-0xc24 0x00000000  // DTR TH
-0xc28 0x00000000  // DTR TH
-0xc2c 0x00000000  // DTR TH
-0xc30 0x69e9ac44  // PWED_TH option2=0x69e9bb44, 0x69e9ab44, 0x69e9ac44
-0xc34 0x469652cf   
-0xc38 0x49795994   
-0xc3c 0x0a979718  
-0xc40 0x1f7c403f  
-0xc44 0x000100b7  
-0xc48 0xec020107 //[1]=1:enable L1_SBD 
-0xc4c 0x007f037f // turn off edcca 
-0xc50 0x69543420 // AAGC=1,0x68043420, AAGC=2,0x69543420 
-0xc54 0x43bc009e 
-0xc58 0x69543420 // AAGC=1,0x68043420, AAGC=2,0x69543420   
-0xc5c 0x433c00a8
-0xc60 0x00000000 // DTR TH
-0xc64 0x5116848b //L1-SBD  //31168a8b for 6M sen. 0x5116828b, 0x5116848b
-0xc68 0x47c00bff //L1-SBD
-0xc6c 0x00000036 //L1-SBD
-0xc70 0x2c7f000d // disable AGC flow-1 
-0xc74 0x058610db // AGC RSSI setting time = 600nS.//0x0186109b=>RRSI=500ns,BBP=300ns for PI used, 0x0186175b
-0xc78 0x0000001f
-0xc7c 0x40b95612  // enable ht rxhp 
-0xc80 0x40000100 
-0xc84 0x20f60000 
-0xc88 0x40000100 
-0xc8c 0xa0e40000 //for MRC weighting function 
-0xc90 0x00121820 // TX Power Training for path-A	
-0xc94 0x00000007 	
-0xc98 0x00121820// TX Power Training for path-B
-0xc9c 0x00007f7f // turn off pre-cca
-0xca0 0x00000000 
-0xca4 0x00000080 // reserved
-0xca8 0x00000000 // reserved
-0xcac 0x00000000 // reserved
-0xcb0 0x00000000 // reserved
-0xcb4 0x00000000 // reserved
-0xcb8 0x00000000 // reserved
-0xcbc 0x28000000
-0xcc0 0x00000000 // reserved
-0xcc4 0x00000000 // reserved
-0xcc8 0x00000000 // reserved
-0xccc 0x00000000 // reserved
-0xcd0 0x00000000 // reserved
-0xcd4 0x00000000 // reserved
-0xcd8 0x64b11e20 // DFS
-0xcdc 0xe0767533 // DFS
-0xce0 0x00222222  
-0xce4 0x00000000
-0xce8 0x37644302
-0xcec 0x2f97d40c
-//
-//=======================
-// PAGE_D ( OFDM_PHY1 )
-//=======================
-0xd00 0x00080740 
-0xd04 0x00020403  
-0xd08 0x0000907f  
-0xd0c 0x20010201 
-0xd10 0xa0633333  
-0xd14 0x3333bc43  
-0xd18 0x7a8f5b6b
-0xd2c 0xcc979975  
-0xd30 0x00000000
-0xd34 0x80608404
-0xd38 0x00000000
-0xd3c 0x00027293
-0xd40 0x00000000
-0xd44 0x00000000
-0xd48 0x00000000
-0xd4c 0x00000000
-0xd50 0x6437140a 
-0xd54 0x00000000 
-0xd58 0x00000000
-0xd5c 0x30032064 
-0xd60 0x4653de68
-0xd64 0x04518a3c //[26]=1:enable L1-SBD//
-0xd68 0x00002101
-0xd6c 0x2a201c16  // DTR
-0xd70 0x1812362e  // DTR
-0xd74 0x322c2220  // DTR
-0xd78 0x000e3c24  // DTR
-//=======================
-// PAGE_E
-//=======================
-0xe00 0x2a2a2a2a	// Path-A TX AGC codewod, 6M, 9M, 12M, 18M 
-0xe04 0x2a2a2a2a	// Path-A TX AGC codewod, 24M, 36M, 48M, 54M 
-0xe08 0x03902a2a	// Path-A TX AGC codewod, MCS32, 1M 
-0xe10 0x2a2a2a2a	// Path-A TX AGC codewod, MCS0, MCS1, MCS2, MCS3 
-0xe14 0x2a2a2a2a	// Path-A TX AGC codewod, MCS4, MCS5, MCS6, MCS7 
-0xe18 0x2a2a2a2a	// Path-A TX AGC codewod, MCS8, MCS9, MCS10, MCS11 
-0xe1c 0x2a2a2a2a	// Path-A TX AGC codewod, MCS12, MCS13, MCS14, MCS15 
-0xe28 0x00000000        
-0xe30 0x1000dc1f	// 0xe30~0xe60: IQK
-0xe34 0x10008c1f
-0xe38 0x02140102
-0xe3C 0x681604c2
-0xe40 0x01007c00
-0xe44 0x01004800
-0xe48 0xfb000000
-0xe4c 0x000028d1
-0xe50 0x1000dc1f
-0xe54 0x10008c1f
-0xe58 0x02140102
-0xe5C 0x28160d05
-0xe60 0x00000010
-//0xe64 0x281600a0	// Reserved in 92C/88C
-0xe68 0x001b25a4         //AFE ctrl reg (ASIC)  Ultra low power
-0xe6c 0x63db25a4	// AFE ctrl reg (ASIC)  Blue-Tooth   
-0xe70 0x63db25a4	// AFE ctrl reg (ASIC)  RX_WAIT_CCA 
-0xe74 0x0c126da4	// AFE ctrl reg (ASIC)  TX_CCK_RFON
-0xe78 0x0c126da4	// AFE ctrl reg (ASIC)  TX_CCK_BBON
-0xe7c 0x0c126da4	// AFE ctrl reg (ASIC)  TX_OFDM_RFON
-0xe80 0x0c126da4	// AFE ctrl reg (ASIC)  TX_OFDM_BBON
-0xe84 0x63db25a4	// AFE ctrl reg (ASIC)  TX_TO_RX
-0xe88 0x0c126da4	// AFE ctrl reg (ASIC)  TX_TO_TX 
-0xe8c 0x63db25a4	// AFE ctrl reg (ASIC)  RX_CCK 
-0xed0 0x63db25a4	// AFE ctrl reg (ASIC)  RX_OFDM 
-0xed4 0x63db25a4	// AFE ctrl reg (ASIC)  RX_WAIT_RIFS 
-0xed8 0x63db25a4	// AFE ctrl reg (ASIC)  RX_TO_RX
-0xedc 0x001b25a4	// AFE ctrl reg (ASIC)  Standby 
-0xee0 0x001b25a4	// AFE ctrl reg (ASIC)  Sleep
-0xeec 0x6fdb25a4	// AFE ctrl reg (ASIC)  PMPD_ANAEN 
-//
-0xf14 0x00000003 // debug port selection. 0x0~0x3: PHY DBG, 0x4~0x5: MAC DBG
-0xf1c 0x64	 // Pkt Interval = 100us	
-0xf4c 0x00000004 // Only for FPGA PMAC
-0xf00 0x00000300 // enable BBRSTB, bcz HSSI use clk_bb
-0xff
+//Release version: RTL8192D.0.1006.2011
+//100909
+//0x024 0x0011800d	//syn CLK enable, Xtal_bsel=nand
+//0x028 0x00ffdb83	//320MHz CLK enable
+//0x014 0x088ba955	//SPS=1.537V
+//0x010 0x49022b03
+//=======================
+// PAGE_8 ( FPGA_PHY0 )
+//=======================
+0x800 0x80040002 // turn off RF when 1R CCA 
+0x804 0x00000003
+0x808 0x0000fc00 
+0x80c 0x0000000A  
+0x810 0x10001331
+0x814 0x020c3d10 
+0x818 0x02200385 // [30:29] is DTR, Set off now. turn off RIFS: 0x00200185, turn on RIFS: 0x00200385
+0x81c 0x00000000 
+0x820 0x01000100 // 0x01000000 (SI), 0x01000100 (PI) 
+0x824 0x00390004 
+0x828 0x01000100 // 0x01000000 (SI), 0x01000100 (PI) 
+0x82c 0x00390004 
+0x830 0x27272727 // Path-B TX AGC codewod, 6M, 9M, 12M, 18M
+0x834 0x27272727  // Path-B TX AGC codewod, 24M, 36M, 48M, 54M
+0x838 0x27272727  // Path-B TX AGC codewod, MCS32, 1M, 2M, 5.5M
+0x83c 0x27272727  // Path-B TX AGC codewod, MCS0, MCS1, MCS2, MCS3
+0x840 0x00010000  //RF to standby mode
+0x844 0x00010000  //RF to standby mode 
+0x848 0x27272727  // Path-B TX AGC codewod, MCS4, MCS5, MCS6, MCS7
+0x84c 0x27272727  // Path-B TX AGC codewod, MCS8, MCS9, MCS10, MCS11
+0x850 0x00000000  // RF wakeup, TBD    
+0x854 0x00000000  // RF sleep, TBD
+0x858 0x569a569a 
+0x85c 0x0c1b25a4  // AFE ctrl reg (ASIC)  RX AD3 CCA mode
+0x860 0x66e60250  //88CE default left anatenna
+0x864 0x061f0150 
+0x868 0x27272727  // Path-B TX AGC codewod, MCS12, MCS13, MCS14, MCS15
+0x86c 0x272b2b2b  // Path-B 11M TX AGC codeword, Path-A 2M/5.5M/11M TX AGC codeword
+0x870 0x07000700  // z2: 0x03000300, 92C RF: 0x07000700 (2 internal PA), 92S RF: 0x03000700 (one internal PA)
+0x874 0x22188000  //AD3 must be off for 92D testchip 
+0x878 0x08080808  // RF mode for standby & rx_low_power codeword
+0x87c 0x0001fff8   // TST mode
+0x880 0xc0083070  // AFE ctrl reg (ASIC) 
+0x884 0x00000cd5  // AFE ctrl reg (ASIC) 
+0x888 0x00000000  // AFE ctrl reg (ASIC) 
+0x88c 0xcc0000c0  // [10:1] is r_rdy_cnt for sleep/standby mode, [27],[31] are MCS_IND
+0x890 0x00000800
+0x894 0xfffffffe 
+0x898 0x40302010 
+0x89c 0x00706050 
+//
+//=======================
+// PAGE_9 ( FPGA_PHY1 )
+//=======================
+0x900 0x00000000
+0x904 0x00000023 
+0x908 0x00000000  
+0x90c 0x81121313 // tx antenna by contorl register
+//
+//=======================
+// PAGE_A ( CCK_PHY0 )
+//=======================
+0xa00 0x00d047c8
+0xa04 0x80ff000c // CCK 1T for power saving
+0xa08 0x8c8a8300 // 
+0xa0c 0x2e68120f
+0xa10 0x9500bb78 // 
+0xa14 0x11144028
+0xa18 0x00881117
+0xa1c 0x89140f00
+0xa20 0x1a1b0000 
+0xa24 0x090e1317 
+0xa28 0x00000204
+0xa2c 0x00d30000
+0xa70 0x101fbf00
+0xa74 0x00000007
+//
+//=======================
+// PAGE_B
+//=======================
+//
+//
+//=======================
+// PAGE_C ( OFDM_PHY0 )
+//=======================
+0xc00 0x40071d40  // initial gain @ CCA negedge 
+0xc04 0x03a05633  
+0xc08 0x001000e4  // [8:4] is about DBG_GPIO selection 
+0xc0c 0x6c6c6c6c 
+0xc10 0x08800000 
+0xc14 0x40000100
+0xc18 0x08800000
+0xc1c 0x40000100
+0xc20 0x00000000  // DTR TH
+0xc24 0x00000000  // DTR TH
+0xc28 0x00000000  // DTR TH
+0xc2c 0x00000000  // DTR TH
+0xc30 0x69e9ac44  // PWED_TH option2=0x69e9bb44, 0x69e9ab44, 0x69e9ac44
+0xc34 0x469652cf   
+0xc38 0x49795994   
+0xc3c 0x0a979718  
+0xc40 0x1f7c403f  
+0xc44 0x000100b7  
+0xc48 0xec020107 //[1]=1:enable L1_SBD 
+0xc4c 0x007f037f // turn off edcca 
+0xc50 0x69543420 // AAGC=1,0x68043420, AAGC=2,0x69543420 
+0xc54 0x43bc009e 
+0xc58 0x69543420 // AAGC=1,0x68043420, AAGC=2,0x69543420   
+0xc5c 0x433c00a8
+0xc60 0x00000000 // DTR TH
+0xc64 0x7116848b //L1-SBD  //31168a8b for 6M sen. 0x5116828b, 0x5116848b
+0xc68 0x47c00bff //L1-SBD
+0xc6c 0x00000036 //L1-SBD
+0xc70 0x2c7f000d // disable AGC flow-1 
+0xc74 0x258610db // AGC RSSI setting time = 600nS.//0x0186109b=>RRSI=500ns,BBP=300ns for PI used, 0x0186175b
+0xc78 0x0000001f
+0xc7c 0x40b95612  // enable ht rxhp 
+0xc80 0x40000100 
+0xc84 0x20f60000 
+0xc88 0x40000100 
+0xc8c 0xa0e40000 
+0xc90 0x00121820 // TX Power Training for path-A	
+0xc94 0x00000007 	
+0xc98 0x00121820// TX Power Training for path-B
+0xc9c 0x00007f7f // turn off pre-cca
+0xca0 0x00000000 
+0xca4 0x00000080 // reserved
+0xca8 0x00000000 // reserved
+0xcac 0x00000000 // reserved
+0xcb0 0x00000000 // reserved
+0xcb4 0x00000000 // reserved
+0xcb8 0x00000000 // reserved
+0xcbc 0x28000000
+0xcc0 0x00000000 // reserved
+0xcc4 0x00000000 // reserved
+0xcc8 0x00000000 // reserved
+0xccc 0x00000000 // reserved
+0xcd0 0x00000000 // reserved
+0xcd4 0x00000000 // reserved
+0xcd8 0x64b11e20 // DFS
+0xcdc 0xe0767533 // DFS
+0xce0 0x00222222  
+0xce4 0x00000000
+0xce8 0x37644302
+0xcec 0x2f97d40c
+//
+//=======================
+// PAGE_D ( OFDM_PHY1 )
+//=======================
+0xd00 0x00080740 
+0xd04 0x00020403  
+0xd08 0x0000907f  
+0xd0c 0x20010201 
+0xd10 0xa0633333  
+0xd14 0x3333bc43  
+0xd18 0x7a8f5b6b
+0xd2c 0xcc979975  
+0xd30 0x00000000
+0xd34 0x80608404
+0xd38 0x00000000
+0xd3c 0x00027353
+0xd40 0x00000000
+0xd44 0x00000000
+0xd48 0x00000000
+0xd4c 0x00000000
+0xd50 0x6437140a 
+0xd54 0x00000000 
+0xd58 0x00000000
+0xd5c 0x30032064 
+0xd60 0x4653de68
+0xd64 0x04518a3c //[26]=1:enable L1-SBD//
+0xd68 0x00002101
+0xd6c 0x2a201c16  // DTR
+0xd70 0x1812362e  // DTR
+0xd74 0x322c2220  // DTR
+0xd78 0x000e3c24  // DTR
+//=======================
+// PAGE_E
+//=======================
+0xe00 0x2a2a2a2a	// Path-A TX AGC codewod, 6M, 9M, 12M, 18M 
+0xe04 0x2a2a2a2a	// Path-A TX AGC codewod, 24M, 36M, 48M, 54M 
+0xe08 0x03902a2a	// Path-A TX AGC codewod, MCS32, 1M 
+0xe10 0x2a2a2a2a	// Path-A TX AGC codewod, MCS0, MCS1, MCS2, MCS3 
+0xe14 0x2a2a2a2a	// Path-A TX AGC codewod, MCS4, MCS5, MCS6, MCS7 
+0xe18 0x2a2a2a2a	// Path-A TX AGC codewod, MCS8, MCS9, MCS10, MCS11 
+0xe1c 0x2a2a2a2a	// Path-A TX AGC codewod, MCS12, MCS13, MCS14, MCS15 
+0xe28 0x00000000        
+0xe30 0x1000dc1f	// 0xe30~0xe60: IQK
+0xe34 0x10008c1f
+0xe38 0x02140102
+0xe3C 0x681604c2
+0xe40 0x01007c00
+0xe44 0x01004800
+0xe48 0xfb000000
+0xe4c 0x000028d1
+0xe50 0x1000dc1f
+0xe54 0x10008c1f
+0xe58 0x02140102
+0xe5C 0x28160d05
+0xe60 0x00000010
+//0xe64 0x281600a0	// Reserved in 92C/88C
+0xe68 0x001b25a4         //AFE ctrl reg (ASIC)  Ultra low power
+0xe6c 0x63db25a4	// AFE ctrl reg (ASIC)  Blue-Tooth   
+0xe70 0x63db25a4	// AFE ctrl reg (ASIC)  RX_WAIT_CCA 
+0xe74 0x0c126da4	// AFE ctrl reg (ASIC)  TX_CCK_RFON
+0xe78 0x0c126da4	// AFE ctrl reg (ASIC)  TX_CCK_BBON
+0xe7c 0x0c126da4	// AFE ctrl reg (ASIC)  TX_OFDM_RFON
+0xe80 0x0c126da4	// AFE ctrl reg (ASIC)  TX_OFDM_BBON
+0xe84 0x63db25a4	// AFE ctrl reg (ASIC)  TX_TO_RX
+0xe88 0x0c126da4	// AFE ctrl reg (ASIC)  TX_TO_TX 
+0xe8c 0x63db25a4	// AFE ctrl reg (ASIC)  RX_CCK 
+0xed0 0x63db25a4	// AFE ctrl reg (ASIC)  RX_OFDM 
+0xed4 0x63db25a4	// AFE ctrl reg (ASIC)  RX_WAIT_RIFS 
+0xed8 0x63db25a4	// AFE ctrl reg (ASIC)  RX_TO_RX
+0xedc 0x001b25a4	// AFE ctrl reg (ASIC)  Standby 
+0xee0 0x001b25a4	// AFE ctrl reg (ASIC)  Sleep
+0xeec 0x6fdb25a4	// AFE ctrl reg (ASIC)  PMPD_ANAEN 
+//
+0xf14 0x00000003 // debug port selection. 0x0~0x3: PHY DBG, 0x4~0x5: MAC DBG
+0xf1c 0x64	 // Pkt Interval = 100us	
+0xf4c 0x00000004 // Only for FPGA PMAC
+0xf00 0x00000300 // enable BBRSTB, bcz HSSI use clk_bb
+0xff
diff --git a/drivers/net/wireless/rtl8192cd/data_92d/radio_a_n_92d_hp.txt b/drivers/net/wireless/rtl8192cd/data_92d/radio_a_n_92d_hp.txt
index 0a3dfbb..ae0d598 100644
--- a/drivers/net/wireless/rtl8192cd/data_92d/radio_a_n_92d_hp.txt
+++ b/drivers/net/wireless/rtl8192cd/data_92d/radio_a_n_92d_hp.txt
@@ -1,244 +1,244 @@
-//100909
-0x00 0x30000  //HSSI_AGC
-0x01 0x30000  //2G_RXIQGEN//2G_TXIQGEN
-0x02 0x00000  //2G_TXIQGEN
-0x03 0x18c63
-0x04 0x18c63  //70000
-//0x05 0xfd800  //HSSI_power_control
-//0x06 0xf001c  //HSSI_2G_5G_RX_gain_control  
-//0x07 0x3c800  //HSSI_TX_gain_control
-0x08 0x84000  //2G_LO_leakage
-0x0b 0x1c000  //24000//2G_5G_TX_PA
-0x0e 0x18c67  //APK default 0x18c63	
-0x0f 0x00851  //2G_TXRX_IQGEN
-0x14 0x21440  //TX_bias_table_I
-//0x15 0x00430  //TX_IPA_table
-//0x16 0xe0332  //TX_bias_table_II
-//0x17 0xf0000  //HSSI_SYN2_power_control
-0x18 0x17524  //channel_band_control
-0x19 0x00000  //TRXIQ control
-0x1d 0xa1290  //RXBB_contorl
-//0x22 0x00000
-0x23 0x01558  //TXBB_control
-//0x24 0x00000
-//0x3d 0x00000
-//0x3e 0x00000
-//0x3f 0x00000
-//0x42 0x08400 //thermal meter
-
-//2G_RFE_control
-0x1a 0x30a99
-0x1b 0x40b00
-0x1c 0xfc339
-//5G_RFE_control
-0x3a 0xa57eb     //0xfd7eb  
-0x3b 0x20000     //0xe0000
-0x3c 0xff454     //0xff7d4    
-//2G_TX_RFE_control
-0x20 0x0aa52   
-0x21 0x54000
-//5G_TX_RFE_control
-0x40 0x0aa52
-0x41 0x14000
-//SYN control
-0x25 0x803be
-0x26 0xfc638
-0x27 0x77c18  //0x77c18 for 2G //0x07c08/0x77c58 for 5G 40M/20M,//0x7b858  // SYN loop setting
-0x28 0xde471  //0xed531 for 2G //0xed771 for 5G  // SYN loop setting
-0x29 0xd7110
-0x2a 0x8cb04
-0x2b 0x4128b
-0x2c 0x01840
-//0x2f 0x22ff0
-//2G_PA_control
-0x43 0x2444f     
-0x44 0x1adb0
-0x45 0x56467
-0x46 0x8992c
-0x47 0x0452c     
-//5G_PA_control
-0x48 0xf9c43     
-0x49 0x02e0c
-0x4a 0x546eb
-0x4b 0x8966C
-0x4c 0x0dde9      
-
-////2G_table_start////
-0x18 0x07401
-0x00 0x70000               
-//2G_RX_gain_table 
-0x12 0xdc000
-0x12 0x90000
-0x12 0x51000
-0x12 0x12000
-//2G_TX_gain_table
-0x13 0x287B7
-0x13 0x247AB
-0x13 0x2079F
-0x13 0x1C793
-0x13 0x1839B
-0x13 0x14392
-0x13 0x1019A
-0x13 0x0C191
-0x13 0x08194
-0x13 0x040A0
-0x13 0x00018
-//2G_IPA_bias_table
-0x15 0x0f424
-0x15 0x4f424
-0x15 0x8f424
-//2G_TX_table_II
-0x16 0xe1330 //High gain
-0x16 0xa1330 //middle gain
-0x16 0x61330 //low gain
-0x16 0x21330 //ultra low gain
-
-//High Power - Arthur - 0627
-////5G_table_start////
-//5GL_channel
-0x18 0x17524   
-0x00 0x70000
-//5GL_RX_gain_table 
-0x12 0xcf000
-0x12 0xbc000
-0x12 0x78000
-0x12 0x00000
-//5GL_TX_gain_table
-0x13 0x287bf
-0x13 0x247b3
-0x13 0x207a7
-0x13 0x1c79b
-0x13 0x1839f
-0x13 0x14393
-0x13 0x10399
-0x13 0x0c38d
-0x13 0x08199
-0x13 0x0418d
-0x13 0x00099
-//5G_IPA_bias_table
-0x15 0x0f4C3
-0x15 0x4f4C3
-0x15 0x8f4C3
-//5G_TX_table_II
-0x16 0xe085F //High gain
-0x16 0xa085F //middle gain
-0x16 0x6085F //low gain
-0x16 0x2085F //ultra low gain
-
-//5GM_channel
-0x18 0x37524   
-0x00 0x70000
-//5GM_RX_gain_table 
-0x12 0xcf000
-0x12 0xbc000
-0x12 0x78000
-0x12 0x00000
-//5GM_TX_gain_table
-0x13 0x287bf
-0x13 0x247b3
-0x13 0x207a7
-0x13 0x1c79b
-0x13 0x1839f
-0x13 0x14393
-0x13 0x10399
-0x13 0x0c38d
-0x13 0x08199
-0x13 0x0418d
-0x13 0x00099
-//5G_IPA_bias_table
-0x15 0x0f4C3
-0x15 0x4f4C3
-0x15 0x8f4C3
-//5G_TX_table_II
-0x16 0xe085F //High gain
-0x16 0xa085F //middle gain
-0x16 0x6085F //low gain
-0x16 0x2085F //ultra low gain
-
-//5GH_channel
-0x18 0x57568   
-0x00 0x70000
-//5GH_RX_gain_table 
-0x12 0xcf000
-0x12 0xbc000
-0x12 0x78000
-0x12 0x00000
-//5GH_TX_gain_table
-0x13 0x287bf
-0x13 0x247b3
-0x13 0x207a7
-0x13 0x1c79b
-0x13 0x1839f
-0x13 0x14393
-0x13 0x10399 //0x1039d //0x10399
-0x13 0x0c38d //0x0c399 //0x0c38d
-0x13 0x08199 //0x0819d //0x08199
-0x13 0x0418d //0x04199 //0x0418d
-0x13 0x00099 //0x00099 //0x00099
-//5G_IPA_bias_table
-0x15 0x0f4C3
-0x15 0x4f4C3
-0x15 0x8f4C3
-//5G_TX_table_II
-0x16 0xe085F //High gain
-0x16 0xa085F //middle gain
-0x16 0x6085F //low gain
-0x16 0x2085F //ultra low gain
-// 5G_IMR_tank_start
-0x30 0x4470f        
-0x31 0x44ff0
-0x32 0x00070
-0x33 0xdd480
-0x34 0xffac0
-0x35 0xb80c0
-0x36 0x77000
-0x37 0x64ff2
-0x38 0xe7661
-0x39 0x00e90         
-//end
-
-0x00  0x30000 
-0x18 0x0f401 //2G channel
-0xfe
-0xfe
-0x1e 0x88009
-0x1f 0x80003
-0xfe
-0x1e 0x88001
-0x1f 0x80000
-0xfe     
-//Rewrite Syn-table    
-0x18 0x97524      // set RF 18[19]=1 for DMSP SYN OFF
-0xfe                   
-0xfe
-0xfe
-0xfe                   
-0x2b 0x41289
-0xfe           
-0x2d 0x6aaaa           
-0x2e 0xb4d01           
-0x2d 0x80000           
-0x2e 0x04d02           
-0x2d 0x95555           
-0x2e 0x54d03           
-0x2d 0xaaaaa           
-0x2e 0xb4d04           
-0x2d 0xc0000           
-0x2e 0x04d05           
-0x2d 0xd5555           
-0x2e 0x54d06           
-0x2d 0xeaaaa           
-0x2e 0xb4d07           
-0x2d 0x00000           
-0x2e 0x05108           
-0x2d 0x15555           
-0x2e 0x55109           
-0x2d 0x2aaaa           
-0x2e 0xb510a           
-0x2d 0x40000           
-0x2e 0x0510b           
-0x2d 0x55555           
-0x2e 0x5510c           
-//end          
-//0x18 0x17524 
-0xff 0xffff
+//100909
+0x00 0x30000  //HSSI_AGC
+0x01 0x30000  //2G_RXIQGEN//2G_TXIQGEN
+0x02 0x00000  //2G_TXIQGEN
+0x03 0x18c63
+0x04 0x18c63  //70000
+//0x05 0xfd800  //HSSI_power_control
+//0x06 0xf001c  //HSSI_2G_5G_RX_gain_control  
+//0x07 0x3c800  //HSSI_TX_gain_control
+0x08 0x84000  //2G_LO_leakage
+0x0b 0x1c000  //24000//2G_5G_TX_PA
+0x0e 0x18c67  //APK default 0x18c63	
+0x0f 0x00851  //2G_TXRX_IQGEN
+0x14 0x21440  //TX_bias_table_I
+//0x15 0x00430  //TX_IPA_table
+//0x16 0xe0332  //TX_bias_table_II
+//0x17 0xf0000  //HSSI_SYN2_power_control
+0x18 0x17524  //channel_band_control
+0x19 0x00000  //TRXIQ control
+0x1d 0xa1290  //RXBB_contorl
+//0x22 0x00000
+0x23 0x01558  //TXBB_control
+//0x24 0x00000
+//0x3d 0x00000
+//0x3e 0x00000
+//0x3f 0x00000
+//0x42 0x08400 //thermal meter
+
+//2G_RFE_control
+0x1a 0x30a99
+0x1b 0x40b00
+0x1c 0xfc339
+//5G_RFE_control
+0x3a 0xa57eb     //0xfd7eb  
+0x3b 0x20000     //0xe0000
+0x3c 0xff454     //0xff7d4    
+//2G_TX_RFE_control
+0x20 0x0aa52   
+0x21 0x54000
+//5G_TX_RFE_control
+0x40 0x0aa52
+0x41 0x14000
+//SYN control
+0x25 0x803be
+0x26 0xfc638
+0x27 0x77c18  //0x77c18 for 2G //0x07c08/0x77c58 for 5G 40M/20M,//0x7b858  // SYN loop setting
+0x28 0xde471  //0xed531 for 2G //0xed771 for 5G  // SYN loop setting
+0x29 0xd7110
+0x2a 0x8cb04
+0x2b 0x4128b
+0x2c 0x01840
+//0x2f 0x22ff0
+//2G_PA_control
+0x43 0x2444f     
+0x44 0x1adb0
+0x45 0x56467
+0x46 0x8992c
+0x47 0x04529 //2011.11.16 Arthur 452c intpa 4529 extpa     
+//5G_PA_control
+0x48 0xf9c43     
+0x49 0x02e0c
+0x4a 0x546eb
+0x4b 0x8966C
+0x4c 0x0dde9      
+
+////2G_table_start////
+0x18 0x07401
+0x00 0x70000               
+//2G_RX_gain_table 
+0x12 0xdc000
+0x12 0x90000
+0x12 0x51000
+0x12 0x12000
+//2G_TX_gain_table
+0x13 0x287B7
+0x13 0x247AB
+0x13 0x2079F
+0x13 0x1C793
+0x13 0x1839B
+0x13 0x14392
+0x13 0x1019A
+0x13 0x0C191
+0x13 0x08194
+0x13 0x040A0
+0x13 0x00018
+//2G_IPA_bias_table
+0x15 0x0f424
+0x15 0x4f424
+0x15 0x8f424
+//2G_TX_table_II
+0x16 0xe1330 //High gain
+0x16 0xa1330 //middle gain
+0x16 0x61330 //low gain
+0x16 0x21330 //ultra low gain
+
+//High Power - Arthur - 0627
+////5G_table_start////
+//5GL_channel
+0x18 0x17524   
+0x00 0x70000
+//5GL_RX_gain_table 
+0x12 0xcf000
+0x12 0xbc000
+0x12 0x78000
+0x12 0x00000
+//5GL_TX_gain_table
+0x13 0x287bf
+0x13 0x247b3
+0x13 0x207a7
+0x13 0x1c79b
+0x13 0x1839f
+0x13 0x14393
+0x13 0x10399
+0x13 0x0c38d
+0x13 0x08199
+0x13 0x0418d
+0x13 0x00099
+//5G_IPA_bias_table
+0x15 0x0f4C3
+0x15 0x4f4C3
+0x15 0x8f4C3
+//5G_TX_table_II
+0x16 0xe085F //High gain
+0x16 0xa085F //middle gain
+0x16 0x6085F //low gain
+0x16 0x2085F //ultra low gain
+
+//5GM_channel
+0x18 0x37524   
+0x00 0x70000
+//5GM_RX_gain_table 
+0x12 0xcf000
+0x12 0xbc000
+0x12 0x78000
+0x12 0x00000
+//5GM_TX_gain_table
+0x13 0x287bf
+0x13 0x247b3
+0x13 0x207a7
+0x13 0x1c79b
+0x13 0x1839f
+0x13 0x14393
+0x13 0x10399
+0x13 0x0c38d
+0x13 0x08199
+0x13 0x0418d
+0x13 0x00099
+//5G_IPA_bias_table
+0x15 0x0f4C3
+0x15 0x4f4C3
+0x15 0x8f4C3
+//5G_TX_table_II
+0x16 0xe085F //High gain
+0x16 0xa085F //middle gain
+0x16 0x6085F //low gain
+0x16 0x2085F //ultra low gain
+
+//5GH_channel
+0x18 0x57568   
+0x00 0x70000
+//5GH_RX_gain_table 
+0x12 0xcf000
+0x12 0xbc000
+0x12 0x78000
+0x12 0x00000
+//5GH_TX_gain_table
+0x13 0x287bf
+0x13 0x247b3
+0x13 0x207a7
+0x13 0x1c79b
+0x13 0x1839f
+0x13 0x14393
+0x13 0x10399 //0x1039d //0x10399
+0x13 0x0c38d //0x0c399 //0x0c38d
+0x13 0x08199 //0x0819d //0x08199
+0x13 0x0418d //0x04199 //0x0418d
+0x13 0x00099 //0x00099 //0x00099
+//5G_IPA_bias_table
+0x15 0x0f4C3
+0x15 0x4f4C3
+0x15 0x8f4C3
+//5G_TX_table_II
+0x16 0xe085F //High gain
+0x16 0xa085F //middle gain
+0x16 0x6085F //low gain
+0x16 0x2085F //ultra low gain
+// 5G_IMR_tank_start
+0x30 0x4470f        
+0x31 0x44ff0
+0x32 0x00070
+0x33 0xdd480
+0x34 0xffac0
+0x35 0xb80c0
+0x36 0x77000
+0x37 0x64ff2
+0x38 0xe7661
+0x39 0x00e90         
+//end
+
+0x00  0x30000 
+0x18 0x0f401 //2G channel
+0xfe
+0xfe
+0x1e 0x88009
+0x1f 0x80003
+0xfe
+0x1e 0x88001
+0x1f 0x80000
+0xfe     
+//Rewrite Syn-table    
+0x18 0x97524      // set RF 18[19]=1 for DMSP SYN OFF
+0xfe                   
+0xfe
+0xfe
+0xfe                   
+0x2b 0x41289
+0xfe           
+0x2d 0x6aaaa           
+0x2e 0xb4d01           
+0x2d 0x80000           
+0x2e 0x04d02           
+0x2d 0x95555           
+0x2e 0x54d03           
+0x2d 0xaaaaa           
+0x2e 0xb4d04           
+0x2d 0xc0000           
+0x2e 0x04d05           
+0x2d 0xd5555           
+0x2e 0x54d06           
+0x2d 0xeaaaa           
+0x2e 0xb4d07           
+0x2d 0x00000           
+0x2e 0x05108           
+0x2d 0x15555           
+0x2e 0x55109           
+0x2d 0x2aaaa           
+0x2e 0xb510a           
+0x2d 0x40000           
+0x2e 0x0510b           
+0x2d 0x55555           
+0x2e 0x5510c           
+//end          
+//0x18 0x17524 
+0xff 0xffff
diff --git a/drivers/net/wireless/rtl8192cd/data_92d/radio_b_n_92d_hp.txt b/drivers/net/wireless/rtl8192cd/data_92d/radio_b_n_92d_hp.txt
index b824c46..ae016cd 100644
--- a/drivers/net/wireless/rtl8192cd/data_92d/radio_b_n_92d_hp.txt
+++ b/drivers/net/wireless/rtl8192cd/data_92d/radio_b_n_92d_hp.txt
@@ -1,248 +1,248 @@
-//100909
-0x00 0x30000  //HSSI_AGC
-0x01 0x30000  //2G_RXIQGEN//2G_TXIQGEN
-0x02 0x00000  //2G_TXIQGEN
-0x03 0x18c63
-0x04 0x18c63  //0x70000
-//0x05 0xfd800  //HSSI_power_control
-//0x06 0xf001c  //HSSI_2G_5G_RX_gain_control  
-//0x07 0x3c800  //HSSI_TX_gain_control
-0x08 0x84000  //2G_LO_leakage
-0x0b 0x1c000  //24000//2G_5G_TX_PA
-0x0e 0x18c67  //APK default 0x18c63	
-0x0f 0x00851  //2G_TXRX_IQGEN
-0x14 0x21440  //TX_bias_table_I
-//0x15 0x00430  //TX_IPA_table
-//0x16 0xe0332  //TX_bias_table_II
-//0x17 0x90000  //HSSI_SYN2_power_control
-0x18 0x07401  //channel_band_control
-0x19 0x00060  //TRXIQ control
-0x1d 0xa1290  //RXBB_contorl
-//0x22 0x00000
-0x23 0x01558  //TXBB_control
-//0x24 0x00000
-//0x3d 0x00000
-//0x3e 0x00000
-//0x3f 0x00000
-//0x42 0x08400 //thermal meter
-
-//2G_RFE_control
-0x1a 0x30a99
-0x1b 0x40b00
-0x1c 0xfc339
-//5G_RFE_control
-0x3a 0xa57eb       
-0x3b 0x20000
-0x3c 0xff454 //0xff7d4       
-//2G_TX_RFE_control
-0x20 0x0aa52   
-0x21 0x54000
-//5G_TX_RFE_control
-0x40 0x0aa52
-0x41 0x14000
-//SYN control
-0x25 0x803be
-0x26 0xfc638
-0x27 0x77c18  //0x77c18 for 2G //0x07c08/0x77c58 for 5G 40M/20M,//0x7b858  // SYN loop setting
-0x28 0xd1c31  //0xed531 for 2G //0xed571 for 5G  // SYN loop setting
-0x29 0xd7110
-0x2a 0xaeb04  //0x8cb04
-0x2b 0x4128b
-0x2c 0x01840
-//0x2f 0x22ff0
-//2G_PA_control
-0x43 0x2444f     
-0x44 0x1adb0
-0x45 0x56467
-0x46 0x8992c
-0x47 0x0452c     
-//5G_PA_control
-0x48 0xf9c43     
-0x49 0x02e0c
-0x4a 0x546eb
-0x4b 0x8966C
-0x4c 0x0dde9      
-
-////2G_table_start////
-0x18 0x07401
-0x00 0x70000               
-//2G_RX_gain_table 
-0x12 0xdc000
-0x12 0x90000
-0x12 0x51000
-0x12 0x12000
-//2G_TX_gain_table
-0x13 0x287B7
-0x13 0x247AB
-0x13 0x2079F
-0x13 0x1C793
-0x13 0x1839B
-0x13 0x14392
-0x13 0x1019A
-0x13 0x0C191
-0x13 0x08194
-0x13 0x040A0
-0x13 0x00018
-//2G_IPA_bias_table
-0x15 0x0f424
-0x15 0x4f424
-0x15 0x8f424
-//2G_TX_table_II
-0x16 0xe1330 //High gain
-0x16 0xa1330 //middle gain
-0x16 0x61330 //low gain
-0x16 0x21330 //ultra low gain
-
-//High Power - Arthur - 0627
-////5G_table_start////
-//5GL_channel
-0x18 0x17524   
-0x00 0x70000
-//5GL_RX_gain_table 
-0x12 0xcf000
-0x12 0xbc000
-0x12 0x78000
-0x12 0x00000
-//5GL_TX_gain_table
-0x13 0x287bf
-0x13 0x247b3
-0x13 0x207a7
-0x13 0x1c79b
-0x13 0x1839f
-0x13 0x14393
-0x13 0x10399
-0x13 0x0c38d
-0x13 0x08199
-0x13 0x0418d
-0x13 0x00099
-//5G_IPA_bias_table
-0x15 0x0f4C3
-0x15 0x4f4C3
-0x15 0x8f4C3
-//5G_TX_table_II
-0x16 0xe085F //High gain
-0x16 0xa085F //middle gain
-0x16 0x6085F //low gain
-0x16 0x2085F //ultra low gain
-
-//5GM_channel
-0x18 0x37524   
-0x00 0x70000
-//5GM_RX_gain_table 
-0x12 0xcf000
-0x12 0xbc000
-0x12 0x78000
-0x12 0x00000
-//5GM_TX_gain_table
-0x13 0x287bf
-0x13 0x247b3
-0x13 0x207a7
-0x13 0x1c79b
-0x13 0x1839f
-0x13 0x14393
-0x13 0x10399
-0x13 0x0c38d
-0x13 0x08199
-0x13 0x0418d
-0x13 0x00099
-//5G_IPA_bias_table
-0x15 0x0f4C3
-0x15 0x4f4C3
-0x15 0x8f4C3
-//5G_TX_table_II
-0x16 0xe085F //High gain
-0x16 0xa085F //middle gain
-0x16 0x6085F //low gain
-0x16 0x2085F //ultra low gain
-
-//5GH_channel
-0x18 0x57524   
-0x00 0x70000
-//5GH_RX_gain_table 
-0x12 0xcf000
-0x12 0xbc000
-0x12 0x78000
-0x12 0x00000
-//5GH_TX_gain_table
-0x13 0x287bf
-0x13 0x247b3
-0x13 0x207a7
-0x13 0x1c79b
-0x13 0x1839f
-0x13 0x14393
-0x13 0x10399 //0x1039d //0x10399
-0x13 0x0c38d //0x0c399 //0x0c38d
-0x13 0x08199 //0x0819d //0x08199
-0x13 0x0418d //0x04199 //0x0418d
-0x13 0x00099 //0x00099 //0x00099
-//5G_IPA_bias_table
-0x15 0x0f4C3
-0x15 0x4f4C3
-0x15 0x8f4C3
-//5G_TX_table_II
-0x16 0xe085F //High gain
-0x16 0xa085F //middle gain
-0x16 0x6085F //low gain
-0x16 0x2085F //ultra low gain
-// 5G_IMR_tank_start
-0x30 0x4470f        
-0x31 0x44ff0
-0x32 0x00070
-0x33 0xdd480
-0x34 0xffac0
-0x35 0xb80c0
-0x36 0x77000
-0x37 0x64ff2
-0x38 0xe7661
-0x39 0x00e90         
-//end
-
-0x00  0x30000 
-
-0x18 0x0f401 //2G channel
-0xfe
-0xfe
-0x1e 0x88009
-0x1f 0x80003
-0xfe
-0x1e 0x88001
-0x1f 0x80000
-0xfe
-//Rewrite Syn-table
-0x18 0x87401   // set RF 18[19]=1 for DMSP SYN OFF
-0xfe
-0xfe
-0xfe
-0x2b 0x41289  //02b4128b
-0xfe
-0x2d 0x66666
-0x2e 0x64001
-0x2d 0x91111
-0x2e 0x14002
-0x2d 0xbbbbb
-0x2e 0xb4003
-0x2d 0xe6666
-0x2e 0x64004
-0x2d 0x88888 //0x11111
-0x2e 0x84005 //0x14405
-0x2d 0x9dddd //0x3bbbb
-0x2e 0xd4006 //0xb4406
-0x2d 0xb3333 //0x66666
-0x2e 0x34007 //0x64407
-0x2d 0x48888 //0x91111
-0x2e 0x84408 //0x14408
-0x2d 0xbbbbb
-0x2e 0xb4409
-0x2d 0xe6666
-0x2e 0x6440a
-0x2d 0x11111
-0x2e 0x1480b
-0x2d 0x3bbbb
-0x2e 0xb480c
-0x2d 0x66666
-0x2e 0x6480d
-0x2d 0xccccc
-0x2e 0xc480e
-//end
-//0x18 0x0f401 //2G channel
+//100909
+0x00 0x30000  //HSSI_AGC
+0x01 0x30000  //2G_RXIQGEN//2G_TXIQGEN
+0x02 0x00000  //2G_TXIQGEN
+0x03 0x18c63
+0x04 0x18c63  //0x70000
+//0x05 0xfd800  //HSSI_power_control
+//0x06 0xf001c  //HSSI_2G_5G_RX_gain_control  
+//0x07 0x3c800  //HSSI_TX_gain_control
+0x08 0x84000  //2G_LO_leakage
+0x0b 0x1c000  //24000//2G_5G_TX_PA
+0x0e 0x18c67  //APK default 0x18c63	
+0x0f 0x00851  //2G_TXRX_IQGEN
+0x14 0x21440  //TX_bias_table_I
+//0x15 0x00430  //TX_IPA_table
+//0x16 0xe0332  //TX_bias_table_II
+//0x17 0x90000  //HSSI_SYN2_power_control
+0x18 0x07401  //channel_band_control
+0x19 0x00060  //TRXIQ control
+0x1d 0xa1290  //RXBB_contorl
+//0x22 0x00000
+0x23 0x01558  //TXBB_control
+//0x24 0x00000
+//0x3d 0x00000
+//0x3e 0x00000
+//0x3f 0x00000
+//0x42 0x08400 //thermal meter
+
+//2G_RFE_control
+0x1a 0x30a99
+0x1b 0x40b00
+0x1c 0xfc339
+//5G_RFE_control
+0x3a 0xa57eb       
+0x3b 0x20000
+0x3c 0xff454 //0xff7d4       
+//2G_TX_RFE_control
+0x20 0x0aa52   
+0x21 0x54000
+//5G_TX_RFE_control
+0x40 0x0aa52
+0x41 0x14000
+//SYN control
+0x25 0x803be
+0x26 0xfc638
+0x27 0x77c18  //0x77c18 for 2G //0x07c08/0x77c58 for 5G 40M/20M,//0x7b858  // SYN loop setting
+0x28 0xd1c31  //0xed531 for 2G //0xed571 for 5G  // SYN loop setting
+0x29 0xd7110
+0x2a 0xaeb04  //0x8cb04
+0x2b 0x4128b
+0x2c 0x01840
+//0x2f 0x22ff0
+//2G_PA_control
+0x43 0x2444f     
+0x44 0x1adb0
+0x45 0x56467
+0x46 0x8992c
+0x47 0x04529 //2011.11.16 Arthur 452c intpa 4529 extpa       
+//5G_PA_control
+0x48 0xf9c43     
+0x49 0x02e0c
+0x4a 0x546eb
+0x4b 0x8966C
+0x4c 0x0dde9      
+
+////2G_table_start////
+0x18 0x07401
+0x00 0x70000               
+//2G_RX_gain_table 
+0x12 0xdc000
+0x12 0x90000
+0x12 0x51000
+0x12 0x12000
+//2G_TX_gain_table
+0x13 0x287B7
+0x13 0x247AB
+0x13 0x2079F
+0x13 0x1C793
+0x13 0x1839B
+0x13 0x14392
+0x13 0x1019A
+0x13 0x0C191
+0x13 0x08194
+0x13 0x040A0
+0x13 0x00018
+//2G_IPA_bias_table
+0x15 0x0f424
+0x15 0x4f424
+0x15 0x8f424
+//2G_TX_table_II
+0x16 0xe1330 //High gain
+0x16 0xa1330 //middle gain
+0x16 0x61330 //low gain
+0x16 0x21330 //ultra low gain
+
+//High Power - Arthur - 0627
+////5G_table_start////
+//5GL_channel
+0x18 0x17524   
+0x00 0x70000
+//5GL_RX_gain_table 
+0x12 0xcf000
+0x12 0xbc000
+0x12 0x78000
+0x12 0x00000
+//5GL_TX_gain_table
+0x13 0x287bf
+0x13 0x247b3
+0x13 0x207a7
+0x13 0x1c79b
+0x13 0x1839f
+0x13 0x14393
+0x13 0x10399
+0x13 0x0c38d
+0x13 0x08199
+0x13 0x0418d
+0x13 0x00099
+//5G_IPA_bias_table
+0x15 0x0f4C3
+0x15 0x4f4C3
+0x15 0x8f4C3
+//5G_TX_table_II
+0x16 0xe085F //High gain
+0x16 0xa085F //middle gain
+0x16 0x6085F //low gain
+0x16 0x2085F //ultra low gain
+
+//5GM_channel
+0x18 0x37524   
+0x00 0x70000
+//5GM_RX_gain_table 
+0x12 0xcf000
+0x12 0xbc000
+0x12 0x78000
+0x12 0x00000
+//5GM_TX_gain_table
+0x13 0x287bf
+0x13 0x247b3
+0x13 0x207a7
+0x13 0x1c79b
+0x13 0x1839f
+0x13 0x14393
+0x13 0x10399
+0x13 0x0c38d
+0x13 0x08199
+0x13 0x0418d
+0x13 0x00099
+//5G_IPA_bias_table
+0x15 0x0f4C3
+0x15 0x4f4C3
+0x15 0x8f4C3
+//5G_TX_table_II
+0x16 0xe085F //High gain
+0x16 0xa085F //middle gain
+0x16 0x6085F //low gain
+0x16 0x2085F //ultra low gain
+
+//5GH_channel
+0x18 0x57524   
+0x00 0x70000
+//5GH_RX_gain_table 
+0x12 0xcf000
+0x12 0xbc000
+0x12 0x78000
+0x12 0x00000
+//5GH_TX_gain_table
+0x13 0x287bf
+0x13 0x247b3
+0x13 0x207a7
+0x13 0x1c79b
+0x13 0x1839f
+0x13 0x14393
+0x13 0x10399 //0x1039d //0x10399
+0x13 0x0c38d //0x0c399 //0x0c38d
+0x13 0x08199 //0x0819d //0x08199
+0x13 0x0418d //0x04199 //0x0418d
+0x13 0x00099 //0x00099 //0x00099
+//5G_IPA_bias_table
+0x15 0x0f4C3
+0x15 0x4f4C3
+0x15 0x8f4C3
+//5G_TX_table_II
+0x16 0xe085F //High gain
+0x16 0xa085F //middle gain
+0x16 0x6085F //low gain
+0x16 0x2085F //ultra low gain
+// 5G_IMR_tank_start
+0x30 0x4470f        
+0x31 0x44ff0
+0x32 0x00070
+0x33 0xdd480
+0x34 0xffac0
+0x35 0xb80c0
+0x36 0x77000
+0x37 0x64ff2
+0x38 0xe7661
+0x39 0x00e90         
+//end
+
+0x00  0x30000 
+
+0x18 0x0f401 //2G channel
+0xfe
+0xfe
+0x1e 0x88009
+0x1f 0x80003
+0xfe
+0x1e 0x88001
+0x1f 0x80000
+0xfe
+//Rewrite Syn-table
+0x18 0x87401   // set RF 18[19]=1 for DMSP SYN OFF
+0xfe
+0xfe
+0xfe
+0x2b 0x41289  //02b4128b
+0xfe
+0x2d 0x66666
+0x2e 0x64001
+0x2d 0x91111
+0x2e 0x14002
+0x2d 0xbbbbb
+0x2e 0xb4003
+0x2d 0xe6666
+0x2e 0x64004
+0x2d 0x88888 //0x11111
+0x2e 0x84005 //0x14405
+0x2d 0x9dddd //0x3bbbb
+0x2e 0xd4006 //0xb4406
+0x2d 0xb3333 //0x66666
+0x2e 0x34007 //0x64407
+0x2d 0x48888 //0x91111
+0x2e 0x84408 //0x14408
+0x2d 0xbbbbb
+0x2e 0xb4409
+0x2d 0xe6666
+0x2e 0x6440a
+0x2d 0x11111
+0x2e 0x1480b
+0x2d 0x3bbbb
+0x2e 0xb480c
+0x2d 0x66666
+0x2e 0x6480d
+0x2d 0xccccc
+0x2e 0xc480e
+//end
+//0x18 0x0f401 //2G channel
 0xff 0xffff
\ No newline at end of file
diff --git a/drivers/net/wireless/rtl8192cd/ieee802_mib.h b/drivers/net/wireless/rtl8192cd/ieee802_mib.h
index 35bff57..3a3d7f1 100644
--- a/drivers/net/wireless/rtl8192cd/ieee802_mib.h
+++ b/drivers/net/wireless/rtl8192cd/ieee802_mib.h
@@ -18,7 +18,7 @@
 #ifndef _IEEE802_MIB_H_
 #define _IEEE802_MIB_H_
 
-#define MIB_VERSION				6
+#define MIB_VERSION				11
 
 #define MAX_2G_CHANNEL_NUM		14
 #define MAX_5G_CHANNEL_NUM		196
@@ -72,7 +72,8 @@ struct Dot11StationConfigEntry {
 	unsigned int	fixedTxRate;			// fix tx rate
 	int				swTkipMic;
 	int				protectionDisabled;		// force disable protection
-	int				olbcDetectDisabled;		// david, force disable olbc dection
+	int				olbcDetectDisabled;		// david, force disable olbc dection	
+	int				nmlscDetectDisabled;		// hf, force disable no member legacy station condition detection
 	int				legacySTADeny;			// deny association from legacy (11B) STA
 	int				fastRoaming;			// 1: enable fast-roaming, 0: disable
 	unsigned int	lowestMlcstRate;		// 1: use lowest basic rate to send multicast
@@ -107,6 +108,9 @@ struct Dot118021xAuthEntry {
 	unsigned int	dot118021xAlgrthm;		// could be null, 802.1x/PSK
 	unsigned int	dot118021xDefaultPort;	// used as AP mode for default ieee8021x control port
 	unsigned int	dot118021xcontrolport;
+	unsigned int	acct_enabled;
+	unsigned long	acct_timeout_period;
+	unsigned int	acct_timeout_throughput;
 };
 
 union Keytype {
@@ -262,6 +266,7 @@ struct Dot11RFEntry {
 #endif
 	unsigned char	trsw_pape_C9;
 	unsigned char	trsw_pape_CC;
+	unsigned int	tx2path;
 	unsigned int	txbf;
 	unsigned int	target_pwr;
 };
@@ -294,6 +299,11 @@ struct bss_desc {
 	unsigned char	rssi;
 	unsigned char	sq;
 	unsigned char	network;
+	/*add for P2P_SUPPORT ; for sync; it exist no matter p2p enabled or not*/
+	unsigned char	p2pdevname[33];
+	unsigned char	p2prole;
+	unsigned short	p2pwscconfig;
+	unsigned char	p2paddress[MACADDRLEN];
 };
 
 struct bss_type
@@ -369,6 +379,7 @@ struct MiscEntry {
 	unsigned int	groupID;
 	unsigned int	vap_enable;
 	unsigned int	rsv_txdesc;				// 1: enable "reserve tx desc for each interface" function; 0: disable.
+	unsigned int	use_txq;
 	unsigned int	func_off;
 };
 
@@ -387,6 +398,10 @@ struct Dot11QosEntry {
 	unsigned int	EDCA_STA_config;		// WMM STA, default=0, will be set when assoc AP's EDCA para have been set
 	unsigned char	WMM_IE[7];				// WMM STA, WMM IE
 	unsigned char	WMM_PARA_IE[24];		// WMM EDCA Parameter IE
+	unsigned int	UAPSD_AC_BE;
+	unsigned int	UAPSD_AC_BK;
+	unsigned int	UAPSD_AC_VI;
+	unsigned int	UAPSD_AC_VO;
 
 	struct ParaRecord STA_AC_BE_paraRecord;
 	struct ParaRecord STA_AC_BK_paraRecord;
@@ -433,6 +448,7 @@ struct Dot11nConfigEntry {
 	unsigned int	dot11nAMSDUSendNum;		// max aggregation packet number
 	unsigned int	dot11nLgyEncRstrct;		// bit0: Wep, bit1: TKIP, bit2: restrict Realtek client, bit3: forbid  N mode for legacy enc
 	unsigned int	dot11nCoexist;
+	unsigned int	dot11nTxNoAck;
 };
 
 struct ReorderControlEntry {
@@ -486,7 +502,10 @@ struct VlanConfig {
 	int vlan_id;			// 1~4090: vlan id (per-port)
 	int vlan_pri;			// 0~7: priority; (per-port)
 	int vlan_cfi;			// 0/1: cfi (per-port)
-	int forwarding;			// 0: disable 1:L2 bridged 2:NAT
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+	int forwarding_rule;			// 0: disable 1:L2 bridged 2:NAT
+#endif
+
 };
 
 /*	type define must accordint to the wapi standard	*/
@@ -538,6 +557,24 @@ typedef struct __wapiMibInfo {
 } wapiMibInfo;
 
 
+/*for P2P_SUPPORT*/
+struct P2P_Direct {
+
+	unsigned int   p2p_type;
+	unsigned int   p2p_state;
+	unsigned int   p2p_on_discovery;
+	unsigned char  p2p_intent;
+	unsigned char  p2p_listen_channel;
+	unsigned char  p2p_op_channel;
+
+	unsigned char  p2p_event_indiate;
+
+	unsigned char  p2p_device_name[33];
+	unsigned char  p2p_wsc_pin_code[9];
+	unsigned short p2p_wsc_config_method;
+
+};
+
 // driver mib
 struct wifi_mib {
 	unsigned int					mib_version;
@@ -568,6 +605,7 @@ struct wifi_mib {
 	struct Dot1180211CountryCodeEntry	dot11dCountry;
 	struct EfuseEntry			efuseEntry;
 	struct StaDetectInfo			staDetectInfo;
+	struct P2P_Direct			p2p_mib;	// add for P2P_SUPPORT
 };
 
 #endif // _IEEE802_MIB_H_
diff --git a/drivers/net/wireless/rtl8192cd/wapiCrypto.h b/drivers/net/wireless/rtl8192cd/wapiCrypto.h
index eb4ca9f..bb6341f 100644
--- a/drivers/net/wireless/rtl8192cd/wapiCrypto.h
+++ b/drivers/net/wireless/rtl8192cd/wapiCrypto.h
@@ -1,145 +1,143 @@
-#ifndef	WAPICRYPTO_H
-#define	WAPICRYPTO_H	1
-
-#define		ENCRYPT		0     
-#define		DECRYPT		1
-
-/**
- * \brief          SHA-256 context structure
- */
-typedef struct
-{
-    unsigned long total[2];     /*!< number of bytes processed  */
-    unsigned long state[8];     /*!< intermediate digest state  */
-    unsigned char buffer[64];   /*!< data block being processed */
-
-    unsigned char ipad[64];     /*!< HMAC: inner padding        */
-    unsigned char opad[64];     /*!< HMAC: outer padding        */
-    int is224;                  /*!< 0 => SHA-256, else SHA-224 */
-}
-sha2_context;
-
-/**
- * \brief          SHA-256 context setup
- *
- * \param ctx      context to be initialized
- * \param is224    0 = use SHA256, 1 = use SHA224
- */
-void sha2_starts( sha2_context *ctx, int is224 );
-
-/**
- * \brief          SHA-256 process buffer
- *
- * \param ctx      SHA-256 context
- * \param input    buffer holding the  data
- * \param ilen     length of the input data
- */
-void sha2_update( sha2_context *ctx, unsigned char *input, int ilen );
-
-/**
- * \brief          SHA-256 final digest
- *
- * \param ctx      SHA-256 context
- * \param output   SHA-224/256 checksum result
- */
-void sha2_finish( sha2_context *ctx, unsigned char output[32] );
-
-/**
- * \brief          Output = SHA-256( input buffer )
- *
- * \param input    buffer holding the  data
- * \param ilen     length of the input data
- * \param output   SHA-224/256 checksum result
- * \param is224    0 = use SHA256, 1 = use SHA224
- */
-void sha2( unsigned char *input, int ilen,
-           unsigned char output[32], int is224 );
-
-#if 0
-/**
- * \brief          Output = SHA-256( file contents )
- *
- * \param path     input file name
- * \param output   SHA-224/256 checksum result
- * \param is224    0 = use SHA256, 1 = use SHA224
- *
- * \return         0 if successful, 1 if fopen failed,
- *                 or 2 if fread failed
- */
-int sha2_file( char *path, unsigned char output[32], int is224 );
-#endif
-/**
- * \brief          SHA-256 HMAC context setup
- *
- * \param ctx      HMAC context to be initialized
- * \param key      HMAC secret key
- * \param keylen   length of the HMAC key
- * \param is224    0 = use SHA256, 1 = use SHA224
- */
-void sha2_hmac_starts( sha2_context *ctx, unsigned char *key, int keylen,
-                       int is224 );
-
-/**
- * \brief          SHA-256 HMAC process buffer
- *
- * \param ctx      HMAC context
- * \param input    buffer holding the  data
- * \param ilen     length of the input data
- */
-void sha2_hmac_update( sha2_context *ctx, unsigned char *input, int ilen );
-
-/**
- * \brief          SHA-256 HMAC final digest
- *
- * \param ctx      HMAC context
- * \param output   SHA-224/256 HMAC checksum result
- */
-void sha2_hmac_finish( sha2_context *ctx, unsigned char output[32] );
-
-/**
- * \brief          Output = HMAC-SHA-256( hmac key, input buffer )
- *
- * \param key      HMAC secret key
- * \param keylen   length of the HMAC key
- * \param input    buffer holding the  data
- * \param ilen     length of the input data
- * \param output   HMAC-SHA-224/256 result
- * \param is224    0 = use SHA256, 1 = use SHA224
- */
-void sha2_hmac( unsigned char *key, int keylen,
-                unsigned char *input, int ilen,
-                unsigned char output[32], int is224 );
-
-/**
- * \brief          Checkup routine
- *
- * \return         0 if successful, or 1 if the test failed
- */
-int sha2_self_test( int verbose );
-
-typedef	struct _WPISMS4HEADER {
-	uint8		keyIdx;
-	uint8		reserved;
-	uint8		pn[WAPI_PN_LEN];
-	uint8		data[0];
-}	wpiSMS4Hdr;
-
-//extern unsigned short	rtl_SMS4_rxSeq[RX_QUEUE_NUM];
-/*
-* output = HMAC-SHA-256 ( hmac key, input buffer )
-*/
-void sha256_hmac( unsigned char *key, int keylen,
-                unsigned char *input, int ilen,
-                unsigned char *output, int hlen);
-
-void KD_hmac_sha256( unsigned char *key, int keylen,
-                unsigned char *input, int ilen,
-                unsigned char *output, int hlen);
-
-void WapiSMS4ForMNKEncrypt(uint8 *key, uint8*IV, uint8*input, uint32 inputLength, uint8 *output, uint8 *outputLength, uint32 CryptFlag);
-void GenerateRandomData(unsigned char * data, unsigned int len);
-int32 init_SMS4_CK_Sbox(void);
-
-void SecSWSMS4Encryption(struct rtl8192cd_priv	*priv, struct tx_insn* txcfg);
-int32 SecSWSMS4Decryption(struct rtl8192cd_priv	*priv, struct stat_info *pstat, struct rx_frinfo* pfrinfo);
-#endif	/*	WAPICRYPTO_H	*/
+#ifndef	WAPICRYPTO_H
+#define	WAPICRYPTO_H	1
+
+#define		ENCRYPT		0     
+#define		DECRYPT		1
+
+/**
+ * \brief          SHA-256 context structure
+ */
+typedef struct
+{
+    unsigned long total[2];     /*!< number of bytes processed  */
+    unsigned long state[8];     /*!< intermediate digest state  */
+    unsigned char buffer[64];   /*!< data block being processed */
+
+    unsigned char ipad[64];     /*!< HMAC: inner padding        */
+    unsigned char opad[64];     /*!< HMAC: outer padding        */
+    int is224;                  /*!< 0 => SHA-256, else SHA-224 */
+}
+sha2_context;
+
+/**
+ * \brief          SHA-256 context setup
+ *
+ * \param ctx      context to be initialized
+ * \param is224    0 = use SHA256, 1 = use SHA224
+ */
+void sha2_starts( sha2_context *ctx, int is224 );
+
+/**
+ * \brief          SHA-256 process buffer
+ *
+ * \param ctx      SHA-256 context
+ * \param input    buffer holding the  data
+ * \param ilen     length of the input data
+ */
+void sha2_update( sha2_context *ctx, unsigned char *input, int ilen );
+
+/**
+ * \brief          SHA-256 final digest
+ *
+ * \param ctx      SHA-256 context
+ * \param output   SHA-224/256 checksum result
+ */
+void sha2_finish( sha2_context *ctx, unsigned char output[32] );
+
+/**
+ * \brief          Output = SHA-256( input buffer )
+ *
+ * \param input    buffer holding the  data
+ * \param ilen     length of the input data
+ * \param output   SHA-224/256 checksum result
+ * \param is224    0 = use SHA256, 1 = use SHA224
+ */
+void sha2( unsigned char *input, int ilen,
+           unsigned char output[32], int is224 );
+
+#if 0
+/**
+ * \brief          Output = SHA-256( file contents )
+ *
+ * \param path     input file name
+ * \param output   SHA-224/256 checksum result
+ * \param is224    0 = use SHA256, 1 = use SHA224
+ *
+ * \return         0 if successful, 1 if fopen failed,
+ *                 or 2 if fread failed
+ */
+int sha2_file( char *path, unsigned char output[32], int is224 );
+#endif
+/**
+ * \brief          SHA-256 HMAC context setup
+ *
+ * \param ctx      HMAC context to be initialized
+ * \param key      HMAC secret key
+ * \param keylen   length of the HMAC key
+ * \param is224    0 = use SHA256, 1 = use SHA224
+ */
+void sha2_hmac_starts( sha2_context *ctx, unsigned char *key, int keylen,
+                       int is224 );
+
+/**
+ * \brief          SHA-256 HMAC process buffer
+ *
+ * \param ctx      HMAC context
+ * \param input    buffer holding the  data
+ * \param ilen     length of the input data
+ */
+void sha2_hmac_update( sha2_context *ctx, unsigned char *input, int ilen );
+
+/**
+ * \brief          SHA-256 HMAC final digest
+ *
+ * \param ctx      HMAC context
+ * \param output   SHA-224/256 HMAC checksum result
+ */
+void sha2_hmac_finish( sha2_context *ctx, unsigned char output[32] );
+
+/**
+ * \brief          Output = HMAC-SHA-256( hmac key, input buffer )
+ *
+ * \param key      HMAC secret key
+ * \param keylen   length of the HMAC key
+ * \param input    buffer holding the  data
+ * \param ilen     length of the input data
+ * \param output   HMAC-SHA-224/256 result
+ * \param is224    0 = use SHA256, 1 = use SHA224
+ */
+void sha2_hmac( unsigned char *key, int keylen,
+                unsigned char *input, int ilen,
+                unsigned char output[32], int is224 );
+
+/**
+ * \brief          Checkup routine
+ *
+ * \return         0 if successful, or 1 if the test failed
+ */
+int sha2_self_test( int verbose );
+
+typedef	struct _WPISMS4HEADER {
+	uint8		keyIdx;
+	uint8		reserved;
+	uint8		pn[WAPI_PN_LEN];
+	uint8		data[0];
+}	wpiSMS4Hdr;
+
+//extern unsigned short	rtl_SMS4_rxSeq[RX_QUEUE_NUM];
+/*
+* output = HMAC-SHA-256 ( hmac key, input buffer )
+*/
+void sha256_hmac( unsigned char *key, int keylen,
+                unsigned char *input, int ilen,
+                unsigned char *output, int hlen);
+
+void KD_hmac_sha256( unsigned char *key, int keylen,
+                unsigned char *input, int ilen,
+                unsigned char *output, int hlen);
+
+void WapiSMS4ForMNKEncrypt(uint8 *key, uint8*IV, uint8*input, uint32 inputLength, uint8 *output, uint8 *outputLength, uint32 CryptFlag);
+void GenerateRandomData(unsigned char * data, unsigned int len);
+int32 init_SMS4_CK_Sbox(void);
+int32 SecSWSMS4Decryption(struct rtl8192cd_priv	*priv, struct stat_info *pstat, struct rx_frinfo* pfrinfo);
+#endif	/*	WAPICRYPTO_H	*/
diff --git a/drivers/net/wireless/rtl8192cd/wapi_wai.h b/drivers/net/wireless/rtl8192cd/wapi_wai.h
index c6a6fb4..3aa05b9 100644
--- a/drivers/net/wireless/rtl8192cd/wapi_wai.h
+++ b/drivers/net/wireless/rtl8192cd/wapi_wai.h
@@ -141,7 +141,8 @@ typedef enum __WAPI_AE_STATE {
 typedef	struct	__wapiStaInfo {
 	uint8			asueWapiIE[256];
 	uint8			waiASUEChallange[WAPI_N_LEN];
-	uint8			waiAEChallange[WAPI_N_LEN];
+	uint8			waiAEChallange[WAPI_N_LEN];	
+	uint8			waiAEChallangeNext[WAPI_N_LEN];
 	uint8			waiAuthFlag[WAPI_N_LEN];
 	uint8			asueWapiIELength;
 	uint8			wapiRxFragSeq;
diff --git a/drivers/net/wireless/rtl8192cd/wifi.h b/drivers/net/wireless/rtl8192cd/wifi.h
index 7ae0d09..410a578 100644
--- a/drivers/net/wireless/rtl8192cd/wifi.h
+++ b/drivers/net/wireless/rtl8192cd/wifi.h
@@ -27,6 +27,7 @@
 #define WLAN_CRC_LEN		4
 #define WLAN_BSSID_LEN		6
 #define WLAN_BSS_TS_LEN		8
+#define WLAN_HDR_PSPOLL	16
 #define WLAN_HDR_A3_LEN		24
 #define WLAN_HDR_A4_LEN		30
 #define WLAN_HDR_A3_QOS_LEN	26
@@ -189,6 +190,21 @@ enum WIFI_FRAME_SUBTYPE {
 
 };
 
+
+#ifdef P2P_SUPPORT
+#define CATEGORY_P2P_PUBLIC_ACTION  		4 	
+#define ACTIONY_P2P_PUBLIC_ACTION  			9 	
+#define	_P2P_PUBLIC_ACTION_FIELD_			9		
+#define _P2P_PUBLIC_ACTION_IE_OFFSET_		8
+#define _P2P_ACTION_IE_OFFSET_				7
+#define _P2P_IE_							221
+#define _SUPPORTED_RATES_NO_CCK_ 			2
+
+
+#endif
+
+
+
 #ifdef CONFIG_RTK_MESH
 
 // mesh action field
@@ -324,6 +340,9 @@ enum WIFI_REG_DOMAIN {
 	DOMAIN_MKK1		= 8,
 	DOMAIN_MKK2		= 9,
 	DOMAIN_MKK3		= 10,
+	DOMAIN_NCC		= 11,
+	DOMAIN_RUSSIAN	= 12,
+	DOMAIN_CN		= 13,
 	DOMAIN_MAX
 };
 
@@ -464,6 +483,11 @@ enum WIFI_REG_DOMAIN {
 
 #define GetTid(pbuf)	(cpu_to_le16(*(unsigned short *)((unsigned int)(pbuf) + (((GetToDs(pbuf)<<1)|GetFrDs(pbuf))==3?30:24))) & 0x000f)
 
+#define SetPsPollAid(pbuf, aid)  \
+	do {    \
+		*(unsigned short *)((unsigned int)(pbuf) + 2) |= cpu_to_le16(0xffff & (aid|0xc000)); \
+	} while(0)
+
 //WIFI_WMM
 #define GetQOSackPolicy(pbuf)	((cpu_to_le16(*(unsigned short *)((unsigned int)(pbuf) + (((GetToDs(pbuf)<<1)|GetFrDs(pbuf))==3?30:24))) & 0x0060)>>5)
 
@@ -619,7 +643,7 @@ enum WIFI_REG_DOMAIN {
 #define _ADDBA_Req_ACTION_ID_		0
 #define _ADDBA_Rsp_ACTION_ID_		1
 #define _DELBA_ACTION_ID_			2
-
+#define _VENDOR_ACTION_ID_			0x7f	// add for P2P_SUPPORT
 
 /*-----------------------------------------------------------------------------
 			Below is for HT related definition
diff --git a/drivers/pcmcia/yenta_socket.c b/drivers/pcmcia/yenta_socket.c
index f728a45..6627f95 100644
--- a/drivers/pcmcia/yenta_socket.c
+++ b/drivers/pcmcia/yenta_socket.c
@@ -1236,20 +1236,20 @@ static int yenta_dev_suspend_noirq(struct device *dev)
 	if (!socket)
 		return ret;
 
-	if (socket->type && socket->type->save_state)
-		socket->type->save_state(socket);
+		if (socket->type && socket->type->save_state)
+			socket->type->save_state(socket);
 
 	pci_save_state(pdev);
 	pci_read_config_dword(pdev, 16*4, &socket->saved_state[0]);
 	pci_read_config_dword(pdev, 17*4, &socket->saved_state[1]);
 	pci_disable_device(pdev);
 
-	/*
-	 * Some laptops (IBM T22) do not like us putting the Cardbus
-	 * bridge into D3.  At a guess, some other laptop will
-	 * probably require this, so leave it commented out for now.
-	 */
-	/* pci_set_power_state(dev, 3); */
+		/*
+		 * Some laptops (IBM T22) do not like us putting the Cardbus
+		 * bridge into D3.  At a guess, some other laptop will
+		 * probably require this, so leave it commented out for now.
+		 */
+		/* pci_set_power_state(dev, 3); */
 
 	return ret;
 }
@@ -1272,8 +1272,8 @@ static int yenta_dev_resume_noirq(struct device *dev)
 
 	pci_set_master(pdev);
 
-	if (socket->type && socket->type->restore_state)
-		socket->type->restore_state(socket);
+		if (socket->type && socket->type->restore_state)
+			socket->type->restore_state(socket);
 
 	return pcmcia_socket_dev_resume(dev);
 }
diff --git a/drivers/platform/x86/thinkpad_acpi.c b/drivers/platform/x86/thinkpad_acpi.c
index 7cd6d11..85b8e95 100644
--- a/drivers/platform/x86/thinkpad_acpi.c
+++ b/drivers/platform/x86/thinkpad_acpi.c
@@ -5876,8 +5876,8 @@ static int __init brightness_init(struct ibm_init_struct *iibm)
 	if (brightness_mode == TPACPI_BRGHT_MODE_AUTO ||
 	    brightness_mode == TPACPI_BRGHT_MODE_MAX) {
 		if (quirks & TPACPI_BRGHT_Q_EC)
-			brightness_mode = TPACPI_BRGHT_MODE_ECNVRAM;
-		else
+				brightness_mode = TPACPI_BRGHT_MODE_ECNVRAM;
+			else
 			brightness_mode = TPACPI_BRGHT_MODE_UCMS_STEP;
 
 		dbg_printk(TPACPI_DBG_BRGHT,
diff --git a/drivers/scsi/libsas/sas_port.c b/drivers/scsi/libsas/sas_port.c
index fe8b74c..1cdcb93 100644
--- a/drivers/scsi/libsas/sas_port.c
+++ b/drivers/scsi/libsas/sas_port.c
@@ -81,10 +81,10 @@ static void sas_form_port(struct asd_sas_phy *phy)
 				&& port->num_phys == 0) {
 				memcpy(port->sas_addr, phy->sas_addr,
 					SAS_ADDR_SIZE);
-				break;
-			}
-			spin_unlock(&port->phy_list_lock);
+			break;
 		}
+		spin_unlock(&port->phy_list_lock);
+	}
 	}
 
 	if (i >= sas_ha->num_phys) {
diff --git a/drivers/scsi/mpt2sas/mpt2sas_scsih.c b/drivers/scsi/mpt2sas/mpt2sas_scsih.c
index 7dacc68..c0666c3 100644
--- a/drivers/scsi/mpt2sas/mpt2sas_scsih.c
+++ b/drivers/scsi/mpt2sas/mpt2sas_scsih.c
@@ -4238,7 +4238,7 @@ _scsih_sas_pd_add(struct MPT2SAS_ADAPTER *ioc,
 	    le16_to_cpu(sas_device_pg0.ParentDevHandle),
 	    handle, sas_device_pg0.PhyNum, MPI2_SAS_NEG_LINK_RATE_1_5);
 
-	_scsih_add_device(ioc, handle, 0, 1);
+		_scsih_add_device(ioc, handle, 0, 1);
 }
 
 #ifdef CONFIG_SCSI_MPT2SAS_LOGGING
@@ -4355,12 +4355,12 @@ _scsih_sas_ir_config_change_event(struct MPT2SAS_ADAPTER *ioc, u8 VF_ID,
 		case MPI2_EVENT_IR_CHANGE_RC_VOLUME_CREATED:
 		case MPI2_EVENT_IR_CHANGE_RC_ADDED:
 			if (!foreign_config)
-				_scsih_sas_volume_add(ioc, element);
+			_scsih_sas_volume_add(ioc, element);
 			break;
 		case MPI2_EVENT_IR_CHANGE_RC_VOLUME_DELETED:
 		case MPI2_EVENT_IR_CHANGE_RC_REMOVED:
 			if (!foreign_config)
-				_scsih_sas_volume_delete(ioc, element);
+			_scsih_sas_volume_delete(ioc, element);
 			break;
 		case MPI2_EVENT_IR_CHANGE_RC_PD_CREATED:
 			_scsih_sas_pd_hide(ioc, element);
@@ -4527,7 +4527,7 @@ _scsih_sas_ir_physical_disk_event(struct MPT2SAS_ADAPTER *ioc, u8 VF_ID,
 		    le16_to_cpu(sas_device_pg0.ParentDevHandle),
 		    handle, sas_device_pg0.PhyNum, MPI2_SAS_NEG_LINK_RATE_1_5);
 
-		_scsih_add_device(ioc, handle, 0, 1);
+			_scsih_add_device(ioc, handle, 0, 1);
 
 		break;
 
diff --git a/drivers/scsi/sym53c8xx_2/sym_hipd.c b/drivers/scsi/sym53c8xx_2/sym_hipd.c
index e9e1865..025e3a3 100644
--- a/drivers/scsi/sym53c8xx_2/sym_hipd.c
+++ b/drivers/scsi/sym53c8xx_2/sym_hipd.c
@@ -2313,8 +2313,8 @@ static void sym_int_par (struct sym_hcb *np, u_short sist)
 	struct sym_ccb *cp	= sym_ccb_from_dsa(np, dsa);
 
 	if (printk_ratelimit())
-		printf("%s: SCSI parity error detected: SCR1=%d DBC=%x SBCL=%x\n",
-			sym_name(np), hsts, dbc, sbcl);
+	printf("%s: SCSI parity error detected: SCR1=%d DBC=%x SBCL=%x\n",
+		sym_name(np), hsts, dbc, sbcl);
 
 	/*
 	 *  Check that the chip is connected to the SCSI BUS.
diff --git a/drivers/serial/8250.c b/drivers/serial/8250.c
index d26f4df..e8ee987 100644
--- a/drivers/serial/8250.c
+++ b/drivers/serial/8250.c
@@ -177,7 +177,7 @@ static const struct serial8250_config uart_config[] = {
 		.fifo_size	= 64,
 		.tx_loadsz	= 32,
 		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_01 |
-				  UART_FCR_T_TRIG_10,
+				UART_FCR_T_TRIG_10,
 		.flags		= UART_CAP_FIFO | UART_CAP_EFR | UART_CAP_SLEEP,
 #else
 		.fifo_size	= 16,
@@ -395,7 +395,7 @@ static void serial8250_set_sleep(struct uart_8250_port *p, int sleep)
 			serial_out(p, UART_LCR, 0xBF);
 			serial_out(p, UART_EFR, 0);
 			serial_out(p, UART_LCR, 0);
-}
+		}
 	}
 }
 
@@ -1133,11 +1133,11 @@ static int serial8250_startup(struct uart_port *port)
 	serial_out(up, UART_LCR, UART_LCR_WLEN8);
 
 	spin_lock_irqsave(&up->port.lock, flags);
-		/*
-		 * Most PC uarts need OUT2 raised to enable interrupts.
-		 */
-		if (is_real_interrupt(up->port.irq))
-			up->port.mctrl |= TIOCM_OUT2;
+    /*
+	 * Most PC uarts need OUT2 raised to enable interrupts.
+	 */
+    if (is_real_interrupt(up->port.irq))
+      up->port.mctrl |= TIOCM_OUT2;
 
 	serial8250_set_mctrl(&up->port, up->port.mctrl);
 
@@ -1212,7 +1212,7 @@ static void serial8250_shutdown(struct uart_port *port)
 	serial_out(up, UART_IER, 0);
 
 	spin_lock_irqsave(&up->port.lock, flags);
-		up->port.mctrl &= ~TIOCM_OUT2;
+    up->port.mctrl &= ~TIOCM_OUT2;
 
 	serial8250_set_mctrl(&up->port, up->port.mctrl);
 	spin_unlock_irqrestore(&up->port.lock, flags);
@@ -1398,10 +1398,10 @@ serial8250_set_termios(struct uart_port *port, struct ktermios *termios,
 
 	serial_out(up, UART_LCR, cval);		/* reset DLAB */
 	up->lcr = cval;					/* Save LCR */
-		if (fcr & UART_FCR_ENABLE_FIFO) {
-			/* emulated UARTs (Lucent Venus 167x) need two steps */
+    if (fcr & UART_FCR_ENABLE_FIFO) {
+      /* emulated UARTs (Lucent Venus 167x) need two steps */
       serial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO);
-	}
+    }
     serial_out(up, UART_FCR, fcr);		/* set fcr */
 
 	serial8250_set_mctrl(&up->port, up->port.mctrl);
diff --git a/drivers/serial/Kconfig b/drivers/serial/Kconfig
index 6e3fc4e..d976fa4 100644
--- a/drivers/serial/Kconfig
+++ b/drivers/serial/Kconfig
@@ -140,7 +140,7 @@ config SERIAL_SC16IS7X0
 choice
 	prompt "Crystal for SC16IS7x0 XTAL1"
 	depends on SERIAL_SC16IS7X0
-	help
+	help 
 		Crystal for SC16IS7x0 XTAL1. 
 		This is factor of baudrate, so bad parameter will cause UART to be 
 		abnormal.
diff --git a/drivers/staging/Kconfig b/drivers/staging/Kconfig
index 9818b06..11a4012 100644
--- a/drivers/staging/Kconfig
+++ b/drivers/staging/Kconfig
@@ -41,6 +41,8 @@ config STAGING_EXCLUDE_BUILD
 
 if !STAGING_EXCLUDE_BUILD
 
+source "drivers/staging/rtk_uWiFi/Kconfig"
+
 source "drivers/staging/et131x/Kconfig"
 
 source "drivers/staging/slicoss/Kconfig"
diff --git a/drivers/staging/Makefile b/drivers/staging/Makefile
index e772479..13fefc1 100644
--- a/drivers/staging/Makefile
+++ b/drivers/staging/Makefile
@@ -2,7 +2,7 @@
 
 # fix for build system bug...
 obj-$(CONFIG_STAGING)		+= staging.o
-
+obj-$(CONFIG_USB_UWIFI_HOST)	+= rtk_uWiFi/
 obj-$(CONFIG_ET131X)		+= et131x/
 obj-$(CONFIG_SLICOSS)		+= slicoss/
 obj-$(CONFIG_SXG)		+= sxg/
diff --git a/drivers/staging/rt2870/rt_linux.h b/drivers/staging/rt2870/rt_linux.h
index 49ad37f..74f7e6c 100644
--- a/drivers/staging/rt2870/rt_linux.h
+++ b/drivers/staging/rt2870/rt_linux.h
@@ -188,7 +188,7 @@ struct os_lock  {
 struct os_cookie {
 
 #ifdef RT2870
-	struct usb_device		*pUsb_Dev;
+	struct usb_device	*pUsb_Dev;
 
 	THREAD_PID				MLMEThr_pid;
 	THREAD_PID				RTUSBCmdThr_pid;
diff --git a/drivers/usb/Kconfig b/drivers/usb/Kconfig
index 31cb18e..88eb47c 100644
--- a/drivers/usb/Kconfig
+++ b/drivers/usb/Kconfig
@@ -122,7 +122,8 @@ source "drivers/usb/misc/Kconfig"
 
 source "drivers/usb/atm/Kconfig"
 
-source "drivers/usb/gadget/Kconfig"
+#source "drivers/usb/gadget/Kconfig"
+source "drivers/usb/gadget_cathy/Kconfig"
 
 source "drivers/usb/otg/Kconfig"
 
diff --git a/drivers/usb/Makefile b/drivers/usb/Makefile
index b4969ad..043c379 100644
--- a/drivers/usb/Makefile
+++ b/drivers/usb/Makefile
@@ -4,10 +4,27 @@
 
 # Object files in subdirectories
 
+ifeq ($(CONFIG_USB_UWIFI_HOST),y)
+obj-$(CONFIG_USB)		+= core_uWiFi/
+else
 obj-$(CONFIG_USB)		+= core/
+endif
 
 obj-$(CONFIG_USB_MON)		+= mon/
 
+ifeq ($(CONFIG_USB_UWIFI_HOST),y)
+obj-$(CONFIG_PCI)		+= host_uWiFi/
+obj-$(CONFIG_USB_EHCI_HCD)	+= host_uWiFi/
+obj-$(CONFIG_USB_ISP116X_HCD)	+= host_uWiFi/
+obj-$(CONFIG_USB_OHCI_HCD)	+= host_uWiFi/
+obj-$(CONFIG_USB_UHCI_HCD)	+= host_uWiFi/
+obj-$(CONFIG_USB_FHCI_HCD)	+= host_uWiFi/
+obj-$(CONFIG_USB_SL811_HCD)	+= host_uWiFi/
+obj-$(CONFIG_USB_U132_HCD)	+= host_uWiFi/
+obj-$(CONFIG_USB_R8A66597_HCD)	+= host_uWiFi/
+obj-$(CONFIG_USB_HWA_HCD)	+= host_uWiFi/
+obj-$(CONFIG_USB_ISP1760_HCD)	+= host_uWiFi/
+else
 obj-$(CONFIG_PCI)		+= host/
 obj-$(CONFIG_USB_EHCI_HCD)	+= host/
 obj-$(CONFIG_USB_ISP116X_HCD)	+= host/
@@ -19,10 +36,10 @@ obj-$(CONFIG_USB_U132_HCD)	+= host/
 obj-$(CONFIG_USB_R8A66597_HCD)	+= host/
 obj-$(CONFIG_USB_HWA_HCD)	+= host/
 obj-$(CONFIG_USB_ISP1760_HCD)	+= host/
+endif
 
 obj-$(CONFIG_USB_C67X00_HCD)	+= c67x00/
 
-obj-$(CONFIG_DWC_OTG)       += dwc_otg/
 obj-$(CONFIG_USB_WUSB)		+= wusbcore/
 
 obj-$(CONFIG_USB_ACM)		+= class/
@@ -30,9 +47,13 @@ obj-$(CONFIG_USB_PRINTER)	+= class/
 obj-$(CONFIG_USB_WDM)		+= class/
 obj-$(CONFIG_USB_TMC)		+= class/
 
+ifeq ($(CONFIG_USB_UWIFI_HOST),y)
+obj-$(CONFIG_USB_STORAGE)	+= storage_uWiFi/
+obj-$(CONFIG_USB)		+= storage_uWiFi/
+else
 obj-$(CONFIG_USB_STORAGE)	+= storage/
 obj-$(CONFIG_USB)		+= storage/
-
+endif
 obj-$(CONFIG_USB_MDC800)	+= image/
 obj-$(CONFIG_USB_MICROTEK)	+= image/
 
@@ -42,3 +63,9 @@ obj-$(CONFIG_USB)		+= misc/
 
 obj-$(CONFIG_USB_ATM)		+= atm/
 obj-$(CONFIG_USB_SPEEDTOUCH)	+= atm/
+
+obj-$(CONFIG_DWC_OTG)       += dwc_otg/
+
+#wei add for otg device mode
+obj-$(CONFIG_USB_GADGET)	+= gadget_cathy/
+
diff --git a/drivers/usb/c67x00/c67x00-hcd.h b/drivers/usb/c67x00/c67x00-hcd.h
index e8c6d94..2bf4935 100644
--- a/drivers/usb/c67x00/c67x00-hcd.h
+++ b/drivers/usb/c67x00/c67x00-hcd.h
@@ -28,7 +28,13 @@
 #include <linux/spinlock.h>
 #include <linux/list.h>
 #include <linux/usb.h>
+
+#if defined(CONFIG_USB_UWIFI_HOST)
+#include "../core_uWiFi/hcd.h"
+#else
 #include "../core/hcd.h"
+#endif
+
 #include "c67x00.h"
 
 /*
diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 096badf..820a5e3 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -1120,12 +1120,12 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 	if (uurb->buffer_length > 0) {
 		as->urb->transfer_buffer = kmalloc(uurb->buffer_length,
 				GFP_KERNEL);
-		if (!as->urb->transfer_buffer) {
-			kfree(isopkt);
-			kfree(dr);
-			free_async(as);
-			return -ENOMEM;
-		}
+	if (!as->urb->transfer_buffer) {
+		kfree(isopkt);
+		kfree(dr);
+		free_async(as);
+		return -ENOMEM;
+	}
 	}
 	as->urb->dev = ps->dev;
 	as->urb->pipe = (uurb->type << 30) |
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index efcd940..e165ba2 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -262,7 +262,7 @@ static void led_work (struct work_struct *work)
 
 		/* 30%-50% duty cycle */
 
-		switch (hub->indicator[i]) {
+		switch (hub->indicator[i]) {			
 		/* cycle marker */
 		case INDICATOR_CYCLE:
 			cursor = i;
@@ -532,7 +532,7 @@ int usb_hub_clear_tt_buffer(struct urb *urb)
 			: (USB_ENDPOINT_XFER_BULK << 11);
 	if (usb_pipein (pipe))
 		clear->devinfo |= 1 << 15;
-
+	
 	/* info for completion callback */
 	clear->hcd = bus_to_hcd(udev->bus);
 	clear->ep = urb->ep;
@@ -1443,7 +1443,7 @@ void usb_disconnect(struct usb_device **pdev)
 	REG32(PABCD_DIR) = REG32(PABCD_DIR) |(0x1<<USB_LED_OFFSET);
 	REG32(PABCD_DAT) = REG32(PABCD_DAT) | (0x1<<USB_LED_OFFSET);
 	dev_info (&udev->dev, "USB disconnect, address %d\n", udev->devnum);
-
+	
 	
 	usb_lock_device(udev);
 
@@ -1786,17 +1786,24 @@ static unsigned hub_is_wusb(struct usb_hub *hub)
 	return hcd->wireless;
 }
 
-
+#ifdef CONFIG_RTL_USB_OTG
+#define PORT_RESET_TRIES	5
+#else
 #define PORT_RESET_TRIES	20
+#endif
 #define SET_ADDRESS_TRIES	2
 #define GET_DESCRIPTOR_TRIES	2
 #define SET_CONFIG_TRIES	(2 * (use_both_schemes + 1))
 #define USE_NEW_SCHEME(i)	((i) / 2 == old_scheme_first)
 
+#ifdef CONFIG_RTL_USB_OTG
+#define HUB_ROOT_RESET_TIME	50	/* times are in msec */
+#else
 #define HUB_ROOT_RESET_TIME	500	/* times are in msec */
+#endif
 #define HUB_SHORT_RESET_TIME	10
-#define HUB_LONG_RESET_TIME	2000
-#define HUB_RESET_TIMEOUT	10000
+#define HUB_LONG_RESET_TIME	200
+#define HUB_RESET_TIMEOUT	500
 static int hub_port_wait_reset(struct usb_hub *hub, int port1,
 				struct usb_device *udev, unsigned int delay)
 {
@@ -1860,10 +1867,10 @@ static int hub_port_reset(struct usb_hub *hub, int port1,
 	int i, status;
 	unsigned char retry=3;  //realtek patch, if failed, retry 3 times
 	/* Block EHCI CF initialization during the port reset.
-	 * Some companion controllers don't like it when they mix.
-	 */
-	down_read(&ehci_cf_port_reset_rwsem);
-
+         * Some companion controllers don't like it when they mix.
+         */
+        down_read(&ehci_cf_port_reset_rwsem);
+	
 	/* Reset the port */
 	for (i = 0; i < PORT_RESET_TRIES; i++) {
 		status = set_port_feature(hub->hdev,
diff --git a/drivers/usb/dwc_otg/Kconfig b/drivers/usb/dwc_otg/Kconfig
index fe5415a..6c1d88a 100644
--- a/drivers/usb/dwc_otg/Kconfig
+++ b/drivers/usb/dwc_otg/Kconfig
@@ -19,4 +19,57 @@ config DWC_OTG_DEVICE_ONLY
 config RTL_OTGCTRL
         bool "Enable Realtek usb auto_det control circuit"
         
+config RTL_USB_OTG
+	bool
+	default y if DWC_OTG        
 
+config RTL_ULINKER_USB_SUPPORT
+	bool "Realtek Universal Linker USB support"
+	depends on DWC_OTG
+	#select COMPAT_NET_DEV_OPS
+	#select RTK_VLAN_SUPPORT
+	#select RTK_VLAN_NEW_FEATURE
+	select SCSI
+	select SCSI_PROC_FS
+	select BLK_DEV_SD
+	select SCSI_LOWLEVEL
+	select USB_ANNOUNCE_NEW_DEVICES
+	select USB_DEVICE_CLASS
+	select USB_MON
+	select USB_EHCI_HCD
+	select USB_EHCI_ROOT_HUB_TT
+	select USB_OHCI_HCD
+	select USB_STORAGE
+	select USB_GADGET
+	#select USB_GADGET_VBUS_DRAW="2"
+	select USB_GADGET_SELECTED
+	select USB_OTG_RTL8672
+	select USB_OTG_DEVICE_RTL8672
+	select USB_GADGET_DUALSPEED
+	select USB_ETH
+	select USB_ETH_RNDIS
+	select USB
+	select USB_DEBUG
+	#### power saving
+	select ARCH_CPU_SLEEP
+	select USB_FILE_STORAGE
+
+## for init wlan driver by echo proc
+#config RTL_ULINKER_WLAN_DELAY_INIT
+#	bool
+#	default y if RTL_ULINKER_USB_SUPPORT
+
+## for mode switch
+config RTL_ULINKER_GADGET
+	bool
+	default y if RTL_ULINKER_USB_SUPPORT
+
+## for echo mac address
+config RTL_ULINKER_OTG_MACADDR
+	bool
+	default y if RTL_ULINKER_USB_SUPPORT
+
+## for domain name query
+config RTL_ULINKER_DNS
+	bool
+	default y if RTL_ULINKER_USB_SUPPORT
diff --git a/drivers/usb/dwc_otg/Makefile b/drivers/usb/dwc_otg/Makefile
index 54140d0..83c826d 100644
--- a/drivers/usb/dwc_otg/Makefile
+++ b/drivers/usb/dwc_otg/Makefile
@@ -39,6 +39,7 @@ endif
 obj-y	+= lm.o
 #obj-y	+= dwc_otg.o 
 
-obj-y	+= rtk_otg_autodet.o
+obj-$(CONFIG_RTL_OTGCTRL)	+= rtk_otg_autodet.o
+
 clean:
 	rm -rf   *.o *.ko .*cmd *.mod.c .tmp_versions
\ No newline at end of file
diff --git a/drivers/usb/dwc_otg/dwc_otg_driver.c b/drivers/usb/dwc_otg/dwc_otg_driver.c
index 22321bd..4a79c85 100644
--- a/drivers/usb/dwc_otg/dwc_otg_driver.c
+++ b/drivers/usb/dwc_otg/dwc_otg_driver.c
@@ -1090,12 +1090,24 @@ unsigned int Get_IDDIG_Level()
 Enable_AutoDetectionCircuit(int en)
 {
 	#define SYS_OTG_CONTROL 0xb8000098 
+	#define SYS_PIN_MUX 0xb8000040 
 	if(en==1)	
-	{	REG32(SYS_OTG_CONTROL) |=  (1<<0);  //active_otgctrl=1, enable elvis auto-det circuit	
+	{	
+		unsigned int r;
+		REG32(SYS_PIN_MUX) &= ~(0x7);   //bit [2:0]=0
+
+		REG32(SYS_OTG_CONTROL) |=  (1<<0);  //active_otgctrl=1, enable elvis auto-det circuit	
+	
+		r=REG32(SYS_OTG_CONTROL);
+		r = r  &~((0xf<<6)|(0xf<<10)|(0x7<<14));  //clear
+		REG32(SYS_OTG_CONTROL) = r| (10<<6)|(10<<10)|(4<<14);     //setting
+		
+		REG32(SYS_OTG_CONTROL) |=  (1<<5);  //OTGCMP_EN=1
 		REG32(SYS_OTG_CONTROL) |=  (1<<1);  //start
 	}
 	else
 	{	REG32(SYS_OTG_CONTROL) &= ~(1<<1);  //stop	
+		REG32(SYS_OTG_CONTROL) &= ~(1<<5);  //OTGCMP_EN=0
 		REG32(SYS_OTG_CONTROL) &= ~(1<<0);  //active_otgctrl=0 , disable elvis auto-det circuit		
 	}
 }
@@ -1154,6 +1166,8 @@ int otg_reset_procedure(int mode)
 	gHostMode=mode;
 	if(gHostMode==1)	Set_IDDIG_Level(1,0);	 // 1:device 0:host
 	else					Set_IDDIG_Level(1,1);	 // 1:device 0:host
+#elif defined(CONFIG_RTL_ULINKER)
+	gHostMode=1-Get_IDDIG_Level();
 #else	//auto-det ckt decide iddig
     #if 0  //1: internal enable auto-det,
 	Enable_AutoDetectionCircuit(1);
@@ -1162,7 +1176,7 @@ int otg_reset_procedure(int mode)
 	gHostMode=1-Get_IDDIG_Level();
 #endif
 //----------------------------------------
-#if 0  //
+#if 1 //
 	Set_SelUSBPort(2);  // pass 1: is one port, other value is 2port
 #else  //dynamic get
 	if(Get_SelUSBPort()==1)
@@ -1223,7 +1237,12 @@ int  dwc_otg_driver_init(void)
 #if 1  //for 8196D
 	printk("-------8196D OTG init \n");
 //	otg_proc_init();	
+
+#if defined(CONFIG_RTL_ULINKER)
 	int rc=otg_reset_procedure(0);
+#else
+	int rc=otg_reset_procedure(1);
+#endif
 	if(rc)
 	{	printk("OTG: reset procedure init fail \n");
 		return rc;
@@ -1335,8 +1354,10 @@ int  dwc_otg_driver_init(void)
 	lmdev->resource.start = OTG_BASE;		//base of OTG, 0xb8030000
 	lmdev->resource.end = lmdev->resource.start + 0x0003ffff;	
 	lmdev->resource.flags = IORESOURCE_MEM;
-#define USB_D_IRQ             11   //wei add ,11	
-	lmdev->irq = USB_D_IRQ;	//irq of usb device
+//#define USB_D_IRQ             11   //wei add ,11	
+//	lmdev->irq = USB_D_IRQ;	//irq of usb device
+	lmdev->irq = BSP_OTG_IRQ;	//irq of usb device
+	
 	lmdev->id = 0;
 
 	lm_device_register(lmdev);
@@ -1391,7 +1412,7 @@ int  dwc_otg_driver_init(void)
   return retval;
 
 }
-#ifndef CONFIG_RTL_OTGCTRL
+#if !defined(CONFIG_RTL_OTGCTRL) && !defined(CONFIG_RTL_ULINKER)
 module_init(dwc_otg_driver_init);
 #endif
 
@@ -1429,7 +1450,7 @@ void  dwc_otg_driver_cleanup(void)
 
 	clear_bit(OTG_DRIVER_LOADED, &otg_driver_loaded);
 }
-#ifndef CONFIG_RTL_OTGCTRL
+#if !defined(CONFIG_RTL_OTGCTRL) && !defined(CONFIG_RTL_ULINKER)
 module_exit(dwc_otg_driver_cleanup);
 #endif
 
diff --git a/drivers/usb/dwc_otg/dwc_otg_hcd.c b/drivers/usb/dwc_otg/dwc_otg_hcd.c
index 412da41..0bb0811 100644
--- a/drivers/usb/dwc_otg/dwc_otg_hcd.c
+++ b/drivers/usb/dwc_otg/dwc_otg_hcd.c
@@ -364,7 +364,7 @@ static int32_t dwc_otg_hcd_disconnect_cb( void *_p )
    * longer a B-host. */
   ((struct usb_hcd *)_p)->self.is_b_host = 0;  
 
-#if 0  //cathy have
+#if 1  //cathy have
 	dwc_otg_hcd->disconn_cnt++;
 	if(!timer_pending(&dwc_otg_hcd->disconn_cnt_timer))
 		mod_timer(&dwc_otg_hcd->disconn_cnt_timer, jiffies+200);
diff --git a/drivers/usb/dwc_otg/dwc_otg_hcd_queue.c b/drivers/usb/dwc_otg/dwc_otg_hcd_queue.c
index 779cd05..fbeac25 100644
--- a/drivers/usb/dwc_otg/dwc_otg_hcd_queue.c
+++ b/drivers/usb/dwc_otg/dwc_otg_hcd_queue.c
@@ -147,7 +147,7 @@ void dwc_otg_hcd_qh_init(dwc_otg_hcd_t *_hcd, dwc_otg_qh_t *_qh, struct urb *_ur
 	/* FS/LS Enpoint on HS Hub 
 	 * NOT virtual root hub */
 	_qh->do_split = 0;
-#if 0
+#if 1
 	if (_urb->dev->speed == USB_SPEED_LOW || _urb->dev->speed == USB_SPEED_FULL)
       {
         if (_urb->dev->tt != NULL 
diff --git a/drivers/usb/dwc_otg/dwc_otg_pcd.c b/drivers/usb/dwc_otg/dwc_otg_pcd.c
index 96cb502..4b13980 100644
--- a/drivers/usb/dwc_otg/dwc_otg_pcd.c
+++ b/drivers/usb/dwc_otg/dwc_otg_pcd.c
@@ -79,7 +79,15 @@
 #include "dwc_otg_driver.h"
 #include "dwc_otg_pcd.h"
 
+#ifdef CONFIG_RTL_USB_OTG
+#include "otg_dbg.h"
 
+enum {
+	RTL_GADGET_FSG,
+	RTL_GADGET_ETH,
+};
+extern int rtl_otg_gadget;
+#endif
 
 /**
  * Static PCD pointer for use in usb_gadget_register_driver and
@@ -1597,10 +1605,25 @@ int  dwc_otg_pcd_init(struct lm_device *_lmdev)
   #if 0  //wei add for bind gadget
   	usb_gadget_register_driver( pcd->driver);  //wei add
   #else
-	extern int eth_reg_again();
-  	int ret=eth_reg_again();
-	if(ret!=0) printk("gadget register rc=%d\n", ret);
-#endif
+  	#if defined(CONFIG_RTL_ULINKER)
+		if (rtl_otg_gadget == RTL_GADGET_FSG) {
+			extern int fsg_reg_again();
+			int ret=fsg_reg_again();
+			if(ret!=0) printk("gadget register rc=%d\n", ret);
+		}
+		else {
+			extern int eth_reg_again();
+			int ret=eth_reg_again();
+			if(ret!=0) printk("gadget register rc=%d\n", ret);
+		}
+	#else
+		{
+			extern int eth_reg_again();
+			int ret=eth_reg_again();
+			if(ret!=0) printk("gadget register rc=%d\n", ret);
+		}
+	#endif
+  #endif
 
 
   /*
@@ -1698,8 +1721,21 @@ void dwc_otg_pcd_remove( struct lm_device *_lmdev )
 #if 0  // for un-bind gadget	  
       usb_gadget_unregister_driver( pcd->driver);
 #else
-	extern int eth_unreg_again();
-	eth_unreg_again();	
+	#if defined(CONFIG_RTL_ULINKER_GADGET)
+		if (rtl_otg_gadget == RTL_GADGET_FSG) {
+			extern int fsg_unreg_again();
+			fsg_unreg_again();
+		}
+		else {
+			extern int eth_unreg_again();
+			eth_unreg_again();
+		}
+	#else
+		{
+			extern int eth_unreg_again();
+			eth_unreg_again();
+		}
+	#endif
 #endif
 	  	
     }
@@ -1762,6 +1798,7 @@ int usb_gadget_register_driver(struct usb_gadget_driver *_driver)
 
   DWC_DEBUGPL(DBG_PCD, "bind to driver %s\n", _driver->driver.name);
   retval = _driver->bind(&s_pcd->gadget);
+
   if (retval) 
 	{
       DWC_ERROR("bind to driver %s --> error %d\n", 
diff --git a/drivers/usb/dwc_otg/dwc_otg_pcd_intr.c b/drivers/usb/dwc_otg/dwc_otg_pcd_intr.c
index 7123a9e..8cb3a39 100644
--- a/drivers/usb/dwc_otg/dwc_otg_pcd_intr.c
+++ b/drivers/usb/dwc_otg/dwc_otg_pcd_intr.c
@@ -1808,12 +1808,14 @@ static void complete_ep( dwc_otg_pcd_ep_t *_ep )
 		if (deptsiz.b.xfersize == 0 && deptsiz.b.pktcnt == 0 &&
 				_ep->dwc_ep.xfer_count == _ep->dwc_ep.xfer_len) 
 		{
+		#if !defined(CONFIG_RTL_ULINKER)
 			//only support zlp on endpoint 1 (bulk in)
 			if((_ep->dwc_ep.num == 1) && !_ep->dwc_ep.sent_zlp && !(_ep->dwc_ep.xfer_len & (_ep->dwc_ep.maxpacket-1))){
 				_ep->dwc_ep.sent_zlp = 1;
 				is_last = ep_in_zlp(_ep);
 			}
 			else
+		#endif
 			is_last = 1;
 
 		} 
@@ -2664,6 +2666,9 @@ int32_t dwc_otg_pcd_handle_out_nak_effective( dwc_otg_pcd_t *_pcd )
  * All interrupt registers are processed from LSB to MSB.
  * 
  */
+#if defined(CONFIG_RTL_ULINKER)
+int fsg_init_once = 0;
+#endif
 int32_t dwc_otg_pcd_handle_intr( dwc_otg_pcd_t *_pcd )
 {
 	dwc_otg_core_if_t *core_if = GET_CORE_IF(_pcd);
diff --git a/drivers/usb/dwc_otg/rtk_otg_autodet.c b/drivers/usb/dwc_otg/rtk_otg_autodet.c
index ace88c3..a71b8e1 100644
--- a/drivers/usb/dwc_otg/rtk_otg_autodet.c
+++ b/drivers/usb/dwc_otg/rtk_otg_autodet.c
@@ -6,22 +6,38 @@ void dump_autodet_reg()
 {
 	#define GETBITVAL(v,bit)  ((v&(1<<bit))>>bit)
 
-	unsigned int val=REG32(0xb8000098)	;  //auto_det_ctrl
+	unsigned int val=REG32(SYS_OTG_CONTROL)	;  //auto_det_ctrl
 	printk("Otg_Ctrl_Reg=%x \n", val);
 
 	int force=GETBITVAL(val,2);
-	printk("  b02 [I] Otg_Mux_Sel=%x, %s mode \n", GETBITVAL(val,2), force? "Force": "Auto" );
+	printk("  b02 [I] Otg_Mux_Sel=%x, %s mode \n", force, force? "Force": "Auto" );
 	printk("  b19 [I] Vbus_On=%x \n", GETBITVAL(val,19));
 	printk("  b20 [I] PJ_On=%x \n", GETBITVAL(val,20));
 	printk("  b21 [I] PJ_Toggle=%x \n", GETBITVAL(val,21));
-	printk("  b22 [I] Device_Connect=%x \n", GETBITVAL(val,22));
-	printk("  b23 [I] Host_Disconnect=%x \n", GETBITVAL(val,23));
+	printk("  b22 [I] Phy Device_Connect=%x \n", GETBITVAL(val,22));
+	printk("  b23 [I] Phy Host_Disconnect=%x \n", GETBITVAL(val,23));
+	
+	int connect_sel=GETBITVAL(val,17);	
+	printk("  b17 [I] OTG Connect Sel=%x, From Phy %s  \n", connect_sel, connect_sel?"NOT DisConnect":"Connect" );	
 	printk("  b24 [O] Pow_PJ_On=%x \n", GETBITVAL(val,24));
 	printk("  b25 [O] Pow_VB_On=%x \n", GETBITVAL(val,25));
 
 	if(force)
-	printk("  b03 [I] Otg_force_dev=%x \n", GETBITVAL(val,3));			
-	printk("  b18 [O] Otg_cfg_dev_r=%x \n", GETBITVAL(val,18));	
+	printk("  b03 [I] Otg_force_dev=%x, force use \n", GETBITVAL(val,3));			
+	printk("  b18 [O] Otg_cfg_dev_r=%x, auto use \n", GETBITVAL(val,18));	
+
+
+	#define GET_MVAL(v,bitpos,pat) ((v& ((unsigned int)pat<<bitpos))>>bitpos)
+	#define RANG1 1
+	#define RANG2 3
+	#define RANG3  7
+	#define RANG4 0xf
+	printk("  b05    OTGCMP_EN=%x \n", GET_MVAL(val,5, RANG1));	
+	printk("  b09:06 Vref_L=%x\n", GET_MVAL(val,6, RANG4));	
+	printk("  b13:10 Vref_H=%x\n", GET_MVAL(val,10, RANG4));	
+	printk("  b16:14 Vbus_th=%x \n", GET_MVAL(val,14, RANG3));	
+
+	
 	printk("\n");
 
 }
@@ -45,11 +61,17 @@ void USBPHY_CHIP_Active(int portnum, int active)  //1: in reset,  0: working
 	#define SYS_USB_PHY 0xb8000090
 	if(portnum==0)
 	{	if(active==0)	REG32(SYS_USB_PHY) &= ~(1<<10);   //usbphy_reset=0	
-		else				REG32(SYS_USB_PHY) |=  (1<<10);   //usbphy_reset=1
+		else				
+		{	REG32(SYS_USB_PHY) |=  (1<<8);   //usbphy_en=1
+			REG32(SYS_USB_PHY) |=  (1<<10);   //usbphy_reset=1
+		}
 	}
 	else if(portnum==1)
 	{	if(active==0)	REG32(SYS_USB_PHY) &= ~(1<<21);   //usbphy_reset=0	
-		else				REG32(SYS_USB_PHY) |=  (1<<21);   //usbphy_reset=1
+		else	
+		{	REG32(SYS_USB_PHY) |=  (1<<19);   //usbphy_en=1
+			REG32(SYS_USB_PHY) |=  (1<<21);   //usbphy_reset=1
+		}
 
 	}
 }
@@ -200,21 +222,30 @@ int otg_proc_write_procmem(struct file *file, const char *buf, unsigned long cou
 
 		
         else if (!strcmp(tmp, "dump otg"))		
-	{	extern int gHostMode;
+	{	
+
+		extern int gHostMode;
 		printk("gHostMode=%d\n", gHostMode);
+
+		extern unsigned long otg_driver_loaded; 
+		printk("otg_driver_loaded=%d\n", otg_driver_loaded);		
+			
+#if 0		
 		extern struct lm_device *glmdev; //wei add
 		struct lm_device *pdev=glmdev;
 		printk("glmdev=%x\n", pdev);
 		dwc_otg_device_t *otg_dev = platform_get_drvdata(pdev);
 		printk("otg_dev=%x\n", otg_dev);
+		
 		/*
 		dwc_otg_hcd_t *dwc_otg_hcd = otg_dev->hcd;		
 		printk("dwc_otg_hcd=%x\n",dwc_otg_hcd );
 		struct usb_hcd *hcd = dwc_otg_hcd_to_hcd(dwc_otg_hcd);
 		printk("hcd=%x\n",jcd );
 		*/
-  
+#endif	 
 	}	
+	
         else if (!strcmp(tmp, "dump otgctrl"))		
 	{
 		dump_autodet_reg();			
@@ -229,7 +260,7 @@ int otg_proc_write_procmem(struct file *file, const char *buf, unsigned long cou
 //           printk("gad <0|1 >! \n");		   
            printk("otg <0|1> \n");    
            printk("ehci <0|1> \n");    
-           printk("port <0|1> \n");    
+           printk("port <0|1|?> \n");    
            printk("autodet <0|1> \n");    
            printk("idpin <0|1> \n");    
 		   
@@ -308,7 +339,7 @@ static void otg_timer_isr(unsigned long data)
 static void otgctrl_work_func(struct work_struct *work)
 //static void otg_timer_isr(unsigned long data)
 {
-		//TurnOn_OTGCtrl_Interrupt(0);	
+	  int old=TurnOn_OTGCtrl_Interrupt(0);
 
 	dump_autodet_reg();		
 
@@ -318,7 +349,7 @@ static void otgctrl_work_func(struct work_struct *work)
 
 	unsigned int v=(priv->curr_val) ;	
 
-#if 0  //see idpin result
+#if 0  //software only see idpin result
 	//plugin: PC-> usb disk
 	if( 
 	     ( (v&OTGCTRL_CFG_DEV_R)==0)	 && 
@@ -375,49 +406,43 @@ static void otgctrl_work_func(struct work_struct *work)
 		priv->nFirst=1;
 	}
 #endif
-#if 1	
+#if 1   //software decide the state machine	
   if(v&OTGCTRL_PJ_ON)
   {
        //connect=1
 	//if( (v&OTGCTRL_DEVICE_CONNECT) &&(priv->mode==0))
 	if(  ((v&OTGCTRL_DEVICE_DISCONNECT)==0) &&(priv->mode==0) )		
 	{
-	//change port
-	//USBPHY_CHIP_Active(1,0);
-	//USBPHY_UTMI_Reset(1, 1);	
-
-	//USBPHY_CHIP_Active(1,1);
-	//USBPHY_UTMI_Reset(1, 0);	
-
-		//
-	  int old=TurnOn_OTGCtrl_Interrupt(0);
-	#if P1_HOST_USING_EHCI //EHCI	
-		Set_SelUSBPort(1);	
-		ehci_hcd_init();
-		ohci_hcd_mod_init();
-	#else
-		dwc_otg_driver_init();
-	#endif
-		priv->mode=1;
-	  TurnOn_OTGCtrl_Interrupt(old);			
+		//change port
+		//USBPHY_CHIP_Active(1,0);
+		//USBPHY_UTMI_Reset(1, 1);	
+
+		//USBPHY_CHIP_Active(1,1);
+		//USBPHY_UTMI_Reset(1, 0);	
+
+		printk("OTGCTRL: PJ on, Det device plugin\n");
+
+		#if P1_HOST_USING_EHCI //EHCI	
+			Set_SelUSBPort(1);	
+			ehci_hcd_init();
+			ohci_hcd_mod_init();
+		#else
+			dwc_otg_driver_init();
+		#endif
+			priv->mode=1;
 	
 
 	}
 	//dis-connect=1
 	else if( (v&OTGCTRL_DEVICE_DISCONNECT) && (priv->mode==1) )
 	{
-	#if P1_HOST_USING_EHCI	
-		ehci_hcd_cleanup();	
-		//ohci_hcd_mod_exit();
-	#else
-		dwc_otg_driver_cleanup();
-	#endif
-/*
-		USBPHY_CHIP_Active(1, 0);
-		USBPHY_CHIP_Active(1, 1);
-		USBPHY_UTMI_Reset(1,  1);
-		USBPHY_UTMI_Reset(1,  0);
-*/
+		#if P1_HOST_USING_EHCI	
+			ehci_hcd_cleanup();	
+			//ohci_hcd_mod_exit();
+		#else
+			dwc_otg_driver_cleanup();
+		#endif
+
 		
 		priv->mode=0;
 	}
@@ -425,7 +450,7 @@ static void otgctrl_work_func(struct work_struct *work)
 	else if( (v&OTGCTRL_DEVICE_DISCONNECT) && (priv->mode==0) &&(v&OTGCTRL_VBUS_ON) )
 	{
 		Set_SelUSBPort(0);
-		printk("Vbus on, Det host plugin\n");
+		printk("OTGCTRL: Vbus on, Det host plugin\n");
 		priv->mode=3;
 		dwc_otg_driver_init();
 			
@@ -444,7 +469,7 @@ static void otgctrl_work_func(struct work_struct *work)
 	if(  ((v&OTGCTRL_DEVICE_DISCONNECT)==0) &&(priv->mode==0) )		
 	{
 		Set_SelUSBPort(0);
-		printk("Vbus on, Det Device plugin\n");
+		printk("OTGCTRL: Vbus on, Det Device plugin\n");
 		priv->mode=4;
 		dwc_otg_driver_init();
 			
@@ -456,10 +481,10 @@ static void otgctrl_work_func(struct work_struct *work)
 			
 	}
 	//---------------
-	else if(  ((v&OTGCTRL_DEVICE_DISCONNECT)==0) &&(priv->mode==0) )		
+	else if(  (v&OTGCTRL_DEVICE_DISCONNECT) &&(priv->mode==0) )		
 	{
 		Set_SelUSBPort(0);
-		printk("Vbus on, Det host plugin\n");
+		printk("OTGCTRL: Vbus on, Det host plugin\n");
 		priv->mode=5;
 		dwc_otg_driver_init();
 			
@@ -472,6 +497,8 @@ static void otgctrl_work_func(struct work_struct *work)
 	}
   }
 #endif		
+
+	  TurnOn_OTGCtrl_Interrupt(old);	
 }
 
 //--------------------------------------------------------------------------------------------
@@ -484,7 +511,7 @@ static irqreturn_t otg_ctrl_irq(int _irq, void *_dev)
 	//printk("0xb8003000=%x \n", REG32(0xb8003000) );
 	//dump_autodet_reg();	
 
-	unsigned int v=REG32(0xb8000098);
+	unsigned int v=REG32(SYS_OTG_CONTROL);
 
 	//if(v&OTGCTRL_DEVICE_CONNECT)
 	{
@@ -499,7 +526,7 @@ static irqreturn_t otg_ctrl_irq(int _irq, void *_dev)
 
 		//schedule_work(&otgctrl_work.start_work);
 		PREPARE_DELAYED_WORK(&otgctrl_work.start_work, otgctrl_work_func);
-		schedule_delayed_work(&otgctrl_work.start_work, 50);
+		schedule_delayed_work(&otgctrl_work.start_work, 100);
 
 
 			
@@ -537,15 +564,14 @@ struct device gUSB1CtrlDev;
 //--------------------------------------------------------------------------------------------
 void otg_ctrl_init(void)
 {
-
+	Enable_AutoDetectionCircuit(0);	
+		
  //wei add for test
-    struct proc_dir_entry *entry=create_proc_entry("otg", 0, NULL);
-    if (entry)
-    {  entry->write_proc=otg_proc_write_procmem;
-        entry->read_proc=otg_proc_read_procmem;
-    }
-
-
+	struct proc_dir_entry *entry=create_proc_entry("otg", 0, NULL);
+	if (entry)
+	{  entry->write_proc=otg_proc_write_procmem;
+		entry->read_proc=otg_proc_read_procmem;
+	}
 
 	int retval = request_irq(BSP_OTGCTRL_IRQ, otg_ctrl_irq, IRQF_DISABLED, "otg_ctrl", &gOtgCtrlDev );
 	if(retval!=0)
@@ -593,16 +619,16 @@ void otg_ctrl_init(void)
 		//top, enable auto-det
 		HangUpRes(1);
 
-		//REG32(0xb8000098)&=~(1<<17);   //0: connect is come from connect
-		REG32(0xb8000098)|=(1<<17);   //1: connect is come from dis-connect
+		//REG32(SYS_OTG_CONTROL)&=~(1<<17);   //0: connect is come from connect
+		REG32(SYS_OTG_CONTROL)|=(1<<17);   //1: connect is come from dis-connect
 		
 		//Set_SelUSBPort(0);
-		
+
 		USBPHY_CHIP_Active(1,1);
 		USBPHY_UTMI_Reset(1,0);
 		
-		//Enable_AutoDetectionCircuit(0);	
-		Enable_AutoDetectionCircuit(1);
+		Enable_AutoDetectionCircuit(0);	
+		//Enable_AutoDetectionCircuit(1);
 		Set_IDDIG_Level(0,0);		
 #endif
 	printk("OTGCTRL: init ok\n");
diff --git a/drivers/usb/dwc_otg/rtk_otg_autodet.h b/drivers/usb/dwc_otg/rtk_otg_autodet.h
index 284a22f..e43baf8 100644
--- a/drivers/usb/dwc_otg/rtk_otg_autodet.h
+++ b/drivers/usb/dwc_otg/rtk_otg_autodet.h
@@ -21,6 +21,9 @@
 #include "dwc_otg_pcd.h"
 #include "dwc_otg_hcd.h"
 
+
+#define SYS_OTG_CONTROL 0xb8000098 
+
 #define OTGCTRL_CFG_DEV_R  (1<<18)
 #define OTGCTRL_VBUS_ON  (1<<19)
 #define OTGCTRL_PJ_ON  (1<<20)
diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index a56b24d..ff0e462 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -55,7 +55,11 @@
 #include <asm/unaligned.h>
 
 
+#if defined(CONFIG_USB_UWIFI_HOST)
+#include "../core_uWiFi/hcd.h"
+#else
 #include "../core/hcd.h"
+#endif
 
 
 #define DRIVER_DESC	"USB Host+Gadget Emulator"
diff --git a/drivers/usb/gadget/ether.c b/drivers/usb/gadget/ether.c
index bd102f5..05d5a5c 100644
--- a/drivers/usb/gadget/ether.c
+++ b/drivers/usb/gadget/ether.c
@@ -296,7 +296,7 @@ static int __init eth_bind(struct usb_composite_dev *cdev)
 		device_desc.idVendor = cpu_to_le16(SIMPLE_VENDOR_NUM);
 		device_desc.idProduct = cpu_to_le16(SIMPLE_PRODUCT_NUM);
 		if (!has_rndis())
-			device_desc.bDeviceClass = USB_CLASS_VENDOR_SPEC;
+		device_desc.bDeviceClass = USB_CLASS_VENDOR_SPEC;
 	}
 
 	if (has_rndis()) {
diff --git a/drivers/usb/gadget_cathy/Kconfig b/drivers/usb/gadget_cathy/Kconfig
index a60157c..896e01c 100644
--- a/drivers/usb/gadget_cathy/Kconfig
+++ b/drivers/usb/gadget_cathy/Kconfig
@@ -54,6 +54,22 @@ config USB_GADGET_DEBUG_FILES
 	   here.  If in doubt, or to conserve kernel memory, say "N".
 	   
 	
+config USB_GADGET_VBUS_DRAW
+	int "Maximum VBUS Power usage (2-500 mA)"
+	range 2 500
+	default 2
+	help
+	   Some devices need to draw power from USB when they are
+	   configured, perhaps to operate circuitry or to recharge
+	   batteries.  This is in addition to any local power supply,
+	   such as an AC adapter or batteries.
+
+	   Enter the maximum power your device draws through USB, in
+	   milliAmperes.  The permitted range of values is 2 - 500 mA;
+	   0 mA would be legal, but can make some hosts misbehave.
+
+	   This value will be used except for system-specific gadget
+	   drivers that have more specific information.	
 	
 config	USB_GADGET_SELECTED
 	boolean "USB_GADGET_SELECTED"
@@ -369,21 +385,10 @@ config USB_ETH_RNDIS
 	   XP, you'll need to download drivers from Microsoft's website; a URL
 	   is given in comments found in that info file.
 
-config USB_GADGETFS
-	tristate "Gadget Filesystem (EXPERIMENTAL)"
-	depends on EXPERIMENTAL
-	help
-	  This driver provides a filesystem based API that lets user mode
-	  programs implement a single-configuration USB device, including
-	  endpoint I/O and control requests that don't relate to enumeration.
-	  All endpoints, transfer speeds, and transfer types supported by
-	  the hardware are available, through read() and write() calls.
-
-	  Say "y" to link the driver statically, or "m" to build a
-	  dynamically linked module called "gadgetfs".
-
 config USB_FILE_STORAGE
-	tristate "File-backed Storage Gadget"
+	bool "File-backed Storage Gadget"
+	depends on USB_ETH && EXPERIMENTAL
+	default y
 	help
 	  The File-backed Storage Gadget acts as a USB Mass Storage
 	  disk drive.  As its storage repository it can use a regular
@@ -403,6 +408,40 @@ config USB_FILE_STORAGE_TEST
 	  behavior of USB Mass Storage hosts.  Not needed for
 	  normal operation.
 
+config USB_GADGETFS
+	tristate "Gadget Filesystem (EXPERIMENTAL)"
+	depends on EXPERIMENTAL
+	help
+	  This driver provides a filesystem based API that lets user mode
+	  programs implement a single-configuration USB device, including
+	  endpoint I/O and control requests that don't relate to enumeration.
+	  All endpoints, transfer speeds, and transfer types supported by
+	  the hardware are available, through read() and write() calls.
+
+	  Say "y" to link the driver statically, or "m" to build a
+	  dynamically linked module called "gadgetfs".
+
+#config USB_FILE_STORAGE
+#	tristate "File-backed Storage Gadget"
+#	help
+#	  The File-backed Storage Gadget acts as a USB Mass Storage
+#	  disk drive.  As its storage repository it can use a regular
+#	  file or a block device (in much the same way as the "loop"
+#	  device driver), specified as a module parameter.
+#
+#	  Say "y" to link the driver statically, or "m" to build a
+#	  dynamically linked module called "g_file_storage".
+#
+#config USB_FILE_STORAGE_TEST
+#	bool "File-backed Storage Gadget testing version"
+#	depends on USB_FILE_STORAGE
+#	default n
+#	help
+#	  Say "y" to generate the larger testing version of the
+#	  File-backed Storage Gadget, useful for probing the
+#	  behavior of USB Mass Storage hosts.  Not needed for
+#	  normal operation.
+
 config USB_G_SERIAL
 	tristate "Serial Gadget (with CDC ACM support)"
 	help
diff --git a/drivers/usb/gadget_cathy/Makefile b/drivers/usb/gadget_cathy/Makefile
index 13b5584..f54560c 100644
--- a/drivers/usb/gadget_cathy/Makefile
+++ b/drivers/usb/gadget_cathy/Makefile
@@ -17,14 +17,14 @@ g_ether-objs			:= ether.o usbstring.o config.o epautoconf.o
 g_serial-objs			:= serial.o usbstring.o config.o epautoconf.o
 g_midi-objs			:= gmidi.o usbstring.o config.o epautoconf.o
 gadgetfs-objs			:= inode.o
-g_file_storage-objs		:= file_storage.o usbstring.o config.o \
-					epautoconf.o
+#g_file_storage-objs		:= file_storage.o usbstring.o config.o epautoconf.o
+g_file_storage-objs		:= file_storage.o
 
 ifeq ($(CONFIG_USB_ETH_RNDIS),y)
 	g_ether-objs		+= rndis.o
 endif
  
-obj-$(CONFIG_USB_OTG_DEVICE_RTL8672)		+= g_ether.o 
+#obj-$(CONFIG_USB_OTG_DEVICE_RTL8672)		+= g_ether.o 
 #obj-$(CONFIG_USB_ZERO)		+= g_zero.o
 obj-$(CONFIG_USB_ETH)		+= g_ether.o
 obj-$(CONFIG_USB_GADGETFS)	+= gadgetfs.o
diff --git a/drivers/usb/gadget_cathy/dummy_hcd.c b/drivers/usb/gadget_cathy/dummy_hcd.c
index f1f32d7..633cbb9 100644
--- a/drivers/usb/gadget_cathy/dummy_hcd.c
+++ b/drivers/usb/gadget_cathy/dummy_hcd.c
@@ -59,7 +59,11 @@
 #include <asm/unaligned.h>
 
 
+#if defined(CONFIG_USB_UWIFI_HOST)
+#include "../core_uWiFi/hcd.h"
+#else
 #include "../core/hcd.h"
+#endif
 
 
 #define DRIVER_DESC	"USB Host+Gadget Emulator"
diff --git a/drivers/usb/gadget_cathy/epautoconf.c b/drivers/usb/gadget_cathy/epautoconf.c
index 3842ed3..6a452bb 100644
--- a/drivers/usb/gadget_cathy/epautoconf.c
+++ b/drivers/usb/gadget_cathy/epautoconf.c
@@ -32,14 +32,17 @@
 
 #include "gadget_chips.h"
 
+#if defined(CONFIG_RTL_ULINKER)
+#include "usb_ulinker.h"
+#endif
 
 /* we must assign addresses for configurable endpoints (like net2280) */
-static __devinitdata unsigned epnum;
+static ULINKER_DEVINITDATA unsigned epnum;
 
 // #define MANY_ENDPOINTS
 #ifdef MANY_ENDPOINTS
 /* more than 15 configurable endpoints */
-static __devinitdata unsigned in_epnum;
+static ULINKER_DEVINITDATA unsigned in_epnum;
 #endif
 
 
@@ -59,7 +62,7 @@ static __devinitdata unsigned in_epnum;
  * NOTE:  each endpoint is unidirectional, as specified by its USB
  * descriptor; and isn't specific to a configuration or altsetting.
  */
-static int __devinit
+static int ULINKER_DEVINIT
 ep_matches (
 	struct usb_gadget		*gadget,
 	struct usb_ep			*ep,
@@ -186,7 +189,7 @@ ep_matches (
 	return 1;
 }
 
-static struct usb_ep * __devinit
+static struct usb_ep * ULINKER_DEVINIT
 find_ep (struct usb_gadget *gadget, const char *name)
 {
 	struct usb_ep	*ep;
@@ -228,7 +231,7 @@ find_ep (struct usb_gadget *gadget, const char *name)
  *
  * On failure, this returns a null endpoint descriptor.
  */
-struct usb_ep * __devinit usb_ep_autoconfig (
+struct usb_ep * ULINKER_DEVINIT usb_ep_autoconfig (
 	struct usb_gadget		*gadget,
 	struct usb_endpoint_descriptor	*desc
 )
@@ -295,7 +298,7 @@ struct usb_ep * __devinit usb_ep_autoconfig (
  * state such as ep->driver_data and the record of assigned endpoints
  * used by usb_ep_autoconfig().
  */
-void __devinit usb_ep_autoconfig_reset (struct usb_gadget *gadget)
+void ULINKER_DEVINIT usb_ep_autoconfig_reset (struct usb_gadget *gadget)
 {
 	struct usb_ep	*ep;
 
diff --git a/drivers/usb/gadget_cathy/ether.c b/drivers/usb/gadget_cathy/ether.c
index c92d500..30514ea 100644
--- a/drivers/usb/gadget_cathy/ether.c
+++ b/drivers/usb/gadget_cathy/ether.c
@@ -66,6 +66,10 @@
 #include "../net/otg_dev_driver.h"
 #endif
 
+#if defined(CONFIG_RTL_ULINKER)
+#include "usb_ulinker.h"
+#endif
+
 struct eth_dev		* g_eth_dev;
 #define REG32(reg)   (*(volatile unsigned int *)((unsigned int)reg))
 /*-------------------------------------------------------------------------*/
@@ -1405,6 +1409,15 @@ static void rndis_command_complete (struct usb_ep *ep, struct usb_request *req)
 
 #endif	/* RNDIS */
 
+#if defined(CONFIG_RTL_ULINKER)
+int wall_mount = 1;
+enum {
+	RTL_ETHER_STATE_INIT,
+	RTL_ETHER_STATE_GET_DEV_DESC,
+	RTL_ETHER_STATE_SET_CONF
+};
+int ether_state = RTL_ETHER_STATE_INIT;
+#endif
 /*
  * The setup() callback implements all the ep0 functionality that's not
  * handled lower down.  CDC has a number of less-common features:
@@ -1439,6 +1452,18 @@ eth_setup (struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 		case USB_DT_DEVICE:
 			value = min (wLength, (u16) sizeof device_desc);
 			memcpy (req->buf, &device_desc, value);
+#if defined(CONFIG_RTL_ULINKER)
+				/*
+					if wall_mount=1 means usb driver doesn't get any control urb
+					ie, when ulinker is plugged into a usb adapter, not pc, we need to change ulinker into
+					ether mode after some seconds.
+				*/
+				if (wall_mount)
+				{
+					wall_mount = 0;
+					ether_state = RTL_ETHER_STATE_GET_DEV_DESC;
+				}
+#endif
 			break;
 #ifdef CONFIG_USB_GADGET_DUALSPEED
 		case USB_DT_DEVICE_QUALIFIER:
@@ -1481,6 +1506,12 @@ eth_setup (struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 		spin_lock (&dev->lock);
 		value = eth_set_config (dev, wValue, GFP_ATOMIC);
 		spin_unlock (&dev->lock);
+#if defined(CONFIG_RTL_ULINKER)
+		if ((value == 0) && (ether_state == RTL_ETHER_STATE_GET_DEV_DESC))
+		{
+			ether_state = RTL_ETHER_STATE_SET_CONF;
+		}
+#endif
 		break;
 	case USB_REQ_GET_CONFIGURATION:
 		if (ctrl->bRequestType != USB_DIR_IN)
@@ -1687,7 +1718,7 @@ eth_disconnect (struct usb_gadget *gadget)
 
 /* NETWORK DRIVER HOOKUP (to the layer above this driver) */
 
-static int eth_change_mtu (struct net_device *net, int new_mtu)
+static int geth_change_mtu (struct net_device *net, int new_mtu)
 {
 	struct eth_dev	*dev = netdev_priv(net);
 
@@ -2239,6 +2270,37 @@ static int eth_start_xmit (struct sk_buff *skb, struct net_device *net)
 #ifdef SPEED_UP_TX
 	struct rndis_packet_msg_type *header=NULL;
 #endif
+
+#if defined(CONFIG_RTL_ULINKER_MIXED_MODE)
+	extern int tx_vlan_process(struct net_device *dev, struct vlan_info *info_ori, struct sk_buff *skb, int wlan_pri);
+	extern struct net init_net;
+	static struct net_device *usbeth = NULL;
+	static struct vlan_info_item *pitem = NULL;
+
+	if (usbeth == NULL)
+		usbeth = dev_get_by_name(&init_net, "usb0");
+	else {
+		if (pitem == NULL) {
+			pitem = rtl_get_vlan_info_item_by_dev(usbeth);
+		}
+		else {
+			skb->src_info = &pitem->info;
+		}
+	}
+
+/*
+if (usbeth && skb->dev && usbeth->name && skb->dev->name)
+	printk("%s:%s\n", usbeth->name, skb->dev->name);
+
+
+	if (tx_vlan_process(dev, &pitem->info, skb, 0))
+	{
+		dev_kfree_skb_any(skb);
+		return 0;
+	}
+*/
+#endif /* CONFIG_RTL_ULINKER_MIXED_MODE */
+
 	/* apply outgoing CDC or RNDIS filters */
 	if (!eth_is_promisc (dev)) {
 		u8		*dest = skb->data;
@@ -2557,6 +2619,10 @@ static int eth_stop (struct net_device *net)
 {
 	struct eth_dev		*dev = netdev_priv(net);
 
+#if defined(CONFIG_RTL_ULINKER)
+	 // for link down rndis on winows
+	(void) rndis_signal_disconnect (dev->rndis_config);
+#else
 	VDEBUG (dev, "%s\n", __FUNCTION__);
 	netif_stop_queue (net);
 
@@ -2586,6 +2652,7 @@ static int eth_stop (struct net_device *net)
 					NDIS_MEDIUM_802_3, 0);
 		(void) rndis_signal_disconnect (dev->rndis_config);
 	}
+#endif /* #if defined(CONFIG_RTL_ULINKER) */
 
 	return 0;
 }
@@ -2651,7 +2718,7 @@ eth_unbind (struct usb_gadget *gadget)
 	set_gadget_data (gadget, NULL);
 }
 
-static u8 __devinit nibble (unsigned char c)
+static u8 ULINKER_DEVINIT nibble (unsigned char c)
 {
 	if (likely (isdigit (c)))
 		return c - '0';
@@ -2661,7 +2728,7 @@ static u8 __devinit nibble (unsigned char c)
 	return 0;
 }
 
-static int __devinit get_ether_addr(const char *str, u8 *dev_addr)
+static int ULINKER_DEVINIT get_ether_addr(const char *str, u8 *dev_addr)
 {
 	if (str) {
 		unsigned	i;
@@ -2705,7 +2772,46 @@ static int eth_set_host_mac_addr(struct net_device *net, void *addr)
 	return err;
 }
 
-static int __devinit
+#if defined(CONFIG_RTL_ULINKER) && !defined(CONFIG_COMPAT_NET_DEV_OPS)
+static void eth_set_rx_mode (struct net_device *dev)
+{
+	/*	Not yet implemented.	*/
+}
+
+static void eth_tx_timeout (struct net_device *dev)
+{
+	printk("Tx Timeout!!! Can't send packet\n");
+}
+
+static const struct net_device_ops rtl819x_netdev_ops_usb = {
+	.ndo_open		= eth_open,
+	.ndo_stop		= eth_stop,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_set_mac_address 	= eth_set_host_mac_addr,
+	.ndo_set_multicast_list	= eth_set_rx_mode,
+	.ndo_get_stats		= eth_get_stats,
+	.ndo_do_ioctl		= eth_ioctl,
+#ifdef TEST_MODE
+	.ndo_start_xmit		= eth_start_xmit2,
+#else
+	.ndo_start_xmit		= eth_start_xmit,
+#endif
+	.ndo_tx_timeout		= eth_tx_timeout,
+#if defined(CP_VLAN_TAG_USED)
+	.ndo_vlan_rx_register	= cp_vlan_rx_register,
+#endif
+	.ndo_change_mtu		= geth_change_mtu,
+};
+
+#if 0
+//cathy, for update host mac (eth mac + 1)
+	my_eth_mac_addr = net->set_mac_address;
+	net->set_mac_address = eth_set_host_mac_addr;
+#endif
+
+#endif /* defined(CONFIG_RTL_ULINKER) && !defined(CONFIG_COMPAT_NET_DEV_OPS) */
+
+static int ULINKER_DEVINIT 
 eth_bind (struct usb_gadget *gadget)
 {
 	struct eth_dev		*dev;
@@ -2714,7 +2820,7 @@ eth_bind (struct usb_gadget *gadget)
 	struct usb_ep		*in_ep, *out_ep, *status_ep = NULL;
 	int			status = -ENOMEM;
 	int			gcnum;
-	
+
 	//REG32(0xb8030804) |= 0x02000000;	//cathy, set soft disconnect in reg DCTL
 	/* these flags are only ever cleared; compiler take note */
 #ifndef	DEV_CONFIG_CDC
@@ -2765,7 +2871,7 @@ eth_bind (struct usb_gadget *gadget)
 			gadget->name);
 		return -ENODEV;
 	}
-#endif	
+#endif
 #if 0
 	snprintf (manufacturer, sizeof manufacturer, "%s %s/%s",
 		init_utsname()->sysname, init_utsname()->release,
@@ -2929,6 +3035,18 @@ autoconf_fail:
 	 * The host side address is used with CDC and RNDIS, and commonly
 	 * ends up in a persistent config database.
 	 */
+
+#if defined(CONFIG_RTL_ULINKER)
+{
+	extern char ulinker_rndis_mac[];
+	if (strlen(ulinker_rndis_mac)==12)
+	{
+		strcpy(host_addr, ulinker_rndis_mac);
+		//panic_printk("[%s:%d] host_addr[%s], len[%d]\n", __FUNCTION__, __LINE__, host_addr, strlen(host_addr));
+	}
+}
+#endif
+
 	if (get_ether_addr(dev_addr, net->dev_addr))
 		dev_warn(&gadget->dev,
 			"using random %s ethernet address\n", "self");
@@ -2953,7 +3071,11 @@ autoconf_fail:
 		}
 	}
 
-	net->change_mtu = eth_change_mtu;
+#if defined(CONFIG_RTL_ULINKER) && !defined(CONFIG_COMPAT_NET_DEV_OPS) /* bruce, for support newer net_device */
+	net->netdev_ops = &rtl819x_netdev_ops_usb;
+	SET_ETHTOOL_OPS(net, &ops);
+#else //--- !defined(CONFIG_RTL_ULINKER)
+	net->change_mtu = geth_change_mtu;
 	net->get_stats = eth_get_stats;
 #ifdef TEST_MODE
 	net->hard_start_xmit = eth_start_xmit2;
@@ -2970,6 +3092,8 @@ autoconf_fail:
 	// watchdog_timeo, tx_timeout ...
 	// set_multicast_list
 	SET_ETHTOOL_OPS(net, &ops);
+#endif /* defined(CONFIG_RTL_ULINKER) */
+
 //cathy test
 	device_desc.iSerialNumber = STRING_ETHADDR,
 	
diff --git a/drivers/usb/gadget_cathy/file_storage.c b/drivers/usb/gadget_cathy/file_storage.c
index 8b975d1..d8f9f41 100644
--- a/drivers/usb/gadget_cathy/file_storage.c
+++ b/drivers/usb/gadget_cathy/file_storage.c
@@ -38,16 +38,17 @@
 
 /*
  * The File-backed Storage Gadget acts as a USB Mass Storage device,
- * appearing to the host as a disk drive.  In addition to providing an
- * example of a genuinely useful gadget driver for a USB device, it also
- * illustrates a technique of double-buffering for increased throughput.
- * Last but not least, it gives an easy way to probe the behavior of the
- * Mass Storage drivers in a USB host.
+ * appearing to the host as a disk drive or as a CD-ROM drive.  In addition
+ * to providing an example of a genuinely useful gadget driver for a USB
+ * device, it also illustrates a technique of double-buffering for increased
+ * throughput.  Last but not least, it gives an easy way to probe the
+ * behavior of the Mass Storage drivers in a USB host.
  *
  * Backing storage is provided by a regular file or a block device, specified
  * by the "file" module parameter.  Access can be limited to read-only by
- * setting the optional "ro" module parameter.  The gadget will indicate that
- * it has removable media if the optional "removable" module parameter is set.
+ * setting the optional "ro" module parameter.  (For CD-ROM emulation,
+ * access is always read-only.)  The gadget will indicate that it has
+ * removable media if the optional "removable" module parameter is set.
  *
  * The gadget supports the Control-Bulk (CB), Control-Bulk-Interrupt (CBI),
  * and Bulk-Only (also known as Bulk-Bulk-Bulk or BBB) transports, selected
@@ -64,7 +65,12 @@
  * The default number of LUNs is taken from the number of "file" elements;
  * it is 1 if "file" is not given.  If "removable" is not set then a backing
  * file must be specified for each LUN.  If it is set, then an unspecified
- * or empty backing filename means the LUN's medium is not loaded.
+ * or empty backing filename means the LUN's medium is not loaded.  Ideally
+ * each LUN would be settable independently as a disk drive or a CD-ROM
+ * drive, but currently all LUNs have to be the same type.  The CD-ROM
+ * emulation includes a single data track and no audio tracks; hence there
+ * need be only one backing file per LUN.  Note also that the CD-ROM block
+ * length is set to 512 rather than the more common value 2048.
  *
  * Requirements are modest; only a bulk-in and a bulk-out endpoint are
  * needed (an interrupt-out endpoint is also needed for CBI).  The memory
@@ -91,6 +97,8 @@
  *					USB device controller (usually true),
  *					boolean to permit the driver to halt
  *					bulk endpoints
+ *	cdrom			Default false, boolean for whether to emulate
+ *					a CD-ROM drive
  *	transport=XXX		Default BBB, transport name (CB, CBI, or BBB)
  *	protocol=YYY		Default SCSI, protocol name (RBC, 8020 or
  *					ATAPI, QIC, UFI, 8070, or SCSI;
@@ -103,15 +111,16 @@
  *					PAGE_CACHE_SIZE)
  *
  * If CONFIG_USB_FILE_STORAGE_TEST is not set, only the "file", "ro",
- * "removable", "luns", and "stall" options are available; default values
- * are used for everything else.
+ * "removable", "luns", "stall", and "cdrom" options are available; default
+ * values are used for everything else.
  *
  * The pathnames of the backing files and the ro settings are available in
  * the attribute files "file" and "ro" in the lun<n> subdirectory of the
  * gadget's sysfs directory.  If the "removable" option is set, writing to
  * these files will simulate ejecting/loading the medium (writing an empty
  * line means eject) and adjusting a write-enable tab.  Changes to the ro
- * setting are not allowed when the medium is loaded.
+ * setting are not allowed when the medium is loaded or if CD-ROM emulation
+ * is being used.
  *
  * This gadget driver is heavily based on "Gadget Zero" by David Brownell.
  * The driver's SCSI command interface was based on the "Information
@@ -251,10 +260,12 @@
 #include <linux/spinlock.h>
 #include <linux/string.h>
 #include <linux/suspend.h>
+#include <linux/freezer.h>  //wei add
 #include <linux/utsname.h>
 
-#include <linux/usb_ch9.h>
-#include <linux/usb_gadget.h>
+#include <linux/usb/ch9.h>  //wei add
+#include <linux/usb/gadget.h>  //wei add
+#include <linux/dcache.h>
 
 #include "gadget_chips.h"
 
@@ -263,7 +274,7 @@
 
 #define DRIVER_DESC		"File-backed Storage Gadget"
 #define DRIVER_NAME		"g_file_storage"
-#define DRIVER_VERSION		"28 November 2005"
+#define DRIVER_VERSION		"20 November 2008"
 
 static const char longname[] = DRIVER_DESC;
 static const char shortname[] = DRIVER_NAME;
@@ -276,8 +287,8 @@ MODULE_LICENSE("Dual BSD/GPL");
  *
  * DO NOT REUSE THESE IDs with any other driver!!  Ever!!
  * Instead:  allocate your own, using normal USB-IF procedures. */
-#define DRIVER_VENDOR_ID	0x0525	// NetChip
-#define DRIVER_PRODUCT_ID	0xa4a5	// Linux-USB File-backed Storage Gadget
+#define DRIVER_VENDOR_ID	0x0BDA  //0x0525	// NetChip
+#define DRIVER_PRODUCT_ID	0x8671  //0xa4a5	// Linux-USB File-backed Storage Gadget
 
 
 /*
@@ -287,6 +298,7 @@ MODULE_LICENSE("Dual BSD/GPL");
  */
 
 
+
 /*-------------------------------------------------------------------------*/
 
 #define xprintk(f,level,fmt,args...) \
@@ -294,32 +306,43 @@ MODULE_LICENSE("Dual BSD/GPL");
 #define yprintk(l,level,fmt,args...) \
 	dev_printk(level , &(l)->dev , fmt , ## args)
 
+#if 0
+//wei add
+#define DEBUG 1
+#define DUMP_MSGS 1
+#define VERBOSE 1
+#endif
+
 #ifdef DEBUG
-#define DBG(fsg,fmt,args...) \
+
+	#if 0
+	#define DBG(fsg,fmt,args...) \
 	xprintk(fsg , KERN_DEBUG , fmt , ## args)
-#define LDBG(lun,fmt,args...) \
+	#define LDBG(lun,fmt,args...) \
 	yprintk(lun , KERN_DEBUG , fmt , ## args)
-#define MDBG(fmt,args...) \
+	#define MDBG(fmt,args...) \
 	printk(KERN_DEBUG DRIVER_NAME ": " fmt , ## args)
+	#else
+	#define DBG(fsg,fmt,args...) 	printk( fmt , ## args)
+	#define LDBG(lun,fmt,args...) 	printk( fmt , ## args)
+	#define MDBG(fmt,args...) 		printk( fmt , ## args)
+
+	#endif
+
 #else
-#define DBG(fsg,fmt,args...) \
-	do { } while (0)
-#define LDBG(lun,fmt,args...) \
-	do { } while (0)
-#define MDBG(fmt,args...) \
-	do { } while (0)
-#undef VERBOSE
-#undef DUMP_MSGS
+	#define DBG(fsg,fmt,args...) 	do { } while (0)
+	#define LDBG(lun,fmt,args...) 	do { } while (0)
+	#define MDBG(fmt,args...) 		do { } while (0)
+	#undef VERBOSE
+	#undef DUMP_MSGS
 #endif /* DEBUG */
 
 #ifdef VERBOSE
-#define VDBG	DBG
+#define VDBG		DBG
 #define VLDBG	LDBG
 #else
-#define VDBG(fsg,fmt,args...) \
-	do { } while (0)
-#define VLDBG(lun,fmt,args...) \
-	do { } while (0)
+#define VDBG(fsg,fmt,args...) 	do { } while (0)
+#define VLDBG(lun,fmt,args...) 	do { } while (0)
 #endif /* VERBOSE */
 
 #define ERROR(fsg,fmt,args...) \
@@ -350,12 +373,13 @@ MODULE_LICENSE("Dual BSD/GPL");
 static struct {
 	char		*file[MAX_LUNS];
 	int		ro[MAX_LUNS];
-	int		num_filenames;
-	int		num_ros;
+	unsigned int	num_filenames;
+	unsigned int	num_ros;
 	unsigned int	nluns;
 
 	int		removable;
 	int		can_stall;
+	int		cdrom;
 
 	char		*transport_parm;
 	char		*protocol_parm;
@@ -372,8 +396,11 @@ static struct {
 } mod_data = {					// Default values
 	.transport_parm		= "BBB",
 	.protocol_parm		= "SCSI",
-	.removable		= 0,
-	.can_stall		= 1,
+//	.removable		= 0,  	
+	.removable		= 1,  //wei add
+	.can_stall		= 0,  //wei add
+//	.can_stall		= 0,  //wei add
+	.cdrom			= 1,
 	.vendor			= DRIVER_VENDOR_ID,
 	.product		= DRIVER_PRODUCT_ID,
 	.release		= 0xffff,	// Use controller chip type
@@ -397,6 +424,9 @@ MODULE_PARM_DESC(removable, "true to simulate removable media");
 module_param_named(stall, mod_data.can_stall, bool, S_IRUGO);
 MODULE_PARM_DESC(stall, "false to prevent bulk stalls");
 
+module_param_named(cdrom, mod_data.cdrom, bool, S_IRUGO);
+MODULE_PARM_DESC(cdrom, "true to emulate cdrom instead of disk");
+
 
 /* In the non-TEST version, only the module parameters listed above
  * are available. */
@@ -426,6 +456,10 @@ MODULE_PARM_DESC(buflen, "I/O buffer size");
 
 /*-------------------------------------------------------------------------*/
 
+/* SCSI device types */
+#define TYPE_DISK	0x00
+#define TYPE_CDROM	0x05
+
 /* USB protocol value = the transport method */
 #define USB_PR_CBI	0x00		// Control/Bulk/Interrupt
 #define USB_PR_CB	0x01		// Control/Bulk w/o interrupt
@@ -502,6 +536,8 @@ struct interrupt_data {
 #define SC_READ_12			0xa8
 #define SC_READ_CAPACITY		0x25
 #define SC_READ_FORMAT_CAPACITIES	0x23
+#define SC_READ_HEADER			0x44
+#define SC_READ_TOC			0x43
 #define SC_RELEASE			0x17
 #define SC_REQUEST_SENSE		0x03
 #define SC_RESERVE			0x16
@@ -578,7 +614,7 @@ struct lun {
 
 #define backing_file_is_open(curlun)	((curlun)->filp != NULL)
 
-static inline struct lun *dev_to_lun(struct device *dev)
+static struct lun *dev_to_lun(struct device *dev)
 {
 	return container_of(dev, struct lun, dev);
 }
@@ -713,13 +749,13 @@ struct fsg_dev {
 
 typedef void (*fsg_routine_t)(struct fsg_dev *);
 
-static int inline exception_in_progress(struct fsg_dev *fsg)
+static int  exception_in_progress(struct fsg_dev *fsg)
 {
 	return (fsg->state > FSG_STATE_IDLE);
 }
 
 /* Make bulk-out requests be divisible by the maxpacket size */
-static void inline set_bulk_out_req_length(struct fsg_dev *fsg,
+static void  set_bulk_out_req_length(struct fsg_dev *fsg,
 		struct fsg_buffhd *bh, unsigned int length)
 {
 	unsigned int	rem;
@@ -728,7 +764,7 @@ static void inline set_bulk_out_req_length(struct fsg_dev *fsg,
 	rem = length % fsg->bulk_out_maxpacket;
 	if (rem > 0)
 		length += fsg->bulk_out_maxpacket - rem;
-	bh->outreq->length = length;
+	bh->outreq->length = (unsigned)length;
 }
 
 static struct fsg_dev			*the_fsg;
@@ -752,6 +788,7 @@ static void dump_msg(struct fsg_dev *fsg, const char *label,
 		return;
 	DBG(fsg, "%s, length %u:\n", label, length);
 
+#if 0
 	start = 0;
 	while (length > 0) {
 		num = min(length, 16u);
@@ -759,27 +796,40 @@ static void dump_msg(struct fsg_dev *fsg, const char *label,
 		for (i = 0; i < num; ++i) {
 			if (i == 8)
 				*p++ = ' ';
-			sprintf(p, " %02x", buf[i]);
+			//sprintf(p, " %02x", buf[i]);  //wei del
+			printk("%02x ", buf[i] );
 			p += 3;
 		}
 		*p = 0;
 		printk(KERN_DEBUG "%6x: %s\n", start, line);
+		//printk( "%6x: %s\n", start, line);  //wei add
+		
 		buf += num;
 		start += num;
 		length -= num;
 	}
+#else
+
+	//printk("Addr=%x :", buf);
+	printk("==> ");
+	for(i=0;i<length; i++)
+		printk("%02x ", buf[i]);
+	printk("\n");
+#endif
+
+
 }
 
-static void inline dump_cdb(struct fsg_dev *fsg)
+static void  dump_cdb(struct fsg_dev *fsg)
 {}
 
 #else
 
-static void inline dump_msg(struct fsg_dev *fsg, const char *label,
+static void  dump_msg(struct fsg_dev *fsg, const char *label,
 		const u8 *buf, unsigned int length)
 {}
 
-static void inline dump_cdb(struct fsg_dev *fsg)
+static void  dump_cdb(struct fsg_dev *fsg)
 {
 	int	i;
 	char	cmdbuf[3*MAX_COMMAND_SIZE + 1];
@@ -803,7 +853,9 @@ static int fsg_set_halt(struct fsg_dev *fsg, struct usb_ep *ep)
 	else
 		name = ep->name;
 	DBG(fsg, "%s set halt\n", name);
-	return usb_ep_set_halt(ep);
+	printk("fsg_set_halt\n");
+	return usb_ep_set_halt(ep);  //wei add
+//	return 0;   //wei add
 }
 
 
@@ -811,24 +863,24 @@ static int fsg_set_halt(struct fsg_dev *fsg, struct usb_ep *ep)
 
 /* Routines for unaligned data access */
 
-static u16 inline get_be16(u8 *buf)
+static u16  get_be16(u8 *buf)
 {
 	return ((u16) buf[0] << 8) | ((u16) buf[1]);
 }
 
-static u32 inline get_be32(u8 *buf)
+static u32  get_be32(u8 *buf)
 {
 	return ((u32) buf[0] << 24) | ((u32) buf[1] << 16) |
 			((u32) buf[2] << 8) | ((u32) buf[3]);
 }
 
-static void inline put_be16(u8 *buf, u16 val)
+static void  put_be16(u8 *buf, u16 val)
 {
 	buf[0] = val >> 8;
 	buf[1] = val;
 }
 
-static void inline put_be32(u8 *buf, u32 val)
+static void  put_be32(u8 *buf, u32 val)
 {
 	buf[0] = val >> 24;
 	buf[1] = val >> 16;
@@ -858,13 +910,13 @@ device_desc = {
 	.bLength =		sizeof device_desc,
 	.bDescriptorType =	USB_DT_DEVICE,
 
-	.bcdUSB =		__constant_cpu_to_le16(0x0200),
+	.bcdUSB =		cpu_to_le16(0x0200),
 	.bDeviceClass =		USB_CLASS_PER_INTERFACE,
 
 	/* The next three values can be overridden by module parameters */
-	.idVendor =		__constant_cpu_to_le16(DRIVER_VENDOR_ID),
-	.idProduct =		__constant_cpu_to_le16(DRIVER_PRODUCT_ID),
-	.bcdDevice =		__constant_cpu_to_le16(0xffff),
+	.idVendor =		cpu_to_le16(DRIVER_VENDOR_ID),
+	.idProduct =		cpu_to_le16(DRIVER_PRODUCT_ID),
+	.bcdDevice =		cpu_to_le16(0xffff),
 
 	.iManufacturer =	STRING_MANUFACTURER,
 	.iProduct =		STRING_PRODUCT,
@@ -937,7 +989,7 @@ fs_intr_in_desc = {
 
 	.bEndpointAddress =	USB_DIR_IN,
 	.bmAttributes =		USB_ENDPOINT_XFER_INT,
-	.wMaxPacketSize =	__constant_cpu_to_le16(2),
+	.wMaxPacketSize =	cpu_to_le16(2),
 	.bInterval =		32,	// frames -> 32 ms
 };
 
@@ -952,8 +1004,6 @@ static const struct usb_descriptor_header *fs_function[] = {
 #define FS_FUNCTION_PRE_EP_ENTRIES	2
 
 
-#ifdef	CONFIG_USB_GADGET_DUALSPEED
-
 /*
  * USB 2.0 devices need to expose both high speed and full speed
  * descriptors, unless they only run at full speed.
@@ -967,7 +1017,7 @@ dev_qualifier = {
 	.bLength =		sizeof dev_qualifier,
 	.bDescriptorType =	USB_DT_DEVICE_QUALIFIER,
 
-	.bcdUSB =		__constant_cpu_to_le16(0x0200),
+	.bcdUSB =		cpu_to_le16(0x0200),
 	.bDeviceClass =		USB_CLASS_PER_INTERFACE,
 
 	.bNumConfigurations =	1,
@@ -980,7 +1030,7 @@ hs_bulk_in_desc = {
 
 	/* bEndpointAddress copied from fs_bulk_in_desc during fsg_bind() */
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
-	.wMaxPacketSize =	__constant_cpu_to_le16(512),
+	.wMaxPacketSize =	cpu_to_le16(512),
 };
 
 static struct usb_endpoint_descriptor
@@ -990,7 +1040,7 @@ hs_bulk_out_desc = {
 
 	/* bEndpointAddress copied from fs_bulk_out_desc during fsg_bind() */
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
-	.wMaxPacketSize =	__constant_cpu_to_le16(512),
+	.wMaxPacketSize =	cpu_to_le16(512),
 	.bInterval =		1,	// NAK every 1 uframe
 };
 
@@ -1001,7 +1051,7 @@ hs_intr_in_desc = {
 
 	/* bEndpointAddress copied from fs_intr_in_desc during fsg_bind() */
 	.bmAttributes =		USB_ENDPOINT_XFER_INT,
-	.wMaxPacketSize =	__constant_cpu_to_le16(2),
+	.wMaxPacketSize =	cpu_to_le16(2),
 	.bInterval =		9,	// 2**(9-1) = 256 uframes -> 32 ms
 };
 
@@ -1016,14 +1066,14 @@ static const struct usb_descriptor_header *hs_function[] = {
 #define HS_FUNCTION_PRE_EP_ENTRIES	2
 
 /* Maxpacket and other transfer characteristics vary by speed. */
-#define ep_desc(g,fs,hs)	(((g)->speed==USB_SPEED_HIGH) ? (hs) : (fs))
-
-#else
-
-/* If there's no high speed support, always use the full-speed descriptor. */
-#define ep_desc(g,fs,hs)	fs
-
-#endif	/* !CONFIG_USB_GADGET_DUALSPEED */
+static struct usb_endpoint_descriptor *
+ep_desc(struct usb_gadget *g, struct usb_endpoint_descriptor *fs,
+		struct usb_endpoint_descriptor *hs)
+{
+	if (gadget_is_dualspeed(g) && g->speed == USB_SPEED_HIGH)
+		return hs;
+	return fs;
+}
 
 
 /* The CBI specification limits the serial string to 12 uppercase hexadecimal
@@ -1055,22 +1105,18 @@ static struct usb_gadget_strings	stringtab = {
 static int populate_config_buf(struct usb_gadget *gadget,
 		u8 *buf, u8 type, unsigned index)
 {
-#ifdef CONFIG_USB_GADGET_DUALSPEED
 	enum usb_device_speed			speed = gadget->speed;
-#endif
 	int					len;
 	const struct usb_descriptor_header	**function;
 
 	if (index > 0)
 		return -EINVAL;
 
-#ifdef CONFIG_USB_GADGET_DUALSPEED
-	if (type == USB_DT_OTHER_SPEED_CONFIG)
+	if (gadget_is_dualspeed(gadget) && type == USB_DT_OTHER_SPEED_CONFIG)
 		speed = (USB_SPEED_FULL + USB_SPEED_HIGH) - speed;
-	if (speed == USB_SPEED_HIGH)
+	if (gadget_is_dualspeed(gadget) && speed == USB_SPEED_HIGH)
 		function = hs_function;
 	else
-#endif
 		function = fs_function;
 
 	/* for now, don't advertise srp-only devices */
@@ -1109,8 +1155,10 @@ static void raise_exception(struct fsg_dev *fsg, enum fsg_state new_state)
 		fsg->exception_req_tag = fsg->ep0_req_tag;
 		fsg->state = new_state;
 		if (fsg->thread_task)
+		{	printk("=>send_sig_info\n");
 			send_sig_info(SIGUSR1, SEND_SIG_FORCED,
 					fsg->thread_task);
+		}
 	}
 	spin_unlock_irqrestore(&fsg->lock, flags);
 }
@@ -1296,6 +1344,7 @@ static int class_setup_req(struct fsg_dev *fsg,
 	struct usb_request	*req = fsg->ep0req;
 	int			value = -EOPNOTSUPP;
 	u16			w_index = le16_to_cpu(ctrl->wIndex);
+	u16                     w_value = le16_to_cpu(ctrl->wValue);
 	u16			w_length = le16_to_cpu(ctrl->wLength);
 
 	if (!fsg->config)
@@ -1309,7 +1358,7 @@ static int class_setup_req(struct fsg_dev *fsg,
 			if (ctrl->bRequestType != (USB_DIR_OUT |
 					USB_TYPE_CLASS | USB_RECIP_INTERFACE))
 				break;
-			if (w_index != 0) {
+			if (w_index != 0 || w_value != 0) {
 				value = -EDOM;
 				break;
 			}
@@ -1325,7 +1374,7 @@ static int class_setup_req(struct fsg_dev *fsg,
 			if (ctrl->bRequestType != (USB_DIR_IN |
 					USB_TYPE_CLASS | USB_RECIP_INTERFACE))
 				break;
-			if (w_index != 0) {
+			if (w_index != 0 || w_value != 0) {
 				value = -EDOM;
 				break;
 			}
@@ -1344,7 +1393,7 @@ static int class_setup_req(struct fsg_dev *fsg,
 			if (ctrl->bRequestType != (USB_DIR_OUT |
 					USB_TYPE_CLASS | USB_RECIP_INTERFACE))
 				break;
-			if (w_index != 0) {
+			if (w_index != 0 || w_value != 0) {
 				value = -EDOM;
 				break;
 			}
@@ -1395,7 +1444,7 @@ static int standard_setup_req(struct fsg_dev *fsg,
 			value = sizeof device_desc;
 			memcpy(req->buf, &device_desc, value);
 			break;
-#ifdef CONFIG_USB_GADGET_DUALSPEED
+
 		case USB_DT_DEVICE_QUALIFIER:
 			VDBG(fsg, "get device qualifier\n");
 			if (!fsg->gadget->is_dualspeed)
@@ -1409,12 +1458,12 @@ static int standard_setup_req(struct fsg_dev *fsg,
 			if (!fsg->gadget->is_dualspeed)
 				break;
 			goto get_config;
-#endif
+
 		case USB_DT_CONFIG:
 			VDBG(fsg, "get configuration descriptor\n");
-#ifdef CONFIG_USB_GADGET_DUALSPEED
+
 		get_config:
-#endif
+
 			value = populate_config_buf(fsg->gadget,
 					req->buf,
 					w_value >> 8,
@@ -1515,7 +1564,8 @@ static int fsg_setup(struct usb_gadget *gadget,
 	if (rc >= 0 && rc != DELAYED_STATUS) {
 		rc = min(rc, w_length);
 		fsg->ep0req->length = rc;
-		fsg->ep0req->zero = rc < w_length;
+		fsg->ep0req->zero = rc < w_length
+					&& (rc % gadget->ep0->maxpacket) == 0;  //wei add, 
 		fsg->ep0req_name = (ctrl->bRequestType & USB_DIR_IN ?
 				"ep0-in" : "ep0-out");
 		rc = ep0_queue(fsg);
@@ -1647,7 +1697,8 @@ static int do_read(struct fsg_dev *fsg)
 		/* Wait for the next buffer to become available */
 		bh = fsg->next_buffhd_to_fill;
 		while (bh->state != BUF_STATE_EMPTY) {
-			if ((rc = sleep_thread(fsg)) != 0)
+			rc = sleep_thread(fsg);
+			if (rc)
 				return rc;
 		}
 
@@ -1886,7 +1937,8 @@ static int do_write(struct fsg_dev *fsg)
 		}
 
 		/* Wait for something to happen */
-		if ((rc = sleep_thread(fsg)) != 0)
+		rc = sleep_thread(fsg);
+		if (rc)
 			return rc;
 	}
 
@@ -2059,24 +2111,34 @@ static int do_inquiry(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 {
 	u8	*buf = (u8 *) bh->buf;
 
+#if defined(CONFIG_RTL_ULINKER)
+	static char vendor_id[] = "Realtek ";
+	static char product_disk_id[]  = "USB Ether Driver";
+	static char product_cdrom_id[] = "USB Ether Driver";
+#else
 	static char vendor_id[] = "Linux   ";
-	static char product_id[] = "File-Stor Gadget";
+	static char product_disk_id[] = "File-Stor Gadget";
+	static char product_cdrom_id[] = "File-CD Gadget  ";
+#endif
 
 	if (!fsg->curlun) {		// Unsupported LUNs are okay
 		fsg->bad_lun_okay = 1;
 		memset(buf, 0, 36);
 		buf[0] = 0x7f;		// Unsupported, no device-type
+		buf[4] = 31;		// Additional length
 		return 36;
 	}
 
-	memset(buf, 0, 8);	// Non-removable, direct-access device
+	memset(buf, 0, 8);
+	buf[0] = (mod_data.cdrom ? TYPE_CDROM : TYPE_DISK);
 	if (mod_data.removable)
 		buf[1] = 0x80;
 	buf[2] = 2;		// ANSI SCSI level 2
 	buf[3] = 2;		// SCSI-2 INQUIRY data format
 	buf[4] = 31;		// Additional length
 				// No special options
-	sprintf(buf + 8, "%-8s%-16s%04x", vendor_id, product_id,
+	sprintf(buf + 8, "%-8s%-16s%04x", vendor_id,
+			(mod_data.cdrom ? product_cdrom_id : product_disk_id),
 			mod_data.release);
 	return 36;
 }
@@ -2155,6 +2217,75 @@ static int do_read_capacity(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 }
 
 
+static void store_cdrom_address(u8 *dest, int msf, u32 addr)
+{
+	if (msf) {
+		/* Convert to Minutes-Seconds-Frames */
+		addr >>= 2;		/* Convert to 2048-byte frames */
+		addr += 2*75;		/* Lead-in occupies 2 seconds */
+		dest[3] = addr % 75;	/* Frames */
+		addr /= 75;
+		dest[2] = addr % 60;	/* Seconds */
+		addr /= 60;
+		dest[1] = addr;		/* Minutes */
+		dest[0] = 0;		/* Reserved */
+	} else {
+		/* Absolute sector */
+		put_be32(dest, addr);
+	}
+}
+
+static int do_read_header(struct fsg_dev *fsg, struct fsg_buffhd *bh)
+{
+	struct lun	*curlun = fsg->curlun;
+	int		msf = fsg->cmnd[1] & 0x02;
+	u32		lba = get_be32(&fsg->cmnd[2]);
+	u8		*buf = (u8 *) bh->buf;
+
+	if ((fsg->cmnd[1] & ~0x02) != 0) {		/* Mask away MSF */
+		curlun->sense_data = SS_INVALID_FIELD_IN_CDB;
+		return -EINVAL;
+	}
+	if (lba >= curlun->num_sectors) {
+		curlun->sense_data = SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;
+		return -EINVAL;
+	}
+
+	memset(buf, 0, 8);
+	buf[0] = 0x01;		/* 2048 bytes of user data, rest is EC */
+	store_cdrom_address(&buf[4], msf, lba);
+	return 8;
+}
+
+
+static int do_read_toc(struct fsg_dev *fsg, struct fsg_buffhd *bh)
+{
+	struct lun	*curlun = fsg->curlun;
+	int		msf = fsg->cmnd[1] & 0x02;
+	int		start_track = fsg->cmnd[6];
+	u8		*buf = (u8 *) bh->buf;
+
+	if ((fsg->cmnd[1] & ~0x02) != 0 ||		/* Mask away MSF */
+			start_track > 1) {
+		curlun->sense_data = SS_INVALID_FIELD_IN_CDB;
+		return -EINVAL;
+	}
+
+	memset(buf, 0, 20);
+	buf[1] = (20-2);		/* TOC data length */
+	buf[2] = 1;			/* First track number */
+	buf[3] = 1;			/* Last track number */
+	buf[5] = 0x16;			/* Data track, copying allowed */
+	buf[6] = 0x01;			/* Only track is number 1 */
+	store_cdrom_address(&buf[8], msf, 0);
+
+	buf[13] = 0x16;			/* Lead-out track is data */
+	buf[14] = 0xAA;			/* Lead-out track number */
+	store_cdrom_address(&buf[16], msf, curlun->num_sectors);
+	return 20;
+}
+
+
 static int do_mode_sense(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 {
 	struct lun	*curlun = fsg->curlun;
@@ -2357,6 +2488,29 @@ static int halt_bulk_in_endpoint(struct fsg_dev *fsg)
 	return rc;
 }
 
+static int wedge_bulk_in_endpoint(struct fsg_dev *fsg)
+{
+	int	rc;
+
+	DBG(fsg, "bulk-in set wedge\n");
+	rc = usb_ep_set_wedge(fsg->bulk_in);
+	if (rc == -EAGAIN)
+		VDBG(fsg, "delayed bulk-in endpoint wedge\n");
+	while (rc != 0) {
+		if (rc != -EAGAIN) {
+			WARN(fsg, "usb_ep_set_wedge -> %d\n", rc);
+			rc = 0;
+			break;
+		}
+
+		/* Wait for a short time and then try again */
+		if (msleep_interruptible(100) != 0)
+			return -EINTR;
+		rc = usb_ep_set_wedge(fsg->bulk_in);
+	}
+	return rc;
+}
+
 static int pad_with_zeros(struct fsg_dev *fsg)
 {
 	struct fsg_buffhd	*bh = fsg->next_buffhd_to_fill;
@@ -2370,7 +2524,8 @@ static int pad_with_zeros(struct fsg_dev *fsg)
 
 		/* Wait for the next buffer to be free */
 		while (bh->state != BUF_STATE_EMPTY) {
-			if ((rc = sleep_thread(fsg)) != 0)
+			rc = sleep_thread(fsg);
+			if (rc)
 				return rc;
 		}
 
@@ -2430,7 +2585,8 @@ static int throw_away_data(struct fsg_dev *fsg)
 		}
 
 		/* Otherwise wait for something to happen */
-		if ((rc = sleep_thread(fsg)) != 0)
+		rc = sleep_thread(fsg);
+		if (rc)
 			return rc;
 	}
 	return 0;
@@ -2552,7 +2708,8 @@ static int send_status(struct fsg_dev *fsg)
 	/* Wait for the next buffer to become available */
 	bh = fsg->next_buffhd_to_fill;
 	while (bh->state != BUF_STATE_EMPTY) {
-		if ((rc = sleep_thread(fsg)) != 0)
+		rc = sleep_thread(fsg);
+		if (rc)
 			return rc;
 	}
 
@@ -2580,7 +2737,7 @@ static int send_status(struct fsg_dev *fsg)
 		struct bulk_cs_wrap	*csw = (struct bulk_cs_wrap *) bh->buf;
 
 		/* Store and send the Bulk-only CSW */
-		csw->Signature = __constant_cpu_to_le32(USB_BULK_CS_SIG);
+		csw->Signature = cpu_to_le32(USB_BULK_CS_SIG);
 		csw->Tag = fsg->tag;
 		csw->Residue = cpu_to_le32(fsg->residue);
 		csw->Status = status;
@@ -2771,10 +2928,20 @@ static int do_scsi_command(struct fsg_dev *fsg)
 
 	dump_cdb(fsg);
 
+#if defined(CONFIG_RTL_ULINKER)
+{
+	extern int rtl_otg_gadget;
+
+	if (fsg->cmnd[0]==0xe0) /* for mode switch */
+		rtl_otg_gadget = 1;
+}
+#endif
+
 	/* Wait for the next buffer to become available for data or status */
 	bh = fsg->next_buffhd_to_drain = fsg->next_buffhd_to_fill;
 	while (bh->state != BUF_STATE_EMPTY) {
-		if ((rc = sleep_thread(fsg)) != 0)
+		rc = sleep_thread(fsg);
+		if (rc)
 			return rc;
 		}
 	fsg->phase_error = 0;
@@ -2864,6 +3031,26 @@ static int do_scsi_command(struct fsg_dev *fsg)
 			reply = do_read_capacity(fsg, bh);
 		break;
 
+	case SC_READ_HEADER:
+		if (!mod_data.cdrom)
+			goto unknown_cmnd;
+		fsg->data_size_from_cmnd = get_be16(&fsg->cmnd[7]);
+		if ((reply = check_command(fsg, 10, DATA_DIR_TO_HOST,
+				(3<<7) | (0x1f<<1), 1,
+				"READ HEADER")) == 0)
+			reply = do_read_header(fsg, bh);
+		break;
+
+	case SC_READ_TOC:
+		if (!mod_data.cdrom)
+			goto unknown_cmnd;
+		fsg->data_size_from_cmnd = get_be16(&fsg->cmnd[7]);
+		if ((reply = check_command(fsg, 10, DATA_DIR_TO_HOST,
+				(7<<6) | (1<<1), 1,
+				"READ TOC")) == 0)
+			reply = do_read_toc(fsg, bh);
+		break;
+
 	case SC_READ_FORMAT_CAPACITIES:
 		fsg->data_size_from_cmnd = get_be16(&fsg->cmnd[7]);
 		if ((reply = check_command(fsg, 10, DATA_DIR_TO_HOST,
@@ -2949,6 +3136,7 @@ static int do_scsi_command(struct fsg_dev *fsg)
 		// Fall through
 
 	default:
+ unknown_cmnd:
 		fsg->data_size_from_cmnd = 0;
 		sprintf(unknown, "Unknown x%02x", fsg->cmnd[0]);
 		if ((reply = check_command(fsg, fsg->cmnd_size,
@@ -2990,7 +3178,7 @@ static int received_cbw(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 
 	/* Is the CBW valid? */
 	if (req->actual != USB_BULK_CB_WRAP_LEN ||
-			cbw->Signature != __constant_cpu_to_le32(
+			cbw->Signature != cpu_to_le32(
 				USB_BULK_CB_SIG)) {
 		DBG(fsg, "invalid CBW: len %u sig 0x%x\n",
 				req->actual,
@@ -3048,7 +3236,8 @@ static int get_next_command(struct fsg_dev *fsg)
 		/* Wait for the next buffer to become available */
 		bh = fsg->next_buffhd_to_fill;
 		while (bh->state != BUF_STATE_EMPTY) {
-			if ((rc = sleep_thread(fsg)) != 0)
+			rc = sleep_thread(fsg);
+			if (rc)
 				return rc;
 			}
 
@@ -3064,7 +3253,8 @@ static int get_next_command(struct fsg_dev *fsg)
 
 		/* Wait for the CBW to arrive */
 		while (bh->state != BUF_STATE_FULL) {
-			if ((rc = sleep_thread(fsg)) != 0)
+			rc = sleep_thread(fsg);
+			if (rc)
 				return rc;
 			}
 		smp_rmb();
@@ -3075,7 +3265,8 @@ static int get_next_command(struct fsg_dev *fsg)
 
 		/* Wait for the next command to arrive */
 		while (fsg->cbbuf_cmnd_size == 0) {
-			if ((rc = sleep_thread(fsg)) != 0)
+			rc = sleep_thread(fsg);
+			if (rc)
 				return rc;
 			}
 
@@ -3278,8 +3469,7 @@ static void handle_exception(struct fsg_dev *fsg)
 	/* Clear the existing signals.  Anything but SIGUSR1 is converted
 	 * into a high-priority EXIT exception. */
 	for (;;) {
-		sig = dequeue_signal_lock(current, &fsg->thread_signal_mask,
-				&info);
+		sig = dequeue_signal_lock(current, &fsg->thread_signal_mask, &info);
 		if (!sig)
 			break;
 		if (sig != SIGUSR1) {
@@ -3432,11 +3622,21 @@ static int fsg_main_thread(void *fsg_)
 
 	/* Allow the thread to be killed by a signal, but set the signal mask
 	 * to block everything but INT, TERM, KILL, and USR1. */
+#if 0 //wei del
 	siginitsetinv(&fsg->thread_signal_mask, sigmask(SIGINT) |
 			sigmask(SIGTERM) | sigmask(SIGKILL) |
 			sigmask(SIGUSR1));
 	sigprocmask(SIG_SETMASK, &fsg->thread_signal_mask, NULL);
+#else
+	allow_signal(SIGINT);
+	allow_signal(SIGTERM);
+	allow_signal(SIGKILL);
+	allow_signal(SIGUSR1);
+
+	/* Allow the thread to be frozen */
+	set_freezable();
 
+#endif
 	/* Arrange for userspace references to be interpreted as kernel
 	 * pointers.  That way we can pass a kernel pointer to a routine
 	 * that expects a __user pointer and it will work okay. */
@@ -3483,11 +3683,12 @@ static int fsg_main_thread(void *fsg_)
 	fsg->thread_task = NULL;
 	spin_unlock_irq(&fsg->lock);
 
-	/* In case we are exiting because of a signal, unregister the
-	 * gadget driver and close the backing file. */
-	if (test_and_clear_bit(REGISTERED, &fsg->atomic_bitflags)) {
+	/* If we are exiting because of a signal, unregister the
+	 * gadget driver. */
+	if (test_and_clear_bit(REGISTERED, &fsg->atomic_bitflags)) 
+        {
 		usb_gadget_unregister_driver(&fsg_driver);
-		close_all_backing_files(fsg);
+		//close_all_backing_files(fsg);  //wei del
 	}
 
 	/* Let the unbind and cleanup routines know the thread has exited */
@@ -3508,6 +3709,7 @@ static int open_backing_file(struct lun *curlun, const char *filename)
 	struct inode			*inode = NULL;
 	loff_t				size;
 	loff_t				num_sectors;
+	loff_t				min_sectors;
 
 	/* R/W if we can, R/O if we must */
 	ro = curlun->ro;
@@ -3546,18 +3748,34 @@ static int open_backing_file(struct lun *curlun, const char *filename)
 		ro = 1;
 
 	size = i_size_read(inode->i_mapping->host);
-	if (size < 0) {
+	if (size < 0) 
+	{
 		LINFO(curlun, "unable to find file size: %s\n", filename);
 		rc = (int) size;
 		goto out;
 	}
-	num_sectors = size >> 9;	// File size in 512-byte sectors
-	if (num_sectors == 0) {
+	num_sectors = size >> 9;	// File size in 512-byte blocks
+	min_sectors = 1;
+#if 0  //wei add	
+	if (mod_data.cdrom) 
+	{
+		num_sectors &= ~3;	// Reduce to a multiple of 2048
+		min_sectors = 300*4;	// Smallest track is 300 frames
+		if (num_sectors >= 256*60*75*4) 
+		{
+			num_sectors = (256*60*75 - 1) * 4;
+			LINFO(curlun, "file too big: %s\n", filename);
+			LINFO(curlun, "using only first %d blocks\n",	(int) num_sectors);
+		}
+	}
+#endif	
+#if 1  //wei add	
+	if (num_sectors < min_sectors) {
 		LINFO(curlun, "file too small: %s\n", filename);
 		rc = -ETOOSMALL;
 		goto out;
 	}
-
+#endif
 	get_file(filp);
 	curlun->ro = ro;
 	curlun->filp = filp;
@@ -3597,6 +3815,7 @@ static ssize_t show_ro(struct device *dev, struct device_attribute *attr, char *
 	return sprintf(buf, "%d\n", curlun->ro);
 }
 
+
 static ssize_t show_file(struct device *dev, struct device_attribute *attr, char *buf)
 {
 	struct lun	*curlun = dev_to_lun(dev);
@@ -3606,8 +3825,9 @@ static ssize_t show_file(struct device *dev, struct device_attribute *attr, char
 
 	down_read(&fsg->filesem);
 	if (backing_file_is_open(curlun)) {	// Get the complete pathname
-		p = d_path(curlun->filp->f_dentry, curlun->filp->f_vfsmnt,
-				buf, PAGE_SIZE - 1);
+		//p = d_path(curlun->filp->f_dentry, curlun->filp->f_vfsmnt,buf, PAGE_SIZE - 1);  //wei add, del
+		p = d_path(&curlun->filp->f_path, buf, PAGE_SIZE - 1);
+
 		if (IS_ERR(p))
 			rc = PTR_ERR(p);
 		else {
@@ -3756,7 +3976,7 @@ static void /* __init_or_exit */ fsg_unbind(struct usb_gadget *gadget)
 }
 
 
-static int __init check_parameters(struct fsg_dev *fsg)
+static int  check_parameters(struct fsg_dev *fsg)
 {
 	int	prot;
 	int	gcnum;
@@ -3767,6 +3987,11 @@ static int __init check_parameters(struct fsg_dev *fsg)
 	mod_data.protocol_type = USB_SC_SCSI;
 	mod_data.protocol_name = "Transparent SCSI";
 
+#if 1 //wei add
+	mod_data.file[0]= "/etc/autorun.img";
+	mod_data.num_filenames=1;
+#endif
+
 	if (gadget_is_sh(fsg->gadget))
 		mod_data.can_stall = 0;
 
@@ -3841,7 +4066,7 @@ static int __init check_parameters(struct fsg_dev *fsg)
 }
 
 
-static int __init fsg_bind(struct usb_gadget *gadget)
+static int  fsg_bind(struct usb_gadget *gadget)
 {
 	struct fsg_dev		*fsg = the_fsg;
 	int			rc;
@@ -3863,6 +4088,10 @@ static int __init fsg_bind(struct usb_gadget *gadget)
 		dev_attr_ro.attr.mode = dev_attr_file.attr.mode = 0644;
 		dev_attr_ro.store = store_ro;
 		dev_attr_file.store = store_file;
+		if (!mod_data.cdrom) {
+			dev_attr_ro.attr.mode = 0644;
+			dev_attr_ro.store = store_ro;
+		}
 	}
 
 	/* Find out how many LUNs there should be */
@@ -3887,12 +4116,15 @@ static int __init fsg_bind(struct usb_gadget *gadget)
 	for (i = 0; i < fsg->nluns; ++i) {
 		curlun = &fsg->luns[i];
 		curlun->ro = mod_data.ro[i];
+		if (mod_data.cdrom)
+			curlun->ro = 1;
 		curlun->dev.release = lun_release;
 		curlun->dev.parent = &gadget->dev;
 		curlun->dev.driver = &fsg_driver.driver;
 		dev_set_drvdata(&curlun->dev, fsg);
-		snprintf(curlun->dev.bus_id, BUS_ID_SIZE,
-				"%s-lun%d", gadget->dev.bus_id, i);
+//		snprintf(curlun->dev.bus_id, BUS_ID_SIZE,	"%s-lun%d", gadget->dev.bus_id, i);  //wei add
+//		snprintf(curlun->dev.name, BUS_ID_SIZE,	"%s-lun%d", gadget->dev.name, i);  //wei add
+		dev_set_name(&curlun->dev,"%s-lun%d",    dev_name(&gadget->dev), i);
 
 		if ((rc = device_register(&curlun->dev)) != 0) {
 			INFO(fsg, "failed to register LUN%d: %d\n", i, rc);
@@ -3953,7 +4185,7 @@ static int __init fsg_bind(struct usb_gadget *gadget)
 	intf_desc.bInterfaceProtocol = mod_data.transport_type;
 	fs_function[i + FS_FUNCTION_PRE_EP_ENTRIES] = NULL;
 
-#ifdef CONFIG_USB_GADGET_DUALSPEED
+
 	hs_function[i + HS_FUNCTION_PRE_EP_ENTRIES] = NULL;
 
 	/* Assume ep0 uses the same maxpacket value for both speeds */
@@ -3963,7 +4195,7 @@ static int __init fsg_bind(struct usb_gadget *gadget)
 	hs_bulk_in_desc.bEndpointAddress = fs_bulk_in_desc.bEndpointAddress;
 	hs_bulk_out_desc.bEndpointAddress = fs_bulk_out_desc.bEndpointAddress;
 	hs_intr_in_desc.bEndpointAddress = fs_intr_in_desc.bEndpointAddress;
-#endif
+
 
 	if (gadget->is_otg) {
 		otg_desc.bmAttributes |= USB_OTG_HNP,
@@ -4030,9 +4262,8 @@ static int __init fsg_bind(struct usb_gadget *gadget)
 		if (backing_file_is_open(curlun)) {
 			p = NULL;
 			if (pathbuf) {
-				p = d_path(curlun->filp->f_dentry,
-					curlun->filp->f_vfsmnt,
-					pathbuf, PATH_MAX);
+				//p = d_path(curlun->filp->f_dentry,curlun->filp->f_vfsmnt,pathbuf, PATH_MAX);   //wei add
+				p = d_path(&curlun->filp->f_path,   pathbuf, PATH_MAX);
 				if (IS_ERR(p))
 					p = NULL;
 			}
@@ -4048,15 +4279,22 @@ static int __init fsg_bind(struct usb_gadget *gadget)
 			mod_data.protocol_name, mod_data.protocol_type);
 	DBG(fsg, "VendorID=x%04x, ProductID=x%04x, Release=x%04x\n",
 			mod_data.vendor, mod_data.product, mod_data.release);
-	DBG(fsg, "removable=%d, stall=%d, buflen=%u\n",
+	DBG(fsg, "removable=%d, stall=%d, cdrom=%d, buflen=%u\n",
 			mod_data.removable, mod_data.can_stall,
-			mod_data.buflen);
-	DBG(fsg, "I/O thread pid: %d\n", fsg->thread_task->pid);
+			mod_data.cdrom, mod_data.buflen);
+	//DBG(fsg, "I/O thread pid: %d\n", fsg->thread_task->pid);  //wei del
+	DBG(fsg, "I/O thread pid: %d\n", task_pid_nr(fsg->thread_task));
 
 	set_bit(REGISTERED, &fsg->atomic_bitflags);
 
 	/* Tell the thread to start working */
 	wake_up_process(fsg->thread_task);
+
+	printk("HangUp Res\n");
+	extern void HangUpRes(int en);
+	HangUpRes(1);
+
+	
 	return 0;
 
 autoconf_fail:
@@ -4066,7 +4304,8 @@ autoconf_fail:
 out:
 	fsg->state = FSG_STATE_TERMINATED;	// The thread is dead
 	fsg_unbind(gadget);
-	close_all_backing_files(fsg);
+	//close_all_backing_files(fsg);  //wei del
+	complete(&fsg->thread_notifier);
 	return rc;
 }
 
@@ -4100,7 +4339,7 @@ static struct usb_gadget_driver		fsg_driver = {
 #endif
 	.function	= (char *) longname,
 	.bind		= fsg_bind,
-	.unbind		= __exit_p(fsg_unbind),
+	.unbind		= fsg_unbind,	
 	.disconnect	= fsg_disconnect,
 	.setup		= fsg_setup,
 	.suspend	= fsg_suspend,
@@ -4116,7 +4355,7 @@ static struct usb_gadget_driver		fsg_driver = {
 };
 
 
-static int __init fsg_alloc(void)
+static int  fsg_alloc(void)
 {
 	struct fsg_dev		*fsg;
 
@@ -4132,8 +4371,8 @@ static int __init fsg_alloc(void)
 	return 0;
 }
 
-
-static int __init fsg_init(void)
+//============================================================
+static int  fsg_init(void)
 {
 	int		rc;
 	struct fsg_dev	*fsg;
@@ -4145,11 +4384,72 @@ static int __init fsg_init(void)
 		kref_put(&fsg->ref, fsg_release);
 	return rc;
 }
-module_init(fsg_init);
+//module_init(fsg_init);
 
+//=============================================================
+static void  fsg_cleanup(void)
+{
+	struct fsg_dev	*fsg = the_fsg;
 
-static void __exit fsg_cleanup(void)
+	/* Unregister the driver iff the thread hasn't already done so */
+	if (test_and_clear_bit(REGISTERED, &fsg->atomic_bitflags))
+		usb_gadget_unregister_driver(&fsg_driver);
+
+	/* Wait for the thread to finish up */
+	wait_for_completion(&fsg->thread_notifier);
+
+	close_all_backing_files(fsg);
+	kref_put(&fsg->ref, fsg_release);
+}
+//module_exit(fsg_cleanup);
+
+//================================================================
+#if defined(CONFIG_USB_ETH_RNDIS)
+int fsg_reg_again(void)
+#else
+int eth_reg_again(void)
+#endif
 {
+#if 0
+	int ret=0;
+	 ret=usb_gadget_register_driver (&fsg_driver);
+	 if(ret!=0) printk("Storage: gad reg fail \n");
+	 else        printk("Storage: gad reg ok \n");
+	 return ret;
+#else
+
+	int		rc=0;
+	struct fsg_dev	*fsg;
+
+	printk("storage: register\n");
+	if ((rc = fsg_alloc()) != 0)
+		return rc;
+
+	printk("storage: alloc ok, dev=%x\n", the_fsg);	
+	fsg = the_fsg;
+
+	printk("storage: driver=%x\n ", fsg_driver);	
+	
+	if ((rc = usb_gadget_register_driver(&fsg_driver)) != 0)
+		kref_put(&fsg->ref, fsg_release);
+	return rc;
+#endif
+}
+
+#if defined(CONFIG_USB_ETH_RNDIS)
+int fsg_unreg_again(void)
+#else
+int eth_unreg_again(void)
+#endif
+{
+#if 0
+	int ret;
+	ret=usb_gadget_unregister_driver (&fsg_driver);
+	if(ret!=0)	printk("Storage: gad unreg fail\n");
+	else			printk("Storage: gad unreg pass \n");
+	 return ret;
+#else
+
 	struct fsg_dev	*fsg = the_fsg;
 
 	/* Unregister the driver iff the thread hasn't already done so */
@@ -4161,5 +4461,7 @@ static void __exit fsg_cleanup(void)
 
 	close_all_backing_files(fsg);
 	kref_put(&fsg->ref, fsg_release);
+#endif
 }
-module_exit(fsg_cleanup);
+
+
diff --git a/drivers/usb/gadget_cathy/rndis.c b/drivers/usb/gadget_cathy/rndis.c
index e0ecd9d..22151b2 100644
--- a/drivers/usb/gadget_cathy/rndis.c
+++ b/drivers/usb/gadget_cathy/rndis.c
@@ -44,6 +44,9 @@
 
 #include "rndis.h"
 
+#if defined(CONFIG_RTL_ULINKER)
+#include "usb_ulinker.h"
+#endif
 
 /* The driver for your USB chip needs to support ep0 OUT to work with
  * RNDIS, plus all three CDC Ethernet endpoints (interrupt not optional).
@@ -1398,7 +1401,7 @@ static struct proc_dir_entry *rndis_connect_state [RNDIS_MAX_CONFIGS];
 #endif	/* CONFIG_USB_GADGET_DEBUG_FILES */
 
 
-int __devinit rndis_init (void)
+int ULINKER_DEVINIT rndis_init (void)
 {
 	u8 i;
 
diff --git a/drivers/usb/gadget_cathy/rndis.h b/drivers/usb/gadget_cathy/rndis.h
index c61bd2f..35d5d7e 100644
--- a/drivers/usb/gadget_cathy/rndis.h
+++ b/drivers/usb/gadget_cathy/rndis.h
@@ -19,6 +19,10 @@
 
 #include "ndis.h"
 
+#if defined(CONFIG_RTL_ULINKER)
+#include "usb_ulinker.h"
+#endif
+
 #define RNDIS_MAXIMUM_FRAME_SIZE	1518
 #define RNDIS_MAX_TOTAL_SIZE		1558
 
@@ -264,7 +268,7 @@ int  rndis_signal_disconnect (int configNr);
 int  rndis_state (int configNr);
 extern void rndis_set_host_mac (int configNr, const u8 *addr);
 
-int __devinit rndis_init (void);
+int ULINKER_DEVINIT rndis_init (void);
 void rndis_exit (void);
 
 #endif  /* _LINUX_RNDIS_H */
diff --git a/drivers/usb/gadget_cathy/usb_gadget.h b/drivers/usb/gadget_cathy/usb_gadget.h
index 5321e1a..7c11648 100644
--- a/drivers/usb/gadget_cathy/usb_gadget.h
+++ b/drivers/usb/gadget_cathy/usb_gadget.h
@@ -22,6 +22,10 @@
 #include "usb_ch9.h"
 //#include "../otg/lm.h"
 
+#if defined(CONFIG_RTL_ULINKER)
+#include "usb_ulinker.h"
+#endif
+
 //struct usb_ep;
 /**
  * struct usb_ep - device side representation of USB endpoint
@@ -892,9 +896,9 @@ int usb_gadget_config_buf(const struct usb_config_descriptor *config,
 /* utility wrapping a simple endpoint selection policy */
 #if 0
 extern struct usb_ep *usb_ep_autoconfig (struct usb_gadget *,
-			struct usb_endpoint_descriptor *) __devinit;
+			struct usb_endpoint_descriptor *) ULINKER_DEVINIT;
 
-extern void usb_ep_autoconfig_reset (struct usb_gadget *) __devinit;
+extern void usb_ep_autoconfig_reset (struct usb_gadget *) ULINKER_DEVINIT;
 #endif
 //#endif  /* __KERNEL__ */
 
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index f163571..9e62ed1 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -6,6 +6,9 @@ ifeq ($(CONFIG_USB_DEBUG),y)
 	EXTRA_CFLAGS		+= -DDEBUG
 endif
 
+ifeq ($(CONFIG_RTL_819X),y)
+	EXTRA_CFLAGS		+= -I$(DIR_BOARD)
+endif
 isp1760-objs := isp1760-hcd.o isp1760-if.o
 fhci-objs := fhci-hcd.o fhci-hub.o fhci-q.o fhci-mem.o \
 	     fhci-tds.o fhci-sched.o
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 18f198e..27c884a 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1073,7 +1073,11 @@ MODULE_LICENSE ("GPL");
 #error "missing bus glue for ehci-hcd"
 #endif
 
+#if defined(CONFIG_RTL_ULINKER)
+int ehci_hcd_init(void)
+#else
 static int __init ehci_hcd_init(void)
+#endif
 {
 	if (test_bit(USB_EHCI_LOADED, &usb_hcds_loaded))
 	{	printk("EHCI-HCD: already init \n");
@@ -1149,7 +1153,11 @@ err_out:
 }
 module_init(ehci_hcd_init);
 //-----------------------------------------------------------
+#if defined(CONFIG_RTL_ULINKER)
+void  ehci_hcd_cleanup(void)  //wei add
+#else
 static void __exit ehci_hcd_cleanup(void)
+#endif
 {
 	if (!test_bit(USB_EHCI_LOADED, &usb_hcds_loaded))
 	{	printk("EHCI-HCD: not init, cannot cleanup \n");
diff --git a/drivers/usb/host/ehci-rtl8652.c b/drivers/usb/host/ehci-rtl8652.c
index 1be39ae..e51727a 100644
--- a/drivers/usb/host/ehci-rtl8652.c
+++ b/drivers/usb/host/ehci-rtl8652.c
@@ -317,13 +317,32 @@ static struct platform_driver ehci_rtl8652_driver = {
 		   .name = "rtl8652-ehci",
 		   },
 };
-#if defined(CONFIG_RTL_8196C)
+#if 1//defined(CONFIG_RTL_8196C)
 void SetUSBPhy(unsigned char reg, unsigned char val)
 {
 	
 	#define	USB2_PHY_DELAY	{mdelay(5);}
 	//8196C demo board: 0xE0:99, 0xE1:A8, 0xE2:98, 0xE3:C1,  0xE5:91, 	
+#if !CONFIG_RTL_819XD //8198	
 	REG32(0xb8000034) = (0x1f00 | val); USB2_PHY_DELAY;
+#else  //8196D
+	#define SYS_USB_SIE 0xb8000034
+	#define SYS_USB_PHY 0xb8000090 	
+ 	int oneportsel=(REG32(SYS_USB_SIE) & (1<<18))>>18;
+	
+	unsigned int tmp = REG32(SYS_USB_PHY);  //8672 only	
+	tmp = tmp & ~((0xff<<11)|(0xff<<0));
+
+	
+	if(oneportsel==0)
+	{	REG32(SYS_USB_PHY) = (val << 0) | tmp;   //phy 0
+	}
+	else
+	{	REG32(SYS_USB_PHY) = (val << 11) | tmp;  //phy1
+	}
+
+	USB2_PHY_DELAY;
+#endif
 	//printk("0xb8000034=%08x\n", REG32(0xb8000034));		
 	
 	unsigned char reg_h=(reg &0xf0)>>4;
@@ -461,24 +480,113 @@ static void synopsys_usb_patch(void)
 #endif
 	return;
 }
+//--------------------------------------------
+void EnableUSBPHY(int portnum)
+{
+	if(portnum==0)
+	{
+	//phy0
+	  REG32(0xb8000090) |= (1<<8);	 //USBPHY_EN=1
+	  REG32(0xb8000090) |=   (1<<9);	 //usbphy_reset=1, active high		  
+	  REG32(0xb8000090) &= ~(1<<9);	 //usbphy_reset=0, active high	  	  
+	  REG32(0xb8000090) |= (1<<10);	 //active_usbphyt=1	  
+
+	}
+	else
+	{
+	//phy1
+	  REG32(0xb8000090) |= (1<<19);	 //USBPHY_EN=1
+	  REG32(0xb8000090) |=   (1<<20);	 //usbphy_reset=1, active high	 	  
+	  REG32(0xb8000090) &= ~(1<<20);	 //usbphy_reset=0, active high	  
+	  REG32(0xb8000090) |= (1<<21);	 //active_usbphyt=1	  
+
 
+	}
+}
+//----------------------------------------------
 /*here register platform rtl8652 usb device.
   do it in kernel boot is a good choice*/
  static struct platform_device *usb_dev_host = NULL;  //wei add
  //----------------------------------------------------------------------
 static int  ehci_rtl8652_init(void)
 {
-	 REG32(0xb8000010)=REG32(0xb8000010)|0x20000;
-	/*register platform device*/
-	int retval;
-	//static struct platform_device *usb_dev_host = NULL;
+
 
 	if(usb_dev_host!=NULL)
 	{	printk("Ehci-rtl8652.c: EHCI device already init\n");
 		return -1;
 	}
 
+#if !defined(CONFIG_RTL_819XD)  //8198
+	 REG32(0xb8000010)=REG32(0xb8000010)|(1<<17);
+#else //8196D
 
+#if 0
+		extern void HangUpRes(int);
+		HangUpRes(1);
+#endif
+
+	//one port sel
+	//is 0: phy#1 connect OTG  mac, EHCI is in phy0	
+	//is 1: phy#1 connect EHCI mac
+	
+#ifdef CONFIG_RTL_USB_OTG
+	int oneportsel=0;
+	REG32(0xb8000034) &= ~(1<<18);	 //one port sel=0
+#else
+#if 1  //software force
+	int oneportsel=1;
+	if(oneportsel==1)
+	{	 REG32(0xb8000034) |= (1<<18);	 //one port sel=1
+	}
+	else
+	{	REG32(0xb8000034) &= ~(1<<18);	 //one port sel=0
+	}
+#else  //read-back decide
+	int oneportsel= (REG32(0xb8000034) & (1<<18))>>18;
+	printk("EHCI: one_port_host_sel=%d, EHCI in Port %s\n", oneportsel, (oneportsel==0) ? "0": "1");
+#endif
+#endif
+	//sie
+	 REG32(0xb8000034) |= (1<<11);	 //s_utmi_suspend0=1
+	 REG32(0xb8000034) |= (1<<12);	 //en_usbhost=1	 
+	 REG32(0xb8000034) |= (1<<17);	 //enable pgbndry_disable=1	 
+
+	 
+	 if(oneportsel==1)
+	 {
+	 	EnableUSBPHY(1);
+	 }	 
+	 else //if(oneportsel==1)
+	 {//phy0, phy1
+#ifdef CONFIG_RTL_OTGCTRL	 
+	 extern unsigned int  TurnOn_OTGCtrl_Interrupt(unsigned int);
+	unsigned int old= TurnOn_OTGCtrl_Interrupt(0);
+#endif	
+		EnableUSBPHY(0);
+		EnableUSBPHY(1);
+#ifdef CONFIG_RTL_OTGCTRL		  
+	  TurnOn_OTGCtrl_Interrupt(old);
+#endif	  
+	 }
+
+	 
+	//ip clock mgr
+	 REG32(0xb8000010) |= (1<<12)|(1<<13)|(1<<19)|(1<<20);	 //enable lx1, lx2
+	 REG32(0xb8000010) |= (1<<21);	 //enable host ip
+
+	mdelay(100);
+	 printk("b8021000=%x\n", REG32(0xb8021000) );
+	 printk("b8021054=%x\n", REG32(0xb8021054) );
+
+	 /*	b8021000=10000001
+		b8021054=200000
+	*/	
+
+#endif	 
+	/*register platform device*/
+	int retval;
+	//static struct platform_device *usb_dev_host = NULL;
 	struct resource r[2];
 	memset(&r, 0, sizeof(r));
 
@@ -500,6 +608,8 @@ static int  ehci_rtl8652_init(void)
 		usb_dev_host=NULL;  //wei add
 		goto err;
 	}
+
+#if 0 	
 #if defined(CONFIG_RTL_8198)
 #ifdef CONFIG_RTL8198_REVISION_B
 	// rock: pin_mux for USB over-current detection in rtl8198_rev_a
@@ -512,6 +622,31 @@ static int  ehci_rtl8652_init(void)
 #else
 	synopsys_usb_patch();
 #endif
+#endif
+#if defined(CONFIG_RTL_8196C)
+	synopsys_usb_patch();
+#endif
+#if 1 //wei add
+
+//	disable Host chirp J-K
+//	SetUSBPhy(0xf4,0xe3);	GetUSBPhy(0xf4);
+	//if(oneportsel==1)
+	//SetUSBPhy(0xe6,0xb8);  //disconnect, work
+	//SetUSBPhy(0xe6,0xc8); 
+	
+	//SetUSBPhy(0xe7,0x1c);  //jwen tell
+	//dump
+	int i;
+	for(i=0xe0;i<=0xe7; i++)
+		printk("reg %x=%x\n", i,GetUSBPhy(i) );
+	for(i=0xf0;i<=0xf6; i++)
+		printk("reg %x=%x\n", i,GetUSBPhy(i) );	
+	//FPGA Patch
+	//printk("FPGA patch\n");
+	//REG32(0xb8021094)=0x80008000;  //fpga threshold
+
+	
+#endif
 
 	return 0;
 	err:
@@ -530,4 +665,20 @@ void  ehci_rtl8652_cleanup(void)
 	usb_dev_host=NULL;
 	
 }
+//----------------------------------------------------------------------
+#if 0
+void ehci_autodet_probe()
+{
+	if(usb_dev_host!=NULL)
+	{ehci_rtl8652_drv_probe(usb_dev_host);	
+	}
+}
 
+void ehci_autodet_remove()
+{
+	if(usb_dev_host!=NULL)
+	{ehci_rtl8652_drv_remove(usb_dev_host);
+	}
+
+}
+#endif
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 388dad5..f5f2fda 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -33,7 +33,7 @@
  * It keeps track of every ITD (or SITD) that's linked, and holds enough
  * pre-calculated schedule data to make appending to the queue be quick.
  */
-
+// #define CONFIG_USB_3G_SUPPORT //for specifical dongle
 static int ehci_get_frame (struct usb_hcd *hcd);
 
 /*-------------------------------------------------------------------------*/
@@ -323,7 +323,11 @@ static int tt_available (
 		 * already scheduled transactions
 		 */
 		if (125 < usecs) {
+#ifdef CONFIG_USB_3G_SUPPORT
+		nt ufs = (usecs / 125) - 1;
+#else
 			int ufs = (usecs / 125);
+#endif
 			int i;
 			for (i = uframe; i < (uframe + ufs) && i < 8; i++)
 				if (0 < tt_usecs[i]) {
@@ -436,15 +440,23 @@ static int enable_periodic (struct ehci_hcd *ehci)
 {
 	u32	cmd;
 	int	status;
-
+#ifndef CONFIG_USB_3G_SUPPORT
 	if (ehci->periodic_sched++)
 		return 0;
+#else
+        udelay(1024);
+#endif
 
 	/* did clearing PSE did take effect yet?
 	 * takes effect only at frame boundaries...
 	 */
 	status = handshake_on_error_set_halt(ehci, &ehci->regs->status,
-					     STS_PSS, 0, 9 * 125);
+					     STS_PSS, 0, 
+						#ifdef CONFIG_USB_3G_SUPPORT
+						120000 * 125);
+						#else
+						9 * 125);
+						#endif
 	if (status)
 		return status;
 
@@ -471,7 +483,12 @@ static int disable_periodic (struct ehci_hcd *ehci)
 	 * takes effect only at frame boundaries...
 	 */
 	status = handshake_on_error_set_halt(ehci, &ehci->regs->status,
-					     STS_PSS, STS_PSS, 9 * 125);
+					     STS_PSS, STS_PSS, 
+#ifdef CONFIG_USB_3G_SUPPORT
+						120000 * 125);
+#else
+						9 * 125);
+#endif
 	if (status)
 		return status;
 
@@ -550,7 +567,14 @@ static int qh_link_periodic (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		: (qh->usecs * 8);
 
 	/* maybe enable periodic schedule processing */
+#ifdef CONFIG_USB_3G_SUPPORT
+        if (!ehci->periodic_sched++)
 	return enable_periodic(ehci);
+	return 0;
+
+#else
+	return enable_periodic(ehci);
+#endif
 }
 
 static int qh_unlink_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
@@ -589,7 +613,14 @@ static int qh_unlink_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	qh_put (qh);
 
 	/* maybe turn off periodic schedule */
+        #ifdef CONFIG_USB_3G_SUPPORT
+        ehci->periodic_sched--;
+	if (!ehci->periodic_sched)
+		(void) disable_periodic (ehci);
+
+        #else
 	return disable_periodic(ehci);
+        #endif
 }
 
 static void intr_deschedule (struct ehci_hcd *ehci, struct ehci_qh *qh)
@@ -606,10 +637,18 @@ static void intr_deschedule (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	if (list_empty (&qh->qtd_list)
 			|| (cpu_to_hc32(ehci, QH_CMASK)
 					& qh->hw_info2) != 0)
+#ifdef CONFIG_USB_3G_SUPPORT
+		wait =  55;
+#else
 		wait = 2;
+#endif
 	else
+#ifdef CONFIG_RTL_USB_OTG
+		wait = 55;	/* worst case: 3 * 1024 */
+#else
 		//wait = 55;	/* worst case: 3 * 1024 */
 		wait = 3 * 1024;
+#endif
 
 	udelay (wait);
 	qh->qh_state = QH_STATE_IDLE;
@@ -1565,7 +1604,13 @@ itd_link_urb (
 	urb->hcpriv = NULL;
 
 	timer_action (ehci, TIMER_IO_WATCHDOG);
+#ifdef CONFIG_USB_3G_SUPPORT
+        if (unlikely (!ehci->periodic_sched++))
+	return enable_periodic(ehci);
+	return 0;
+#else
 	return enable_periodic(ehci);
+#endif
 }
 
 #define	ISO_ERRS (EHCI_ISOC_BUF_ERR | EHCI_ISOC_BABBLE | EHCI_ISOC_XACTERR)
@@ -1646,7 +1691,14 @@ itd_complete (
 	ehci_urb_done(ehci, urb, 0);
 	retval = true;
 	urb = NULL;
+#ifdef CONFIG_USB_3G_SUPPORT
+        /* defer stopping schedule; completion can submit */
+	ehci->periodic_sched--;
+	if (unlikely (!ehci->periodic_sched))
+
+#else
 	(void) disable_periodic(ehci);
+#endif
 	ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs--;
 
 	if (unlikely(list_is_singular(&stream->td_list))) {
@@ -1968,7 +2020,13 @@ sitd_link_urb (
 	urb->hcpriv = NULL;
 
 	timer_action (ehci, TIMER_IO_WATCHDOG);
+#ifdef CONFIG_USB_3G_SUPPORT
+        if (!ehci->periodic_sched++)
 	return enable_periodic(ehci);
+	return 0;
+#else
+	return enable_periodic(ehci);
+#endif
 }
 
 /*-------------------------------------------------------------------------*/
@@ -2035,6 +2093,11 @@ sitd_complete (
 	ehci_urb_done(ehci, urb, 0);
 	retval = true;
 	urb = NULL;
+#ifdef CONFIG_USB_3G_SUPPORT
+        /* defer stopping schedule; completion can submit */
+	ehci->periodic_sched--;
+	if (!ehci->periodic_sched)
+#endif
 	(void) disable_periodic(ehci);
 	ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs--;
 
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 04d0445..5d35e01 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -1097,7 +1097,11 @@ MODULE_LICENSE ("GPL");
 #error "missing bus glue for ohci-hcd"
 #endif
 
+#if defined(CONFIG_RTL_ULINKER)
+int  ohci_hcd_mod_init(void)  //wei add
+#else
 static int __init ohci_hcd_mod_init(void)
+#endif
 {
 	if ( test_bit(USB_OHCI_LOADED, &usb_hcds_loaded))
 	{	printk("OHCI-HCD: already init \n");
@@ -1226,7 +1230,11 @@ err_out:
 }
 module_init(ohci_hcd_mod_init);
 //-----------------------------------------------------------
+#if defined(CONFIG_RTL_ULINKER)
+void  ohci_hcd_mod_exit(void)  //wei add
+#else
 static void __exit ohci_hcd_mod_exit(void)
+#endif
 {
 	if (!test_bit(USB_OHCI_LOADED, &usb_hcds_loaded))
 	{	printk("OHCI-HCD: not init, cannot cleanup \n");
diff --git a/drivers/usb/misc/ftdi-elan.c b/drivers/usb/misc/ftdi-elan.c
index 9d0675e..527f296 100644
--- a/drivers/usb/misc/ftdi-elan.c
+++ b/drivers/usb/misc/ftdi-elan.c
@@ -73,7 +73,12 @@ static struct list_head ftdi_static_list;
 */
 #include "usb_u132.h"
 #include <asm/io.h>
+
+#if defined(CONFIG_USB_UWIFI_HOST)
+#include "../core_uWiFi/hcd.h"
+#else
 #include "../core/hcd.h"
+#endif
 
 	/* FIXME ohci.h is ONLY for internal use by the OHCI driver.
 	 * If you're going to try stuff like this, you need to split
diff --git a/drivers/usb/mon/mon_main.c b/drivers/usb/mon/mon_main.c
index 5e0ab42..fc73d82 100644
--- a/drivers/usb/mon/mon_main.c
+++ b/drivers/usb/mon/mon_main.c
@@ -13,7 +13,12 @@
 #include <linux/mutex.h>
 
 #include "usb_mon.h"
+
+#if defined(CONFIG_USB_UWIFI_HOST)
+#include "../core_uWiFi/hcd.h"
+#else
 #include "../core/hcd.h"
+#endif
 
 static void mon_stop(struct mon_bus *mbus);
 static void mon_dissolve(struct mon_bus *mbus, struct usb_bus *ubus);
diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index efb39b5..dcc2985 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -60,7 +60,12 @@ struct musb_ep;
 #include "musb_regs.h"
 
 #include "musb_gadget.h"
+
+#if defined(CONFIG_USB_UWIFI_HOST)
+#include "../core_uWiFi/hcd.h"
+#else
 #include "../core/hcd.h"
+#endif
 #include "musb_host.h"
 
 
diff --git a/drivers/usb/serial/mct_u232.c b/drivers/usb/serial/mct_u232.c
index 08ba8e6..6d64727 100644
--- a/drivers/usb/serial/mct_u232.c
+++ b/drivers/usb/serial/mct_u232.c
@@ -416,8 +416,8 @@ static void mct_u232_release(struct usb_serial *serial)
 	for (i = 0; i < serial->num_ports; ++i) {
 		/* My special items, the standard routines free my urbs */
 		priv = usb_get_serial_port_data(serial->port[i]);
-		kfree(priv);
-	}
+			kfree(priv);
+		}
 } /* mct_u232_release */
 
 static int  mct_u232_open(struct tty_struct *tty,
diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c
index b72bbe1..c7ac37a 100644
--- a/drivers/usb/serial/option.c
+++ b/drivers/usb/serial/option.c
@@ -161,6 +161,7 @@ static int  option_resume(struct usb_serial *serial);
 #define HUAWEI_PRODUCT_E143D			0x143D
 #define HUAWEI_PRODUCT_E143E			0x143E
 #define HUAWEI_PRODUCT_E143F			0x143F
+#define HUAWEI_PRODUCT_K4505			0x1464
 
 #define QUANTA_VENDOR_ID			0x0408
 #define QUANTA_PRODUCT_Q101			0xEA02
@@ -316,6 +317,9 @@ static int  option_resume(struct usb_serial *serial);
 #define SMPS_VENDOR_ID              0xfeed
 #define SMPS_PRODUCT_TITAN20            0x1234
 
+/* VIBO */
+#define VIBO_VENDOR_ID				0x1c9e
+#define VIBO_PRODUCT_D200			0x9605
 
 static struct usb_device_id option_ids[] = {
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_COLT) },
@@ -547,6 +551,12 @@ static struct usb_device_id option_ids[] = {
     /* mobilepeak */
     { USB_DEVICE_AND_INTERFACE_INFO(SMPS_VENDOR_ID, SMPS_PRODUCT_TITAN20, 0xff, 0xff, 0xff) },
 
+	/* Huawei*/
+	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_K4505, 0xff, 0xff, 0xff) },
+
+	/* vibo */
+    { USB_DEVICE(VIBO_VENDOR_ID, VIBO_PRODUCT_D200) },
+
 	{ } /* Terminating entry */
 };
 MODULE_DEVICE_TABLE(usb, option_ids);
diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index dbef77f..ea05b63 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -161,7 +161,7 @@ static void destroy_serial(struct kref *kref)
 					i < serial->num_port_pointers; ++i) {
 			port = serial->port[i];
 			if (port)
-				port_free(port);
+			port_free(port);
 		}
 	}
 
diff --git a/drivers/usb/serial/visor.c b/drivers/usb/serial/visor.c
index e50f397..c17c934 100644
--- a/drivers/usb/serial/visor.c
+++ b/drivers/usb/serial/visor.c
@@ -929,8 +929,8 @@ static void visor_release(struct usb_serial *serial)
 
 	for (i = 0; i < serial->num_ports; i++) {
 		priv = usb_get_serial_port_data(serial->port[i]);
-		kfree(priv);
-	}
+			kfree(priv);
+		}
 }
 
 static int __init visor_init(void)
diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 1d76bf0..cac5675 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -1865,6 +1865,13 @@ UNUSUAL_DEV( 0xed10, 0x7636, 0x0001, 0x0001,
 		"Digital MP3 Audio Player",
 		US_SC_DEVICE, US_PR_DEVICE, NULL, US_FL_NOT_LOCKABLE ),
 
+/* brucehou@RTK for AMOI H01 */
+UNUSUAL_DEV(  0x1614, 0x0800, 0x0000, 0x0000,
+		"Amoi",
+		"Mass Storage",
+		US_SC_DEVICE, US_PR_DEVICE, option_ms_init,
+		0),
+
 /* Control/Bulk transport for all SubClass values */
 USUAL_DEV(US_SC_RBC, US_PR_CB, USB_US_TYPE_STOR),
 USUAL_DEV(US_SC_8020, US_PR_CB, USB_US_TYPE_STOR),
diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c
index b4fb1d0..145b486 100644
--- a/fs/binfmt_elf.c
+++ b/fs/binfmt_elf.c
@@ -502,21 +502,21 @@ static unsigned long load_elf_interp(struct elfhdr *interp_elf_ex,
 	}
 
 	if (last_bss > elf_bss) {
-		/*
-		 * Now fill out the bss section.  First pad the last page up
-		 * to the page boundary, and then perform a mmap to make sure
-		 * that there are zero-mapped pages up to and including the
-		 * last bss page.
-		 */
-		if (padzero(elf_bss)) {
-			error = -EFAULT;
-			goto out_close;
-		}
+	/*
+	 * Now fill out the bss section.  First pad the last page up
+	 * to the page boundary, and then perform a mmap to make sure
+	 * that there are zero-mapped pages up to and including the 
+	 * last bss page.
+	 */
+	if (padzero(elf_bss)) {
+		error = -EFAULT;
+		goto out_close;
+	}
 
-		/* What we have mapped so far */
-		elf_bss = ELF_PAGESTART(elf_bss + ELF_MIN_ALIGN - 1);
+	/* What we have mapped so far */
+	elf_bss = ELF_PAGESTART(elf_bss + ELF_MIN_ALIGN - 1);
 
-		/* Map the last of the bss segment */
+	/* Map the last of the bss segment */
 		down_write(&current->mm->mmap_sem);
 		error = do_brk(elf_bss, last_bss - elf_bss);
 		up_write(&current->mm->mmap_sem);
diff --git a/fs/binfmt_flat.c b/fs/binfmt_flat.c
index e92f229..204b56d 100644
--- a/fs/binfmt_flat.c
+++ b/fs/binfmt_flat.c
@@ -841,8 +841,8 @@ static int load_flat_shared_library(int id, struct lib_info *libs)
 	abort_creds(bprm.cred);
 
 out:
-	allow_write_access(bprm.file);
-	fput(bprm.file);
+		allow_write_access(bprm.file);
+		fput(bprm.file);
 
 	return(res);
 }
diff --git a/fs/cifs/file.c b/fs/cifs/file.c
index bd44591..8d8eebf 100644
--- a/fs/cifs/file.c
+++ b/fs/cifs/file.c
@@ -491,7 +491,7 @@ static int cifs_reopen_file(struct file *file, bool can_flush)
 		return -EBADF;
 
 	xid = GetXid();
-	mutex_lock(&pCifsFile->fh_mutex);
+		mutex_lock(&pCifsFile->fh_mutex);
 	if (!pCifsFile->invalidHandle) {
 		mutex_unlock(&pCifsFile->fh_mutex);
 		FreeXid(xid);
diff --git a/fs/exec.c b/fs/exec.c
index 42414e5..28a9ef5 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -678,7 +678,7 @@ exit:
 EXPORT_SYMBOL(open_exec);
 
 int kernel_read(struct file *file, loff_t offset,
-		char *addr, unsigned long count)
+	char *addr, unsigned long count)
 {
 	mm_segment_t old_fs;
 	loff_t pos = offset;
diff --git a/fs/hugetlbfs/inode.c b/fs/hugetlbfs/inode.c
index 7ae4e4b..9af06ae 100644
--- a/fs/hugetlbfs/inode.c
+++ b/fs/hugetlbfs/inode.c
@@ -955,7 +955,7 @@ struct file *hugetlb_file_setup(const char *name, size_t size, int acctflag,
 		} else {
 			*user = NULL;
 			return ERR_PTR(-EPERM);
-		}
+	}
 	}
 
 	root = hugetlbfs_vfsmount->mnt_root;
diff --git a/fs/inode.c b/fs/inode.c
index bc908a0..5d4ee5c 100644
--- a/fs/inode.c
+++ b/fs/inode.c
@@ -208,7 +208,7 @@ static struct inode *alloc_inode(struct super_block *sb)
 		inode = kmem_cache_alloc(inode_cachep, GFP_KERNEL);
 
 	if (!inode)
-		return NULL;
+	return NULL;
 
 	if (unlikely(inode_init_always(sb, inode))) {
 		if (inode->i_sb->s_op->destroy_inode)
diff --git a/fs/ocfs2/super.c b/fs/ocfs2/super.c
index e201fe0..4829529 100644
--- a/fs/ocfs2/super.c
+++ b/fs/ocfs2/super.c
@@ -233,12 +233,12 @@ static int ocfs2_osb_dump(struct ocfs2_super *osb, char *buf, int len)
 			osb->s_mount_opt, osb->s_atime_quantum);
 
 	if (cconn) {
-		out += snprintf(buf + out, len - out,
+	out += snprintf(buf + out, len - out,
 				"%10s => Stack: %s  Name: %*s  "
 				"Version: %d.%d\n", "Cluster",
-				(*osb->osb_cluster_stack == '\0' ?
-				 "o2cb" : osb->osb_cluster_stack),
-				cconn->cc_namelen, cconn->cc_name,
+			(*osb->osb_cluster_stack == '\0' ?
+			 "o2cb" : osb->osb_cluster_stack),
+			cconn->cc_namelen, cconn->cc_name,
 				cconn->cc_version.pv_major,
 				cconn->cc_version.pv_minor);
 	}
diff --git a/fs/proc/base.c b/fs/proc/base.c
index f705cfd..f9c8a9a 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -242,7 +242,7 @@ struct mm_struct *mm_for_maps(struct task_struct *task)
 	mm = get_task_mm(task);
 	if (mm && mm != current->mm &&
 			!ptrace_may_access(task, PTRACE_MODE_READ)) {
-		mmput(mm);
+	mmput(mm);
 		mm = NULL;
 	}
 	mutex_unlock(&task->cred_exec_mutex);
diff --git a/fs/squashfs/squashfs_fs.h b/fs/squashfs/squashfs_fs.h
index aacc0e9..36e1604 100644
--- a/fs/squashfs/squashfs_fs.h
+++ b/fs/squashfs/squashfs_fs.h
@@ -211,7 +211,7 @@ struct meta_index {
 /*
  * definitions for structures on disk
  */
-#define ZLIB_COMPRESSION	 1
+#define ZLIB_COMPRESSION	1
 #define LZMA_COMPRESSION	2
 #define LZO_COMPRESSION		3
 
diff --git a/fs/squashfs/squashfs_fs_sb.h b/fs/squashfs/squashfs_fs_sb.h
index 874b0d8..7533350 100644
--- a/fs/squashfs/squashfs_fs_sb.h
+++ b/fs/squashfs/squashfs_fs_sb.h
@@ -53,25 +53,25 @@ struct squashfs_cache_entry {
 
 struct squashfs_sb_info {
 	const struct squashfs_decompressor	*decompressor;
-	int			devblksize;
-	int			devblksize_log2;
-	struct squashfs_cache	*block_cache;
-	struct squashfs_cache	*fragment_cache;
-	struct squashfs_cache	*read_page;
-	int			next_meta_index;
-	__le64			*id_table;
-	__le64			*fragment_index;
-	unsigned int		*fragment_index_2;
-	struct mutex		read_data_mutex;
-	struct mutex		meta_index_mutex;
-	struct meta_index	*meta_index;
+	int					devblksize;
+	int					devblksize_log2;
+	struct squashfs_cache			*block_cache;
+	struct squashfs_cache			*fragment_cache;
+	struct squashfs_cache			*read_page;
+	int					next_meta_index;
+	__le64					*id_table;
+	__le64					*fragment_index;
+	unsigned int				*fragment_index_2;
+	struct mutex				read_data_mutex;
+	struct mutex				meta_index_mutex;
+	struct meta_index			*meta_index;
 	void					*stream;
-	__le64			*inode_lookup_table;
-	u64			inode_table;
-	u64			directory_table;
-	unsigned int		block_size;
-	unsigned short		block_log;
-	long long		bytes_used;
-	unsigned int		inodes;
+	__le64					*inode_lookup_table;
+	u64					inode_table;
+	u64					directory_table;
+	unsigned int				block_size;
+	unsigned short				block_log;
+	long long				bytes_used;
+	unsigned int				inodes;
 };
 #endif
diff --git a/include/asm-mips/rtl865x/re865x.h b/include/asm-mips/rtl865x/re865x.h
index e8effa7..d7562e6 100644
--- a/include/asm-mips/rtl865x/re865x.h
+++ b/include/asm-mips/rtl865x/re865x.h
@@ -1,410 +1,16 @@
 /*
- * Copyright c                Realtek Semiconductor Corporation, 2003
- * All rights reserved.                                                    
- * 
  * $Header: /home1/sub1/tmp/cvs2svn/skylark/skylark/skylark/linux-2.6.x/include/asm-mips/rtl865x/re865x.h,v 1.1 2007-12-07 05:52:23 alva_zhang Exp $
  *
  * $Author: alva_zhang $
  *
- * Abstract:
+ *  Copyright (c) 2011 Realtek Semiconductor Corp.
  *
- *   re865x.h  -- ioctl symbol definitions
- *
- * $Log: not supported by cvs2svn $
- * Revision 1.1.1.1  2007/08/06 10:04:57  root
- * Initial import source to CVS
- *
- * Revision 1.76  2007/04/23 13:05:40  bo_zhao
- * +: add new qos support
- *
- * Revision 1.75  2007/04/04 03:44:39  alva_zhang
- * +: support rtl865xC MIB Couter function
- *
- * Revision 1.74  2007/04/04 02:29:03  bo_zhao
- * *: update MNQueue
- *
- * Revision 1.73  2007/03/28 03:04:56  bo_zhao
- * :Add 865xC MNQueue
- *
- * Revision 1.72  2007/03/12 05:40:34  darcy_lu
- * +: add macro definition for get l2 table
- *
- * Revision 1.71  2007/03/06 06:56:06  chihhsing
- * +: add new IOCTRL for port-base VLAN tagged/untagged
- *
- * Revision 1.70  2007/03/05 06:07:18  qjj_qin
- * *:865xc igmp snooping support
- *
- * Revision 1.69  2007/02/14 09:23:21  qjj_qin
- * *:macro for igmp snooping
- *
- * Revision 1.68  2007/02/13 07:37:44  qjj_qin
- * +:igmp proxy to snooping
- *
- * Revision 1.67  2007/01/08 01:57:27  hyking_liu
- * +: add tag RTL8651_IOCTL_SETMULTIPPPOESESSIONSTATUS for idle time out
- *
- * Revision 1.66  2006/12/28 02:45:07  hyking_liu
- * +: add tag SETNAPTTCPUDPPORTRANGE
- *
- * Revision 1.65  2006/12/05 05:56:59  qjj_qin
- * *:add SDK API to specify detail multicast upstream
- *
- * Revision 1.64  2006/11/28 02:53:47  hyking_liu
- * +: Add Micro for ioctl_setvlanPromiscuous
- *
- * Revision 1.63  2006/11/13 06:36:25  qjj_qin
- * +:igmp proxy for multi-port wan port
- *
- * Revision 1.62  2006/10/25 07:11:58  qy_wang
- * +:add an IOCTRL function to get extension device name & vid
- *
- * Revision 1.61  2006/08/16 08:33:31  cw_du
- * +:Add #define RTL8651_IOCTL_ENABLE_UNNUMBERNAPTPROC	2797.
- *
- * Revision 1.60  2006/08/15 05:38:56  hyking_liu
- * +: Add FLUSHGENERICDMZFILTER for flush dmzfilter.
- *
- * Revision 1.59  2006/08/14 05:25:44  hyking_liu
- * *: Modify for DMZ ipFilter API
- *
- * Revision 1.58  2006/08/08 08:56:29  hyking_liu
- * +: add define of IOCTL_ADDGENERICDMZHOST
- *
- * Revision 1.57  2006/08/07 07:20:52  jiucai_wang
- * +:add RTL8651_IOCTL_MANUALKEYFLAGSEND for ipsec manual key mode
- *
- * Revision 1.56  2006/08/02 02:20:45  hyking_liu
- * +: Add the define of RTL8651_IOCTL_ADDDMZHOSTEXT used in re_core.c
- *
- * Revision 1.55  2006/05/30 02:13:06  jiucai_wang
- * +:add the micro declaration for reinit route list(line 2795)
- *
- * Revision 1.54  2006/05/24 09:45:45  jiucai_wang
- * +:add some micro definition(line:541-546)
- *
- * Revision 1.53  2006/04/13 05:54:58  chenyl
- * +: KERNELPROC for kernel procdure testing
- *
- * Revision 1.52  2006/03/16 03:12:37  yjlou
- * +: Support various NAT Cone Type:
- *    Naive, Symmetric, Restricted, Port-Restricted, and Full Cone.
- *
- * Revision 1.51  2006/01/27 07:10:48  shliu
- * *: add definition of RTL8651_IOCTL_SETURLFORWARDLOGGING
- *
- * Revision 1.50  2006/01/26 16:04:49  shliu
- * *: define RTL8651_IOCTL_FLUSHURLFILTERRULE
- *
- * Revision 1.49  2006/01/25 14:53:07  yjlou
- * *: fixed the bug of pbnat(Protocol-Base NAT): auto enable when any entry is enabled.
- *
- * Revision 1.48  2006/01/24 13:52:52  shliu
- * *: add ioctl definition RTL8651_IOCTL_SETURLDEFAULTACTION
- *
- * Revision 1.47  2006/01/23 02:05:40  shliu
- * *: add RTL8651_IOCTL_URLUNKNOWNTYPECASESENSITIVE
- *
- * Revision 1.46  2006/01/23 01:57:15  shliu
- * *: add RTL8651_IOCTL_ADDGENERICURLFILTERRULE & RTL8651_IOCTL_DELGENERICURLFILTERRULE
- *
- * Revision 1.45  2005/12/12 03:25:00  tony
- * +: New Feature: support trusted user in url filter.
- *
- * Revision 1.44  2005/12/02 15:41:11  chenyl
- * *: circular buffer write protection by kernel mutex lock / unlock
- *
- * Revision 1.43  2005/12/02 10:04:46  chenyl
- * +: capture Log buffer's snapshot to user space memory under mutex lock/unlock protection.
- * *: shliu's new circ_msg write mechanism.
- *
- * Revision 1.42  2005/11/21 12:40:55  chenyl
- * *: always turn OFF interrupts when R/W flash
- *
- * Revision 1.41  2005/10/26 12:54:40  shliu
- * *: add RTL8651_IOCTL_REPROBE
- *
- * Revision 1.40  2005/10/26 04:57:45  shliu
- * *: new API for deletion of proto stack action table entry
- *
- * Revision 1.39  2005/09/25 17:02:11  shliu
- * *: add definitions for mac filter APIs
- *
- * Revision 1.38  2005/09/09 06:11:05  shliu
- * *: add an API of add generic proto stack action
- *
- * Revision 1.37  2005/09/07 09:54:21  chenyl
- * +: set pure-sw forwarding via http-daemon
- *
- * Revision 1.36  2005/08/04 06:50:15  shliu
- * *: add getChipVersion system call
- *
- * Revision 1.35  2005/08/03 07:35:07  rupert
- * +: Add IOCTL for rtl8651a_addAclRuleExt and rtl8651a_delAclRuleExt
- *
- * Revision 1.34  2005/07/29 09:44:00  chenyl
- * +: dns module in ROMEDRV
- * +: domain blocking (SDK + RomeDrv)
- *
- * Revision 1.33  2005/06/07 14:44:50  shliu
- * *: add rtl8651_addDriverNaptMapping() API.
- *
- * Revision 1.32  2005/06/01 07:10:22  tony
- * *:add a addarp ioctl
- *
- * Revision 1.31  2005/05/04 02:42:00  shliu
- * *: define reinit ROMEDRV for ioctl case
- *
- * Revision 1.30  2005/01/18 13:33:37  ghhuang
- * *: Replace Diffserv API
- *
- * Revision 1.29  2005/01/18 08:50:22  ghhuang
- * +: Diffserv (DSCP) remarking support
- *
- * Revision 1.28  2005/01/11 03:22:55  ghhuang
- * *:MNQ bug fix - Correct ACL undeletion
- *
- * Revision 1.27  2005/01/03 02:52:22  tony
- * +: add API: rtl8651_queryUpnpMapTimeAge
- *
- * Revision 1.26  2004/12/22 08:41:49  tony
- * *: support for alg qos
- *
- * Revision 1.25  2004/12/02 03:08:37  yjlou
- * +: support IPX/Netbios Passthru function
- *
- * Revision 1.24  2004/11/01 08:22:21  tony
- * *: support for rtl8651_addProtoStackServerPortRange
- *
- * Revision 1.23  2004/10/21 11:48:39  chenyl
- * +: web-based icmp/l4 protocol DMZ forwarding
- *
- * Revision 1.22  2004/10/11 05:20:27  yjlou
- * +: add RTL8651_IOCTL_ENABLE_DROP_UNKNOWN_PPPOE_DROP
- *
- * Revision 1.21  2004/10/05 09:20:42  chenyl
- * +: web page to turn ON/OFF ip-multicast system
- *
- * Revision 1.20  2004/10/01 08:37:32  yjlou
- * +: RTL8651_IOCTL_ENABLE_PPPOE_PASSTHRU and RTL8651_IOCTL_ENABLE_IPV6_PASSTHRU
- *
- * Revision 1.19  2004/09/23 08:29:33  tony
- * new features: when wan port's link is changed, the DHCPC will auto renew.
- *
- * Revision 1.18  2004/09/15 14:52:19  chenyl
- * *: enable multicast upload cache
- * *: modify PPTP's default MTU
- *
- * Revision 1.17  2004/09/03 03:00:09  chhuang
- * +: add new feature: pseudo VLAN
- *
- * Revision 1.16  2004/09/02 06:15:38  chenyl
- * *: multicast :
- * 	- when turning-on ip-multicast, periodic query will be sent immediately
- * +: tbldrv
- * 	- add options when run addNaptConnection
- * 		- PURE_SW: pure software entry
- * 		- DONT_CHECK_INTIP: ignore internal IP checking
- * 		- TO_PROTOCOL_STACK: this napt packet must be trapped to protocol stack
- * +: forwarding engine:
- * 	- protocol stack TCP/UDP flow cache
- * 	- napt redirect register/unregister/query
- *
- * Revision 1.15  2004/08/20 12:29:17  cfliu
- * +: Add loose UDP ctrl item
- *
- * Revision 1.14  2004/08/18 05:39:59  chenyl
- * +: napt special option web-based setting
- *
- * Revision 1.13  2004/07/27 10:48:52  cfliu
- * *: Fix all compile warnings
- *
- * Revision 1.12  2004/07/27 03:06:16  chenyl
- * +: Add DoS ignore type setting ioctl items
- *
- * Revision 1.11  2004/07/19 02:12:26  chhuang
- * *: modify M-N-1 queue
- *
- * Revision 1.10  2004/07/14 13:55:59  chenyl
- * +: web page for MN queue
- *
- * Revision 1.9  2004/07/12 04:25:36  chenyl
- * *: extend existing port scan mechanism
- *
- * Revision 1.8  2004/07/08 10:58:40  tony
- * +: add new ioctl api.
- *
- * Revision 1.7  2004/07/06 07:22:13  chhuang
- * +: add rate limit
- *
- * Revision 1.6  2004/06/29 07:37:13  chenyl
- * +: igmp-proxy filter
- *
- * Revision 1.5  2004/06/21 03:49:17  chhuang
- * +: define RTL8651_IOCTL_NETMTU
- *
- * Revision 1.4  2004/06/16 04:43:11  tony
- * *: support reboot and get loader version for MMU.
- *
- * Revision 1.3  2004/06/14 09:05:40  rupert
- * *: serial definition
- *
- * Revision 1.58  2004/06/11 11:07:17  cfliu
- * +: Add Cable meter and Interface counter webpage
- *
- * Revision 1.57  2004/05/31 14:41:04  jzchen
- * Add Counter setting IO control definition
- *
- * Revision 1.56  2004/05/28 06:11:51  yjlou
- * +: add IOCTL for rtl8651_addProtocolBasedNAT() and rtl8651_delProtocolBasedNAT()
- *
- * Revision 1.55  2004/05/27 05:14:18  cfliu
- * Remove INIT_HARDWARE
- *
- * Revision 1.54  2004/05/20 08:45:49  chhuang
- * add Web Page for QoS
- *
- * Revision 1.53  2004/05/19 08:49:22  orlando
- * add RTL8651_IOCTL_DIAG_LED
- *
- * Revision 1.52  2004/05/17 07:22:16  tony
- * fix pppoe silent timeout bug and make PPTP/L2TP support silent timeout.
- *
- * Revision 1.51  2004/05/14 10:18:15  orlando
- * add RTL8651_IOCTL_DIAG_LED
- *
- * Revision 1.50  2004/05/12 07:20:15  chenyl
- * +: source ip blocking
- * *: modify dos mechanism
- *
- * Revision 1.49  2004/05/10 05:53:45  chhuang
- * add new IOCTL: RTL8651_IOCTL_ADDURLFILTER
- *
- * Revision 1.48  2004/05/05 08:27:07  tony
- * new features: add remote management spec
- *
- * Revision 1.47  2004/04/29 05:47:52  chhuang
- * add new ioctl for rtl8651_addNaptMappingExt()
- *
- * Revision 1.46  2004/04/27 07:05:02  chenyl
- * +: ioctl number: RTL8651_IOCTL_SETDEFAULTIGMPUPSTREAM
- *
- * Revision 1.45  2004/04/19 13:45:18  tony
- * add resetPptpProprity and resetL2tpProprity IOCTL.
- *
- * Revision 1.44  2004/04/14 02:45:50  tony
- * add ioctl RTL8651_IOCTL_SETLOOPBACKPORTPHY
- *
- * Revision 1.43  2004/04/13 08:15:53  tony
- * fix bug: make PPTP/L2TP run stably.
- *
- * Revision 1.42  2004/04/09 02:26:12  tony
- * remove rtl8651_specifyNetworkIntfLinkLayerType_1 IOCTL.
- *
- * Revision 1.41  2004/04/08 13:18:12  tony
- * add PPTP/L2TP routine for MII lookback port.
- *
- * Revision 1.40  2004/04/08 12:25:42  cfliu
- * Add del ACL ioctl()
- *
- * Revision 1.39  2004/02/24 05:12:33  cfliu
- * Add symbols required for WLAN HW acceleration code
- *
- * Revision 1.38  2004/02/10 13:00:34  orlando
- * add lanType field in pppoeCfg_t
- *
- * Revision 1.37  2004/02/09 09:18:00  tony
- * add function: user is able to add protocol stack Server used TCP ports by
- * rtl8651_addProtoStackServerUsedTcpPort(incoming_src_port); and flush the
- * table by rtl8651_flushProtoStackServerUsedTcpPort();
- *
- * Revision 1.36  2004/02/04 06:24:19  rupert
- * Add UDP IOCTL
- *
- * Revision 1.35  2004/01/29 09:38:02  tony
- * add case RTL8651_IOCTL_ADDNAPTSERVERPORTRANGE ,RTL8651_IOCTL_DELNAPTSERVERPORTRANGE
- *
- * Revision 1.34  2004/01/29 02:03:34  orlando
- * correct duplicate conflicts
- *
- * Revision 1.33  2004/01/27 02:03:04  tony
- * add RTL8651_IOCTL_FLUSHNAPTSERVERPORTBYEXTIP
- *
- * Revision 1.32  2004/01/12 12:32:23  orlando
- * add RTL8651_IOCTL_SETPPPOEDEFAULTDIALSESSIONID
- *
- * Revision 1.31  2003/12/12 02:40:44  tony
- * add rtl8651_setMtu() function.
- *
- * Revision 1.30  2003/12/10 03:08:58  tony
- * make logging function support time zone in kernel space.
- *
- * Revision 1.29  2003/12/08 13:53:25  orlando
- * add RTL8651_IOCTL_ENABLELOGGING
- *
- * Revision 1.28  2003/12/04 10:39:02  hiwu
- * add RTL8651_ADDNAPTUPNPPORTMAPPING
- * add RTL8651_DELNAPTUPNPPORTMAPPING
- *
- * Revision 1.27  2003/12/03 14:29:07  cfliu
- * comment out old debug commands when CLE is enabled.
- *
- * Revision 1.26  2003/12/02 10:24:47  tony
- * Add Routine: support DoS is able to set threshold by user(Webs GUI).
- *
- * Revision 1.25  2003/12/01 12:35:52  tony
- * make ALG is able to be configured by users(Web GUI).
- *
- * Revision 1.24  2003/11/28 01:38:17  rupert
- * add PPPOEUP_CFG PPPOEDOWN_CFG BATCH IOCTL
- *
- * Revision 1.23  2003/11/21 01:56:47  tony
- * add function: user is able to add protocol stack used UDP ports by
- * rtl8651_addProtoStackUsedUdpPort(incoming_src_port);
- *
- * Revision 1.22  2003/11/18 13:28:28  rupert
- * add ioctl for dial demand and timeout
- *
- * Revision 1.21  2003/11/18 09:04:47  tony
- * add routine: support mtu configure by user in pppoe.
- *
- * Revision 1.20  2003/11/06 12:15:56  rupert
- * add delete policy route  ioctl
- *
- * Revision 1.19  2003/10/30 10:20:49  orlando
- * add definitions for command "addflow"
- *
- * Revision 1.18  2003/10/28 09:58:35  rupert
- * add policy route
- *
- * Revision 1.17  2003/10/28 08:32:36  orlando
- * add RTL8651_IOCOL_ENABLENAPTAUTOADD
- *
- * Revision 1.16  2003/10/24 13:37:42  orlando
- * add debug command "dhs","dftcp","dficmp"
- *
- * Revision 1.15  2003/10/24 10:25:58  tony
- * add DoS attack interactive webpage,
- * FwdEngine is able to get WAN status by rtl8651_wanStatus(0:disconnect,1:connect)
- *
- * Revision 1.14  2003/10/20 10:13:08  orlando
- * add define for debug command "dl2","dgidx","dfwd"
- *
- * Revision 1.13  2003/10/20 04:52:11  orlando
- * add _RTL_LOGGING related stuff
- *
- * Revision 1.12  2003/10/09 13:23:44  tony
- * TRIGGER_PORT: add function rtl8651_flushTriggerPortRules,rtl8651_addTriggerPortRule
- *
- * Revision 1.11  2003/10/01 09:43:12  orlando
- * add RTL8651_IOCTL_SETPPPOESESSIONHANGUP
- *
- * Revision 1.10  2003/10/01 06:17:57  orlando
- * add cvs file header
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
  *
  */
 
-
 #ifndef _LINUX_IF_RE865X_H
 #define _LINUX_IF_RE865X_H
 
diff --git a/include/asm-mips/rtl865x/rtl865xc_asicregs.h b/include/asm-mips/rtl865x/rtl865xc_asicregs.h
index a2c3381..55da054 100644
--- a/include/asm-mips/rtl865x/rtl865xc_asicregs.h
+++ b/include/asm-mips/rtl865x/rtl865xc_asicregs.h
@@ -1,4 +1,3 @@
-
 /*
 * ----------------------------------------------------------------
 * Copyright c                  Realtek Semiconductor Corporation, 2002  
@@ -175,7 +174,7 @@ extern int8						*pVirtualSWTable;
 #define HSA_BASE			REAL_HSA_BASE
 #endif
 
-#ifdef CONFIG_RTL_8198
+#if defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 #define PIN_MUX_SEL_2                           (SYSTEM_BASE + 0x0044)
 #endif
 
@@ -505,6 +504,11 @@ link partner ability registers field definitions
 #define CPUTPDCR1					(0x024 + CPU_IFACE_BASE)		/* Tx pkthdr descriptor control High */
 #define CPUTPDCR(idx)				(CPUTPDCR0 + (idx << 2))		/* Tx pkthdr descriptor control with index */
 
+#if defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+#define CPUTPDCR2					(0x060 + CPU_IFACE_BASE)    /* Tx Pkthdr Descriptor 2 Control Register */
+#define CPUTPDCR3					(0x064 + CPU_IFACE_BASE)    /* Tx Pkthdr Descriptor 3 Control Register */
+#endif
+
 #define CPUIIMR						(0x028 + CPU_IFACE_BASE)		/* Interrupt mask control */
 #define CPUIISR						(0x02c + CPU_IFACE_BASE)		/* Interrupt status control */
 #define CPUQDM0						(0x030 + CPU_IFACE_BASE)		/* Queue ID 0 and Descriptor Ring Mapping Register */
@@ -623,8 +627,8 @@ link partner ability registers field definitions
 #define PKTHDR_DESC_RUNOUT_IP_ALL	(0x3f << 17)			/* Run out anyone pkthdr descriptor interrupt pending */
 #define PKTHDR_DESC_RUNOUT_IP(idx)		(1 << (17+(idx)))		/* Run out pkthdr descriptor [IDX] interrupt pending */
 
-#define MBUF_DESC_RUNOUT_IP_ALL		(1 << 11)			/* Run out anyone mbuf interrupt pending */
-#define MBUF_DESC_RUNOUT_IP0			(1 << 11)			/* Run out mbuf descriptor 0 interrupt pending */
+#define MBUF_DESC_RUNOUT_IP_ALL		(1 << 16)			/* Run out anyone mbuf interrupt pending */
+#define MBUF_DESC_RUNOUT_IP0			(1 << 16)			/* Run out mbuf descriptor 0 interrupt pending */
 
 #define TX_DONE_IP0						(1 << 9)				/* Tx one packet done interrupt for descriptor 0 pending */
 #define TX_DONE_IP1						(1 << 10)			/* Tx one packet done interrupt for descriptor 1 pending */
@@ -761,7 +765,7 @@ link partner ability registers field definitions
 #define USEDDSC_MASK				(0x3ff<<16)				/* Total Used Descriptor */
 #define SharedBufFCON_Flag			(1<<14)					/* SharedBufFCON threshold triggerred flag */
 #define MaxUsedDsc_OFFSET			0						/* Max Used Descriptor Count History */
-#define MaxUsedDsc_MASK			(0x3ff<<0)				/* Max Used Descriptor Count History */
+#define MaxUsedDsc_MASK			(0x3fff<<0)				/* Max Used Descriptor Count History */
 
 /* PCSR0 - Port Congestion Status Register 0 */
 #define P3OQCgst_OFFSET			(24)
@@ -1022,6 +1026,18 @@ to forward packet to the unauthorized node. Otherwise, it is not allowed.
 #define LONG_TXE       	                    (1 << 22)                /* Back pressure, carrier based */
 #define DIS_MASK_CGST                       (1 << 21)
 #define EN_48_DROP                          (1 << 20)
+#define SELIPG_OFFSET                       (18)                     	/* Define min. IPG between backpressure data */
+#define SELIPG_MASK                       	(0x3 << 18)                /* Define min. IPG between backpressure data */
+#define SELIPG_7                    		(0<<18)     			/* 7, unit: byte-time */
+#define SELIPG_8                    		(1<<18)     			/* 8, unit: byte-time */
+#define SELIPG_11                    		(2<<18)     			/* 11, unit: byte-time */
+#define SELIPG_12                    		(3<<18)     			/* 12, unit: byte-time */
+#define SPDUP_100       	                    (1 << 16)                /* 10000 times speed up aging timer */
+#define CF_SYSCLK_SEL_MASK					(0x3 << 12)
+#define CF_SYSCLK_SEL_OFFSET				(12)
+#define CF_FCDSC_OFFSET                    (4)                     	/* Flow control DSC tolerance, default: 24 pages ( also minimum value ) */
+#define CF_FCDSC_MASK                       (0x7f << 4)                /* Flow control DSC tolerance, default: 24 pages ( also minimum value ) */
+#define CF_RXIPG_MASK                       (0xf << 0)                /* Min. IPG limitation for RX receiving packetMinimum value is 6. Maximum value is 12. */
 
 /* MDCIOCR - MDC/MDIO Command */
 #define COMMAND_OFFSET				31			/* MDCMDIO Command */
@@ -1098,7 +1114,7 @@ to forward packet to the unauthorized node. Otherwise, it is not allowed.
 /* CSCR, CCR - Checksum Control Register */
 #define EnL4ChkCal                          (1<<5)                   /* Enable L4 Checksum Re-calculation */
 #define EnL3ChkCal                          (1<<4)                   /* Enable L3 Checksum Re-calculation */
-#if defined(CONFIG_RTL_8196C) || defined(CONFIG_RTL_8198)
+#if defined(CONFIG_RTL_8196C) || defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 #define AcceptL2Err                          (1<<3)                   /* CPU port L2 CRC Error Allow; 0: Not Allowed, 1: Allowed (default) */
 #endif
 #define L4ChkSErrAllow                      (1<<2)                   /* L4 Checksum Error Allow */
@@ -1145,7 +1161,7 @@ to forward packet to the unauthorized node. Otherwise, it is not allowed.
 #define Port0_TypeCfg_UTP                   (0<< 0)
 #define Port0_TypeCfg_GMII_MII_RGMII        (1<< 0)
 
-#if defined(CONFIG_RTL_8196C) || defined(CONFIG_RTL_8198)
+#if defined(CONFIG_RTL_8196C) || defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 
 #define GIGA_P5_PHYID	0x16
 /* 0xBB804104 ~ 0xBB804124 */
@@ -1172,7 +1188,8 @@ to forward packet to the unauthorized node. Otherwise, it is not allowed.
 		FrcAbi_AnAbi_sel[0]: 10Mbps Half-duplexFrcAbi_AnAbi_sel[1]: 10Mbps Full-duplexFrcAbi_AnAbi_sel[2]: 100Mbps Half-duplex
 		FrcAbi_AnAbi_sel[3]: 100Mbps Full-duplexFrcAbi_AnAbi_sel[4]: 1000Mbps Full-duplex	
 	 */
-// !!! temp, 8198 has no these bits
+
+//Note: 96C/98 have remove these bits !!!
 #define IPMSTP_PortST_MASK				(3<<21)		/* Mask of IP Multicast Spanning Tree Protocol Port State Control */
 #define IPMSTP_PortST_OFFSET				(21)			/* Offset of IP Multicast Spanning Tree Protocol Port State Control */
 #define IPMSTP_PortST_DISABLE			(0<<21)		/* Disable State of IP Multicast Spanning Tree Protocol Port State Control */
@@ -1188,6 +1205,13 @@ to forward packet to the unauthorized node. Otherwise, it is not allowed.
 #define ForceDuplex                         (1<<18)     /* Force Duplex */
 #define AutoNegoSts_OFFSET                     (18)
 #define AutoNegoSts_MASK                       (0x1f<<18) 
+
+#define NwayAbility1000MF                    (1<<22)     /* Auto-Negotiation advertise ability: 1000Mbps Full-duplex*/
+#define NwayAbility100MF                     (1<<21)     /* Auto-Negotiation advertise ability: 100Mbps Full-duplex */
+#define NwayAbility100MH                     (1<<20)     /* Auto-Negotiation advertise ability: 100Mbps Half-duplex */
+#define NwayAbility10MF                      (1<<19)     /* Auto-Negotiation advertise ability: 10Mbps Full-duplex */
+#define NwayAbility10MH                      (1<<18)     /* Auto-Negotiation advertise ability: 10Mbps Half-duplex */
+
 /* bit 16, 17
   if EnForceMode = 1, PAUSE flow control ability Control .
 	[0]= enable TX pause ability
@@ -1295,6 +1319,8 @@ to forward packet to the unauthorized node. Otherwise, it is not allowed.
 #endif
 
 /* PSRP0,PSRP1,PSRP2,PSRP3,PSRP4,PSRP5,PSRP6,PSRP7,PSRP8 - Port Status Register Port 0~8 */
+#define PortEEEStatus_MASK					(3<<12)
+#define PortEEEStatus_OFFSET				12
 #define LinkDownEventFlag                   (1<<8)      /* Port Link Down Event detecting monitor flag */
 #define PortStatusNWayEnable                (1<<7)      /* N-Way Enable */
 #define PortStatusRXPAUSE                   (1<<6)      /* Rx PAUSE */
@@ -1369,7 +1395,7 @@ to forward packet to the unauthorized node. Otherwise, it is not allowed.
 #define CVIDR                               (0x00+SWMISC_BASE)     /* Chip Version ID Register */
 #define SSIR						        (0x04+SWMISC_BASE)     /* System Initial and Reset Registe*/
 
-#if defined(CONFIG_RTL_8196C) || defined(CONFIG_RTL_8198)
+#if defined(CONFIG_RTL_8196C) || defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 #define CRMR                                (0x08+SWMISC_BASE)     /* Chip Revision Management Register */
 #define BISTCR                              (0x0C+SWMISC_BASE)     /* BIST control */
 #define BISTTSDR0                           (0x38+SWMISC_BASE)     /* BIST Test Status Diagnostic Register 0 */
@@ -1402,6 +1428,10 @@ to forward packet to the unauthorized node. Otherwise, it is not allowed.
 #endif
 #define SIRR						        (SSIR)                 /* Alias Name */
 
+#if defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+#define MEMCR                              (0x34+SWMISC_BASE)     /* MEM CTRL Register */
+#endif
+
 /* 	SIRR, SSIR - System Initial and Reset Register*/
 #define SwitchFullRst                       (1 << 2)   /* Reset all tables & queues */
 #define SwitchSemiRst                       (1 << 1)   /* Reset queues */
@@ -1684,6 +1714,10 @@ to forward packet to the unauthorized node. Otherwise, it is not allowed.
 #define QPKTFCRP5G0                         (0x0B8+SBFCTR)        /* Queue-Packet-Based Flow Control Register for Port 5 Group 0 */
 #define QPKTFCRP5G1                         (0x0BC+SBFCTR)        /* Queue-Packet-Based Flow Control Register for Port 5 Group 1 */
 #define QPKTFCRP5G2                         (0x0C0+SBFCTR)        /* Queue-Packet-Based Flow Control Register for Port 5 Group 2 */
+#define QPKTFCRP6G0							(0x0C4+SBFCTR)		  /* Queue-Packet-Based Flow Control Register for Port 6 Group 0 */
+#define QPKTFCRP6G1							(0x0C8+SBFCTR)		  /* Queue-Packet-Based Flow Control Register for Port 6 Group 1 */
+#define QPKTFCRP6G2							(0x0CC+SBFCTR)		  /* Queue-Packet-Based Flow Control Register for Port 6 Group 2 */
+
 #define FCCR0                               (0x0d0+SBFCTR)        /* Flow Control Configuration Register 0 */
 #define FCCR1                               (0x0d4+SBFCTR)        /* Flow Control Configuration Register 1 */
 #define PQPLGR                              (0x0d8+SBFCTR)        /* Per Queue Physical Length Gap Register */
@@ -1781,8 +1815,7 @@ to forward packet to the unauthorized node. Otherwise, it is not allowed.
 #define IQ_DSC_FCOFF_MASK                  (0xff<<0)             /* Mask for input Queue Flow control turn ON descriptor threshold */
 //#endif
 
-
-#ifdef CONFIG_RTK_VOIP_865xC_QOS
+#ifdef  CONFIG_RTK_VOIP_QOS
 #define PSRP6_RW			    (SWCORE_BASE+0x4600)  /*CPU Port Status : R/W */
 #endif
 
@@ -3074,6 +3107,7 @@ enum FDB_FLAGS
 	#define PIN_MUX_SEL     (SYSTEM_BASE+0x30)      /* 0xB8000030 - 0xB8000033 */
 #else
 	#define PIN_MUX_SEL 0xb8000040
+	#define PIN_MUX_SEL2 	0xb8000044
 #endif
 
 /* Shared Pin Register field definitions */
@@ -3478,6 +3512,11 @@ void rtl865x_wireCompBlinkAmber(void);
 #define BSP_RTL8198_REVISION_A	0xC0000000
 #define BSP_RTL8198_REVISION_B	0xC0000001   
 #define SYS_CLK_MAG 0xb8000010
+#define SYS_SW_CLK_ENABLE  0x200
 #define SYS_SW_RESET 0x800
+#define CM_ACTIVE_SWCORE			(1<<11)
+#define CM_PROTECT					(1<<27)
+
 #endif   /* _ASICREGS_H */
 
+
diff --git a/include/asm-mips/rtl865x/rtl_glue.h b/include/asm-mips/rtl865x/rtl_glue.h
index 97bab5a..67a6273 100644
--- a/include/asm-mips/rtl865x/rtl_glue.h
+++ b/include/asm-mips/rtl865x/rtl_glue.h
@@ -7,161 +7,8 @@
 * Abstract :Header of porting layer
 * Author	: Edward Jin-Ru Chen
 *
-* $Id: rtl_glue.h,v 1.1 2007-12-07 05:52:23 alva_zhang Exp $
-* $Log: not supported by cvs2svn $
-* Revision 1.1.1.1  2007/08/06 10:04:57  root
-* Initial import source to CVS
-*
-* Revision 1.34  2007/06/07 05:35:30  chenyl
-* +: add new function "rtlglue_clearDCache" to clear D-cache without
-*    writing back to external memory. ( Only for Processor with this function )
-*
-* Revision 1.33  2007/06/01 09:20:52  michaelhuang
-* -: removed the rtl867x compiler flag.
-*
-* Revision 1.32  2007/04/09 14:14:01  michaelhuang
-* +: added rtlglue_read() function
-*
-* Revision 1.31  2007/03/02 13:31:59  chenyl
-* *: enable range based D-cache flush function.
-*
-* Revision 1.30  2007/01/09 02:36:08  michaelhuang
-* *: Prepare implement test module for RTL8672
-*
-* Revision 1.29  2006/12/21 06:57:00  yjlou
-* -: remove the following usages:
-*    printk
-*    printfByPolling
-*
-* Revision 1.28  2006/11/28 02:15:14  hyking_liu
-* *: Mofify function related with usrDefineTunnel
-*
-* Revision 1.27  2006/11/21 12:28:35  chenyl
-* *: rearrange some code
-* *: bug fix - Src VLAN decision
-* *: bug fix - D-cache invalidation for FAST extension device forwarding
-* *: bug fix - m_unused1 and ph_reserved are needed for FAST extension device forwarding
-*
-* Revision 1.26  2006/10/26 02:15:32  qy_wang
-* *:remove the inculed file net_device.h in rtl8651_layer2fwd.c
-*
-* Revision 1.25  2006/10/25 07:10:15  qy_wang
-* +:add a function to block extension device when link up
-*
-* Revision 1.24  2006/08/31 15:44:48  chenyl
-* *: add some declarations of external APIs
-*
-* Revision 1.23  2006/07/13 15:55:49  chenyl
-* *: modify code for RTL865XC driver compilation.
-* *: dos2unix process
-*
-* Revision 1.22  2006/06/20 05:53:22  brian_bin
-* +: brian_bin move open, write, close declaration into __RTL_GLUE__ define brace
-*
-* Revision 1.21  2006/01/12 08:32:37  brian_bin
-* +: brian_bin add kernel system call of file operations
-*
-* Revision 1.20  2006/01/02 02:52:14  chenyl
-* +: VLAN-tag support extension port forwarding and software Rome Driver forwarding.
-*
-* Revision 1.19  2005/09/16 11:34:48  tony
-* *: bug fixed: support kernel space swNic model code for RTL865XC.
-*
-* Revision 1.18  2005/09/06 02:36:38  yjlou
-* +: add random and time glue functions.
-*
-* Revision 1.17  2005/07/20 15:29:38  yjlou
-* +: porting Model Code to Linux Kernel: check RTL865X_MODEL_KERNEL.
-*
-* Revision 1.16  2005/07/01 09:34:41  yjlou
-* *: porting swNic2.c into model code.
-*
-* Revision 1.15  2005/06/19 05:41:19  yjlou
-* *: merge ASIC driver into model code.
-*
-* Revision 1.14  2005/06/07 15:00:57  chenyl
-* *: modify mutex Lock / Unlock code to check the balance of Lock/Unlock function call
-*
-* Revision 1.13  2004/11/29 07:35:44  chenyl
-* *: fix bug : multiple-PPPoE MTU setting bug
-* *: fix bug : Never add second session's ip into ASIC in multiple-PPPoE WAN type.
-* *: fix bug : Tunekey abnormal behavior when multiple-PPPoE Dial-on-demand Dynamically turn ON/OFF
-* *: in forwarding engine Init function, the parameter == 0xffffffff means user want to set as default value
-* *: add Mutex-Lock/Unlock checking in testing code
-*
-* Revision 1.12  2004/11/05 09:54:08  yjlou
-* +: support more precise timeUpdate() function.
-*   +: add EVENT_TRIGGER_TIMEUPDATE==2
-*   *: modify #ifdef EVENT_TRIGGER_TIMEUPDATE
-*
-* Revision 1.11  2004/07/27 10:47:08  cfliu
-* -: Remove RTL865x external loopback port related code for PPTP/L2TP/WLAN
-*
-* Revision 1.10  2004/06/23 08:11:55  yjlou
-* *: change the declaration of rtlglue_getmstime()
-*
-* Revision 1.9  2004/05/03 14:56:18  cfliu
-* Add 8650B extension port support.
-* Revise all WLAN/extport related code.
-*
-* Revision 1.8  2004/05/03 02:53:03  chenyl
-* *: swNic_getRingSize -> rtlglue_getRingSize and move it from swNic2.c to rtl_glue.c
-* *: set default upstream ip to 0 if we config interface to dhcp
-*
-* Revision 1.7  2004/04/30 08:58:08  chenyl
-* +: ip multicast/igmp proxy
-*
-* Revision 1.6  2004/04/08 12:11:20  cfliu
-* Change extension port API.....define rtlglue_extDeviceSend()
-*
-* Revision 1.5  2004/03/31 09:37:01  cfliu
-* Add WDS support
-*
-* Revision 1.4  2004/03/19 13:13:35  cfliu
-* Reorganize ROME driver local header files. Put all private data structures into different .h file corrsponding to its layering
-* Rename printf, printk, malloc, free with rtlglue_XXX prefix
-*
-* Revision 1.1  2004/03/10 11:42:36  cfliu
-* Move rtl_glue.* from rtl865x/
-*
-* Revision 1.2  2004/03/03 10:40:38  yjlou
-* *: commit for mergence the difference in rtl86xx_tbl/ since 2004/02/26.
-*
-* Revision 1.1  2004/02/25 14:26:33  chhuang
-* *** empty log message ***
-*
-* Revision 1.2  2004/02/25 14:24:52  chhuang
-* *** empty log message ***
-*
-* Revision 1.7  2004/02/24 04:15:43  cfliu
-* add API for WLAN acceleration
-*
-* Revision 1.6  2004/02/18 13:54:37  chhuang
-* *** empty log message ***
-*
-* Revision 1.5  2003/12/26 09:27:50  orlando
-* add rtl_glue.h
-*
-* Revision 1.3  2003/09/30 06:07:50  orlando
-* check in RTL8651BLDRV_V20_20030930
-*
-* Revision 1.4  2003/06/10 05:33:30  cfliu
-* Remove rtl8651_tblDrvFwdSend registration.
-* Add rtlglue_drvSend to replace rtl8651_tblDrvFwdSend function pointer
-*
-* Revision 1.3  2003/06/09 04:48:43  cfliu
-* add 3 OS dependent glue functions to support mbuf external cluster allocation.
-* Rewrite all help messages using Autoduck's syntax so documentation could generated automatically.
-*
-* Revision 1.2  2003/05/23 07:47:06  cfliu
-* Extract porting function and fix compile warning.
-*
-* Revision 1.1  2003/05/23 04:55:25  jzchen
-* Add rtl glue to solve porting issue
-*
 */
 
-
 #include "rtl_types.h"
 #if defined(CONFIG_RTL865X)
 //#include "mbuf.h"
diff --git a/include/asm-mips/rtl865x/rtl_types.h b/include/asm-mips/rtl865x/rtl_types.h
index f94206f..b737676 100644
--- a/include/asm-mips/rtl865x/rtl_types.h
+++ b/include/asm-mips/rtl865x/rtl_types.h
@@ -10,192 +10,6 @@
 * Revision 1.1.1.1  2007/08/06 10:04:57  root
 * Initial import source to CVS
 *
-* Revision 1.21  2007/05/15 03:36:56  michaelhuang
-* *: fixed compatibility for Linux Kernel 2.6
-*
-* Revision 1.20  2007/04/04 15:48:54  chenyl
-* +: cleshell commend for asic register configuration : mmtu ( multicast mtu )
-*
-* Revision 1.19  2006/08/29 13:00:00  chenyl
-* *: New SWNIC driver for RTL865xC
-* *: some rearrange in re_core.c for Bootstrap sequence being more readable.
-*
-* Revision 1.18  2006/02/27 07:47:06  ympan
-* +: No change by ympan
-*
-* Revision 1.17  2005/09/27 05:59:44  chenyl
-* *: modify IRAM / DRAM layout:
-* 	IRAM/DRAM-FWD		: external used, swNic ... blahblah
-* 	IRAM/DRAM-L2-FWD	: fwdengine internal used, L2 and below (ex. preprocess, postprocess)
-* 	IRAM/DRAM-L34-FWD	: fwdengine internal used, L3/L4 process only (ex. Routing, decision table...etc).
-*
-* 	=> If L34 is used, we strongly suggest L2 must be used, too.
-*
-* Revision 1.16  2005/08/23 14:38:26  chenyl
-* +: apply prioirty IRAM/DRAM usage
-*
-* Revision 1.15  2005/08/22 07:33:55  chenyl
-* *: don't set DRAM/IRAM for other OSs yet.
-*
-* Revision 1.14  2005/08/18 09:14:08  chenyl
-* *: add code to porting to other OSs
-*
-* Revision 1.13  2005/08/18 06:29:29  chenyl
-* +: always define the rtlglue_printf in rtl_types.h
-*
-* Revision 1.12  2005/07/01 09:34:41  yjlou
-* *: porting swNic2.c into model code.
-*
-* Revision 1.11  2005/06/19 05:29:37  yjlou
-* *: use 'unsigned int' to replace 'size_t'
-* *: define spinlock_t when RTL865X_MODEL_USER defined.
-*
-* Revision 1.10  2005/06/10 05:32:22  yjlou
-* +: Porting CLE Shell to Linux user space for model test.
-*    See RTL865X_MODEL_USER compile flags.
-*
-* Revision 1.9  2005/01/10 03:21:43  yjlou
-* *: always define __IRAM and __DRAM
-*
-* Revision 1.8  2004/07/23 13:42:45  tony
-* *: remove all warning messages
-*
-* Revision 1.7  2004/07/05 08:25:32  chenyl
-* +: define __IRAM, __DRAM for module test
-*
-* Revision 1.6  2004/07/04 15:04:55  cfliu
-* +: add IRAM and DRAM
-*
-* Revision 1.5  2004/04/20 03:44:03  tony
-* if disable define "RTL865X_OVER_KERNEL" and "RTL865X_OVER_LINUX", __KERNEL__ and __linux__ will be undefined.
-*
-* Revision 1.4  2004/03/19 13:13:35  cfliu
-* Reorganize ROME driver local header files. Put all private data structures into different .h file corrsponding to its layering
-* Rename printf, printk, malloc, free with rtlglue_XXX prefix
-*
-* Revision 1.3  2004/03/05 07:44:27  cfliu
-* fix header file problem for ctype.h
-*
-* Revision 1.2  2004/03/03 10:40:38  yjlou
-* *: commit for mergence the difference in rtl86xx_tbl/ since 2004/02/26.
-*
-* Revision 1.1  2004/02/25 14:26:33  chhuang
-* *** empty log message ***
-*
-* Revision 1.3  2004/02/25 14:24:52  chhuang
-* *** empty log message ***
-*
-* Revision 1.8  2003/12/10 06:30:12  tony
-* add linux/config.h, disable define CONFIG_RTL865X_NICDRV2 in mbuf.c by default
-*
-* Revision 1.7  2003/12/03 14:25:43  cfliu
-* change SIZE_T to _SIZE_T. Linux kernel seems to recognize _SIZE_T
-*
-* Revision 1.6  2003/10/01 12:29:02  tony
-* #define DEBUG_P(args...) while(0);
-*
-* Revision 1.5  2003/10/01 10:31:47  tony
-* solve all the compiler warnning messages in the board.c
-*
-* Revision 1.4  2003/09/30 06:07:50  orlando
-* check in RTL8651BLDRV_V20_20030930
-*
-* Revision 1.30  2003/07/21 06:27:49  cfliu
-* no message
-*
-* Revision 1.29  2003/04/30 15:32:30  cfliu
-* move macros to types.h
-*
-* Revision 1.28  2003/03/13 10:29:22  cfliu
-* Remove unused symbols
-*
-* Revision 1.27  2003/03/06 05:00:04  cfliu
-* Move '#pragma ghs inlineprologue' to rtl_depend.h since it is compiler dependent
-*
-* Revision 1.26  2003/03/06 03:41:46  danwu
-* Prevent compiler from generating internal sub-routine call code at the
-*  function prologue and epilogue automatically
-*
-* Revision 1.25  2003/03/03 09:16:35  hiwu
-* remove ip4a
-*
-* Revision 1.24  2003/02/18 10:04:06  jzchen
-* Add ether_addr_t to compatable with protocol stack's ether_addr
-*
-* Revision 1.23  2003/01/21 05:59:51  cfliu
-* add min, max, SETBITS, CLEARBITS, etc.
-*
-* Revision 1.22  2002/11/25 07:31:30  cfliu
-* Remove _POSIX_SOURCE since it is cygwin specific
-*
-* Revision 1.21  2002/09/30 11:51:49  jzchen
-* Add ASSERT_ISR for not print inside ISR
-*
-* Revision 1.20  2002/09/18 01:43:24  jzchen
-* Add type limit definition
-*
-* Revision 1.19  2002/09/16 00:14:34  elvis
-* remove struct posix_handle_t (change the handle type from
-*  structure to uint32)
-*
-* Revision 1.18  2002/08/20 01:40:40  danwu
-* Add definitions of ipaddr_t & macaddr_t.
-*
-* Revision 1.17  2002/07/30 04:36:30  danwu
-* Add ASSERT_CSP.
-*
-* Revision 1.16  2002/07/19 06:47:30  cfliu
-* Add _POSIX_SOURCE symbol
-*
-* Revision 1.15  2002/07/05 02:10:39  elvis
-* Add new types for OSK
-*
-* Revision 1.14  2002/07/03 12:36:21  orlando
-* <rtl_depend.h> will use type definitions. Has to be moved to
-* be after the type declaration lines.
-*
-* Revision 1.13  2002/07/03 09:19:00  cfliu
-* Removed all standard header files from source code. They would be included by <core/types.h>-><rtl_depend.h>
-*
-* Revision 1.12  2002/07/03 09:16:48  cfliu
-* Removed all standard header files from source code. They would be included by <core/types.h>-><rtl_depend.h>
-*
-* Revision 1.11  2002/07/03 07:14:47  orlando
-* Add "struct posix_handle_t_", used by POSIX module.
-*
-* Revision 1.9  2002/06/21 03:15:36  cfliu
-* Add time.h for struct timeval
-*
-* Revision 1.8  2002/06/14 01:58:03  cfliu
-* Move sa_family_t to socket
-*
-* Revision 1.7  2002/06/13 09:37:42  cfliu
-* Move byte order conversion routines to socket
-*
-* Revision 1.6  2002/05/23 04:24:37  hiwu
-* change memaddr_t to calladdr_t
-*
-* Revision 1.5  2002/05/13 10:15:16  hiwu
-* add new type definition
-*
-* Revision 1.4  2002/05/09 05:21:51  cfliu
-* Add parenthesis around swaps16, swapl32
-*
-* Revision 1.3  2002/04/30 03:07:34  orlando
-* Remove UIxx_T definitions to conform with new
-* naming conventions.
-*
-* Revision 1.2  2002/04/29 10:10:32  hiwu
-* add NTOHS macro
-*
-* Revision 1.1.1.1  2002/04/26 08:53:53  orlando
-* Initial source tree creation.
-*
-* Revision 1.9  2002/04/25 03:59:05  cfliu
-* no message
-*
-* Revision 1.8  2002/04/08 08:08:04  hiwu
-* initial version
 *
 */
 
diff --git a/include/asm-rlx/rtl865x/rtl865xc_asicregs.h b/include/asm-rlx/rtl865x/rtl865xc_asicregs.h
index a2c3381..d27db0a 100644
--- a/include/asm-rlx/rtl865x/rtl865xc_asicregs.h
+++ b/include/asm-rlx/rtl865x/rtl865xc_asicregs.h
@@ -1098,7 +1098,7 @@ to forward packet to the unauthorized node. Otherwise, it is not allowed.
 /* CSCR, CCR - Checksum Control Register */
 #define EnL4ChkCal                          (1<<5)                   /* Enable L4 Checksum Re-calculation */
 #define EnL3ChkCal                          (1<<4)                   /* Enable L3 Checksum Re-calculation */
-#if defined(CONFIG_RTL_8196C) || defined(CONFIG_RTL_8198)
+#if defined(CONFIG_RTL_8196C) || defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 #define AcceptL2Err                          (1<<3)                   /* CPU port L2 CRC Error Allow; 0: Not Allowed, 1: Allowed (default) */
 #endif
 #define L4ChkSErrAllow                      (1<<2)                   /* L4 Checksum Error Allow */
@@ -1145,7 +1145,7 @@ to forward packet to the unauthorized node. Otherwise, it is not allowed.
 #define Port0_TypeCfg_UTP                   (0<< 0)
 #define Port0_TypeCfg_GMII_MII_RGMII        (1<< 0)
 
-#if defined(CONFIG_RTL_8196C) || defined(CONFIG_RTL_8198)
+#if defined(CONFIG_RTL_8196C) || defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 
 #define GIGA_P5_PHYID	0x16
 /* 0xBB804104 ~ 0xBB804124 */
@@ -1369,7 +1369,7 @@ to forward packet to the unauthorized node. Otherwise, it is not allowed.
 #define CVIDR                               (0x00+SWMISC_BASE)     /* Chip Version ID Register */
 #define SSIR						        (0x04+SWMISC_BASE)     /* System Initial and Reset Registe*/
 
-#if defined(CONFIG_RTL_8196C) || defined(CONFIG_RTL_8198)
+#if defined(CONFIG_RTL_8196C) || defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
 #define CRMR                                (0x08+SWMISC_BASE)     /* Chip Revision Management Register */
 #define BISTCR                              (0x0C+SWMISC_BASE)     /* BIST control */
 #define BISTTSDR0                           (0x38+SWMISC_BASE)     /* BIST Test Status Diagnostic Register 0 */
diff --git a/include/linux/irqnr.h b/include/linux/irqnr.h
index ec87b21..84c1ecb 100644
--- a/include/linux/irqnr.h
+++ b/include/linux/irqnr.h
@@ -8,7 +8,6 @@
 
 #ifndef CONFIG_GENERIC_HARDIRQS
 #include <asm/irq.h>
-
 /*
  * Wrappers for non-genirq architectures:
  */
@@ -24,7 +23,12 @@
 #else /* CONFIG_GENERIC_HARDIRQS */
 
 extern int nr_irqs;
-extern struct irq_desc *irq_to_desc(unsigned int irq);
+#if defined(CONFIG_RTL_819X) && !defined(CONFIG_RTL_8196C) && !defined(CONFIG_SPARSE_IRQ)
+ //__MIPS16 is defined at include/net/rtl/rtl_types.h
+ extern __attribute__((mips16))  struct irq_desc *irq_to_desc(unsigned int irq);
+#else
+ extern  struct irq_desc *irq_to_desc(unsigned int irq);
+#endif
 
 # define for_each_irq_desc(irq, desc)					\
 	for (irq = 0, desc = irq_to_desc(irq); irq < nr_irqs;		\
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index 1ab7f93..7033a70 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -858,7 +858,7 @@ struct net_device
 
 	/* VLAN feature mask */
 	unsigned long vlan_features;
-
+	
 	/* for setting kernel sock attribute on TCP connection setup */
 #define GSO_MAX_SIZE		65536
 	unsigned int		gso_max_size;
@@ -1001,6 +1001,14 @@ static inline void *netdev_priv(const struct net_device *dev)
  */
 #define SET_NETDEV_DEV(net, pdev)	((net)->dev.parent = (pdev))
 
+#ifdef CONFIG_RTL_USB_OTG
+/* Set the sysfs device type for the network logical device to allow
+ * fin grained indentification of different network device types. For
+ * example Ethernet, Wirelss LAN, Bluetooth, WiMAX etc.
+ */
+#define SET_NETDEV_DEVTYPE(net, devtype)	((net)->dev.type = (devtype))
+#endif
+
 /**
  *	netif_napi_add - initialize a napi context
  *	@dev:  network device
diff --git a/include/linux/netfilter_ipv4/ip_conntrack_pptp.h b/include/linux/netfilter_ipv4/ip_conntrack_pptp.h
index 934d8fa..7b24f81 100644
--- a/include/linux/netfilter_ipv4/ip_conntrack_pptp.h
+++ b/include/linux/netfilter_ipv4/ip_conntrack_pptp.h
@@ -333,26 +333,6 @@ extern void
 (*ip_nat_pptp_hook_expectfn)(struct ip_conntrack *ct,
 			     struct ip_conntrack_expect *exp);
 
-#define	ETH_ALEN	6
-struct pptp_acc_info {
-	unsigned long fast_pptp_lastxmit;
-	int valid;
-	struct net_device *wanDev;
-	unsigned char ourMac[ETH_ALEN];
-	__u16 ourCallID;
-	__u32 ourIp;
-	unsigned char peerMac[ETH_ALEN];
-	__u16 peerCallID;
-	__u32 peerIp;
-	unsigned int tx_seqno;
-	unsigned int rx_seqno;
-	__u16 tx_ipID;
-	__u16 ipID;
-	unsigned int tx_seqno_daemon;
-	unsigned int rx_seqno_daemon;
-	struct net_device *pppDev;
-	struct ppp_channel *pppChan;
-};
 
 #endif /* __KERNEL__ */
 #endif /* _CONNTRACK_PPTP_H */
diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index d76ec8e..901331b 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -14,7 +14,7 @@
 #define NETLINK_SELINUX		7	/* SELinux event notifications */
 #define NETLINK_ISCSI		8	/* Open-iSCSI */
 #define NETLINK_AUDIT		9	/* auditing */
-#define NETLINK_FIB_LOOKUP	10	
+#define NETLINK_FIB_LOOKUP	10
 #define NETLINK_CONNECTOR	11
 #define NETLINK_NETFILTER	12	/* netfilter subsystem */
 #define NETLINK_IP6_FW		13
@@ -24,11 +24,16 @@
 /* leave room for NETLINK_DM (DM Events) */
 #define NETLINK_SCSITRANSPORT	18	/* SCSI Transports */
 #define NETLINK_ECRYPTFS	19
+
+#if defined(CONFIG_RTL_819X)
 #define NETLINK_RTK_DEBUG 	21
 #define NETLINK_RTK_FILTER 	22
 #define NETLINK_MULTICAST_DELETE 	23
+#define NETLINK_RTK_FB		24
+#define NETLINK_RTK_HW_QOS 25
+#endif
 
-#define MAX_LINKS 32		
+#define MAX_LINKS 32
 
 struct net;
 
diff --git a/include/linux/serial.h b/include/linux/serial.h
index e5bb75a..99bbdbb 100644
--- a/include/linux/serial.h
+++ b/include/linux/serial.h
@@ -116,7 +116,7 @@ struct serial_uart_config {
 #define ASYNCB_SPD_SHI		12 /* Use 230400 instead of 38400 bps */
 #define ASYNCB_LOW_LATENCY	13 /* Request low latency behaviour */
 #define ASYNCB_BUGGY_UART	14 /* This is a buggy UART, skip some safety
-				    * checks.  Note: can be dangerous! */
+				  * checks.  Note: can be dangerous! */
 #define ASYNCB_AUTOPROBE	15 /* Port was autoprobed by PCI or PNP code */
 #define ASYNCB_LAST_USER	15
 
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index f87db57..5c751a5 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -36,10 +36,14 @@
 #define RTL_PRIV_DATA_SIZE		128
 #endif
 
-#if defined(CONFIG_RTL_QOS_PATCH)
+#if defined(CONFIG_RTL_QOS_PATCH)  || defined(CONFIG_RTK_VOIP_QOS)|| defined(CONFIG_RTK_VLAN_WAN_TAG_SUPPORT)
 #define	QOS_PATCH_HIGH_QUEUE_PRIO	7
 #define	QOS_PATCH_RX_FROM_LOCAL		0xff
 #define QOS_PATCH_RX_FROM_WIRELESS      7
+#if defined(CONFIG_RTK_VLAN_WAN_TAG_SUPPORT)
+#define RX_FROM_LOCAL	QOS_PATCH_RX_FROM_LOCAL
+#define RX_FROM_WIRELESS QOS_PATCH_RX_FROM_WIRELESS
+#endif
 #endif
 
 
@@ -265,7 +269,7 @@ typedef unsigned int sk_buff_data_t;
 typedef unsigned char *sk_buff_data_t;
 #endif
 
-/** 
+/**
  *	struct sk_buff - socket buffer
  *	@next: Next buffer in list
  *	@prev: Previous buffer in list
@@ -294,7 +298,7 @@ typedef unsigned char *sk_buff_data_t;
  *	@priority: Packet queueing priority
  *	@users: User count - see {datagram,tcp}.c
  *	@protocol: Packet protocol from driver
- *	@truesize: Buffer size 
+ *	@truesize: Buffer size
  *	@head: Head of buffer
  *	@data: Data head pointer
  *	@tail: Tail pointer
@@ -424,13 +428,16 @@ struct sk_buff {
 
 #if defined(CONFIG_RTK_VLAN_SUPPORT)
 	struct vlan_tag tag;
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+	struct vlan_info *src_info;
+#endif
 #endif
 #if defined (CONFIG_RTL_LOCAL_PUBLIC)
 	__u32 srcLocalPublicIp;
 	__u8 fromLocalPublic;
 	__u8 toLocalPublic;
 	__u8 localPublicFlags;
-#endif 
+#endif
 #if defined(CONFIG_RTL_FAST_BRIDGE)
 	__u8 fast_br_forwarding_flags;
 #endif
@@ -1380,7 +1387,7 @@ static inline int skb_network_offset(const struct sk_buff *skb)
  * The downside to this alignment of the IP header is that the DMA is now
  * unaligned. On some architectures the cost of an unaligned DMA is high
  * and this cost outweighs the gains made by aligning the IP header.
- * 
+ *
  * Since this trade off varies between architectures, we allow NET_IP_ALIGN
  * to be overridden.
  */
@@ -1626,7 +1633,7 @@ static inline int skb_cow_head(struct sk_buff *skb, unsigned int headroom)
  *	is untouched. Otherwise it is extended. Returns zero on
  *	success. The skb is freed on error.
  */
- 
+
 static inline int skb_padto(struct sk_buff *skb, unsigned int len)
 {
 	unsigned int size = skb->len;
diff --git a/include/linux/usb/gadget.h b/include/linux/usb/gadget.h
index fe55572..1e52d3a 100644
--- a/include/linux/usb/gadget.h
+++ b/include/linux/usb/gadget.h
@@ -115,6 +115,12 @@ struct usb_ep_ops {
 		gfp_t gfp_flags);
 	void (*free_request) (struct usb_ep *ep, struct usb_request *req);
 
+#ifdef CONFIG_RTL_USB_OTG
+	void *(*alloc_buffer) (struct usb_ep *ep, unsigned bytes,
+		dma_addr_t *dma, gfp_t gfp_flags);
+	void (*free_buffer) (struct usb_ep *ep, void *buf, dma_addr_t dma,
+		unsigned bytes);
+#endif
 	int (*queue) (struct usb_ep *ep, struct usb_request *req,
 		gfp_t gfp_flags);
 	int (*dequeue) (struct usb_ep *ep, struct usb_request *req);
@@ -233,6 +239,49 @@ static inline void usb_ep_free_request(struct usb_ep *ep,
 	ep->ops->free_request(ep, req);
 }
 
+#ifdef CONFIG_RTL_USB_OTG
+/**
+ * usb_ep_alloc_buffer - allocate an I/O buffer
+ * @ep:the endpoint associated with the buffer
+ * @len:length of the desired buffer
+ * @dma:pointer to the buffer's DMA address; must be valid
+ * @gfp_flags:GFP_* flags to use
+ *
+ * Returns a new buffer, or null if one could not be allocated.
+ * The buffer is suitably aligned for dma, if that endpoint uses DMA,
+ * and the caller won't have to care about dma-inconsistency
+ * or any hidden "bounce buffer" mechanism.  No additional per-request
+ * DMA mapping will be required for such buffers.
+ * Free it later with usb_ep_free_buffer().
+ *
+ * You don't need to use this call to allocate I/O buffers unless you
+ * want to make sure drivers don't incur costs for such "bounce buffer"
+ * copies or per-request DMA mappings.
+ */
+static inline void *
+usb_ep_alloc_buffer (struct usb_ep *ep, unsigned len, dma_addr_t *dma,
+	gfp_t gfp_flags)
+{
+	return ep->ops->alloc_buffer (ep, len, dma, gfp_flags);
+}
+
+/**
+ * usb_ep_free_buffer - frees an i/o buffer
+ * @ep:the endpoint associated with the buffer
+ * @buf:CPU view address of the buffer
+ * @dma:the buffer's DMA address
+ * @len:length of the buffer
+ *
+ * reverses the effect of usb_ep_alloc_buffer().
+ * caller guarantees the buffer will no longer be accessed
+ */
+static inline void
+usb_ep_free_buffer (struct usb_ep *ep, void *buf, dma_addr_t dma, unsigned len)
+{
+	ep->ops->free_buffer (ep, buf, dma, len);
+}
+#endif
+
 /**
  * usb_ep_queue - queues (submits) an I/O request to an endpoint.
  * @ep:the endpoint associated with the request
@@ -892,9 +941,16 @@ static inline void usb_free_descriptors(struct usb_descriptor_header **v)
 
 /* utility wrapping a simple endpoint selection policy */
 
+#if defined(CONFIG_RTL_ULINKER)
+extern struct usb_ep *usb_ep_autoconfig(struct usb_gadget *,
+			struct usb_endpoint_descriptor *);
+
+extern void usb_ep_autoconfig_reset(struct usb_gadget *);
+#else
 extern struct usb_ep *usb_ep_autoconfig(struct usb_gadget *,
 			struct usb_endpoint_descriptor *) __devinit;
 
 extern void usb_ep_autoconfig_reset(struct usb_gadget *) __devinit;
+#endif /* #if defined(CONFIG_RTL_ULINKER) */
 
 #endif /* __LINUX_USB_GADGET_H */
diff --git a/include/net/netfilter/nf_conntrack.h b/include/net/netfilter/nf_conntrack.h
index b184310..33be296 100644
--- a/include/net/netfilter/nf_conntrack.h
+++ b/include/net/netfilter/nf_conntrack.h
@@ -17,6 +17,7 @@
 #if defined(CONFIG_FAST_PATH_SPI_ENABLED)
 #define FAST_PATH_SPI_ENABLED		1
 #endif
+
 #endif
 
 #include <linux/netfilter/nf_conntrack_common.h>
@@ -79,6 +80,7 @@ union nf_conntrack_help {
 
 struct nf_conntrack_helper;
 
+
 /* Must be kept in sync with the classes defined by helpers */
 #define NF_CT_MAX_EXPECT_CLASSES	3
 
@@ -118,28 +120,102 @@ struct nf_conn {
 	/* Timer function; drops refcnt when it goes off. */
 	struct timer_list timeout;
 
+#if defined(CONFIG_NF_CONNTRACK_MARK)
+	u_int32_t mark;
+#endif
+
+#ifdef CONFIG_NF_CONNTRACK_SECMARK
+	u_int32_t secmark;
+#endif
+
+#if defined(CONFIG_NETFILTER_XT_MATCH_LAYER7) || \
+    defined(CONFIG_NETFILTER_XT_MATCH_LAYER7_MODULE)
+	struct {
+		/*
+		 * e.g. "http". NULL before decision. "unknown" after decision
+		 * if no match.
+		 */
+		char *app_proto;
+		/*
+		 * application layer data so far. NULL after match decision.
+		 */
+		char *app_data;
+		unsigned int app_data_len;
+	} layer7;
+#endif
+
 	/* Storage reserved for other modules: */
 	union nf_conntrack_proto proto;
 
 	/* Extensions */
 	struct nf_ct_ext *ext;
 
-#ifdef CONFIG_NET_NS
+	#ifdef CONFIG_NET_NS
 	struct net *ct_net;
-#endif
+	#endif
 
 	#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
        struct list_head 	state_tuple;
+	   char drop_flag;
+	   char removed;
 	#endif
+};
 
-	#if defined(CONFIG_NF_CONNTRACK_MARK)
-	u_int32_t mark;
-	#endif
 
-	#ifdef CONFIG_NF_CONNTRACK_SECMARK
-	u_int32_t secmark;
-	#endif
-};
+extern int routerTypeFlag;
+
+#define CONFIG_RTL_ROUTER_FAST_PATH 1
+#if defined (CONFIG_RTL_ROUTER_FAST_PATH)
+extern unsigned int _br0_ip;
+extern unsigned int _br0_mask;
+
+static inline int rtl_isRouterType(struct nf_conn *ct)
+{
+	if(((ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip == ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip) &&
+	    (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip == ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3.ip)))
+	    		return 1;
+	return 0;
+}
+
+static inline int rtl_isRouterTypeWantoLan(struct nf_conn * ct)
+{
+	if((ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3.ip != _br0_ip) &&
+		((ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3.ip & _br0_mask) == (_br0_ip & _br0_mask)) &&
+		((ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip & _br0_mask) != (_br0_ip & _br0_mask)))
+			return 1;
+
+	return 0;
+}
+
+
+static inline int rtl_isNatTypeWantoLan(struct nf_conn* ct)
+{
+	if(ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip== ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip)
+		return 1;
+
+	return 0;
+}
+
+static inline int rtl_isRouterTypeLantoWan(struct nf_conn* ct)
+{
+	if((ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip != _br0_ip) &&
+	  	 ((ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip & _br0_mask) == (_br0_ip & _br0_mask)) &&
+	 	 ((ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3.ip & _br0_mask) != (_br0_ip & _br0_mask)))
+			return 1;
+
+	return 0;
+}
+
+static inline int rtl_isNatTypeLantoWan(struct nf_conn* ct)
+{
+	if (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip== ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3.ip)
+		return 1;
+
+	return 0;
+}
+
+#endif
+
 
 static inline struct nf_conn *
 nf_ct_tuplehash_to_ctrack(const struct nf_conntrack_tuple_hash *hash)
@@ -233,30 +309,30 @@ extern void __nf_ct_refresh_acct(struct nf_conn *ct,
 				 int do_acct);
 
 #if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
-extern void __nf_ct_refresh_acct_proto(struct nf_conn *ct, 
+extern void __nf_ct_refresh_acct_proto(void *ct,
 				      enum ip_conntrack_info ctinfo,
-				      const struct sk_buff *skb,
+				      const void *skb,
 				      unsigned long extra_jiffies,
 				      int do_acct,
-				      unsigned char proto, 
+				      unsigned char proto,
 				      void * extra1,
 				      void * extra2);
 
-static inline void nf_ct_refresh_acct_tcp(struct nf_conn *ct, 
+static inline void nf_ct_refresh_acct_tcp(struct nf_conn *ct,
 				      enum ip_conntrack_info ctinfo,
 				      const struct sk_buff *skb,
 				      unsigned long extra_jiffies,
 				      enum tcp_conntrack oldstate,
-				      enum tcp_conntrack newstate) 
+				      enum tcp_conntrack newstate)
 {
 	__nf_ct_refresh_acct_proto(ct, ctinfo, skb, extra_jiffies, 1, 6, (void *)oldstate, (void *)newstate);
 }
 
 
-static inline void nf_ct_refresh_acct_udp(struct nf_conn *ct, 
+static inline void nf_ct_refresh_acct_udp(struct nf_conn *ct,
 				      enum ip_conntrack_info ctinfo,
 				      const struct sk_buff *skb,
-				      unsigned long extra_jiffies, char * status) 
+				      unsigned long extra_jiffies, char * status)
 {
 	__nf_ct_refresh_acct_proto(ct, ctinfo, skb, extra_jiffies, 1, 17, (void *)status, (void *)0);
 }
@@ -309,6 +385,20 @@ extern void nf_conntrack_tcp_update(const struct sk_buff *skb,
 /* Fake conntrack entry for untracked connections */
 extern struct nf_conn nf_conntrack_untracked;
 
+#if defined(CONFIG_RTL_BATTLENET_ALG)
+#define BATTLENET_PORT 6112
+#define RTL_DEV_NAME_NUM(name,num)	name#num
+#define RTL_PS_PPP_NAME	"ppp"
+#define RTL_PS_PPP0_DEV_NAME RTL_DEV_NAME_NUM(RTL_PS_PPP_NAME,0)
+extern unsigned int wan_ip;
+extern unsigned int wan_mask;
+extern struct net_device *rtl865x_getBattleNetWanDev(void );
+extern int rtl865x_getBattleNetDevIpAndNetmask(struct net_device * dev, unsigned int *ipAddr, unsigned int *netMask );
+extern struct nf_conn *rtl_find_ct_by_tuple_src(struct nf_conntrack_tuple *tuple, int *flag);
+extern struct nf_conn *rtl_find_ct_by_tuple_dst(struct nf_conntrack_tuple *tuple, int *flag);
+
+#endif
+
 /* Iterate over all conntracks: if iter returns true, it's deleted. */
 extern void
 nf_ct_iterate_cleanup(struct net *net, int (*iter)(struct nf_conn *i, void *data), void *data);
@@ -353,5 +443,40 @@ do {							\
 #define MODULE_ALIAS_NFCT_HELPER(helper) \
         MODULE_ALIAS("nfct-helper-" helper)
 
+
+#define RTL_NF_ALG_CTL 1
+
+#ifdef RTL_NF_ALG_CTL
+extern int alg_enable(int type);
+
+enum alg_type
+{
+    alg_type_ftp,
+    alg_type_tftp,
+    alg_type_rtsp,
+    alg_type_pptp,
+    alg_type_l2tp,
+    alg_type_ipsec,
+    alg_type_sip,
+    alg_type_h323,
+    alg_type_end
+};
+
+struct alg_entry
+{
+    char *name;
+    int enable;
+};
+
+#define ALG_CTL_DEF(type, val)  [alg_type_##type] = {#type, val}
+
+#define ALG_CHECK_ONOFF(type)   \
+if (!alg_enable(type))\
+{\
+    return NF_ACCEPT;\
+}
+#endif
+
+
 #endif /* __KERNEL__ */
 #endif /* _NF_CONNTRACK_H */
diff --git a/include/net/netfilter/nf_conntrack_expect.h b/include/net/netfilter/nf_conntrack_expect.h
index a965280..9a9b51c 100644
--- a/include/net/netfilter/nf_conntrack_expect.h
+++ b/include/net/netfilter/nf_conntrack_expect.h
@@ -81,6 +81,11 @@ void nf_conntrack_expect_fini(struct net *net);
 struct nf_conntrack_expect *
 __nf_ct_expect_find(struct net *net, const struct nf_conntrack_tuple *tuple);
 
+#if defined(CONFIG_IP_NF_TARGET_CONENAT)
+struct nf_conntrack_expect *
+__nf_ct_expect_find_bysave(struct net *net, const struct nf_conntrack_tuple *tupleMake, const struct nf_conntrack_tuple *tuple);
+#endif
+
 struct nf_conntrack_expect *
 nf_ct_expect_find_get(struct net *net, const struct nf_conntrack_tuple *tuple);
 
@@ -99,7 +104,7 @@ void nf_ct_expect_init(struct nf_conntrack_expect *, unsigned int, u_int8_t,
 		       const union nf_inet_addr *,
 		       u_int8_t, const __be16 *, const __be16 *);
 void nf_ct_expect_put(struct nf_conntrack_expect *exp);
-int nf_ct_expect_related_report(struct nf_conntrack_expect *expect, 
+int nf_ct_expect_related_report(struct nf_conntrack_expect *expect,
 				u32 pid, int report);
 static inline int nf_ct_expect_related(struct nf_conntrack_expect *expect)
 {
diff --git a/include/net/rtl/fastpath/fastpath_core.h b/include/net/rtl/fastpath/fastpath_core.h
index 9d02db0..5f5d0db 100644
--- a/include/net/rtl/fastpath/fastpath_core.h
+++ b/include/net/rtl/fastpath/fastpath_core.h
@@ -71,8 +71,8 @@
 /***********************************cary:refine filter.c**********************************/
 #define FASTPATH_FILTER	1
 /***********************************************************************************/
-#define CUSTOM_RSP_PACKET 
-#define DOS_FILTER 
+#define CUSTOM_RSP_PACKET
+#define DOS_FILTER
 #define URL_FILTER
 
 //#define URL_CONTENT_AUTHENTICATION
@@ -103,7 +103,7 @@
 
 typedef struct _unAuth_skb_s
 {
-	struct list_head list;	
+	struct list_head list;
 	int id; /*skb->iphdr.id*/
 	uint32 saddr;
 	uint32 daddr;
@@ -122,8 +122,8 @@ int rtl_urlContent_auth(struct sk_buff *skb);
 
 struct l2tp_info
 {
-	struct net_device *wan_dev;
-	struct net_device *ppp0_dev;
+	void *wan_dev;
+	void *ppp0_dev;
 	unsigned long last_xmit;
 	__u32 daddr;
 	__u32 saddr;
@@ -131,7 +131,7 @@ struct l2tp_info
 	__u16 cid;                   /* Caller ID */
         unsigned char mac_header[ETH_HLEN];
 	__u16 valid;
-	
+
 
 };
 
@@ -165,7 +165,7 @@ struct l2tp_header
 	__u16 Ns;                    /* Optional next sent */
 	__u16 Nr;                    /* Optional next received */
 };
-extern void (*l2tp_tx_id_hook)(struct sk_buff *skb);
+extern void (*l2tp_tx_id_hook)(void *skb);
 
 #endif
 
@@ -199,6 +199,26 @@ struct pptp_info {
 };
 */
 
+struct pptp_acc_info {
+	unsigned long fast_pptp_lastxmit;
+	int valid;
+	void *wanDev;
+	unsigned char ourMac[ETHER_ADDR_LEN];
+	__u16 ourCallID;
+	__u32 ourIp;
+	unsigned char peerMac[ETHER_ADDR_LEN];
+	__u16 peerCallID;
+	__u32 peerIp;
+	unsigned int tx_seqno;
+	unsigned int rx_seqno;
+	__u16 tx_ipID;
+	__u16 ipID;
+	unsigned int tx_seqno_daemon;
+	unsigned int rx_seqno_daemon;
+	void *pppDev;
+	struct ppp_channel *pppChan;
+};
+
 extern int fast_pptp_fw;
 
 
@@ -276,10 +296,10 @@ void register_customRspHook(int *_cusRsp401_func,int *_cusRspTCPFinAck_func,int
 void unregister_customRspHook(void);
 void register_customRspStr(char *_str);
 void unregister_customRspStr(void);
- int  GenerateHTTP401(struct sk_buff *skb);
+ int  GenerateHTTP401(void *skb);
 #endif
 #ifdef DOS_FILTER
-	extern int filter_enter(struct sk_buff *skb);
+	extern int filter_enter(void *skb);
 	extern int __init filter_init(void);
 	extern void __exit filter_exit(void);
 	extern void filter_addconnect(ipaddr_t ipaddr);
@@ -287,21 +307,21 @@ void unregister_customRspStr(void);
 #endif
 
 #ifdef FAST_PPTP
-	extern void fast_pptp_filter(struct sk_buff *skb);
-	extern void fast_pptp_sync_rx_seq(struct sk_buff *skb);
+	extern void fast_pptp_filter(void *skb);
+	extern void fast_pptp_sync_rx_seq(void *skb);
 	extern int __init fast_pptp_init(void);
 	extern void __exit fast_pptp_exit(void);
-	extern int fast_pptp_to_lan(struct sk_buff **pskb);
-	extern int Check_GRE_rx_net_device(struct sk_buff *skb);
+	extern int fast_pptp_to_lan(void **pskb);
+	extern int Check_GRE_rx_net_device(void *skb);
 	extern int pptp_tcp_finished;
 #endif
 
 #ifdef FAST_L2TP
 	extern int __init fast_l2tp_init(void);
 	extern void __exit fast_l2tp_exit(void);
-	extern int fast_l2tp_to_wan(struct sk_buff *skb);
-	extern void fast_l2tp_rx(struct sk_buff *skb);
-	extern void l2tp_tx_id(struct sk_buff *skb);	
+	extern int fast_l2tp_to_wan(void *skb);
+	extern void fast_l2tp_rx(void *skb);
+	extern void l2tp_tx_id(void *skb);
 	extern int fast_l2tp_fw;
 #endif
 
@@ -320,7 +340,7 @@ void unregister_customRspStr(void);
 #define	ROUTE_TABLE_ENTRY_MAX	64
 
 #if !defined(CONFIG_RTL8186_KB_N)
-#if defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_92D_SUPPORT)
+#if defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_92D_SUPPORT) ||defined(CONFIG_RTL_8196D) ||defined(CONFIG_RTL_8197D) ||(defined(CONFIG_RTL_8196E)&&defined(CONFIG_RTL_SDRAM_GE_32M))
 #define	NAPT_TABLE_LIST_MAX	4096
 #define	NAPT_TABLE_ENTRY_MAX	4096
 #define	PATH_TABLE_LIST_MAX	4096
@@ -358,7 +378,7 @@ enum LR_RESULT
 	LR_ERROR_PARAMETER = -2,				/* The given parameter error */
 	LR_EXIST = -3,							/* The entry you want to add has been existed, add failed */
 	LR_NONEXIST = -4,						/* The specified entry is not found */
-	
+
 	LR_NOBUFFER = -1000,					/* Out of Entry Space */
 	LR_INVAPARAM = -1001,					/* Invalid parameters */
 	LR_NOTFOUND = -1002,					/* Entry not found */
@@ -440,8 +460,8 @@ enum LR_RESULT rtk_delSession( uint8* ifname );
 
 enum LR_RESULT rtk_addNaptConnection(rtl_fp_napt_entry *fpNaptEntry,
 #if defined(IMPROVE_QOS)
-									struct sk_buff *pskb, struct nf_conn *ct, 
-#endif								
+									void *pskb, void *ct,
+#endif
 									enum NP_FLAGS flags);
 enum LR_RESULT rtk_delNaptConnection( rtl_fp_napt_entry *fpNaptEntry);
 #if defined(IMPROVE_QOS)
@@ -455,7 +475,7 @@ int32 rtl_br_fdb_time_update(void *br, void *fdb, const unsigned char *addr);
 int32 rtl_fp_dev_queue_xmit_check(struct sk_buff *skb, struct net_device *dev);
 int32 rtl_fp_dev_hard_start_xmit_check(struct sk_buff *skb, struct net_device *dev, struct netdev_queue *txq);
 
-#if defined(IMPROVE_QOS) || defined(CONFIG_RTL_HW_QOS_SUPPORT) 
+#if defined(IMPROVE_QOS) || defined(CONFIG_RTL_HW_QOS_SUPPORT)
 //To query hardware address based on IP through arp table of dev
 int arp_req_get_ha(__be32 queryIP, struct net_device *dev, unsigned char * resHwAddr);
 #endif
@@ -597,8 +617,8 @@ int fastpath_dump_napt_entry_num(char *page, int len);
 			chksum = htons((uint16) accumulate); \
 		} \
 	}while(0)	/* Checksum adjustment */
-	
-	
+
+
 #define FASTPATH_ADJUST_CHKSUM_NAPT(ip_mod, ip_org, port_mod, port_org, chksum) \
 	do { \
 		s32 accumulate = 0; \
@@ -643,22 +663,22 @@ int fast_path_pre_process_check(struct iphdr *iph, struct tcphdr *tcphupuh, stru
 int fast_path_post_process_xmit_check(struct iphdr *iph, struct tcphdr *tcphupuh, struct sk_buff *skb);
 int fast_path_post_process_return_check(struct iphdr *iph, struct tcphdr *tcphupuh, struct sk_buff *skb);
 int ip_finish_output3(struct sk_buff *skb);
-__IRAM_GEN int enter_fast_path(struct sk_buff *skb);
+__IRAM_GEN int enter_fast_path(void *skb);
 uint8 *FastPath_Route(ipaddr_t dIp);
 int FastPath_Enter(struct sk_buff **skb);
 extern int Get_fast_pptp_fw(void);
 #ifdef CONFIG_FAST_PATH_MODULE
 extern int (*fast_path_hook)(struct sk_buff **pskb) ;
 extern enum LR_RESULT (*FastPath_hook1)( ipaddr_t ip, ipaddr_t mask );
-extern enum LR_RESULT (*FastPath_hook2)( ipaddr_t ip, ipaddr_t mask, ipaddr_t gateway, uint8* ifname, enum RT_FLAGS flags );                     
+extern enum LR_RESULT (*FastPath_hook2)( ipaddr_t ip, ipaddr_t mask, ipaddr_t gateway, uint8* ifname, enum RT_FLAGS flags );
 extern int (*fast_path_hook)(struct sk_buff **pskb) ;
 extern enum LR_RESULT (*FastPath_hook3)( ipaddr_t ip, ipaddr_t mask, ipaddr_t gateway, uint8* ifname, enum RT_FLAGS flags );
 extern  enum LR_RESULT (*FastPath_hook4)( rtl_fp_napt_entry *fpNaptEntry);
 extern enum LR_RESULT (*FastPath_hook5)( ipaddr_t ip, ether_addr_t* mac, enum ARP_FLAGS flags );
 enum LR_RESULT (*FastPath_hook6)( rtl_fp_napt_entry *fpNaptEntry,
 #if defined(IMPROVE_QOS)
-									struct sk_buff *pskb, struct nf_conn *ct, 
-#endif								
+									struct sk_buff *pskb, struct nf_conn *ct,
+#endif
                                                                enum NP_FLAGS flags);
 extern enum LR_RESULT (*FastPath_hook7)( ipaddr_t ip );
 extern enum LR_RESULT (*FastPath_hook8)( ipaddr_t ip, ether_addr_t* mac, enum ARP_FLAGS flags );
@@ -666,12 +686,12 @@ extern int (*FastPath_hook9)( void );
 extern int (*FastPath_hook10)(struct sk_buff *skb);
 extern enum LR_RESULT (*FastPath_hook11)(rtl_fp_napt_entry *fpNaptEntry, uint32 interval);
 
-extern  int fast_pptp_to_wan(struct sk_buff *skb);
+extern  int fast_pptp_to_wan(void *skb);
 #endif
 
 /* ---------------------------------------------------------------------------------------------------- */
 #if defined(FASTPATH_FILTER)
-#define RTL_FILTER_CONTENT_MAXNUM 40	
+#define RTL_FILTER_CONTENT_MAXNUM 40
 #define RTL_TABLE_FILTER_ENTRY_COUNT 10
 #define IP_RANGE_TABLE 	1
 #define MAC_TABLE		2
@@ -691,7 +711,7 @@ typedef struct _rlt_filter_table_head
 typedef struct _filter_ipRange_fastpath
 {
 	struct list_head list;
-	uint32 addr_start; /*ipaddr start*/	
+	uint32 addr_start; /*ipaddr start*/
 	uint32 addr_end; /*address end*/
 	uint32 flag; /*0 bit: default action[0:block,1:forward];1 bit: src ip or dest ip[0:src, 1:dest];2 bit: refer both direction*/
 			    /*bit 9: valid 1; invalid 0*/
@@ -701,7 +721,7 @@ typedef struct _filter_ipRange_fastpath
 #define RTL_URL_FILTER_CONTENT_MAXNUM_FASTPATH 40
 typedef struct _url_table_head_entry_fastpath
 {
-	struct list_head list;	
+	struct list_head list;
 	uint32 flag;
 	int (*func)(struct sk_buff *skb);
 }url_table_head_entry_fastpath;
@@ -723,7 +743,7 @@ typedef struct _rtl_mac_entry_fastpath
 {
 	struct list_head list;
 	char mac[ETHER_ADDR_LEN];
-	uint8 flag; 
+	uint8 flag;
 }rtl_mac_entry_fastpath;
 
 typedef struct _rtl_sch_entry_fastpath
@@ -745,7 +765,7 @@ typedef struct _filter_table_info
 typedef struct _filter_table_list
 {
 	struct list_head table_list;
-	struct list_head item_list;	
+	struct list_head item_list;
 	uint32 type;	//type
 	uint32 flag;
 	uint32 num;
@@ -754,8 +774,8 @@ typedef struct _filter_table_list
 
 typedef struct _filter_item_entry
 {
-	struct list_head item_list;	
-	struct list_head rule_list;	
+	struct list_head item_list;
+	struct list_head rule_list;
 	uint32 relation_flag;	//bit0: is the first condition? 1;0
 						//bit1: have next condition? 1:0 [next table condition]
 						//bit2: have "and" logic condition?1:0
@@ -764,7 +784,7 @@ typedef struct _filter_item_entry
 						//bit8: all match flag 1: all, 0: not all
 						//bit9: NULL flag, 1:NULL, 0: not NULL
 	uint32 index;
-	uint32 flag;		
+	uint32 flag;
 	char data[RTL_FILTER_CONTENT_MAXNUM];
 }filter_item_entry;
 
@@ -783,8 +803,78 @@ extern filter_table_list table_list_head;
 #define RTL_FASTPATH_PPP0_DEV_NAME	"ppp0"
 
 #if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
-void rtl_fp_mark_invalid(struct nf_conn *ct);
+void rtl_fp_mark_invalid(void *ct);
+#endif
+
+#define FASTPTH_INDEPENDENCE_KERNEL 1
+#if defined(FASTPTH_INDEPENDENCE_KERNEL)
+extern struct dst_entry *dst_tmp;
+extern int ppp_start_xmit(struct sk_buff *skb, struct net_device *dev);
+extern struct sk_buff *ppp_receive_nonmp_frame(struct ppp *ppp, struct sk_buff *skb, int is_fast_fw);
+unsigned int rtl_get_skb_len(struct sk_buff *skb);
+__be16 rtl_get_skb_protocol(struct sk_buff *skb);
+unsigned char rtl_get_skb_type(struct sk_buff *skb);
+char *rtl_get_skb_dev_name(struct sk_buff *skb);
+__wsum rtl_get_skb_csum(struct sk_buff *skb);
+unsigned char *rtl_skb_mac_header(struct sk_buff * skb);
+int rtl_ppp_proto_check(struct sk_buff *skb, unsigned char* ppp_proto);
+unsigned int rtl_ipt_do_table(struct sk_buff * skb, unsigned int hook, void *in, void *out);
+int rtl_ip_route_input(struct sk_buff  *skb, __be32 daddr, __be32 saddr, u8 tos);
+int rtl_skb_dst_check(struct sk_buff *skb);
+void rtl_set_skb_ip_summed(struct sk_buff *skb, int value);
+void rtl_dst_release(struct sk_buff *skb);
+void rtl_set_skb_dev(struct sk_buff *skb, struct net_device *dev);
+void rtl_set_skb_inDev(struct sk_buff *skb);
+__u32 rtl_get_skb_mark(struct sk_buff *skb);
+void rtl_set_skb_mark(struct sk_buff *skb, unsigned int value);
+void rtl_store_skb_dst(struct sk_buff *skb);
+void rtl_set_skb_dst(struct sk_buff *skb);
+int rtl_tcp_get_timeouts(void *ptr);
+int rtl_arp_req_get_ha(__be32 queryIP, void *device, unsigned char * resHwAddr);
+void rtl_set_skb_dmac(struct sk_buff *skb, void *device);
+void rtl_set_skb_smac(struct sk_buff *skb, void *device);
+u_int8_t rtl_get_ct_protonum(void *ct_ptr, enum ip_conntrack_dir dir);
+unsigned long rtl_get_ct_udp_status(void *ct_ptr);
+u_int8_t rtl_get_ct_tcp_state(void *ct_ptr);
+__be32 rtl_get_ct_ip_by_dir(void *ct_ptr, enum ip_conntrack_dir dir, int flag);
+__be16 rtl_get_ct_port_by_dir(void *ct_ptr, enum ip_conntrack_dir dir, int flag);
+void rtl_set_ct_timeout_expires(void *ct_ptr, unsigned long value);
+unsigned long rtl_hold_time(void *br_ptr);
+void rtl_set_fdb_aging(void *fdb_ptr, unsigned long value);
+unsigned long rtl_get_fdb_aging(void *fdb_ptr);
+struct iphdr *rtl_ip_hdr(struct sk_buff *skb);
+struct ethhdr *rtl_eth_hdr(struct sk_buff *skb);
+int rtl_skb_mac_header_was_set(struct sk_buff *skb);
+void rtl_skb_set_mac_header(struct sk_buff *skb, int offset);
+struct net_device * rtl_get_dev_by_name(char *name);
+struct net_device *rtl_get_skb_dev(struct sk_buff* skb);
+unsigned char *rtl_get_skb_data(struct sk_buff* skb);
+void rtl_skb_reset_network_header(struct sk_buff *skb);
+void rtl_skb_reset_transport_header(struct sk_buff *skb);
+int rtl_call_skb_ndo_start_xmit(struct sk_buff *skb);
+char * rtl_get_ppp_dev_name(struct net_device *ppp_dev);
+void * rtl_get_ppp_dev_priv(struct net_device *ppp_dev);
+void rtl_inc_ppp_stats(struct ppp *ppp, int act, int len);
+void *rtl_set_skb_data(struct sk_buff *skb, int offset, int action);
+void *rtl_set_skb_tail(struct sk_buff *skb, int offset, int action);
+struct sk_buff *rtl_ppp_receive_nonmp_frame(struct ppp *ppp, struct sk_buff *skb, int is_fast_fw);
+int rtl_ppp_start_xmit(struct sk_buff *skb, struct net_device *dev);
+void rtl_set_skb_cb(struct sk_buff *skb, char *value, int len);
+int rtl_ppp_vj_check(struct ppp* ppp);
+void *rtl_get_ppp_xmit_pending(struct ppp* ppp);
+void rtl_set_ppp_xmit_pending(struct ppp* ppp, struct sk_buff* skb);
+void rtl_set_skb_nfct(struct sk_buff *skb, void *value);
+struct neighbour *rtl_neigh_lookup(const void *pkey, struct net_device *dev);
+struct hh_cache *rtl_get_hh_from_neigh(struct neighbour *neigh);
+seqlock_t rtl_get_lock_from_hh(struct hh_cache * hh);
+unsigned short rtl_get_len_from_hh(struct hh_cache * hh);
+unsigned long *rtl_get_data_from_hh(struct hh_cache * hh);
+unsigned int rtl_skb_headroom(struct sk_buff *skb);
+int rtl_skb_cloned(struct sk_buff *skb);
+int rtl_skb_shared(const struct sk_buff *skb);
+
 #endif
 
+
 #endif	/* __FASTPATH_CORE_H__ */
 
diff --git a/include/net/rtl/features/rtl_features.h b/include/net/rtl/features/rtl_features.h
index 45b2c74..c2e1ef4 100644
--- a/include/net/rtl/features/rtl_features.h
+++ b/include/net/rtl/features/rtl_features.h
@@ -1,19 +1,21 @@
-#ifndef	RTL_FEATURES_H
-#define	RTL_FEATURES_H		1
-
-extern int	rtl_nf_conntrack_threshold;
-
-#if defined(CONFIG_RTL_IPTABLES_FAST_PATH) || defined(CONFIG_RTL_HARDWARE_NAT) || defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
-#define IS_CLASSD_ADDR(__ipv4addr__)				((((uint32)(__ipv4addr__)) & 0xf0000000) == 0xe0000000)
-#define IS_ALLZERO_ADDR(__ipv4addr__)				((((uint32)(__ipv4addr__)) & 0xffffffff) == 0)
-#define IS_BROADCAST_ADDR(__ipv4addr__)			((((uint32)(__ipv4addr__)) & 0xffffffff) == 0xffffffff)
-#endif
-
+#ifndef	RTL_FEATURES_H
+#define	RTL_FEATURES_H		1
+
+extern char __conntrack_drop_check(void* tmp);
+extern int	rtl_nf_conntrack_threshold;
+extern int	drop_priority_max_idx;
+
+#if defined(CONFIG_RTL_IPTABLES_FAST_PATH) || defined(CONFIG_RTL_HARDWARE_NAT) || defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+#define IS_CLASSD_ADDR(__ipv4addr__)				((((uint32)(__ipv4addr__)) & 0xf0000000) == 0xe0000000)
+#define IS_ALLZERO_ADDR(__ipv4addr__)				((((uint32)(__ipv4addr__)) & 0xffffffff) == 0)
+#define IS_BROADCAST_ADDR(__ipv4addr__)			((((uint32)(__ipv4addr__)) & 0xffffffff) == 0xffffffff)
+#endif
+
 #if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
-struct tcp_state_hash_head
+struct tcp_state_hash_head
 {
 	enum tcp_conntrack state;
-	
+
 	struct list_head* state_hash;
 };
 struct udp_state_hash_head
@@ -31,8 +33,8 @@ struct DROP_PRORITY{
 };
 
 extern struct tcp_state_hash_head Tcp_State_Hash_Head[];
-extern struct udp_state_hash_head Udp_State_Hash_Head[];
-extern struct DROP_PRORITY drop_priority[];
+extern struct udp_state_hash_head Udp_State_Hash_Head[];
+extern struct DROP_PRORITY drop_priority[];
 
 enum {
 	PROT_ICMP,
@@ -40,140 +42,141 @@ enum {
 	PROT_UDP,
 	PROT_MAX
 };
-#endif
-
-#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
-#if defined(CONFIG_PROC_FS)
-extern unsigned long rtl_gc_overflow_timout;
-void gc_overflow_timout_proc_init(void);
-#endif
-void clean_from_lists(struct nf_conn *ct, struct net *net);
-void rtl_death_action(struct nf_conn *ct);
-int drop_one_conntrack(const struct nf_conntrack_tuple *orig,const struct nf_conntrack_tuple *repl);
-int32 rtl_nf_conn_GC_init(void);
-int32 rtl_connGC_addList(struct sk_buff *skb, struct nf_conn *ct);
-#endif
-
-#if defined(CONFIG_RTL_IPTABLES_FAST_PATH)
-int rtl_fpTimer_update(struct nf_conn *ct);
-#endif
-
-void rtl_fpAddConnCache(struct nf_conn *ct, struct sk_buff *skb);
-
-#if defined(CONFIG_RTL_LOCAL_PUBLIC) || defined(CONFIG_RTL_MULTIPLE_WAN) || (defined(CONFIG_NET_SCHED)&&defined(CONFIG_RTL_IPTABLES_FAST_PATH)) || defined(CONFIG_RTL_HW_QOS_SUPPORT) 
+#endif
+
+#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+#if defined(CONFIG_PROC_FS)
+extern unsigned long rtl_gc_overflow_timout;
+void gc_overflow_timout_proc_init(void);
+#endif
+void clean_from_lists(void *ct, void *net);
+void rtl_death_action(void *ct);
+int drop_one_conntrack(const struct nf_conntrack_tuple *orig,const struct nf_conntrack_tuple *repl);
+int isReservedConntrack(const struct nf_conntrack_tuple * orig, const struct nf_conntrack_tuple * repl);
+int32 rtl_nf_conn_GC_init(void);
+int32 rtl_connGC_addList(void *skb, void *ct);
+#endif
+
+#if defined(CONFIG_RTL_IPTABLES_FAST_PATH)
+int rtl_fpTimer_update(void *ct);
+#endif
+
+void rtl_fpAddConnCache(struct nf_conn *ct, struct sk_buff *skb);
+
+#if defined(CONFIG_RTL_LOCAL_PUBLIC) || defined(CONFIG_RTL_MULTIPLE_WAN) || (defined(CONFIG_NET_SCHED)&&defined(CONFIG_RTL_IPTABLES_FAST_PATH)) || defined(CONFIG_RTL_HW_QOS_SUPPORT)
 extern struct net_device *rtl865x_getWanDev(void );
 extern struct net_device *rtl865x_getLanDev(void );
 #endif
-
-#if defined (CONFIG_RTL_LOCAL_PUBLIC) || defined(CONFIG_RTL_HW_QOS_SUPPORT)
+
+#if defined (CONFIG_RTL_LOCAL_PUBLIC) || defined(CONFIG_RTL_HW_QOS_SUPPORT)
 extern int rtl865x_attainDevType(unsigned char *devName, unsigned int *isLanDev, unsigned int *isWanDev);
-#endif
-
+#endif
+
 #if defined(CONFIG_RTL_IPTABLES_FAST_PATH) || defined(CONFIG_RTL_HARDWARE_NAT)
 /*2007-12-19*/
-extern int 	tcp_get_timeouts_by_state(u_int8_t state);
+extern int 	tcp_get_timeouts_by_state(u_int8_t state);
 extern unsigned int nf_ct_udp_timeout;
-extern unsigned int nf_ct_udp_timeout_stream;
-void rtl_check_for_acc(struct nf_conn *ct, unsigned long expires);
-void rtl_delConnCache(struct nf_conn *ct);
-int32 rtl_connCache_timer_update(struct nf_conn *ct);
-#endif
-
-#if defined(CONFIG_RTL_HARDWARE_NAT)
-int rtl865x_handle_nat(struct nf_conn *ct, int act, struct sk_buff *skb);
-int rtl_hwnat_timer_update(struct nf_conn *ct);
-#endif
-
-#if defined(IMPROVE_QOS) && (defined(CONFIG_RTL_IPTABLES_FAST_PATH) || defined(CONFIG_RTL_HARDWARE_NAT))
-void rtl_addConnCache(struct nf_conn *ct, struct sk_buff *skb);
-#endif
-
-#if defined(CONFIG_RTL_819X)
-int32 rtl_nat_init(void);
-#endif
-
-#if defined(CONFIG_NET_SCHED)
-extern int gQosEnabled;
-int32 rtl_qos_init(void);
-int32 rtl_qos_cleanup(void);
-#endif
-
-#if defined(CONFIG_RTL_FAST_BRIDGE)
-int32 rtl_fb_add_br_entry(skb)
-#endif
-
-//#define CONFIG_HARDWARE_NAT_DEBUG
-
-#if defined(CONFIG_RTL_HARDWARE_NAT)
-#define RTL_MULTIPLE_WAN_NUM		2
-
+extern unsigned int nf_ct_udp_timeout_stream;
+void rtl_check_for_acc(struct nf_conn *ct, unsigned long expires);
+void rtl_delConnCache(struct nf_conn *ct);
+int32 rtl_connCache_timer_update(struct nf_conn *ct);
+#endif
+
+#if defined(CONFIG_RTL_HARDWARE_NAT)
+int32 rtl865x_handle_nat(struct nf_conn *ct, int act, struct sk_buff *skb);
+int rtl_hwnat_timer_update(struct nf_conn *ct);
+#endif
+
+#if defined(IMPROVE_QOS) && (defined(CONFIG_RTL_IPTABLES_FAST_PATH) || defined(CONFIG_RTL_HARDWARE_NAT))
+void rtl_addConnCache(struct nf_conn *ct, struct sk_buff *skb);
+#endif
+
+#if defined(CONFIG_RTL_819X)
+int32 rtl_nat_init(void);
+#endif
+
+#if defined(CONFIG_NET_SCHED)
+extern int gQosEnabled;
+int32 rtl_qos_init(void);
+int32 rtl_qos_cleanup(void);
+#endif
+
+#if defined(CONFIG_RTL_FAST_BRIDGE)
+int32 rtl_fb_add_br_entry(skb)
+#endif
+
+//#define CONFIG_HARDWARE_NAT_DEBUG
+
+#if defined(CONFIG_RTL_HARDWARE_NAT)
+#define RTL_MULTIPLE_WAN_NUM		2
+
 typedef struct _rtl_masq_if_struct
 {
 	unsigned int valid;
 	unsigned int ipAddr;
 	//struct ipt_entry *masq_entry;
 	char ifName[IFNAMSIZ];
-}rtl_masq_if;
-
+}rtl_masq_if;
+
 rtl_masq_if *rtl_get_masq_info_by_devName(const char* name);
 #endif
-
-#if	defined(CONFIG_RTL_HARDWARE_NAT )
-/*2007-12-19*/
-int32 syn_asic_arp(struct neighbour *n, int add);
-
-#if defined(CONFIG_RTL_MULTIPLE_WAN)
-int32 rtl_get_ps_arp_mapping(u32 ip,void *arp_entry);
-#endif
-#endif
-
-#if defined(FAST_PATH_SPI_ENABLED)
-extern struct nf_conntrack_l4proto **nf_ct_protos[PF_MAX];
+
+#if	defined(CONFIG_RTL_HARDWARE_NAT )
+/*2007-12-19*/
+int32 syn_asic_arp(struct neighbour *n, int add);
+
+#if defined(CONFIG_RTL_MULTIPLE_WAN)
+int32 rtl_get_ps_arp_mapping(u32 ip,void *arp_entry);
+#endif
+#endif
+
+#if defined(FAST_PATH_SPI_ENABLED)
+extern struct nf_conntrack_l4proto **nf_ct_protos[PF_MAX];
 extern unsigned int
-	rtl_nf_conntrack_in(struct net *net, unsigned int dataoff, unsigned int hooknum, struct sk_buff *skb);
-#endif
-
-#if defined(CONFIG_RTL_HARDWARE_NAT)	
-int rtl_flush_extern_ip(void);
-int rtl_init_masq_info(void);	
-int rtl_check_for_extern_ip(const char *name,
-		unsigned int valid_hooks, struct xt_table_info *newinfo,
-		void *entry0, unsigned int size,
-		unsigned int number, const unsigned int *hook_entries,
-		const unsigned int *underflows);
-#endif
-
+	rtl_nf_conntrack_in(struct net *net, unsigned int dataoff, unsigned int hooknum, struct sk_buff *skb);
+#endif
+
+#if defined(CONFIG_RTL_HARDWARE_NAT)
+int rtl_flush_extern_ip(void);
+int rtl_init_masq_info(void);
+int rtl_check_for_extern_ip(const char *name,
+		unsigned int valid_hooks, struct xt_table_info *newinfo,
+		void *entry0, unsigned int size,
+		unsigned int number, const unsigned int *hook_entries,
+		const unsigned int *underflows);
+#endif
+
 #if defined(CONFIG_RTL_HARDWARE_NAT)
-int rtl865x_handle_nat(struct nf_conn *ct, int act, struct sk_buff *skb);
-int32 rtl_update_ip_tables(char *name,  unsigned long event, struct in_ifaddr *ina);
-int32 rtl_fn_insert(struct fib_table *tb, struct fib_config *cfg, struct fib_info *fi);
-int32 rtl_fn_delete(struct fib_table *tb, struct fib_config *cfg);
-int32 rtl_fn_flush(int	 fz_order, int idx, u32 tb_id, u32 fn_key);
-int32 rtl_ip_vs_conn_expire_check(struct ip_vs_conn *cp);
-int32 rtl_ip_vs_conn_expire_check_delete(struct ip_vs_conn *cp);
-int32 rtl_tcp_state_transition_check(struct ip_vs_conn *cp, int direction, const struct sk_buff *skb, struct ip_vs_protocol *pp);
-int32 rtl_udp_state_transition_check(struct ip_vs_conn *cp, int direction, const struct sk_buff *skb, struct ip_vs_protocol *pp);
-#endif
-
+int32 rtl865x_handle_nat(struct nf_conn *ct, int act, struct sk_buff *skb);
+int32 rtl_update_ip_tables(char *name,  unsigned long event, struct in_ifaddr *ina);
+int32 rtl_fn_insert(struct fib_table *tb, struct fib_config *cfg, struct fib_info *fi);
+int32 rtl_fn_delete(struct fib_table *tb, struct fib_config *cfg);
+int32 rtl_fn_flush(int	 fz_order, int idx, u32 tb_id, u32 fn_key);
+int32 rtl_ip_vs_conn_expire_check(struct ip_vs_conn *cp);
+int32 rtl_ip_vs_conn_expire_check_delete(struct ip_vs_conn *cp);
+int32 rtl_tcp_state_transition_check(struct ip_vs_conn *cp, int direction, const struct sk_buff *skb, struct ip_vs_protocol *pp);
+int32 rtl_udp_state_transition_check(struct ip_vs_conn *cp, int direction, const struct sk_buff *skb, struct ip_vs_protocol *pp);
+#endif
+
 #if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
 extern int	rtl_newGC_session_status_flags;
 extern unsigned long rtl_newGC_session_status_time;
-
+
 #if (HZ==100)
 #define	RTL_FP_SESSION_LEVEL3_INTERVAL		(1)
-#define	RTL_FP_SESSION_LEVEL1_INTERVAL		(200)	/* 2 second */
+#define	RTL_FP_SESSION_LEVEL1_INTERVAL		(200)	/* 2 second */
 #elif (HZ==1000)
 #define	RTL_FP_SESSION_LEVEL3_INTERVAL		(10)
-#define	RTL_FP_SESSION_LEVEL1_INTERVAL		(2000)	/* 2 second */
+#define	RTL_FP_SESSION_LEVEL1_INTERVAL		(2000)	/* 2 second */
 #else
 #error "Please adjust the parameter according to the HZ"
 #endif
 
-#if defined(CONFIG_RTL_8198)
-#define	RTL_FP_SESSION_LEVEL3_ALLOW_COUNT	(40)
-#else
-#define	RTL_FP_SESSION_LEVEL3_ALLOW_COUNT	(16)	
-#endif
+#if defined(CONFIG_RTL_8198)
+#define	RTL_FP_SESSION_LEVEL3_ALLOW_COUNT	(40)
+#else
+#define	RTL_FP_SESSION_LEVEL3_ALLOW_COUNT	(16)
+#endif
 #define	RTL_FP_SESSION_LEVEL1_RX_WEIGHT		(8)
 
 #define	RTL_FP_SESSION_LEVEL_IDLE				0
@@ -182,6 +185,29 @@ extern unsigned long rtl_newGC_session_status_time;
 #define	RTL_FP_SESSION_LEVEL3					3
 //void rtl_fp_mark_invalid(struct nf_conn *ct);
 //enum LR_RESULT rtk_refreshOSConnectionTimer(void);
+
+#if 1 //defined(CONFIG_RTL_GC_INDEPENDENCE_ON_KERNEL)
+int rtl_gc_threshold_check(struct net* net);
+void rtl_list_del(struct nf_conn* ct);
+void rtl_hlist_nulls_del_rcu(struct nf_conn* ct, enum ip_conntrack_dir dir);
+void rtl_list_add_tail(struct nf_conn* ct, int proto, int flag);
+int rtl_test_bit(struct nf_conn* ct, int num);
+int rtl_del_ct_timer(struct nf_conn *ct);
+void rtl_add_ct_timer(struct nf_conn *ct);
+void rtl_list_move_tail(struct nf_conn *ct, int proto, int state);
+unsigned long rtl_get_ct_timer_expires(struct nf_conn* ct);
+void rtl_nf_ct_stat_inc(struct net* net);
+int rtl_skb_network_offset(struct sk_buff *skb);
+u_int8_t rtl_new_gc_get_ct_protonum(void *ct_ptr, enum ip_conntrack_dir dir);
+struct iphdr *rtl_new_gc_ip_hdr(struct sk_buff *skb);
+__be16 rtl_new_gc_get_skb_protocol(struct sk_buff *skb);
+unsigned long rtl_new_gc_get_ct_udp_status(void *ct_ptr);
+u_int8_t rtl_new_gc_get_ct_tcp_state(void *ct_ptr);
+void rtl_new_gc_set_ct_timeout_expires(void *ct_ptr, unsigned long value);
+__be32 rtl_new_gc_get_ct_ip_by_dir(void *ct_ptr, enum ip_conntrack_dir dir, int flag);
+__be16 rtl_new_gc_get_ct_port_by_dir(void *ct_ptr, enum ip_conntrack_dir dir, int flag);
 #endif
-
-#endif	/*	RTL_FEATURES_H	*/
+
+#endif
+
+#endif	/*	RTL_FEATURES_H	*/
diff --git a/include/net/rtl/features/rtl_ps_hooks.h b/include/net/rtl/features/rtl_ps_hooks.h
index 6af1b86..11b78c4 100644
--- a/include/net/rtl/features/rtl_ps_hooks.h
+++ b/include/net/rtl/features/rtl_ps_hooks.h
@@ -3,6 +3,7 @@
 
 #include <linux/netfilter_ipv4.h>
 #include <linux/netfilter/nf_conntrack_common.h>
+
 #include <linux/netfilter/nf_conntrack_tcp.h>
 
 #include <net/rtl/rtl_types.h>
@@ -60,8 +61,10 @@ int32 rtl_netif_receive_skb_hooks(struct sk_buff **pskb);
 int32 rtl_br_dev_queue_push_xmit_before_xmit_hooks(struct sk_buff *skb);
 
 #ifdef CONFIG_NET_SCHED
+
 extern int gQosEnabled; 
 #endif
+
 int32 rtl_neigh_forced_gc_hooks(struct neigh_table *tbl, struct neighbour *n);
 int32 rtl_neigh_flush_dev_hooks(struct neigh_table *tbl, struct net_device *dev, struct neighbour *n);
 int32 rtl_neigh_destroy_hooks(struct neighbour *n);
@@ -79,6 +82,7 @@ int32 rtl_neigh_init_hooks(void);
 int32 rtl___br_fdb_get_timeout_hooks(struct net_bridge *br, struct net_bridge_fdb_entry *fdb, const unsigned char *addr);
 #endif
 int32 rtl_translate_table_hooks(const char *name,
+
 		unsigned int valid_hooks,
 		struct xt_table_info *newinfo,
 		void *entry0,
@@ -134,11 +138,17 @@ int32 __drop_one_conntrack_process_hooks2(struct nf_conn* ct, int dropPrioIdx, i
 int32 rtl_nf_conn_GC_init_hooks(void);
 #endif
 
+
 #if defined(CONFIG_BRIDGE)
+int32 rtl_fdb_create_hooks(struct net_bridge_fdb_entry *fdb,const unsigned char *addr);
+int32 rtl865x_addAuthFDBEntry_hooks(const unsigned char *addr);
 int32 rtl_fdb_delete_hooks(struct net_bridge_fdb_entry *f);
-int32 rtl_br_fdb_cleanup_hooks(struct net_bridge *br, struct net_bridge_fdb_entry *f);
+int32 rtl_br_fdb_cleanup_hooks(struct net_bridge *br, struct net_bridge_fdb_entry *f, unsigned long delay);
+
 #endif
 
+
 #endif
 
 
+
diff --git a/include/net/rtl/rtk_vlan.h b/include/net/rtl/rtk_vlan.h
index 71764b6..23305d6 100644
--- a/include/net/rtl/rtk_vlan.h
+++ b/include/net/rtl/rtk_vlan.h
@@ -1,38 +1,56 @@
-/*
- *      Headler file of Realtek VLAN
- *
- *      $Id: rtk_vlan.h,v 1.3 2009/06/01 07:00:27 davidhsu Exp $
- */
-
-#ifndef _RTK_VLAN_H
-#define _RTK_VLAN_H
-#include "rtl_types.h"
-
-struct vlan_info {
-	int global_vlan;	// 0/1 - global vlan disable/enable
-	int is_lan;				// 1: eth-lan/wlan port, 0: wan port	
-	int vlan;					// 0/1: disable/enable vlan
-	int tag;					// 0/1: disable/enable tagging
-	int id;						// 1~4090: vlan id
-	int pri;						// 0~7: priority;
-	int cfi;						// 0/1: cfi
-};
-
-struct _vlan_tag {
-	unsigned short tpid;	// protocol id
-	unsigned short pci;	// priority:3, cfi:1, id:12
-};
-
-struct vlan_tag {
-	union
-	{	
-		unsigned long v;
-		struct _vlan_tag f;
-	};	
-};
-
-#if defined(CONFIG_RTL_HW_STP)
-uint32 rtl865x_getVlanPortMask(uint32 vid); 
-#endif
-
-#endif // _RTK_VLAN_H
+/*
+ *      Headler file of Realtek VLAN
+ *
+ *      $Id: rtk_vlan.h,v 1.3 2009/06/01 07:00:27 davidhsu Exp $
+ */
+
+#ifndef _RTK_VLAN_H
+#define _RTK_VLAN_H
+#include "rtl_types.h"
+
+struct vlan_info {
+	int global_vlan;	// 0/1 - global vlan disable/enable
+	int is_lan;				// 1: eth-lan/wlan port, 0: wan port
+	int vlan;					// 0/1: disable/enable vlan
+	int tag;					// 0/1: disable/enable tagging
+	int id;						// 1~4090: vlan id
+	int pri;						// 0~7: priority;
+	int cfi;						// 0/1: cfi
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+	int forwarding_rule;				// 0:disabled/1: bridge/2:NAT
+	int index;
+#endif
+};
+
+struct _vlan_tag {
+	unsigned short tpid;	// protocol id
+	unsigned short pci;	// priority:3, cfi:1, id:12
+};
+
+struct vlan_tag {
+	union
+	{
+		unsigned long v;
+		struct _vlan_tag f;
+	};
+};
+
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+extern struct vlan_info management_vlan;
+extern unsigned char lan_macaddr[6];
+struct vlan_info_item {
+	struct vlan_info info;
+	struct net_device *dev;
+};
+struct net_device *rtl_get_wan_from_vlan_info(void);
+int rtl_add_vlan_info(struct vlan_info *info, struct net_device *dev);
+struct vlan_info_item *rtl_get_vlan_info_item_by_dev(struct net_device *dev);
+
+#endif
+
+
+#if defined(CONFIG_RTL_HW_STP)
+uint32 rtl865x_getVlanPortMask(uint32 vid);
+#endif
+
+#endif // _RTK_VLAN_H
diff --git a/include/net/rtl/rtl865x_fdb_api.h b/include/net/rtl/rtl865x_fdb_api.h
index b2fb239..edbab8c 100644
--- a/include/net/rtl/rtl865x_fdb_api.h
+++ b/include/net/rtl/rtl865x_fdb_api.h
@@ -10,17 +10,62 @@
 #endif
 
 #define FDB_STATIC						0x01		/* flag for FDB: process static entry only */
-#define FDB_DYNAMIC					0x02		/* flag for FDB: process dynamic entry only */
+#define FDB_DYNAMIC						0x02		/* flag for FDB: process dynamic entry only */
+
+#define RTL865x_FDB_NUMBER				4
+#define RTL865x_L2_TYPEI			0x0001		/* Referenced by ARP/PPPoE */
+#define RTL865x_L2_TYPEII			0x0002		/* Referenced by Protocol */
+#define RTL865x_L2_TYPEIII			0x0004		/* Referenced by PCI/Extension Port */
+#define CONFIG_RTL865X_SYNC_L2			1
+#define RTL865X_FDBENTRY_TIMEOUT		0x1001		/*fdb entry time out*/
+#define RTL865X_FDBENTRY_450SEC		0x1002		/*fdb entry 450s timing*/
+#define RTL865X_FDBENTRY_300SEC		0x1004		/*fdb entry 300s timing*/
+#define RTL865X_FDBENTRY_150SEC		0x1008		/*fdb entry 150s timing*/
+
+/*#define ETHER_ADDR_LEN				6
+typedef struct ether_addr_s {
+	uint8 octet[ETHER_ADDR_LEN];
+} ether_addr_t;*/
+/*
+typedef struct rtl865x_tblAsicDrv_l2Param_s {
+	ether_addr_t	macAddr;
+	uint32 		memberPortMask; //extension ports [rtl8651_totalExtPortNum-1:0] are located at bits [RTL8651_PORT_NUMBER+rtl8651_totalExtPortNum-1:RTL8651_PORT_NUMBER]
+	uint32 		ageSec;
+	uint32	 	cpu:1,
+				srcBlk:1,
+				isStatic:1,				
+				nhFlag:1,
+				fid:2,
+				auth:1;
+
+} rtl865x_tblAsicDrv_l2Param_t;*/
+
+//extern typedef struct rtl865x_tblAsicDrv_l2Param_s	rtl865x_tblAsicDrv_l2Param_t;
+
+
 
 void update_hw_l2table(const char *srcName,const unsigned char *addr);
 int32 rtl_get_hw_fdb_age(uint32 fid,ether_addr_t *mac, uint32 flags);
-int32 rtl865x_addAuthFDBEntry(const unsigned char *addr, int32 auth, int32  port);
+int32 rtl865x_addAuthFDBEntry(const unsigned char *addr, int32 auth, int32  port, int32 srcblk);
 int32 rtl865x_setRestrictPortNum(int32 port, uint8 isEnable, int32 number);
 int32 rtl865x_check_authfdbentry_Byport(int32 port_num, const unsigned char  *macAddr);
 int32 rtl865x_enableLanPortNumRestrict(uint8 isEnable);
+int32 rtl865x_delAuthLanFDBEntry(uint16 l2Type,  const unsigned char *addr);
+int32 rtl865x_delLanFDBEntry(uint16 l2Type,  const unsigned char *addr);
+
+int32 rtl865x_arrangeFdbEntry(const unsigned char *timeout_addr, int32 *port);
+//extern int32 rtl865x_Lookup_fdb_entry(uint32 fid, ether_addr_t *mac, uint32 flags, uint32 *col_num, rtl865x_tblAsicDrv_l2Param_t *L2buff);
+
+int32 rtl865x_getPortNum(const unsigned char *addr);
+int32 rtl865x_ConvertPortMasktoPortNum(int32 portmask);
+int32 rtl865x_addFDBEntry(const unsigned char *addr);
+
 
 #if defined(CONFIG_RTL865X_LANPORT_RESTRICTION)
 #define	LAN_RESTRICT_PORT_NUMBER		9
+#define RTL_LAN_RESTRICT_STAT2	2
+#define RTL_LAN_RESTRICT_STAT1	1
+#define RTL_LAN_RESTRICT_STAT0	0
 
 typedef struct _lan_restrict_info
 {
@@ -32,6 +77,17 @@ typedef struct _lan_restrict_info
 
 extern lan_restrict_info	lan_restrict_tbl[LAN_RESTRICT_PORT_NUMBER];
 
+
+//int32 rtl865x_addAuthFDBEntry_hooks(struct net_bridge_fdb_entry *fdb,const unsigned char *addr);
+
+
+int32 lan_restrict_getBlockAddr(int32 port , const unsigned char *swap_addr);
+int32 lan_restrict_CheckStatusByport(int32 port);
+
+
+
+
+
 int32 rtl_check_fdb_entry_check_exist(uint32 fid, ether_addr_t *mac, uint32 flags);
 int32 rtl_check_fdb_entry_check_srcBlock(uint32 fid, ether_addr_t *mac, int32 *SrcBlk);
 int32 lanrestrict_callbackFn_for_add_fdb(void *param);
diff --git a/include/net/rtl/rtl865x_multicast.h b/include/net/rtl/rtl865x_multicast.h
index 2b55ad5..3552c34 100644
--- a/include/net/rtl/rtl865x_multicast.h
+++ b/include/net/rtl/rtl865x_multicast.h
@@ -1,41 +1,41 @@
-#ifndef RTL865X_MULTICAST_H
-#define RTL865X_MULTICAST_H
-
-#define RTL865X_NETWORK_INTERFACE_DATA_STRUCTURE
-
-#define RTL865X_MULTICAST_TABLE_AGE				35
-#define RTL865X_MULTICAST_TABLE_ASIC_FULL_AGE	35
-#define RTL865X_MULTICAST_TABLE_ASIC_AGE			10	/* we would always write this value into ASIC */
-#define RTL865X_MULTICAST_SWAP_THRESHOLD		400
-#define SINGLE_BITMASK_ISSET(x) ((x & (x - 1)) == 0)	/* chenyl: only 1 bit is set in vlanMask */
-
-
-/*================================================
-  * Multicast Data Structure
-  *================================================*/
-#define TBLDRV_MULTICAST_DATA_STRUCTURE
-
-/* mcast entry flag */
-#define 	RTL865X_MULTICAST_PPPOEPATCH_CPUBIT		0x01
-#define 	RTL865X_MULTICAST_EXTIP_SET				0x02
-#define 	RTL865X_MULTICAST_UPLOADONLY				0x04
-
-#define 	MAX_MCAST_FWD_DESCRIPTOR_CNT			256
-#define	MAX_MCAST_TABLE_ENTRY_CNT				128
-
+#ifndef RTL865X_MULTICAST_H
+#define RTL865X_MULTICAST_H
+
+#define RTL865X_NETWORK_INTERFACE_DATA_STRUCTURE
+
+#define RTL865X_MULTICAST_TABLE_AGE				35
+#define RTL865X_MULTICAST_TABLE_ASIC_FULL_AGE	35
+#define RTL865X_MULTICAST_TABLE_ASIC_AGE			10	/* we would always write this value into ASIC */
+#define RTL865X_MULTICAST_SWAP_THRESHOLD		400
+#define SINGLE_BITMASK_ISSET(x) ((x & (x - 1)) == 0)	/* chenyl: only 1 bit is set in vlanMask */
+
+
+/*================================================
+  * Multicast Data Structure
+  *================================================*/
+#define TBLDRV_MULTICAST_DATA_STRUCTURE
+
+/* mcast entry flag */
+#define 	RTL865X_MULTICAST_PPPOEPATCH_CPUBIT		0x01
+#define 	RTL865X_MULTICAST_EXTIP_SET				0x02
+#define 	RTL865X_MULTICAST_UPLOADONLY				0x04
+
+#define 	MAX_MCAST_FWD_DESCRIPTOR_CNT			256
+#define	MAX_MCAST_TABLE_ENTRY_CNT				128
+
 
 /*
  * List definitions.
  */
-#define MC_LIST_HEAD(name, type)						\
+#define MC_LIST_HEAD(name, type)						\
 struct name {								\
 	struct type *lh_first;	/* first element */			\
 }
 
-#define MC_LIST_HEAD_INITIALIZER(head)					\
+#define MC_LIST_HEAD_INITIALIZER(head)					\
 	{ NULL }
 
-#define MC_LIST_ENTRY(type)						\
+#define MC_LIST_ENTRY(type)						\
 struct {								\
 	struct type *le_next;	/* next element */			\
 	struct type **le_prev;	/* address of previous next element */	\
@@ -45,18 +45,18 @@ struct {								\
  * List functions.
  */
 
-#define MC_LIST_EMPTY(head) ((head)->lh_first == NULL)
+#define MC_LIST_EMPTY(head) ((head)->lh_first == NULL)
 
-#define MC_LIST_FIRST(head)	((head)->lh_first)
+#define MC_LIST_FIRST(head)	((head)->lh_first)
 
-#define MC_LIST_FOREACH(var, head, field)					\
+#define MC_LIST_FOREACH(var, head, field)					\
 	for((var) = (head)->lh_first; (var); (var) = (var)->field.le_next)
 
-#define MC_LIST_INIT(head) do {						\
+#define MC_LIST_INIT(head) do {						\
 	(head)->lh_first = NULL;					\
 } while (0)
 
-#define MC_LIST_INSERT_AFTER(listelm, elm, field) do {			\
+#define MC_LIST_INSERT_AFTER(listelm, elm, field) do {			\
 	if (((elm)->field.le_next = (listelm)->field.le_next) != NULL)	\
 		(listelm)->field.le_next->field.le_prev =		\
 		    &(elm)->field.le_next;				\
@@ -64,32 +64,32 @@ struct {								\
 	(elm)->field.le_prev = &(listelm)->field.le_next;		\
 } while (0)
 
-#define MC_LIST_INSERT_BEFORE(listelm, elm, field) do {			\
+#define MC_LIST_INSERT_BEFORE(listelm, elm, field) do {			\
 	(elm)->field.le_prev = (listelm)->field.le_prev;		\
 	(elm)->field.le_next = (listelm);				\
 	*(listelm)->field.le_prev = (elm);				\
 	(listelm)->field.le_prev = &(elm)->field.le_next;		\
 } while (0)
 
-#define MC_LIST_INSERT_HEAD(head, elm, field) do {				\
+#define MC_LIST_INSERT_HEAD(head, elm, field) do {				\
 	if (((elm)->field.le_next = (head)->lh_first) != NULL)		\
 		(head)->lh_first->field.le_prev = &(elm)->field.le_next;\
 	(head)->lh_first = (elm);					\
 	(elm)->field.le_prev = &(head)->lh_first;			\
 } while (0)
 
-#define MC_LIST_NEXT(elm, field)	((elm)->field.le_next)
+#define MC_LIST_NEXT(elm, field)	((elm)->field.le_next)
 
-#define MC_LIST_REMOVE(elm, field) do {					\
+#define MC_LIST_REMOVE(elm, field) do {					\
 	if ((elm)->field.le_next != NULL)				\
 		(elm)->field.le_next->field.le_prev = 			\
-		    (elm)->field.le_prev;				\
-	if ((elm)->field.le_prev != NULL)	\
-		*(elm)->field.le_prev = (elm)->field.le_next;			\
+		    (elm)->field.le_prev;				\
+	if ((elm)->field.le_prev != NULL)	\
+		*(elm)->field.le_prev = (elm)->field.le_next;			\
 } while (0)
-
-
-
+
+
+
 
 /*
  * Counting Tail queue definitions.
@@ -186,22 +186,22 @@ struct {								\
 	*(elm)->field.tqe_prev = (elm)->field.tqe_next;			\
 	(head)->tqh_count--;\
 } while (0)
-
-#define ETHERNET_DEVICE_TYPE 0
-#define WIRELESS_DEVICE_TYPE 1
-#define VIRTUAL_DEVICE_TYPE  2
-typedef struct rtl865x_mcast_fwd_descriptor_s{
-	char netifName[16];
-	unsigned int descPortMask;
-	char toCpu;
-	unsigned int vid;
-	unsigned int fwdPortMask;
-	MC_LIST_ENTRY(rtl865x_mcast_fwd_descriptor_s)	next;
-	
-}rtl865x_mcast_fwd_descriptor_t;
-
-typedef MC_LIST_HEAD(mcast_fwd_descriptor_head_s, rtl865x_mcast_fwd_descriptor_s)  mcast_fwd_descriptor_head_t;
-
+
+#define ETHERNET_DEVICE_TYPE 0
+#define WIRELESS_DEVICE_TYPE 1
+#define VIRTUAL_DEVICE_TYPE  2
+typedef struct rtl865x_mcast_fwd_descriptor_s{
+	char netifName[16];
+	unsigned int descPortMask;
+	char toCpu;
+	unsigned int vid;
+	unsigned int fwdPortMask;
+	MC_LIST_ENTRY(rtl865x_mcast_fwd_descriptor_s)	next;
+	
+}rtl865x_mcast_fwd_descriptor_t;
+
+typedef MC_LIST_HEAD(mcast_fwd_descriptor_head_s, rtl865x_mcast_fwd_descriptor_s)  mcast_fwd_descriptor_head_t;
+
 /*
  * Tail queue definitions.
  */
@@ -290,71 +290,71 @@ struct {								\
 		(head)->tqh_last = (elm)->field.tqe_prev;		\
 	*(elm)->field.tqe_prev = (elm)->field.tqe_next;			\
 } while (0)
-
-typedef struct rtl865x_tblDrv_mCast_s {
-	unsigned int	sip;
-	unsigned int	dip;
-	unsigned short	svid;
-	unsigned short 	port;
-	unsigned int	mbr;
-	unsigned short	age;
-	unsigned short	cpu;
-	unsigned int extIp;
-	/*above field is for asic table usage*/
-	mcast_fwd_descriptor_head_t fwdDescChain;
-	unsigned int	count;
-	unsigned int	maxPPS;
-	unsigned char	cpuHold;
-	unsigned char	flag;
-	unsigned char	inAsic;	
-	unsigned char	unKnownMCast;
-#if  defined(CONFIG_RTL8196C_REVISION_B) || defined (CONFIG_RTL8198_REVISION_B) 
-	unsigned short liveTime;
-#endif 
-	TAILQ_ENTRY(rtl865x_tblDrv_mCast_s) nextMCast;
-	
-} rtl865x_tblDrv_mCast_t;
-
-struct rtl865x_multicastTable{
-	
-	struct freeList_s {
-		
-		TAILQ_HEAD( _FreeMultiCastEntry, rtl865x_tblDrv_mCast_s) freeMultiCast;
-	} freeList;
-
-	struct inuseList_s {
-		TAILQ_HEAD( _InuseMCast, rtl865x_tblDrv_mCast_s) *mCastTbl;
-	}inuseList;
-
-};
-
-typedef struct rtl865x_mCastConfig_s{
-	unsigned int externalPortMask;
-	
-}rtl865x_mCastConfig_t;
-
-int rtl865x_initMulticast(rtl865x_mCastConfig_t * mCastConfig);
-int rtl865x_reinitMulticast(void);	
-
-int rtl865x_addMulticastExternalPort(unsigned int extPort);
-int rtl865x_delMulticastExternalPort(unsigned int extPort);
-
-int rtl865x_setMulticastExternalPortMask(unsigned int extPortMask);
-int rtl865x_getMulticastExternalPortMask(void);
-
-int rtl865x_addMulticastExternalPortMask(unsigned int extPortMask);
-int rtl865x_delMulticastExternalPortMask(unsigned int extPortMask);
-
-rtl865x_tblDrv_mCast_t *rtl865x_findMCastEntry(unsigned int mAddr, unsigned int sip, unsigned short svid, unsigned short sport);
-
-int rtl865x_addMulticastEntry(unsigned int mAddr, unsigned int sip, unsigned short svid, unsigned short sport, 
-									rtl865x_mcast_fwd_descriptor_t * newFwdDescChain, 
-									int flushOldChain, unsigned int extIp, char cpuHold, unsigned char flag);
-
-int rtl865x_delMulticastEntry(unsigned int mcast_addr);
-
-int rtl865x_genVirtualMCastFwdDescriptor(unsigned int forceToCpu, unsigned int  fwdPortMask, rtl865x_mcast_fwd_descriptor_t *fwdDescriptor);
-int rtl865x_blockMulticastFlow(unsigned int srcVlanId, unsigned int srcPort,unsigned int srcIpAddr, unsigned int destIpAddr);
-
-#endif
-
+
+typedef struct rtl865x_tblDrv_mCast_s {
+	unsigned int	sip;
+	unsigned int	dip;
+	unsigned short	svid;
+	unsigned short 	port;
+	unsigned int	mbr;
+	unsigned short	age;
+	unsigned short	cpu;
+	unsigned int extIp;
+	/*above field is for asic table usage*/
+	mcast_fwd_descriptor_head_t fwdDescChain;
+	unsigned int	count;
+	unsigned int	maxPPS;
+	unsigned char	cpuHold;
+	unsigned char	flag;
+	unsigned char	inAsic;	
+	unsigned char	unKnownMCast;
+#if  defined(CONFIG_RTL8196C_REVISION_B) || defined (CONFIG_RTL8198_REVISION_B) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+	unsigned short liveTime;
+#endif 
+	TAILQ_ENTRY(rtl865x_tblDrv_mCast_s) nextMCast;
+	
+} rtl865x_tblDrv_mCast_t;
+
+struct rtl865x_multicastTable{
+	
+	struct freeList_s {
+		
+		TAILQ_HEAD( _FreeMultiCastEntry, rtl865x_tblDrv_mCast_s) freeMultiCast;
+	} freeList;
+
+	struct inuseList_s {
+		TAILQ_HEAD( _InuseMCast, rtl865x_tblDrv_mCast_s) *mCastTbl;
+	}inuseList;
+
+};
+
+typedef struct rtl865x_mCastConfig_s{
+	unsigned int externalPortMask;
+	
+}rtl865x_mCastConfig_t;
+
+int rtl865x_initMulticast(rtl865x_mCastConfig_t * mCastConfig);
+int rtl865x_reinitMulticast(void);	
+
+int rtl865x_addMulticastExternalPort(unsigned int extPort);
+int rtl865x_delMulticastExternalPort(unsigned int extPort);
+
+int rtl865x_setMulticastExternalPortMask(unsigned int extPortMask);
+int rtl865x_getMulticastExternalPortMask(void);
+
+int rtl865x_addMulticastExternalPortMask(unsigned int extPortMask);
+int rtl865x_delMulticastExternalPortMask(unsigned int extPortMask);
+
+rtl865x_tblDrv_mCast_t *rtl865x_findMCastEntry(unsigned int mAddr, unsigned int sip, unsigned short svid, unsigned short sport);
+
+int rtl865x_addMulticastEntry(unsigned int mAddr, unsigned int sip, unsigned short svid, unsigned short sport, 
+									rtl865x_mcast_fwd_descriptor_t * newFwdDescChain, 
+									int flushOldChain, unsigned int extIp, char cpuHold, unsigned char flag);
+
+int rtl865x_delMulticastEntry(unsigned int mcast_addr);
+
+int rtl865x_genVirtualMCastFwdDescriptor(unsigned int forceToCpu, unsigned int  fwdPortMask, rtl865x_mcast_fwd_descriptor_t *fwdDescriptor);
+int rtl865x_blockMulticastFlow(unsigned int srcVlanId, unsigned int srcPort,unsigned int srcIpAddr, unsigned int destIpAddr);
+
+#endif
+
diff --git a/include/net/rtl/rtl865x_netif.h b/include/net/rtl/rtl865x_netif.h
index e2c0c95..67da825 100644
--- a/include/net/rtl/rtl865x_netif.h
+++ b/include/net/rtl/rtl865x_netif.h
@@ -1,10 +1,10 @@
 /*
-* Copyright c                  Realtek Semiconductor Corporation, 2008  
+* Copyright c                  Realtek Semiconductor Corporation, 2008
 * All rights reserved.
-* 
+*
 * Program : network interface driver header file
-* Abstract : 
-* Author : hyking (hyking_liu@realsil.com.cn)  
+* Abstract :
+* Author : hyking (hyking_liu@realsil.com.cn)
 */
 
 #ifndef RTL865X_NETIF_H
@@ -28,7 +28,7 @@
 #if 1 //def CONFIG_RTL_LAYERED_DRIVER_ACL
 typedef struct _rtl865x_AclRule_s
 {
-	union 
+	union
 	{
 		/* MAC ACL rule */
 		struct {
@@ -36,7 +36,7 @@ typedef struct _rtl865x_AclRule_s
 			ether_addr_t _srcMac, _srcMacMask;
 			uint16 _typeLen, _typeLenMask;
 		} MAC;
-		
+
 		/* IP Group ACL rule */
 		struct
 		{
@@ -50,31 +50,31 @@ typedef struct _rtl865x_AclRule_s
 				{
 					uint8 _proto, _protoMask, _flagMask;// flag & flagMask only last 3-bit is meaning ful
 					uint32 _FOP:1, _FOM:1, _httpFilter:1, _httpFilterM:1, _identSrcDstIp:1, _identSrcDstIpM:1;
-					union 
+					union
 					{
 						uint8 _flag;
-						struct 
+						struct
 						{
 							uint8 pend1:5,
 								 pend2:1,
 								 _DF:1,	//don't fragment flag
 								 _MF:1;	//more fragments flag
 						} s;
-					} un;							
-				} ip; 
-				
+					} un;
+				} ip;
+
 				/* ICMP ACL rule */
-				struct 
+				struct
 				{
 					uint8 _type, _typeMask, _code, _codeMask;
-				} icmp; 
-				
+				} icmp;
+
 				/* IGMP ACL rule */
 				struct
 				{
 					uint8 _type, _typeMask;
-				} igmp; 
-				
+				} igmp;
+
 				/* TCP ACL rule */
 				struct
 				{
@@ -94,20 +94,20 @@ typedef struct _rtl865x_AclRule_s
 								  _syn:1, //sync bit
 								  _fin:1; //fin bit
 						}s;
-					}un;					
+					}un;
 				}tcp;
-				
+
 				/* UDP ACL rule */
-				struct 
+				struct
 				{
 					uint16 _srcPortUpperBound, _srcPortLowerBound;
-					uint16 _dstPortUpperBound, _dstPortLowerBound;										
-				}udp; 
-			}is;			
-		}L3L4; 
+					uint16 _dstPortUpperBound, _dstPortLowerBound;
+				}udp;
+			}is;
+		}L3L4;
 
 		/* Source filter ACL rule */
-		struct 
+		struct
 		{
 			ether_addr_t _srcMac, _srcMacMask;
 			uint16 _srcPort, _srcPortMask;
@@ -117,9 +117,9 @@ typedef struct _rtl865x_AclRule_s
 			uint32 _ignoreL4:1, //L2 rule
 				  	 _ignoreL3L4:1; //L3 rule
 		} SRCFILTER;
-		
+
 		/* Destination filter ACL rule */
-		struct 
+		struct
 		{
 			ether_addr_t _dstMac, _dstMacMask;
 			uint16 _vlanIdx, _vlanIdxMask;
@@ -135,7 +135,7 @@ typedef struct _rtl865x_AclRule_s
 #endif
 	}un_ty;
 
-	
+
 	uint32	ruleType_:5,
 			actionType_:4,
 			pktOpApp_:3,
@@ -145,17 +145,17 @@ typedef struct _rtl865x_AclRule_s
 			upDown_:1,//0: uplink acl rule for hw qos; 1: downlink acl rule for hw qos
 #endif
 			nexthopIdx_:5, /* Index of nexthop table (NOT L2 table) */	/* used as network interface index for 865xC qos system */
-			ratelimtIdx_:4; /* Index of rate limit table */	/* used as outputQueue index for 865xC qos system */		
+			ratelimtIdx_:4; /* Index of rate limit table */	/* used as outputQueue index for 865xC qos system */
+
 
-	
 	uint32	netifIdx_:3, /*for redirect*/
 			pppoeIdx_:3, /*for redirect*/
 			L2Idx_:10, /* Index of L2 table */
 			inv_flag:8, /*mainly for iptables-->acl rule, when iptables rule has invert netif flag, this acl rule is added to other netifs*/
 			aclIdx:7;	/* aisc entry idx */
-	
+
 	struct _rtl865x_AclRule_s *pre,*next;
-	
+
 }rtl865x_AclRule_t;
 
 
@@ -203,7 +203,7 @@ typedef struct _rtl865x_AclRule_s
 
 /* ICMP ACL Rule Definition */
 #define icmpType_				un_ty.L3L4.is.icmp._type
-#define icmpTypeMask_			un_ty.L3L4.is.icmp._typeMask	
+#define icmpTypeMask_			un_ty.L3L4.is.icmp._typeMask
 #define icmpCode_				un_ty.L3L4.is.icmp._code
 #define icmpCodeMask_			un_ty.L3L4.is.icmp._codeMask
 
@@ -359,6 +359,11 @@ typedef struct _rtl865x_AclRule_s
 #define RTL_DRV_LAN_P4_NETIF_NAME RTL_DRV_WAN0_NETIF_NAME
 #define RTL_DRV_LAN_P5_NETIF_NAME "eth5"
 
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+#define RTL_DRV_LAN_P7_NETIF_NAME "eth7"
+#endif
+
+
 /************************************
 *	const variable defination
 *************************************/
@@ -372,7 +377,7 @@ typedef struct _rtl865x_AclRule_s
 	#define	RTL_LANPORT_MASK			0x1C1
 	#define	RTL8366RB_GMIIPORT		0x20
 	#define	RTL8366RB_LANPORT		0xCf
-	#define	RTL8366RB_WANPORT		0x10	
+	#define	RTL8366RB_WANPORT		0x10
 #elif defined(CONFIG_RTL_819X) && (defined(CONFIG_RTK_VLAN_SUPPORT) || defined (CONFIG_RTL_MULTI_LAN_DEV))
 #if defined (CONFIG_POCKET_ROUTER_SUPPORT)
 	#define	RTL_WANPORT_MASK		0x10
@@ -383,8 +388,8 @@ typedef struct _rtl865x_AclRule_s
 #elif defined(CONFIG_8198_PORT5_RGMII)
 	#define	RTL_WANPORT_MASK		0x10
 	#define	RTL_LANPORT_MASK			0x12f
-#else	
-        #if defined (CONFIG_RTL_8196C_iNIC)	
+#else
+        #if defined (CONFIG_RTL_8196C_iNIC)
 	#define	RTL_WANPORT_MASK		0x01
 	#define	RTL_LANPORT_MASK			0x110 //mark_inic , only port4 connect to MII
 	#elif defined (CONFIG_RTK_INBAND_HOST_HACK)
@@ -440,8 +445,8 @@ typedef struct _rtl865x_AclRule_s
 	#endif
 #endif	/*	defined(CONFIG_RTL8186_KB_N) || defined(CONFIG_RTL_819X)	*/
 
-#if defined(CONFIG_RTK_VLAN_SUPPORT) || defined (CONFIG_RTL_MULTI_LAN_DEV) 
-#if defined(CONFIG_8198_PORT5_GMII)
+#if defined(CONFIG_RTK_VLAN_SUPPORT) || defined (CONFIG_RTL_MULTI_LAN_DEV)
+#if defined(CONFIG_8198_PORT5_GMII) || defined(CONFIG_RTK_VLAN_NEW_FEATURE)
 	#define ETH_INTF_NUM	6
 #else
 	#define ETH_INTF_NUM	5
@@ -453,17 +458,17 @@ typedef struct _rtl865x_AclRule_s
 typedef struct rtl865x_netif_s
 {
 	uint16 	vid; /*netif->vid*/
-	uint16 	mtu; /*netif's MTU*/	
-	uint32 	if_type:5; /*interface type, 0:ether,1:pppoe....*/			
+	uint16 	mtu; /*netif's MTU*/
+	uint32 	if_type:5; /*interface type, 0:ether,1:pppoe....*/
 	ether_addr_t macAddr;
 	uint32	is_wan:1, /*wan interface?*/
 			dmz:1,	/*DMZ/routing lan*/
 			is_slave:1; /*is slave interface?*/
-	uint8	name[MAX_IFNAMESIZE];	
+	uint8	name[MAX_IFNAMESIZE];
 	uint16	enableRoute;
-#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+#if defined (CONFIG_RTL_LOCAL_PUBLIC) ||defined(CONFIG_RTL_MULTIPLE_WAN)
 	uint16	forMacBasedMCast;
-#endif		
+#endif
 }rtl865x_netif_t;
 
 /*internal...*/
@@ -493,6 +498,15 @@ int  rtl865x_del_pattern_acl_for_contentFilter(rtl865x_AclRule_t *rule,char *net
 int32 rtl865x_acl_test(int32 testNo);
 #endif
 
+
+//#define CONFIG_RTL_IPTABLES2ACL_PATCH 1
+#if defined(CONFIG_RTL_IPTABLES2ACL_PATCH)
+int32 rtl865x_add_sw_acl(rtl865x_AclRule_t *rule, char *netifName,int32 priority);
+int32 _rtl865x_synAclwithAsicTbl(void);
+int32 rtl865x_flush_allAcl_sw_fromChain(char *netifName, int32 priority, uint32 flag);
+#endif
+
+
 int32 rtl865x_deReferNetif(char *ifName);
 int32 rtl865x_referNetif(char *ifName);
 int32 rtl865x_setNetifMtu(rtl865x_netif_t *netif);
diff --git a/include/net/rtl/rtl_nic.h b/include/net/rtl/rtl_nic.h
index c911b7d..aedef94 100644
--- a/include/net/rtl/rtl_nic.h
+++ b/include/net/rtl/rtl_nic.h
@@ -16,7 +16,10 @@
 #define CONFIG_RTL_PHY_PATCH		1
 #define RTK_QUE			1
 #if defined(CONFIG_NET_WIRELESS_AGN) || defined (CONFIG_RTL8192SE) || defined(CONFIG_RTL8192CD) || defined(CONFIG_RTL8192CD_MODULE)
-#define BR_SHORTCUT	1
+#if !defined(CONFIG_RTL_FASTBRIDGE)
+#define BR_SHORTCUT         1
+#define BR_SHORTCUT_C2      1
+#endif
 #endif
 /*
 *#define	CONFIG_RTL_MULTI_LAN_DEV	1
@@ -106,7 +109,7 @@ struct dev_priv {
 	u32 			opened;
 	u32			irq_owner; //record which dev request IRQ
 	struct net_device_stats net_stats;
-#if defined(DYNAMIC_ADJUST_TASKLET) || defined(CONFIG_RTL8186_TR) || defined(BR_SHORTCUT) || defined(CONFIG_RTL8196C_REVISION_B) || defined(CONFIG_RTL_8198)
+#if defined(DYNAMIC_ADJUST_TASKLET) || defined(CONFIG_RTL8186_TR) || defined(BR_SHORTCUT) || defined(CONFIG_RTL8196C_REVISION_B) || defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
     struct timer_list expire_timer; 
 #endif
 
@@ -197,6 +200,11 @@ struct port_statistics  {
 //#define RTL_PS_WAN1_DEV_NAME RTL_DEV_NAME_NUM(RTL_PS_ETH_NAME,2)
 #endif
 
+#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+#define RTL_PS_BR1_DEV_NAME     "br1"
+#define RTL_PS_ETH_NAME_ETH2	"eth2"
+#endif
+
 #if defined(CONFIG_RTL_PUBLIC_SSID)
 #define RTL_LAN_DEVICE_NAME "br0"
 #define RTL_GW_WAN_DEVICE_NAME "br1"
@@ -254,7 +262,7 @@ typedef struct _ps_drv_netif_mapping_s
 int32 rtl865x_changeOpMode(int mode);
 
 #if defined(CONFIG_RTL_ETH_PRIV_SKB)
-__MIPS16 __IRAM_FWD int is_rtl865x_eth_priv_buf(unsigned char *head);
+__MIPS16 __IRAM_FWD  int is_rtl865x_eth_priv_buf(unsigned char *head);
 void free_rtl865x_eth_priv_buf(unsigned char *head);
 #endif
 
@@ -265,10 +273,14 @@ int rtl_del_ps_drv_netif_mapping(struct net_device *dev);
 #if defined(CONFIG_RTK_VLAN_SUPPORT) && defined(CONFIG_RTK_VLAN_FOR_CABLE_MODEM)
 extern struct net_device* get_dev_by_vid(int vid);
 #endif
-extern __MIPS16 struct net_device *get_shortcut_dev(unsigned char *da);
+extern __MIPS16  struct net_device *get_shortcut_dev(unsigned char *da);
 #define CONFIG_RTL_NIC_HWSTATS
 
 int32 rtl865x_changeOpMode(int mode);
 int  rtl865x_reChangeOpMode (void);
 
+#if defined(CONFIG_RTL_HW_VLAN_SUPPORT)
+extern int rtl_hw_vlan_ignore_tagged_mc;
+#endif
+
 #endif
diff --git a/include/net/rtl/rtl_types.h b/include/net/rtl/rtl_types.h
index cdd2943..c3e933a 100644
--- a/include/net/rtl/rtl_types.h
+++ b/include/net/rtl/rtl_types.h
@@ -243,9 +243,10 @@
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0))
 #include <linux/config.h>
 #endif
-#include <linux/ctype.h>
+//#include <linux/ctype.h>
 #include <linux/module.h>
-#include <linux/string.h>
+//#include <linux/string.h>
+
 #endif /*__KERNEL__*/
 #endif /*__linux__*/
 
@@ -361,8 +362,11 @@
 		print macro
     =============================================================================== */
 #if	defined(__linux__)&&defined(__KERNEL__)
-
+	#ifndef CONFIG_PRINTK
+	#define rtlglue_printf	panic_printk
+	#else
 	#define rtlglue_printf	printk
+	#endif
 
 #else	/* defined(__linux__)&&defined(__KERNEL__) */
 
@@ -547,12 +551,6 @@ typedef struct ether_addr_s {
 #define CACHED(addr)			((uint32)(addr) & ~(UNCACHE_MASK))
 #endif
 
-#if defined(CONFIG_RTL_PROC_DEBUG)
-#define RTL865X_DRIVER_DEBUG_FLAG /*flag for debug*/
-#else
-#undef RTL865X_DRIVER_DEBUG_FLAG /*flag for debug*/
-#endif
-
 /*	asic configuration	*/
 #define RTL8651_OUTPUTQUEUE_SIZE		6
 #define TOTAL_VLAN_PRIORITY_NUM	8
@@ -560,14 +558,97 @@ typedef struct ether_addr_s {
 
 #if defined(CONFIG_RTL_8196C)
 #define CONFIG_RTL8196C_ETH_IOT         1
-#ifdef CONFIG_RTL_WTDOG
+#ifdef CONFIG_MP_PSD_SUPPORT
+#undef CONFIG_RTL8196C_GREEN_ETHERNET
+#else
 #define CONFIG_RTL_8196C_ESD            1 
 #endif
 #endif
 
-#if defined(CONFIG_RTL_8198) && defined(CONFIG_RTL_WTDOG)
+#if defined(CONFIG_RTL_8198) && !defined(CONFIG_RTL_819XD)
 #define CONFIG_RTL_8198_ESD        1
 #endif 
 
+#if defined(CONFIG_RTL_8198)
+#define RTL8198_EEE_MAC 	1
+#endif
+
+#if defined(CONFIG_RTL_819XD) || defined(CONFIG_RTL_8196E)
+#define CONFIG_RTL_8197D_DYN_THR		1
+#endif
+
+#define DYN_THR_LINK_UP_PORTS			3
+
+/* IC default value */
+#define DYN_THR_DEF_fcON				0xac
+#define DYN_THR_DEF_fcOFF				0xa0
+#define DYN_THR_DEF_sharedON			0x62
+#define DYN_THR_DEF_sharedOFF			0x4a
+
+/* aggressive value */
+#define DYN_THR_AGG_fcON				0xd0
+#define DYN_THR_AGG_fcOFF				0xc0
+#define DYN_THR_AGG_sharedON			0xc0
+#define DYN_THR_AGG_sharedOFF			0xa8
+
+#if defined(CONFIG_RTL_LOG_DEBUG)
+extern int scrlog_printk(const char * fmt, ...);
+
+extern struct RTL_LOG_PRINT_MASK
+{
+	uint32 ERROR:1;
+	uint32 WARN:1;
+	uint32 INFO:1;
+}RTL_LogTypeMask;
+
+extern struct RTL_LOG_ERROR_MASK
+{
+	uint32 MEM:1;
+	uint32 SKB:1;
+}RTL_LogErrorMask;
+extern uint32 RTL_LogRatelimit;
+
+extern struct RTL_LOG_MODULE_MASK
+{
+	uint8 NIC:1;
+	uint8 WIRELESS:1;
+	uint8 PROSTACK:1;
+}RTL_LogModuleMask;
+
+
+#define LOG_LIMIT (!RTL_LogRatelimit||net_ratelimit())
+
+
+#define LOG_ERROR(fmt, args...) do{ \
+	if(RTL_LogTypeMask.ERROR&&LOG_LIMIT)scrlog_printk("ERROR:"fmt, ## args); \
+		}while(0)
+		
+#define LOG_MEM_ERROR(fmt, args...) do{ \
+	if(RTL_LogTypeMask.ERROR&&RTL_LogErrorMask.MEM&&LOG_LIMIT)scrlog_printk("ERROR:"fmt, ## args); \
+		}while(0)
+		
+#define LOG_SKB_ERROR(fmt, args...) do{ \
+		if(RTL_LogTypeMask.ERROR&&RTL_LogErrorMask.SKB&&LOG_LIMIT)scrlog_printk("ERROR:"fmt, ## args); \
+			}while(0)
+			
+#define LOG_WARN(fmt, args...) do{ \
+		if(RTL_LogTypeMask.WARN&&LOG_LIMIT)scrlog_printk("WARN:"fmt, ## args); \
+			}while(0)
+			
+#define LOG_INFO(fmt, args...) do{ \
+		if(RTL_LogTypeMask.INFO&&LOG_LIMIT)scrlog_printk("INFO:"fmt, ## args); \
+			}while(0)
+
+#else
+
+#define LOG_ERROR(fmt, args...) 
+#define LOG_MEM_ERROR(fmt, args...) 
+#define LOG_SKB_ERROR(fmt, args...)
+#define LOG_WARN(fmt, args...)
+#define LOG_INFO(fmt, args...)
+
+#endif 
+
 #endif 
 
+
diff --git a/kernel/fork.c b/kernel/fork.c
index f4be1ee..45fee3a 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -571,10 +571,10 @@ void mm_release(struct task_struct *tsk, struct mm_struct *mm)
 	if (tsk->clear_child_tid) {
 		if (!(tsk->flags & PF_SIGNALED) &&
 		    atomic_read(&mm->mm_users) > 1) {
-			/*
-			 * We don't check the error code - if userspace has
-			 * not set up a proper pointer then tough luck.
-			 */
+		/*
+		 * We don't check the error code - if userspace has
+		 * not set up a proper pointer then tough luck.
+		 */
 			put_user(0, tsk->clear_child_tid);
 			sys_futex(tsk->clear_child_tid, FUTEX_WAKE,
 					1, NULL, NULL, 0);
diff --git a/kernel/irq/handle.c b/kernel/irq/handle.c
index da77a15..024e97f 100644
--- a/kernel/irq/handle.c
+++ b/kernel/irq/handle.c
@@ -269,9 +269,9 @@ int __init early_irq_init(void)
 	return arch_early_irq_init();
 }
 
-#if defined(CONFIG_RTL_819X)
-__IRAM_GEN
-#endif
+ #if defined(CONFIG_RTL_819X)
+ __MIPS16 __IRAM_GEN
+ #endif
 struct irq_desc *irq_to_desc(unsigned int irq)
 {
 	return (irq < NR_IRQS) ? irq_desc + irq : NULL;
diff --git a/kernel/signal.c b/kernel/signal.c
index 2dfc931..0f0ef22 100644
--- a/kernel/signal.c
+++ b/kernel/signal.c
@@ -2414,9 +2414,9 @@ do_sigaltstack (const stack_t __user *uss, stack_t __user *uoss, unsigned long s
 	stack_t oss;
 	int error;
 
-	oss.ss_sp = (void __user *) current->sas_ss_sp;
-	oss.ss_size = current->sas_ss_size;
-	oss.ss_flags = sas_ss_flags(sp);
+		oss.ss_sp = (void __user *) current->sas_ss_sp;
+		oss.ss_size = current->sas_ss_size;
+		oss.ss_flags = sas_ss_flags(sp);
 
 	if (uss) {
 		void __user *ss_sp;
diff --git a/kernel/trace/ring_buffer.c b/kernel/trace/ring_buffer.c
index f99b792..ae0d95f 100644
--- a/kernel/trace/ring_buffer.c
+++ b/kernel/trace/ring_buffer.c
@@ -2285,7 +2285,7 @@ ring_buffer_consume(struct ring_buffer *buffer, int cpu, u64 *ts)
 
 	event = rb_buffer_peek(buffer, cpu, ts);
 	if (event)
-		rb_advance_reader(cpu_buffer);
+	rb_advance_reader(cpu_buffer);
 
 	spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);
 
diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c
index 3928aee..1919bd1 100644
--- a/kernel/trace/trace.c
+++ b/kernel/trace/trace.c
@@ -2994,7 +2994,7 @@ tracing_fill_pipe_page(size_t rem, struct trace_iterator *iter)
 		}
 
 		if (ret != TRACE_TYPE_NO_CONSUME)
-			trace_consume(iter);
+		trace_consume(iter);
 		rem -= count;
 		if (!find_next_entry_inc(iter))	{
 			rem = 0;
@@ -4127,7 +4127,7 @@ static void __ftrace_dump(bool disable_tracing)
 
 			ret = print_trace_line(&iter);
 			if (ret != TRACE_TYPE_NO_CONSUME)
-				trace_consume(&iter);
+			trace_consume(&iter);
 		}
 
 		trace_printk_seq(&iter.seq);
diff --git a/kernel/trace/trace_functions.c b/kernel/trace/trace_functions.c
index 01e5c43..c3a8a2e 100644
--- a/kernel/trace/trace_functions.c
+++ b/kernel/trace/trace_functions.c
@@ -195,9 +195,9 @@ static void tracing_stop_function_trace(void)
 	ftrace_function_enabled = 0;
 
 	if (func_flags.val & TRACE_FUNC_OPT_STACK)
-		unregister_ftrace_function(&trace_stack_ops);
+	unregister_ftrace_function(&trace_stack_ops);
 	else
-		unregister_ftrace_function(&trace_ops);
+	unregister_ftrace_function(&trace_ops);
 }
 
 static int func_set_flag(u32 old_flags, u32 bit, int set)
diff --git a/lib/decompress_unlzma.c b/lib/decompress_unlzma.c
index 135cd04..b2fd927 100644
--- a/lib/decompress_unlzma.c
+++ b/lib/decompress_unlzma.c
@@ -104,7 +104,7 @@ static inline void INIT rc_init(struct rc *rc,
 				       char *buffer, int buffer_size)
 {
 	if (fill)
-	rc->fill = fill;
+		rc->fill = fill;
 	else
 		rc->fill = nofill;
 	rc->buffer = (uint8_t *)buffer;
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index 8c826fd..1fd4ba1 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -878,7 +878,7 @@ static int rmqueue_bulk(struct zone *zone, unsigned int order,
 		 * properly.
 		 */
 		if (likely(cold == 0))
-			list_add(&page->lru, list);
+		list_add(&page->lru, list);
 		else
 			list_add_tail(&page->lru, list);
 		set_page_private(page, migratetype);
@@ -1450,7 +1450,7 @@ zonelist_scan:
 				goto this_zone_full;
 			default:
 				/* did we reclaim enough */
-				if (!zone_watermark_ok(zone, order, mark,
+			if (!zone_watermark_ok(zone, order, mark,
 						classzone_idx, alloc_flags))
 					goto this_zone_full;
 			}
diff --git a/net/bridge/Makefile b/net/bridge/Makefile
index 70ef935..e45cb9a 100644
--- a/net/bridge/Makefile
+++ b/net/bridge/Makefile
@@ -2,7 +2,7 @@
 # Makefile for the IEEE 802.1d ethernet bridging layer.
 #
 
-ifeq ($(CONFIG_MESH_ENABLE),y)
+ifeq ($(CONFIG_RTL_MESH_SUPPORT),y)
         EXTRA_CFLAGS += -DCONFIG_RTK_MESH
 endif
 
@@ -10,15 +10,18 @@ obj-$(CONFIG_BRIDGE) += bridge.o
 
 bridge-y	:= br.o br_device.o br_fdb.o br_forward.o br_if.o br_input.o \
 			br_ioctl.o br_notify.o br_stp.o br_stp_bpdu.o \
-			br_stp_if.o br_stp_timer.o br_netlink.o
+			br_stp_if.o br_stp_timer.o br_netlink.o 
 
 bridge-$(CONFIG_SYSFS) += br_sysfs_if.o br_sysfs_br.o
 
-bridge-$(CONFIG_RTL865X_LANPORT_RESTRICTION) += lan_restrict.o
+bridge-$(CONFIG_RTL865X_LANPORT_RESTRICTION) += ../rtl/features/lan_restrict.o
 
 bridge-$(CONFIG_BRIDGE_NETFILTER) += br_netfilter.o
 
 obj-$(CONFIG_DOMAIN_NAME_QUERY_SUPPORT) += pocket_filter.o
+ifeq ($(CONFIG_RTL_ULINKER),y)
+        obj-y += pocket_filter.o
+endif
 
 obj-$(CONFIG_BRIDGE_NF_EBTABLES) += netfilter/
 
diff --git a/net/bridge/br.c b/net/bridge/br.c
index 0b956f5..b05f9c6 100644
--- a/net/bridge/br.c
+++ b/net/bridge/br.c
@@ -24,14 +24,15 @@
 
 #include <linux/proc_fs.h>
 #if defined (CONFIG_RTL865X_LANPORT_RESTRICTION)
-#include "lan_restrict.h"
+#include <net/rtl/features/lan_restrict.h>
+
 #endif
-#if defined(CONFIG_DOMAIN_NAME_QUERY_SUPPORT)
+#if defined(CONFIG_DOMAIN_NAME_QUERY_SUPPORT) || defined(CONFIG_RTL_ULINKER)
 extern int __init br_filter_init(void);
 extern void __exit br_filter_exit(void);
 #endif
 
-#if defined(CONFIG_HTTP_FILE_SERVER_SUPPORT)
+#if defined(CONFIG_HTTP_FILE_SERVER_SUPPORT) || defined(CONFIG_RTL_USB_UWIFI_HOST_SPEEDUP)
 #include <linux/inetdevice.h>
 #define NIPQUAD_HTTP(addr) \
 	((unsigned char *)&addr)[0], \
@@ -683,6 +684,28 @@ static unsigned char* br_generateIgmpQuery(struct net_bridge * br)
 		return NULL;
 	}
 	
+    #ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+	if(!strcmp(RTL_PS_BR1_DEV_NAME, br->dev->name))
+	{
+		if (landev = brDev){
+			in_dev=(struct net_device *)(landev->ip_ptr);
+			if (in_dev != NULL) {
+				for (ifap=in_dev->ifa_list; ifap != NULL; ifap=ifap->ifa_next) {
+					if (strcmp(br->dev->name, ifap->ifa_label) == 0){
+						if(igmpVersion==3)
+						{
+							memcpy(&igmpV3QueryBuf[26],&ifap->ifa_address,4);
+						}
+						else
+						{
+							memcpy(&igmpV2QueryBuf[26],&ifap->ifa_address,4);
+						}
+					}
+				}
+			}
+		}
+	}
+        #endif
 	if(igmpVersion==3)
 	{
 		igmpV3QueryBuf[24]=0;
@@ -757,7 +780,11 @@ void br_igmpQueryTimerExpired(unsigned long arg)
 	struct net_bridge_port *prev;
 	unsigned int fwdCnt=0;
 
+#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+	if(IGMPProxyOpened && strcmp(br->dev->name,RTL_PS_BR1_DEV_NAME))
+#else
 	if(IGMPProxyOpened)
+#endif
 	{
 		return ;
 	}
@@ -886,7 +913,53 @@ static int br_mldQueryWrite_proc(struct file *file, const char *buffer,
       return -EFAULT;
 }
 
-static unsigned char mldQueryBuf[86]={	0x33,0x33,0x00,0x00,0x00,0x01,		/*destination mac*/
+struct proc_dir_entry *procMldVersion=NULL;
+int mldVersion=2;
+static int br_mldVersionRead_proc(char *page, char **start, off_t off, 
+		int count, int *eof, void *data)
+{
+
+      int len;
+
+      len = sprintf(page, "%c\n", mldVersion + '0');
+
+
+      if (len <= off+count) *eof = 1;
+      *start = page + off;
+      len -= off;
+      if (len>count) len = count;
+      if (len<0) len = 0;
+      return len;
+
+}
+
+static int br_mldVersionWrite_proc(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+      unsigned char tmp; 
+      if (count < 2) 
+	    return -EFAULT;
+      
+	if (buffer && !copy_from_user(&tmp, buffer, 1)) {
+		mldVersion = tmp - '0';
+		if(mldVersion>=2)
+		{
+			mldVersion=2;
+		}
+		else if (mldVersion<=1)
+		{
+			mldVersion=1;
+		}
+		else
+		{
+			mldVersion=2;
+		}
+	    return count;
+      }
+      return -EFAULT;
+}
+
+static unsigned char mldQueryBuf[90]={	0x33,0x33,0x00,0x00,0x00,0x01,		/*destination mac*/
 									0x00,0x00,0x00,0x00,0x00,0x00,		/*source mac*/	/*offset:6*/
 									0x86,0xdd,						/*ether type*/	/*offset:12*/
 									0x60,0x00,0x00,0x00,				/*version(1 byte)-traffic cliass(1 byte)- flow label(2 bytes)*/	/*offset:14*/
@@ -910,7 +983,8 @@ static unsigned char mldQueryBuf[86]={	0x33,0x33,0x00,0x00,0x00,0x01,		/*destina
 									0x00,0x00,0x00,0x00,				/*multicast address,fixed as 0*/
 									0x00,0x00,0x00,0x00,			
 									0x00,0x00,0x00,0x00,			
-									0x00,0x00,0x00,0x00
+									0x00,0x00,0x00,0x00,
+									0x0a,0x3c,0x00,0x00
 								};			
 
 static unsigned char ipv6PseudoHdrBuf[40]=	{	
@@ -982,10 +1056,28 @@ static unsigned char* br_generateMldQuery(struct net_bridge * br)
 
 	
 	memcpy(ipv6PseudoHdrBuf,&mldQueryBuf[22],16);			/*set pseudo-header source ip*/
+	if(mldVersion==2)
+	{
+		mldQueryBuf[19]=	0x24;
+	}
+	else
+	{
+		mldQueryBuf[19]=	0x20;
+	}
 
 	mldQueryBuf[64]=0;/*reset checksum*/
 	mldQueryBuf[65]=0;
-	checkSum=br_ipv6Checksum(&mldQueryBuf[62],24,ipv6PseudoHdrBuf);
+	if(mldVersion==2)
+	{
+		ipv6PseudoHdrBuf[35]=28;
+		checkSum=br_ipv6Checksum(&mldQueryBuf[62],28,ipv6PseudoHdrBuf);
+	}
+	else
+	{
+		ipv6PseudoHdrBuf[35]=24;
+		checkSum=br_ipv6Checksum(&mldQueryBuf[62],24,ipv6PseudoHdrBuf);
+	}
+	
 	
 	mldQueryBuf[64]=(checkSum&0xff00)>>8;
 	mldQueryBuf[65]=(checkSum&0x00ff);
@@ -1023,9 +1115,18 @@ void br_mldQueryTimerExpired(unsigned long arg)
 		return;
 	}
 	
-	memcpy(skb->data,mldBuf,86);
-	skb->len = 0;
-	skb_put(skb, 86);
+	if(mldVersion==2)
+	{
+		memcpy(skb->data,mldBuf,90);
+		skb->len = 0;
+		skb_put(skb, 90);
+	}
+	else
+	{
+		memcpy(skb->data,mldBuf,86);
+		skb->len = 0;
+		skb_put(skb, 86);
+	}
  
 	prev = NULL;
 	fwdCnt=0;
@@ -1081,6 +1182,13 @@ void br_mCastQueryTimerExpired(unsigned long arg)
 	struct net_bridge *br = (struct net_bridge*) arg;
 	
 	mod_timer(&br->mCastQuerytimer, jiffies+MCAST_QUERY_INTERVAL*HZ);
+    #ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+		if(!strcmp(br->dev->name,RTL_PS_BR1_DEV_NAME))
+		{
+			br_igmpQueryTimerExpired(arg);
+			return;
+		}
+	#endif
 	
 	if(mCastQueryTimerCnt%2==0)
 	{
@@ -1251,6 +1359,11 @@ static int __init br_init(void)
 
 
 #if defined (CONFIG_RTL_MLD_SNOOPING)
+		procMldVersion= create_proc_entry("br_mldVersion", 0, NULL);
+		if (procMldVersion) {
+		    procMldVersion->read_proc = br_mldVersionRead_proc;
+		    procMldVersion->write_proc = br_mldVersionWrite_proc;
+		}
 		procMldQuery= create_proc_entry("br_mldquery", 0, NULL);
 		if (procMldQuery) {
 		    procMldQuery->read_proc = br_mldQueryRead_proc;
@@ -1283,10 +1396,10 @@ static int __init br_init(void)
 
 	br_fdb_get_hook = br_fdb_get;
 	br_fdb_put_hook = br_fdb_put;
-#if defined(CONFIG_DOMAIN_NAME_QUERY_SUPPORT)
+#if defined(CONFIG_DOMAIN_NAME_QUERY_SUPPORT) || defined(CONFIG_RTL_ULINKER)
 	br_filter_init();
 #endif
-#if defined(CONFIG_HTTP_FILE_SERVER_SUPPORT)
+#if defined(CONFIG_HTTP_FILE_SERVER_SUPPORT) || defined(CONFIG_RTL_USB_UWIFI_HOST_SPEEDUP)
 	http_file_init();
 #endif	
 	return 0;
@@ -1334,6 +1447,10 @@ static void __exit br_deinit(void)
 	}
 
 #if defined (CONFIG_RTL_MLD_SNOOPING)
+	if (procMldVersion) {
+	 	 remove_proc_entry("br_mldVersion", procMldVersion);		
+		procMldVersion = NULL;
+	}
 	if (procMldQuery) {
 		 remove_proc_entry("br_mldquery", procMldQuery);		
 		procMldQuery = NULL;
@@ -1362,10 +1479,10 @@ static void __exit br_deinit(void)
 
 	br_handle_frame_hook = NULL;
 	br_fdb_fini();
-#if defined(CONFIG_DOMAIN_NAME_QUERY_SUPPORT)
+#if defined(CONFIG_DOMAIN_NAME_QUERY_SUPPORT) || defined(CONFIG_RTL_ULINKER)
 	br_filter_exit();
 #endif
-#if defined(CONFIG_HTTP_FILE_SERVER_SUPPORT)
+#if defined(CONFIG_HTTP_FILE_SERVER_SUPPORT) || defined(CONFIG_RTL_USB_UWIFI_HOST_SPEEDUP)
 	http_file_exit();
 #endif	
 }
diff --git a/net/bridge/br_device.c b/net/bridge/br_device.c
index efa336e..ffe451c 100644
--- a/net/bridge/br_device.c
+++ b/net/bridge/br_device.c
@@ -43,6 +43,10 @@ extern unsigned int brIgmpModuleIndex;
 extern unsigned int nicIgmpModuleIndex;
 #endif
 
+#if defined(CONFIG_RTL_HW_VLAN_SUPPORT)
+extern uint32 rtl_hw_vlan_get_tagged_portmask(void);
+#endif
+
 #if defined (CONFIG_RTL_HARDWARE_MULTICAST)
 int rtl865x_ipMulticastHardwareAccelerate(struct net_bridge *br, unsigned int brFwdPortMask,
 												unsigned int srcPort,unsigned int srcVlanId, 
@@ -128,7 +132,11 @@ ap_hcm_out:
 				}
 				#endif
 
-				if( iph->daddr == 0xEFFFFFFA)
+				#if defined(CONFIG_USB_UWIFI_HOST)
+				if(iph->daddr == 0xEFFFFFFA || iph->daddr == 0xE1010101)
+				#else
+				if(iph->daddr == 0xEFFFFFFA)
+				#endif
 				{
 					/*for microsoft upnp*/
 					reserved=1;
@@ -182,7 +190,7 @@ ap_hcm_out:
 				}
 				else
 				{
-		br_flood_deliver(br, skb);
+					br_flood_deliver(br, skb);
 				}
 			}
 #endif		
@@ -346,7 +354,7 @@ void br_dev_setup(struct net_device *dev)
 	SET_ETHTOOL_OPS(dev, &br_ethtool_ops);
 	dev->tx_queue_len = 0;
 	dev->priv_flags = IFF_EBRIDGE;
-#if defined(CONFIG_HTTP_FILE_SERVER_SUPPORT)
+#if defined(CONFIG_HTTP_FILE_SERVER_SUPPORT) || defined(CONFIG_RTL_USB_UWIFI_HOST_SPEEDUP)
 	dev->features = NETIF_F_SG | NETIF_F_FRAGLIST | NETIF_F_HIGHDMA |
 			NETIF_F_GSO_MASK | NETIF_F_NO_CSUM | NETIF_F_LLTX |
 			NETIF_F_NETNS_LOCAL | NETIF_F_GSO|NETIF_F_GRO|NETIF_F_LRO;
@@ -372,6 +380,9 @@ int rtl865x_ipMulticastHardwareAccelerate(struct net_bridge *br, unsigned int br
 	//int fwdDescCnt;
 	//unsigned short port_bitmask=0;
 
+	unsigned int tagged_portmask=0;
+
+
 	struct rtl_multicastDataInfo multicastDataInfo;
 	struct rtl_multicastFwdInfo  multicastFwdInfo;
 	
@@ -384,7 +395,7 @@ int rtl865x_ipMulticastHardwareAccelerate(struct net_bridge *br, unsigned int br
 	if(strcmp(br->dev->name,RTL_PS_BR0_DEV_NAME)!=0)
 	{
 		return -1;
-}
+	}
 
 	if(brFwdPortMask & br0SwFwdPortMask)
 	{
@@ -429,11 +440,26 @@ int rtl865x_ipMulticastHardwareAccelerate(struct net_bridge *br, unsigned int br
 		fwdDescriptor.fwdPortMask=multicastFwdInfo.fwdPortMask & (~(1<<srcPort));
 	}
 
-	rtl865x_addMulticastEntry(destIpAddr, srcIpAddr, (unsigned short)srcVlanId, (unsigned short)srcPort, 
-						&fwdDescriptor, 1, 0, 0, 0);
-	
+#if defined(CONFIG_RTL_HW_VLAN_SUPPORT)
+	if(rtl_hw_vlan_ignore_tagged_mc == 1)
+		tagged_portmask = rtl_hw_vlan_get_tagged_portmask();
+#endif
+	if((fwdDescriptor.fwdPortMask & tagged_portmask) == 0)
+	{
+
+		ret=rtl865x_addMulticastEntry(destIpAddr, srcIpAddr, (unsigned short)srcVlanId, (unsigned short)srcPort,
+							&fwdDescriptor, 1, 0, 0, 0);
+	}
+
 	return 0;
 }
 
 #endif
+#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+int rtl865x_same_root(struct net_device *dev1,struct net_device *dev2){
 
+	struct net_bridge_port *p = rcu_dereference(dev1->br_port);
+	struct net_bridge_port *p2 = rcu_dereference(dev2->br_port);
+	return !strncmp(p->br->dev->name,p2->br->dev->name,3);
+}
+#endif
diff --git a/net/bridge/br_fdb.c b/net/bridge/br_fdb.c
index 2e491a7..1e6e2f1 100644
--- a/net/bridge/br_fdb.c
+++ b/net/bridge/br_fdb.c
@@ -31,7 +31,8 @@
 #include <net/rtl/features/rtl_ps_hooks.h>
 
 #if defined (CONFIG_RTL_LAYERED_DRIVER_L2)&& defined (CONFIG_RTL865X_LANPORT_RESTRICTION)
-#include "lan_restrict.h"
+#include <net/rtl/features/lan_restrict.h>
+
 #endif
 
 #endif	/*	defined(CONFIG_RTL_819X)	*/
@@ -48,7 +49,7 @@ extern int IGMPProxyOpened;
 void add_igmp_ext_entry(	struct net_bridge_fdb_entry *fdb ,unsigned char *srcMac , unsigned char portComeIn);
 void update_igmp_ext_entry(	struct net_bridge_fdb_entry *fdb ,unsigned char *srcMac , unsigned char portComeIn);
 void del_igmp_ext_entry(	struct net_bridge_fdb_entry *fdb ,unsigned char *srcMac , unsigned char portComeIn );
-static void br_igmp_fdb_expired(struct net_bridge_fdb_entry *ent);
+//void br_igmp_fdb_expired(struct net_bridge_fdb_entry *ent);
 #endif
 
 static struct kmem_cache *br_fdb_cache __read_mostly;
@@ -102,9 +103,11 @@ static inline void fdb_delete(struct net_bridge_fdb_entry *f)
 {
 	hlist_del_rcu(&f->hlist);
 	br_fdb_put(f);
+	#if 0
 	#if defined(CONFIG_RTL_819X)
 	rtl_fdb_delete_hooks(f);
 	#endif
+	#endif
 }
 
 void br_fdb_changeaddr(struct net_bridge_port *p, const unsigned char *newaddr)
@@ -134,6 +137,7 @@ void br_fdb_changeaddr(struct net_bridge_port *p, const unsigned char *newaddr)
 				}
 
 				/* delete old one */
+				//printk("[%s][%d].\n", __FUNCTION__, __LINE__);
 				fdb_delete(f);
 				goto insert;
 			}
@@ -147,7 +151,7 @@ void br_fdb_changeaddr(struct net_bridge_port *p, const unsigned char *newaddr)
 }
 
 #if defined (CONFIG_RTL_IGMP_SNOOPING)
-static void br_igmp_fdb_expired(struct net_bridge_fdb_entry *ent)
+ void br_igmp_fdb_expired(struct net_bridge_fdb_entry *ent)
 {
 	int i2;
 	unsigned long igmp_walktimeout;	
@@ -244,24 +248,33 @@ static void br_igmp_fdb_expired(struct net_bridge_fdb_entry *ent)
 	
 }
 #endif
+
 void br_fdb_cleanup(unsigned long _data)
 {
 	struct net_bridge *br = (struct net_bridge *)_data;
+#if 0
+#if defined(CONFIG_RTL_LAYERED_DRIVER) && defined(CONFIG_RTL_LAYERED_DRIVER_L2)
+	int32 port_num;
+#if defined (CONFIG_RTL865X_LANPORT_RESTRICTION)
+	unsigned char swap_addr[ETHER_ADDR_LEN];
+#endif
+	int ret;
+	unsigned long hw_aging;
+#endif
+#endif
 	unsigned long delay = hold_time(br);
 	unsigned long next_timer = jiffies + br->forward_delay;
 	int i;
-	#if defined (CONFIG_RTL865X_LANPORT_RESTRICTION) && defined(CONFIG_RTL_LAYERED_DRIVER) && defined(CONFIG_RTL_LAYERED_DRIVER_L2) && defined(CONFIG_RTL865X_SYNC_L2)
-	int32 port_num;
-	unsigned char swap_addr[ETHER_ADDR_LEN];
-	#endif
-
+	
 	spin_lock_bh(&br->hash_lock);
+	
 	for (i = 0; i < BR_HASH_SIZE; i++) {
 		struct net_bridge_fdb_entry *f;
 		struct hlist_node *h, *n;
 
 		hlist_for_each_entry_safe(f, h, n, &br->hash[i], hlist) {
 			unsigned long this_timer;
+			
 			#if defined	(CONFIG_RTL_IGMP_SNOOPING)
 			if(	f->is_static &&
 				f->igmpFlag &&
@@ -269,49 +282,40 @@ void br_fdb_cleanup(unsigned long _data)
 			{
 										
 				br_igmp_fdb_expired(f);
+				
 				if(time_before_eq(f->ageing_timer +300*HZ,  jiffies))
 				{
 					DEBUG_PRINT("fdb_delete:f->addr.addr is 0x%02x:%02x:%02x-%02x:%02x:%02x\n",
 					f->addr.addr[0],f->addr.addr[1],f->addr.addr[2],f->addr.addr[3],f->addr.addr[4],f->addr.addr[5]);	
 					fdb_delete(f);
 				}
-				
+			
 			}
 			#endif
 
 			if (f->is_static)
 				continue;
-
+			
 			#if defined(CONFIG_RTL_819X)
-			rtl_br_fdb_cleanup_hooks(br, f);
+				rtl_br_fdb_cleanup_hooks(br,f, delay);
 			#endif
+			this_timer = f->ageing_timer+delay;
 			
-			this_timer = f->ageing_timer + delay;
-			if (time_before_eq(this_timer, jiffies)) {
-				#if defined (CONFIG_RTL865X_LANPORT_RESTRICTION) && defined(CONFIG_RTL_LAYERED_DRIVER) && defined(CONFIG_RTL_LAYERED_DRIVER_L2) && defined(CONFIG_RTL865X_SYNC_L2)
-				/*try to find blocked l2 entry, then set it to authed*/
-				if (port_num != -100)
-				{
-					if ((lan_restrict_getBlockAddr(port_num, swap_addr)) == SUCCESS)
-					{
-						/*									
-						printk("\n arrange block entry is %x %x %x %x %x %x\n", swap_addr[0],
-																swap_addr[1],
-																swap_addr[2],
-																swap_addr[3],
-																swap_addr[4],
-																swap_addr[5]);
-																
-						*/
-						rtl865x_addAuthFDBEntry(swap_addr, TRUE, port_num);
-					}
-				}
-				#endif	/* #if defined (CONFIG_RTL865X_LANPORT_RESTRICTION) && defined(CONFIG_RTL_LAYERED_DRIVER) && defined(CONFIG_RTL_LAYERED_DRIVER_L2) && defined(CONFIG_RTL865X_SYNC_L2)	*/
-
+			if (time_before_eq(this_timer, jiffies)) 
+			{
 				fdb_delete(f);
-			} else if (time_before(this_timer, next_timer))
+				/*delete  an  FDB Entry   */
+			} 
+			else if (time_before(this_timer, next_timer))
+			{
 				next_timer = this_timer;
-		}
+			}
+			else
+			{
+				//printk("[%s][%d].\n", __FUNCTION__, __LINE__);
+			}
+
+		} //end hlist_for_each_entry_safe
 	}
 	spin_unlock_bh(&br->hash_lock);
 
@@ -320,6 +324,8 @@ void br_fdb_cleanup(unsigned long _data)
 	mod_timer(&br->gc_timer, round_jiffies(next_timer + HZ/4));
 }
 
+
+
 /* Completely flush all dynamic entries in forwarding database.*/
 void br_fdb_flush(struct net_bridge *br)
 {
@@ -338,12 +344,16 @@ void br_fdb_flush(struct net_bridge *br)
 				br_igmp_fdb_expired(f);
 				if(time_before_eq(f->ageing_timer + 300*HZ,  jiffies))
 				{
+					//printk("[%s][%d].\n", __FUNCTION__, __LINE__);
 					fdb_delete(f);
 				}
 			}
 		#endif
 			if (!f->is_static)
-				fdb_delete(f);
+				{
+					//printk("[%s][%d].\n", __FUNCTION__, __LINE__);
+					fdb_delete(f);
+				}
 		}
 	}
 	spin_unlock_bh(&br->hash_lock);
@@ -386,7 +396,7 @@ void br_fdb_delete_by_port(struct net_bridge *br,
 					}
 				}
 			}
-
+			//printk("[%s][%d].\n", __FUNCTION__, __LINE__);
 			fdb_delete(f);
 		skip_delete: ;
 		}
@@ -433,26 +443,51 @@ struct net_bridge_fdb_entry *br_fdb_get(struct net_bridge *br,
 	return fdb;
 }
 
-static void fdb_rcu_free(struct rcu_head *head)
+/*static void fdb_rcu_free(struct rcu_head *head)
 {
 	struct net_bridge_fdb_entry *ent
-		= container_of(head, struct net_bridge_fdb_entry, rcu);
+		= container_of(head, struct net_bridge_fdb_entry, rcu);	
+	kmem_cache_free(br_fdb_cache, ent);
+#if defined(CONFIG_RTL_819X)
+	rtl_fdb_delete_hooks(f);
+	fdb_entry_num--;
+	if(fdb_entry_num < 0)
+	{
+		printk("fdb entry num error!!!!\n");
+		fdb_entry_num = 0;
+	}
+#endif
+}*/
+
+static void fdb_rcu_free(struct rcu_head *head)
+{
+struct net_bridge_fdb_entry *ent
+		= container_of(head, struct net_bridge_fdb_entry, rcu);	
 	kmem_cache_free(br_fdb_cache, ent);
 #if defined(CONFIG_RTL_819X)
+	#if defined(CONFIG_RTL_819X)
+	rtl_fdb_delete_hooks(ent);
+	#endif
 	fdb_entry_num--;
 	if(fdb_entry_num < 0)
 	{
 		printk("fdb entry num error!!!!\n");
 		fdb_entry_num = 0;
 	}
+	/*printk("fdb_entry_num:%d\n",fdb_entry_num);*/
 #endif
 }
 
 /* Set entry up for deletion with RCU  */
 void br_fdb_put(struct net_bridge_fdb_entry *ent)
 {
-	if (atomic_dec_and_test(&ent->use_count))
+	
+	if (atomic_dec_and_test(&ent->use_count)) {
+
 		call_rcu(&ent->rcu, fdb_rcu_free);
+		//rtl_fdb_delete_hooks(ent);
+	
+	}
 }
 
 /*
@@ -523,82 +558,45 @@ static struct net_bridge_fdb_entry *fdb_create(struct hlist_head *head,
 					       int is_local)
 {
 	struct net_bridge_fdb_entry *fdb;
-#if defined (CONFIG_RTL_IGMP_SNOOPING)
-	int i3;
-#endif
+
 #if defined(CONFIG_RTL_819X)
 	if(fdb_entry_num >= fdb_entry_max)
 		return NULL;
 #endif
+	int i3;
 
 	fdb = kmem_cache_alloc(br_fdb_cache, GFP_ATOMIC);
-	if (fdb) {
+	if (fdb) 
+	{
 		memcpy(fdb->addr.addr, addr, ETH_ALEN);
 		atomic_set(&fdb->use_count, 1);
-#if defined(CONFIG_RTL_819X)
-		fdb_entry_num++;
-#endif
+		#if defined(CONFIG_RTL_819X)
+			fdb_entry_num++;
+		#endif
 		hlist_add_head_rcu(&fdb->hlist, head);
 
 		fdb->dst = source;
 		fdb->is_local = is_local;
 		fdb->is_static = is_local;
 		fdb->ageing_timer = jiffies;
-
-#if defined (CONFIG_RTL_IGMP_SNOOPING)	
+		
+		#if defined (CONFIG_RTL_IGMP_SNOOPING)
+		
 		fdb->group_src = 0;
 		fdb->igmpFlag=0;
-		for(i3=0 ; i3<FDB_IGMP_EXT_NUM ;i3++){
+		for(i3=0 ; i3<FDB_IGMP_EXT_NUM ;i3++)
+		{
 			fdb->igmp_fdb_arr[i3].valid = 0;
 			fdb->portUsedNum[i3] = 0;		
 		}
-
-#endif
-
-
-#if defined(CONFIG_RTL_LAYERED_DRIVER) && defined(CONFIG_RTL_LAYERED_DRIVER_L2) && defined(CONFIG_RTL865X_SYNC_L2)
-		if (fdb->is_static == 0)
-		{
-#if defined (CONFIG_RTL865X_LANPORT_RESTRICTION)
-			/*lookup hw l2 table by mac */
-			ether_addr_t *macAddr;
-			int32 column;
-			rtl865x_tblAsicDrv_l2Param_t	fdbEntry;
-			int8 port_num = -1;
-			fdb->entry_timing = 300*HZ;
-			macAddr = (ether_addr_t *)(addr);
-			
-			if (rtl865x_Lookup_fdb_entry(RTL_LAN_FID, macAddr, FDB_DYNAMIC, &column,&fdbEntry) == SUCCESS)
-			{
-
-				port_num = rtl865x_ConvertPortMasktoPortNum(fdbEntry.memberPortMask);
-
-				/*function opened, and should be authed*/
-				if (lan_restrict_CheckStatusByport(port_num) == TRUE)
-				{
-					rtl865x_addAuthFDBEntry(addr, TRUE, port_num);
-				}
-				/*function opened, and set it to block*/
-				else if(lan_restrict_CheckStatusByport(port_num) == FALSE)
-				{
-					rtl865x_addAuthFDBEntry(addr, FALSE, port_num);
-				
-				}
-				/*function not open , no need to be authed*/
-				else  if(lan_restrict_CheckStatusByport(port_num) == FAILED)
-				{
-					rtl865x_addFDBEntry(addr);
-				}
-			}
-
-
-#else
-				fdb->entry_timing = 300*HZ;
-				rtl865x_addFDBEntry(addr);
-#endif
-		}
-#endif		
+		#endif
+		
+		#if defined(CONFIG_RTL_819X)
+		rtl_fdb_create_hooks(fdb, addr);		
+		#endif
+		
 	}
+	
 	return fdb;
 }
 
@@ -628,6 +626,7 @@ static int fdb_insert(struct net_bridge *br, struct net_bridge_port *source,
 		printk(KERN_WARNING "%s adding interface with same address "
 		       "as a received packet\n",
 		       source->dev->name);
+		//printk("[%s][%d].\n", __FUNCTION__, __LINE__);
 		fdb_delete(fdb);
 	}
 
@@ -664,20 +663,27 @@ void br_fdb_update(struct net_bridge *br, struct net_bridge_port *source,
 		return;
 
 	fdb = fdb_find(head, addr);
-	if (likely(fdb)) {
+	if (likely(fdb)) 
+	{
+		
 		/* attempt to update an entry for a local interface */
-		if (unlikely(fdb->is_local)) {
+		if (unlikely(fdb->is_local)) 
+		{
 			if (net_ratelimit())
 				printk(KERN_WARNING "%s: received packet with "
 				       " own address as source address\n",
 				       source->dev->name);
-		} else {
+		} 
+		else 
+		{
 			/* fastpath: update of existing entry */
-#if defined (CONFIG_RTL865X_ETH)
+			/* 02-17-2012: move to WLAN driver update_fwtbl_asoclst() to avoid hacking the Linux kernel or the other kernel */
+#if 0 //defined (CONFIG_RTL865X_ETH)
 //                       if (((unsigned long)fdb->dst) != ((unsigned long)source->br->dev->a)) { 
-				if (fdb->dst != source){
-                               update_hw_l2table(source->dev->name, addr);
-                       }
+			if (fdb->dst != source)
+			{	
+				update_hw_l2table(source->dev->name, addr);
+			}
 #endif			
 			fdb->dst = source;
 			fdb->ageing_timer = jiffies;
diff --git a/net/bridge/br_forward.c b/net/bridge/br_forward.c
index a3754ac..326aced 100644
--- a/net/bridge/br_forward.c
+++ b/net/bridge/br_forward.c
@@ -38,16 +38,48 @@ extern int mldSnoopEnabled;
 #endif
 #endif
 
+#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+extern unsigned int brIgmpModuleIndex_2;
+#endif
+
 #if	defined(CONFIG_RTL_819X)
 #include <net/rtl/features/rtl_ps_hooks.h>
 #endif
+#include <net/rtl/features/rtl_ps_log.h>
 
 
 /* Don't forward packets to originating port or forwarding diasabled */
 static inline int should_deliver(const struct net_bridge_port *p,
 				 const struct sk_buff *skb)
 {
-	return (skb->dev != p->dev && p->state == BR_STATE_FORWARDING);
+	if (skb->dev == p->dev ||
+	    p->state != BR_STATE_FORWARDING)
+		return 0;
+
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+		if (skb->src_info) {
+			struct vlan_info_item *pitem = rtl_get_vlan_info_item_by_dev(p->dev);
+
+			/* index == 1, it means skb is cloned skb in rx_vlan_process */
+			if (skb->src_info->index) {
+				if (pitem && pitem->info.forwarding_rule!=1)
+					return 0;
+			}
+
+			/* vlan_br can't send packet to vlan_nat */
+			if (skb->src_info->forwarding_rule==1) {
+				if (pitem && pitem->info.forwarding_rule==2)
+					return 0;
+			}
+
+			/* vlan_nat can't send packet to vlan_br */
+			if (skb->src_info->forwarding_rule==2) {
+				if (pitem && pitem->info.forwarding_rule==1)
+					return 0;
+			}
+		}
+#endif
+	return 1;
 }
 
 static inline unsigned packet_length(const struct sk_buff *skb)
@@ -129,7 +161,7 @@ void br_forward(const struct net_bridge_port *to, struct sk_buff *skb)
 	kfree_skb(skb);
 }
 
-#ifdef CONFIG_RTK_INBAND_HOST_HACK	
+#ifdef CONFIG_RTK_INBAND_HOST_HACK
 #define ETH_P_RTK_NOTIFY 0x9000 //mark_issue
 #define ETH_P_RTK_NOTIFY1 0x9001
 #define ETH_P_RTK		0x8899	// Realtek Remote Control Protocol (RRCP)
@@ -137,12 +169,12 @@ void br_forward(const struct net_bridge_port *to, struct sk_buff *skb)
 #define LOCAL_INBAND_IF0 "eth0"
 
 static inline int inband_deliver_check(struct net_bridge_port *p, struct sk_buff *skb)
-{	
+{
 	struct ethhdr *eth_hdr_p;
 	eth_hdr_p = eth_hdr(skb);
 
-	if(eth_hdr_p->h_proto == ETH_P_RTK_NOTIFY || eth_hdr_p->h_proto == ETH_P_RTK 
-							  || eth_hdr_p->h_proto == ETH_P_RTK_NOTIFY1 )		
+	if(eth_hdr_p->h_proto == ETH_P_RTK_NOTIFY || eth_hdr_p->h_proto == ETH_P_RTK
+							  || eth_hdr_p->h_proto == ETH_P_RTK_NOTIFY1 )
 		if(memcmp(p->dev->name,LOCAL_INBAND_IF1,4) && memcmp(p->dev->name,LOCAL_INBAND_IF0,4) ) //not foward if not eth1 or eth0
 			return 0;
 	return 1;
@@ -161,15 +193,16 @@ static void br_flood(struct net_bridge *br, struct sk_buff *skb,
 	prev = NULL;
 
 	list_for_each_entry_rcu(p, &br->port_list, list) {
-#ifndef CONFIG_RTK_INBAND_HOST_HACK		
+#ifndef CONFIG_RTK_INBAND_HOST_HACK
 		if (should_deliver(p, skb)) {
 #else
 		if ((should_deliver(p, skb)) && (inband_deliver_check(p, skb))) {
-#endif		
+#endif
 			if (prev != NULL) {
 				struct sk_buff *skb2;
 
 				if ((skb2 = skb_clone(skb, GFP_ATOMIC)) == NULL) {
+					LOG_MEM_ERROR("%s(%d) skb clone failed, drop it\n", __FUNCTION__, __LINE__);
 					br->dev->stats.tx_dropped++;
 					kfree_skb(skb);
 					return;
@@ -219,7 +252,7 @@ int bitmask_to_id(unsigned char val)
 	return (i);
 }
 
-static void br_multicast(struct net_bridge *br, unsigned int fwdPortMask, struct sk_buff *skb, int clone, 
+static void br_multicast(struct net_bridge *br, unsigned int fwdPortMask, struct sk_buff *skb, int clone,
 		  void (*__packet_hook)(const struct net_bridge_port *p, struct sk_buff *skb))
 {
 //	char i;
@@ -228,32 +261,34 @@ static void br_multicast(struct net_bridge *br, unsigned int fwdPortMask, struct
 	unsigned short port_bitmask=0;
         if (clone) {
                 struct sk_buff *skb2;
-                                                                                                                                              
+
                 if ((skb2 = skb_clone(skb, GFP_ATOMIC)) == NULL) {
+			LOG_MEM_ERROR("%s(%d) skb clone failed, drop it\n", __FUNCTION__, __LINE__);
                         br->dev->stats.tx_dropped++;
                         return;
                 }
-                                                                                                                                              
+
                 skb = skb2;
         }
-                                                                                                                                              
+
 	prev = NULL;
-	
+
 	list_for_each_entry_safe(p, n, &br->port_list, list) {
 		port_bitmask = (1 << p->port_no);
                 if ((port_bitmask & fwdPortMask) && should_deliver(p, skb)) {
                         if (prev != NULL) {
                                 struct sk_buff *skb2;
-                                                                                                                                 
+
                                 if ((skb2 = skb_clone(skb, GFP_ATOMIC)) == NULL) {
+					LOG_MEM_ERROR("%s(%d) skb clone failed, drop it\n", __FUNCTION__, __LINE__);
                                         br->dev->stats.tx_dropped++;
                                         kfree_skb(skb);
                                         return;
                                 }
-                                        
+
                                 __packet_hook(prev, skb2);
                         }
-                                                                                                                       
+
                         prev = p;
                 }
 	}
@@ -279,13 +314,98 @@ extern struct net_bridge *bridge0;
 extern int ipMulticastFastFwd;
 extern int needCheckMfc;
 #if defined (CONFIG_IP_MROUTE)
-extern int rtl865x_checkMfcCache(struct net *net,__be32 origin,__be32 mcastgrp);
+#if defined (CONFIG_RTL_IGMP_PROXY)
+extern int rtl865x_checkMfcCache(struct net *net,struct net_device *dev,__be32 origin,__be32 mcastgrp);
+#endif
 #endif
 
 #if defined(CONFIG_RTL_MLD_SNOOPING)
 extern int re865x_getIpv6TransportProtocol(struct ipv6hdr* ipv6h);
 #endif
 
+extern int rtl865x_blockMulticastFlow(unsigned int srcVlanId, unsigned int srcPort,unsigned int srcIpAddr, unsigned int destIpAddr);
+extern int rtl865x_curOpMode;
+
+#define MAX_UNKNOWN_MULTICAST_NUM 16
+#define MAX_UNKNOWN_MULTICAST_PPS 1500
+#define BLOCK_UNKNOWN_MULTICAST 1
+
+struct rtl865x_unKnownMCastRecord
+{
+	unsigned int groupAddr;
+	unsigned long lastJiffies;
+	unsigned long pktCnt;
+	unsigned int valid;
+};
+struct rtl865x_unKnownMCastRecord unKnownMCastRecord[MAX_UNKNOWN_MULTICAST_NUM];
+
+int rtl865x_checkUnknownMCastLoading(struct rtl_multicastDataInfo *mCastInfo)
+{
+	int i;
+	if(mCastInfo==NULL)
+	{
+		return 0;
+	}
+	/*check entry existed or not*/
+	for(i=0; i<MAX_UNKNOWN_MULTICAST_NUM; i++)
+	{
+		if((unKnownMCastRecord[i].valid==1) && (unKnownMCastRecord[i].groupAddr==mCastInfo->groupAddr[0]))
+		{
+			break;
+		}
+	}
+
+	/*find an empty one*/
+	if(i==MAX_UNKNOWN_MULTICAST_NUM)
+	{
+		for(i=0; i<MAX_UNKNOWN_MULTICAST_NUM; i++)
+		{
+			if(unKnownMCastRecord[i].valid!=1)
+			{
+				break;
+			}
+		}
+	}
+
+	/*find an exipired one */
+	if(i==MAX_UNKNOWN_MULTICAST_NUM)
+	{
+		for(i=0; i<MAX_UNKNOWN_MULTICAST_NUM; i++)
+		{
+			if(	time_before(unKnownMCastRecord[i].lastJiffies+HZ,jiffies)
+				|| time_after(unKnownMCastRecord[i].lastJiffies,jiffies+HZ)	)
+			{
+		
+				break;
+			}
+		}
+	}
+
+	if(i==MAX_UNKNOWN_MULTICAST_NUM)
+	{
+		return 0;
+	}
+
+	unKnownMCastRecord[i].groupAddr=mCastInfo->groupAddr[0];
+	unKnownMCastRecord[i].valid=1;
+	
+	if(time_after(unKnownMCastRecord[i].lastJiffies+HZ,jiffies))
+	{
+		unKnownMCastRecord[i].pktCnt++;
+	}
+	else
+	{
+		unKnownMCastRecord[i].lastJiffies=jiffies;
+		unKnownMCastRecord[i].pktCnt=0;
+	}
+
+	if(unKnownMCastRecord[i].pktCnt>MAX_UNKNOWN_MULTICAST_PPS)
+	{
+		return BLOCK_UNKNOWN_MULTICAST;
+	}
+
+	return 0;
+}
 int rtl865x_ipMulticastFastFwd(struct sk_buff *skb)
 {
 	const unsigned char *dest = NULL;
@@ -294,38 +414,48 @@ int rtl865x_ipMulticastFastFwd(struct sk_buff *skb)
 	unsigned char proto=0;
 	unsigned char reserved=0;
 	int ret=-1;
-	
+
 	struct net_bridge_port *prev;
 	struct net_bridge_port *p, *n;
 	struct rtl_multicastDataInfo multicastDataInfo;
 	struct rtl_multicastFwdInfo multicastFwdInfo;
 	struct sk_buff *skb2;
-	
+
 	unsigned short port_bitmask=0;
 	#if defined (CONFIG_RTL_MLD_SNOOPING)
 	struct ipv6hdr * ipv6h=NULL;
 	#endif
 	unsigned int fwdCnt;
-	
+#if	defined (CONFIG_RTL_IGMP_PROXY)
+	struct net_device *dev=skb->dev;
+#endif
+#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+	extern struct net_bridge *bridge1;
+	struct net_bridge *bridge = bridge0;
+#endif	
+#if defined (CONFIG_RTL_HARDWARE_MULTICAST)
+	unsigned int srcPort=skb->srcPort;
+	unsigned int srcVlanId=skb->srcVlanId;
+#endif
 	/*check fast forward enable or not*/
 	if(ipMulticastFastFwd==0)
 	{
 		return -1;
 	}
-	
+
 	/*check dmac is multicast or not*/
 	dest=eth_hdr(skb)->h_dest;
 	if((dest[0]&0x01)==0)
 	{
 		return -1;
 	}
-	
+
 	//printk("%s:%d,dest is 0x%x-%x-%x-%x-%x-%x\n",__FUNCTION__,__LINE__,dest[0],dest[1],dest[2],dest[3],dest[4],dest[5]);
 	if(igmpsnoopenabled==0)
 	{
 		return -1;
 	}
-	
+
 	/*check bridge0 exist or not*/
 	if((bridge0==NULL) ||(bridge0->dev->flags & IFF_PROMISC))
 	{
@@ -336,6 +466,12 @@ int rtl865x_ipMulticastFastFwd(struct sk_buff *skb)
 	{
 		return -1;
 	}
+    #ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+	if((strncmp(skb->dev->name,RTL_PS_BR1_DEV_NAME,3)==0))
+	{
+		return -1;
+	}
+	#endif
 
 	/*check igmp snooping enable or not, and check dmac is ipv4 multicast mac or not*/
 	if  ((dest[0]==0x01) && (dest[1]==0x00) && (dest[2]==0x5e))
@@ -353,41 +489,77 @@ int rtl865x_ipMulticastFastFwd(struct sk_buff *skb)
 		{
 			return -1;
 		}
-		
+
 		iph=(struct iphdr *)(ptr+2);
-	
+
 		if(iph->daddr== 0xEFFFFFFA)
 		{
 			/*for microsoft upnp*/
 			reserved=1;
 		}
-		
+
 		/*only speed up udp and tcp*/
-		proto =  iph->protocol;  
+		proto =  iph->protocol;
 		//printk("%s:%d,proto is %d\n",__FUNCTION__,__LINE__,proto);
 		 if(((proto ==IPPROTO_UDP) ||(proto ==IPPROTO_TCP)) && (reserved ==0))
 		{
-			
+
 			#if defined (CONFIG_IP_MROUTE)
 			/*multicast data comes from wan, need check multicast forwardig cache*/
 			if((strncmp(skb->dev->name,RTL_PS_WAN0_DEV_NAME,4)==0) && needCheckMfc )
 			{
-				if(rtl865x_checkMfcCache(&init_net,iph->saddr,iph->daddr)!=0)
+				#if	defined (CONFIG_RTL_IGMP_PROXY)
+				if(rtl865x_checkMfcCache(&init_net,dev,iph->saddr,iph->daddr)!=0)
+				#endif	
 				{
+					if(rtl865x_checkUnknownMCastLoading(&multicastDataInfo)==BLOCK_UNKNOWN_MULTICAST)
+					{
+						if((skb->srcVlanId!=0) && (skb->srcPort!=0xFFFF))
+						{
+							rtl865x_blockMulticastFlow(srcVlanId, srcPort, iph->saddr,iph->daddr);
+						}
+						else
+						{
+							kfree_skb(skb);
+							return 0;
+						}
+					}
+				
 					return -1;
 				}
 			}
 			#endif
-			
+
 			multicastDataInfo.ipVersion=4;
 			multicastDataInfo.sourceIp[0]=  (unsigned int)(iph->saddr);
 			multicastDataInfo.groupAddr[0]=  (unsigned int)(iph->daddr);
-			
+
+            #ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT //fix tim
+			if(!strcmp(skb->dev->name,RTL_PS_ETH_NAME_ETH2)){
+					ret= rtl_getMulticastDataFwdInfo(brIgmpModuleIndex_2, &multicastDataInfo, &multicastFwdInfo);
+					bridge = bridge1;
+			}
+			else
+		    #endif
 			ret= rtl_getMulticastDataFwdInfo(brIgmpModuleIndex, &multicastDataInfo, &multicastFwdInfo);
-			
+
 			//printk("%s:%d,ret is %d\n",__FUNCTION__,__LINE__,ret);
-			 if((ret!=0)||multicastFwdInfo.reservedMCast ||multicastFwdInfo.unknownMCast) 
+			 if((ret!=0)||multicastFwdInfo.reservedMCast || multicastFwdInfo.unknownMCast)
 			{
+				if( multicastFwdInfo.unknownMCast && 
+					(strncmp(skb->dev->name,RTL_PS_WAN0_DEV_NAME,4)==0) && 		//only block heavyloading multicast data from wan
+					(rtl865x_checkUnknownMCastLoading(&multicastDataInfo)==BLOCK_UNKNOWN_MULTICAST))
+				{
+					if((skb->srcVlanId!=0) && (skb->srcPort!=0xFFFF))
+					{
+						rtl865x_blockMulticastFlow(srcVlanId, srcPort, iph->saddr,iph->daddr);
+					}
+					else
+					{
+						kfree_skb(skb);
+						return 0;
+					}
+				}
 				return -1;
 			}
 
@@ -404,21 +576,31 @@ int rtl865x_ipMulticastFastFwd(struct sk_buff *skb)
 				}
 			}
 			#endif
-			
+
 			skb_push(skb, ETH_HLEN);
-			
+
 			prev = NULL;
 			fwdCnt=0;
-			list_for_each_entry_safe(p, n, &bridge0->port_list, list) 
+
+        #ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+			list_for_each_entry_safe(p, n, &bridge->port_list, list) 
+		#else
+			list_for_each_entry_safe(p, n, &bridge0->port_list, list)
+		#endif
 			{
 				port_bitmask = (1 << p->port_no);
-				if ((port_bitmask & multicastFwdInfo.fwdPortMask) && (skb->dev != p->dev && p->state == BR_STATE_FORWARDING)) 
+				if ((port_bitmask & multicastFwdInfo.fwdPortMask) && (skb->dev != p->dev && p->state == BR_STATE_FORWARDING))
 				{
-					if (prev != NULL) 
-					{                                                                                       
-						if ((skb2 = skb_clone(skb, GFP_ATOMIC)) == NULL) 
+					if (prev != NULL)
+					{
+						if ((skb2 = skb_clone(skb, GFP_ATOMIC)) == NULL)
 						{
+							LOG_MEM_ERROR("%s(%d) skb clone failed, drop it\n", __FUNCTION__, __LINE__);
+                            #ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+							bridge->dev->stats.tx_dropped++;
+			    			#else
 							bridge0->dev->stats.tx_dropped++;
+							#endif
 							kfree_skb(skb);
 							return 0;
 						}
@@ -428,15 +610,15 @@ int rtl865x_ipMulticastFastFwd(struct sk_buff *skb)
 						prev->dev->hard_start_xmit(skb2, prev->dev);
 						#else
 						prev->dev->netdev_ops->ndo_start_xmit(skb2,prev->dev);
-						#endif                  
+						#endif
 						fwdCnt++;
 					}
-						                                                                               
+
 					prev = p;
 				}
 			}
 
-			if (prev != NULL) 
+			if (prev != NULL)
 			{
 				skb->dev=prev->dev;
 				//printk("%s:%d,prev->dev->name is %s\n",__FUNCTION__,__LINE__,prev->dev->name);
@@ -444,7 +626,7 @@ int rtl865x_ipMulticastFastFwd(struct sk_buff *skb)
 				prev->dev->hard_start_xmit(skb, prev->dev);
 				#else
 				prev->dev->netdev_ops->ndo_start_xmit(skb,prev->dev);
-				#endif                            
+				#endif
 				fwdCnt++;
 			}
 
@@ -454,7 +636,7 @@ int rtl865x_ipMulticastFastFwd(struct sk_buff *skb)
 				skb_pull(skb, ETH_HLEN);
 				return -1;
 			}
-			
+
 			return 0;
 
 		}
@@ -470,14 +652,14 @@ int rtl865x_ipMulticastFastFwd(struct sk_buff *skb)
 		{
 			return -1;
 		}
-		
+
 		/*due to ipv6 passthrough*/
 		p= rcu_dereference(skb->dev->br_port);
 		if(p==NULL)
 		{
 			return -1;
 		}
-		
+
 		//printk("%s:%d,skb->dev->name is %s\n",__FUNCTION__,__LINE__,skb->dev->name );
 		ptr=(unsigned char *)eth_hdr(skb)+12;
 		/*check vlan tag exist or not*/
@@ -491,13 +673,13 @@ int rtl865x_ipMulticastFastFwd(struct sk_buff *skb)
 		{
 			return -1;
 		}
-		
+
 		ipv6h=(struct ipv6hdr *)(ptr+2);
 		proto =  re865x_getIpv6TransportProtocol(ipv6h);
-		
+
 		//printk("%s:%d,proto is %d\n",__FUNCTION__,__LINE__,proto);
 		 if((proto ==IPPROTO_UDP) ||(proto ==IPPROTO_TCP))
-		{			
+		{
 			multicastDataInfo.ipVersion=6;
 			memcpy(&multicastDataInfo.sourceIp, &ipv6h->saddr, sizeof(struct in6_addr));
 			memcpy(&multicastDataInfo.groupAddr, &ipv6h->daddr, sizeof(struct in6_addr));
@@ -519,23 +701,23 @@ int rtl865x_ipMulticastFastFwd(struct sk_buff *skb)
 				{
 					return -1;
 				}
-	
+
 			}
-			
+
 			//printk("%s:%d,multicastFwdInfo.fwdPortMask is 0x%x\n",__FUNCTION__,__LINE__,multicastFwdInfo.fwdPortMask);
-			
+
 			skb_push(skb, ETH_HLEN);
 
 			prev = NULL;
 			fwdCnt=0;
-			list_for_each_entry_safe(p, n, &bridge0->port_list, list) 
+			list_for_each_entry_safe(p, n, &bridge0->port_list, list)
 			{
 				port_bitmask = (1 << p->port_no);
-				if ((port_bitmask & multicastFwdInfo.fwdPortMask) && (skb->dev != p->dev && p->state == BR_STATE_FORWARDING)) 
+				if ((port_bitmask & multicastFwdInfo.fwdPortMask) && (skb->dev != p->dev && p->state == BR_STATE_FORWARDING))
 				{
-					if (prev != NULL) 
-					{                                                                                       
-						if ((skb2 = skb_clone(skb, GFP_ATOMIC)) == NULL) 
+					if (prev != NULL)
+					{
+						if ((skb2 = skb_clone(skb, GFP_ATOMIC)) == NULL)
 						{
 							kfree_skb(skb);
 							return 0;
@@ -546,15 +728,15 @@ int rtl865x_ipMulticastFastFwd(struct sk_buff *skb)
 						prev->dev->hard_start_xmit(skb2, prev->dev);
 						#else
 						prev->dev->netdev_ops->ndo_start_xmit(skb2,prev->dev);
-						#endif                             
+						#endif
 						fwdCnt++;
 					}
-						                                                                               
+
 					prev = p;
 				}
 			}
 
-			if (prev != NULL) 
+			if (prev != NULL)
 			{
 				skb->dev=prev->dev;
 				//printk("%s:%d,prev->dev->name is %s\n",__FUNCTION__,__LINE__,prev->dev->name);
@@ -562,25 +744,25 @@ int rtl865x_ipMulticastFastFwd(struct sk_buff *skb)
 				prev->dev->hard_start_xmit(skb, prev->dev);
 				#else
 				prev->dev->netdev_ops->ndo_start_xmit(skb,prev->dev);
-				#endif                            
+				#endif
 				fwdCnt++;
 			}
-			
+
 			if(fwdCnt==0)
 			{
 				//printk("%s:%d\n",__FUNCTION__,__LINE__);
 				/*avoid memory leak*/
 				skb_pull(skb, ETH_HLEN);
-				return -1;	
+				return -1;
 			}
-				
-			return 0;	
+
+			return 0;
 		}
 
 	}
 #endif
 
-	return -1;	
+	return -1;
 }
 
 #endif
diff --git a/net/bridge/br_if.c b/net/bridge/br_if.c
index b1f6608..484a513 100644
--- a/net/bridge/br_if.c
+++ b/net/bridge/br_if.c
@@ -32,6 +32,11 @@ struct net_bridge *bridge0=NULL;
 unsigned int brIgmpModuleIndex=0xFFFFFFFF;
 unsigned int br0SwFwdPortMask=0xFFFFFFFF;
 extern void br_mCastQueryTimerExpired(unsigned long arg);
+#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+struct net_bridge *bridge1=NULL;
+unsigned int brIgmpModuleIndex_2=0xFFFFFFFF;
+unsigned int br1SwFwdPortMask=0xFFFFFFFF;
+#endif
 #endif
 
 #if defined (CONFIG_RTL_STP)
@@ -266,7 +271,6 @@ static struct net_device *new_bridge_dev(struct net *net, const char *name)
 	br->ageing_time = 300 * HZ;
 
 #if defined (CONFIG_RTK_MESH)
-
 	br->eth0_monitor_interval = MESH_PORTAL_EXPIRE * HZ;
 	br->mesh_pathsel_pid=0;
 #if defined (STP_ADDCOST_ETH)
@@ -460,7 +464,7 @@ int br_set_meshpathsel_pid(int pid)
 	if( !pid )
 		br->eth0_received = 0;
 
-	//printk("Receive Pathsel daemon pid:%d\n",br->mesh_pathsel_pid);
+	printk("Receive Pathsel daemon pid:%d\n",br->mesh_pathsel_pid);
 	return 1;
 }
 #endif
@@ -544,9 +548,34 @@ int br_add_bridge(struct net *net, const char *name)
 			add_timer(&bridge0->mCastQuerytimer);
 		}
 		
-		rtl_setIpv4UnknownMCastFloodMap(brIgmpModuleIndex, 0x0);
+		rtl_setIpv4UnknownMCastFloodMap(brIgmpModuleIndex, 0xFFFFFFFF);
 		rtl_setIpv6UnknownMCastFloodMap(brIgmpModuleIndex, 0xFFFFFFFF);
 	}
+    #ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+	if(strcmp(name,RTL_PS_BR1_DEV_NAME)==0)
+	{
+		rtl_multicastDeviceInfo_t devInfo2;
+		memset(&devInfo2, 0, sizeof(rtl_multicastDeviceInfo_t ));
+		strcpy(devInfo2.devName, RTL_PS_BR1_DEV_NAME);
+		
+		ret=rtl_registerIgmpSnoopingModule(&brIgmpModuleIndex_2);
+		#if defined (CONFIG_RTL_HARDWARE_MULTICAST)
+		if(ret==0)
+		{
+			 rtl_setIgmpSnoopingModuleDevInfo(brIgmpModuleIndex_2,&devInfo2);
+		}
+		#endif
+		bridge1=netdev_priv(dev);
+		if(bridge1!=NULL)
+		{
+			init_timer(&bridge1->mCastQuerytimer);
+			bridge1->mCastQuerytimer.data=bridge1;
+			bridge1->mCastQuerytimer.expires=jiffies+MCAST_QUERY_INTERVAL*HZ;
+			bridge1->mCastQuerytimer.function=(void*)br_mCastQueryTimerExpired;
+			add_timer(&bridge1->mCastQuerytimer);
+		}
+	}
+#endif
 #endif
  out:
 	rtnl_unlock();
@@ -592,6 +621,19 @@ int br_del_bridge(struct net *net, const char *name)
 		#endif
 		bridge0=NULL;
 	}
+    #ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+	if(strcmp(name,RTL_PS_BR1_DEV_NAME)==0)
+	{
+		rtl_unregisterIgmpSnoopingModule(brIgmpModuleIndex_2);
+		#if defined (CONFIG_RTL_MLD_SNOOPING)
+		if(bridge1 && timer_pending(&bridge1->mCastQuerytimer))
+		{
+			del_timer(&bridge1->mCastQuerytimer);
+		}
+		#endif
+		bridge1=NULL;
+	}
+	#endif
 	#endif
 
 	rtnl_unlock();
diff --git a/net/bridge/br_input.c b/net/bridge/br_input.c
index 70f9be5..f18cc2f 100644
--- a/net/bridge/br_input.c
+++ b/net/bridge/br_input.c
@@ -42,6 +42,11 @@ extern int mldSnoopEnabled;
 extern unsigned int brIgmpModuleIndex;
 extern unsigned int br0SwFwdPortMask;
 
+#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+extern unsigned int brIgmpModuleIndex_2;
+extern unsigned int br1SwFwdPortMask;
+#endif
+
 #if defined (MCAST_TO_UNICAST)
 extern int IGMPProxyOpened;
 
@@ -55,7 +60,7 @@ static char ICMPv6_check(struct sk_buff *skb , unsigned char *gmac);
 
 #endif	//end of MCAST_TO_UNICAST
 
-#if defined(CONFIG_DOMAIN_NAME_QUERY_SUPPORT)
+#if defined(CONFIG_DOMAIN_NAME_QUERY_SUPPORT) || defined(CONFIG_RTL_ULINKER)
 #include <net/udp.h>
 #endif
 
@@ -64,7 +69,7 @@ static void br_update_igmp_snoop_fdb(unsigned char op, struct net_bridge *br, st
 									,struct sk_buff *skb);
 #endif	//end of CONFIG_RTL_IGMP_SNOOPING
 
-#if defined(CONFIG_DOMAIN_NAME_QUERY_SUPPORT)
+#if defined(CONFIG_DOMAIN_NAME_QUERY_SUPPORT) || defined(CONFIG_RTL_ULINKER)
 extern int br_filter_enter(struct sk_buff *skb);
 extern unsigned char dut_br0_mac[];
 extern unsigned char Filter_State;
@@ -423,7 +428,7 @@ int br_handle_frame_finish(struct sk_buff *skb)
 	}
 #endif
 
-#if defined(CONFIG_DOMAIN_NAME_QUERY_SUPPORT)
+#if defined(CONFIG_DOMAIN_NAME_QUERY_SUPPORT) || defined(CONFIG_RTL_ULINKER)
 	if(enable_filter){			
 		if(br_filter_enter(skb))
 			goto drop;
@@ -594,7 +599,12 @@ ap_hcm_out:
 		{
 
 			iph=(struct iphdr *)skb_network_header(skb);
-			if(iph->daddr== 0xEFFFFFFA)
+			#if defined(CONFIG_USB_UWIFI_HOST)
+				if(iph->daddr == 0xEFFFFFFA || iph->daddr == 0xE1010101)
+			#else
+				if(iph->daddr == 0xEFFFFFFA)
+			#endif
+			
 			{
 				/*for microsoft upnp*/
 				reserved=1;
@@ -610,11 +620,25 @@ ap_hcm_out:
 				//filter igmp pkts by upper hook like iptables 
 				if(IgmpRxFilter_Hook != NULL)
 				{
+					struct net_device	*origDev=skb->dev;
+					if((skb->dev->br_port) && (skb->dev->br_port->br))
+					{
+						skb->dev=skb->dev->br_port->br->dev;
+					}
+					
 					if(IgmpRxFilter_Hook(skb, NF_INET_PRE_ROUTING,  skb->dev, NULL,dev_net(skb->dev)->ipv4.iptable_filter) !=NF_ACCEPT)
 					{
+						skb->dev=origDev;
 						DEBUG_PRINT(" filter a pkt:%d %s:% \n", k, skb->dev->name, &(dev_net(skb->dev)->ipv4.iptable_filter->name[0]));
 						goto drop;
 					}
+					else
+					{
+						skb->dev=origDev;
+					}
+						
+					
+					
 				}else
 					DEBUG_PRINT("IgmpRxFilter_Hook is NULL\n");
 #endif
@@ -629,6 +653,15 @@ ap_hcm_out:
 					}
 				}
 				
+                #ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+				if(!strcmp(br->dev->name,RTL_PS_BR1_DEV_NAME))
+				{
+					rtl_igmpMldProcess(brIgmpModuleIndex_2, skb_mac_header(skb), p->port_no, &fwdPortMask);
+					//flooding igmp packet
+					fwdPortMask=(~(1<<(p->port_no))) & 0xFFFFFFFF;
+				}
+				else
+				#endif
 				rtl_igmpMldProcess(brIgmpModuleIndex, skb_mac_header(skb), p->port_no, &fwdPortMask);
 				br_multicast_forward(br, fwdPortMask, skb, 0);
 			}
@@ -640,6 +673,13 @@ ap_hcm_out:
 				multicastDataInfo.sourceIp[0]=  (uint32)(iph->saddr);
 				multicastDataInfo.groupAddr[0]=  (uint32)(iph->daddr);
 				
+                #ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+				if(!strcmp(br->dev->name,RTL_PS_BR1_DEV_NAME))
+				{
+					ret= rtl_getMulticastDataFwdInfo(brIgmpModuleIndex_2, &multicastDataInfo, &multicastFwdInfo);
+				}
+				else
+				#endif
 				ret= rtl_getMulticastDataFwdInfo(brIgmpModuleIndex, &multicastDataInfo, &multicastFwdInfo);
 				br_multicast_forward(br, multicastFwdInfo.fwdPortMask, skb, 0);
 				if((ret==SUCCESS) && (multicastFwdInfo.cpuFlag==0))
@@ -732,7 +772,7 @@ ap_hcm_out:
 			br_forward(dst->dst, skb);
 		else
 			br_flood_forward(br, skb);
-	}
+	}	
 #else 
 
 		if (dst)
@@ -786,7 +826,7 @@ struct sk_buff *br_handle_frame(struct net_bridge_port *p, struct sk_buff *skb)
 
 	skb = skb_share_check(skb, GFP_ATOMIC);
 	if (!skb)
-		return NULL;
+		return NULL;	
 
 	if (unlikely(is_link_local(dest))) {
 		/* Pause frames shouldn't be passed up by driver anyway */
diff --git a/net/bridge/br_ioctl.c b/net/bridge/br_ioctl.c
index 00385fd..9eb7bcf 100644
--- a/net/bridge/br_ioctl.c
+++ b/net/bridge/br_ioctl.c
@@ -406,6 +406,7 @@ static int old_deviceless(struct net *net, void __user *uarg)
 	{
 		return br_set_meshpathsel_pid(args[1]);
 	}
+	/*
 	case BRCTL_GET_PORTSTAT:
 	{
 		struct net_bridge *br;
@@ -429,6 +430,7 @@ static int old_deviceless(struct net *net, void __user *uarg)
 
 			return br->eth0_received;
 	}
+	*/
 #endif
 
 #if defined (CONFIG_RTL_IGMP_SNOOPING)
diff --git a/net/bridge/br_stp.c b/net/bridge/br_stp.c
index 4846a15..52492cc 100644
--- a/net/bridge/br_stp.c
+++ b/net/bridge/br_stp.c
@@ -334,10 +334,10 @@ void br_config_bpdu_generation(struct net_bridge *br)
 				if(memcmp((void *)(p->dev->name), "eth0", 4)==0)
 					continue;
 #endif
-			br_transmit_config(p);
+				br_transmit_config(p);
+			}
 	}
 }
-}
 
 /* called under bridge lock */
 static inline void br_reply(struct net_bridge_port *p)
@@ -390,7 +390,7 @@ static void br_make_blocking(struct net_bridge_port *p)
 		if (p->state == BR_STATE_FORWARDING ||
 		    p->state == BR_STATE_LEARNING)
 			br_topology_change_detection(p->br);
-
+		
 #if defined (CONFIG_RTK_MESH)
 #if 0
 #if defined (STP_DISABLE_ETH)
diff --git a/net/bridge/pocket_filter.c b/net/bridge/pocket_filter.c
index 05c2d80..60f9558 100644
--- a/net/bridge/pocket_filter.c
+++ b/net/bridge/pocket_filter.c
@@ -1,505 +1,553 @@
-#include <linux/config.h>
-#include <linux/module.h>
-#include <linux/proc_fs.h>
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/sched.h>
-#include <linux/kernel.h>
-#include <linux/kernel_stat.h>
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/slab.h>
-#include <asm/uaccess.h>
-//#include <linux/brlock.h>
-#include <linux/net.h>
-#include <linux/socket.h>
-
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/string.h>
-#include <net/ip.h>
-#include <net/protocol.h>
-#include <net/route.h>
-#include <net/sock.h>
-#include <net/arp.h>
-#include <net/raw.h>
-#include <net/checksum.h>
-#include <linux/netfilter.h>
-#include <linux/netfilter_ipv4.h>
-#include <linux/netlink.h>
-#include <net/udp.h>
-#include <net/rtl/rtl865x_netif.h>
-#include <net/rtl/rtl_nic.h>
-#if defined(CONFIG_HTTP_FILE_SERVER_SUPPORT)
-extern void get_lan_ip_mask(void);
-#endif
-#define OPT_CODE 0
-#define OPT_LEN 1
-#define OPT_DATA 2
-#define OPTION_FIELD		0
-#define FILE_FIELD		1
-#define SNAME_FIELD		2
-/* DHCP option codes (partial list) */
-#define DHCP_PADDING		0x00
-#define DHCP_SUBNET		0x01
-#define DHCP_TIME_OFFSET	0x02
-#define DHCP_ROUTER		0x03
-#define DHCP_TIME_SERVER	0x04
-#define DHCP_NAME_SERVER	0x05
-#define DHCP_DNS_SERVER		0x06
-#define DHCP_LOG_SERVER		0x07
-#define DHCP_COOKIE_SERVER	0x08
-#define DHCP_LPR_SERVER		0x09
-#define DHCP_HOST_NAME		0x0c
-#define DHCP_BOOT_SIZE		0x0d
-#define DHCP_DOMAIN_NAME	0x0f
-#define DHCP_SWAP_SERVER	0x10
-#define DHCP_ROOT_PATH		0x11
-#define DHCP_IP_TTL		0x17
-#define DHCP_MTU		0x1a
-#define DHCP_BROADCAST		0x1c
-#define DHCP_STATIC_ROUTE	0x21 
-#define DHCP_NTP_SERVER		0x2a
-#define DHCP_WINS_SERVER	0x2c
-#define DHCP_REQUESTED_IP	0x32
-#define DHCP_LEASE_TIME		0x33
-#define DHCP_OPTION_OVER	0x34
-#define DHCP_MESSAGE_TYPE	0x35
-#define DHCP_SERVER_ID		0x36
-#define DHCP_PARAM_REQ		0x37
-#define DHCP_MESSAGE		0x38
-#define DHCP_MAX_SIZE		0x39
-#define DHCP_T1			0x3a
-#define DHCP_T2			0x3b
-#define DHCP_VENDOR		0x3c
-#define DHCP_CLIENT_ID		0x3d
-#define DHCP_NETBIOS_NODETYPE 0x2e
-#define DHCP_NETBIOS_SCOPE 0x2F
-#define DHCP_END		0xFF
-int br_filter_mangle_udp_packet(struct sk_buff **skb, unsigned int match_offset,unsigned int match_len,unsigned char *rep_buffer, unsigned int rep_len);
-struct proc_dir_entry *filter_root=NULL;
-static struct proc_dir_entry *res1=NULL;
-static struct proc_dir_entry *res2=NULL;
-int enable_filter=0;
-static unsigned char filter_config[256];
-int dut_br0_ip=0;
-unsigned char dut_br0_mac[6]={0};
-unsigned char Filter_State=0;
-struct dhcpMessage {
-	unsigned char op;
-	unsigned char htype;
-	unsigned char hlen;
-	unsigned char hops;
-	unsigned int xid;
-	unsigned short secs;
-	unsigned short flags;
-	unsigned int ciaddr;
-	unsigned int yiaddr;
-	unsigned int siaddr;
-	unsigned int giaddr;
-	unsigned char chaddr[16];
-	unsigned char sname[64];
-	unsigned char file[128];
-	unsigned int cookie;
-	unsigned char options[308]; /* 312 - cookie */ 
-};
-
-struct udp_dhcp_packet {
-	struct iphdr ip;
-	struct udphdr udp;
-	struct dhcpMessage data;
-};
-
-static int br_filter_resize_packet(struct sk_buff **skb, int new_size)
-{
-	struct iphdr *iph;
-	
-
-
-	if (new_size > (*skb)->len + skb_tailroom(*skb)) {
-		struct sk_buff *newskb;
-		newskb = skb_copy_expand(*skb, skb_headroom(*skb), new_size - (*skb)->len,GFP_ATOMIC);
-
-		if (!newskb) {
-			return 0;
-		} else {
-			kfree_skb(*skb);
-			*skb = newskb;
-		}
-	}
-	
-	return 1;
-}
-
-int br_filter_mangle_udp_packet(struct sk_buff **skb, unsigned int match_offset,unsigned int match_len,unsigned char *rep_buffer, unsigned int rep_len)
-{
-	//struct iphdr *iph = (*skb)->nh.iph;
-	struct iphdr *iph = (struct iphdr *)skb_network_header(*skb);
-	struct udphdr *udph = (void *)iph + iph->ihl * 4;
-	unsigned char *data;
-	u_int32_t udplen, newlen, newudplen;
-
-	udplen = (*skb)->len - iph->ihl*4;
-	newudplen = udplen - match_len + rep_len;
-	newlen = iph->ihl*4 + newudplen;
-
-	/* UDP helpers might accidentally mangle the wrong packet */
-	if (udplen < sizeof(*udph) + match_offset + match_len) {
-		return 0;
-	}
-
-	if (newlen > 65535) {
-		return 0;
-	}
-
-	if ((*skb)->len != newlen) {
-		if (!br_filter_resize_packet(skb, newlen)) {
-			return 0;
-		}
-	}
-
-	/* skb may be copied !! */
-	//iph = (*skb)->nh.iph;
-	iph = (struct iphdr *)skb_network_header(*skb);
-	udph = (void *)iph + iph->ihl*4;
-	data = (void *)udph + sizeof(struct udphdr);
-
-	if (rep_len != match_len)
-		/* move post-replacement */
-		memmove(data + match_offset + rep_len,
-			data + match_offset + match_len,
-			(*skb)->tail - (data + match_offset + match_len));
-
-	/* insert data from buffer */
-	memcpy(data + match_offset, rep_buffer, rep_len);
-
-	/* update skb info */
-	if (newlen > (*skb)->len) {
-		
-		skb_put(*skb, newlen - (*skb)->len);
-	} else {
-		
-		skb_trim(*skb, newlen);
-	}
-
-	/* update the length of the UDP and IP packets to the new values*/
-	udph->len = htons((*skb)->len - iph->ihl*4);
-	iph->tot_len = htons(newlen);
-
-	/* fix udp checksum if udp checksum was previously calculated */
-	if (udph->check != 0) {
-		udph->check = 0;
-		udph->check = csum_tcpudp_magic(iph->saddr, iph->daddr,
-						newudplen, IPPROTO_UDP,
-						csum_partial((char *)udph,
-						             newudplen, 0));
-	}
-	ip_send_check(iph);
-
-	return 1;
-}
-unsigned char *br_filter_get_dhcp_option(struct dhcpMessage *packet, int code)
-{
-	int i, length;
-	unsigned char *optionptr=NULL;
-	int over = 0, done = 0, curr = OPTION_FIELD;
-	
-	optionptr = packet->options;
-	i = 0;
-	length = 308;
-	while (!done) {
-		if (i >= length) {
-			return NULL;
-		}
-		if (optionptr[i + OPT_CODE] == code) {
-			if (i + 1 + optionptr[i + OPT_LEN] >= length) {
-				return NULL;
-			}
-			return optionptr + i + 2;
-		}			
-		switch (optionptr[i + OPT_CODE]) {
-		case DHCP_PADDING:
-			i++;
-			break;
-		case DHCP_OPTION_OVER:
-			if (i + 1 + optionptr[i + OPT_LEN] >= length) {
-				return NULL;
-			}
-			over = optionptr[i + 3];
-			i += optionptr[OPT_LEN] + 2;
-			break;
-		case DHCP_END:
-			if (curr == OPTION_FIELD && over & FILE_FIELD) {
-				optionptr = packet->file;
-				i = 0;
-				length = 128;
-				curr = FILE_FIELD;
-			} else if (curr == FILE_FIELD && over & SNAME_FIELD) {
-				optionptr = packet->sname;
-				i = 0;
-				length = 64;
-				curr = SNAME_FIELD;
-			} else done = 1;
-			break;
-		default:
-			i += optionptr[OPT_LEN + i] + 2;
-		}
-	}
-	return NULL;
-}
-int br_filter_enter(struct sk_buff *skb)
-{
-	struct iphdr *iph;
-	struct udphdr *udph;
-	unsigned char *data_start;
-	struct udp_dhcp_packet *dhcp_packet=NULL;
-	//iph = skb->nh.iph;
-        iph = (struct iphdr *)skb_network_header(skb);
-	int i;
-	unsigned int match_offset=0;
-	unsigned int match_len=0;
-	unsigned char replace_buffer[6]={0};
-	unsigned char option_len=0,*temp;
-	if(enable_filter==0)
-		return 0;
-	else{
-		
-		udph=(void *) iph + iph->ihl*4;
-		//panic_printk("start to trace dhcp packet, dst port=%d\n",udph->dest);
-		if(iph->protocol==IPPROTO_UDP &&(udph->dest ==67 || udph->dest ==68)){
-			if(udph->dest ==67){//from Client host in dhcp 
-				//panic_printk("start to trace dhcp packet:client packet from :%s\n",skb->dev->name);
-				if(!strcmp(skb->dev->name, RTL_PS_LAN_P0_DEV_NAME)){
-					if(Filter_State==0){ 
-						//panic_printk("in this state, we drop client packet:Filter_State=%d\n",Filter_State);
-						return 1;
-					}
-				}
-				
-			}
-			
-			if(udph->dest ==68){//from server host in dhcp
-				if(Filter_State==1 || Filter_State==0){ //our dut has got ip address
-					dhcp_packet =(struct udp_dhcp_packet *)skb->data; 
-					if ((temp = br_filter_get_dhcp_option(&(dhcp_packet->data), DHCP_DNS_SERVER))) 
-					{
-						int roop=0;
-						unsigned char *router_temp, *subnet_temp;
-
-						router_temp = br_filter_get_dhcp_option(&(dhcp_packet->data), DHCP_ROUTER);
-
-						subnet_temp = br_filter_get_dhcp_option(&(dhcp_packet->data), DHCP_SUBNET);
-
-#if 0 //debug for domain name query						
-printk("\r\n DHCP_ROUTER=[%x.%x.%x.%x]__[%s-%u]\r\n",(unsigned char *)router_temp[0],
-(unsigned char *)router_temp[1], (unsigned char *)router_temp[2], (unsigned char *)router_temp[3], __FILE__,__LINE__);	
-
-printk("\r\n DHCP_SUBNET=[%x.%x.%x.%x]__[%s-%u]\r\n",(unsigned char *)subnet_temp[0],
-(unsigned char *)subnet_temp[1], (unsigned char *)subnet_temp[2], (unsigned char *)subnet_temp[3], __FILE__,__LINE__);
-
-	
-printk("\r\n dut_br0_ip=[%x.%x.%x.%x]__[%s-%u]\r\n",((unsigned char *)&dut_br0_ip)[0],
-((unsigned char *)&dut_br0_ip)[1], ((unsigned char *)&dut_br0_ip)[2], ((unsigned char *)&dut_br0_ip)[3], __FILE__,__LINE__);						
-
-printk("\r\n router_temp & subnet_temp=[%x],__[%s-%u]\r\n",((*(unsigned int*)router_temp) & (*(unsigned int*)subnet_temp)),__FILE__,__LINE__);
-printk("\r\n dut_br0_ip  & subnet_temp=[%x],__[%s-%u]\r\n",(dut_br0_ip & (*(unsigned int*)subnet_temp)),__FILE__,__LINE__);
-#endif //#if 0 //debug for domain name query
-
-						if(((*(unsigned int*)router_temp) & (*(unsigned int*)subnet_temp)) != (dut_br0_ip & (*(unsigned int*)subnet_temp)))
-						{
-							//printk("\r\n dut ip does not in the client's subnet. __[%s-%u]\r\n",__FILE__,__LINE__);
-							return 0;
-						}
-							
-						option_len = (temp-1)[0];
-						match_offset=(temp-2)-(unsigned char *)&(dhcp_packet->data);
-						match_len = option_len+2;
-						
-						replace_buffer[0]= DHCP_DNS_SERVER;
-						replace_buffer[1]=4;
-						replace_buffer[2]=((unsigned char *)&dut_br0_ip)[0];
-						replace_buffer[3]=((unsigned char *)&dut_br0_ip)[1];
-						replace_buffer[4]=((unsigned char *)&dut_br0_ip)[2];
-						replace_buffer[5]=((unsigned char *)&dut_br0_ip)[3];
-						if(replace_buffer[2] != 0 || replace_buffer[3] != 0 || replace_buffer[4] != 0 || replace_buffer[5] != 0){
-							//panic_printk("in this state, we mangle dhcp server packet, dns ip =%02X%02X%02X%02X\n",replace_buffer[2],replace_buffer[3],replace_buffer[4],replace_buffer[5]);
-							br_filter_mangle_udp_packet(&skb, match_offset, match_len, replace_buffer, 6);
-						}
-					}
-				}
-					
-					
-			}
-		}
-		return 0;
-	}
-}
-
-
-static int en_filter_proc_read(char *page, char **start, off_t off,
-		     int count, int *eof, void *data)
-{
-
-      int len=0;
-
-      len = sprintf(page, "%d\n", enable_filter);
-
-      if (len <= off+count) *eof = 1;
-      *start = page + off;
-      len -= off;
-      if (len>count) len = count;
-      if (len<0) len = 0;
-   	
-      return len;
-
-}
-
-static int filter_conf_proc_read(char *page, char **start, off_t off,
-		     int count, int *eof, void *data)
-{
-
-      int len=0;
-
-      len = sprintf(page, "%s\n", filter_config);
-
-
-      if (len <= off+count) *eof = 1;
-      *start = page + off;
-      len -= off;
-      if (len>count) len = count;
-      if (len<0) len = 0;
-      return len;
-
-}
-
-static int _is_hex_br_filter(char c)
-{
-	if(((c >= '0') && (c <= '9')) ||((c >= 'A') && (c <= 'F')) ||((c >= 'a') && (c <= 'f')))
-		return 1;
-	else
-    		return 0;
-}
-static int en_filter_proc_write(struct file *file, const char *buffer,
-		      unsigned long count, void *data)
-{
-      char tmpbuf[80];
-
-
-      if (count < 2)
-	    return -EFAULT;
-	    
-	if (buffer && !copy_from_user(tmpbuf, buffer, 80))  {
-		if (tmpbuf[0] == '0'){ 
-			enable_filter = 0;	
-		}else if (tmpbuf[0] == '1'){
-			enable_filter = 1;
-		}	    
-		return count;
-	}	
-      return -EFAULT;
-}
-int br_filter_string_to_hex(char *string, unsigned char *key, int len)
-{
-	char tmpBuf[4];
-	int idx, ii=0;
-	for (idx=0; idx<len; idx+=2) {
-		tmpBuf[0] = string[idx];
-		tmpBuf[1] = string[idx+1];
-		tmpBuf[2] = 0;
-		if ( !_is_hex_br_filter(tmpBuf[0]) || !_is_hex_br_filter(tmpBuf[1]))
-			return 0;
-
-		key[ii++] = (unsigned char) simple_strtol(tmpBuf, (char**)NULL, 16);
-	}
-	return 1;
-}
-static int filter_conf_proc_write(struct file *file, const char *buffer,
-		      unsigned long count, void *data)
-{
-      char tmpbuf[1024];
-      char *tokptr, *strptr=tmpbuf;
-	u_int8_t idx=1;
-	u_int32_t val;
-
-      if (count < 2)
-	    return -EFAULT;
-	memset(filter_config, 0x00, 256);
-      if (buffer && !copy_from_user(&filter_config, buffer, count)) {
-	      strncpy(tmpbuf,filter_config,count);
-	      while ((tokptr = strtok(strptr," ")) !=NULL)
-		{
-			strptr=NULL;
-			val=simple_strtol(tokptr,NULL,0);
-			switch(idx)
-			{
-			case 1:
-				val=simple_strtol(tokptr,NULL,16);
-				dut_br0_ip=val;
-				break;
-			case 2:
-				br_filter_string_to_hex(tokptr, dut_br0_mac, 12);
-				//panic_printk("dut mac=%02X:%02X:%02X:%02X:%02X:%02X\n",dut_br0_mac[0], dut_br0_mac[1], dut_br0_mac[2], dut_br0_mac[3],dut_br0_mac[4],dut_br0_mac[5]); 
-				break;
-			case 3:
-				val=simple_strtol(tokptr,NULL,10);
-				Filter_State=val;
-				//panic_printk("Filter_State=%d\n",Filter_State);
-				break;	
-			default:
-				break;
-			}
-			idx++;
-
-		}
-#if defined(CONFIG_HTTP_FILE_SERVER_SUPPORT)		
-		get_lan_ip_mask();
-#endif		
-	    return count;
-      }
-      return -EFAULT;
-}
-
-
-int __init br_filter_init(void)
-{
-#if defined(CONFIG_PROC_FS)
-
-	struct proc_dir_entry *devices = NULL,*pvc = NULL,*svc = NULL;
-	filter_root = proc_mkdir("pocket",NULL);
-	if (!filter_root){
-		printk("create folder fail\n");
-		return -ENOMEM;
-	}
-	res1 = create_proc_entry("en_filter", 0, filter_root);
-	if (res1) {
-		res1->read_proc = en_filter_proc_read;
-		res1->write_proc = en_filter_proc_write;
-	}
-
-	res2 = create_proc_entry("filter_conf", 0, filter_root);
-	if (res2) {
-		res2->read_proc = filter_conf_proc_read;
-		res2->write_proc = filter_conf_proc_write;
-	}
-	
-#endif // CONFIG_PROC_FS
-	return 0;
-}
-
-void __exit br_filter_exit(void)
-{
-#if defined(CONFIG_PROC_FS)
-	if (res1) {
-		remove_proc_entry("en_filter", filter_root);
-		res2 = NULL;
-	}
-	if (res2) {
-		remove_proc_entry("filter_conf", filter_root);
-		res2 = NULL;
-	}
-
-	remove_proc_entry("pocket",NULL);
-#endif // CONFIG_PROC_FS
-}
-
-
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/kernel_stat.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <asm/uaccess.h>
+//#include <linux/brlock.h>
+#include <linux/net.h>
+#include <linux/socket.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/string.h>
+#include <net/ip.h>
+#include <net/protocol.h>
+#include <net/route.h>
+#include <net/sock.h>
+#include <net/arp.h>
+#include <net/raw.h>
+#include <net/checksum.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter_ipv4.h>
+#include <linux/netlink.h>
+#include <net/udp.h>
+#include <net/rtl/rtl865x_netif.h>
+#include <net/rtl/rtl_nic.h>
+#if defined(CONFIG_RTL_USB_UWIFI_HOST_SPEEDUP) || defined(CONFIG_HTTP_FILE_SERVER_SUPPORT) || defined(CONFIG_RTL_ULINKER)
+extern void get_lan_ip_mask(void);
+#endif
+#define OPT_CODE 0
+#define OPT_LEN 1
+#define OPT_DATA 2
+#define OPTION_FIELD		0
+#define FILE_FIELD		1
+#define SNAME_FIELD		2
+/* DHCP option codes (partial list) */
+#define DHCP_PADDING		0x00
+#define DHCP_SUBNET		0x01
+#define DHCP_TIME_OFFSET	0x02
+#define DHCP_ROUTER		0x03
+#define DHCP_TIME_SERVER	0x04
+#define DHCP_NAME_SERVER	0x05
+#define DHCP_DNS_SERVER		0x06
+#define DHCP_LOG_SERVER		0x07
+#define DHCP_COOKIE_SERVER	0x08
+#define DHCP_LPR_SERVER		0x09
+#define DHCP_HOST_NAME		0x0c
+#define DHCP_BOOT_SIZE		0x0d
+#define DHCP_DOMAIN_NAME	0x0f
+#define DHCP_SWAP_SERVER	0x10
+#define DHCP_ROOT_PATH		0x11
+#define DHCP_IP_TTL		0x17
+#define DHCP_MTU		0x1a
+#define DHCP_BROADCAST		0x1c
+#define DHCP_STATIC_ROUTE	0x21
+#define DHCP_NTP_SERVER		0x2a
+#define DHCP_WINS_SERVER	0x2c
+#define DHCP_REQUESTED_IP	0x32
+#define DHCP_LEASE_TIME		0x33
+#define DHCP_OPTION_OVER	0x34
+#define DHCP_MESSAGE_TYPE	0x35
+#define DHCP_SERVER_ID		0x36
+#define DHCP_PARAM_REQ		0x37
+#define DHCP_MESSAGE		0x38
+#define DHCP_MAX_SIZE		0x39
+#define DHCP_T1			0x3a
+#define DHCP_T2			0x3b
+#define DHCP_VENDOR		0x3c
+#define DHCP_CLIENT_ID		0x3d
+#define DHCP_NETBIOS_NODETYPE 0x2e
+#define DHCP_NETBIOS_SCOPE 0x2F
+#define DHCP_END		0xFF
+int br_filter_mangle_udp_packet(struct sk_buff **skb, unsigned int match_offset,unsigned int match_len,unsigned char *rep_buffer, unsigned int rep_len);
+struct proc_dir_entry *filter_root=NULL;
+static struct proc_dir_entry *res1=NULL;
+static struct proc_dir_entry *res2=NULL;
+int enable_filter=0;
+static unsigned char filter_config[256];
+int dut_br0_ip=0;
+unsigned char dut_br0_mac[6]={0};
+unsigned char Filter_State=0;
+struct dhcpMessage {
+	unsigned char op;
+	unsigned char htype;
+	unsigned char hlen;
+	unsigned char hops;
+	unsigned int xid;
+	unsigned short secs;
+	unsigned short flags;
+	unsigned int ciaddr;
+	unsigned int yiaddr;
+	unsigned int siaddr;
+	unsigned int giaddr;
+	unsigned char chaddr[16];
+	unsigned char sname[64];
+	unsigned char file[128];
+	unsigned int cookie;
+	unsigned char options[308]; /* 312 - cookie */
+};
+
+struct udp_dhcp_packet {
+	struct iphdr ip;
+	struct udphdr udp;
+	struct dhcpMessage data;
+};
+
+static int br_filter_resize_packet(struct sk_buff **skb, int new_size)
+{
+	struct iphdr *iph;
+
+
+
+	if (new_size > (*skb)->len + skb_tailroom(*skb)) {
+		struct sk_buff *newskb;
+		newskb = skb_copy_expand(*skb, skb_headroom(*skb), new_size - (*skb)->len,GFP_ATOMIC);
+
+		if (!newskb) {
+			return 0;
+		} else {
+			kfree_skb(*skb);
+			*skb = newskb;
+		}
+	}
+
+	return 1;
+}
+
+int br_filter_mangle_udp_packet(struct sk_buff **skb, unsigned int match_offset,unsigned int match_len,unsigned char *rep_buffer, unsigned int rep_len)
+{
+	//struct iphdr *iph = (*skb)->nh.iph;
+	struct iphdr *iph = (struct iphdr *)skb_network_header(*skb);
+	struct udphdr *udph = (void *)iph + iph->ihl * 4;
+	unsigned char *data;
+	u_int32_t udplen, newlen, newudplen;
+
+	udplen = (*skb)->len - iph->ihl*4;
+	newudplen = udplen - match_len + rep_len;
+	newlen = iph->ihl*4 + newudplen;
+
+	/* UDP helpers might accidentally mangle the wrong packet */
+	if (udplen < sizeof(*udph) + match_offset + match_len) {
+		return 0;
+	}
+
+	if (newlen > 65535) {
+		return 0;
+	}
+
+	if ((*skb)->len != newlen) {
+		if (!br_filter_resize_packet(skb, newlen)) {
+			return 0;
+		}
+	}
+
+	/* skb may be copied !! */
+	//iph = (*skb)->nh.iph;
+	iph = (struct iphdr *)skb_network_header(*skb);
+	udph = (void *)iph + iph->ihl*4;
+	data = (void *)udph + sizeof(struct udphdr);
+
+	if (rep_len != match_len)
+		/* move post-replacement */
+		memmove(data + match_offset + rep_len,
+			data + match_offset + match_len,
+			(*skb)->tail - (data + match_offset + match_len));
+
+	/* insert data from buffer */
+	memcpy(data + match_offset, rep_buffer, rep_len);
+
+	/* update skb info */
+	if (newlen > (*skb)->len) {
+
+		skb_put(*skb, newlen - (*skb)->len);
+	} else {
+
+		skb_trim(*skb, newlen);
+	}
+
+	/* update the length of the UDP and IP packets to the new values*/
+	udph->len = htons((*skb)->len - iph->ihl*4);
+	iph->tot_len = htons(newlen);
+
+	/* fix udp checksum if udp checksum was previously calculated */
+	if (udph->check != 0) {
+		udph->check = 0;
+		udph->check = csum_tcpudp_magic(iph->saddr, iph->daddr,
+						newudplen, IPPROTO_UDP,
+						csum_partial((char *)udph,
+						             newudplen, 0));
+	}
+	ip_send_check(iph);
+
+	return 1;
+}
+unsigned char *br_filter_get_dhcp_option(struct dhcpMessage *packet, int code)
+{
+	int i, length;
+	unsigned char *optionptr=NULL;
+	int over = 0, done = 0, curr = OPTION_FIELD;
+
+	optionptr = packet->options;
+	i = 0;
+	length = 308;
+	while (!done) {
+		if (i >= length) {
+			return NULL;
+		}
+		if (optionptr[i + OPT_CODE] == code) {
+			if (i + 1 + optionptr[i + OPT_LEN] >= length) {
+				return NULL;
+			}
+			return optionptr + i + 2;
+		}
+		switch (optionptr[i + OPT_CODE]) {
+		case DHCP_PADDING:
+			i++;
+			break;
+		case DHCP_OPTION_OVER:
+			if (i + 1 + optionptr[i + OPT_LEN] >= length) {
+				return NULL;
+			}
+			over = optionptr[i + 3];
+			i += optionptr[OPT_LEN] + 2;
+			break;
+		case DHCP_END:
+			if (curr == OPTION_FIELD && over & FILE_FIELD) {
+				optionptr = packet->file;
+				i = 0;
+				length = 128;
+				curr = FILE_FIELD;
+			} else if (curr == FILE_FIELD && over & SNAME_FIELD) {
+				optionptr = packet->sname;
+				i = 0;
+				length = 64;
+				curr = SNAME_FIELD;
+			} else done = 1;
+			break;
+		default:
+			i += optionptr[OPT_LEN + i] + 2;
+		}
+	}
+	return NULL;
+}
+
+
+int br_filter_enter(struct sk_buff *skb)
+{
+	struct iphdr *iph;
+	struct udphdr *udph;
+	unsigned char *data_start;
+	struct udp_dhcp_packet *dhcp_packet=NULL;
+	//iph = skb->nh.iph;
+        iph = (struct iphdr *)skb_network_header(skb);
+	int i;
+	unsigned int match_offset=0;
+	unsigned int match_len=0;
+	unsigned char replace_buffer[6]={0};
+	unsigned char option_len=0,*temp;
+	if(enable_filter==0)
+		return 0;
+	else{
+
+	#if 0//defined(CONFIG_RTL_ULINKER)
+		if (skb) {
+			iph = (struct iphdr *)skb_network_header(skb);
+			if (iph) {}
+			else return 0;
+		}	else return 0;
+
+		/* if da is dut */
+		{
+			unsigned char *dst_mac;
+			dst_mac=(unsigned char*)(skb_mac_header(skb));
+
+			if (memcmp(dut_br0_mac, dst_mac, ETH_ALEN)==0)
+			{
+				//panic_printk("\r\n dst mac equal to dut_br0_mac. __[%s-%u]\r\n",__FILE__,__LINE__);
+				return 0;
+			}
+		}
+	#endif /* #if defined(CONFIG_RTL_ULINKER) */
+		
+		udph=(void *) iph + iph->ihl*4;
+		//panic_printk("start to trace dhcp packet, dst port=%d\n",udph->dest);
+		if(iph->protocol==IPPROTO_UDP &&(udph->dest ==67 || udph->dest ==68)){
+			if(udph->dest ==67){//from Client host in dhcp
+				//panic_printk("start to trace dhcp packet:client packet from :%s\n",skb->dev->name);
+				if(!strcmp(skb->dev->name, RTL_PS_LAN_P0_DEV_NAME)){
+					if(Filter_State==0){
+						//panic_printk("in this state, we drop client packet:Filter_State=%d\n",Filter_State);
+						return 1;
+					}
+				}
+
+			}
+
+			if(udph->dest ==68){//from server host in dhcp
+				if(Filter_State==1 || Filter_State==0){ //our dut has got ip address
+					dhcp_packet =(struct udp_dhcp_packet *)skb->data;
+					if ((temp = br_filter_get_dhcp_option(&(dhcp_packet->data), DHCP_DNS_SERVER)))
+					{
+						int roop=0;
+						unsigned char *router_temp, *subnet_temp;
+
+						router_temp = br_filter_get_dhcp_option(&(dhcp_packet->data), DHCP_ROUTER);
+
+						subnet_temp = br_filter_get_dhcp_option(&(dhcp_packet->data), DHCP_SUBNET);
+
+#if 0 //debug for domain name query
+printk("\r\n DHCP_ROUTER=[%x.%x.%x.%x]__[%s-%u]\r\n",(unsigned char *)router_temp[0],
+(unsigned char *)router_temp[1], (unsigned char *)router_temp[2], (unsigned char *)router_temp[3], __FILE__,__LINE__);
+
+printk("\r\n DHCP_SUBNET=[%x.%x.%x.%x]__[%s-%u]\r\n",(unsigned char *)subnet_temp[0],
+(unsigned char *)subnet_temp[1], (unsigned char *)subnet_temp[2], (unsigned char *)subnet_temp[3], __FILE__,__LINE__);
+
+
+printk("\r\n dut_br0_ip=[%x.%x.%x.%x]__[%s-%u]\r\n",((unsigned char *)&dut_br0_ip)[0],
+((unsigned char *)&dut_br0_ip)[1], ((unsigned char *)&dut_br0_ip)[2], ((unsigned char *)&dut_br0_ip)[3], __FILE__,__LINE__);
+
+printk("\r\n router_temp & subnet_temp=[%x],__[%s-%u]\r\n",((*(unsigned int*)router_temp) & (*(unsigned int*)subnet_temp)),__FILE__,__LINE__);
+printk("\r\n dut_br0_ip  & subnet_temp=[%x],__[%s-%u]\r\n",(dut_br0_ip & (*(unsigned int*)subnet_temp)),__FILE__,__LINE__);
+#endif //#if 0 //debug for domain name query
+
+						if(((*(unsigned int*)router_temp) & (*(unsigned int*)subnet_temp)) != (dut_br0_ip & (*(unsigned int*)subnet_temp)))
+						{
+							//printk("\r\n dut ip does not in the client's subnet. __[%s-%u]\r\n",__FILE__,__LINE__);
+							return 0;
+						}
+
+						option_len = (temp-1)[0];
+						match_offset=(temp-2)-(unsigned char *)&(dhcp_packet->data);
+						match_len = option_len+2;
+
+						replace_buffer[0]= DHCP_DNS_SERVER;
+						replace_buffer[1]=4;
+						replace_buffer[2]=((unsigned char *)&dut_br0_ip)[0];
+						replace_buffer[3]=((unsigned char *)&dut_br0_ip)[1];
+						replace_buffer[4]=((unsigned char *)&dut_br0_ip)[2];
+						replace_buffer[5]=((unsigned char *)&dut_br0_ip)[3];
+						if(replace_buffer[2] != 0 || replace_buffer[3] != 0 || replace_buffer[4] != 0 || replace_buffer[5] != 0){
+							//panic_printk("in this state, we mangle dhcp server packet, dns ip =%02X%02X%02X%02X\n",replace_buffer[2],replace_buffer[3],replace_buffer[4],replace_buffer[5]);
+							br_filter_mangle_udp_packet(&skb, match_offset, match_len, replace_buffer, 6);
+						}
+					}
+				}
+
+
+			}
+		}
+		return 0;
+	}
+}
+
+
+static int en_filter_proc_read(char *page, char **start, off_t off,
+		     int count, int *eof, void *data)
+{
+
+      int len=0;
+
+      len = sprintf(page, "%d\n", enable_filter);
+
+      if (len <= off+count) *eof = 1;
+      *start = page + off;
+      len -= off;
+      if (len>count) len = count;
+      if (len<0) len = 0;
+
+      return len;
+
+}
+
+static int filter_conf_proc_read(char *page, char **start, off_t off,
+		     int count, int *eof, void *data)
+{
+
+      int len=0;
+
+      len = sprintf(page, "%s\n", filter_config);
+
+
+      if (len <= off+count) *eof = 1;
+      *start = page + off;
+      len -= off;
+      if (len>count) len = count;
+      if (len<0) len = 0;
+      return len;
+
+}
+
+static int _is_hex_br_filter(char c)
+{
+	if(((c >= '0') && (c <= '9')) ||((c >= 'A') && (c <= 'F')) ||((c >= 'a') && (c <= 'f')))
+		return 1;
+	else
+    		return 0;
+}
+static int en_filter_proc_write(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+      char tmpbuf[80];
+
+
+      if (count < 2)
+	    return -EFAULT;
+
+	if (buffer && !copy_from_user(tmpbuf, buffer, 80))  {
+		if (tmpbuf[0] == '0'){
+			enable_filter = 0;
+		}else if (tmpbuf[0] == '1'){
+			enable_filter = 1;
+		}
+		return count;
+	}
+      return -EFAULT;
+}
+int br_filter_string_to_hex(char *string, unsigned char *key, int len)
+{
+	char tmpBuf[4];
+	int idx, ii=0;
+	for (idx=0; idx<len; idx+=2) {
+		tmpBuf[0] = string[idx];
+		tmpBuf[1] = string[idx+1];
+		tmpBuf[2] = 0;
+		if ( !_is_hex_br_filter(tmpBuf[0]) || !_is_hex_br_filter(tmpBuf[1]))
+			return 0;
+
+		key[ii++] = (unsigned char) simple_strtol(tmpBuf, (char**)NULL, 16);
+	}
+	return 1;
+}
+
+#if !defined(CONFIG_RTL_IPTABLES_FAST_PATH)
+#ifndef __HAVE_ARCH_STRTOK
+char * ___strtok;
+char * strtok(char * s,const char * ct)
+{
+	char *sbegin, *send;
+
+	sbegin  = s ? s : ___strtok;
+	if (!sbegin) {
+		return NULL;
+	}
+	sbegin += strspn(sbegin,ct);
+	if (*sbegin == '\0') {
+		___strtok = NULL;
+		return( NULL );
+	}
+	send = strpbrk( sbegin, ct);
+	if (send && *send != '\0')
+		*send++ = '\0';
+	___strtok = send;
+	return (sbegin);
+}
+#endif
+#endif
+
+static int filter_conf_proc_write(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+      char tmpbuf[1024];
+      char *tokptr, *strptr=tmpbuf;
+	u_int8_t idx=1;
+	u_int32_t val;
+
+      if (count < 2)
+	    return -EFAULT;
+	memset(filter_config, 0x00, 256);
+      if (buffer && !copy_from_user(&filter_config, buffer, count)) {
+	      strncpy(tmpbuf,filter_config,count);
+	      while ((tokptr = strtok(strptr," ")) !=NULL)
+		{
+			strptr=NULL;
+			val=simple_strtol(tokptr,NULL,0);
+			switch(idx)
+			{
+			case 1:
+				val=simple_strtol(tokptr,NULL,16);
+				dut_br0_ip=val;
+				break;
+			case 2:
+				br_filter_string_to_hex(tokptr, dut_br0_mac, 12);
+				//panic_printk("dut mac=%02X:%02X:%02X:%02X:%02X:%02X\n",dut_br0_mac[0], dut_br0_mac[1], dut_br0_mac[2], dut_br0_mac[3],dut_br0_mac[4],dut_br0_mac[5]);
+				break;
+			case 3:
+				val=simple_strtol(tokptr,NULL,10);
+				Filter_State=val;
+				//panic_printk("Filter_State=%d\n",Filter_State);
+				break;
+			default:
+				break;
+			}
+			idx++;
+
+		}
+#if defined(CONFIG_RTL_USB_UWIFI_HOST_SPEEDUP) || defined(CONFIG_HTTP_FILE_SERVER_SUPPORT)
+		get_lan_ip_mask();
+#endif
+	    return count;
+      }
+      return -EFAULT;
+}
+
+
+int __init br_filter_init(void)
+{
+#if defined(CONFIG_PROC_FS)
+
+	struct proc_dir_entry *devices = NULL,*pvc = NULL,*svc = NULL;
+	filter_root = proc_mkdir("pocket",NULL);
+	if (!filter_root){
+		printk("create folder fail\n");
+		return -ENOMEM;
+	}
+	res1 = create_proc_entry("en_filter", 0, filter_root);
+	if (res1) {
+		res1->read_proc = en_filter_proc_read;
+		res1->write_proc = en_filter_proc_write;
+	}
+
+	res2 = create_proc_entry("filter_conf", 0, filter_root);
+	if (res2) {
+		res2->read_proc = filter_conf_proc_read;
+		res2->write_proc = filter_conf_proc_write;
+	}
+
+#endif // CONFIG_PROC_FS
+	return 0;
+}
+
+void __exit br_filter_exit(void)
+{
+#if defined(CONFIG_PROC_FS)
+	if (res1) {
+		remove_proc_entry("en_filter", filter_root);
+		res2 = NULL;
+	}
+	if (res2) {
+		remove_proc_entry("filter_conf", filter_root);
+		res2 = NULL;
+	}
+
+	remove_proc_entry("pocket",NULL);
+#endif // CONFIG_PROC_FS
+}
+
+
diff --git a/net/core/dev.c b/net/core/dev.c
index e587642..fdffb51 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -128,14 +128,19 @@
 #include <linux/random.h>
 
 #include <net/rtl/rtl_types.h>
+
+
+#if defined(CONFIG_RTL_BATTLENET_ALG)
 #include <linux/inetdevice.h>
+#include <net/rtl/rtl_nic.h>
+#endif
 
 #include "net-sysfs.h"
 
 #if	defined(CONFIG_RTL_819X)
 #include <net/rtl/features/rtl_ps_hooks.h>
 #endif
-
+#include <net/rtl/features/rtl_ps_log.h>
 /* Instead of increasing this, you should create a hash table. */
 #define MAX_GRO_SKBS 8
 
@@ -1171,6 +1176,14 @@ int dev_close(struct net_device *dev)
 
 	dev->flags &= ~IFF_UP;
 
+#if defined(CONFIG_RTL_FASTBRIDGE)
+	/*
+	 *	Clear fast bridge related cache.
+	 */
+	printk("[%s] closed\n", dev->name);
+	rtl_fb_flush_by_dev(dev);
+#endif
+
 	/*
 	 * Tell people we are down
 	 */
@@ -1407,19 +1420,19 @@ void __netif_schedule(struct Qdisc *q)
 EXPORT_SYMBOL(__netif_schedule);
 
 #if defined(CONFIG_RTL_ETH_PRIV_SKB_DEBUG)
-extern int is_rtl865x_eth_priv_buf(unsigned char *head);
+__MIPS16 __IRAM_FWD  extern int is_rtl865x_eth_priv_buf(unsigned char *head);
 int get_cpu_completion_queue_num(void)
 {
-	int skbCnt = 0;	
+	int skbCnt = 0;
 	struct softnet_data *sd = &__get_cpu_var(softnet_data);
 	struct sk_buff *clist = sd->completion_queue;
 
-	while (clist) 
+	while (clist)
 	{
 		if(is_rtl865x_eth_priv_buf(clist->head))
 			skbCnt++;
-		clist = clist->next;			
-	}	
+		clist = clist->next;
+	}
 
 	return skbCnt;
 }
@@ -1889,7 +1902,7 @@ gso:
 			if(gQosEnabled)
 				__netif_schedule(q);
 			else
-			qdisc_run(q);
+				qdisc_run(q);
 #else
 			qdisc_run(q);
 #endif
@@ -1959,6 +1972,60 @@ int netdev_budget __read_mostly = 128;	//300;
 int weight_p __read_mostly = 128;		//64;            /* old backlog weight */
 
 DEFINE_PER_CPU(struct netif_rx_stats, netdev_rx_stat) = { 0, };
+#if defined(CONFIG_RTL_BATTLENET_ALG)
+extern int rtl865x_curOpMode;
+struct net_device *rtl865x_getBattleNetWanDev(void )
+{
+	struct net_device * wanDev=NULL;
+
+	if(rtl865x_curOpMode==GATEWAY_MODE)
+	{
+		wanDev=__dev_get_by_name(&init_net,"ppp0");
+		if(wanDev == NULL)
+			wanDev=__dev_get_by_name(&init_net,"eth1");
+	}
+	else if(rtl865x_curOpMode==WISP_MODE)
+	{
+		wanDev=__dev_get_by_name(&init_net,"wlan0");
+	}
+	else if(rtl865x_curOpMode==BRIDGE_MODE)
+	{
+		wanDev=__dev_get_by_name(&init_net,"br0");
+	}
+
+	return wanDev;
+}
+
+int rtl865x_getBattleNetDevIpAndNetmask(struct net_device * dev, unsigned int *ipAddr, unsigned int *netMask )
+{
+	struct in_device *in_dev;
+	struct in_ifaddr *ifap = NULL;
+
+	if((dev==NULL) || (ipAddr==NULL) || (netMask==NULL))
+	{
+		return FAILED;
+	}
+
+	*ipAddr=0;
+	*netMask=0;
+
+	in_dev=(struct net_device *)(dev->ip_ptr);
+	if (in_dev != NULL) {
+		for (ifap=in_dev->ifa_list; ifap != NULL; ifap=ifap->ifa_next) {
+			if (strcmp(dev->name, ifap->ifa_label) == 0){
+				*ipAddr = ifap->ifa_address;
+				*netMask = ifap->ifa_mask;
+				return SUCCESS;
+			}
+		}
+
+	}
+
+	return FAILED;
+
+}
+
+#endif
 
 /**
  *	netif_rx	-	post buffer to the network code
@@ -1987,7 +2054,7 @@ int netif_rx(struct sk_buff *skb)
 	if (!skb->tstamp.tv64)
 		net_timestamp(skb);
 
-	
+
 	/*
 	 * The code is rearranged so that the path is the most
 	 * short when CPU is congested, but is still operating.
@@ -5293,7 +5360,7 @@ static int __init net_dev_init(void)
 	netdev_max_backlog = 512;	//1000;
 	netdev_budget = 128;	//300;
 	weight_p = 128;		//64;            /* old backlog weight */
-	
+
 	BUG_ON(!dev_boot_phase);
 
 	if (dev_proc_init())
diff --git a/net/core/dst.c b/net/core/dst.c
index cbaa60a..d2eea6a 100644
--- a/net/core/dst.c
+++ b/net/core/dst.c
@@ -205,7 +205,7 @@ void * dst_alloc(struct dst_ops * ops)
 			rtl_dst_alloc_gc_post_check1_hooks(ops);
 			
 			return NULL;
-	}
+		}
 	}
 
 //hyking:so .....	
diff --git a/net/core/neighbour.c b/net/core/neighbour.c
index 637221d..3cd254f 100644
--- a/net/core/neighbour.c
+++ b/net/core/neighbour.c
@@ -170,7 +170,7 @@ static int neigh_forced_gc(struct neigh_table *tbl)
 				/*delete asic arp entry*/
 				rtl_neigh_forced_gc_hooks(tbl, n);
 				#endif
-				
+
 				write_unlock(&n->lock);
 				neigh_cleanup_and_release(n);
 				continue;
@@ -253,7 +253,7 @@ static void neigh_flush_dev(struct neigh_table *tbl, struct net_device *dev)
 				if (n->nud_state & NUD_VALID)
 				{
 					n->nud_state = NUD_NOARP;
-				}	
+				}
 				else
 					n->nud_state = NUD_NONE;
 				NEIGH_PRINTK2("neigh %p is stray.\n", n);
@@ -770,20 +770,21 @@ static void neigh_periodic_timer(unsigned long arg)
 		if (atomic_read(&n->refcnt) == 1 &&
 		    (state == NUD_FAILED ||
 		     time_after(now, n->used + n->parms->gc_staletime))) {
-			*np = n->next;
-			n->dead = 1;
+
 			#if defined(CONFIG_RTL_819X)
 			if (RTL_PS_HOOKS_BREAK==rtl_neigh_periodic_timer_hooks(n, 0)) {
 				write_unlock(&n->lock);
-				continue;
+				goto next_elt;
 			}
 
 			#if 0
-			printk("%s:%d: ip:%u.%u.%u.%u, mac:%x:%x:%x:%x:%x:%x,n->nud_state is 0x%x,tval is %d\n", 
-			__FUNCTION__,__LINE__,NIPQUAD(htonl(*((u32 *)n->primary_key))), n->ha[0], n->ha[1], 
+			printk("%s:%d: ip:%u.%u.%u.%u, mac:%x:%x:%x:%x:%x:%x,n->nud_state is 0x%x,tval is %d\n",
+			__FUNCTION__,__LINE__,NIPQUAD(htonl(*((u32 *)n->primary_key))), n->ha[0], n->ha[1],
 			n->ha[2], n->ha[3], n->ha[4], n->ha[5],n->nud_state,tval);
 			#endif
 			#endif
+			*np = n->next;
+			n->dead = 1;
 
 			write_unlock(&n->lock);
 			neigh_cleanup_and_release(n);
@@ -890,7 +891,7 @@ static void neigh_timer_handler(unsigned long arg)
 	#if defined(CONFIG_RTL_819X)
 	rtl_neigh_timer_handler_during_update_hooks(neigh, state);
 	#endif
-	
+
 	if ((neigh->nud_state & (NUD_INCOMPLETE | NUD_PROBE)) &&
 	    atomic_read(&neigh->probes) >= neigh_max_probes(neigh)) {
 		struct sk_buff *skb;
@@ -1183,7 +1184,7 @@ out:
 	/*different mac address, and add new arp mapping entry*/
 	rtl_neigh_update_post_hooks(neigh, lladdr, old);
 	#endif
-	
+
 	write_unlock_bh(&neigh->lock);
 
 	if (notify)
@@ -2906,7 +2907,7 @@ static int __init neigh_init(void)
 	#if defined(CONFIG_RTL_819X)
 	rtl_neigh_init_hooks();
 	#endif
-	
+
 	return 0;
 }
 
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index 22117d5..3e24fd2 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -222,14 +222,17 @@ struct sk_buff *__alloc_skb(unsigned int size, gfp_t gfp_mask,
 	skb->srcVlanPriority=0;
 #endif
 
-#if defined(CONFIG_NETFILTER_XT_MATCH_PHYPORT) || defined(CONFIG_RTL_FAST_FILTER) || defined(CONFIG_RTL_QOS_PATCH)
+#if defined(CONFIG_NETFILTER_XT_MATCH_PHYPORT) || defined(CONFIG_RTL_FAST_FILTER) || defined(CONFIG_RTL_QOS_PATCH)|| defined(CONFIG_RTK_VOIP_QOS) || defined(CONFIG_RTK_VLAN_WAN_TAG_SUPPORT)
 	skb->srcPhyPort=0xFF;
 	skb->dstPhyPort=0xFF;
 #endif
 
 #if defined(CONFIG_RTK_VLAN_SUPPORT)
 	skb->tag.v = 0;
-#endif	
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+	skb->src_info = NULL;
+#endif
+#endif
 
 #if defined (CONFIG_RTL_LOCAL_PUBLIC)
 	skb->srcLocalPublicIp=0;
@@ -304,7 +307,7 @@ struct sk_buff *dev_alloc_8190_skb(unsigned char *data, int size)
         shinfo->gso_type = 0;
         shinfo->ip6_frag_id = 0;
         shinfo->frag_list = NULL;
- 
+
 #ifdef CONFIG_RTK_VOIP_VLAN_ID
         skb->rx_vlan = 0;
         skb->rx_wlan = 0;
@@ -320,13 +323,16 @@ struct sk_buff *dev_alloc_8190_skb(unsigned char *data, int size)
 	skb->srcVlanPriority=0;
 #endif
 
-#if defined(CONFIG_NETFILTER_XT_MATCH_PHYPORT) || defined(CONFIG_RTL_FAST_FILTER) || defined(CONFIG_RTL_QOS_PATCH)
+#if defined(CONFIG_NETFILTER_XT_MATCH_PHYPORT) || defined(CONFIG_RTL_FAST_FILTER) || defined(CONFIG_RTL_QOS_PATCH) || defined(CONFIG_RTK_VOIP_QOS)|| defined(CONFIG_RTK_VLAN_WAN_TAG_SUPPORT)
 	skb->srcPhyPort=0xFF;
 	skb->dstPhyPort=0xFF;
 #endif
 
 #if defined(CONFIG_RTK_VLAN_SUPPORT)
 	skb->tag.v = 0;
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+	skb->src_info = NULL;
+#endif
 #endif
 
 #if defined (CONFIG_RTL_LOCAL_PUBLIC)
@@ -346,7 +352,7 @@ struct sk_buff *dev_alloc_8190_skb(unsigned char *data, int size)
 #endif
 
         return skb;
- 
+
 out:
         return NULL;
 }
@@ -465,7 +471,7 @@ static void skb_release_data(struct sk_buff *skb)
 #if defined(CONFIG_RTL_ETH_PRIV_SKB)
 		if (is_rtl865x_eth_priv_buf(skb->head)) {
 			free_rtl865x_eth_priv_buf(skb->head);
-		}            
+		}
 		else
 #endif
 #ifdef CONFIG_RTL8190_PRIV_SKB
@@ -476,10 +482,10 @@ static void skb_release_data(struct sk_buff *skb)
 		else
 #endif
 		{
-		kfree(skb->head);
+			kfree(skb->head);
+		}
 	}
 }
-}
 
 /*
  *	Free an skbuff by memory without cleaning the state.
@@ -689,7 +695,7 @@ static void __copy_skb_header(struct sk_buff *new, const struct sk_buff *old)
 	new->srcVlanPriority=old->srcVlanPriority;
 #endif
 
-#if defined(CONFIG_NETFILTER_XT_MATCH_PHYPORT) || defined(CONFIG_RTL_FAST_FILTER) || defined(CONFIG_RTL_QOS_PATCH)
+#if defined(CONFIG_NETFILTER_XT_MATCH_PHYPORT) || defined(CONFIG_RTL_FAST_FILTER) || defined(CONFIG_RTL_QOS_PATCH) || defined(CONFIG_RTK_VOIP_QOS)|| defined(CONFIG_RTK_VLAN_WAN_TAG_SUPPORT)
 	new->srcPhyPort=old->srcPhyPort;
 	new->dstPhyPort=old->dstPhyPort;
 #endif
@@ -740,7 +746,7 @@ static struct sk_buff *__skb_clone(struct sk_buff *n, struct sk_buff *skb)
 	C(srcVlanPriority);
 #endif
 
-#if defined(CONFIG_NETFILTER_XT_MATCH_PHYPORT) || defined(CONFIG_RTL_FAST_FILTER) || defined(CONFIG_RTL_QOS_PATCH)
+#if defined(CONFIG_NETFILTER_XT_MATCH_PHYPORT) || defined(CONFIG_RTL_FAST_FILTER) || defined(CONFIG_RTL_QOS_PATCH) || defined(CONFIG_RTK_VOIP_QOS)|| defined(CONFIG_RTK_VLAN_WAN_TAG_SUPPORT)
 	C(srcPhyPort);
 	C(dstPhyPort);
 #endif
@@ -814,6 +820,9 @@ struct sk_buff *skb_clone(struct sk_buff *skb, gfp_t gfp_mask)
 #ifdef CONFIG_RTK_VLAN_SUPPORT
 	//C(tag.v);
 	n->tag.v = skb->tag.v;
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+	n->src_info = skb->src_info;
+#endif
 #endif
 #if defined (CONFIG_RTL_LOCAL_PUBLIC)
 	n->srcLocalPublicIp = skb->srcLocalPublicIp;
@@ -845,8 +854,11 @@ static void copy_skb_header(struct sk_buff *new, const struct sk_buff *old)
 	new->network_header   += offset;
 	new->mac_header	      += offset;
 #endif
-#ifdef CONFIG_RTK_VLAN_SUPPORT	
+#ifdef CONFIG_RTK_VLAN_SUPPORT
 	new->tag.v = old->tag.v;
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+	new->src_info = old->src_info;
+#endif
 #endif
 #if defined (CONFIG_RTL_LOCAL_PUBLIC)
 	new->srcLocalPublicIp=old->srcLocalPublicIp;
diff --git a/net/core/sock.c b/net/core/sock.c
index 3f5e77e..70c38dd 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -267,7 +267,67 @@ static void sock_disable_timestamp(struct sock *sk, int flag)
 	}
 }
 
+#if defined (CONFIG_RTL_SOCK_DEBUG)
 
+int dump_inet_sock(struct inet_sock * inet)
+{
+	if(inet==NULL)
+	{
+		return -1;
+	}
+	
+	printk("daddr:0x%x,rcv_saddr:0x%x,dport:%d,num:%d,saddr:0x%x,uc_ttl:%d,sport:%d,id:%d,tos:%d,mc_ttl:%d,mc_index:%d,mc_addr:0x%x\n",
+		inet->daddr, inet->rcv_saddr,inet->dport,inet->num,inet->saddr,inet->uc_ttl,inet->sport,inet->id,inet->tos,inet->mc_ttl,inet->mc_index,inet->mc_addr);
+	
+	return 0;
+
+}
+
+int dump_inet_timewait_sock(struct inet_timewait_sock * inet_tw)
+{
+	if(inet_tw==NULL)
+	{
+		return -1;
+	}
+	
+	printk("tw_sport:%d,tw_daddr:0x%x,tw_rcv_saddr:0x%x,tw_dport:%d,tw_num:%d\n",
+		inet_tw->tw_sport, inet_tw->tw_daddr,inet_tw->tw_rcv_saddr,inet_tw->tw_dport,inet_tw->tw_num);
+	
+	return 0;
+
+}
+	
+int dump_sock_skb_info(struct sock * sk)
+{
+	struct sk_buff *list=NULL;
+	unsigned int skbCnt=0;
+	
+	if(sk==NULL)
+	{
+		return -1;
+	}
+
+	//dump_inet_sock(inet_sk(sk));
+
+	list=(struct sk_buff *)(&sk->sk_receive_queue)->next;
+	while((list!=NULL) && (list!=(struct sk_buff *)(&sk->sk_receive_queue)))
+	{
+		//printk(".");
+		skbCnt++;
+		list= list->next;
+	}
+
+	list=sk->sk_backlog.head;
+	while((list!=NULL) && (list != sk->sk_backlog.head))
+	{
+		//printk(".");
+		skbCnt++;
+		list= list->next;
+	}
+	printk("queued pkt num is %d\n",skbCnt);	
+}
+
+#endif
 int sock_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)
 {
 	int err = 0;
diff --git a/net/ipv4/Kconfig b/net/ipv4/Kconfig
index d5ebb83..77d2208 100644
--- a/net/ipv4/Kconfig
+++ b/net/ipv4/Kconfig
@@ -96,9 +96,13 @@ config RTL_IPTABLES_FAST_PATH
         default y
 
 config FAST_PATH_SPI_ENABLED
-	bool "Realtek Fastpath SPI(stateful packet inspection) support"
-	depends on RTL_IPTABLES_FAST_PATH
-	default n
+        bool "Realtek Fastpath SPI(stateful packet inspection) support"
+        depends on RTL_IPTABLES_FAST_PATH
+        default n
+
+config RTL_FASTBRIDGE
+        tristate "Realtek fast bridge"
+        default n
 
 config IP_FIB_TRIE_STATS
 	bool "FIB TRIE statistics"
diff --git a/net/ipv4/arp.c b/net/ipv4/arp.c
index 3c7e76c..ddc1b05 100644
--- a/net/ipv4/arp.c
+++ b/net/ipv4/arp.c
@@ -178,6 +178,13 @@ static void parp_redo(struct sk_buff *skb);
 #ifdef CONFIG_RTK_VLAN_SUPPORT
 	#include <net/rtl/rtk_vlan.h>
 	static struct vlan_tag arp_tag;
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+	static struct vlan_info *arp_info;
+#endif
+#endif
+
+#if defined(CONFIG_RTK_VOIP_QOS) || defined(CONFIG_RTK_VLAN_WAN_TAG_SUPPORT)
+static int arp_rx_port;
 #endif
 
 static struct neigh_ops arp_generic_ops = {
@@ -425,16 +432,30 @@ static void arp_solicit(struct neighbour *neigh, struct sk_buff *skb)
 	}
 
 #ifdef CONFIG_RTK_VLAN_SUPPORT
-	if (skb)
+	if (skb){
 		arp_tag = skb->tag;
+	#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+		arp_info = skb->src_info;
+	#endif
+	}
 #endif
+#if defined(CONFIG_RTK_VOIP_QOS) || defined(CONFIG_RTK_VLAN_WAN_TAG_SUPPORT)
+	if(skb)
+		arp_rx_port = skb->srcPhyPort;
+#endif		
 	arp_send(ARPOP_REQUEST, ETH_P_ARP, target, dev, saddr,
 		 dst_ha, dev->dev_addr, NULL);
 
-#ifdef CONFIG_RTK_VLAN_SUPPORT 
+#ifdef CONFIG_RTK_VLAN_SUPPORT
 	arp_tag.v = 0;
-#endif		 
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+	arp_info = NULL;
+#endif
+#endif
 
+#if defined(CONFIG_RTK_VOIP_QOS) || defined(CONFIG_RTK_VLAN_WAN_TAG_SUPPORT)	 
+	arp_rx_port = 0;
+#endif
 	if (dst_ha)
 		read_unlock_bh(&neigh->lock);
 }
@@ -639,8 +660,14 @@ struct sk_buff *arp_create(int type, int ptype, __be32 dest_ip,
 	skb->protocol = htons(ETH_P_ARP);
 #ifdef CONFIG_RTK_VLAN_SUPPORT
 	skb->tag = arp_tag;
-#endif	
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+	skb->src_info = arp_info;
+#endif
+#endif
 
+#if defined(CONFIG_RTK_VOIP_QOS) || defined(CONFIG_RTK_VLAN_WAN_TAG_SUPPORT)	
+	skb->srcPhyPort = arp_rx_port;
+#endif
 	if (src_hw == NULL)
 		src_hw = dev->dev_addr;
 	if (dest_hw == NULL)
@@ -773,14 +800,14 @@ static void rtl865x_lpArpProxyHandler(unsigned long arg)
 	{
 		goto end_of_handler;
 	}
-	
+
 	lanDev=rtl865x_getLanDev();
 	wanDev=rtl865x_getWanDev();
 	lpCnt=rtl865x_getAllLocalPublic(lpArray, MAX_LOCAL_PUBLIC_NUM);
 	if(lanDev!=NULL)
 	{
 		rtl865x_getDevIpAndNetmask(lanDev, &lanIpAddr, &lanNetMask);
-	
+
 		for(i=0; i<lpCnt; i++)
 		{
 			if(memcmp(lpArray[i].mac, zeroMac, 6)==0)
@@ -798,7 +825,7 @@ static void rtl865x_lpArpProxyHandler(unsigned long arg)
 			{
 				continue;
 			}
-			
+
 			dupGw=0;
 			for(j=0; j<i; j++)
 			{
@@ -808,7 +835,7 @@ static void rtl865x_lpArpProxyHandler(unsigned long arg)
 					dupGw=1;
 					break;
 				}
-				
+
 			}
 
 			if(dupGw==0)
@@ -823,8 +850,8 @@ static void rtl865x_lpArpProxyHandler(unsigned long arg)
 
 	if(wanDev)
 		dev_put(wanDev);
-	
-end_of_handler:	
+
+end_of_handler:
 	mod_timer(&lpArpProxyTimer, jiffies +LOACL_PUBLIC_PROBE_PERIOD);
 }
 
@@ -869,7 +896,7 @@ static int arp_process(struct sk_buff *skb)
 	unsigned char fromLocalPublic;
 	unsigned char toLocalPublic;
 	unsigned char localPublicMac[6];
-	
+
 	struct rtl865x_localPublic srcLocalPubicInfo;
 	struct rtl865x_localPublic dstLocalPublicInfo;
 	struct net_device * wanDev=NULL;
@@ -935,7 +962,7 @@ static int arp_process(struct sk_buff *skb)
 #ifdef CONFIG_RTK_INBAND_HOST_HACK
 //reject arp request for AP
 extern int br_hackMac_enable;
-	if(br_hackMac_enable)	
+	if(br_hackMac_enable)
 	{
         if(arp->ar_op == htons(ARPOP_REQUEST))
                 goto out;
@@ -985,10 +1012,18 @@ extern int br_hackMac_enable;
  *  cache.
  */
 #ifdef CONFIG_RTK_VLAN_SUPPORT
-	if (skb)
+	if (skb){
 		arp_tag = skb->tag;
-#endif		    
+	#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+		arp_info = skb->src_info;
+	#endif
+	}
+#endif
 
+#if defined(CONFIG_RTK_VOIP_QOS) || defined(CONFIG_RTK_VLAN_WAN_TAG_SUPPORT) 
+	if(skb)
+		arp_rx_port = skb->srcPhyPort;
+#endif
 	/* Special case: IPv4 duplicate address detection packet (RFC2131) */
 	if (sip == 0) {
 		if (arp->ar_op == htons(ARPOP_REQUEST) &&
@@ -1004,7 +1039,7 @@ extern int br_hackMac_enable;
 	{
 		goto	common_arp_process;
 	}
-	
+
 	if(arp->ar_op == htons(ARPOP_REQUEST))
 	{
 		if(sip==tip)
@@ -1012,11 +1047,11 @@ extern int br_hackMac_enable;
 			/*gratuitous arp*/
 			goto common_arp_process;
 		}
-		
+
 		fromLocalPublic=rtl865x_isLocalPublicIp(sip);
 		toLocalPublic=rtl865x_isLocalPublicIp(tip);
 		rtl865x_attainDevType(dev->name, &rxFromLan, &rxFromWan);
-		
+
  		//rtl865x_getNetDecisionPolicy(&curPolicy);
 		//rtl865x_getDefACLForNetDecisionMiss(&defInAclStart, &defInAclEnd,&defOutAclStart,&defOutAclEnd);
 		ret=rtl865x_checkMacAddrLocation(sha, &srcIsElanMac, &srcIsWlanMac);
@@ -1029,7 +1064,7 @@ extern int br_hackMac_enable;
 			rtl865x_getDevIpAndNetmask(lanDev, &lanIpAddr, &lanNetMask);
 			wanDev=rtl865x_getWanDev();
 			rtl865x_getDevIpAndNetmask(wanDev,&wanIpAddr,&wanNetMask);
-			
+
 			if(fromLocalPublic && (!toLocalPublic))
 			{
 				//printk("%s:%d,sip is 0x%x,tip is 0x%x\n",__FUNCTION__,__LINE__,sip,tip);
@@ -1038,10 +1073,10 @@ extern int br_hackMac_enable;
 				{
 					goto common_arp_process;
 				}
-			
+
 				/*send out this arp request to wan*/
 				if((sip & srcLocalPubicInfo.netMask) == (tip & srcLocalPubicInfo.netMask))
-				{							
+				{
 					if(wanDev)
 					{
 						//printk("%s:%d,lanIpAddr is %d.%d.%d.%d, lanNetMask is %d.%d.%d.%d\n",__FUNCTION__,__LINE__,NIPQUAD(lanIpAddr),NIPQUAD(lanNetMask));
@@ -1085,11 +1120,11 @@ extern int br_hackMac_enable;
 							//target in lan
 							arp_send(ARPOP_REQUEST, ETH_P_ARP, tip, lanDev, lanIpAddr, NULL, lanDev->dev_addr, NULL);
 						}
-						
+
 					}
 				}
-				
-				
+
+
 				n = neigh_event_ns(&arp_tbl, sha, &sip, dev);
 				#if 0
 				if(tip==srcLocalPubicInfo.defGateway)
@@ -1101,7 +1136,7 @@ extern int br_hackMac_enable;
 				{
 					/*target is not at lan*/
 					arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dev->dev_addr,sha);
-				}				
+				}
 				else if((tip & srcLocalPubicInfo.netMask) == (sip & srcLocalPubicInfo.netMask))
 				{
 					/*target in the same subnet as local public, include  default gw, but not local public*/
@@ -1116,7 +1151,7 @@ extern int br_hackMac_enable;
 				#if 1
 				//software local public
 				if(srcLocalPubicInfo.hw == 0)
-				{					
+				{
 					if((tip & lanNetMask) != (lanIpAddr & lanNetMask))
 					{
 						if(tip==wanIpAddr)
@@ -1160,9 +1195,9 @@ extern int br_hackMac_enable;
 								arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dst_n->ha,sha);
 							}
 							neigh_release(dst_n);
-						}						
+						}
 					}
-					
+
 				}
 				else
 				{
@@ -1178,7 +1213,7 @@ extern int br_hackMac_enable;
 								arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dst_n->ha,sha);
 							}
 							neigh_release(dst_n);
-						}						
+						}
 					}
 					else
 #endif
@@ -1202,19 +1237,19 @@ extern int br_hackMac_enable;
 					//hyking:don't reply,until dst_n is found....
 				}
 				#endif
-				
-				
-				if (n) 
+
+
+				if (n)
 				{
 					neigh_release(n);
 				}
 				goto out;
-				
+
 			}
 			else if((!fromLocalPublic) && toLocalPublic)
 			{
 				goto common_arp_process;
-		
+
 			}
 			else if(fromLocalPublic && toLocalPublic)
 			{
@@ -1224,15 +1259,15 @@ extern int br_hackMac_enable;
 				{
 					goto common_arp_process;
 				}
-				
+
 				ret=rtl865x_getLocalPublicInfo(tip, &dstLocalPublicInfo);
 				if(ret!=0)
 				{
 					goto common_arp_process;
 				}
-					
+
 				n = neigh_event_ns(&arp_tbl, sha, &sip, dev);
-			
+
 				#if 0
 				if((srcLocalPubicInfo.ipAddr & srcLocalPubicInfo.netMask) != (tip & srcLocalPubicInfo.netMask))
 				{
@@ -1266,7 +1301,7 @@ extern int br_hackMac_enable;
 						{
 							arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dstLocalPublicInfo.mac,sha);
 						}
-						
+
 					}
 					else if ((srcLocalPubicInfo.hw==0) && (dstLocalPublicInfo.hw==0))
 					{
@@ -1276,15 +1311,15 @@ extern int br_hackMac_enable;
 							arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dstLocalPublicInfo.mac,sha);
 						}
 					}
-						
+
 				}
 				#endif
 				if(memcmp(dstLocalPublicInfo.mac, zeroMac,6)!=0)
 				{
 					arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dstLocalPublicInfo.mac,sha);
 				}
-				
-				if (n) 
+
+				if (n)
 				{
 					neigh_release(n);
 				}
@@ -1294,33 +1329,33 @@ extern int br_hackMac_enable;
 			{
 				goto common_arp_process;
 			}
-		
+
 		}
 		else if (rxFromWan)
 		{
 			 if((!fromLocalPublic) && toLocalPublic)
-			{	
+			{
 				n = neigh_event_ns(&arp_tbl, sha, &sip, dev);
 
 				#if 0
-				rtl865x_getLocalPublicInfo(tip, &dstLocalPublicInfo);	
+				rtl865x_getLocalPublicInfo(tip, &dstLocalPublicInfo);
 				if((sip & dstLocalPublicInfo.netMask) == (tip & dstLocalPublicInfo.netMask))
 				{
 					lanDev=rtl865x_getLanDev();
 					if(lanDev)
 					{
 						arp_send(ARPOP_REQUEST, ETH_P_ARP, tip, lanDev, sip, NULL, lanDev->dev_addr, NULL);
-					}	
+					}
 				}
 				#endif
-				
+
 				if(rtl865x_getLocalPublicMac(tip, localPublicMac)==0)
 				{
 					arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,localPublicMac,sha);
 				}
-				
-				if (n) 
-				{	
+
+				if (n)
+				{
 					neigh_release(n);
 				}
 				goto out;
@@ -1337,9 +1372,9 @@ extern int br_hackMac_enable;
 			 {
 				/*impossible, should be dropped at dev rx*/
 			 }
-			
+
 		}
-		
+
 	}
 
 common_arp_process:
@@ -1434,8 +1469,14 @@ out:
 	consume_skb(skb);
 #ifdef CONFIG_RTK_VLAN_SUPPORT
 	arp_tag.v = 0;
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+	arp_info = NULL;
+#endif
 #endif
 
+#if defined(CONFIG_RTK_VOIP_QOS) || defined(CONFIG_RTK_VLAN_WAN_TAG_SUPPORT)
+	arp_rx_port = 0;
+#endif
 	return 0;
 }
 
@@ -1597,11 +1638,19 @@ static unsigned arp_state_to_flags(struct neighbour *neigh)
  *	Get an ARP cache entry.
  */
 
+#if defined (CONFIG_RTL_819X)
+extern int get_dev_ip_mask(const char * name,unsigned int * ip,unsigned int * mask);
+#endif
 static int arp_req_get(struct arpreq *r, struct net_device *dev)
 {
 	__be32 ip = ((struct sockaddr_in *) &r->arp_pa)->sin_addr.s_addr;
 	struct neighbour *neigh;
 	int err = -ENXIO;
+#if defined (CONFIG_RTL_819X)
+	unsigned int dev_ip, dev_mask;
+	unsigned char zero_ha[ALIGN(MAX_ADDR_LEN, sizeof(unsigned long))];
+	int ret=-1;
+#endif
 
 	neigh = neigh_lookup(&arp_tbl, &ip, dev);
 	if (neigh) {
@@ -1614,6 +1663,41 @@ static int arp_req_get(struct arpreq *r, struct net_device *dev)
 		neigh_release(neigh);
 		err = 0;
 	}
+#if defined (CONFIG_RTL_819X)
+	if (neigh) 
+	{
+		memset(zero_ha, 0 , sizeof(zero_ha));
+		if( (memcmp(neigh->ha, zero_ha , dev->addr_len)==0) &&
+			((dev!=NULL) && (strncmp(dev->name, "br0",3)==0)))
+		{			
+			ret=get_dev_ip_mask(dev->name, &dev_ip, &dev_mask); 
+			if((ret==0) && (dev_ip !=0) && (dev_mask!=0) && (ip!= dev_ip) && ((ip & dev_mask) == (dev_ip & dev_mask)))
+			{
+				arp_send(ARPOP_REQUEST, ETH_P_ARP, ip, dev, dev_ip,NULL, dev->dev_addr, NULL);
+			}
+		}
+
+	}
+	else
+	{
+		if((dev!=NULL) && (strncmp(dev->name, "br0",3)==0))
+		{
+			
+			ret=get_dev_ip_mask(dev->name, &dev_ip, &dev_mask);
+			if((ret==0) && (dev_ip !=0) && (dev_mask!=0) && (ip!= dev_ip) && ((ip & dev_mask) == (dev_ip & dev_mask)))
+			{
+				neigh = __neigh_lookup(&arp_tbl,&ip, dev,1);	
+				arp_send(ARPOP_REQUEST, ETH_P_ARP, ip, dev, dev_ip,NULL, dev->dev_addr, NULL);
+				if(neigh)
+					neigh_release(neigh);
+				//printk("%s:%d,neigh->refcnt is %d\n",__FUNCTION__,__LINE__,atomic_read(&neigh->refcnt));
+				
+				
+			}
+		}
+		
+	}
+#endif
 	return err;
 }
 
@@ -1788,6 +1872,13 @@ void __init arp_init(void)
 	register_netdevice_notifier(&arp_netdev_notifier);
 #ifdef CONFIG_RTK_VLAN_SUPPORT
 	arp_tag.v = 0;
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+	arp_info = NULL;
+#endif
+#endif
+
+#if defined(CONFIG_RTK_VOIP_QOS) || defined(CONFIG_RTK_VLAN_WAN_TAG_SUPPORT)
+	arp_rx_port = 0;
 #endif
 
 #if defined (CONFIG_RTL_LOCAL_PUBLIC)
diff --git a/net/ipv4/fib_hash.c b/net/ipv4/fib_hash.c
index d1463bf..4d886c4 100644
--- a/net/ipv4/fib_hash.c
+++ b/net/ipv4/fib_hash.c
@@ -613,7 +613,7 @@ static int fn_hash_delete(struct fib_table *tb, struct fib_config *cfg)
 
 	if (fa_to_delete) {
 		int kill_fn;
-
+		
 		#if defined(CONFIG_RTL_819X)
 		rtl_fn_hash_delete_hooks(tb, cfg);
 		#endif
diff --git a/net/ipv4/ip_input.c b/net/ipv4/ip_input.c
index 3d01ea9..b75738f 100644
--- a/net/ipv4/ip_input.c
+++ b/net/ipv4/ip_input.c
@@ -144,14 +144,15 @@
 #include <linux/mroute.h>
 #include <linux/netlink.h>
 
-#if defined(CONFIG_RTL_USB_IP_HOST_SPEEDUP) || defined(CONFIG_HTTP_FILE_SERVER_SUPPORT)
+#if defined(CONFIG_RTL_USB_IP_HOST_SPEEDUP) || defined(CONFIG_HTTP_FILE_SERVER_SUPPORT) || defined(CONFIG_RTL_USB_UWIFI_HOST_SPEEDUP)
 int isUsbIp_Reserved(struct sk_buff *skb, unsigned int hooknum, int direction);
 unsigned int _lan_ip=0xC0A801FE;
 unsigned int _lan_mask=0xFFFFFF00;
 #define USBIP_PORT_NUM 445
 #define USBIP_PORT_NUM_1 139
 #define HTTP_PORT_NUM 80
-unsigned int isUSBexported=1;
+#define UWIFI_PORT_NUM 2379
+
 enum netfilter_hooks {
 	_PRE_ROUTING,
 	_LOCAL_IN,
@@ -191,6 +192,8 @@ int isUsbIp_Reserved(struct sk_buff *skb, unsigned int hooknum, int direction)
 				ret=1;
 			if(_lan_ip != 0 && th->dest==USBIP_PORT_NUM_1 && skb->pkt_type== PACKET_HOST)
 				ret=1;
+			if(_lan_ip != 0 && th->dest==UWIFI_PORT_NUM && skb->pkt_type== PACKET_HOST)
+				ret=1;	
 
 		}
 		if(direction==1){ //tx we check src port
@@ -198,16 +201,22 @@ int isUsbIp_Reserved(struct sk_buff *skb, unsigned int hooknum, int direction)
 				ret=1;
 			if(_lan_ip != 0 && th->source==USBIP_PORT_NUM_1 && skb->pkt_type== PACKET_HOST)
 				ret=1;
+			if(_lan_ip != 0 && th->source==UWIFI_PORT_NUM && skb->pkt_type== PACKET_HOST)
+				ret=1;	
 
 		}
 #else
 		if(direction==0){ //rx we check dest port
 			if(_lan_ip != 0 && (th->dest==USBIP_PORT_NUM || th->dest==HTTP_PORT_NUM) && skb->pkt_type== PACKET_HOST)
 				ret=1;
+			if(_lan_ip != 0 && (th->dest==USBIP_PORT_NUM_1 || th->dest==UWIFI_PORT_NUM) && skb->pkt_type== PACKET_HOST)
+				ret=1;
 		}
 		if(direction==1){ //tx we check src port
 			if(_lan_ip != 0 && (th->source==USBIP_PORT_NUM || th->source==HTTP_PORT_NUM) && skb->pkt_type== PACKET_HOST)
 				ret=1;
+			if(_lan_ip != 0 && (th->source==USBIP_PORT_NUM_1 || th->source==UWIFI_PORT_NUM) && skb->pkt_type== PACKET_HOST)
+				ret=1;	
 		}
 #endif
 	}
@@ -337,7 +346,7 @@ int ip_local_deliver(struct sk_buff *skb)
 		if (ip_defrag(skb, IP_DEFRAG_LOCAL_DELIVER))
 			return 0;
 	}
-#if defined(CONFIG_RTL_USB_IP_HOST_SPEEDUP) || defined(CONFIG_HTTP_FILE_SERVER_SUPPORT)
+#if defined(CONFIG_RTL_USB_IP_HOST_SPEEDUP) || defined(CONFIG_HTTP_FILE_SERVER_SUPPORT) || defined(CONFIG_RTL_USB_UWIFI_HOST_SPEEDUP)
 	if(isUsbIp_Reserved(skb,NF_INET_LOCAL_IN, 0)==0){
 		return NF_HOOK(PF_INET, NF_INET_LOCAL_IN, skb, skb->dev, NULL, ip_local_deliver_finish);
 	}else{
@@ -423,7 +432,26 @@ static int ip_rcv_finish(struct sk_buff *skb)
 			goto drop;
 		}
 	}
-
+#if defined (CONFIG_RTL_819X)
+	/*to fix guest can access local web ui*/
+	#include <linux/udp.h>
+        if (skb->dst->input == &ip_local_deliver) {
+                if (skb->__unused == 0xe5 && iph->protocol== IPPROTO_UDP) {
+                        struct udphdr *hdr = (struct udphdr *)((u_int32_t *)iph + iph->ihl);
+                        if (hdr->dest == 53 || hdr->dest == 67) // DNS Domain or dhcp
+                                skb->__unused = 0;
+                }
+
+                if (skb->__unused == 0xe5 && iph->protocol== IPPROTO_TCP) {
+                        struct udphdr *hdr = (struct udphdr *)((u_int32_t *)iph + iph->ihl);
+                        if (hdr->dest == 52869) // IGD port
+                                skb->__unused = 0;
+                }
+
+                if (skb->__unused == 0xe5)
+                        goto drop;
+        }
+#endif
 #ifdef CONFIG_NET_CLS_ROUTE
 	if (unlikely(skb->dst->tclassid)) {
 		struct ip_rt_acct *st = per_cpu_ptr(ip_rt_acct, smp_processor_id());
@@ -520,7 +548,7 @@ int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt,
 
 	/* Must drop socket now because of tproxy. */
 	skb_orphan(skb);
-#if defined(CONFIG_RTL_USB_IP_HOST_SPEEDUP) || defined(CONFIG_HTTP_FILE_SERVER_SUPPORT)
+#if defined(CONFIG_RTL_USB_IP_HOST_SPEEDUP) || defined(CONFIG_HTTP_FILE_SERVER_SUPPORT) || defined(CONFIG_RTL_USB_UWIFI_HOST_SPEEDUP)
 	if(isUsbIp_Reserved(skb,NF_INET_PRE_ROUTING, 0)==0){
 		return NF_HOOK(PF_INET, NF_INET_PRE_ROUTING, skb, dev, NULL,ip_rcv_finish);
 	}else{
diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c
index e0e8e88..439e11e 100644
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@ -80,8 +80,9 @@
 #include <linux/netlink.h>
 #include <linux/tcp.h>
 
+#include <net/rtl/features/rtl_ps_log.h>
 
-#if defined(CONFIG_RTL_USB_IP_HOST_SPEEDUP) || defined(CONFIG_HTTP_FILE_SERVER_SUPPORT)
+#if defined(CONFIG_RTL_USB_IP_HOST_SPEEDUP) || defined(CONFIG_HTTP_FILE_SERVER_SUPPORT) || defined(CONFIG_RTL_USB_UWIFI_HOST_SPEEDUP)
 extern int isUsbIp_Reserved(struct sk_buff *skb, unsigned int hooknum, int direction);
 #endif
 
@@ -101,7 +102,7 @@ int __ip_local_out(struct sk_buff *skb)
 
 	iph->tot_len = htons(skb->len);
 	ip_send_check(iph);
-	#if defined(CONFIG_RTL_USB_IP_HOST_SPEEDUP) || defined(CONFIG_HTTP_FILE_SERVER_SUPPORT)
+	#if defined(CONFIG_RTL_USB_IP_HOST_SPEEDUP) || defined(CONFIG_HTTP_FILE_SERVER_SUPPORT) || defined(CONFIG_RTL_USB_UWIFI_HOST_SPEEDUP)
 	if(isUsbIp_Reserved(skb, NF_INET_LOCAL_OUT, 1)==0){
 		return nf_hook(PF_INET, NF_INET_LOCAL_OUT, skb, NULL, skb->dst->dev,dst_output);
 	}else{
@@ -207,6 +208,7 @@ static inline int ip_finish_output2(struct sk_buff *skb)
 
 		skb2 = skb_realloc_headroom(skb, LL_RESERVED_SPACE(dev));
 		if (skb2 == NULL) {
+			//LOG_MEM_ERROR("%s skb realloc headroom failed\n", __FUNCTION__);
 			kfree_skb(skb);
 			return -ENOMEM;
 		}
@@ -292,6 +294,7 @@ int ip_mc_output(struct sk_buff *skb)
 		/* Multicasts with ttl 0 must not go beyond the host */
 
 		if (ip_hdr(skb)->ttl == 0) {
+			//LOG_SKB_ERROR("%s drop Multicast pkt for ttl 0\n", __FUNCTION__);
 			kfree_skb(skb);
 			return 0;
 		}
@@ -317,7 +320,7 @@ int ip_output(struct sk_buff *skb)
 
 	skb->dev = dev;
 	skb->protocol = htons(ETH_P_IP);
-	#if defined(CONFIG_RTL_USB_IP_HOST_SPEEDUP) || defined(CONFIG_HTTP_FILE_SERVER_SUPPORT)
+	#if defined(CONFIG_RTL_USB_IP_HOST_SPEEDUP) || defined(CONFIG_HTTP_FILE_SERVER_SUPPORT) || defined(CONFIG_RTL_USB_UWIFI_HOST_SPEEDUP)
 
 	if(isUsbIp_Reserved(skb, NF_INET_POST_ROUTING, 1)==0){
 	return NF_HOOK_COND(PF_INET, NF_INET_POST_ROUTING, skb, NULL, dev,
@@ -437,7 +440,7 @@ static void ip_copy_metadata(struct sk_buff *to, struct sk_buff *from)
 	/* Copy the flags to each fragment. */
 	IPCB(to)->flags = IPCB(from)->flags;
 
-#if defined(CONFIG_RTL_QOS_PATCH) && defined(CONFIG_RTL_819X)
+#if (defined(CONFIG_RTL_QOS_PATCH) || defined(CONFIG_RTK_VOIP_QOS)|| defined(CONFIG_RTK_VLAN_WAN_TAG_SUPPORT))&& defined(CONFIG_RTL_819X) 
         to->srcPhyPort = from->srcPhyPort;
 #endif
 
diff --git a/net/ipv4/ipmr.c b/net/ipv4/ipmr.c
index 9195353..29e1973 100644
--- a/net/ipv4/ipmr.c
+++ b/net/ipv4/ipmr.c
@@ -66,6 +66,11 @@
 #if defined(CONFIG_IP_PIMSM_V1) || defined(CONFIG_IP_PIMSM_V2)
 #define CONFIG_IP_PIMSM	1
 #endif
+#if	defined (CONFIG_RTL_IGMP_PROXY)
+
+static int ipmr_find_vif(struct net_device *dev);
+
+#endif
 
 /* Big lock, protecting vif table, mrt cache and mroute socket state.
    Note that the changes are semaphored via rtnl_lock.
@@ -533,11 +538,12 @@ static struct mfc_cache *ipmr_cache_find(struct net *net,
 	struct mfc_cache *c;
 
 	for (c = net->ipv4.mfc_cache_array[line]; c; c = c->next) {
-		if (c->mfc_origin==origin && c->mfc_mcastgrp==mcastgrp)
+		if (c->mfc_origin==origin && c->mfc_mcastgrp==mcastgrp){
 			break;
+		}
 	}
-
-	#if defined (CONFIG_RTL_IGMP_PROXY)
+#if 0		
+#if defined (CONFIG_RTL_IGMP_PROXY)
 	// Casey, for IGMP v2
 	if(c == NULL) {
 		origin = 0;
@@ -548,15 +554,28 @@ static struct mfc_cache *ipmr_cache_find(struct net *net,
 			}
 		}
 	}
-	#endif
+#endif
+#endif
 	return c;
 }
 
 #if defined (CONFIG_RTL_IGMP_SNOOPING)
-int rtl865x_checkMfcCache(struct net *net,__be32 origin,__be32 mcastgrp)
+#if	defined (CONFIG_RTL_IGMP_PROXY)
+int rtl865x_checkMfcCache(struct net *net,struct net_device *dev,__be32 origin,__be32 mcastgrp)
 {
-	struct mfc_cache *mfc;
+	struct mfc_cache *mfc=NULL;
+	int vif_index;
+	__be32 origin_temp=0;
+	
 	mfc=ipmr_cache_find(net,origin,mcastgrp);
+	
+	if(mfc==NULL)
+	{
+		vif_index = ipmr_find_vif(dev);
+		origin_temp = vif_index;
+		mfc = ipmr_cache_find(net, origin_temp, mcastgrp);
+	}
+	
 	if(mfc!=NULL)
 	{
 		return 0;
@@ -576,6 +595,7 @@ int rtl865x_checkMfcCache(struct net *net,__be32 origin,__be32 mcastgrp)
 	return -1;
 }
 #endif
+#endif
 
 /*
  *	Allocate a multicast cache entry
@@ -1491,6 +1511,12 @@ int ip_mr_input(struct sk_buff *skb)
 	struct mfc_cache *cache;
 	struct net *net = dev_net(skb->dev);
 	int local = skb->rtable->rt_flags&RTCF_LOCAL;
+#if defined (CONFIG_RTL_IGMP_PROXY)
+	cache=NULL;
+	struct net_device *dev=skb->dev;
+	int vif_index;
+	__be32 origin_temp=0;
+#endif
 
 	/* Packet is looped back after forward, it should not be
 	   forwarded second time, but still can be delivered locally.
@@ -1521,8 +1547,19 @@ int ip_mr_input(struct sk_buff *skb)
 	}
 
 	read_lock(&mrt_lock);
+	
+	
+#if defined (CONFIG_RTL_IGMP_PROXY)
+	vif_index=ipmr_find_vif(dev);
+	origin_temp = vif_index;
+	cache = ipmr_cache_find(net, origin_temp, ip_hdr(skb)->daddr);
+	if (cache==NULL){
+		cache = ipmr_cache_find(net, ip_hdr(skb)->saddr, ip_hdr(skb)->daddr);
+	}
+#else
 	cache = ipmr_cache_find(net, ip_hdr(skb)->saddr, ip_hdr(skb)->daddr);
 
+#endif
 	/*
 	 *	No usable cache entry
 	 */
diff --git a/net/ipv4/netfilter/Kconfig b/net/ipv4/netfilter/Kconfig
index 1833bdb..886b523 100644
--- a/net/ipv4/netfilter/Kconfig
+++ b/net/ipv4/netfilter/Kconfig
@@ -181,6 +181,16 @@ config IP_NF_TARGET_MASQUERADE
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config IP_NF_TARGET_CONENAT
+        tristate "CONENAT target support"
+        depends on NF_NAT
+	depends on IP_NF_TARGET_MASQUERADE
+        default m if NETFILTER_ADVANCED=n
+        help
+          It is a FULL CONE NAT(see RFC 3489), you can use it instead of MASQUERADE.
+
+          To compile it as a module, choose M here.  If unsure, say N.
+
 config IP_NF_TARGET_NETMAP
 	tristate "NETMAP target support"
 	depends on NF_NAT
@@ -204,6 +214,7 @@ config IP_NF_TARGET_REDIRECT
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+
 config NF_NAT_SNMP_BASIC
 	tristate "Basic SNMP-ALG support"
 	depends on NF_NAT
@@ -220,6 +231,7 @@ config NF_NAT_SNMP_BASIC
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+
 # If they want FTP, set to $CONFIG_IP_NF_NAT (m or y),
 # or $CONFIG_IP_NF_FTP (m or y), whichever is weaker.
 # From kconfig-language.txt:
@@ -283,6 +295,22 @@ config NF_NAT_SIP
 	depends on NF_CONNTRACK && NF_NAT
 	default NF_NAT && NF_CONNTRACK_SIP
 
+#
+# Desc:add ip sec for alg
+#
+config NF_NAT_IPSEC
+        tristate
+        depends on NF_CONNTRACK && NF_NAT
+        default NF_NAT && NF_CONNTRACK_IPSEC
+
+#
+# Desc:add rtsp for alg
+#
+config NF_NAT_RTSP
+        tristate
+        depends on NF_CONNTRACK && NF_NAT
+        default NF_NAT && NF_CONNTRACK_RTSP
+
 # mangle + specific targets
 config IP_NF_MANGLE
 	tristate "Packet mangling"
diff --git a/net/ipv4/netfilter/Makefile b/net/ipv4/netfilter/Makefile
index a638add..ba24526 100644
--- a/net/ipv4/netfilter/Makefile
+++ b/net/ipv4/netfilter/Makefile
@@ -30,7 +30,8 @@ obj-$(CONFIG_NF_NAT_PPTP) += nf_nat_pptp.o
 obj-$(CONFIG_NF_NAT_SIP) += nf_nat_sip.o
 obj-$(CONFIG_NF_NAT_SNMP_BASIC) += nf_nat_snmp_basic.o
 obj-$(CONFIG_NF_NAT_TFTP) += nf_nat_tftp.o
-
+obj-$(CONFIG_NF_NAT_IPSEC) += nf_nat_ipsec.o
+obj-$(CONFIG_NF_NAT_RTSP) += nf_nat_rtsp.o
 # NAT protocols (nf_nat)
 obj-$(CONFIG_NF_NAT_PROTO_DCCP) += nf_nat_proto_dccp.o
 obj-$(CONFIG_NF_NAT_PROTO_GRE) += nf_nat_proto_gre.o
@@ -61,6 +62,7 @@ obj-$(CONFIG_IP_NF_TARGET_NETMAP) += ipt_NETMAP.o
 obj-$(CONFIG_IP_NF_TARGET_REDIRECT) += ipt_REDIRECT.o
 obj-$(CONFIG_IP_NF_TARGET_REJECT) += ipt_REJECT.o
 obj-$(CONFIG_IP_NF_TARGET_ULOG) += ipt_ULOG.o
+obj-$(CONFIG_IP_NF_TARGET_CONENAT) += ipt_CONENAT.o
 
 # generic ARP tables
 obj-$(CONFIG_IP_NF_ARPTABLES) += arp_tables.o
diff --git a/net/ipv4/netfilter/ip_tables.c b/net/ipv4/netfilter/ip_tables.c
index 8c7c3d7..89f259c 100644
--- a/net/ipv4/netfilter/ip_tables.c
+++ b/net/ipv4/netfilter/ip_tables.c
@@ -54,7 +54,7 @@ typedef struct xt_rule_to_acl_s
 {
 	struct list_head list;
 	char iniface[IFNAMSIZ], outiface[IFNAMSIZ];
-	rtl865x_AclRule_t *aclRule;	
+	rtl865x_AclRule_t *aclRule;
 } xt_rule_to_acl_t;
 
 LIST_HEAD(rtl865x_iptRule2Acl_tbl_list);
@@ -380,7 +380,7 @@ ipt_do_table(struct sk_buff *skb,
 	back = get_entry(table_base, private->underflow[hook]);
 
 	if(ip == NULL)
-	{	
+	{
 		//printk("==========%s %s(%d), ip header is NULL!!!\n",__FILE__,__FUNCTION__,__LINE__);
 		return NF_DROP;
 	}
@@ -388,13 +388,13 @@ ipt_do_table(struct sk_buff *skb,
 	do {
 		IP_NF_ASSERT(e);
 		IP_NF_ASSERT(back);
-		
+
 		if(e == NULL)
 		{
 			//printk("==========%s %s(%d), ip header is NULL!!!\n",__FILE__,__FUNCTION__,__LINE__);
 			return NF_DROP;
 		}
-		
+
 		if (ip_packet_match(ip, indev, outdev,
 		    &e->ip, mtpar.fragoff)) {
 			struct ipt_entry_target *t;
@@ -499,7 +499,7 @@ mark_source_chains(struct xt_table_info *newinfo,
 {
 	unsigned int hook;
 
-#if 0 //def CONFIG_RTL_HARDWARE_NAT  
+#if 0 //def CONFIG_RTL_HARDWARE_NAT
 	/*2007-12-19*/
 	unsigned int masqif_set = 0;
 #endif
@@ -598,7 +598,7 @@ mark_source_chains(struct xt_table_info *newinfo,
 					newpos = pos + e->next_offset;
 				}
 
-				
+
 #if 0 // defined(CONFIG_RTL_HARDWARE_NAT)
 				/*2007-12-19*/
 #ifdef CONFIG_HARDWARE_NAT_DEBUG
@@ -610,11 +610,11 @@ mark_source_chains(struct xt_table_info *newinfo,
 					//printk("%s:%d:t->target.u.kernel.target->name is %s\n",__FUNCTION__,__LINE__,t->target.u.kernel.target->name);
 					printk("%s:%d:e->src(%u.%u.%u.%u),e->dst(%u.%u.%u.%u)\n",__FUNCTION__,
 						__LINE__,NIPQUAD(e->ip.src.s_addr),NIPQUAD(e->ip.dst.s_addr));
-					
+
 				}
 #endif
 				if ((masq_if[0] == '\0') && (hook == NF_INET_POST_ROUTING) &&
-					((strcmp(t->target.u.user.name, "MASQUERADE") == 0)	)) 
+					((strcmp(t->target.u.user.name, "MASQUERADE") == 0)	))
 				{
 					struct net_device *dev;
 					struct in_ifaddr *ina;
@@ -622,16 +622,16 @@ mark_source_chains(struct xt_table_info *newinfo,
 					masqif_set = 1;
 					memcpy(masq_if, e->ip.outiface, IFNAMSIZ);
 					dev = __dev_get_by_name(&init_net, masq_if);
-					
+
 					#ifdef CONFIG_HARDWARE_NAT_DEBUG
 					/*2007-12-19*/
 					printk("%s:%d:masq_if is %s\n",__FUNCTION__,__LINE__,masq_if);
 					#endif
 
-					if ((dev)&&(dev->ip_ptr)) {			
-						
-						ina=(struct in_ifaddr *)(((struct in_device *)(dev->ip_ptr))->ifa_list);						
-						if (ina!=NULL) 
+					if ((dev)&&(dev->ip_ptr)) {
+
+						ina=(struct in_ifaddr *)(((struct in_device *)(dev->ip_ptr))->ifa_list);
+						if (ina!=NULL)
 						{
 							if (hw_napt_ip) {
 								rc = 0;
@@ -649,7 +649,7 @@ mark_source_chains(struct xt_table_info *newinfo,
 							//printk("%s:%d:masq_if is %s\n",__FUNCTION__,__LINE__,masq_if);
 							//printk("---------------ip(%u.%u.%u.%u)\n",NIPQUAD((u32)(ina->ifa_local)));
 							rc = rtl865x_addIp(0,(u32)(ina->ifa_local),IP_TYPE_NAPT);
-			#endif							
+			#endif
 
 							if (rc == SUCCESS)
 								hw_napt_ip = ina->ifa_local;
@@ -661,7 +661,7 @@ mark_source_chains(struct xt_table_info *newinfo,
 					}
 				}
 
-#endif							
+#endif
 
 				e = (struct ipt_entry *)
 					(entry0 + newpos);
@@ -676,7 +676,7 @@ mark_source_chains(struct xt_table_info *newinfo,
 		if (masqif_set == 0 && masq_if[0] != '\0' && hook==NF_INET_POST_ROUTING) {
 			masq_if[0] = '\0';
 		}
-#endif	
+#endif
 
 	}
 	return 1;
@@ -876,7 +876,7 @@ check_entry_size_and_hooks(struct ipt_entry *e,
 	/* Clear counters and comefrom */
 	e->counters = ((struct xt_counters) { 0, 0 });
 	e->comefrom = 0;
-	
+
 	(*i)++;
 	return 0;
 }
@@ -907,7 +907,7 @@ cleanup_entry(struct ipt_entry *e, unsigned int *i)
 
 #if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
 static struct xt_target ipt_standard_target;
-static struct xt_target ipt_error_target; 
+static struct xt_target ipt_error_target;
 
 static void rtl865x_print_iptRule2Acl_tbl(void)
 {
@@ -924,18 +924,18 @@ static void rtl865x_print_iptRule2Acl_tbl(void)
 			list_for_each_entry(match2acl,&listNode->chainList[i],list)
 			{
 				printk("  inIf(%s) outIn(%s) aclType(0x%x) aclAction(0x%x),direction(%d)\n",match2acl->iniface,match2acl->outiface,match2acl->aclRule->ruleType_,match2acl->aclRule->actionType_,match2acl->aclRule->direction_);
-			}			
+			}
 		}
-		
+
 	}
 	printk("=======================================\n");
 }
 
 static rtl865x_iptRule2Acl_tbl* rtl865x_get_ipt2Acl_tbl(const char *name)
 {
-	rtl865x_iptRule2Acl_tbl *listNode,*retEntry;	
+	rtl865x_iptRule2Acl_tbl *listNode,*retEntry;
 	retEntry = NULL;
-	
+
 	list_for_each_entry(listNode,&rtl865x_iptRule2Acl_tbl_list,list)
 	{
 		if(memcmp(listNode->tblName,name,strlen(name)) == 0)
@@ -957,9 +957,9 @@ static int ipt_ip2Acl(struct ipt_entry *e, rtl865x_AclRule_t *acl, int *all_matc
 
 
 	acl->ruleType_ = RTL865X_ACL_IP;
-		
+
 	/*proto 0=ANY */
-	if(e->ip.proto == 0)		
+	if(e->ip.proto == 0)
 		acl->ipProtoMask_ = 0x0;
 	else
 		acl->ipProtoMask_ = 0xff;
@@ -1011,17 +1011,17 @@ static int standard_target2Acl(struct ipt_entry_target *t,rtl865x_AclRule_t *rul
 		default:
 			rule->actionType_ = RTL865X_ACL_TOCPU;
 			break;
-					
+
 	}
 	return 0;
 }
 
 /*translate iptables rule to ACL*/
-static int translate_rule2Acl(struct ipt_entry *e,  
+static int translate_rule2Acl(struct ipt_entry *e,
 unsigned char *base,const char *name,unsigned int size,
 const unsigned int valid_hooks,const unsigned int *hook_entries)
 {
-	
+
 	int match_cnt = 0;
 	int hook_num = -1;
 	int nxt_hookNum = -1;
@@ -1052,10 +1052,10 @@ const unsigned int valid_hooks,const unsigned int *hook_entries)
 	hook_num = get_hookNum(e,base,valid_hooks,hook_entries);
 
 	/*last entry of this hooknum??*/
-	last_entry = 0;	
+	last_entry = 0;
 	if(((void *) e - (void *)base + e->next_offset) >= size)
 		last_entry = 1;
-	
+
 	if(last_entry == 0)
 	{
 		nxt_entry = (struct ipt_entry *)((void *)e + e->next_offset);
@@ -1081,7 +1081,7 @@ const unsigned int valid_hooks,const unsigned int *hook_entries)
 	if(last_entry)
 	{
 		if(t->u.kernel.target == &ipt_standard_target)
-		{			
+		{
 			switch((-((struct ipt_standard_target *)t)->verdict) -1)
 			{
 				case NF_DROP:
@@ -1099,21 +1099,21 @@ const unsigned int valid_hooks,const unsigned int *hook_entries)
 				default:
 					 default_action = RTL865X_ACL_TOCPU;
 					break;
-							
+
 			}
-			
+
 			if(hook_num == NF_INET_LOCAL_IN)
 				in_def_action = default_action;
 			else if(hook_num == NF_INET_LOCAL_OUT)
 				out_def_action = default_action;
-			
+
 		}
 	}
 
 	///*only translate input&forward chain rule*/
 	//translate all chains for filter table now...
 	#if 0
-	if(	(hook_num >= NF_INET_LOCAL_OUT 
+	if(	(hook_num >= NF_INET_LOCAL_OUT
 #if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
 		&& memcmp(name, RTL865X_QOS_TABLE_NAME, RTL865X_QOS_TABLE_LEN)
 #endif
@@ -1122,24 +1122,24 @@ const unsigned int valid_hooks,const unsigned int *hook_entries)
 	#else
 	if(last_entry)
 		goto next;
-	
+
 	#endif
-	
-	list_node = kmalloc(sizeof(xt_rule_to_acl_t),GFP_KERNEL);	
+
+	list_node = kmalloc(sizeof(xt_rule_to_acl_t),GFP_KERNEL);
 	if(!list_node)
 	{
 		printk("\n!!!!!!%s(%d): No memory freed for kmalloc!!!",__FUNCTION__,__LINE__);
 		goto next;
 	}
-		
+
 	rule = kmalloc(sizeof(rtl865x_AclRule_t), GFP_KERNEL);
 	if(!rule)
-	{			
+	{
 		printk("\n!!!!!!%s(%d): No memory freed for kmalloc!!!",__FUNCTION__,__LINE__);
 		goto next;
 	}
 
-	
+
 	memset(rule, 0,sizeof(rtl865x_AclRule_t));
 	//default: all packet to cpu
 	rule->actionType_ = RTL865X_ACL_TOCPU;
@@ -1148,11 +1148,11 @@ const unsigned int valid_hooks,const unsigned int *hook_entries)
 	/*invert interface flag*/
 	if(e->ip.invflags & IPT_INV_VIA_IN)
 		rule->inv_flag = RTL865X_INVERT_IN_NETIF;
-	
+
 	else if(e->ip.invflags & IPT_INV_VIA_OUT)
 		rule->inv_flag = RTL865X_INVERT_OUT_NETIF;
-	
-	target = t->u.kernel.target;		
+
+	target = t->u.kernel.target;
 	match_cnt = IPT_MATCH_NUMBER(e);
 	retval = -1;
 	if(match_cnt == 0)
@@ -1163,7 +1163,7 @@ const unsigned int valid_hooks,const unsigned int *hook_entries)
 
 		if(retval != 0)
 			printk("%s(%d) BUG!!!!\n",__FUNCTION__,__LINE__);
-		
+
 		/*acl action....*/
 		if(t->u.kernel.target == &ipt_standard_target)
 		{
@@ -1177,8 +1177,8 @@ const unsigned int valid_hooks,const unsigned int *hook_entries)
 			{
 #if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
 				/* Add the following conditions for pathing qos rules */
-				if (!memcmp(name, RTL865X_QOS_TABLE_NAME, RTL865X_QOS_TABLE_LEN) && 
-					e->ip.outiface[0]=='\0' && 
+				if (!memcmp(name, RTL865X_QOS_TABLE_NAME, RTL865X_QOS_TABLE_LEN) &&
+					e->ip.outiface[0]=='\0' &&
 					retval == RTL_QOSFINDSPECIALNETIF)
 				{
 					memcpy(qosIfName, data, strlen(data));
@@ -1209,15 +1209,15 @@ const unsigned int valid_hooks,const unsigned int *hook_entries)
 				rule->actionType_ = RTL865X_ACL_DROP;
 			else if (rule->actionType_ == RTL865X_ACL_DROP)
 				rule->actionType_ = RTL865X_ACL_PERMIT;
-		}			
+		}
 	}
 	else if(match_cnt == 1)
 	{
 		__match = (void *)(e) + sizeof(struct ipt_entry);
-			
+
 		/*translate match to ACL rule...*/
 		if(__match->u.kernel.match && __match->u.kernel.match->match2acl)
-		{	
+		{
 			retval = __match->u.kernel.match->match2acl(name, &e->ip, __match->u.kernel.match, __match->data,rule,&invflags);
 			if(retval == 0)
 			{
@@ -1250,9 +1250,9 @@ const unsigned int valid_hooks,const unsigned int *hook_entries)
 						default:
 							rule->actionType_ = RTL865X_ACL_TOCPU;
 							break;
-						
+
 					}
-					#endif					
+					#endif
 				}
 				else if (t->u.kernel.target->target2acl)
 				{
@@ -1261,8 +1261,8 @@ const unsigned int valid_hooks,const unsigned int *hook_entries)
 					{
 #if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
 						/* Add the following conditions for pathing qos rules */
-						if (!memcmp(name, RTL865X_QOS_TABLE_NAME, RTL865X_QOS_TABLE_LEN) && 
-							e->ip.outiface[0]=='\0' && 
+						if (!memcmp(name, RTL865X_QOS_TABLE_NAME, RTL865X_QOS_TABLE_LEN) &&
+							e->ip.outiface[0]=='\0' &&
 							retval == RTL_QOSFINDSPECIALNETIF)
 						{
 							memcpy(qosIfName, data, strlen(data));
@@ -1335,7 +1335,7 @@ const unsigned int valid_hooks,const unsigned int *hook_entries)
 						default:
 							rule->actionType_ = RTL865X_ACL_TOCPU;
 							break;
-						
+
 					}
 					#endif
 				}
@@ -1346,8 +1346,8 @@ const unsigned int valid_hooks,const unsigned int *hook_entries)
 					{
 #if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
 						/* Add the following conditions for pathing qos rules */
-						if (!memcmp(name, RTL865X_QOS_TABLE_NAME, RTL865X_QOS_TABLE_LEN) && 
-							e->ip.outiface[0]=='\0' && 
+						if (!memcmp(name, RTL865X_QOS_TABLE_NAME, RTL865X_QOS_TABLE_LEN) &&
+							e->ip.outiface[0]=='\0' &&
 							retval == RTL_QOSFINDSPECIALNETIF)
 						{
 							memcpy(qosIfName, data, strlen(data));
@@ -1391,9 +1391,9 @@ const unsigned int valid_hooks,const unsigned int *hook_entries)
 
 				if(rule->actionType_ == RTL865X_ACL_PERMIT)
 					establish_rule_permit = 1;
-				
+
 				goto next;
-			}			
+			}
 			else if(retval == RTL865X_SKIP_THIS_RULE)
 			{
 				goto next;
@@ -1416,7 +1416,7 @@ const unsigned int valid_hooks,const unsigned int *hook_entries)
 	{
 		int		len;
 		int		hasNoSpt = FALSE;
-		
+
 		len = 0;
 		while(match_cnt>0)
 		{
@@ -1445,10 +1445,10 @@ const unsigned int valid_hooks,const unsigned int *hook_entries)
 
 		if (hasNoSpt==TRUE)
 			retval = RTL865X_MATCH_NOT_SUPPORTED;
-		
+
 		if(retval == 0)
 		{
-		
+
 			/*translate target to ACL action*/
 			if(t->u.kernel.target == &ipt_standard_target)
 			{
@@ -1478,7 +1478,7 @@ const unsigned int valid_hooks,const unsigned int *hook_entries)
 					default:
 						rule->actionType_ = RTL865X_ACL_TOCPU;
 						break;
-					
+
 				}
 				#endif
 			}
@@ -1489,8 +1489,8 @@ const unsigned int valid_hooks,const unsigned int *hook_entries)
 				{
 #if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
 					/* Add the following conditions for pathing qos rules */
-					if (!memcmp(name, RTL865X_QOS_TABLE_NAME, RTL865X_QOS_TABLE_LEN) && 
-						e->ip.outiface[0]=='\0' && 
+					if (!memcmp(name, RTL865X_QOS_TABLE_NAME, RTL865X_QOS_TABLE_LEN) &&
+						e->ip.outiface[0]=='\0' &&
 						retval == RTL_QOSFINDSPECIALNETIF)
 					{
 						memcpy(qosIfName, data, strlen(data));
@@ -1520,7 +1520,7 @@ const unsigned int valid_hooks,const unsigned int *hook_entries)
 			{
 				rule->actionType_ = RTL865X_ACL_TOCPU;
 			}
-			
+
 			/*invert interface flag*/
 			if(invflags)
 			{
@@ -1528,8 +1528,8 @@ const unsigned int valid_hooks,const unsigned int *hook_entries)
 					rule->actionType_ = RTL865X_ACL_DROP;
 				else if(rule->actionType_ == RTL865X_ACL_DROP)
 					rule->actionType_ = RTL865X_ACL_PERMIT;
-			}	
-			
+			}
+
 		}
 		else if(retval == RTL865X_SKIP_THIS_RULE)
 		{
@@ -1554,7 +1554,7 @@ const unsigned int valid_hooks,const unsigned int *hook_entries)
 		goto next;
 
 	/*add xt_rule_to_acl to list*/
-	/* 
+	/*
 	  *	Since we do the acl check actually in PREROUTING chain
 	  *	Some toCpu pkt maybe mis-decided by FORWARD chain rules
 	  *	So, we do the following patch.
@@ -1563,7 +1563,7 @@ const unsigned int valid_hooks,const unsigned int *hook_entries)
 	{
 		if(rule->actionType_ != RTL865X_ACL_PERMIT)
 			rule->actionType_ = RTL865X_ACL_TOCPU;
-		
+
 		rule->pktOpApp_ = RTL865X_ACL_L3_AND_L4;
 	}
 
@@ -1571,7 +1571,7 @@ const unsigned int valid_hooks,const unsigned int *hook_entries)
 		rule->direction_ = RTL865X_ACL_INGRESS;
 	else
 		rule->direction_ = RTL865X_ACL_EGRESS;
-	
+
 	list_node->aclRule = rule;
 #if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
 	if (qosIfName[0]!='\0')
@@ -1609,12 +1609,12 @@ next:
 	/*free memory and return*/
 	if(rule)
 		kfree(rule);
-	
+
 	if(list_node)
 		kfree(list_node);
-		
+
 	return 0;
-	
+
 }
 
 static int translate_ipTblRules2Acl(const char *name,
@@ -1652,7 +1652,7 @@ static int translate_ipTblRules2Acl(const char *name,
 		list_for_each_entry_safe(list_node,nxt,&rtl865x_iptRule2Acl_def_rule_list,list)
 		{
 			list_del(&list_node->list);
-			list_add_tail(&list_node->list,&ipt2aclTbl->chainList[RTL865x_CHAINLIST_PRIORITY_LEVEL_4]);		
+			list_add_tail(&list_node->list,&ipt2aclTbl->chainList[RTL865x_CHAINLIST_PRIORITY_LEVEL_4]);
 		}
 
 	/*hyking:
@@ -1662,27 +1662,27 @@ static int translate_ipTblRules2Acl(const char *name,
 //	if((def_action == RTL865X_ACL_DROP) && !memcmp(name,"filter",strlen("filter")))
 		if(establish_rule_permit == 1)
 			in_def_action = RTL865X_ACL_PERMIT;
-		
+
 		if((in_def_action == RTL865X_ACL_DROP))
-		{	
+		{
 			/*deal with the permit multicast acl...*/
-			list_node = kmalloc(sizeof(xt_rule_to_acl_t),GFP_KERNEL);	
+			list_node = kmalloc(sizeof(xt_rule_to_acl_t),GFP_KERNEL);
 			if(!list_node)
 			{
 				printk("\n!!!!!!%s(%d): No memory freed for kmalloc!!!",__FUNCTION__,__LINE__);
 				goto next;
 			}
-				
+
 			rule = kmalloc(sizeof(rtl865x_AclRule_t), GFP_KERNEL);
 			if(!rule)
 			{
 				if(list_node)
 					kfree(list_node);
-				
+
 				printk("\n!!!!!!%s(%d): No memory freed for kmalloc!!!",__FUNCTION__,__LINE__);
 				goto next;
 			}
-			
+
 			/*permit all multicast packet...*/
 			memset(rule, 0,sizeof(rtl865x_AclRule_t));
 			rule->ruleType_ = RTL865X_ACL_MAC;
@@ -1691,30 +1691,30 @@ static int translate_ipTblRules2Acl(const char *name,
 
 			rule->dstMac_.octet[0] = 0x01;
 			rule->dstMacMask_.octet[0] = 0x01;
-			
+
 			/*add xt_rule_to_acl to list*/
 			list_node->aclRule = rule;
 			list_node->iniface[0] = '\0';
 			list_add_tail(&list_node->list,&ipt2aclTbl->chainList[RTL865x_CHAINLIST_PRIORITY_LEVEL_3]);
 
 			/*permit all arp packet*/
-			list_node = kmalloc(sizeof(xt_rule_to_acl_t),GFP_KERNEL);	
+			list_node = kmalloc(sizeof(xt_rule_to_acl_t),GFP_KERNEL);
 			if(!list_node)
 			{
 				printk("\n!!!!!!%s(%d): No memory freed for kmalloc!!!",__FUNCTION__,__LINE__);
 				goto next;
 			}
-				
+
 			rule = kmalloc(sizeof(rtl865x_AclRule_t), GFP_KERNEL);
 			if(!rule)
 			{
 				if(list_node)
 					kfree(list_node);
-				
+
 				printk("\n!!!!!!%s(%d): No memory freed for kmalloc!!!",__FUNCTION__,__LINE__);
 				goto next;
 			}
-			
+
 			/*permit all arp packet...*/
 			memset(rule, 0,sizeof(rtl865x_AclRule_t));
 			rule->ruleType_ = RTL865X_ACL_MAC;
@@ -1723,31 +1723,31 @@ static int translate_ipTblRules2Acl(const char *name,
 
 			rule->typeLen_ = 0x0806;
 			rule->typeLenMask_ = 0xffff;
-			
+
 			/*add xt_rule_to_acl to list*/
 			list_node->aclRule = rule;
 			list_node->iniface[0] = '\0';
 			list_add_tail(&list_node->list,&ipt2aclTbl->chainList[RTL865x_CHAINLIST_PRIORITY_LEVEL_3]);
-			
+
 		}
 
 		//in bound
-		list_node = kmalloc(sizeof(xt_rule_to_acl_t),GFP_KERNEL);	
+		list_node = kmalloc(sizeof(xt_rule_to_acl_t),GFP_KERNEL);
 		if(!list_node)
 		{
 			printk("\n!!!!!!%s(%d): No memory freed for kmalloc!!!",__FUNCTION__,__LINE__);
 			goto next;
 		}
-			
+
 		rule = kmalloc(sizeof(rtl865x_AclRule_t), GFP_KERNEL);
 		if(!rule)
-{
+		{
 			if(list_node)
 				kfree(list_node);
 
 			printk("\n!!!!!!%s(%d): No memory freed for kmalloc!!!",__FUNCTION__,__LINE__);
 			goto next;
-	}
+		}
 
 		memset(rule, 0,sizeof(rtl865x_AclRule_t));
 
@@ -1757,17 +1757,17 @@ static int translate_ipTblRules2Acl(const char *name,
 			rule->actionType_	= in_def_action;
 			rule->pktOpApp_ 	= RTL865X_ACL_ALL_LAYER;
 			rule->direction_ = RTL865X_ACL_INGRESS;
-			
+
 			/*add xt_rule_to_acl to list*/
 			list_node->aclRule = rule;
 			list_node->iniface[0] = '\0';
 			list_add_tail(&list_node->list,&ipt2aclTbl->chainList[RTL865x_CHAINLIST_PRIORITY_LEVEL_4]);
-}
+		}
 
 		//outbound
-		list_node = kmalloc(sizeof(xt_rule_to_acl_t),GFP_KERNEL);	
+		list_node = kmalloc(sizeof(xt_rule_to_acl_t),GFP_KERNEL);
 		if(!list_node)
-{
+		{
 			printk("\n!!!!!!%s(%d): No memory freed for kmalloc!!!",__FUNCTION__,__LINE__);
 			goto next;
 		}
@@ -1780,12 +1780,12 @@ static int translate_ipTblRules2Acl(const char *name,
 
 			printk("\n!!!!!!%s(%d): No memory freed for kmalloc!!!",__FUNCTION__,__LINE__);
 			goto next;
-}
+		}
 
 		memset(rule, 0,sizeof(rtl865x_AclRule_t));
 
 
-{
+		{
 			rule->ruleType_	= RTL865X_ACL_MAC;
 			rule->actionType_	= out_def_action;
 			rule->pktOpApp_ 	= RTL865X_ACL_ALL_LAYER;
@@ -1800,7 +1800,7 @@ static int translate_ipTblRules2Acl(const char *name,
 
 	return 0;
 
-next:	
+next:
 	return ret;
 }
 
@@ -1812,7 +1812,7 @@ static int rtl865x_free_chain_inIpt2Acl_tbl(struct list_head *listHead)
 	{
 		list_del(&match2acl->list);
 		kfree(match2acl->aclRule);
-		kfree(match2acl);			
+		kfree(match2acl);
 	}
 
 	return 0;
@@ -1848,7 +1848,29 @@ void rtl865x_rearrange_ipt2Acl_tbl(char *name)
 	rtl865x_iptRule2Acl_tbl *ipt2aclTbl;
 	xt_rule_to_acl_t *match2acl;
 	int i,retval;
+#if defined(CONFIG_RTL_IPTABLES2ACL_PATCH)
+	list_for_each_entry(ipt2aclTbl,&rtl865x_iptRule2Acl_tbl_list,list)
+	{
+		rtl865x_flush_allAcl_sw_fromChain(NULL,ipt2aclTbl->priority,RTL865X_ACL_INGRESS);
+		rtl865x_flush_allAcl_sw_fromChain(NULL,ipt2aclTbl->priority,RTL865X_ACL_EGRESS);
+	}
 
+	//_rtl865x_synAclwithAsicTbl();
+
+	list_for_each_entry(ipt2aclTbl,&rtl865x_iptRule2Acl_tbl_list,list)
+	{
+		for(i = 0; i < RTL865X_CHAINLIST_NUMBER_PER_TBL; i++)
+		{
+			list_for_each_entry(match2acl,&ipt2aclTbl->chainList[i],list)
+			{
+				retval = rtl865x_add_sw_acl(match2acl->aclRule, match2acl->iniface, ipt2aclTbl->priority);
+			}
+		}
+
+	}
+
+	_rtl865x_synAclwithAsicTbl();
+#else
 	//hyking:since default permit before rearrange rules to acl table,don't add permit acl now.
 	//rtl865x_add_def_permit_acl();
 
@@ -1857,18 +1879,19 @@ void rtl865x_rearrange_ipt2Acl_tbl(char *name)
 		/*firstly, remove all acl which is add by user...*/
 		rtl865x_flush_allAcl_fromChain(NULL,ipt2aclTbl->priority,RTL865X_ACL_INGRESS);
 		rtl865x_flush_allAcl_fromChain(NULL,ipt2aclTbl->priority,RTL865X_ACL_EGRESS);
-		
+
 		for(i = 0; i < RTL865X_CHAINLIST_NUMBER_PER_TBL; i++)
 		{
 			list_for_each_entry(match2acl,&ipt2aclTbl->chainList[i],list)
-			{			
+			{
 				retval = rtl865x_add_acl(match2acl->aclRule, match2acl->iniface, ipt2aclTbl->priority);
 			}
 		}
 	}
 
 	//rtl865x_del_def_permit_acl();
-	}
+#endif
+}
 
 
 /*
@@ -1878,15 +1901,15 @@ int rtl865x_register_ipt2Acl_tbl(rtl865x_iptRule2Acl_tbl *tbl)
 {
 	rtl865x_iptRule2Acl_tbl *node,*insPos;
 
-	insPos = NULL;	
+	insPos = NULL;
 	node = NULL;
 
 	node = rtl865x_get_ipt2Acl_tbl(tbl->tblName);
 	if(node != NULL)
 		return -1;
-	
+
 	list_for_each_entry(node,&rtl865x_iptRule2Acl_tbl_list,list)
-{
+	{
 		if(node->priority > tbl->priority)
 		{
 			insPos = node;
@@ -1919,8 +1942,8 @@ int rtl865x_unregister_ipt2Acl_tbl(char *tblName)
 			for(i = 0; i < RTL865X_CHAINLIST_NUMBER_PER_TBL; i++)
 				rtl865x_free_chain_inIpt2Acl_tbl(&listNode->chainList[i]);
 			kfree(listNode);
-	return 0;
-}
+			return 0;
+		}
 	}
 
 	return -1;
@@ -2004,7 +2027,7 @@ translate_table(const char *name,
 		rtl865x_iptRule2Acl_tbl *tbl;
 		int i,ret;
 		int32_t priority;
-		
+
 		if(memcmp(name,"filter",strlen("filter")) == 0)
 			priority = RTL865X_ACL_USER_USED;
 #if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
@@ -2033,8 +2056,8 @@ translate_table(const char *name,
 			if(ret != 0)
 			{
 				kfree(tbl);
-			}			
-		}		
+			}
+		}
 	}
 #endif
 #if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
@@ -2490,7 +2513,7 @@ do_replace(struct net *net, void __user *user, unsigned int len)
 			   tmp.num_counters, tmp.counters);
 	if (ret)
 		goto free_newinfo_untrans;
-	
+
 #if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
 	//rtl865x_rearrange_iptblAcl();
 	//rtl865x_print_iptRule2Acl_tbl();
@@ -2502,7 +2525,7 @@ do_replace(struct net *net, void __user *user, unsigned int len)
  free_newinfo_untrans:
 	IPT_ENTRY_ITERATE(loc_cpu_entry, newinfo->size, cleanup_entry, NULL);
  free_newinfo:
- 	
+
 #if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
 	rtl865x_free_allchains_inIpt2Acl_tbl(tmp.name);
 #endif
@@ -3370,7 +3393,7 @@ static int icmp_match2acl(const char *tablename,
 	unsigned int code_range = 0;
 	int i = 0;
 	rtl865x_AclRule_t *rule = (rtl865x_AclRule_t *)acl_rule;
-	
+
 
 	if(ip == NULL || matchinfo == NULL)
 		return 1;
@@ -3396,8 +3419,8 @@ static int icmp_match2acl(const char *tablename,
 
 	if(icmpinfo->invflags & IPT_ICMP_INV)
 		if(invflags)
-			*invflags = 1;	
-	
+			*invflags = 1;
+
 	return 0;
 }
 #endif
@@ -3491,7 +3514,7 @@ static int __init ip_tables_init(void)
 	#if defined(CONFIG_RTL_819X)
 	rtl_ip_tables_init_hooks();
 	#endif
-	
+
 #if defined (CONFIG_RTL_IGMP_SNOOPING) && defined (CONFIG_NETFILTER)
 		IgmpRxFilter_Hook = ipt_do_table;
 #endif
diff --git a/net/ipv4/netfilter/ipt_MASQUERADE.c b/net/ipv4/netfilter/ipt_MASQUERADE.c
index b80c059..c978d70 100644
--- a/net/ipv4/netfilter/ipt_MASQUERADE.c
+++ b/net/ipv4/netfilter/ipt_MASQUERADE.c
@@ -23,7 +23,6 @@
 #include <linux/netfilter_ipv4.h>
 #include <linux/netfilter/x_tables.h>
 
-
 #if defined (CONFIG_RTL_819X)
 #include <net/rtl/features/rtl_ps_hooks.h>
 #endif
@@ -65,6 +64,10 @@ masquerade_tg(struct sk_buff *skb, const struct xt_target_param *par)
 	const struct nf_nat_multi_range_compat *mr;
 	const struct rtable *rt;
 	__be32 newsrc;
+#if defined(CONFIG_IP_NF_TARGET_CONENAT)
+	extern unsigned int conenat_type;
+	unsigned int ret;
+#endif
 
 	NF_CT_ASSERT(par->hooknum == NF_INET_POST_ROUTING);
 
@@ -113,6 +116,15 @@ masquerade_tg(struct sk_buff *skb, const struct xt_target_param *par)
 	nat->masq_index = par->out->ifindex;
 	write_unlock_bh(&masq_lock);
 
+#if defined(CONFIG_IP_NF_TARGET_CONENAT)
+	if ((conenat_type >=1) && (conenat_type <= 3) &&
+	     (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.protonum == IPPROTO_UDP))
+	{
+	       extern unsigned int rtl_find_appropriate_newrange(struct nf_conn *ct, __be32 newsrc, const struct nf_nat_multi_range_compat *mr);
+		ret = rtl_find_appropriate_newrange(ct, newsrc, mr);
+		return ret;
+	}
+#endif
 	/* Transfer from original range. */
 	newrange = ((struct nf_nat_range)
 		{ mr->range[0].flags | IP_NAT_RANGE_MAP_IPS,
@@ -167,7 +179,7 @@ static int masq_inet_event(struct notifier_block *this,
 			   void *ptr)
 {
 	struct net_device *dev = ((struct in_ifaddr *)ptr)->ifa_dev->dev;
-	
+
 	if(event == NETDEV_DOWN)
 		masq_device_event(this, event, dev);
 
diff --git a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
index 64e165c..3ebe9e0 100644
--- a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
+++ b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
@@ -186,12 +186,15 @@ static struct nf_hook_ops ipv4_conntrack_ops[] __read_mostly = {
 };
 
 #if defined(CONFIG_SYSCTL) && defined(CONFIG_NF_CONNTRACK_PROC_COMPAT)
-static int log_invalid_proto_min = 0;
-static int log_invalid_proto_max = 255;
+
 #if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
 extern int conntrack_dointvec(ctl_table *table, int write, struct file *filp,
 		     void *buffer, size_t *lenp, loff_t *ppos);
 #endif
+
+static int log_invalid_proto_min = 0;
+static int log_invalid_proto_max = 255;
+
 static ctl_table ip_ct_sysctl_table[] = {
 	{
 		.ctl_name	= NET_IPV4_NF_CONNTRACK_MAX,
diff --git a/net/ipv4/netfilter/nf_nat_core.c b/net/ipv4/netfilter/nf_nat_core.c
index 6d145d7..0caf61c 100644
--- a/net/ipv4/netfilter/nf_nat_core.c
+++ b/net/ipv4/netfilter/nf_nat_core.c
@@ -39,6 +39,7 @@
 #if defined(CONFIG_RTL_819X)
 #include <net/rtl/features/rtl_ps_hooks.h>
 #endif
+#include <net/rtl/features/rtl_ps_log.h>
 
 static DEFINE_SPINLOCK(nf_nat_lock);
 
@@ -305,7 +306,7 @@ get_unique_tuple(struct nf_conntrack_tuple *tuple,
 				rtl865x_preReserveConn(&rtl865xNaptEntry);
 				goto out;
 			}
-
+		
 		}
 		else
 		{
@@ -333,6 +334,12 @@ nf_nat_setup_info(struct nf_conn *ct,
 	struct net *net = nf_ct_net(ct);
 	struct nf_conntrack_tuple curr_tuple, new_tuple;
 	struct nf_conn_nat *nat;
+	#if defined(CONFIG_RTL_BATTLENET_ALG)
+	extern unsigned int _br0_ip;
+	extern unsigned int _br0_mask;
+	struct nf_conn *ct_temp = NULL;
+	int flag_ori;
+	#endif
 	int have_to_hash = !(ct->status & IPS_NAT_DONE_MASK);
 
 	/* nat helper or nfctnetlink also setup binding */
@@ -365,6 +372,25 @@ nf_nat_setup_info(struct nf_conn *ct,
 		nf_ct_invert_tuplepr(&reply, &new_tuple);
 		nf_conntrack_alter_reply(ct, &reply);
 
+		#if defined(CONFIG_RTL_BATTLENET_ALG)
+		if((ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.protonum == IPPROTO_UDP) &&
+		    (ntohs(ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.all) == BATTLENET_PORT) &&
+		    ((ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip & _br0_mask) == (_br0_ip & _br0_mask)) &&
+		    ((ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip & _br0_mask) != (_br0_ip & _br0_mask)))
+		{
+			spin_lock_bh(&nf_conntrack_lock);
+
+			ct_temp = rtl_find_ct_by_tuple_src(&(ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple), &flag_ori);
+
+			if((flag_ori == 1) && (ct_temp != NULL))
+			{
+				if((ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u.all) != (ct_temp->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u.all))
+					ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u.all  = ct_temp->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u.all;
+			}
+
+			spin_unlock_bh(&nf_conntrack_lock);
+		}
+		#endif
 		/* Non-atomic: we own this at the moment. */
 		if (maniptype == IP_NAT_MANIP_SRC)
 			ct->status |= IPS_SRC_NAT;
@@ -430,7 +456,32 @@ manip_pkt(u_int16_t proto,
 	}
 	return true;
 }
+#if defined(CONFIG_RTL_BATTLENET_ALG)
+static void rtl_set_nat_status(struct nf_conn *ct, struct sk_buff *skb, enum nf_nat_manip_type mtype)
+{
+	extern unsigned int _br0_ip;
+	extern unsigned int _br0_mask;
+
+	if((ip_hdr(skb)->protocol == IPPROTO_UDP) &&
+	  (ntohs(ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.all) == BATTLENET_PORT) &&
+	  ((ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip & _br0_mask) == (_br0_ip & _br0_mask)) &&
+	  (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip == wan_ip)&&
+	  (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip != ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip) &&
+	  (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip != ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3.ip))
+	  {
+		if (mtype == IP_NAT_MANIP_SRC)
+			ct->status |= IPS_SRC_NAT;
+		else
+			ct->status |= IPS_DST_NAT;
 
+		/* It's done. */
+		if (mtype == IP_NAT_MANIP_DST)
+			set_bit(IPS_DST_NAT_DONE_BIT, &ct->status);
+		else
+			set_bit(IPS_SRC_NAT_DONE_BIT, &ct->status);
+	  }
+}
+#endif
 /* Do packet manipulations according to nf_nat_setup_info. */
 unsigned int nf_nat_packet(struct nf_conn *ct,
 			   enum ip_conntrack_info ctinfo,
@@ -443,6 +494,9 @@ unsigned int nf_nat_packet(struct nf_conn *ct,
 	#if defined(CONFIG_RTL_819X)
 	rtl_nf_conntrack_inso_s	conn_info;
 	#endif
+	#if defined(CONFIG_RTL_BATTLENET_ALG)
+	rtl_set_nat_status(ct, skb, mtype);
+	#endif
 
 	if (mtype == IP_NAT_MANIP_SRC)
 		statusbit = IPS_SRC_NAT;
diff --git a/net/ipv4/netfilter/nf_nat_proto_common.c b/net/ipv4/netfilter/nf_nat_proto_common.c
index b04d454..02e7c27 100644
--- a/net/ipv4/netfilter/nf_nat_proto_common.c
+++ b/net/ipv4/netfilter/nf_nat_proto_common.c
@@ -21,7 +21,7 @@
 #include <net/rtl/rtl_types.h>
 #include <net/rtl/rtl865x_nat.h>
 #endif
-#if defined (CONFIG_RTL_HARDWARE_NAT) && defined (CONFIG_RTL_INBOUND_COLLISION_AVOIDANCE)	
+#if defined (CONFIG_RTL_HARDWARE_NAT) && defined (CONFIG_RTL_INBOUND_COLLISION_AVOIDANCE)
 extern __DRAM_GEN int gHwNatEnabled;
 #endif
 bool nf_nat_proto_in_range(const struct nf_conntrack_tuple *tuple,
@@ -50,7 +50,7 @@ bool nf_nat_proto_unique_tuple(struct nf_conntrack_tuple *tuple,
 	unsigned int range_size, min, i;
 	__be16 *portptr;
 	u_int16_t off;
-#if defined (CONFIG_RTL_HARDWARE_NAT) && defined (CONFIG_RTL_INBOUND_COLLISION_AVOIDANCE)	
+#if defined (CONFIG_RTL_HARDWARE_NAT) && defined (CONFIG_RTL_INBOUND_COLLISION_AVOIDANCE)
 	unsigned int tryCnt=0;
 	rtl865x_napt_entry rtl865xNaptEntry;
 	unsigned int asicNaptHashScore=0;
@@ -97,7 +97,7 @@ bool nf_nat_proto_unique_tuple(struct nf_conntrack_tuple *tuple,
 	else
 		off = *rover;
 
-#if defined (CONFIG_RTL_HARDWARE_NAT) && defined (CONFIG_RTL_INBOUND_COLLISION_AVOIDANCE) 
+#if defined (CONFIG_RTL_HARDWARE_NAT) && defined (CONFIG_RTL_INBOUND_COLLISION_AVOIDANCE)
 if(ct->master || (ct->status & IPS_EXPECTED)){
 	for (i = 0; i < range_size; i++, off++) {
 		*portptr = htons(min + off % range_size);
@@ -108,11 +108,11 @@ if(ct->master || (ct->status & IPS_EXPECTED)){
 		return true;
 	}
 }else
-{	
+{
 	for (i = 0; i < range_size; i++) {
-		if(gHwNatEnabled) 
+		if((gHwNatEnabled) && (maniptype==IP_NAT_MANIP_SRC))
 		{
-			rtl865x_optimizeExtPort(off++, range_size, &newOff);		
+			rtl865x_optimizeExtPort(off++, range_size, &newOff);
 			*portptr = htons(min + newOff % range_size);
 		}
 		else
@@ -120,10 +120,10 @@ if(ct->master || (ct->status & IPS_EXPECTED)){
 			*portptr = htons(min + off % range_size);
 			off++;
 		}
-		
+
 		if (nf_nat_used_tuple(tuple, ct))
 			continue;
-		
+
 		if((gHwNatEnabled) && (maniptype==IP_NAT_MANIP_SRC))
 		{
 			/* outbound flow */
@@ -134,14 +134,14 @@ if(ct->master || (ct->status & IPS_EXPECTED)){
 			rtl865xNaptEntry.intPort = rtl865xNaptEntry.protocol?ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.tcp.port:ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.udp.port;
 			rtl865xNaptEntry.remPort = rtl865xNaptEntry.protocol?ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u.tcp.port:ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u.udp.port;
 			rtl865xNaptEntry.extPort= rtl865xNaptEntry.protocol?tuple->src.u.tcp.port:tuple->src.u.udp.port;
-			
+
 			rtl865x_getAsicNaptHashScore(&rtl865xNaptEntry,&asicNaptHashScore);
-	
+
 			if(asicNaptHashScore==100)
 			{
 				highestScore=asicNaptHashScore;
 				lowestScore=asicNaptHashScore;
-				bestCandidatePort=*portptr; 
+				bestCandidatePort=*portptr;
 			}
 			else
 			{
@@ -152,25 +152,25 @@ if(ct->master || (ct->status & IPS_EXPECTED)){
 					highestScore=asicNaptHashScore;
 					lowestScore=asicNaptHashScore;
 				}
-				
+
 				if(asicNaptHashScore>highestScore)
 				{
 					highestScore=asicNaptHashScore;
-					bestCandidatePort=*portptr; 
+					bestCandidatePort=*portptr;
 				}
 
 				if(asicNaptHashScore<lowestScore)
 				{
 					lowestScore=asicNaptHashScore;
 				}
-				
+
 				if(tryCnt++<=MAX_EXTPORT_TRY_CNT)
 				{
 					continue;
-				}	
+				}
 				else
 				{
-					*portptr=bestCandidatePort; 
+					*portptr=bestCandidatePort;
 				}
 			}
 
@@ -179,15 +179,15 @@ if(ct->master || (ct->status & IPS_EXPECTED)){
 		}
 /*
 			printk("%s:%d:maniptype is %d, %s (%u.%u.%u.%u:%u -> %u.%u.%u.%u:%u -> %u.%u.%u.%u:%u) ,lowestScore is %d,highestScore is %d\n\n\n",
-			__FUNCTION__,__LINE__,maniptype, rtl865xNaptEntry.protocol?"tcp":"udp", 
-			NIPQUAD(rtl865xNaptEntry.intIp), rtl865xNaptEntry.intPort, NIPQUAD(rtl865xNaptEntry.extIp), rtl865xNaptEntry.extPort, NIPQUAD(rtl865xNaptEntry.remIp), rtl865xNaptEntry.remPort,lowestScore, highestScore);	
+			__FUNCTION__,__LINE__,maniptype, rtl865xNaptEntry.protocol?"tcp":"udp",
+			NIPQUAD(rtl865xNaptEntry.intIp), rtl865xNaptEntry.intPort, NIPQUAD(rtl865xNaptEntry.extIp), rtl865xNaptEntry.extPort, NIPQUAD(rtl865xNaptEntry.remIp), rtl865xNaptEntry.remPort,lowestScore, highestScore);
 */
 
 		if (!(range->flags & IP_NAT_RANGE_PROTO_RANDOM))
 			*rover = off;
 		return true;
 	}
-}	
+}
 #else
 	for (i = 0; i < range_size; i++, off++) {
 		*portptr = htons(min + off % range_size);
diff --git a/net/ipv4/raw.c b/net/ipv4/raw.c
index f774651..2b58d39 100644
--- a/net/ipv4/raw.c
+++ b/net/ipv4/raw.c
@@ -107,6 +107,45 @@ void raw_unhash_sk(struct sock *sk)
 }
 EXPORT_SYMBOL_GPL(raw_unhash_sk);
 
+
+#if defined (CONFIG_RTL_SOCK_DEBUG)
+extern int dump_inet_sock(struct inet_sock * inet);
+extern int dump_sock_skb_info(struct sock * sk);
+
+int dumpRawSockInfo(void)
+{
+	unsigned long flags;
+	int hash;
+	struct hlist_head *head;
+	struct sock *sk;
+	struct hlist_node *node;
+
+
+	for(hash=0;hash<RAW_HTABLE_SIZE; hash++)
+	{
+		read_lock(&raw_v4_hashinfo.lock);
+		head = &raw_v4_hashinfo.ht[hash];
+		if (hlist_empty(head))
+			goto out;
+		local_irq_save( flags);
+		for(sk = __sk_head(head);sk!=NULL;sk=sk_next(sk))
+		 {	
+			printk("raw sock,hash:%d,sk is 0x%x,\n",hash,(unsigned int)sk);	
+			dump_inet_sock(inet_sk(sk));
+			dump_sock_skb_info(sk);
+			printk("--------------------------------------------------------------------------------------------\n");	
+			
+		}
+		local_irq_restore( flags);
+	out:
+		read_unlock(&raw_v4_hashinfo.lock);
+
+	}
+	
+
+}
+
+#endif
 static struct sock *__raw_v4_lookup(struct net *net, struct sock *sk,
 		unsigned short num, __be32 raddr, __be32 laddr, int dif)
 {
@@ -114,12 +153,23 @@ static struct sock *__raw_v4_lookup(struct net *net, struct sock *sk,
 
 	sk_for_each_from(sk, node) {
 		struct inet_sock *inet = inet_sk(sk);
-
-		if (net_eq(sock_net(sk), net) && inet->num == num	&&
-		    !(inet->daddr && inet->daddr != raddr) 		&&
-		    !(inet->rcv_saddr && inet->rcv_saddr != laddr)	&&
-		    !(sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif))
-			goto found; /* gotcha */
+		#if defined (CONFIG_RTL_819X)
+		if(num==47)
+		{
+			if (net_eq(sock_net(sk), net) && inet->num == num	&&
+			    !(inet->rcv_saddr && inet->rcv_saddr != laddr)	&&
+			    !(sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif))
+				goto found; /* gotcha */
+		}
+		else
+		#endif
+		{
+			if (net_eq(sock_net(sk), net) && inet->num == num	&&
+			    !(inet->daddr && inet->daddr != raddr) 		&&
+			    !(inet->rcv_saddr && inet->rcv_saddr != laddr)	&&
+			    !(sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif))
+				goto found; /* gotcha */
+		}
 	}
 	sk = NULL;
 found:
diff --git a/net/ipv4/route.c b/net/ipv4/route.c
index f4e13c9..010b076 100644
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@ -1117,8 +1117,8 @@ static int rt_garbage_collect(struct dst_ops *ops)
 		else
 		{
 			rt_cache_clean(ip_rt_max_size);
-		if (atomic_read(&ipv4_dst_ops.entries) < ip_rt_max_size)
-			goto out;
+			if (atomic_read(&ipv4_dst_ops.entries) < ip_rt_max_size)
+				goto out;
 		}
 #endif
 	} while (!in_softirq() && time_before_eq(jiffies, now));
@@ -1196,7 +1196,7 @@ restart:
 				if (net_ratelimit())
 					printk(KERN_WARNING
 					    "Neighbour table failure & not caching routes.\n");
-				rt_drop(rt);
+		rt_drop(rt);
 				return err;
 			}
 		}
diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c
index 83187c0..11d9c56 100644
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@ -487,7 +487,7 @@ void tcp_v4_send_check(struct sock *sk, int len, struct sk_buff *skb)
 					  inet->daddr, 0);
 		skb->csum_start = skb_transport_header(skb) - skb->head;
 		skb->csum_offset = offsetof(struct tcphdr, check);
-	} else {
+	} else {		
 		//Hyking:fixme
 		//it's seem that the skb->csum is wrong
 		//fix it after....
@@ -1525,6 +1525,73 @@ csum_err:
 	goto discard;
 }
 
+#if defined (CONFIG_RTL_SOCK_DEBUG)
+extern int dump_inet_sock(struct inet_sock * inet);
+extern int  dump_inet_timewait_sock(struct inet_timewait_sock * inet_tw);
+extern int dump_sock_skb_info(struct sock * sk);
+int dumpTcpSockInfo(void)
+{
+	unsigned long flags;
+	struct sock *sk;
+	const struct hlist_nulls_node *node;
+	unsigned int hash ;
+	struct udp_hslot *hslot;
+	struct sk_buff *list=NULL;
+	struct inet_listen_hashbucket *ilb;
+	struct inet_ehash_bucket *head=NULL;
+	unsigned int slot;
+	
+	
+	for(hash=0; hash <INET_LHTABLE_SIZE; hash++)
+	{
+	
+		ilb = &tcp_hashinfo.listening_hash[hash];
+		local_irq_save( flags);
+		sk_nulls_for_each_rcu(sk, node, &ilb->head) {
+			printk("tcp listener socket,hash:%d,sk is 0x%x,\n",hash,(unsigned int)sk);	
+			dump_inet_sock(inet_sk(sk));
+			dump_sock_skb_info(sk);
+			printk("--------------------------------------------------------------------------------------------\n");	
+		}
+		
+		local_irq_restore( flags);
+
+	}
+
+	//printk("%s:%d,tcp_hashinfo.ehash_size is %d\n",__FUNCTION__,__LINE__,tcp_hashinfo.ehash_size);
+	for(slot=0; slot <tcp_hashinfo.ehash_size; slot++)
+	{
+	
+		head = &tcp_hashinfo.ehash[slot];
+		
+		local_irq_save( flags);
+		sk_nulls_for_each_rcu(sk, node, &head->chain) {
+			
+			printk("tcp established socket,hash:%d,sk is 0x%x,\n",hash,(unsigned int)sk);	
+			dump_inet_sock(inet_sk(sk));
+			dump_sock_skb_info(sk);
+			printk("--------------------------------------------------------------------------------------------\n");	
+		
+		}
+	
+		sk_nulls_for_each_rcu(sk, node, &head->twchain) {
+			
+			printk("tcp time-wait socket socket,hash:%d,sk is 0x%x,\n",hash,(unsigned int)sk);	
+			dump_inet_timewait_sock(inet_twsk(sk));
+			dump_sock_skb_info(sk);
+			printk("--------------------------------------------------------------------------------------------\n");	
+		
+
+		}
+		local_irq_restore( flags);
+		
+
+	}
+	
+	return 0;
+	
+}
+#endif
 /*
  *	From tcp_input.c
  */
diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c
index 044e142..2dd2bbc 100644
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@ -1162,7 +1162,39 @@ drop:
 	kfree_skb(skb);
 	return -1;
 }
+#if defined (CONFIG_RTL_SOCK_DEBUG)
+extern int dump_inet_sock(struct inet_sock * inet);
+extern int dump_sock_skb_info(struct sock * sk);
+int dumpUdpSockInfo(void)
+{
+	unsigned long flags;
+	struct sock *sk;
+	struct hlist_nulls_node *node;
+	unsigned int hash ;
+	struct udp_hslot *hslot;
+	struct inet_sock *inet;
+	
+	rcu_read_lock();
+	for(hash=0;hash<UDP_HTABLE_SIZE;hash++)
+	{
+		hslot = &udp_table.hash[hash];
+		local_irq_save( flags);
+		sk_nulls_for_each_rcu(sk, node, &hslot->head)
+		{	
+			printk("udp sock,hash:%d,sk is 0x%x,\n",hash,(unsigned int)sk);	
+			dump_inet_sock(inet_sk(sk));
+			dump_sock_skb_info(sk);
+			printk("--------------------------------------------------------------------------------------------\n");		
+		}
+		local_irq_restore( flags);
+	}
+	rcu_read_unlock();
+	
+	return 0;
+	
+}
 
+#endif
 /*
  *	Multicasts and broadcasts go to each listener.
  *
diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c
index c3a5a67..082d60f 100644
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@ -185,8 +185,16 @@ static struct ipv6_devconf ipv6_devconf __read_mostly = {
 #endif
 	.proxy_ndp		= 0,
 	.accept_source_route	= 0,	/* we do not accept RH0 by default. */
+#ifdef CONFIG_IPV6_MROUTE
+	.mc_forwarding		= 1,
+#endif
 	.disable_ipv6		= 0,
-	.accept_dad		= 1,
+#ifdef CONFIG_RTL_IPV6READYLOGO
+	.accept_dad			= 2,
+#else
+	.accept_dad 		= 1,
+#endif
+
 };
 
 static struct ipv6_devconf ipv6_devconf_dflt __read_mostly = {
@@ -219,8 +227,16 @@ static struct ipv6_devconf ipv6_devconf_dflt __read_mostly = {
 #endif
 	.proxy_ndp		= 0,
 	.accept_source_route	= 0,	/* we do not accept RH0 by default. */
+#ifdef CONFIG_IPV6_MROUTE
+	.mc_forwarding		= 1,
+#endif
 	.disable_ipv6		= 0,
-	.accept_dad		= 1,
+#ifdef CONFIG_RTL_IPV6READYLOGO
+	.accept_dad			= 2,
+#else
+	.accept_dad 		= 1,
+#endif
+
 };
 
 /* IPv6 Wildcard Address and Loopback Address defined by RFC2553 */
@@ -2324,7 +2340,7 @@ static void addrconf_dev_config(struct net_device *dev)
 		/* Alas, we support only Ethernet autoconfiguration. */
 		return;
 	}
-
+	
 #if defined(CONFIG_RTL_IPV6READYLOGO)
         if(!strcmp(dev->name,"eth0"))
                 return;
@@ -2855,7 +2871,7 @@ static void addrconf_dad_timer(unsigned long data)
 	}
 	else
 	{
-
+		
 		/* send a neighbour solicitation for our addr */		
 		if(delay_flag)
 		{
@@ -4304,7 +4320,7 @@ static struct addrconf_sysctl_table
 			.procname	=	"mc_forwarding",
 			.data		=	&ipv6_devconf.mc_forwarding,
 			.maxlen		=	sizeof(int),
-			.mode		=	0444,
+			.mode		=	0644,
 			.proc_handler	=	proc_dointvec,
 		},
 #endif
diff --git a/net/ipv6/exthdrs.c b/net/ipv6/exthdrs.c
index 1e19a1c..34a5aa2 100644
--- a/net/ipv6/exthdrs.c
+++ b/net/ipv6/exthdrs.c
@@ -378,7 +378,8 @@ looped_back:
 	}
 
 	switch (hdr->type) {
-#if defined(CONFIG_RTL_IPV6READYLOGO)	
+		/*deprecate RH0 by RFC5095 because of security problem*/
+#if 0//defined(CONFIG_RTL_IPV6READYLOGO)	
 		case IPV6_SRCRT_TYPE_0:
 		//printk("[%s][%d]-[%p][offset=%x]\n", __FUNCTION__, __LINE__, (&hdr->nexthdr), (&hdr->nexthdr) - skb_network_header(skb));
 		if (hdr->hdrlen & 0x01) {
diff --git a/net/netfilter/Kconfig b/net/netfilter/Kconfig
index e3401b8..c227a76 100644
--- a/net/netfilter/Kconfig
+++ b/net/netfilter/Kconfig
@@ -220,6 +220,37 @@ config NF_CONNTRACK_NETBIOS_NS
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+#
+# Desc:add ip sec for alg
+#
+config NF_CONNTRACK_IPSEC
+        tristate "IPSEC protocol support"
+        depends on NETFILTER_ADVANCED
+        help
+          This module adds support for IPSEC connection tracking and NAT.
+          To compile it as a module, choose M here. If unsure, say N.
+
+#
+# Desc:add rtsp for alg
+#
+config NF_CONNTRACK_RTSP
+    tristate "RTSP protocol support"
+    depends on NETFILTER_ADVANCED
+    help
+      This module adds support for RTSP connection tracking and NAT.
+      To compile it as a module, choose M here. If unsure, say N.
+
+
+#
+# Desc:add l2tp for alg
+#
+config NF_CONNTRACK_L2TP
+    tristate "L2TP protocol support"
+    depends on NETFILTER_ADVANCED
+    help
+      This module adds support for L2TP connection tracking and NAT.
+      To compile it as a module, choose M here. If unsure, say N.
+
 config NF_CONNTRACK_PPTP
 	tristate "PPtP protocol support"
 	depends on NETFILTER_ADVANCED
@@ -276,6 +307,16 @@ config NF_CONNTRACK_TFTP
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config RTL_BATTLENET_ALG
+        tristate "BATTLENET alg support"
+        depends on NETFILTER_ADVANCED
+	default n
+        help
+          TFTP connection tracking helper, this is required depending
+          on how restrictive your ruleset is.
+
+          To compile it as a module, choose M here.  If unsure, say N.
+
 config NF_CT_NETLINK
 	tristate 'Connection tracking netlink interface'
 	select NETFILTER_NETLINK
@@ -884,6 +925,26 @@ config NETFILTER_XT_MATCH_STATE
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config NETFILTER_XT_MATCH_LAYER7
+	tristate '"layer7" match support'
+	depends on NETFILTER_XTABLES
+	depends on EXPERIMENTAL && (IP_NF_CONNTRACK || NF_CONNTRACK)
+	depends on NF_CT_ACCT
+	help
+	  Say Y if you want to be able to classify connections (and their
+	  packets) based on regular expression matching of their applications
+	  layer data.   This is one way to classify applications such as
+	  peer-to-peer filesharing systems that do not always use the same
+	  port.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
+config NETFILTER_XT_MATCH_LAYER7_DEBUG
+	bool 'Layer 7 debugging output'
+	depends on NETFILTER_XT_MATCH_LAYER7
+	help
+	  Say Y to get lots of debugging output.
+
 config NETFILTER_XT_MATCH_STATISTIC
 	tristate '"statistic" match support'
 	depends on NETFILTER_ADVANCED
diff --git a/net/netfilter/Makefile b/net/netfilter/Makefile
index 506304b..21c65bb 100644
--- a/net/netfilter/Makefile
+++ b/net/netfilter/Makefile
@@ -33,7 +33,9 @@ obj-$(CONFIG_NF_CONNTRACK_PPTP) += nf_conntrack_pptp.o
 obj-$(CONFIG_NF_CONNTRACK_SANE) += nf_conntrack_sane.o
 obj-$(CONFIG_NF_CONNTRACK_SIP) += nf_conntrack_sip.o
 obj-$(CONFIG_NF_CONNTRACK_TFTP) += nf_conntrack_tftp.o
-
+obj-$(CONFIG_NF_CONNTRACK_L2TP) += nf_conntrack_l2tp.o
+obj-$(CONFIG_NF_CONNTRACK_RTSP) += nf_conntrack_rtsp.o
+obj-$(CONFIG_NF_CONNTRACK_IPSEC) += nf_conntrack_ipsec.o
 # transparent proxy support
 obj-$(CONFIG_NETFILTER_TPROXY) += nf_tproxy_core.o
 
@@ -88,6 +90,7 @@ obj-$(CONFIG_NETFILTER_XT_MATCH_RECENT) += xt_recent.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_SCTP) += xt_sctp.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_SOCKET) += xt_socket.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_STATE) += xt_state.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_LAYER7) += xt_layer7.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_STATISTIC) += xt_statistic.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_STRING) += xt_string.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_TCPMSS) += xt_tcpmss.o
diff --git a/net/netfilter/ipvs/ip_vs_conn.c b/net/netfilter/ipvs/ip_vs_conn.c
index 31a3d8c..cc239e1 100644
--- a/net/netfilter/ipvs/ip_vs_conn.c
+++ b/net/netfilter/ipvs/ip_vs_conn.c
@@ -655,7 +655,7 @@ static void ip_vs_conn_expire(unsigned long data)
 		/* does anybody control me? */
 		if (cp->control)
 			ip_vs_control_del(cp);
-
+		
 		#if defined (CONFIG_RTL_819X)  
 		rtl_ip_vs_conn_expire_hooks2(cp);
 		#endif
diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c
index 5f6c28d..b6e0dd9 100644
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@ -48,6 +48,7 @@
 #if defined(CONFIG_RTL_819X)
 #include <net/rtl/features/rtl_ps_hooks.h>
 #endif
+#include <net/rtl/features/rtl_ps_log.h>
 
 #define NF_CONNTRACK_VERSION	"0.5.0"
 
@@ -205,7 +206,7 @@ destroy_conntrack(struct nf_conntrack *nfct)
 	conn_info.ct = ct;
 
 	rtl_nf_conntrack_destroy_hooks(&conn_info);
-	#endif		
+	#endif
 
 	rcu_read_lock();
 	l4proto = __nf_ct_l4proto_find(nf_ct_l3num(ct), nf_ct_protonum(ct));
@@ -220,6 +221,13 @@ destroy_conntrack(struct nf_conntrack *nfct)
 	 * too. */
 	nf_ct_remove_expectations(ct);
 
+	#if defined(CONFIG_NETFILTER_XT_MATCH_LAYER7) || defined(CONFIG_NETFILTER_XT_MATCH_LAYER7_MODULE)
+	if(ct->layer7.app_proto)
+		kfree(ct->layer7.app_proto);
+	if(ct->layer7.app_data)
+	kfree(ct->layer7.app_data);
+	#endif
+
 	/* We overload first tuple to link into unconfirmed list. */
 	if (!nf_ct_is_confirmed(ct)) {
 		BUG_ON(hlist_nulls_unhashed(&ct->tuplehash[IP_CT_DIR_ORIGINAL].hnnode));
@@ -236,6 +244,40 @@ destroy_conntrack(struct nf_conntrack *nfct)
 	nf_conntrack_free(ct);
 }
 
+#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+static void death_by_timeout_forced(unsigned long ul_conntrack)
+{
+	struct nf_conn *ct = (void *)ul_conntrack;
+	struct net *net = nf_ct_net(ct);
+	struct nf_conn_help *help;
+	struct nf_conntrack_helper *helper;
+
+	help = nfct_help(ct);
+	if (help) {
+		rcu_read_lock();
+		helper = rcu_dereference(help->helper);
+		if (helper && helper->destroy)
+			helper->destroy(ct);
+		rcu_read_unlock();
+	}
+
+	spin_lock_bh(&nf_conntrack_lock);
+	/* Inside lock so preempt is disabled on module removal path.
+	 * Otherwise we can get spurious warnings. */
+	NF_CT_STAT_INC(net, delete_list);
+
+	#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+	clean_from_lists(ct, net);
+	#else
+	clean_from_lists(ct);
+	#endif
+
+
+	spin_unlock_bh(&nf_conntrack_lock);
+	nf_ct_put(ct);
+}
+#endif
+
 static void death_by_timeout(unsigned long ul_conntrack)
 {
 	struct nf_conn *ct = (void *)ul_conntrack;
@@ -265,7 +307,7 @@ static void death_by_timeout(unsigned long ul_conntrack)
 	 * Otherwise we can get spurious warnings. */
 	NF_CT_STAT_INC(net, delete_list);
 	#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
-	clean_from_lists(ct, net);
+	clean_from_lists((void*)ct, (void*)net);
 	#else
 	clean_from_lists(ct);
 	#endif
@@ -425,7 +467,7 @@ __nf_conntrack_confirm(struct sk_buff *skb)
 	conn_info.ct = ct;
 	conn_info.skb = skb;
 	conn_info.ctinfo = ctinfo;
-	rtl_nf_conntrack_confirm_hooks(&conn_info);	        			 
+	rtl_nf_conntrack_confirm_hooks(&conn_info);
 	#endif
 
 	/* Timer relative to confirmation time, not original
@@ -541,6 +583,8 @@ static noinline int early_drop(struct net *net, unsigned int hash)
 }
 #endif
 
+
+
 struct nf_conn *nf_conntrack_alloc(struct net *net,
 				   const struct nf_conntrack_tuple *orig,
 				   const struct nf_conntrack_tuple *repl,
@@ -556,10 +600,22 @@ struct nf_conn *nf_conntrack_alloc(struct net *net,
 
 	/* We don't want any race condition at early drop stage */
 	atomic_inc(&net->ct.count);
+#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+	if(nf_conntrack_max &&
+		((atomic_read(&net->ct.count) > rtl_nf_conntrack_threshold))&&
+		(atomic_read(&net->ct.count) < (nf_conntrack_max-1)))
+	{
+		if(isReservedConntrack(orig,repl))
+		{
+			/*use reserved conntrack,continue to allocate*/
+			goto alloc_reserved_conn;
+		}
+	}
+#endif
 
 #if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
 	if (nf_conntrack_max && unlikely(atomic_read(&net->ct.count) > rtl_nf_conntrack_threshold))
-#else	
+#else
 	if (nf_conntrack_max && unlikely(atomic_read(&net->ct.count) > nf_conntrack_max))
 #endif
 	{
@@ -568,7 +624,7 @@ struct nf_conn *nf_conntrack_alloc(struct net *net,
 		if(!drop_one_conntrack(orig,repl))
 #else
 		unsigned int hash = hash_conntrack(orig);
-		if (!early_drop(net, hash)) 
+		if (!early_drop(net, hash))
 #endif
 		{
 			atomic_dec(&net->ct.count);
@@ -580,13 +636,14 @@ struct nf_conn *nf_conntrack_alloc(struct net *net,
 		}
 	}
 
+alloc_reserved_conn:
 	/*
 	 * Do not use kmem_cache_zalloc(), as this cache uses
 	 * SLAB_DESTROY_BY_RCU.
 	 */
 	ct = kmem_cache_alloc(nf_conntrack_cachep, gfp);
 	if (ct == NULL) {
-		pr_debug("nf_conntrack_alloc: Can't alloc conntrack.\n");
+		LOG_WARN("nf_conntrack_alloc: Can't alloc conntrack.\n");
 		atomic_dec(&net->ct.count);
 		return ERR_PTR(-ENOMEM);
 	}
@@ -628,6 +685,146 @@ EXPORT_SYMBOL_GPL(nf_conntrack_free);
 
 /* Allocate a new conntrack: we return -ENOMEM if classification
    failed due to stress.  Otherwise it really is unclassifiable. */
+#if defined(CONFIG_RTL_BATTLENET_ALG)
+unsigned int wan_ip = 0;
+unsigned int wan_mask = 0;
+
+struct nf_conn *rtl_find_ct_by_tuple_dst(struct nf_conntrack_tuple *tuple, int *flag)
+{
+	int i;
+	extern unsigned int _br0_ip;
+	extern unsigned int _br0_mask;
+	struct nf_conn *ct;
+	struct nf_conntrack_tuple_hash *h;
+	struct hlist_nulls_node *n;
+
+	for(i=0; i< nf_conntrack_htable_size; i++)
+	{
+		hlist_nulls_for_each_entry(h, n, &init_net.ct.hash[i], hnnode)
+		{
+			if((__nf_ct_tuple_dst_equal(tuple, &h->tuple)) &&
+			  ((h->tuple.src.u3.ip & _br0_mask) != (_br0_ip & _br0_mask))&&
+			   (h->tuple.src.u.all == BATTLENET_PORT))
+			  {
+				//memcpy(&reply_tuple_temp, h, sizeof(struct nf_conntrack_tuple_hash));
+				ct = nf_ct_tuplehash_to_ctrack(h);
+
+				if(((ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip & _br0_mask) == (_br0_ip & _br0_mask)) &&
+				    ((ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip & _br0_mask) != (_br0_ip & _br0_mask))&&
+				     (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip != tuple->src.u3.ip)){
+						*flag = 1;
+						return ct;
+					}
+			  }
+		}
+	}
+
+	return NULL;
+
+}
+
+struct nf_conn *rtl_find_ct_by_tuple_src(struct nf_conntrack_tuple *tuple, int *flag)
+{
+	int i;
+	extern unsigned int _br0_ip;
+	extern unsigned int _br0_mask;
+	struct nf_conn *ct;
+	struct nf_conntrack_tuple_hash *h;
+	struct hlist_nulls_node *n;
+
+	for(i=0; i< nf_conntrack_htable_size; i++)
+	{
+		hlist_nulls_for_each_entry(h, n, &init_net.ct.hash[i], hnnode)
+		{
+			if((__nf_ct_tuple_src_equal(tuple, &h->tuple)) &&
+			   (h->tuple.src.u3.ip  != wan_ip))
+			  {
+				ct = nf_ct_tuplehash_to_ctrack(h);
+
+				if(((ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3.ip & _br0_mask) != (_br0_ip & _br0_mask)) &&
+				     (ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u.all == BATTLENET_PORT)&&
+				     (ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip == wan_ip)){
+						*flag = 1;
+						return ct;
+					}
+			  }
+		}
+	}
+
+	return NULL;
+
+}
+
+static void rtl_reconfig_reply_tupe(struct sk_buff *skb, const struct nf_conntrack_tuple *tuple,
+	struct nf_conntrack_tuple *repl_tuple)
+{
+
+	extern unsigned int _br0_ip;
+	extern unsigned int _br0_mask;
+
+	int flag_reply = 0;
+	int flag_ori = 0;
+	struct nf_conn *ct_temp_reply = NULL;
+	struct nf_conn *ct_temp_ori = NULL;
+	struct net_device *wan_device = NULL;
+
+	//struct nf_conntrack_tuple_hash reply_tuple_temp;
+	//memset(&reply_tuple_temp, 0, sizeof(struct nf_conntrack_tuple_hash));
+
+	wan_device = rtl865x_getBattleNetWanDev();
+	rtl865x_getBattleNetDevIpAndNetmask(wan_device, &wan_ip, &wan_mask);
+	/*
+	1. protocol is udp;
+	2. original src port is 6112;
+	3. original src ip is lan ip;
+	4. original dst ip is wan ip(ppp dev ip);
+	e.g:
+	original:192.168.1.100:6112->192.168.123.2:6112
+	reply_1: 192.168.123.2:6112->192.168.1.100:6112
+	reply_2: 192.168.1.101:6112->192.168.123.2:6112
+	*/
+	//printk("_br0_ip is %2x, _br0_mask is %2x\n", _br0_ip, _br0_mask);
+	if((ip_hdr(skb)->protocol == IPPROTO_UDP) &&
+		(ntohs(tuple->src.u.all) == BATTLENET_PORT) &&
+		((tuple->src.u3.ip & _br0_mask) == (_br0_ip & _br0_mask)) &&
+		((wan_ip!=0)&&(tuple->dst.u3.ip == wan_ip)))
+	{
+		spin_lock_bh(&nf_conntrack_lock);
+		ct_temp_reply = rtl_find_ct_by_tuple_dst(tuple, &flag_reply);
+
+		if((flag_reply == 1) && (ct_temp_reply != NULL))
+		{
+			/*printk("%s[%d],  sip is %2x, sport is %d; dip is %2x, dport is %d\n", __FUNCTION__, __LINE__,
+				h->tuple.src.u3.ip, h->tuple.src.u.all,
+				h->tuple.dst.u3.ip, h->tuple.dst.u.all);*/
+
+			/*printk("%s[%d],  sip is %2x, sport is %d; dip is %2x, dport is %d\n", __FUNCTION__, __LINE__,
+					ct_temp_reply->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip,
+					ct_temp_reply->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.all,
+					ct_temp_reply->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip,
+					ct_temp_reply->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u.all);*/
+
+			ct_temp_ori = rtl_find_ct_by_tuple_src(tuple, &flag_ori);
+
+			if((flag_ori == 1) && (ct_temp_ori != NULL))
+			{
+				/*change ct's reply src ip and port as the original tuple found*/
+				repl_tuple->src.u3.ip = ct_temp_reply->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;
+				repl_tuple->src.u.all  = ct_temp_reply->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.all;
+
+				/*change ct's reply dst ip and port as original dst ip and port*/
+				repl_tuple->dst.u3.ip = tuple->dst.u3.ip;
+				repl_tuple->dst.u.all  = ct_temp_ori->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u.all;
+			}
+		}
+
+		spin_unlock_bh(&nf_conntrack_lock);
+
+	}
+
+}
+#endif
+
 static struct nf_conntrack_tuple_hash *
 init_conntrack(struct net *net,
 	       const struct nf_conntrack_tuple *tuple,
@@ -649,6 +846,10 @@ init_conntrack(struct net *net,
 		return NULL;
 	}
 
+#if defined(CONFIG_RTL_BATTLENET_ALG)
+	rtl_reconfig_reply_tupe(skb, tuple, &repl_tuple);
+#endif
+
 	ct = nf_conntrack_alloc(net, tuple, &repl_tuple, GFP_ATOMIC);
 	if (IS_ERR(ct)) {
 		pr_debug("Can't allocate conntrack.\n");
@@ -697,6 +898,10 @@ init_conntrack(struct net *net,
 	conn_info.l3proto = l3proto;
 	conn_info.l4proto = l4proto;
 	rtl_nf_init_conntrack_hooks(&conn_info);
+	#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+	ct->drop_flag = -1;
+	ct->removed   = 0;
+	#endif
 	#endif
 
 	/* Overload tuple linked list to put us in unconfirmed list. */
@@ -1094,7 +1299,13 @@ void nf_ct_iterate_cleanup(struct net *net,
 	while ((ct = get_next_corpse(net, iter, data, &bucket)) != NULL) {
 		/* Time to push up daises... */
 		if (del_timer(&ct->timeout))
+		{
+			#if defined (CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+			death_by_timeout_forced((unsigned long)ct);
+			#else
 			death_by_timeout((unsigned long)ct);
+			#endif
+		}
 		/* ... else the timer will get him soon. */
 
 		nf_ct_put(ct);
@@ -1382,6 +1593,95 @@ err_stat:
 	return ret;
 }
 
+#ifdef RTL_NF_ALG_CTL
+
+struct alg_entry alg_list[alg_type_end] =
+{
+    ALG_CTL_DEF(ftp,  1),
+    ALG_CTL_DEF(tftp, 1),
+    ALG_CTL_DEF(rtsp, 1),
+    ALG_CTL_DEF(pptp, 1),
+    ALG_CTL_DEF(l2tp, 1),
+    ALG_CTL_DEF(ipsec,1),
+    ALG_CTL_DEF(sip,  1),
+    ALG_CTL_DEF(h323, 1),
+};
+
+int alg_enable(int type)
+{
+    return alg_list[type].enable;
+}
+EXPORT_SYMBOL_GPL(alg_enable);
+
+static struct proc_dir_entry *proc_alg = NULL;
+
+static int proc_alg_debug_read(char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+    char *out = page;
+	int len = 0;
+    int i = 0;
+
+    out += sprintf(out, "\n===================================================\n");
+    for (i = 0; i < alg_type_end; i++)
+    {
+        out += sprintf(out, "| %s=%d\n", alg_list[i].name, alg_list[i].enable);
+    }
+    out += sprintf(out, "---------------------------------------------------\n");
+
+	len = out - page;
+	len -= off;
+	if (len < count) {
+		*eof = 1;
+		if (len <= 0)
+            return 0;
+	} else
+		len = count;
+
+	*start = page + off;
+	return len;
+}
+
+static int proc_alg_debug_write( struct file *filp, const char __user *buf,unsigned long len, void *data )
+{
+	int ret;
+	char str_buf[256];
+	char action[20] = {0};
+	int val = 0;
+	int i = 0;
+
+	if(len > 255)
+	{
+		printk("Usage: echo ftp 1 > /proc/alg \n");
+		return len;
+	}
+
+	copy_from_user(str_buf,buf,len);
+	str_buf[len] = '\0';
+
+	ret = sscanf(str_buf, "%s %d", action, (int*)&val);
+	if(ret != 2 || val < 0 )
+	{
+		printk("Error. Sample: echo ftp 1 > /proc/alg \n");
+		return len;
+	}
+
+	for (i = 0; i < alg_type_end; i++)
+	{
+	    if (0 == strcmp(action, alg_list[i].name))
+	    {
+	        alg_list[i].enable = val;
+	        return len;
+	    }
+	}
+
+	printk("Error: Unkown command.\n");
+
+	return len;
+}
+#endif
+
+
 int nf_conntrack_init(struct net *net)
 {
 	int ret;
@@ -1400,6 +1700,14 @@ int nf_conntrack_init(struct net *net)
 		rcu_assign_pointer(ip_ct_attach, nf_conntrack_attach);
 		rcu_assign_pointer(nf_ct_destroy, destroy_conntrack);
 	}
+
+#ifdef RTL_NF_ALG_CTL
+	proc_alg = create_proc_entry("alg", 0, NULL);
+	if (proc_alg) {
+		proc_alg->read_proc = proc_alg_debug_read;
+		proc_alg->write_proc = proc_alg_debug_write;
+	}
+#endif
 	return 0;
 
 out_net:
diff --git a/net/netfilter/nf_conntrack_expect.c b/net/netfilter/nf_conntrack_expect.c
index afde8f9..bb5ca74 100644
--- a/net/netfilter/nf_conntrack_expect.c
+++ b/net/netfilter/nf_conntrack_expect.c
@@ -102,6 +102,39 @@ __nf_ct_expect_find(struct net *net, const struct nf_conntrack_tuple *tuple)
 }
 EXPORT_SYMBOL_GPL(__nf_ct_expect_find);
 
+#if defined(CONFIG_IP_NF_TARGET_CONENAT)
+static inline int
+exp_src_cmp(const struct nf_conntrack_expect * exp,
+	    const struct nf_conntrack_tuple * tp)
+{
+	return	exp->saved_ip == tp->src.u3.ip &&
+			exp->saved_proto.udp.port == tp->src.u.udp.port &&
+			exp->tuple.dst.protonum == tp->dst.protonum;
+}
+
+struct nf_conntrack_expect *
+__nf_ct_expect_find_bysave(struct net *net, const struct nf_conntrack_tuple *tupleMake, const struct nf_conntrack_tuple *tuple)
+{
+	struct nf_conntrack_expect *i;
+	struct hlist_node *n;
+	unsigned int h;
+
+	if (!net->ct.expect_count)
+		return NULL;
+
+	h = nf_ct_expect_dst_hash(tupleMake);
+
+	hlist_for_each_entry(i, n, &net->ct.expect_hash[h], hnode) {
+
+		if (exp_src_cmp(i, tuple)){
+				return i;
+			}
+	}
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(__nf_ct_expect_find_bysave);
+#endif
+
 /* Just find a expectation corresponding to a tuple. */
 struct nf_conntrack_expect *
 nf_ct_expect_find_get(struct net *net, const struct nf_conntrack_tuple *tuple)
@@ -412,7 +445,7 @@ out:
 	return ret;
 }
 
-int nf_ct_expect_related_report(struct nf_conntrack_expect *expect, 
+int nf_ct_expect_related_report(struct nf_conntrack_expect *expect,
 				u32 pid, int report)
 {
 	int ret;
diff --git a/net/netfilter/nf_conntrack_ftp.c b/net/netfilter/nf_conntrack_ftp.c
index 00fecc3..6e2dd9d 100644
--- a/net/netfilter/nf_conntrack_ftp.c
+++ b/net/netfilter/nf_conntrack_ftp.c
@@ -367,6 +367,10 @@ static int help(struct sk_buff *skb,
 	int found = 0, ends_in_nl;
 	typeof(nf_nat_ftp_hook) nf_nat_ftp;
 
+	#ifdef RTL_NF_ALG_CTL
+	ALG_CHECK_ONOFF(alg_type_ftp);
+	#endif
+
 	/* Until there's been traffic both ways, don't look in packets. */
 	if (ctinfo != IP_CT_ESTABLISHED
 	    && ctinfo != IP_CT_ESTABLISHED+IP_CT_IS_REPLY) {
diff --git a/net/netfilter/nf_conntrack_h323_main.c b/net/netfilter/nf_conntrack_h323_main.c
index 6636949..d0cc635 100644
--- a/net/netfilter/nf_conntrack_h323_main.c
+++ b/net/netfilter/nf_conntrack_h323_main.c
@@ -569,6 +569,10 @@ static int h245_help(struct sk_buff *skb, unsigned int protoff,
 	int dataoff;
 	int ret;
 
+	#ifdef RTL_NF_ALG_CTL
+	ALG_CHECK_ONOFF(alg_type_h323);
+	#endif
+
 	/* Until there's been traffic both ways, don't look in packets. */
 	if (ctinfo != IP_CT_ESTABLISHED &&
 	    ctinfo != IP_CT_ESTABLISHED + IP_CT_IS_REPLY) {
@@ -1115,6 +1119,10 @@ static int q931_help(struct sk_buff *skb, unsigned int protoff,
 	int dataoff;
 	int ret;
 
+	#ifdef RTL_NF_ALG_CTL
+	ALG_CHECK_ONOFF(alg_type_h323);
+	#endif
+
 	/* Until there's been traffic both ways, don't look in packets. */
 	if (ctinfo != IP_CT_ESTABLISHED &&
 	    ctinfo != IP_CT_ESTABLISHED + IP_CT_IS_REPLY) {
@@ -1695,6 +1703,9 @@ static int ras_help(struct sk_buff *skb, unsigned int protoff,
 	int datalen = 0;
 	int ret;
 
+	#ifdef RTL_NF_ALG_CTL
+	ALG_CHECK_ONOFF(alg_type_h323);
+	#endif
 	pr_debug("nf_ct_ras: skblen = %u\n", skb->len);
 
 	spin_lock_bh(&nf_h323_lock);
diff --git a/net/netfilter/nf_conntrack_pptp.c b/net/netfilter/nf_conntrack_pptp.c
index 3807ac7..c7020f4 100644
--- a/net/netfilter/nf_conntrack_pptp.c
+++ b/net/netfilter/nf_conntrack_pptp.c
@@ -516,6 +516,10 @@ conntrack_pptp_help(struct sk_buff *skb, unsigned int protoff,
 	int ret;
 	u_int16_t msg;
 
+	#ifdef RTL_NF_ALG_CTL
+	ALG_CHECK_ONOFF(alg_type_pptp);
+	#endif
+
 	/* don't do any tracking before tcp handshake complete */
 	if (ctinfo != IP_CT_ESTABLISHED &&
 	    ctinfo != IP_CT_ESTABLISHED + IP_CT_IS_REPLY)
diff --git a/net/netfilter/nf_conntrack_proto.c b/net/netfilter/nf_conntrack_proto.c
index 383e90a..7f26cf2 100644
--- a/net/netfilter/nf_conntrack_proto.c
+++ b/net/netfilter/nf_conntrack_proto.c
@@ -32,7 +32,7 @@
 #if defined(FAST_PATH_SPI_ENABLED)
 	struct nf_conntrack_l4proto **nf_ct_protos[PF_MAX]  __read_mostly;
 #else
-static struct nf_conntrack_l4proto **nf_ct_protos[PF_MAX] __read_mostly;
+	static struct nf_conntrack_l4proto **nf_ct_protos[PF_MAX] __read_mostly;
 #endif
 
 struct nf_conntrack_l3proto *nf_ct_l3protos[AF_MAX] __read_mostly;
diff --git a/net/netfilter/nf_conntrack_proto_tcp.c b/net/netfilter/nf_conntrack_proto_tcp.c
index 6667b4a..bcd43b6 100644
--- a/net/netfilter/nf_conntrack_proto_tcp.c
+++ b/net/netfilter/nf_conntrack_proto_tcp.c
@@ -33,6 +33,10 @@
 #include <net/rtl/features/rtl_ps_hooks.h>
 #endif
 
+#if defined(FAST_PATH_SPI_ENABLED)
+extern int fast_spi;
+#endif
+
 /* Protects ct->proto.tcp */
 static DEFINE_RWLOCK(tcp_lock);
 
@@ -494,7 +498,7 @@ static void tcp_sack(const struct sk_buff *skb, unsigned int dataoff,
 }
 
 #if !defined(FAST_PATH_SPI_ENABLED)
-static 
+static
 #endif
 	bool tcp_in_window(const struct nf_conn *ct,
 			  struct ip_ct_tcp *state,
@@ -990,7 +994,11 @@ static int tcp_packet(struct nf_conn *ct,
 	}
 
 #if defined(FAST_PATH_SPI_ENABLED) || !(defined(CONFIG_RTL_IPTABLES_FAST_PATH) ||defined(CONFIG_RTL_HARDWARE_NAT))
-	if (!tcp_in_window(ct, &ct->proto.tcp, dir, index,
+	if (
+#if defined(FAST_PATH_SPI_ENABLED)
+(fast_spi == 1) &&
+#endif
+		!tcp_in_window(ct, &ct->proto.tcp, dir, index,
 			   skb, dataoff, th, pf)) {
 		write_unlock_bh(&tcp_lock);
 		return -NF_ACCEPT;
diff --git a/net/netfilter/nf_conntrack_sip.c b/net/netfilter/nf_conntrack_sip.c
index 4b57216..3724b4a 100644
--- a/net/netfilter/nf_conntrack_sip.c
+++ b/net/netfilter/nf_conntrack_sip.c
@@ -1268,6 +1268,10 @@ static int sip_help(struct sk_buff *skb,
 	int ret;
 	typeof(nf_nat_sip_hook) nf_nat_sip;
 
+	#ifdef RTL_NF_ALG_CTL
+	ALG_CHECK_ONOFF(alg_type_sip);
+	#endif
+
 	/* No Data ? */
 	dataoff = protoff + sizeof(struct udphdr);
 	if (dataoff >= skb->len)
diff --git a/net/netfilter/nf_conntrack_standalone.c b/net/netfilter/nf_conntrack_standalone.c
index 81b9c2f..5f96573 100644
--- a/net/netfilter/nf_conntrack_standalone.c
+++ b/net/netfilter/nf_conntrack_standalone.c
@@ -183,6 +183,13 @@ static int ct_seq_show(struct seq_file *s, void *v)
 		goto release;
 #endif
 
+
+#if defined(CONFIG_NETFILTER_XT_MATCH_LAYER7) || defined(CONFIG_NETFILTER_XT_MATCH_LAYER7_MODULE)
+	if(ct->layer7.app_proto &&
+           seq_printf(s, "l7proto=%s ", ct->layer7.app_proto))
+		return -ENOSPC;
+#endif
+
 	if (seq_printf(s, "use=%u\n", atomic_read(&ct->ct_general.use)))
 		goto release;
 
diff --git a/net/netfilter/nf_conntrack_tftp.c b/net/netfilter/nf_conntrack_tftp.c
index 46e646b..9efad09 100644
--- a/net/netfilter/nf_conntrack_tftp.c
+++ b/net/netfilter/nf_conntrack_tftp.c
@@ -47,6 +47,10 @@ static int tftp_help(struct sk_buff *skb,
 	unsigned int ret = NF_ACCEPT;
 	typeof(nf_nat_tftp_hook) nf_nat_tftp;
 
+	#ifdef RTL_NF_ALG_CTL
+	ALG_CHECK_ONOFF(alg_type_tftp);
+	#endif
+
 	tfh = skb_header_pointer(skb, protoff + sizeof(struct udphdr),
 				 sizeof(_tftph), &_tftph);
 	if (tfh == NULL)
diff --git a/net/netfilter/xt_mac.c b/net/netfilter/xt_mac.c
index 6e85a2a..c72b548 100644
--- a/net/netfilter/xt_mac.c
+++ b/net/netfilter/xt_mac.c
@@ -61,19 +61,19 @@ static int compare_with_header_cache_dest_mac(const struct sk_buff *skb, char *m
 
 static bool mac_mt(const struct sk_buff *skb, const struct xt_match_param *par)
 {
-    const struct xt_mac_info *info = par->matchinfo;
+	const struct xt_mac_info *info = par->matchinfo;   
 
 	if (info->flags & MAC_SRC) {
-    /* Is mac pointer valid? */
+	     /* Is mac pointer valid? */
 	    if ((skb_mac_header(skb) >= skb->head
 		    && (skb_mac_header(skb) + ETH_HLEN) <= skb->data
-	   /* If so, compare... */
+		    /* If so, compare... */
 		    && ((!compare_ether_addr(eth_hdr(skb)->h_source, info->srcaddr.macaddr))
 			^ !!(info->flags & MAC_SRC_INV)))==0)
 	    	{
 			return 0;
 	    	}
-}
+	}
 
 	if (info->flags & MAC_DST) {
 	     /* Is mac pointer valid? */
diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c
index 39fad9e..f25d103 100644
--- a/net/netlink/af_netlink.c
+++ b/net/netlink/af_netlink.c
@@ -1497,11 +1497,11 @@ int rtk_nlrecvmsg(struct sk_buff *skb,int _len, void *_recv_data)
 	int pid;
 //	struct sk_buff *skb;
   	struct nlmsghdr *nlh;
-
+	
 	pid=0;
 //  	printk("net_link: data is ready to read.\n");
   	//skb = skb_get(_skb);
-
+	
 	if (skb->len >= NLMSG_SPACE(0)) {
     		nlh = nlmsg_hdr(skb);
 		memcpy(_recv_data,NLMSG_DATA(nlh),_len);
diff --git a/net/rtl/fastpath/98/fast_l2tp_core.S b/net/rtl/fastpath/98/fast_l2tp_core.S
index 5987f0b..5348d62 100644
--- a/net/rtl/fastpath/98/fast_l2tp_core.S
+++ b/net/rtl/fastpath/98/fast_l2tp_core.S
@@ -87,48 +87,54 @@ l2tpInfo:
 	.type	is_l2tp_device, @function
 is_l2tp_device:
 	.set	nomips16
-	.frame	$sp,0,$31		# vars= 0, regs= 0/0, args= 0, gp= 0
-	.mask	0x00000000,0
+	.frame	$sp,24,$31		# vars= 0, regs= 2/0, args= 16, gp= 0
+	.mask	0x80010000,-4
 	.fmask	0x00000000,0
+	addiu	$sp,$sp,-24
 	lui	$2,%hi(l2tpInfo+4)
+	sw	$16,16($sp)
+	move	$16,$4
+	sw	$31,20($sp)
 	lw	$2,%lo(l2tpInfo+4)($2)
 	.set	noreorder
 	.set	nomacro
 	beq	$2,$0,$L2
-	move	$5,$2
+	move	$4,$2
 	.set	macro
 	.set	reorder
 
-	move	$3,$4
+	jal	rtl_get_ppp_dev_name
 #APP
 	.set	noreorder
 	.set	noat
-	lbu	$2,($5)
-1:	lbu	$1,($3)
-	addiu	$5,1
-	bne	$1,$2,2f
-	addiu	$3,1
-	bnez	$2,1b
-	lbu	$2,($5)
-	move	$2,$1
-2:	subu	$2,$1
+	lbu	$3,($2)
+1:	lbu	$1,($16)
+	addiu	$2,1
+	bne	$1,$3,2f
+	addiu	$16,1
+	bnez	$3,1b
+	lbu	$3,($2)
+	move	$3,$1
+2:	subu	$3,$1
 3:	.set	at
 	.set	reorder
 #NO_APP
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L1
-	li	$3,1			# 0x1
+	beq	$3,$0,$L1
+	li	$2,1			# 0x1
 	.set	macro
 	.set	reorder
 
 $L2:
-	move	$3,$0
+	move	$2,$0
 $L1:
+	lw	$31,20($sp)
+	lw	$16,16($sp)
 	.set	noreorder
 	.set	nomacro
 	j	$31
-	move	$2,$3
+	addiu	$sp,$sp,24
 	.set	macro
 	.set	reorder
 
@@ -149,13 +155,11 @@ set_l2tp_device:
 	addiu	$sp,$sp,-24
 	lui	$2,%hi(fast_l2tp_fw)
 	sw	$31,16($sp)
-	move	$5,$4
 	lw	$2,%lo(fast_l2tp_fw)($2)
-	lui	$4,%hi(init_net)
 	beq	$2,$0,$L4
-	addiu	$4,$4,%lo(init_net)
+	nop
 
-	jal	__dev_get_by_name
+	jal	rtl_get_dev_by_name
 	nop
 
 	lui	$3,%hi(l2tpInfo)
@@ -176,45 +180,53 @@ $L4:
 	.type	event_ppp_dev_down, @function
 event_ppp_dev_down:
 	.set	nomips16
-	.frame	$sp,24,$31		# vars= 0, regs= 1/0, args= 16, gp= 0
-	.mask	0x80000000,-8
+	.frame	$sp,32,$31		# vars= 0, regs= 3/0, args= 16, gp= 0
+	.mask	0x80030000,-8
 	.fmask	0x00000000,0
+	addiu	$sp,$sp,-32
 	lui	$2,%hi(l2tpInfo)
-	addiu	$sp,$sp,-24
-	sw	$31,16($sp)
-	addiu	$5,$2,%lo(l2tpInfo)
-	lhu	$2,38($5)
+	sw	$17,20($sp)
+	addiu	$17,$2,%lo(l2tpInfo)
+	lhu	$2,38($17)
+	sw	$16,16($sp)
+	move	$16,$4
+	.set	noreorder
+	.set	nomacro
 	beq	$2,$0,$L6
-	lw	$2,4($5)
+	sw	$31,24($sp)
+	.set	macro
+	.set	reorder
+
+	lw	$2,4($17)
 	.set	noreorder
 	.set	nomacro
 	beq	$2,$0,$L6
-	move	$6,$2
+	move	$4,$2
 	.set	macro
 	.set	reorder
 
-	move	$3,$4
+	jal	rtl_get_ppp_dev_name
 #APP
 	.set	noreorder
 	.set	noat
-	lbu	$2,($6)
-1:	lbu	$1,($3)
-	addiu	$6,1
-	bne	$1,$2,2f
-	addiu	$3,1
-	bnez	$2,1b
-	lbu	$2,($6)
-	move	$2,$1
-2:	subu	$2,$1
+	lbu	$3,($2)
+1:	lbu	$1,($16)
+	addiu	$2,1
+	bne	$1,$3,2f
+	addiu	$16,1
+	bnez	$3,1b
+	lbu	$3,($2)
+	move	$3,$1
+2:	subu	$3,$1
 3:	.set	at
 	.set	reorder
 #NO_APP
-	li	$6,40			# 0x28
-	move	$4,$5
+	move	$5,$0
+	move	$4,$17
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L6
-	move	$5,$0
+	bne	$3,$0,$L6
+	li	$6,40			# 0x28
 	.set	macro
 	.set	reorder
 
@@ -222,11 +234,13 @@ event_ppp_dev_down:
 	lui	$2,%hi(state)
 	sw	$0,%lo(state)($2)
 $L6:
-	lw	$31,16($sp)
+	lw	$31,24($sp)
+	lw	$17,20($sp)
+	lw	$16,16($sp)
 	.set	noreorder
 	.set	nomacro
 	j	$31
-	addiu	$sp,$sp,24
+	addiu	$sp,$sp,32
 	.set	macro
 	.set	reorder
 
@@ -245,39 +259,46 @@ $LC1:
 	.type	l2tp_tx_id, @function
 l2tp_tx_id:
 	.set	nomips16
-	.frame	$sp,40,$31		# vars= 0, regs= 6/0, args= 16, gp= 0
-	.mask	0x801f0000,-4
+	.frame	$sp,48,$31		# vars= 0, regs= 7/0, args= 16, gp= 0
+	.mask	0x803f0000,-8
 	.fmask	0x00000000,0
 	.set	noreorder
 	.set	nomacro
 	
-	addiu	$sp,$sp,-40
-	sw	$19,28($sp)
-	move	$19,$4
-	sw	$31,36($sp)
+	addiu	$sp,$sp,-48
 	sw	$20,32($sp)
+	move	$20,$4
+	sw	$31,40($sp)
+	sw	$19,28($sp)
 	sw	$18,24($sp)
+	sw	$21,36($sp)
 	sw	$17,20($sp)
+	jal	rtl_get_skb_data
 	sw	$16,16($sp)
-	lw	$18,156($4)
-	lbu	$2,0($18)
+
+	move	$4,$20
+	jal	rtl_ip_hdr
+	move	$18,$2
+
+	move	$19,$2
+	lbu	$2,0($2)
 	andi	$2,$2,0xf
 	sll	$2,$2,2
-	addu	$4,$18,$2
+	addu	$4,$19,$2
 	li	$2,1701			# 0x6a5
 	lhu	$6,0($4)
 	andi	$3,$6,0xffff
-	bne	$3,$2,$L28
+	bne	$3,$2,$L26
 	addiu	$5,$4,8
 
 	lhu	$2,2($4)
-	bne	$2,$3,$L28
+	bne	$2,$3,$L26
 	li	$2,1701			# 0x6a5
 
 	lhu	$3,8($4)
 	sll	$2,$3,16
 	sra	$2,$2,16
-	bgez	$2,$L13
+	bgez	$2,$L11
 	addiu	$2,$4,12
 
 	andi	$3,$3,0x4000
@@ -285,14 +306,14 @@ l2tp_tx_id:
 	movn	$17,$2,$3		#conditional move  
 	li	$2,4			# 0x4
 	lhu	$16,14($17)
-	bne	$16,$2,$L29
+	bne	$16,$2,$L27
 	li	$2,11			# 0xb
 
 	lui	$2,%hi(l2tpInfo)
 	addiu	$4,$2,%lo(l2tpInfo)
 	lhu	$3,20($4)
 	lhu	$2,0($17)
-	bne	$3,$2,$L29
+	bne	$3,$2,$L27
 	li	$2,11			# 0xb
 
 	move	$5,$0
@@ -307,60 +328,62 @@ l2tp_tx_id:
 	lui	$2,%hi(state)
 	sw	$0,%lo(state)($2)
 	li	$2,11			# 0xb
-$L29:
-	bne	$16,$2,$L30
+$L27:
+	bne	$16,$2,$L28
 	li	$2,12			# 0xc
 
-	lui	$20,%hi(state)
-	lw	$2,%lo(state)($20)
-	bne	$2,$0,$L30
+	lui	$21,%hi(state)
+	lw	$2,%lo(state)($21)
+	bne	$2,$0,$L28
 	li	$2,12			# 0xc
 
+	jal	rtl_get_skb_dev_name
+	move	$4,$20
+
 	lui	$5,%hi($LC1)
-	li	$6,4			# 0x4
-	lw	$4,24($19)
-	jal	memcmp
+	move	$4,$2
 	addiu	$5,$5,%lo($LC1)
+	jal	memcmp
+	li	$6,4			# 0x4
 
-	bne	$2,$0,$L30
+	bne	$2,$0,$L28
 	li	$2,12			# 0xc
 
-	lw	$3,24($19)
-	lui	$2,%hi(l2tpInfo)
+	jal	rtl_get_skb_dev
+	move	$4,$20
+
 	lui	$4,%hi(l2tpInfo+24)
-	li	$6,6			# 0x6
-	sw	$3,%lo(l2tpInfo)($2)
+	lui	$3,%hi(l2tpInfo)
 	addiu	$4,$4,%lo(l2tpInfo+24)
-	lw	$5,176($19)
+	addiu	$5,$18,-8
+	li	$6,6			# 0x6
 	jal	memcpy
-	addiu	$5,$5,-8
+	sw	$2,%lo(l2tpInfo)($3)
 
 	lui	$4,%hi(l2tpInfo+30)
-	lw	$5,176($19)
 	addiu	$4,$4,%lo(l2tpInfo+30)
-	li	$6,6			# 0x6
+	addiu	$5,$18,-14
 	jal	memcpy
-	addiu	$5,$5,-14
+	li	$6,6			# 0x6
 
 	lui	$4,%hi(l2tpInfo+36)
-	lw	$5,176($19)
 	addiu	$4,$4,%lo(l2tpInfo+36)
-	li	$6,2			# 0x2
+	addiu	$5,$18,-2
 	jal	memcpy
-	addiu	$5,$5,-2
+	li	$6,2			# 0x2
 
 	li	$2,1			# 0x1
-	sw	$2,%lo(state)($20)
+	sw	$2,%lo(state)($21)
 	li	$2,12			# 0xc
-$L30:
+$L28:
 	bne	$16,$2,$L10
 	nop
 
 	lhu	$2,2($17)
 	beq	$2,$0,$L10
-	lui	$19,%hi(state)
+	lui	$18,%hi(state)
 
-	lw	$2,%lo(state)($19)
+	lw	$2,%lo(state)($18)
 	sltu	$2,$2,2
 	beq	$2,$0,$L10
 	lui	$16,%hi(l2tpInfo)
@@ -370,9 +393,9 @@ $L30:
 	sh	$2,20($16)
 	lhu	$2,2($17)
 	sh	$2,22($16)
-	lw	$2,12($18)
+	lw	$2,12($19)
 	sw	$2,16($16)
-	lw	$2,16($18)
+	lw	$2,16($19)
 	move	$4,$2
 	jal	filter_addconnect
 	sw	$2,12($16)
@@ -386,12 +409,12 @@ $L30:
 
 	li	$2,2			# 0x2
 	j	$L10
-	sw	$2,%lo(state)($19)
+	sw	$2,%lo(state)($18)
 
-$L13:
+$L11:
 	andi	$3,$6,0xffff
 	li	$2,1701			# 0x6a5
-$L28:
+$L26:
 	bne	$3,$2,$L10
 	nop
 
@@ -430,14 +453,15 @@ $L28:
 	lui	$2,%hi(state)
 	sw	$0,%lo(state)($2)
 $L10:
-	lw	$31,36($sp)
+	lw	$31,40($sp)
+	lw	$21,36($sp)
 	lw	$20,32($sp)
 	lw	$19,28($sp)
 	lw	$18,24($sp)
 	lw	$17,20($sp)
 	lw	$16,16($sp)
 	j	$31
-	addiu	$sp,$sp,40
+	addiu	$sp,$sp,48
 
 	.set	macro
 	.set	reorder
@@ -449,146 +473,164 @@ $L10:
 	.type	fast_l2tp_rx, @function
 fast_l2tp_rx:
 	.set	nomips16
-	.frame	$sp,40,$31		# vars= 0, regs= 6/0, args= 16, gp= 0
-	.mask	0x801f0000,-4
+	.frame	$sp,48,$31		# vars= 0, regs= 8/0, args= 16, gp= 0
+	.mask	0x807f0000,-4
 	.fmask	0x00000000,0
 	.set	noreorder
 	.set	nomacro
 	
-	addiu	$sp,$sp,-40
-	sw	$19,28($sp)
-	move	$19,$4
-	sw	$31,36($sp)
+	addiu	$sp,$sp,-48
+	sw	$31,44($sp)
+	sw	$22,40($sp)
 	sw	$20,32($sp)
-	sw	$18,24($sp)
 	sw	$17,20($sp)
+	move	$17,$4
 	sw	$16,16($sp)
-	lw	$18,156($4)
-	lw	$3,84($4)
-	lbu	$2,0($18)
-	sltu	$3,$3,40
+	sw	$21,36($sp)
+	sw	$19,28($sp)
+	jal	rtl_ip_hdr
+	sw	$18,24($sp)
+
+	move	$4,$17
+	move	$20,$2
+	lbu	$2,0($2)
 	andi	$2,$2,0xf
 	sll	$2,$2,2
-	bne	$3,$0,$L32
-	addu	$5,$18,$2
+	jal	rtl_get_skb_data
+	addu	$16,$20,$2
+
+	move	$4,$17
+	jal	rtl_get_skb_len
+	move	$22,$2
 
-	lhu	$3,0($5)
+	sltu	$2,$2,40
+	bne	$2,$0,$L30
 	li	$2,1701			# 0x6a5
-	bne	$3,$2,$L32
+
+	lhu	$3,0($16)
+	bne	$3,$2,$L30
 	nop
 
-	lhu	$2,2($5)
-	bne	$2,$3,$L32
-	lui	$20,%hi(l2tpInfo)
+	lhu	$2,2($16)
+	bne	$2,$3,$L30
+	lui	$21,%hi(l2tpInfo)
 
-	lw	$2,%lo(l2tpInfo)($20)
-	bne	$2,$0,$L37
+	lw	$2,%lo(l2tpInfo)($21)
+	bne	$2,$0,$L33
 	nop
 
 	jal	l2tp_tx_id
-	nop
+	move	$4,$17
 
-$L37:
-	lw	$5,176($19)
-	addiu	$17,$20,%lo(l2tpInfo)
-	lhu	$2,20($17)
-	lbu	$3,28($5)
-	srl	$4,$3,5
-	andi	$3,$3,0x2
-	andi	$16,$4,0x2
-	beq	$2,$0,$L32
-	addu	$16,$16,$3
-
-	lhu	$2,22($17)
-	beq	$2,$0,$L32
-	addu	$3,$5,$16
-
-	lbu	$2,36($3)
-	bne	$2,$0,$L32
+$L33:
+	lbu	$2,28($22)
+	addiu	$19,$21,%lo(l2tpInfo)
+	lhu	$4,20($19)
+	srl	$3,$2,5
+	andi	$2,$2,0x2
+	andi	$18,$3,0x2
+	beq	$4,$0,$L30
+	addu	$18,$18,$2
+
+	lhu	$2,22($19)
+	beq	$2,$0,$L30
+	addu	$16,$22,$18
+
+	lbu	$2,36($16)
+	bne	$2,$0,$L30
 	li	$2,33			# 0x21
 
-	lbu	$3,37($3)
-	bne	$3,$2,$L32
+	lbu	$3,37($16)
+	bne	$3,$2,$L30
 	nop
 
-	lw	$2,%lo(l2tpInfo)($20)
-	beq	$2,$0,$L32
+	lw	$2,%lo(l2tpInfo)($21)
+	beq	$2,$0,$L30
 	nop
 
-	lw	$3,16($17)
-	lw	$2,16($18)
-	bne	$3,$2,$L32
+	lw	$3,16($20)
+	lw	$2,16($19)
+	bne	$2,$3,$L30
 	nop
 
-	lw	$3,12($18)
-	lw	$2,12($17)
-	bne	$2,$3,$L32
+	lw	$2,4($19)
+	bne	$2,$0,$L37
 	nop
 
-	lw	$2,4($17)
-	bne	$2,$0,$L41
-	lui	$4,%hi(init_net)
-
-	lui	$5,%hi($LC0)
-	addiu	$4,$4,%lo(init_net)
-	jal	__dev_get_by_name
-	addiu	$5,$5,%lo($LC0)
-
-	sw	$2,4($17)
-$L41:
-	lw	$4,4($17)
-	beq	$4,$0,$L32
-	nop
+	lui	$4,%hi($LC0)
+	jal	rtl_get_dev_by_name
+	addiu	$4,$4,%lo($LC0)
 
-	lw	$2,176($19)
-	addu	$2,$2,$16
-	lbu	$3,47($2)
+	sw	$2,4($19)
+$L37:
+	lw	$5,4($19)
+	beq	$5,$0,$L30
 	li	$2,6			# 0x6
-	beq	$3,$2,$L44
+
+	lbu	$3,47($16)
+	beq	$3,$2,$L40
 	li	$2,17			# 0x11
 
-	bne	$3,$2,$L32
+	bne	$3,$2,$L30
 	nop
 
-$L44:
-	sw	$4,24($19)
-	addiu	$5,$16,38
+$L40:
+	jal	rtl_set_skb_dev
+	move	$4,$17
+
+	addiu	$5,$18,38
 	jal	skb_pull
-	move	$4,$19
+	move	$4,$17
+
+	jal	rtl_skb_reset_network_header
+	move	$4,$17
+
+	jal	rtl_skb_reset_transport_header
+	move	$4,$17
 
-	lw	$2,176($19)
-	sw	$2,152($19)
-	sw	$2,156($19)
-	lw	$4,4($17)
-	beq	$4,$0,$L32
+	lw	$4,4($19)
+	beq	$4,$0,$L30
 	nop
 
-	lw	$16,180($4)
-	beq	$16,$0,$L32
+	jal	rtl_get_ppp_dev_priv
 	nop
 
-	jal	get_ppp_stats
-	move	$4,$16
+	beq	$2,$0,$L30
+	nop
+
+	lw	$4,4($19)
+	jal	rtl_get_ppp_dev_priv
+	nop
+
+	move	$4,$17
+	jal	rtl_get_skb_len
+	move	$16,$2
 
 	move	$4,$16
-	lw	$3,0($2)
-	addiu	$3,$3,1
-	jal	get_ppp_stats
-	sw	$3,0($2)
+	lw	$31,44($sp)
+	move	$6,$2
+	lw	$22,40($sp)
+	move	$5,$0
+	lw	$21,36($sp)
+	lw	$20,32($sp)
+	lw	$19,28($sp)
+	lw	$18,24($sp)
+	lw	$17,20($sp)
+	lw	$16,16($sp)
+	j	rtl_inc_ppp_stats
+	addiu	$sp,$sp,48
 
-	lw	$3,8($2)
-	lw	$4,84($19)
-	addu	$3,$3,$4
-	sw	$3,8($2)
-$L32:
-	lw	$31,36($sp)
+$L30:
+	lw	$31,44($sp)
+	lw	$22,40($sp)
+	lw	$21,36($sp)
 	lw	$20,32($sp)
 	lw	$19,28($sp)
 	lw	$18,24($sp)
 	lw	$17,20($sp)
 	lw	$16,16($sp)
 	j	$31
-	addiu	$sp,$sp,40
+	addiu	$sp,$sp,48
 
 	.set	macro
 	.set	reorder
@@ -610,11 +652,11 @@ get_fast_l2tp_lastxmit:
 	addiu	$5,$2,%lo(l2tpInfo)
 	li	$2,1			# 0x1
 	lhu	$3,38($5)
-	bne	$3,$2,$L46
+	bne	$3,$2,$L42
 	move	$4,$0
 
 	lw	$4,8($5)
-$L46:
+$L42:
 	j	$31
 	move	$2,$4
 
@@ -628,28 +670,40 @@ $L46:
 	.type	check_for_fast_l2tp_to_wan, @function
 check_for_fast_l2tp_to_wan:
 	.set	nomips16
-	.frame	$sp,0,$31		# vars= 0, regs= 0/0, args= 0, gp= 0
-	.mask	0x00000000,0
+	.frame	$sp,24,$31		# vars= 0, regs= 2/0, args= 16, gp= 0
+	.mask	0x80010000,-4
 	.fmask	0x00000000,0
 	.set	noreorder
 	.set	nomacro
 	
-	lw	$4,156($4)
+	addiu	$sp,$sp,-24
+	sw	$16,16($sp)
+	sw	$31,20($sp)
+	jal	rtl_ip_hdr
+	move	$16,$4
+
+	move	$4,$16
+	lbu	$3,9($2)
 	li	$2,1			# 0x1
-	lbu	$3,9($4)
-	beq	$3,$2,$L48
+	beq	$3,$2,$L44
 	move	$5,$0
 
-	lw	$2,12($4)
+	jal	rtl_ip_hdr
+	nop
+
 	li	$3,-256			# 0xffffff00
+	lw	$2,12($2)
 	and	$2,$2,$3
 	li	$3,171966464			# 0xa400000
 	ori	$3,$3,0x4000
 	xor	$2,$2,$3
 	sltu	$5,$0,$2
-$L48:
-	j	$31
+$L44:
+	lw	$31,20($sp)
 	move	$2,$5
+	lw	$16,16($sp)
+	j	$31
+	addiu	$sp,$sp,24
 
 	.set	macro
 	.set	reorder
@@ -667,20 +721,21 @@ __func__.0:
 	.type	fast_l2tp_to_wan, @function
 fast_l2tp_to_wan:
 	.set	nomips16
-	.frame	$sp,88,$31		# vars= 48, regs= 5/0, args= 16, gp= 0
-	.mask	0x800f0000,-8
+	.frame	$sp,88,$31		# vars= 48, regs= 6/0, args= 16, gp= 0
+	.mask	0x801f0000,-4
 	.fmask	0x00000000,0
 	addiu	$sp,$sp,-88
 	lui	$2,%hi(fast_l2tp_fw)
 	sw	$17,68($sp)
-	sw	$31,80($sp)
+	sw	$31,84($sp)
+	sw	$20,80($sp)
 	sw	$19,76($sp)
 	sw	$18,72($sp)
 	sw	$16,64($sp)
 	lw	$2,%lo(fast_l2tp_fw)($2)
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L57
+	beq	$2,$0,$L49
 	move	$17,$4
 	.set	macro
 	.set	reorder
@@ -688,84 +743,99 @@ fast_l2tp_to_wan:
 	lui	$18,%hi(l2tpInfo)
 	addiu	$3,$18,%lo(l2tpInfo)
 	lhu	$2,20($3)
-	beq	$2,$0,$L57
+	.set	noreorder
+	.set	nomacro
+	beq	$2,$0,$L47
+	move	$5,$0
+	.set	macro
+	.set	reorder
+
 	lhu	$2,22($3)
-	beq	$2,$0,$L57
+	beq	$2,$0,$L47
 	lw	$2,%lo(l2tpInfo)($18)
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L56
+	bne	$2,$0,$L48
 	li	$2,1			# 0x1
 	.set	macro
 	.set	reorder
 
-$L57:
+$L49:
+	.set	noreorder
+	.set	nomacro
+	j	$L47
+	move	$5,$0
+	.set	macro
+	.set	reorder
+
+$L48:
+	lhu	$3,38($3)
 	.set	noreorder
 	.set	nomacro
-	j	$L55
-	move	$3,$0
+	bne	$3,$2,$L47
+	move	$5,$0
 	.set	macro
 	.set	reorder
 
-$L56:
-	lhu	$4,38($3)
+	jal	rtl_ip_hdr
+	move	$4,$17
+	lhu	$20,2($2)
 	.set	noreorder
 	.set	nomacro
-	bne	$4,$2,$L55
-	move	$3,$0
+	jal	rtl_skb_headroom
+	move	$16,$2
 	.set	macro
 	.set	reorder
 
-	lw	$2,176($17)
-	lw	$3,172($17)
-	lw	$16,156($17)
-	subu	$2,$2,$3
 	sltu	$2,$2,52
-	lhu	$19,2($16)
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L62
-	li	$3,1073741824			# 0x40000000
+	bne	$2,$0,$L65
+	li	$5,52			# 0x34
 	.set	macro
 	.set	reorder
 
-	lw	$2,104($17)
-	and	$2,$2,$3
-	beq	$2,$0,$L78
-	lw	$2,168($17)
-	lw	$2,0($2)
-	andi	$2,$2,0xffff
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$4,$L80
+	jal	rtl_skb_cloned
 	move	$4,$17
 	.set	macro
 	.set	reorder
 
-$L78:
-	lw	$2,184($17)
-	xori	$2,$2,0x1
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L81
+	bne	$2,$0,$L65
+	li	$5,52			# 0x34
+	.set	macro
+	.set	reorder
+
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_skb_shared
 	move	$4,$17
 	.set	macro
 	.set	reorder
 
-$L62:
+	.set	noreorder
+	.set	nomacro
+	beq	$2,$0,$L66
 	move	$4,$17
-$L80:
+	.set	macro
+	.set	reorder
+
+	li	$5,52			# 0x34
+$L65:
 	.set	noreorder
 	.set	nomacro
 	jal	skb_realloc_headroom
-	li	$5,52			# 0x34
+	move	$4,$17
 	.set	macro
 	.set	reorder
 
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L55
-	move	$3,$0
+	beq	$2,$0,$L47
+	move	$5,$0
 	.set	macro
 	.set	reorder
 
@@ -778,12 +848,13 @@ $L80:
 	.set	reorder
 
 	move	$4,$17
-$L81:
+$L66:
+	li	$5,52			# 0x34
 	lbu	$16,1($16)
 	.set	noreorder
 	.set	nomacro
 	jal	skb_push
-	li	$5,52			# 0x34
+	addiu	$19,$sp,16
 	.set	macro
 	.set	reorder
 
@@ -801,43 +872,51 @@ $L81:
 	lw	$3,16($sp)
 	ori	$2,$2,0xffff
 	addiu	$4,$18,%lo(l2tpInfo)
-	addiu	$8,$sp,16
+	move	$5,$0
 	and	$3,$3,$2
 	li	$2,1073741824			# 0x40000000
 	or	$3,$3,$2
 	li	$2,-251723776			# 0xf0ff0000
 	ori	$2,$2,0xffff
-	addiu	$6,$sp,32
 	and	$3,$3,$2
 	li	$2,83886080			# 0x5000000
 	or	$3,$3,$2
 	li	$2,16384
-	lw	$5,16($4)
-	lw	$4,12($4)
+	lw	$7,16($4)
+	lw	$6,12($4)
+	move	$4,$17
 	sh	$2,22($sp)
 	li	$2,17
 	sb	$2,25($sp)
 	li	$2,64
 	sw	$3,16($sp)
-	sw	$5,28($sp)
+	sw	$6,32($sp)
+	sw	$7,28($sp)
 	sb	$2,24($sp)
-	li	$2,-805371904			# 0xcfff0000
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_set_skb_ip_summed
 	sb	$16,17($sp)
-	ori	$2,$2,0xffff
-	sw	$4,32($sp)
-	lw	$3,104($17)
-	lw	$4,84($17)
-	and	$3,$3,$2
-	addiu	$4,$4,-14
-	sw	$3,104($17)
-	sh	$4,18($sp)
+	.set	macro
+	.set	reorder
+
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_len
+	move	$4,$17
+	.set	macro
+	.set	reorder
+
+	addiu	$6,$sp,32
+	addiu	$2,$2,-14
+	sh	$2,18($sp)
 	lw	$3,16($sp)
 	sh	$0,20($sp)
 	lw	$4,20($sp)
 	srl	$2,$3,22
 	andi	$2,$2,0x3c
 	addu	$5,$3,$4
-	addu	$7,$8,$2
+	addu	$7,$19,$2
 	sh	$0,26($sp)
 	sltu	$4,$5,$4
 	lw	$2,24($sp)
@@ -849,18 +928,20 @@ $L81:
 	addu	$5,$5,$3
 	sltu	$4,$5,$3
 	addu	$5,$5,$4
-$L70:
+$L55:
 	lw	$2,0($6)
 	addiu	$6,$6,4
 	addu	$5,$5,$2
 	sltu	$4,$5,$2
 	.set	noreorder
 	.set	nomacro
-	bne	$6,$7,$L70
+	bne	$6,$7,$L55
 	addu	$5,$5,$4
 	.set	macro
 	.set	reorder
 
+	move	$4,$17
+	addiu	$16,$18,%lo(l2tpInfo)
 #APP
 		.set	push		# csum_fold
 	.set	noat		
@@ -872,90 +953,126 @@ $L70:
 	xori	$5, 0xffff	
 	.set	pop
 #NO_APP
-	sh	$5,10($8)
-	li	$6,20			# 0x14
-	lw	$4,176($17)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_data
+	sh	$5,10($19)
+	.set	macro
+	.set	reorder
+
 	addiu	$5,$sp,16
-	addiu	$16,$18,%lo(l2tpInfo)
+	addiu	$4,$2,14
 	.set	noreorder
 	.set	nomacro
 	jal	memcpy
-	addiu	$4,$4,14
+	li	$6,20			# 0x14
 	.set	macro
 	.set	reorder
 
-	addiu	$2,$19,18
-	lhu	$4,20($16)
-	li	$7,1701
+	addiu	$2,$20,18
 	lhu	$3,22($16)
-	addiu	$5,$sp,40
+	li	$6,1701
+	lhu	$5,20($16)
+	move	$4,$17
 	sh	$2,44($sp)
 	li	$2,2
 	sh	$2,48($sp)
 	li	$2,-253
 	sh	$2,54($sp)
 	li	$2,33
-	sh	$7,42($sp)
-	li	$6,18			# 0x12
-	sh	$4,50($sp)
 	sh	$3,52($sp)
+	sh	$6,42($sp)
+	sh	$5,50($sp)
+	sh	$6,40($sp)
 	sh	$2,56($sp)
-	sh	$7,40($sp)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_data
 	sh	$0,46($sp)
-	lw	$4,176($17)
+	.set	macro
+	.set	reorder
+
+	li	$6,18			# 0x12
+	addiu	$5,$sp,40
 	.set	noreorder
 	.set	nomacro
 	jal	memcpy
-	addiu	$4,$4,34
+	addiu	$4,$2,34
 	.set	macro
 	.set	reorder
 
-	lw	$2,%lo(l2tpInfo)($18)
-	sw	$2,24($17)
+	lw	$5,%lo(l2tpInfo)($18)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_set_skb_dev
+	move	$4,$17
+	.set	macro
+	.set	reorder
+
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_data
+	move	$4,$17
+	.set	macro
+	.set	reorder
+
+	.set	noreorder
+	.set	nomacro
+	jal	timeoutCheck_skipp_pkt
+	addiu	$4,$2,52
+	.set	macro
+	.set	reorder
+
+	li	$3,1			# 0x1
+	.set	noreorder
+	.set	nomacro
+	beq	$2,$3,$L60
 	lui	$2,%hi(jiffies)
+	.set	macro
+	.set	reorder
+
 	lw	$2,%lo(jiffies)($2)
+	sw	$2,8($16)
+$L60:
 	lw	$4,4($16)
 	.set	noreorder
 	.set	nomacro
-	beq	$4,$0,$L75
-	sw	$2,8($16)
+	beq	$4,$0,$L67
+	lui	$2,%hi(gQosEnabled)
 	.set	macro
 	.set	reorder
 
-	lw	$16,180($4)
+	jal	rtl_get_ppp_dev_priv
 	.set	noreorder
 	.set	nomacro
-	beq	$16,$0,$L82
+	beq	$2,$0,$L67
 	lui	$2,%hi(gQosEnabled)
 	.set	macro
 	.set	reorder
 
+	lw	$4,4($16)
+	jal	rtl_get_ppp_dev_priv
+	move	$4,$17
 	.set	noreorder
 	.set	nomacro
-	jal	get_ppp_stats
-	move	$4,$16
+	jal	rtl_get_skb_len
+	move	$16,$2
 	.set	macro
 	.set	reorder
 
 	move	$4,$16
-	lw	$3,4($2)
-	addiu	$3,$3,1
+	move	$6,$2
 	.set	noreorder
 	.set	nomacro
-	jal	get_ppp_stats
-	sw	$3,4($2)
+	jal	rtl_inc_ppp_stats
+	li	$5,1			# 0x1
 	.set	macro
 	.set	reorder
 
-	lw	$3,12($2)
-	lw	$4,84($17)
-	addu	$3,$3,$4
-	sw	$3,12($2)
-$L75:
 	lui	$2,%hi(gQosEnabled)
-$L82:
+$L67:
 	lw	$2,%lo(gQosEnabled)($2)
-	beq	$2,$0,$L76
+	beq	$2,$0,$L62
 	.set	noreorder
 	.set	nomacro
 	jal	dev_queue_xmit
@@ -965,26 +1082,24 @@ $L82:
 
 	.set	noreorder
 	.set	nomacro
-	j	$L55
-	li	$3,1			# 0x1
+	j	$L47
+	li	$5,1			# 0x1
 	.set	macro
 	.set	reorder
 
-$L76:
-	lw	$5,24($17)
-	lw	$2,184($5)
-	lw	$2,16($2)
+$L62:
 	.set	noreorder
 	.set	nomacro
-	jal	$2
+	jal	rtl_call_skb_ndo_start_xmit
 	move	$4,$17
 	.set	macro
 	.set	reorder
 
-	li	$3,1			# 0x1
-$L55:
-	lw	$31,80($sp)
-	move	$2,$3
+	li	$5,1			# 0x1
+$L47:
+	lw	$31,84($sp)
+	move	$2,$5
+	lw	$20,80($sp)
 	lw	$19,76($sp)
 	lw	$18,72($sp)
 	lw	$17,68($sp)
@@ -1037,13 +1152,13 @@ l2tp_read_proc:
 	subu	$4,$4,$17
 	slt	$3,$16,$4
 	movn	$4,$16,$3		#conditional move
-	bne	$2,$0,$L84
+	bne	$2,$0,$L69
 	slt	$5,$4,0
 
 	lw	$2,56($sp)
 	li	$3,1			# 0x1
 	sw	$3,0($2)
-$L84:
+$L69:
 	sw	$18,0($19)
 	move	$2,$0
 	lw	$31,32($sp)
@@ -1074,7 +1189,7 @@ l2tp_write_proc:
 	sw	$31,28($sp)
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L87
+	bne	$2,$0,$L72
 	move	$16,$6
 	.set	macro
 	.set	reorder
@@ -1082,7 +1197,7 @@ l2tp_write_proc:
 	addiu	$2,$5,1
 	.set	noreorder
 	.set	nomacro
-	beq	$5,$0,$L89
+	beq	$5,$0,$L74
 	or	$3,$5,$2
 	.set	macro
 	.set	reorder
@@ -1092,7 +1207,7 @@ l2tp_write_proc:
 	and	$2,$2,$3
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L89
+	bne	$2,$0,$L74
 	li	$6,1			# 0x1
 	.set	macro
 	.set	reorder
@@ -1107,7 +1222,7 @@ l2tp_write_proc:
 #NO_APP
 	.set	noreorder
 	.set	nomacro
-	bne	$6,$0,$L87
+	bne	$6,$0,$L72
 	li	$3,-14			# 0xfffffff2
 	.set	macro
 	.set	reorder
@@ -1119,7 +1234,7 @@ l2tp_write_proc:
 	li	$3,1			# 0x1
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$3,$L97
+	bne	$2,$3,$L82
 	lui	$4,%hi(l2tp_tx_id_hook)
 	.set	macro
 	.set	reorder
@@ -1128,16 +1243,16 @@ l2tp_write_proc:
 	addiu	$2,$2,%lo(l2tp_tx_id)
 	.set	noreorder
 	.set	nomacro
-	j	$L98
+	j	$L83
 	sw	$2,%lo(l2tp_tx_id_hook)($4)
 	.set	macro
 	.set	reorder
 
-$L97:
+$L82:
 	lui	$2,%hi(l2tpInfo+20)
 	sw	$0,%lo(l2tp_tx_id_hook)($4)
 	sh	$0,%lo(l2tpInfo+20)($2)
-$L98:
+$L83:
 	lui	$4,%hi(l2tpInfo)
 	move	$5,$0
 	li	$6,40			# 0x28
@@ -1152,14 +1267,14 @@ $L98:
 	move	$3,$16
 	.set	noreorder
 	.set	nomacro
-	j	$L87
+	j	$L72
 	sw	$0,%lo(state)($2)
 	.set	macro
 	.set	reorder
 
-$L89:
+$L74:
 	li	$3,-14			# 0xfffffff2
-$L87:
+$L72:
 	lw	$31,28($sp)
 	move	$2,$3
 	lw	$16,24($sp)
@@ -1202,7 +1317,7 @@ fast_l2tp_init:
 	addiu	$4,$4,%lo(l2tpInfo)
 	move	$5,$0
 	li	$6,40			# 0x28
-	beq	$2,$0,$L100
+	beq	$2,$0,$L85
 	sw	$2,%lo(res1)($7)
 
 	lui	$2,%hi(l2tp_read_proc)
@@ -1212,7 +1327,7 @@ fast_l2tp_init:
 	lw	$3,%lo(res1)($7)
 	addiu	$2,$2,%lo(l2tp_write_proc)
 	sw	$2,68($3)
-$L100:
+$L85:
 	lui	$2,%hi(l2tp_tx_id_hook)
 	sw	$0,%lo(l2tp_tx_id_hook)($2)
 	lui	$2,%hi(fast_l2tp_fw)
@@ -1249,14 +1364,14 @@ fast_l2tp_exit:
 	lw	$2,%lo(res1)($16)
 	addiu	$4,$4,%lo($LC4)
 	sw	$31,20($sp)
-	beq	$2,$0,$L101
+	beq	$2,$0,$L86
 	move	$5,$2
 
 	jal	remove_proc_entry
 	nop
 
 	sw	$0,%lo(res1)($16)
-$L101:
+$L86:
 	lw	$31,20($sp)
 	lw	$16,16($sp)
 	j	$31
diff --git a/net/rtl/fastpath/98/fast_pptp_core.S b/net/rtl/fastpath/98/fast_pptp_core.S
index e99b2cf..1719a65 100644
--- a/net/rtl/fastpath/98/fast_pptp_core.S
+++ b/net/rtl/fastpath/98/fast_pptp_core.S
@@ -103,48 +103,54 @@ pptp_conn_check:
 	.type	is_pptp_device, @function
 is_pptp_device:
 	.set	nomips16
-	.frame	$sp,0,$31		# vars= 0, regs= 0/0, args= 0, gp= 0
-	.mask	0x00000000,0
+	.frame	$sp,24,$31		# vars= 0, regs= 2/0, args= 16, gp= 0
+	.mask	0x80010000,-4
 	.fmask	0x00000000,0
+	addiu	$sp,$sp,-24
 	lui	$2,%hi(pptpAccInfo+56)
+	sw	$16,16($sp)
+	move	$16,$4
+	sw	$31,20($sp)
 	lw	$2,%lo(pptpAccInfo+56)($2)
 	.set	noreorder
 	.set	nomacro
 	beq	$2,$0,$L2
-	move	$5,$2
+	move	$4,$2
 	.set	macro
 	.set	reorder
 
-	move	$3,$4
+	jal	rtl_get_ppp_dev_name
 #APP
 	.set	noreorder
 	.set	noat
-	lbu	$2,($5)
-1:	lbu	$1,($3)
-	addiu	$5,1
-	bne	$1,$2,2f
-	addiu	$3,1
-	bnez	$2,1b
-	lbu	$2,($5)
-	move	$2,$1
-2:	subu	$2,$1
+	lbu	$3,($2)
+1:	lbu	$1,($16)
+	addiu	$2,1
+	bne	$1,$3,2f
+	addiu	$16,1
+	bnez	$3,1b
+	lbu	$3,($2)
+	move	$3,$1
+2:	subu	$3,$1
 3:	.set	at
 	.set	reorder
 #NO_APP
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L1
-	li	$3,1			# 0x1
+	beq	$3,$0,$L1
+	li	$2,1			# 0x1
 	.set	macro
 	.set	reorder
 
 $L2:
-	move	$3,$0
+	move	$2,$0
 $L1:
+	lw	$31,20($sp)
+	lw	$16,16($sp)
 	.set	noreorder
 	.set	nomacro
 	j	$31
-	move	$2,$3
+	addiu	$sp,$sp,24
 	.set	macro
 	.set	reorder
 
@@ -165,13 +171,11 @@ set_pptp_device:
 	addiu	$sp,$sp,-24
 	lui	$2,%hi(fast_pptp_fw)
 	sw	$31,16($sp)
-	move	$5,$4
 	lw	$2,%lo(fast_pptp_fw)($2)
-	lui	$4,%hi(init_net)
 	beq	$2,$0,$L4
-	addiu	$4,$4,%lo(init_net)
+	nop
 
-	jal	__dev_get_by_name
+	jal	rtl_get_dev_by_name
 	nop
 
 	lui	$3,%hi(pptpAccInfo)
@@ -192,39 +196,57 @@ $L4:
 	.type	Check_GRE_rx_net_device, @function
 Check_GRE_rx_net_device:
 	.set	nomips16
-	.frame	$sp,0,$31		# vars= 0, regs= 0/0, args= 0, gp= 0
-	.mask	0x00000000,0
+	.frame	$sp,32,$31		# vars= 0, regs= 4/0, args= 16, gp= 0
+	.mask	0x80070000,-4
 	.fmask	0x00000000,0
 	.set	noreorder
 	.set	nomacro
 	
-	lw	$3,156($4)
-	lui	$2,%hi(pptpAccInfo)
-	addiu	$7,$2,%lo(pptpAccInfo)
-	move	$5,$4
-	lbu	$2,0($3)
+	addiu	$sp,$sp,-32
+	sw	$31,28($sp)
+	sw	$18,24($sp)
+	sw	$17,20($sp)
+	move	$17,$4
+	jal	rtl_ip_hdr
+	sw	$16,16($sp)
+
+	move	$4,$17
+	jal	rtl_get_skb_data
+	move	$16,$2
+
+	lui	$3,%hi(pptpAccInfo)
+	lbu	$5,0($16)
+	addiu	$18,$3,%lo(pptpAccInfo)
+	lw	$3,8($18)
+	move	$4,$17
+	andi	$5,$5,0xf
 	move	$6,$0
-	lw	$4,176($4)
-	andi	$2,$2,0xf
-	lw	$3,8($7)
-	sll	$2,$2,2
+	sll	$5,$5,2
 	beq	$3,$0,$L6
-	addu	$4,$4,$2
+	addu	$16,$2,$5
+
+	jal	rtl_get_skb_dev
+	nop
 
-	lw	$2,24($5)
-	bne	$3,$2,$L10
+	lw	$3,8($18)
+	bne	$3,$2,$L8
 	li	$6,1			# 0x1
 
-	lhu	$3,6($4)
-	lhu	$2,30($7)
+	lhu	$3,6($16)
+	lhu	$2,30($18)
 	beq	$3,$2,$L6
 	nop
 
-$L10:
+$L8:
 	move	$6,$0
 $L6:
-	j	$31
+	lw	$31,28($sp)
 	move	$2,$6
+	lw	$18,24($sp)
+	lw	$17,20($sp)
+	lw	$16,16($sp)
+	j	$31
+	addiu	$sp,$sp,32
 
 	.set	macro
 	.set	reorder
@@ -236,34 +258,40 @@ $L6:
 	.type	fast_pptp_filter, @function
 fast_pptp_filter:
 	.set	nomips16
-	.frame	$sp,32,$31		# vars= 0, regs= 4/0, args= 16, gp= 0
-	.mask	0x80070000,-4
+	.frame	$sp,40,$31		# vars= 0, regs= 5/0, args= 16, gp= 0
+	.mask	0x800f0000,-8
 	.fmask	0x00000000,0
 	.set	noreorder
 	.set	nomacro
 	
-	addiu	$sp,$sp,-32
+	addiu	$sp,$sp,-40
+	sw	$19,28($sp)
+	move	$19,$4
+	sw	$31,32($sp)
 	sw	$18,24($sp)
-	sw	$31,28($sp)
 	sw	$17,20($sp)
+	jal	rtl_ip_hdr
 	sw	$16,16($sp)
-	lw	$2,84($4)
-	lw	$8,156($4)
+
+	move	$4,$19
+	jal	rtl_get_skb_len
+	move	$18,$2
+
 	sltu	$2,$2,56
-	bne	$2,$0,$L13
-	move	$18,$4
+	bne	$2,$0,$L11
+	nop
 
-	lbu	$2,0($8)
-	lbu	$3,9($8)
+	lbu	$2,0($18)
+	lbu	$3,9($18)
 	andi	$2,$2,0xf
 	sll	$2,$2,2
-	addu	$4,$8,$2
+	addu	$4,$18,$2
 	li	$2,6			# 0x6
-	bne	$3,$2,$L13
+	bne	$3,$2,$L11
 	li	$2,1723			# 0x6bb
 
 	lhu	$3,0($4)
-	bne	$3,$2,$L13
+	bne	$3,$2,$L11
 	nop
 
 	lw	$2,12($4)
@@ -271,116 +299,123 @@ fast_pptp_filter:
 	sll	$2,$2,2
 	addu	$4,$4,$2
 	li	$2,1			# 0x1
-	lhu	$6,2($4)
-	addiu	$9,$4,8
-	andi	$5,$6,0xffff
-	bne	$5,$2,$L18
-	addiu	$7,$4,12
+	lhu	$7,2($4)
+	addiu	$8,$4,8
+	andi	$5,$7,0xffff
+	bne	$5,$2,$L14
+	addiu	$6,$4,12
 
 	lhu	$3,8($4)
 	li	$2,8			# 0x8
-	bne	$3,$2,$L18
+	bne	$3,$2,$L14
 	nop
 
-	lbu	$2,4($7)
-	bne	$2,$5,$L18
+	lbu	$2,4($6)
+	bne	$2,$5,$L14
 	lui	$16,%hi(pptpAccInfo)
 
 	addiu	$5,$16,%lo(pptpAccInfo)
 	lw	$2,36($5)
-	beq	$2,$0,$L19
+	beq	$2,$0,$L15
 	nop
 
 	lw	$2,20($5)
-	beq	$2,$0,$L19
+	beq	$2,$0,$L15
 	nop
 
 	lw	$2,32($5)
-	beq	$2,$0,$L19
+	beq	$2,$0,$L15
 	nop
 
 	lhu	$3,12($4)
 	lhu	$2,18($5)
-	bne	$2,$3,$L13
+	bne	$2,$3,$L11
 	nop
 
 	lhu	$3,30($5)
-	lhu	$2,2($7)
-	bne	$3,$2,$L13
+	lhu	$2,2($6)
+	bne	$3,$2,$L11
 	nop
 
-$L19:
+$L15:
 	li	$17,1			# 0x1
 	lui	$2,%hi(pptp_tcp_finished)
 	sw	$17,%lo(pptp_tcp_finished)($2)
 	addiu	$16,$16,%lo(pptpAccInfo)
-	lhu	$2,0($7)
-	lui	$4,%hi(pptpAccInfo+24)
-	addiu	$4,$4,%lo(pptpAccInfo+24)
-	li	$6,6			# 0x6
+	lhu	$2,0($6)
+	move	$4,$19
 	sh	$2,18($16)
-	lhu	$2,2($7)
+	lhu	$2,2($6)
 	sh	$2,30($16)
-	lw	$2,16($8)
+	lw	$2,16($18)
 	sw	$2,20($16)
-	lw	$2,12($8)
+	lw	$2,12($18)
 	sw	$17,36($16)
+	jal	rtl_get_skb_dev
 	sw	$2,32($16)
-	lw	$2,24($18)
+
+	move	$4,$19
+	jal	rtl_get_skb_data
 	sw	$2,8($16)
-	lw	$5,176($18)
+
+	lui	$4,%hi(pptpAccInfo+24)
+	addiu	$5,$2,-8
+	li	$6,6			# 0x6
 	jal	memcpy
-	addiu	$5,$5,-8
+	addiu	$4,$4,%lo(pptpAccInfo+24)
+
+	jal	rtl_get_skb_data
+	move	$4,$19
 
 	lui	$4,%hi(pptpAccInfo+12)
-	lw	$5,176($18)
 	addiu	$4,$4,%lo(pptpAccInfo+12)
-	li	$6,6			# 0x6
+	addiu	$5,$2,-14
 	jal	memcpy
-	addiu	$5,$5,-14
+	li	$6,6			# 0x6
 
-	j	$L13
+	j	$L11
 	sw	$17,4($16)
 
-$L18:
-	andi	$3,$6,0xffff
+$L14:
+	andi	$3,$7,0xffff
 	li	$2,1			# 0x1
-	bne	$3,$2,$L13
+	bne	$3,$2,$L11
 	li	$2,13			# 0xd
 
-	lhu	$3,0($9)
-	bne	$3,$2,$L13
+	lhu	$3,0($8)
+	bne	$3,$2,$L11
 	lui	$4,%hi(pptpAccInfo)
 
 	addiu	$3,$4,%lo(pptpAccInfo)
 	lw	$2,36($3)
-	beq	$2,$0,$L33
+	beq	$2,$0,$L29
 	lui	$2,%hi(pptp_tcp_finished)
 
 	lw	$2,20($3)
-	beq	$2,$0,$L33
+	beq	$2,$0,$L29
 	lui	$2,%hi(pptp_tcp_finished)
 
 	lw	$2,32($3)
-	beq	$2,$0,$L33
+	beq	$2,$0,$L29
 	lui	$2,%hi(pptp_tcp_finished)
 
 	lhu	$3,18($3)
-	lhu	$2,4($9)
-	bne	$3,$2,$L13
+	lhu	$2,4($8)
+	bne	$3,$2,$L11
 	addiu	$3,$4,%lo(pptpAccInfo)
 
 	lui	$2,%hi(pptp_tcp_finished)
-$L33:
+$L29:
 	sw	$0,%lo(pptp_tcp_finished)($2)
 	sw	$0,4($3)
-$L13:
-	lw	$31,28($sp)
+$L11:
+	lw	$31,32($sp)
+	lw	$19,28($sp)
 	lw	$18,24($sp)
 	lw	$17,20($sp)
 	lw	$16,16($sp)
 	j	$31
-	addiu	$sp,$sp,32
+	addiu	$sp,$sp,40
 
 	.set	macro
 	.set	reorder
@@ -392,223 +427,279 @@ $L13:
 	.type	fast_pptp_to_lan, @function
 fast_pptp_to_lan:
 	.set	nomips16
-	.frame	$sp,40,$31		# vars= 0, regs= 6/0, args= 16, gp= 0
-	.mask	0x801f0000,-4
+	.frame	$sp,48,$31		# vars= 0, regs= 8/0, args= 16, gp= 0
+	.mask	0x807f0000,-4
 	.fmask	0x00000000,0
 	.set	noreorder
 	.set	nomacro
 	
-	addiu	$sp,$sp,-40
-	lui	$9,%hi(pptpAccInfo)
+	addiu	$sp,$sp,-48
+	sw	$22,40($sp)
+	move	$22,$0
+	sw	$21,36($sp)
+	move	$21,$4
 	sw	$20,32($sp)
-	move	$20,$4
+	lui	$20,%hi(pptpAccInfo)
+	sw	$16,16($sp)
+	addiu	$16,$20,%lo(pptpAccInfo)
+	sw	$31,44($sp)
 	sw	$19,28($sp)
-	sw	$31,36($sp)
 	sw	$18,24($sp)
 	sw	$17,20($sp)
-	sw	$16,16($sp)
-	lw	$16,0($4)
-	addiu	$4,$9,%lo(pptpAccInfo)
-	lw	$3,8($4)
-	lw	$2,24($16)
-	bne	$2,$3,$L41
-	move	$19,$0
-
-	lw	$7,156($16)
+	lw	$18,0($4)
+	jal	rtl_get_skb_dev
+	move	$4,$18
+
+	lw	$3,8($16)
+	bne	$2,$3,$L30
+	move	$7,$0
+
+	jal	rtl_ip_hdr
+	move	$4,$18
+
+	lbu	$3,9($2)
 	li	$2,47			# 0x2f
-	lbu	$3,9($7)
-	bne	$3,$2,$L34
-	move	$8,$0
+	bne	$3,$2,$L30
+	move	$7,$0
+
+	jal	rtl_get_skb_len
+	move	$4,$18
 
-	lw	$2,84($16)
 	sltu	$2,$2,20
-	bne	$2,$0,$L34
-	nop
+	bne	$2,$0,$L30
+	move	$7,$0
 
-	lbu	$2,0($7)
-	lw	$3,176($16)
-	andi	$2,$2,0xf
-	sll	$2,$2,2
-	addu	$5,$3,$2
+	jal	rtl_ip_hdr
+	move	$4,$18
+
+	move	$4,$18
+	jal	rtl_get_skb_data
+	move	$17,$2
+
+	lbu	$3,0($17)
+	andi	$3,$3,0xf
+	sll	$3,$3,2
+	addu	$5,$2,$3
 	li	$3,1			# 0x1
 	lbu	$2,1($5)
 	andi	$2,$2,0x7
-	bne	$2,$3,$L34
-	li	$2,34827			# 0x880b
+	bne	$2,$3,$L30
+	move	$7,$0
 
 	lhu	$3,2($5)
-	bne	$3,$2,$L34
-	li	$17,8			# 0x8
+	li	$2,34827			# 0x880b
+	bne	$3,$2,$L30
+	li	$19,8			# 0x8
 
 	lhu	$3,6($5)
-	lhu	$2,30($4)
-	bne	$3,$2,$L34
+	lhu	$2,30($16)
+	bne	$3,$2,$L30
 	move	$6,$0
 
 	lbu	$2,0($5)
 	andi	$2,$2,0x10
-	beq	$2,$0,$L43
+	beq	$2,$0,$L35
 	nop
 
 	lw	$2,8($5)
-	li	$17,12			# 0xc
-	sw	$2,40($4)
-$L43:
+	li	$19,12			# 0xc
+	sw	$2,40($16)
+$L35:
 	lb	$2,1($5)
-	addiu	$3,$17,4
+	addiu	$3,$19,4
 	lhu	$4,4($5)
 	slt	$2,$2,0
-	movn	$17,$3,$2		#conditional move  
-	beq	$4,$0,$L41
-	addu	$5,$5,$17
+	movn	$19,$3,$2		#conditional move  
+	beq	$4,$0,$L33
+	addu	$5,$5,$19
 
 	lbu	$3,0($5)
-	bne	$3,$0,$L46
+	bne	$3,$0,$L38
 	li	$2,255			# 0xff
 
 	addiu	$5,$5,1
-	j	$L47
+	j	$L39
 	li	$6,1			# 0x1
 
-$L46:
-	bne	$3,$2,$L47
+$L38:
+	bne	$3,$2,$L39
 	li	$2,3			# 0x3
 
 	lbu	$3,1($5)
-	bne	$3,$2,$L47
+	bne	$3,$2,$L39
 	nop
 
 	addiu	$5,$5,2
 	lbu	$2,0($5)
-	bne	$2,$0,$L47
+	bne	$2,$0,$L39
 	li	$6,2			# 0x2
 
 	addiu	$5,$5,1
 	li	$6,3			# 0x3
-$L47:
+$L39:
 	lbu	$3,0($5)
 	li	$2,33			# 0x21
-	beq	$3,$2,$L51
+	beq	$3,$2,$L43
 	li	$2,253			# 0xfd
 
-	bne	$3,$2,$L34
-	move	$8,$0
+	bne	$3,$2,$L30
+	move	$7,$0
 
-$L51:
+$L43:
 	addiu	$6,$6,1
-	beq	$6,$0,$L41
-	move	$18,$3
+	beq	$6,$0,$L33
+	move	$16,$3
 
-	lbu	$2,0($7)
+	lbu	$2,0($17)
 	andi	$2,$2,0xf
 	sll	$2,$2,2
-	addu	$2,$2,$17
-	addu	$17,$2,$6
+	addu	$2,$2,$19
+	addu	$19,$2,$6
 	li	$2,33			# 0x21
-	beq	$3,$2,$L54
-	move	$5,$17
+	beq	$3,$2,$L46
+	addiu	$17,$20,%lo(pptpAccInfo)
 
-	addiu	$19,$9,%lo(pptpAccInfo)
-	lw	$2,56($19)
-	beq	$2,$0,$L34
-	move	$8,$0
+	lw	$4,56($17)
+	beq	$4,$0,$L30
+	move	$7,$0
 
-	lw	$2,180($2)
-	beq	$2,$0,$L34
-	move	$4,$16
+	jal	rtl_get_ppp_dev_priv
+	nop
 
+	beq	$2,$0,$L30
+	move	$7,$0
+
+	addiu	$5,$19,-2
 	jal	skb_pull
-	addiu	$5,$17,-2
+	move	$4,$18
 
-	move	$5,$16
-	lw	$2,176($16)
+	jal	rtl_get_skb_data
+	move	$4,$18
+
+	sb	$16,1($2)
 	sb	$0,0($2)
-	lw	$2,176($16)
-	sb	$18,1($2)
-	lw	$2,56($19)
-	lw	$4,180($2)
-	jal	ppp_receive_nonmp_frame
+	lw	$4,56($17)
+	jal	rtl_get_ppp_dev_priv
+	nop
+
+	move	$5,$18
+	move	$4,$2
+	jal	rtl_ppp_receive_nonmp_frame
 	li	$6,1			# 0x1
 
-	li	$8,-2			# 0xfffffffe
-	beq	$2,$0,$L34
-	move	$16,$2
+	li	$7,-2			# 0xfffffffe
+	beq	$2,$0,$L30
+	move	$18,$2
 
-	li	$19,1			# 0x1
-	j	$L58
-	sw	$2,0($20)
+	li	$22,1			# 0x1
+	j	$L50
+	sw	$2,0($21)
 
-$L54:
+$L46:
+	move	$5,$19
 	jal	skb_pull
-	move	$4,$16
+	move	$4,$18
 
-$L58:
-	lw	$4,176($16)
-	andi	$17,$4,0x3
-	beq	$17,$0,$L59
+$L50:
+	jal	rtl_get_skb_data
+	move	$4,$18
+
+	andi	$19,$2,0x3
+	beq	$19,$0,$L59
+	move	$4,$18
+
+	jal	rtl_skb_headroom
+	move	$4,$18
+
+	sltu	$2,$2,$19
+	bne	$2,$0,$L51
 	nop
 
-	lw	$2,172($16)
-	subu	$2,$4,$2
-	sltu	$2,$2,$17
-	bne	$2,$0,$L59
-	move	$5,$4
+	jal	rtl_get_skb_data
+	move	$4,$18
 
-	lw	$6,84($16)
+	move	$4,$18
+	jal	rtl_get_skb_data
+	subu	$17,$2,$19
+
+	move	$4,$18
+	jal	rtl_get_skb_len
+	move	$16,$2
+
+	move	$4,$17
+	move	$5,$16
 	jal	memmove
-	subu	$4,$4,$17
+	move	$6,$2
 
-	lw	$2,176($16)
-	lw	$3,164($16)
-	subu	$2,$2,$17
-	subu	$3,$3,$17
-	sw	$2,176($16)
-	sw	$3,164($16)
+	move	$4,$18
+	move	$5,$19
+	jal	rtl_set_skb_data
+	li	$6,1			# 0x1
+
+	move	$4,$18
+	move	$5,$19
+	jal	rtl_set_skb_tail
+	li	$6,1			# 0x1
+
+$L51:
+	move	$4,$18
 $L59:
-	lw	$2,176($16)
-	lui	$5,%hi(pptpAccInfo)
-	addiu	$3,$5,%lo(pptpAccInfo)
-	sw	$2,152($16)
-	sw	$2,156($16)
-	lw	$2,56($3)
-	beq	$2,$0,$L34
-	move	$8,$0
+	jal	rtl_skb_reset_network_header
+	lui	$17,%hi(pptpAccInfo)
+
+	addiu	$16,$17,%lo(pptpAccInfo)
+	jal	rtl_skb_reset_transport_header
+	move	$4,$18
+
+	lw	$4,56($16)
+	beq	$4,$0,$L30
+	move	$7,$0
+
+	bne	$22,$0,$L60
+	addiu	$2,$17,%lo(pptpAccInfo)
 
-	bne	$19,$0,$L63
+	jal	rtl_get_ppp_dev_priv
 	nop
 
-	lw	$4,180($2)
-	beq	$4,$0,$L68
-	addiu	$2,$5,%lo(pptpAccInfo)
+	beq	$2,$0,$L60
+	addiu	$2,$17,%lo(pptpAccInfo)
 
-	lw	$2,156($4)
-	lw	$3,164($4)
-	addiu	$2,$2,1
-	sw	$2,156($4)
-	lw	$2,84($16)
-	addu	$3,$3,$2
-	addiu	$3,$3,-2
-	sw	$3,164($4)
-$L63:
-	addiu	$2,$5,%lo(pptpAccInfo)
-$L68:
-	li	$8,1			# 0x1
-	lw	$2,56($2)
-	j	$L34
-	sw	$2,24($16)
-
-$L41:
-	move	$8,$0
-$L34:
-	lw	$31,36($sp)
-	move	$2,$8
+	lw	$4,56($16)
+	jal	rtl_get_ppp_dev_priv
+	nop
+
+	move	$4,$18
+	jal	rtl_get_skb_len
+	move	$16,$2
+
+	move	$4,$16
+	addiu	$6,$2,-2
+	jal	rtl_inc_ppp_stats
+	move	$5,$0
+
+	addiu	$2,$17,%lo(pptpAccInfo)
+$L60:
+	lw	$5,56($2)
+	jal	rtl_set_skb_dev
+	move	$4,$18
+
+	j	$L30
+	li	$7,1			# 0x1
+
+$L33:
+	move	$7,$0
+$L30:
+	lw	$31,44($sp)
+	move	$2,$7
+	lw	$22,40($sp)
+	lw	$21,36($sp)
 	lw	$20,32($sp)
 	lw	$19,28($sp)
 	lw	$18,24($sp)
 	lw	$17,20($sp)
 	lw	$16,16($sp)
 	j	$31
-	addiu	$sp,$sp,40
+	addiu	$sp,$sp,48
 
 	.set	macro
 	.set	reorder
@@ -630,16 +721,16 @@ get_fastpptp_lastxmit:
 	lui	$5,%hi(pptpAccInfo)
 	lw	$2,%lo(fast_pptp_fw)($2)
 	addiu	$3,$5,%lo(pptpAccInfo)
-	beq	$2,$0,$L69
+	beq	$2,$0,$L61
 	move	$4,$0
 
 	lw	$3,4($3)
 	li	$2,1			# 0x1
-	bne	$3,$2,$L69
+	bne	$3,$2,$L61
 	nop
 
 	lw	$4,%lo(pptpAccInfo)($5)
-$L69:
+$L61:
 	j	$31
 	move	$2,$4
 
@@ -665,43 +756,65 @@ $LC2:
 	.type	fast_pptp_to_wan, @function
 fast_pptp_to_wan:
 	.set	nomips16
-	.frame	$sp,80,$31		# vars= 40, regs= 6/0, args= 16, gp= 0
-	.mask	0x801f0000,-4
+	.frame	$sp,88,$31		# vars= 40, regs= 7/0, args= 16, gp= 0
+	.mask	0x803f0000,-8
 	.fmask	0x00000000,0
-	addiu	$sp,$sp,-80
-	li	$2,16711680			# 0xff0000
+	addiu	$sp,$sp,-88
+	sw	$31,80($sp)
+	sw	$18,64($sp)
+	move	$18,$4
 	sw	$17,60($sp)
-	move	$17,$4
-	sw	$31,76($sp)
+	sw	$16,56($sp)
+	sw	$21,76($sp)
 	sw	$20,72($sp)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_ip_hdr
 	sw	$19,68($sp)
-	sw	$18,64($sp)
-	sw	$16,56($sp)
-	lw	$7,156($4)
-	li	$4,-16777216			# 0xff000000
-	lw	$3,12($7)
-	and	$5,$3,$2
-	and	$4,$3,$4
-	li	$2,167772160			# 0xa000000
+	.set	macro
+	.set	reorder
+
+	move	$4,$18
+	lw	$16,12($2)
+	li	$2,-16777216			# 0xff000000
 	.set	noreorder
 	.set	nomacro
-	bne	$4,$2,$L78
-	andi	$3,$3,0xff00
+	jal	rtl_ip_hdr
+	and	$16,$16,$2
 	.set	macro
 	.set	reorder
 
+	move	$4,$18
+	lw	$3,12($2)
+	li	$2,16711680			# 0xff0000
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_ip_hdr
+	and	$17,$3,$2
+	.set	macro
+	.set	reorder
+
+	lw	$2,12($2)
+	andi	$3,$2,0xff00
+	li	$2,167772160			# 0xa000000
+	.set	noreorder
+	.set	nomacro
+	bne	$16,$2,$L64
 	li	$2,4194304			# 0x400000
+	.set	macro
+	.set	reorder
+
 	.set	noreorder
 	.set	nomacro
-	bne	$5,$2,$L78
+	bne	$17,$2,$L64
 	li	$2,16384			# 0x4000
 	.set	macro
 	.set	reorder
 
 	.set	noreorder
 	.set	nomacro
-	bne	$3,$2,$L112
-	lui	$19,%hi(pptpAccInfo)
+	bne	$3,$2,$L89
+	lui	$20,%hi(pptpAccInfo)
 	.set	macro
 	.set	reorder
 
@@ -710,128 +823,196 @@ fast_pptp_to_wan:
 	li	$2,3			# 0x3
 	.set	noreorder
 	.set	nomacro
-	beq	$3,$2,$L71
+	beq	$3,$2,$L63
 	move	$4,$0
 	.set	macro
 	.set	reorder
 
-$L78:
-	lui	$19,%hi(pptpAccInfo)
-$L112:
-	addiu	$6,$19,%lo(pptpAccInfo)
-	lw	$5,56($6)
+$L64:
+	lui	$20,%hi(pptpAccInfo)
+$L89:
+	addiu	$17,$20,%lo(pptpAccInfo)
+	lw	$4,56($17)
+	beq	$4,$0,$L83
+	jal	rtl_get_ppp_dev_name
 	.set	noreorder
 	.set	nomacro
-	beq	$5,$0,$L71
+	beq	$2,$0,$L63
 	move	$4,$0
 	.set	macro
 	.set	reorder
 
-	lui	$3,%hi($LC0)
-	move	$4,$5
-	addiu	$2,$3,%lo($LC0)
+	lw	$4,56($17)
+	jal	rtl_get_ppp_dev_name
+	lui	$4,%hi($LC0)
+	addiu	$3,$4,%lo($LC0)
 #APP
 	.set	noreorder
 	.set	noat
-	lbu	$3,($4)
-1:	lbu	$1,($2)
-	addiu	$4,1
-	bne	$1,$3,2f
+	lbu	$4,($2)
+1:	lbu	$1,($3)
 	addiu	$2,1
-	bnez	$3,1b
-	lbu	$3,($4)
-	move	$3,$1
-2:	subu	$3,$1
+	bne	$1,$4,2f
+	addiu	$3,1
+	bnez	$4,1b
+	lbu	$4,($2)
+	move	$4,$1
+2:	subu	$4,$1
 3:	.set	at
 	.set	reorder
 #NO_APP
 	.set	noreorder
 	.set	nomacro
-	bne	$3,$0,$L71
+	bne	$4,$0,$L63
 	move	$4,$0
 	.set	macro
 	.set	reorder
 
-	lw	$2,4($6)
-	beq	$2,$0,$L71
-	lw	$16,180($5)
-	beq	$16,$0,$L71
-	lw	$2,92($16)
-	beq	$2,$0,$L83
-	lw	$2,80($16)
-	andi	$2,$2,0x1000
-	beq	$2,$0,$L71
-	lw	$2,128($16)
-	beq	$2,$0,$L82
-$L83:
-	lw	$2,120($16)
-	lbu	$20,1($7)
+	lw	$2,4($17)
+	.set	noreorder
+	.set	nomacro
+	beq	$2,$0,$L90
+	addiu	$2,$20,%lo(pptpAccInfo)
+	.set	macro
+	.set	reorder
+
+	lw	$4,56($17)
+	beq	$4,$0,$L90
+	jal	rtl_get_ppp_dev_priv
+	.set	noreorder
+	.set	nomacro
+	beq	$2,$0,$L68
+	addiu	$2,$20,%lo(pptpAccInfo)
+	.set	macro
+	.set	reorder
+
+	lw	$4,56($17)
+	jal	rtl_get_ppp_dev_priv
+	move	$4,$2
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L71
+	jal	rtl_ppp_vj_check
+	move	$16,$2
+	.set	macro
+	.set	reorder
+
+	li	$3,1			# 0x1
+	.set	noreorder
+	.set	nomacro
+	beq	$2,$3,$L63
+	move	$4,$0
+	.set	macro
+	.set	reorder
+
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_ip_hdr
+	move	$4,$18
+	.set	macro
+	.set	reorder
+
+	lbu	$21,1($2)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_ppp_xmit_pending
+	move	$4,$16
+	.set	macro
+	.set	reorder
+
+	.set	noreorder
+	.set	nomacro
+	bne	$2,$0,$L63
 	move	$4,$0
 	.set	macro
 	.set	reorder
 
 	lui	$5,%hi($LC2)
-	addiu	$4,$17,32
+	li	$6,3			# 0x3
 	addiu	$5,$5,%lo($LC2)
 	.set	noreorder
 	.set	nomacro
-	jal	memcpy
-	li	$6,3			# 0x3
+	jal	rtl_set_skb_cb
+	move	$4,$18
 	.set	macro
 	.set	reorder
 
-	addiu	$2,$19,%lo(pptpAccInfo)
-	lw	$5,56($2)
+	lw	$5,56($17)
 	.set	noreorder
 	.set	nomacro
-	jal	ppp_start_xmit
-	move	$4,$17
+	jal	rtl_ppp_start_xmit
+	move	$4,$18
+	.set	macro
+	.set	reorder
+
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_ppp_xmit_pending
+	move	$4,$16
 	.set	macro
 	.set	reorder
 
-	lw	$18,120($16)
 	.set	noreorder
 	.set	nomacro
-	beq	$18,$0,$L71
+	beq	$2,$0,$L63
 	li	$4,1			# 0x1
 	.set	macro
 	.set	reorder
 
-	sw	$0,120($16)
-	lw	$2,176($18)
-	lw	$3,172($18)
-	subu	$2,$2,$3
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_ppp_xmit_pending
+	move	$4,$16
+	.set	macro
+	.set	reorder
+
+	move	$4,$16
+	move	$18,$2
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_set_ppp_xmit_pending
+	move	$5,$0
+	.set	macro
+	.set	reorder
+
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_skb_headroom
+	move	$4,$18
+	.set	macro
+	.set	reorder
+
 	sltu	$2,$2,50
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L92
-	move	$17,$18
+	bne	$2,$0,$L91
+	move	$4,$18
 	.set	macro
 	.set	reorder
 
-	lw	$2,104($18)
-	li	$3,1073741824			# 0x40000000
-	and	$2,$2,$3
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L111
-	li	$3,1			# 0x1
+	jal	rtl_skb_cloned
+	move	$4,$18
 	.set	macro
 	.set	reorder
 
-	lw	$2,168($18)
-	lw	$2,0($2)
-	andi	$2,$2,0xffff
-	bne	$2,$3,$L92
-$L111:
-	lw	$2,184($17)
-	xori	$2,$2,0x1
-	beq	$2,$0,$L91
-$L92:
+	.set	noreorder
+	.set	nomacro
+	bne	$2,$0,$L91
 	move	$4,$18
+	.set	macro
+	.set	reorder
+
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_skb_shared
+	move	$4,$18
+	.set	macro
+	.set	reorder
+
+	beq	$2,$0,$L74
+	move	$4,$18
+$L91:
 	.set	noreorder
 	.set	nomacro
 	jal	skb_realloc_headroom
@@ -841,7 +1022,7 @@ $L92:
 
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L71
+	beq	$2,$0,$L63
 	move	$4,$0
 	.set	macro
 	.set	reorder
@@ -850,12 +1031,12 @@ $L92:
 	.set	noreorder
 	.set	nomacro
 	jal	consume_skb
-	move	$17,$2
+	move	$18,$2
 	.set	macro
 	.set	reorder
 
-$L91:
-	move	$4,$17
+$L74:
+	move	$4,$18
 	.set	noreorder
 	.set	nomacro
 	jal	skb_push
@@ -876,11 +1057,12 @@ $L91:
 
 	lui	$5,%hi(pptpAccInfo+12)
 	addiu	$5,$5,%lo(pptpAccInfo+12)
+	li	$6,6			# 0x6
 	addiu	$4,$16,6
 	.set	noreorder
 	.set	nomacro
 	jal	memcpy
-	li	$6,6			# 0x6
+	addiu	$17,$20,%lo(pptpAccInfo)
 	.set	macro
 	.set	reorder
 
@@ -890,38 +1072,46 @@ $L91:
 	sb	$0,13($16)
 	ori	$2,$2,0xffff
 	lw	$3,16($sp)
-	addiu	$6,$19,%lo(pptpAccInfo)
-	lw	$5,32($6)
-	addiu	$10,$sp,16
+	move	$5,$0
+	lw	$7,32($17)
+	move	$4,$18
 	and	$3,$3,$2
 	li	$2,1073741824			# 0x40000000
 	or	$3,$3,$2
 	li	$2,-251723776			# 0xf0ff0000
 	ori	$2,$2,0xffff
-	addiu	$8,$sp,32
+	addiu	$19,$sp,16
 	and	$3,$3,$2
 	li	$2,83886080			# 0x5000000
 	or	$3,$3,$2
 	li	$2,16384
-	lw	$4,20($6)
+	lw	$6,20($17)
 	sh	$2,22($sp)
 	li	$2,47
 	sb	$2,25($sp)
 	li	$2,64
 	sw	$3,16($sp)
+	sw	$7,32($sp)
+	sw	$6,28($sp)
 	sb	$2,24($sp)
-	li	$2,-805371904			# 0xcfff0000
-	sb	$20,17($sp)
-	ori	$2,$2,0xffff
-	sw	$4,28($sp)
-	sw	$5,32($sp)
-	lw	$3,104($17)
-	lw	$4,84($17)
-	and	$3,$3,$2
-	sw	$3,104($17)
-	addiu	$4,$4,-14
-	lhu	$5,44($6)
-	sh	$4,18($sp)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_set_skb_ip_summed
+	sb	$21,17($sp)
+	.set	macro
+	.set	reorder
+
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_len
+	move	$4,$18
+	.set	macro
+	.set	reorder
+
+	addiu	$7,$sp,32
+	lhu	$5,44($17)
+	addiu	$2,$2,-14
+	sh	$2,18($sp)
 	addiu	$5,$5,1
 	lw	$3,16($sp)
 	sh	$5,20($sp)
@@ -929,101 +1119,138 @@ $L91:
 	srl	$2,$3,22
 	sh	$0,26($sp)
 	andi	$2,$2,0x3c
-	addu	$7,$3,$4
-	addu	$9,$10,$2
-	sltu	$4,$7,$4
+	addu	$6,$3,$4
+	addu	$8,$19,$2
+	sltu	$4,$6,$4
 	lw	$2,24($sp)
-	addu	$7,$7,$4
+	addu	$6,$6,$4
 	lw	$3,28($sp)
-	addu	$7,$7,$2
-	sltu	$4,$7,$2
-	addu	$7,$7,$4
-	addu	$7,$7,$3
-	sltu	$4,$7,$3
-	sh	$5,44($6)
-	addu	$7,$7,$4
-$L100:
-	lw	$2,0($8)
-	addiu	$8,$8,4
-	addu	$7,$7,$2
-	sltu	$4,$7,$2
+	addu	$6,$6,$2
+	sltu	$4,$6,$2
+	addu	$6,$6,$4
+	addu	$6,$6,$3
+	sltu	$4,$6,$3
+	sh	$5,44($17)
+	addu	$6,$6,$4
+$L78:
+	lw	$2,0($7)
+	addiu	$7,$7,4
+	addu	$6,$6,$2
+	sltu	$4,$6,$2
 	.set	noreorder
 	.set	nomacro
-	bne	$8,$9,$L100
-	addu	$7,$7,$4
+	bne	$7,$8,$L78
+	addu	$6,$6,$4
 	.set	macro
 	.set	reorder
 
-	lhu	$2,4($10)
-	addiu	$16,$19,%lo(pptpAccInfo)
+	lhu	$2,4($19)
+	addiu	$16,$20,%lo(pptpAccInfo)
+	move	$4,$18
+	sh	$2,46($16)
 #APP
 		.set	push		# csum_fold
 	.set	noat		
-	sll	$1, $7, 16	
-	addu	$7, $1		
-	sltu	$1, $7, $1	
-	srl	$7, $7, 16	
-	addu	$7, $1		
-	xori	$7, 0xffff	
+	sll	$1, $6, 16	
+	addu	$6, $1		
+	sltu	$1, $6, $1	
+	srl	$6, $6, 16	
+	addu	$6, $1		
+	xori	$6, 0xffff	
 	.set	pop
 #NO_APP
-	sh	$2,46($16)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_data
+	sh	$6,10($19)
+	.set	macro
+	.set	reorder
+
 	addiu	$5,$sp,16
-	sh	$7,10($10)
 	li	$6,20			# 0x14
-	lw	$4,176($17)
 	.set	noreorder
 	.set	nomacro
 	jal	memcpy
-	addiu	$4,$4,14
+	addiu	$4,$2,14
 	.set	macro
 	.set	reorder
 
 	li	$2,48
 	sb	$2,40($sp)
 	li	$2,-127
+	move	$4,$18
 	sb	$2,41($sp)
 	li	$2,-30709
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_len
 	sh	$2,42($sp)
-	addiu	$5,$sp,40
-	lw	$2,36($16)
+	.set	macro
+	.set	reorder
+
+	move	$4,$18
+	lw	$3,36($16)
+	addiu	$2,$2,-50
+	lhu	$5,18($16)
+	lw	$7,40($16)
+	move	$6,$3
+	addiu	$3,$3,1
+	sh	$5,46($sp)
+	sh	$2,44($sp)
+	sw	$3,36($16)
+	sw	$7,52($sp)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_data
+	sw	$6,48($sp)
+	.set	macro
+	.set	reorder
+
 	li	$6,16			# 0x10
-	lw	$3,84($17)
-	lhu	$7,18($16)
-	move	$4,$2
-	lw	$8,40($16)
-	addiu	$3,$3,-50
-	addiu	$2,$2,1
-	sh	$3,44($sp)
-	sh	$7,46($sp)
-	sw	$2,36($16)
-	sw	$8,52($sp)
-	sw	$4,48($sp)
-	lw	$4,176($17)
+	addiu	$5,$sp,40
 	.set	noreorder
 	.set	nomacro
 	jal	memcpy
-	addiu	$4,$4,34
+	addiu	$4,$2,34
 	.set	macro
 	.set	reorder
 
 	lui	$2,%hi(jiffies)
-	lw	$3,%lo(jiffies)($2)
-	move	$4,$17
-	lw	$2,8($16)
-	sw	$3,%lo(pptpAccInfo)($19)
+	lw	$2,%lo(jiffies)($2)
+	move	$4,$18
+	lw	$5,8($16)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_set_skb_dev
+	sw	$2,%lo(pptpAccInfo)($20)
+	.set	macro
+	.set	reorder
+
 	.set	noreorder
 	.set	nomacro
 	jal	dev_queue_xmit
-	sw	$2,24($17)
+	move	$4,$18
 	.set	macro
 	.set	reorder
 
+	.set	noreorder
+	.set	nomacro
+	j	$L63
 	li	$4,1			# 0x1
-$L82:
-$L71:
-	lw	$31,76($sp)
+	.set	macro
+	.set	reorder
+
+$L68:
+$L90:
+	lw	$4,56($2)
+	beq	$4,$0,$L83
+	jal	rtl_get_ppp_dev_priv
+$L83:
+	move	$4,$0
+$L63:
+	lw	$31,80($sp)
 	move	$2,$4
+	lw	$21,76($sp)
 	lw	$20,72($sp)
 	lw	$19,68($sp)
 	lw	$18,64($sp)
@@ -1032,7 +1259,7 @@ $L71:
 	.set	noreorder
 	.set	nomacro
 	j	$31
-	addiu	$sp,$sp,80
+	addiu	$sp,$sp,88
 	.set	macro
 	.set	reorder
 
@@ -1044,28 +1271,33 @@ $L71:
 	.type	fast_pptp_sync_rx_seq, @function
 fast_pptp_sync_rx_seq:
 	.set	nomips16
-	.frame	$sp,0,$31		# vars= 0, regs= 0/0, args= 0, gp= 0
-	.mask	0x00000000,0
+	.frame	$sp,24,$31		# vars= 0, regs= 1/0, args= 16, gp= 0
+	.mask	0x80000000,-8
 	.fmask	0x00000000,0
 	.set	noreorder
 	.set	nomacro
 	
-	lw	$5,156($4)
+	addiu	$sp,$sp,-24
+	sw	$31,16($sp)
+	jal	rtl_ip_hdr
+	nop
+
 	li	$3,1			# 0x1
-	addiu	$4,$5,20
+	addiu	$4,$2,20
+	move	$5,$2
 	lbu	$2,1($4)
 	andi	$2,$2,0x7
-	bne	$2,$3,$L119
+	bne	$2,$3,$L92
 	li	$2,34827			# 0x880b
 
 	lhu	$3,2($4)
-	bne	$3,$2,$L119
+	bne	$3,$2,$L92
 	lui	$2,%hi(pptpAccInfo)
 
 	addiu	$6,$2,%lo(pptpAccInfo)
 	lbu	$2,20($5)
 	andi	$2,$2,0x10
-	beq	$2,$0,$L117
+	beq	$2,$0,$L94
 	nop
 
 	lw	$2,52($6)
@@ -1073,16 +1305,17 @@ fast_pptp_sync_rx_seq:
 	addiu	$2,$2,1
 	sw	$2,52($6)
 	sw	$3,8($4)
-$L117:
+$L94:
 	lb	$2,1($4)
-	bgez	$2,$L119
+	bgez	$2,$L92
 	lui	$2,%hi(pptpAccInfo+48)
 
 	lw	$2,%lo(pptpAccInfo+48)($2)
 	sw	$2,12($4)
-$L119:
+$L92:
+	lw	$31,16($sp)
 	j	$31
-	nop
+	addiu	$sp,$sp,24
 
 	.set	macro
 	.set	reorder
@@ -1094,53 +1327,72 @@ $L119:
 	.type	sync_tx_pptp_gre_seqno, @function
 sync_tx_pptp_gre_seqno:
 	.set	nomips16
-	.frame	$sp,8,$31		# vars= 8, regs= 0/0, args= 0, gp= 0
-	.mask	0x00000000,0
+	.frame	$sp,48,$31		# vars= 8, regs= 5/0, args= 16, gp= 0
+	.mask	0x800f0000,-8
 	.fmask	0x00000000,0
+	addiu	$sp,$sp,-48
+	sw	$18,32($sp)
+	move	$18,$4
+	sw	$17,28($sp)
+	sw	$16,24($sp)
+	sw	$31,40($sp)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_data
+	sw	$19,36($sp)
+	.set	macro
+	.set	reorder
+
+	move	$17,$2
 	lui	$2,%hi(fast_pptp_fw)
-	addiu	$sp,$sp,-8
-	lw	$5,176($4)
 	lw	$2,%lo(fast_pptp_fw)($2)
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L120
-	addiu	$7,$5,14
+	beq	$2,$0,$L96
+	addiu	$16,$17,14
 	.set	macro
 	.set	reorder
 
 #APP
-	raw_local_irq_save	$9
+	raw_local_irq_save	$19
 #NO_APP
-	lbu	$3,9($7)
+	lbu	$3,9($16)
 	li	$2,47			# 0x2f
-	bne	$3,$2,$L123
-	lw	$2,84($4)
+	bne	$3,$2,$L99
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_len
+	move	$4,$18
+	.set	macro
+	.set	reorder
+
 	sltu	$2,$2,35
+	bne	$2,$0,$L99
+	move	$4,$18
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L123
-	move	$12,$0
+	jal	rtl_get_skb_data
+	move	$18,$0
 	.set	macro
 	.set	reorder
 
-	lbu	$2,14($5)
-	lw	$3,176($4)
-	move	$10,$sp
-	andi	$2,$2,0xf
+	addiu	$8,$sp,16
+	lbu	$3,14($17)
 	move	$5,$0
-	sll	$2,$2,2
-	addu	$3,$3,$2
-	addiu	$8,$3,16
-	addiu	$6,$3,14
-$L127:
-	addu	$2,$8,$5
-	addu	$4,$10,$5
+	andi	$3,$3,0xf
+	sll	$3,$3,2
+	addu	$2,$2,$3
+	addiu	$7,$2,16
+	addiu	$6,$2,14
+$L103:
+	addu	$2,$7,$5
+	addu	$4,$8,$5
 	lbu	$3,0($2)
 	addiu	$5,$5,1
 	slt	$2,$5,2
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L127
+	bne	$2,$0,$L103
 	sb	$3,0($4)
 	.set	macro
 	.set	reorder
@@ -1150,85 +1402,85 @@ $L127:
 	andi	$2,$2,0x7
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$3,$L123
+	bne	$2,$3,$L99
 	li	$2,34827			# 0x880b
 	.set	macro
 	.set	reorder
 
-	lhu	$3,0($sp)
-	bne	$3,$2,$L123
+	lhu	$3,16($sp)
+	bne	$3,$2,$L99
 	lbu	$2,0($6)
 	andi	$2,$2,0x10
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L130
-	lui	$10,%hi(pptpAccInfo)
+	beq	$2,$0,$L106
+	lui	$8,%hi(pptpAccInfo)
 	.set	macro
 	.set	reorder
 
-	addiu	$4,$10,%lo(pptpAccInfo)
-	lhu	$3,4($7)
+	addiu	$4,$8,%lo(pptpAccInfo)
+	lhu	$3,4($16)
 	lhu	$2,46($4)
-	beq	$3,$2,$L131
+	beq	$3,$2,$L107
 	lhu	$3,6($6)
 	lhu	$2,18($4)
-	bne	$3,$2,$L131
+	bne	$3,$2,$L107
 	lw	$3,32($4)
-	lw	$2,16($7)
+	lw	$2,16($16)
 	.set	noreorder
 	.set	nomacro
-	bne	$3,$2,$L131
+	bne	$3,$2,$L107
 	lui	$2,%hi(pptpAccInfo+48)
 	.set	macro
 	.set	reorder
 
 	lw	$3,8($6)
-	addiu	$8,$2,%lo(pptpAccInfo+48)
-	addiu	$11,$sp,4
-	sw	$3,4($sp)
+	addiu	$7,$2,%lo(pptpAccInfo+48)
+	addiu	$9,$sp,20
+	sw	$3,20($sp)
 	move	$5,$0
-$L138:
-	addu	$2,$11,$5
-	addu	$4,$8,$5
+$L114:
+	addu	$2,$9,$5
+	addu	$4,$7,$5
 	lbu	$3,0($2)
 	addiu	$5,$5,1
 	slt	$2,$5,4
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L138
+	bne	$2,$0,$L114
 	sb	$3,0($4)
 	.set	macro
 	.set	reorder
 
-	addiu	$2,$10,%lo(pptpAccInfo)
-	addiu	$8,$6,8
+	addiu	$2,$8,%lo(pptpAccInfo)
+	addiu	$7,$6,8
 	lw	$3,36($2)
 	move	$5,$0
 	move	$4,$3
 	addiu	$3,$3,1
 	sw	$3,36($2)
-	sw	$4,4($sp)
-$L143:
-	addu	$2,$11,$5
-	addu	$4,$8,$5
+	sw	$4,20($sp)
+$L119:
+	addu	$2,$9,$5
+	addu	$4,$7,$5
 	lbu	$3,0($2)
 	addiu	$5,$5,1
 	slt	$2,$5,4
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L143
+	bne	$2,$0,$L119
 	sb	$3,0($4)
 	.set	macro
 	.set	reorder
 
-	j	$L130
-$L131:
-	li	$12,1			# 0x1
-$L130:
+	j	$L106
+$L107:
+	li	$18,1			# 0x1
+$L106:
 	lb	$2,1($6)
 	.set	noreorder
 	.set	nomacro
-	bgez	$2,$L146
+	bgez	$2,$L122
 	lui	$2,%hi(pptpAccInfo)
 	.set	macro
 	.set	reorder
@@ -1236,72 +1488,72 @@ $L130:
 	addiu	$4,$2,%lo(pptpAccInfo)
 	lhu	$3,6($6)
 	lhu	$2,18($4)
-	bne	$3,$2,$L123
+	bne	$3,$2,$L99
 	lw	$3,32($4)
-	lw	$2,16($7)
+	lw	$2,16($16)
 	.set	noreorder
 	.set	nomacro
-	bne	$3,$2,$L123
+	bne	$3,$2,$L99
 	move	$5,$0
 	.set	macro
 	.set	reorder
 
 	lw	$2,40($4)
 	addiu	$6,$6,12
-	addiu	$8,$sp,4
-	sw	$2,4($sp)
-$L153:
-	addu	$2,$8,$5
+	addiu	$7,$sp,20
+	sw	$2,20($sp)
+$L129:
+	addu	$2,$7,$5
 	addu	$4,$6,$5
 	lbu	$3,0($2)
 	addiu	$5,$5,1
 	slt	$2,$5,4
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L153
+	bne	$2,$0,$L129
 	sb	$3,0($4)
 	.set	macro
 	.set	reorder
 
-$L146:
+$L122:
 	.set	noreorder
 	.set	nomacro
-	bne	$12,$0,$L123
+	bne	$18,$0,$L99
 	lui	$3,%hi(pptpAccInfo)
 	.set	macro
 	.set	reorder
 
-	addiu	$6,$7,16
+	addiu	$6,$16,16
 	addiu	$3,$3,%lo(pptpAccInfo)
 	lhu	$2,44($3)
 	addiu	$2,$2,1
 	sh	$2,44($3)
-	lw	$3,0($7)
-	sh	$2,4($7)
-	lw	$4,4($7)
+	lw	$3,0($16)
+	sh	$2,4($16)
+	lw	$4,4($16)
 	srl	$2,$3,22
 	andi	$2,$2,0x3c
 	addu	$5,$3,$4
-	addu	$8,$7,$2
-	sh	$0,10($7)
+	addu	$7,$16,$2
+	sh	$0,10($16)
 	sltu	$4,$5,$4
-	lw	$2,8($7)
+	lw	$2,8($16)
 	addu	$5,$5,$4
-	lw	$3,12($7)
+	lw	$3,12($16)
 	addu	$5,$5,$2
 	sltu	$4,$5,$2
 	addu	$5,$5,$4
 	addu	$5,$5,$3
 	sltu	$4,$5,$3
 	addu	$5,$5,$4
-$L156:
+$L132:
 	lw	$2,0($6)
 	addiu	$6,$6,4
 	addu	$5,$5,$2
 	sltu	$4,$5,$2
 	.set	noreorder
 	.set	nomacro
-	bne	$6,$8,$L156
+	bne	$6,$7,$L132
 	addu	$5,$5,$4
 	.set	macro
 	.set	reorder
@@ -1317,16 +1569,21 @@ $L156:
 	xori	$5, 0xffff	
 	.set	pop
 #NO_APP
-	sh	$5,10($7)
-$L123:
+	sh	$5,10($16)
+$L99:
 #APP
-	raw_local_irq_restore	$9
+	raw_local_irq_restore	$19
 #NO_APP
-$L120:
+$L96:
+	lw	$31,40($sp)
+	lw	$19,36($sp)
+	lw	$18,32($sp)
+	lw	$17,28($sp)
+	lw	$16,24($sp)
 	.set	noreorder
 	.set	nomacro
 	j	$31
-	addiu	$sp,$sp,8
+	addiu	$sp,$sp,48
 	.set	macro
 	.set	reorder
 
@@ -1371,13 +1628,13 @@ ppfw_read_proc:
 	subu	$4,$4,$17
 	slt	$3,$16,$4
 	movn	$4,$16,$3		#conditional move
-	bne	$2,$0,$L175
+	bne	$2,$0,$L151
 	slt	$5,$4,0
 
 	lw	$2,56($sp)
 	li	$3,1			# 0x1
 	sw	$3,0($2)
-$L175:
+$L151:
 	sw	$18,0($19)
 	move	$2,$0
 	lw	$31,32($sp)
@@ -1409,10 +1666,10 @@ atoi_dec:
 	addiu	$2,$5,-48
 	andi	$2,$2,0x00ff
 	sltu	$2,$2,10
-	beq	$2,$0,$L183
+	beq	$2,$0,$L159
 	move	$7,$0
 
-$L181:
+$L157:
 	addiu	$6,$6,1
 	sll	$2,$5,24
 	lbu	$5,0($6)
@@ -1424,10 +1681,10 @@ $L181:
 	andi	$4,$4,0x00ff
 	addu	$3,$3,$2
 	sltu	$4,$4,10
-	bne	$4,$0,$L181
+	bne	$4,$0,$L157
 	addiu	$7,$3,-48
 
-$L183:
+$L159:
 	j	$31
 	move	$2,$7
 
@@ -1470,13 +1727,13 @@ pptpconn_read_proc:
 	subu	$4,$4,$17
 	slt	$3,$16,$4
 	movn	$4,$16,$3		#conditional move
-	bne	$2,$0,$L185
+	bne	$2,$0,$L161
 	slt	$5,$4,0
 
 	lw	$2,56($sp)
 	li	$3,1			# 0x1
 	sw	$3,0($2)
-$L185:
+$L161:
 	sw	$18,0($19)
 	move	$2,$0
 	lw	$31,32($sp)
@@ -1506,7 +1763,7 @@ pptpconn_write_proc:
 	sw	$31,216($sp)
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L188
+	bne	$2,$0,$L164
 	move	$3,$6
 	.set	macro
 	.set	reorder
@@ -1516,7 +1773,7 @@ pptpconn_write_proc:
 	or	$2,$5,$2
 	.set	noreorder
 	.set	nomacro
-	beq	$5,$0,$L188
+	beq	$5,$0,$L164
 	or	$7,$2,$6
 	.set	macro
 	.set	reorder
@@ -1525,7 +1782,7 @@ pptpconn_write_proc:
 	and	$2,$2,$7
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L191
+	bne	$2,$0,$L167
 	move	$4,$13
 	.set	macro
 	.set	reorder
@@ -1539,10 +1796,10 @@ pptpconn_write_proc:
 	.set	reorder
 #NO_APP
 	move	$3,$6
-$L191:
+$L167:
 	.set	noreorder
 	.set	nomacro
-	bne	$3,$0,$L188
+	bne	$3,$0,$L164
 	move	$4,$13
 	.set	macro
 	.set	reorder
@@ -1550,7 +1807,7 @@ $L191:
 	jal	atoi_dec
 	lui	$3,%hi(pptp_conn_check)
 	sw	$2,%lo(pptp_conn_check)($3)
-$L188:
+$L164:
 	lw	$31,216($sp)
 	li	$2,-14			# 0xfffffff2
 	.set	noreorder
@@ -1581,13 +1838,13 @@ ppfw_write_proc:
 	move	$16,$5
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L198
+	bne	$2,$0,$L174
 	sw	$17,28($sp)
 	.set	macro
 	.set	reorder
 
-$L204:
-$L245:
+$L180:
+$L221:
 	addiu	$4,$6,32
 	.set	noreorder
 	.set	nomacro
@@ -1599,14 +1856,14 @@ $L245:
 	li	$3,-14			# 0xfffffff2
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L198
+	beq	$2,$0,$L174
 	move	$17,$2
 	.set	macro
 	.set	reorder
 
 	.set	noreorder
 	.set	nomacro
-	beq	$16,$0,$L249
+	beq	$16,$0,$L225
 	addu	$3,$16,$18
 	.set	macro
 	.set	reorder
@@ -1617,7 +1874,7 @@ $L245:
 	and	$2,$2,$3
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L250
+	bne	$2,$0,$L226
 	move	$6,$18
 	.set	macro
 	.set	reorder
@@ -1632,10 +1889,10 @@ $L245:
 	.set	at
 	.set	reorder
 #NO_APP
-$L250:
+$L226:
 	.set	noreorder
 	.set	nomacro
-	bne	$6,$0,$L249
+	bne	$6,$0,$L225
 	move	$4,$17
 	.set	macro
 	.set	reorder
@@ -1661,7 +1918,7 @@ $L250:
 	lw	$2,%lo(fast_pptp_fw)($16)
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L257
+	beq	$2,$0,$L233
 	lui	$3,%hi(sync_tx_pptp_gre_seqno_hook)
 	.set	macro
 	.set	reorder
@@ -1670,14 +1927,14 @@ $L250:
 	addiu	$2,$2,%lo(sync_tx_pptp_gre_seqno)
 	.set	noreorder
 	.set	nomacro
-	j	$L258
+	j	$L234
 	sw	$2,%lo(sync_tx_pptp_gre_seqno_hook)($3)
 	.set	macro
 	.set	reorder
 
-$L257:
+$L233:
 	sw	$0,%lo(sync_tx_pptp_gre_seqno_hook)($3)
-$L258:
+$L234:
 	.set	noreorder
 	.set	nomacro
 	jal	kfree
@@ -1687,12 +1944,12 @@ $L258:
 
 	.set	noreorder
 	.set	nomacro
-	j	$L198
+	j	$L174
 	move	$3,$18
 	.set	macro
 	.set	reorder
 
-$L249:
+$L225:
 	.set	noreorder
 	.set	nomacro
 	jal	kfree
@@ -1701,7 +1958,7 @@ $L249:
 	.set	reorder
 
 	li	$3,-14			# 0xfffffff2
-$L198:
+$L174:
 	lw	$31,36($sp)
 	move	$2,$3
 	lw	$18,32($sp)
@@ -1749,7 +2006,7 @@ fast_pptp_init:
 	addiu	$4,$4,%lo($LC9)
 	move	$5,$0
 	move	$6,$0
-	beq	$2,$0,$L260
+	beq	$2,$0,$L236
 	sw	$2,%lo(res1)($7)
 
 	lui	$2,%hi(ppfw_read_proc)
@@ -1759,7 +2016,7 @@ fast_pptp_init:
 	lw	$3,%lo(res1)($7)
 	addiu	$2,$2,%lo(ppfw_write_proc)
 	sw	$2,68($3)
-$L260:
+$L236:
 	jal	create_proc_entry
 	nop
 
@@ -1769,7 +2026,7 @@ $L260:
 	addiu	$4,$4,%lo(pptpAccInfo)
 	move	$5,$0
 	li	$6,64			# 0x40
-	beq	$2,$0,$L261
+	beq	$2,$0,$L237
 	sw	$2,%lo(res_check_pptp)($7)
 
 	lui	$2,%hi(pptpconn_read_proc)
@@ -1779,7 +2036,7 @@ $L260:
 	lw	$3,%lo(res_check_pptp)($7)
 	addiu	$2,$2,%lo(pptpconn_write_proc)
 	sw	$2,68($3)
-$L261:
+$L237:
 	jal	memset
 	nop
 
@@ -1813,25 +2070,25 @@ fast_pptp_exit:
 	sw	$17,20($sp)
 	lui	$17,%hi(res_check_pptp)
 	sw	$31,24($sp)
-	beq	$2,$0,$L263
+	beq	$2,$0,$L239
 	move	$5,$2
 
 	jal	remove_proc_entry
 	nop
 
 	sw	$0,%lo(res1)($16)
-$L263:
+$L239:
 	lw	$2,%lo(res_check_pptp)($17)
 	lui	$4,%hi($LC9)
 	addiu	$4,$4,%lo($LC9)
-	beq	$2,$0,$L262
+	beq	$2,$0,$L238
 	move	$5,$2
 
 	jal	remove_proc_entry
 	nop
 
 	sw	$0,%lo(res_check_pptp)($17)
-$L262:
+$L238:
 	lw	$31,24($sp)
 	lw	$17,20($sp)
 	lw	$16,16($sp)
diff --git a/net/rtl/fastpath/98/fastpath_core.S b/net/rtl/fastpath/98/fastpath_core.S
index 78e0f01..d9edad4 100644
--- a/net/rtl/fastpath/98/fastpath_core.S
+++ b/net/rtl/fastpath/98/fastpath_core.S
@@ -68,94 +68,6 @@
 	.endm							
 
 #NO_APP
-	.section	.text.arp_req_get_ha,"ax",@progbits
-	.align	2
-	.globl	arp_req_get_ha
-	.ent	arp_req_get_ha
-	.type	arp_req_get_ha, @function
-arp_req_get_ha:
-	.set	nomips16
-	.frame	$sp,48,$31		# vars= 8, regs= 5/0, args= 16, gp= 0
-	.mask	0x800f0000,-8
-	.fmask	0x00000000,0
-	addiu	$sp,$sp,-48
-	sw	$18,32($sp)
-	move	$18,$5
-	sw	$4,16($sp)
-	lui	$4,%hi(arp_tbl)
-	sw	$19,36($sp)
-	addiu	$4,$4,%lo(arp_tbl)
-	move	$19,$6
-	addiu	$5,$sp,16
-	move	$6,$18
-	sw	$17,28($sp)
-	sw	$16,24($sp)
-	sw	$31,40($sp)
-	.set	noreorder
-	.set	nomacro
-	jal	neigh_lookup
-	li	$17,-6			# 0xfffffffa
-	.set	macro
-	.set	reorder
-
-	.set	noreorder
-	.set	nomacro
-	beq	$2,$0,$L2
-	move	$16,$2
-	.set	macro
-	.set	reorder
-
-	jal	local_bh_disable
-	move	$4,$19
-	lbu	$6,256($18)
-	.set	noreorder
-	.set	nomacro
-	jal	memcpy
-	addiu	$5,$16,36
-	.set	macro
-	.set	reorder
-
-	jal	local_bh_enable
-#APP
-	   
-
-	1:	ll	$3, 72($16)		# atomic_sub_return	
-       nop                                             
-	subu	$2, $3, 1				
-	sc	$2, 72($16)					
-	beqz	$2, 2f					
-	subu	$2, $3, 1				
-	.subsection 2					
-2:	b	1b					
-	.previous					
-
-	   
-
-#NO_APP
-	move	$17,$0
-	.set	noreorder
-	.set	nomacro
-	bne	$2,$0,$L2
-	move	$4,$16
-	.set	macro
-	.set	reorder
-
-	jal	neigh_destroy
-$L2:
-	move	$2,$17
-	lw	$31,40($sp)
-	lw	$19,36($sp)
-	lw	$18,32($sp)
-	lw	$17,28($sp)
-	lw	$16,24($sp)
-	.set	noreorder
-	.set	nomacro
-	j	$31
-	addiu	$sp,$sp,48
-	.set	macro
-	.set	reorder
-
-	.end	arp_req_get_ha
 	.section	.text.cache_timeout,"ax",@progbits
 	.align	2
 	.ent	cache_timeout
@@ -169,7 +81,7 @@ cache_timeout:
 	.set	nomacro
 	
 	lbu	$2,0($4)
-	beq	$2,$0,$L19
+	beq	$2,$0,$L9
 	move	$7,$4
 
 	lw	$2,8($4)
@@ -192,19 +104,19 @@ cache_timeout:
 	addu	$2,$2,$4
 	sb	$0,0($7)
 	lw	$3,44($7)
-	beq	$6,$0,$L15
+	beq	$6,$0,$L5
 	sll	$5,$2,2
 
-	j	$L16
+	j	$L6
 	sw	$3,44($6)
 
-$L15:
+$L5:
 	lui	$2,%hi(udp_cache_table)
 	lw	$2,%lo(udp_cache_table)($2)
 	lw	$2,0($2)
 	addu	$2,$5,$2
 	sw	$3,4($2)
-$L16:
+$L6:
 	lw	$2,40($7)
 	sll	$3,$4,1
 	lw	$5,44($7)
@@ -230,7 +142,7 @@ $L16:
 	sw	$6,4($4)
 	addiu	$2,$2,1
 	sw	$2,8($4)
-$L19:
+$L9:
 	j	$31
 	nop
 
@@ -250,8 +162,8 @@ udp_fragCache_init:
 	.set	noreorder
 	.set	nomacro
 	
-$L25:
-$L66:
+$L15:
+$L56:
 	addiu	$sp,$sp,-56
 	lui	$2,%hi(malloc_sizes+4)
 	sw	$19,44($sp)
@@ -269,11 +181,11 @@ $L66:
 
 	move	$3,$0
 	move	$17,$2
-	beq	$2,$0,$L20
+	beq	$2,$0,$L10
 	sw	$2,%lo(udp_cache_table)($16)
 
-$L75:
-$L116:
+$L65:
+$L106:
 	lui	$20,%hi(udp_cache_list_free)
 	sll	$4,$19,1
 	addiu	$3,$20,%lo(udp_cache_list_free)
@@ -290,22 +202,22 @@ $L116:
 	sw	$2,0($17)
 	lw	$2,%lo(udp_cache_table)($16)
 	lw	$2,0($2)
-	beq	$2,$0,$L20
+	beq	$2,$0,$L10
 	li	$3,-1			# 0xffffffff
 
-	j	$L119
+	j	$L109
 	slt	$5,$0,$19
 
-$L183:
-	j	$L20
+$L173:
+	j	$L10
 	move	$3,$0
 
-$L119:
-	beq	$5,$0,$L182
+$L109:
+	beq	$5,$0,$L172
 	move	$17,$0
 
 	move	$4,$0
-$L124:
+$L114:
 	lw	$2,%lo(udp_cache_table)($18)
 	addiu	$17,$17,1
 	slt	$3,$17,$19
@@ -320,16 +232,16 @@ $L124:
 	lw	$2,0($2)
 	addu	$2,$4,$2
 	addiu	$4,$4,12
-	bne	$3,$0,$L124
+	bne	$3,$0,$L114
 	sw	$2,4($2)
 
 	move	$17,$0
-$L184:
-	beq	$5,$0,$L182
+$L174:
+	beq	$5,$0,$L172
 	lui	$2,%hi(malloc_sizes+12)
 
-$L132:
-$L173:
+$L122:
+$L163:
 	li	$5,32			# 0x20
 	lw	$4,%lo(malloc_sizes+12)($2)
 	jal	kmem_cache_alloc
@@ -338,7 +250,7 @@ $L173:
 	move	$5,$0
 	move	$16,$2
 	addiu	$4,$2,16
-	beq	$2,$0,$L183
+	beq	$2,$0,$L173
 	move	$6,$0
 
 	jal	init_timer_key
@@ -359,12 +271,12 @@ $L173:
 	lw	$2,8($3)
 	sw	$4,4($3)
 	addiu	$2,$2,1
-	j	$L184
+	j	$L174
 	sw	$2,8($3)
 
-$L182:
+$L172:
 	li	$3,1			# 0x1
-$L20:
+$L10:
 	lw	$31,52($sp)
 	move	$2,$3
 	lw	$20,48($sp)
@@ -579,27 +491,27 @@ FastPath_Route:
 	move	$8,$0
 	lw	$3,%lo(route_list_inuse)($2)
 	move	$7,$0
-$L202:
-	beq	$3,$0,$L201
+$L192:
+	beq	$3,$0,$L191
 	nop
 
 	lw	$5,8($3)
 	sltu	$2,$5,$7
-	bne	$2,$0,$L197
+	bne	$2,$0,$L187
 	and	$6,$4,$5
 
 	lw	$2,4($3)
-	bne	$6,$2,$L197
+	bne	$6,$2,$L187
 	nop
 
 	move	$7,$5
 	addiu	$8,$3,16
-$L197:
+$L187:
 	lw	$3,44($3)
-	j	$L202
+	j	$L192
 	nop
 
-$L201:
+$L191:
 	j	$31
 	move	$2,$8
 
@@ -617,50 +529,67 @@ rtk_addNaptConnection:
 	.mask	0xc0ff0000,-4
 	.fmask	0x00000000,0
 	addiu	$sp,$sp,-152
-	li	$2,-1			# 0xffffffff
-	sw	$23,140($sp)
-	move	$23,$7
+	li	$3,-1			# 0xffffffff
+	sw	$fp,144($sp)
+	move	$fp,$7
+	sw	$19,124($sp)
+	move	$19,$5
 	sw	$18,120($sp)
-	move	$18,$5
-	sw	$17,116($sp)
-	move	$17,$4
+	move	$18,$4
 	sw	$31,148($sp)
-	sw	$fp,144($sp)
+	sw	$23,140($sp)
 	sw	$22,136($sp)
 	sw	$21,132($sp)
 	sw	$20,128($sp)
-	sw	$19,124($sp)
+	sw	$17,116($sp)
 	sw	$16,112($sp)
 	.set	noreorder
 	.set	nomacro
-	beq	$5,$0,$L203
+	beq	$5,$0,$L193
 	sw	$6,160($sp)
 	.set	macro
 	.set	reorder
 
-	lw	$3,0($4)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_eth_hdr
+	move	$4,$5
+	.set	macro
+	.set	reorder
+
+	.set	noreorder
+	.set	nomacro
+	beq	$2,$0,$L193
+	li	$3,-1			# 0xffffffff
+	.set	macro
+	.set	reorder
+
+	lw	$3,0($18)
 	li	$2,17			# 0x11
-	lw	$4,20($4)
+	lw	$4,20($18)
 	li	$5,6			# 0x6
 	xori	$3,$3,0x2
 	movn	$5,$2,$3		#conditional move  
 	.set	noreorder
 	.set	nomacro
 	jal	filter_addconnect
-	sw	$5,72($sp)
+	sw	$5,76($sp)
 	.set	macro
 	.set	reorder
 
-	lw	$22,0($17)
-	lw	$21,4($17)
-	lw	$20,8($17)
-	andi	$2,$22,0xffff
-	lw	$19,20($17)
+#APP
+	raw_local_irq_save	$22
+#NO_APP
+	lw	$23,0($18)
+	lw	$21,4($18)
+	lw	$20,8($18)
+	andi	$2,$23,0xffff
+	lw	$17,20($18)
 	move	$4,$21
-	lw	$16,24($17)
+	lw	$16,24($18)
 	move	$5,$20
 	sw	$2,16($sp)
-	move	$6,$19
+	move	$6,$17
 	.set	noreorder
 	.set	nomacro
 	jal	FastPath_Hash_NAPT_Entry
@@ -671,88 +600,118 @@ rtk_addNaptConnection:
 	lui	$9,%hi(table_napt)
 	lw	$3,%lo(table_napt)($9)
 	sll	$7,$2,1
-	move	$fp,$2
+	sw	$2,72($sp)
 	addu	$2,$7,$2
 	lw	$3,0($3)
 	sll	$2,$2,2
 	addu	$2,$2,$3
 	lw	$4,0($2)
-$L333:
-	beq	$4,$0,$L331
+$L287:
+	.set	noreorder
+	.set	nomacro
+	beq	$4,$0,$L286
+	lui	$5,%hi(napt_list_free)
+	.set	macro
+	.set	reorder
+
 	lw	$2,4($4)
-	bne	$2,$22,$L209
+	bne	$2,$23,$L201
 	lw	$2,8($4)
-	bne	$2,$21,$L209
+	bne	$2,$21,$L201
 	lw	$2,12($4)
-	bne	$2,$20,$L209
+	bne	$2,$20,$L201
 	lw	$3,16($4)
-	lw	$2,12($17)
-	bne	$3,$2,$L209
+	lw	$2,12($18)
+	bne	$3,$2,$L201
 	lw	$3,20($4)
-	lw	$2,16($17)
-	bne	$3,$2,$L209
+	lw	$2,16($18)
+	bne	$3,$2,$L201
 	lw	$2,24($4)
-	bne	$2,$19,$L209
+	bne	$2,$17,$L201
 	lw	$2,28($4)
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$16,$L323
-	move	$2,$0
+	bne	$2,$16,$L201
+	li	$2,-1			# 0xffffffff
 	.set	macro
 	.set	reorder
 
-$L209:
-	lw	$4,36($4)
-	j	$L333
-$L331:
+	lw	$8,160($sp)
+	lb	$3,212($8)
+	.set	noreorder
+	.set	nomacro
+	bne	$3,$2,$L203
+	li	$2,6			# 0x6
+	.set	macro
+	.set	reorder
+
+	lw	$9,76($sp)
+	.set	noreorder
+	.set	nomacro
+	beq	$9,$2,$L204
+	li	$2,17			# 0x11
+	.set	macro
+	.set	reorder
+
+	bne	$9,$2,$L203
+$L204:
+	lw	$4,160($sp)
+	jal	__conntrack_drop_check
+	lw	$3,160($sp)
+	sb	$2,212($3)
+$L203:
 #APP
-	raw_local_irq_save	$2
+	raw_local_irq_restore	$22
 #NO_APP
-	lui	$5,%hi(napt_list_free)
-	lw	$8,%lo(napt_list_free)($5)
 	.set	noreorder
 	.set	nomacro
-	beq	$8,$0,$L213
-	sw	$2,76($sp)
+	j	$L193
+	move	$3,$0
 	.set	macro
 	.set	reorder
 
-	lw	$2,0($17)
+$L201:
+	lw	$4,36($4)
+	j	$L287
+$L286:
+	lw	$8,%lo(napt_list_free)($5)
+	beq	$8,$0,$L212
+	lw	$2,0($18)
 	lw	$4,44($8)
 	sw	$2,4($8)
-	lw	$2,4($17)
+	lw	$2,4($18)
 	lw	$3,48($8)
 	sw	$2,8($8)
-	lw	$2,8($17)
+	lw	$2,8($18)
 	sw	$2,12($8)
-	lw	$2,12($17)
+	lw	$2,12($18)
 	sw	$2,16($8)
-	lw	$2,16($17)
+	lw	$2,16($18)
 	sw	$2,20($8)
-	lw	$2,20($17)
+	lw	$2,20($18)
 	sw	$2,24($8)
-	lw	$2,24($17)
-	sw	$23,32($8)
+	lw	$2,24($18)
+	sw	$fp,32($8)
 	sw	$2,28($8)
 	li	$2,-1
 	.set	noreorder
 	.set	nomacro
-	beq	$4,$0,$L215
+	beq	$4,$0,$L214
 	sb	$2,0($8)
 	.set	macro
 	.set	reorder
 
 	.set	noreorder
 	.set	nomacro
-	j	$L216
+	j	$L215
 	sw	$3,48($4)
 	.set	macro
 	.set	reorder
 
-$L215:
+$L214:
 	addiu	$2,$5,%lo(napt_list_free)
 	sw	$3,4($2)
-$L216:
+$L215:
 	lw	$4,48($8)
 	addiu	$5,$5,%lo(napt_list_free)
 	lw	$2,44($8)
@@ -760,10 +719,11 @@ $L216:
 	addiu	$3,$3,%lo(napt_list_inuse)
 	addiu	$6,$8,44
 	sw	$2,0($4)
-	addu	$4,$7,$fp
+	lw	$2,72($sp)
+	addu	$4,$7,$2
+	addiu	$7,$8,36
 	lw	$2,8($5)
 	sll	$4,$4,2
-	addiu	$7,$8,36
 	addiu	$2,$2,-1
 	sw	$2,8($5)
 	sw	$0,44($8)
@@ -811,95 +771,135 @@ $L216:
 	.set	noreorder
 	.set	nomacro
 	jal	rtl865x_getWanDev
-	move	$19,$2
+	move	$20,$2
 	.set	macro
 	.set	reorder
 
-	addiu	$4,$sp,24
-	lw	$22,156($18)
-	move	$20,$2
-	lw	$5,160($18)
-	li	$6,6			# 0x6
-	lbu	$2,0($22)
-	lhu	$3,106($18)
-	addiu	$5,$5,6
+	move	$4,$19
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_protocol
+	move	$21,$2
+	.set	macro
+	.set	reorder
+
+	move	$4,$19
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_ip_hdr
+	sw	$2,100($sp)
+	.set	macro
+	.set	reorder
+
+	move	$4,$19
+	move	$fp,$2
+	lbu	$2,0($2)
 	andi	$2,$2,0xf
 	sll	$2,$2,2
-	addu	$23,$22,$2
+	addu	$2,$fp,$2
 	.set	noreorder
 	.set	nomacro
-	jal	memcpy
-	sw	$3,100($sp)
+	jal	rtl_eth_hdr
+	sw	$2,80($sp)
 	.set	macro
 	.set	reorder
 
-	addiu	$4,$sp,32
-	lw	$5,160($18)
+	li	$6,6			# 0x6
+	addiu	$5,$2,6
 	.set	noreorder
 	.set	nomacro
 	jal	memcpy
+	addiu	$4,$sp,24
+	.set	macro
+	.set	reorder
+
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_eth_hdr
+	move	$4,$19
+	.set	macro
+	.set	reorder
+
 	li	$6,6			# 0x6
+	move	$5,$2
+	.set	noreorder
+	.set	nomacro
+	jal	memcpy
+	addiu	$4,$sp,32
+	.set	macro
+	.set	reorder
+
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_mark
+	move	$4,$19
+	.set	macro
+	.set	reorder
+
+	move	$4,$19
+	sw	$2,104($sp)
+	lw	$3,12($fp)
+	lw	$5,80($sp)
+	sw	$3,84($sp)
+	lhu	$5,0($5)
+	lw	$9,80($sp)
+	sw	$5,92($sp)
+	lw	$8,16($fp)
+	sw	$8,88($sp)
+	lhu	$9,2($9)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_store_skb_dst
+	sw	$9,96($sp)
 	.set	macro
 	.set	reorder
 
-	lw	$4,12($22)
-	sw	$4,80($sp)
-	lhu	$5,0($23)
-	sw	$5,88($sp)
-	lw	$2,16($22)
-	sw	$2,84($sp)
-	lhu	$3,2($23)
-	sw	$3,92($sp)
-	lw	$4,28($18)
-	sw	$4,96($sp)
-	sw	$0,28($18)
-	lw	$5,4($17)
-	lw	$6,20($17)
-	lw	$4,8($17)
+	lui	$8,%hi(path_list_free)
+	lw	$5,4($18)
+	lw	$6,20($18)
+	lw	$4,8($18)
 	srl	$2,$5,8
 	srl	$3,$6,16
 	xor	$2,$2,$5
 	xor	$3,$3,$6
 	srl	$4,$4,4
-	lw	$5,24($17)
+	lw	$5,24($18)
 	xor	$2,$2,$3
 	xor	$2,$2,$4
 	lui	$4,%hi(path_table_list_max)
 	xor	$2,$2,$5
-	lw	$5,72($sp)
+	lw	$5,76($sp)
 	lw	$3,%lo(path_table_list_max)($4)
 	xor	$2,$2,$5
-	lui	$5,%hi(path_list_free)
 	srl	$4,$2,12
 	addiu	$3,$3,-1
 	xor	$2,$2,$4
-	and	$fp,$3,$2
-	lw	$16,%lo(path_list_free)($5)
-	lw	$2,144($18)
+	lw	$16,%lo(path_list_free)($8)
+	and	$3,$3,$2
 	.set	noreorder
 	.set	nomacro
-	beq	$16,$0,$L226
-	sw	$2,104($sp)
+	beq	$16,$0,$L219
+	sw	$3,72($sp)
 	.set	macro
 	.set	reorder
 
-	lw	$2,0($17)
+	lw	$2,0($18)
 	sw	$2,4($16)
-	lw	$2,4($17)
+	lw	$2,4($18)
 	sw	$2,16($16)
-	lw	$2,8($17)
+	lw	$2,8($18)
 	sw	$2,12($16)
-	lw	$2,20($17)
+	lw	$2,20($18)
 	sw	$2,20($16)
-	lw	$2,24($17)
+	lw	$2,24($18)
 	sw	$2,8($16)
-	lw	$2,12($17)
+	lw	$2,12($18)
 	sw	$2,24($16)
-	lw	$2,16($17)
+	lw	$2,16($18)
 	sw	$2,28($16)
-	lw	$4,20($17)
+	lw	$4,20($18)
 	sw	$4,32($16)
-	lw	$2,24($17)
+	lw	$2,24($18)
 	.set	noreorder
 	.set	nomacro
 	jal	FastPath_Route
@@ -916,303 +916,379 @@ $L216:
 	sb	$2,0($16)
 	.set	noreorder
 	.set	nomacro
-	beq	$4,$3,$L227
+	beq	$4,$3,$L220
 	sb	$0,1($16)
 	.set	macro
 	.set	reorder
 
 	li	$2,1			# 0x1
 	sb	$2,1($16)
-$L227:
+$L220:
 	lw	$3,12($16)
 	lw	$2,28($16)
-	beq	$3,$2,$L228
+	beq	$3,$2,$L221
 	lbu	$2,1($16)
 	ori	$2,$2,0x2
 	sb	$2,1($16)
-$L228:
+$L221:
 	sw	$0,48($16)
-	addiu	$21,$sp,40
+	addiu	$23,$sp,40
 	sw	$0,52($16)
-	move	$4,$21
-	lw	$2,4($17)
+	move	$4,$23
+	lw	$2,4($18)
 	move	$5,$0
 	li	$6,14			# 0xe
-	sw	$2,12($22)
-	lw	$2,8($17)
-	sh	$2,0($23)
-	lw	$2,20($17)
-	sw	$2,16($22)
-	lw	$2,24($17)
+	sw	$2,12($fp)
+	lw	$2,8($18)
+	lw	$9,80($sp)
+	sh	$2,0($9)
+	lw	$2,20($18)
+	sw	$2,16($fp)
+	lw	$2,24($18)
 	.set	noreorder
 	.set	nomacro
 	jal	memset
-	sh	$2,2($23)
+	sh	$2,2($9)
 	.set	macro
 	.set	reorder
 
+	move	$4,$19
 	.set	noreorder
 	.set	nomacro
-	beq	$19,$0,$L229
-	move	$5,$19
+	jal	rtl_set_skb_mark
+	move	$5,$0
 	.set	macro
 	.set	reorder
 
-	lw	$4,4($17)
 	.set	noreorder
 	.set	nomacro
-	jal	arp_req_get_ha
-	move	$6,$21
+	beq	$20,$0,$L292
+	move	$4,$19
 	.set	macro
 	.set	reorder
 
+	lw	$4,4($18)
+	move	$5,$20
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L229
-	addiu	$5,$sp,56
+	jal	rtl_arp_req_get_ha
+	move	$6,$23
 	.set	macro
 	.set	reorder
 
-	lw	$4,176($18)
-	li	$6,2			# 0x2
 	.set	noreorder
 	.set	nomacro
-	jal	memcmp
-	addiu	$4,$4,-2
+	bne	$2,$0,$L292
+	move	$4,$19
 	.set	macro
 	.set	reorder
 
-	bne	$2,$0,$L230
-	lw	$3,160($18)
-	beq	$3,$0,$L230
-	lbu	$2,12($3)
-	lbu	$3,13($3)
-	sll	$2,$2,8
-	or	$3,$3,$2
-	li	$2,2048			# 0x800
-	beq	$3,$2,$L230
-	lw	$2,176($18)
-	addiu	$2,$2,-22
-	sw	$2,160($18)
-$L230:
-	lw	$4,160($18)
-	move	$5,$21
-	li	$6,6			# 0x6
 	.set	noreorder
 	.set	nomacro
-	jal	memcpy
-	addiu	$4,$4,6
+	jal	rtl_ppp_proto_check
+	addiu	$5,$sp,56
 	.set	macro
 	.set	reorder
 
-	addiu	$5,$19,320
-	lw	$4,160($18)
+	move	$17,$2
+	li	$2,1			# 0x1
+	bne	$17,$2,$L223
 	.set	noreorder
 	.set	nomacro
-	jal	memcpy
-	li	$6,6			# 0x6
+	jal	rtl_skb_mac_header_was_set
+	move	$4,$19
 	.set	macro
 	.set	reorder
 
-$L229:
-	sw	$0,144($18)
-	li	$2,2048			# 0x800
-	lw	$3,100($sp)
+	bne	$2,$17,$L223
 	.set	noreorder
 	.set	nomacro
-	bne	$3,$2,$L239
-	lui	$2,%hi(nf_hooks+128)
+	jal	rtl_eth_hdr
+	move	$4,$19
 	.set	macro
 	.set	reorder
 
-	lw	$3,%lo(nf_hooks+128)($2)
-	addiu	$2,$2,%lo(nf_hooks+128)
+	lbu	$3,12($2)
+	lbu	$2,13($2)
+	sll	$3,$3,8
+	or	$2,$2,$3
+	li	$3,2048			# 0x800
 	.set	noreorder
 	.set	nomacro
-	beq	$3,$2,$L239
-	lui	$2,%hi(init_net+236)
+	beq	$2,$3,$L223
+	move	$4,$19
 	.set	macro
 	.set	reorder
 
-	move	$4,$18
-	lw	$2,%lo(init_net+236)($2)
-	move	$5,$0
-	move	$6,$19
-	move	$7,$20
 	.set	noreorder
 	.set	nomacro
-	jal	ipt_do_table
-	sw	$2,16($sp)
+	jal	rtl_skb_set_mac_header
+	li	$5,-22			# 0xffffffea
 	.set	macro
 	.set	reorder
 
-$L239:
-	lw	$2,144($18)
-	addiu	$21,$sp,40
-	move	$4,$21
-	move	$5,$0
-	sw	$2,48($16)
-	li	$6,14			# 0xe
-	lw	$2,12($17)
-	sw	$2,12($22)
-	lw	$2,16($17)
-	sh	$2,0($23)
-	lw	$2,20($17)
-	sw	$2,16($22)
-	lw	$2,24($17)
+$L223:
 	.set	noreorder
 	.set	nomacro
-	jal	memset
-	sh	$2,2($23)
+	jal	rtl_eth_hdr
+	move	$4,$19
 	.set	macro
 	.set	reorder
 
+	move	$5,$23
+	addiu	$4,$2,6
 	.set	noreorder
 	.set	nomacro
-	beq	$20,$0,$L244
-	move	$5,$20
+	jal	memcpy
+	li	$6,6			# 0x6
 	.set	macro
 	.set	reorder
 
-	lw	$4,20($17)
+	move	$4,$19
 	.set	noreorder
 	.set	nomacro
-	jal	arp_req_get_ha
-	move	$6,$21
+	jal	rtl_set_skb_dmac
+	move	$5,$20
 	.set	macro
 	.set	reorder
 
+	li	$2,2048			# 0x800
+	lw	$3,100($sp)
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L244
-	addiu	$5,$sp,56
+	bne	$3,$2,$L292
+	move	$4,$19
 	.set	macro
 	.set	reorder
 
-	lw	$4,176($18)
-	li	$6,2			# 0x2
+	lui	$2,%hi(nf_hooks+128)
+	lw	$3,%lo(nf_hooks+128)($2)
+	addiu	$2,$2,%lo(nf_hooks+128)
 	.set	noreorder
 	.set	nomacro
-	jal	memcmp
-	addiu	$4,$4,-2
+	beq	$3,$2,$L292
+	move	$6,$20
 	.set	macro
 	.set	reorder
 
-	bne	$2,$0,$L245
-	lw	$3,160($18)
-	beq	$3,$0,$L245
-	lbu	$2,12($3)
-	lbu	$3,13($3)
-	sll	$2,$2,8
-	or	$3,$3,$2
-	li	$2,2048			# 0x800
-	beq	$3,$2,$L245
-	lw	$2,176($18)
-	addiu	$2,$2,-22
-	sw	$2,160($18)
-$L245:
-	lw	$4,160($18)
-	move	$5,$21
+	move	$5,$0
 	.set	noreorder
 	.set	nomacro
-	jal	memcpy
-	li	$6,6			# 0x6
+	jal	rtl_ipt_do_table
+	move	$7,$21
 	.set	macro
 	.set	reorder
 
-	addiu	$5,$20,320
-	lw	$4,160($18)
-	li	$6,6			# 0x6
+	move	$4,$19
+$L292:
 	.set	noreorder
 	.set	nomacro
-	jal	memcpy
-	addiu	$4,$4,6
+	jal	rtl_get_skb_mark
+	addiu	$23,$sp,40
 	.set	macro
 	.set	reorder
 
-$L244:
-	sw	$0,144($18)
-	li	$2,2048			# 0x800
-	lw	$4,100($sp)
+	move	$4,$23
+	sw	$2,48($16)
+	move	$5,$0
+	lw	$2,12($18)
+	li	$6,14			# 0xe
+	sw	$2,12($fp)
+	lw	$2,16($18)
+	lw	$8,80($sp)
+	sh	$2,0($8)
+	lw	$2,20($18)
+	sw	$2,16($fp)
+	lw	$2,24($18)
 	.set	noreorder
 	.set	nomacro
-	bne	$4,$2,$L254
-	lui	$2,%hi(nf_hooks+160)
+	jal	memset
+	sh	$2,2($8)
 	.set	macro
 	.set	reorder
 
-	lw	$3,%lo(nf_hooks+160)($2)
-	addiu	$2,$2,%lo(nf_hooks+160)
+	move	$4,$19
 	.set	noreorder
 	.set	nomacro
-	beq	$3,$2,$L254
-	lui	$2,%hi(init_net+236)
+	jal	rtl_set_skb_mark
+	move	$5,$0
+	.set	macro
+	.set	reorder
+
+	.set	noreorder
+	.set	nomacro
+	beq	$21,$0,$L228
+	move	$5,$21
+	.set	macro
+	.set	reorder
+
+	lw	$4,20($18)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_arp_req_get_ha
+	move	$6,$23
+	.set	macro
+	.set	reorder
+
+	.set	noreorder
+	.set	nomacro
+	bne	$2,$0,$L228
+	move	$4,$19
+	.set	macro
+	.set	reorder
+
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_ppp_proto_check
+	addiu	$5,$sp,56
+	.set	macro
+	.set	reorder
+
+	move	$17,$2
+	li	$2,1			# 0x1
+	bne	$17,$2,$L229
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_skb_mac_header_was_set
+	move	$4,$19
+	.set	macro
+	.set	reorder
+
+	bne	$2,$17,$L229
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_eth_hdr
+	move	$4,$19
+	.set	macro
+	.set	reorder
+
+	lbu	$3,12($2)
+	lbu	$2,13($2)
+	sll	$3,$3,8
+	or	$2,$2,$3
+	li	$3,2048			# 0x800
+	.set	noreorder
+	.set	nomacro
+	beq	$2,$3,$L229
+	move	$4,$19
+	.set	macro
+	.set	reorder
+
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_skb_set_mac_header
+	li	$5,-22			# 0xffffffea
+	.set	macro
+	.set	reorder
+
+$L229:
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_eth_hdr
+	move	$4,$19
+	.set	macro
+	.set	reorder
+
+	move	$5,$23
+	move	$4,$2
+	.set	noreorder
+	.set	nomacro
+	jal	memcpy
+	li	$6,6			# 0x6
+	.set	macro
+	.set	reorder
+
+	move	$4,$19
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_set_skb_smac
+	move	$5,$21
+	.set	macro
+	.set	reorder
+
+	li	$2,2048			# 0x800
+	lw	$9,100($sp)
+	.set	noreorder
+	.set	nomacro
+	bne	$9,$2,$L228
+	lui	$2,%hi(nf_hooks+160)
+	.set	macro
+	.set	reorder
+
+	lw	$3,%lo(nf_hooks+160)($2)
+	addiu	$2,$2,%lo(nf_hooks+160)
+	.set	noreorder
+	.set	nomacro
+	beq	$3,$2,$L228
+	move	$4,$19
 	.set	macro
 	.set	reorder
 
-	move	$4,$18
-	lw	$2,%lo(init_net+236)($2)
 	li	$5,4			# 0x4
-	move	$6,$19
-	move	$7,$20
+	move	$6,$20
 	.set	noreorder
 	.set	nomacro
-	jal	ipt_do_table
-	sw	$2,16($sp)
+	jal	rtl_ipt_do_table
+	move	$7,$21
+	.set	macro
+	.set	reorder
+
+$L228:
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_mark
+	move	$4,$19
 	.set	macro
 	.set	reorder
 
-$L254:
-	lw	$2,144($18)
 	sw	$2,52($16)
 	li	$2,6			# 0x6
-	lw	$5,72($sp)
+	lw	$3,76($sp)
 	.set	noreorder
 	.set	nomacro
-	bne	$5,$2,$L259
+	bne	$3,$2,$L234
 	lui	$2,%hi(nf_ct_udp_timeout_stream)
 	.set	macro
 	.set	reorder
 
-	lw	$2,160($sp)
-	lbu	$4,176($2)
-	jal	tcp_get_timeouts_by_state
+	lw	$4,160($sp)
+	jal	rtl_tcp_get_timeouts
 	.set	noreorder
 	.set	nomacro
-	j	$L338
+	j	$L290
 	sw	$2,60($16)
 	.set	macro
 	.set	reorder
 
-$L259:
+$L234:
 	lw	$2,%lo(nf_ct_udp_timeout_stream)($2)
 	sw	$2,60($16)
-$L338:
+$L290:
 	lui	$2,%hi(jiffies)
-	lw	$3,160($sp)
-	lw	$4,76($16)
-	sw	$3,56($16)
-	lw	$2,%lo(jiffies)($2)
+	lw	$4,160($sp)
 	lw	$3,72($16)
+	sw	$4,56($16)
+	lw	$2,%lo(jiffies)($2)
+	lw	$4,76($16)
 	.set	noreorder
 	.set	nomacro
-	beq	$3,$0,$L262
+	beq	$3,$0,$L237
 	sw	$2,40($16)
 	.set	macro
 	.set	reorder
 
 	.set	noreorder
 	.set	nomacro
-	j	$L263
+	j	$L238
 	sw	$4,76($3)
 	.set	macro
 	.set	reorder
 
-$L262:
+$L237:
 	lui	$5,%hi(path_list_free)
 	addiu	$2,$5,%lo(path_list_free)
 	sw	$4,4($2)
-$L263:
+$L238:
 	lw	$3,76($16)
 	lui	$5,%hi(path_list_free)
 	lw	$2,72($16)
@@ -1223,14 +1299,16 @@ $L263:
 	lui	$3,%hi(path_list_inuse)
 	lw	$2,8($5)
 	addiu	$3,$3,%lo(path_list_inuse)
-	sll	$4,$fp,1
-	addiu	$8,$16,64
+	lw	$8,72($sp)
 	addiu	$2,$2,-1
-	addu	$4,$4,$fp
 	sw	$2,8($5)
-	sll	$4,$4,2
+	sll	$4,$8,1
+	lw	$9,72($sp)
+	addiu	$8,$16,64
 	sw	$0,72($16)
 	lw	$2,4($3)
+	addu	$4,$4,$9
+	sll	$4,$4,2
 	sw	$2,76($16)
 	lw	$2,4($3)
 	sw	$16,0($2)
@@ -1259,52 +1337,53 @@ $L263:
 	lw	$2,8($4)
 	addiu	$2,$2,1
 	sw	$2,8($4)
-$L226:
-	lw	$5,12($17)
-	lw	$6,20($17)
+$L219:
+	lw	$5,12($18)
+	lui	$8,%hi(path_list_free)
+	lw	$6,20($18)
+	lw	$4,24($18)
 	srl	$3,$5,16
-	lw	$4,24($17)
 	srl	$2,$6,8
 	xor	$3,$3,$5
 	xor	$2,$2,$6
 	srl	$4,$4,4
+	lw	$5,16($18)
 	xor	$2,$2,$3
-	lw	$5,16($17)
 	xor	$2,$2,$4
 	lui	$4,%hi(path_table_list_max)
 	xor	$2,$2,$5
-	lw	$5,72($sp)
+	lw	$5,76($sp)
 	lw	$3,%lo(path_table_list_max)($4)
 	xor	$2,$2,$5
-	lui	$5,%hi(path_list_free)
 	srl	$4,$2,12
 	addiu	$3,$3,-1
-	lw	$16,%lo(path_list_free)($5)
 	xor	$2,$2,$4
+	lw	$16,%lo(path_list_free)($8)
+	and	$3,$3,$2
 	.set	noreorder
 	.set	nomacro
-	beq	$16,$0,$L267
-	and	$fp,$3,$2
+	beq	$16,$0,$L242
+	sw	$3,72($sp)
 	.set	macro
 	.set	reorder
 
-	lw	$2,0($17)
+	lw	$2,0($18)
 	sw	$2,4($16)
-	lw	$2,20($17)
+	lw	$2,20($18)
 	sw	$2,16($16)
-	lw	$2,24($17)
+	lw	$2,24($18)
 	sw	$2,12($16)
-	lw	$2,12($17)
+	lw	$2,12($18)
 	sw	$2,20($16)
-	lw	$2,16($17)
+	lw	$2,16($18)
 	sw	$2,8($16)
-	lw	$2,20($17)
+	lw	$2,20($18)
 	sw	$2,24($16)
-	lw	$2,24($17)
+	lw	$2,24($18)
 	sw	$2,28($16)
-	lw	$4,4($17)
+	lw	$4,4($18)
 	sw	$4,32($16)
-	lw	$2,8($17)
+	lw	$2,8($18)
 	.set	noreorder
 	.set	nomacro
 	jal	FastPath_Route
@@ -1321,97 +1400,127 @@ $L226:
 	sb	$2,0($16)
 	.set	noreorder
 	.set	nomacro
-	beq	$4,$3,$L268
+	beq	$4,$3,$L243
 	sb	$0,1($16)
 	.set	macro
 	.set	reorder
 
 	li	$2,4			# 0x4
 	sb	$2,1($16)
-$L268:
+$L243:
 	lw	$3,8($16)
 	lw	$2,36($16)
-	beq	$3,$2,$L269
+	beq	$3,$2,$L244
 	lbu	$2,1($16)
 	ori	$2,$2,0x8
 	sb	$2,1($16)
-$L269:
+$L244:
 	sw	$0,48($16)
-	addiu	$21,$sp,40
+	addiu	$23,$sp,40
 	sw	$0,52($16)
-	move	$4,$21
-	lw	$2,20($17)
+	move	$4,$23
+	lw	$2,20($18)
 	move	$5,$0
 	li	$6,14			# 0xe
-	sw	$2,12($22)
-	lw	$2,24($17)
-	sh	$2,0($23)
-	lw	$2,12($17)
-	sw	$2,16($22)
-	lw	$2,16($17)
+	sw	$2,12($fp)
+	lw	$2,24($18)
+	lw	$9,80($sp)
+	sh	$2,0($9)
+	lw	$2,12($18)
+	sw	$2,16($fp)
+	lw	$2,16($18)
 	.set	noreorder
 	.set	nomacro
 	jal	memset
-	sh	$2,2($23)
+	sh	$2,2($9)
 	.set	macro
 	.set	reorder
 
+	move	$4,$19
 	.set	noreorder
 	.set	nomacro
-	beq	$20,$0,$L270
-	move	$5,$20
+	jal	rtl_set_skb_mark
+	move	$5,$0
 	.set	macro
 	.set	reorder
 
-	lw	$4,20($17)
 	.set	noreorder
 	.set	nomacro
-	jal	arp_req_get_ha
-	move	$6,$21
+	beq	$21,$0,$L293
+	move	$4,$19
 	.set	macro
 	.set	reorder
 
+	lw	$4,20($18)
+	move	$5,$21
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L270
+	jal	rtl_arp_req_get_ha
+	move	$6,$23
+	.set	macro
+	.set	reorder
+
+	.set	noreorder
+	.set	nomacro
+	bne	$2,$0,$L293
+	move	$4,$19
+	.set	macro
+	.set	reorder
+
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_ppp_proto_check
 	addiu	$5,$sp,56
 	.set	macro
 	.set	reorder
 
-	lw	$4,176($18)
-	li	$6,2			# 0x2
+	move	$17,$2
+	li	$2,1			# 0x1
+	bne	$17,$2,$L246
 	.set	noreorder
 	.set	nomacro
-	jal	memcmp
-	addiu	$4,$4,-2
+	jal	rtl_skb_mac_header_was_set
+	move	$4,$19
 	.set	macro
 	.set	reorder
 
-	bne	$2,$0,$L271
-	lw	$3,160($18)
-	beq	$3,$0,$L271
-	lbu	$2,12($3)
-	lbu	$3,13($3)
-	sll	$2,$2,8
-	or	$3,$3,$2
-	li	$2,2048			# 0x800
-	beq	$3,$2,$L271
-	lw	$2,176($18)
-	addiu	$2,$2,-22
-	sw	$2,160($18)
-$L271:
-	lw	$4,160($18)
-	move	$5,$21
-	li	$6,6			# 0x6
+	bne	$2,$17,$L246
 	.set	noreorder
 	.set	nomacro
-	jal	memcpy
-	addiu	$4,$4,6
+	jal	rtl_eth_hdr
+	move	$4,$19
 	.set	macro
 	.set	reorder
 
-	addiu	$5,$20,320
-	lw	$4,160($18)
+	lbu	$3,12($2)
+	lbu	$2,13($2)
+	sll	$3,$3,8
+	or	$2,$2,$3
+	li	$3,2048			# 0x800
+	.set	noreorder
+	.set	nomacro
+	beq	$2,$3,$L246
+	move	$4,$19
+	.set	macro
+	.set	reorder
+
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_skb_set_mac_header
+	li	$5,-22			# 0xffffffea
+	.set	macro
+	.set	reorder
+
+$L246:
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_eth_hdr
+	move	$4,$19
+	.set	macro
+	.set	reorder
+
+	move	$5,$23
+	addiu	$4,$2,6
 	.set	noreorder
 	.set	nomacro
 	jal	memcpy
@@ -1419,105 +1528,153 @@ $L271:
 	.set	macro
 	.set	reorder
 
-$L270:
-	sw	$0,144($18)
+	move	$4,$19
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_set_skb_dmac
+	move	$5,$21
+	.set	macro
+	.set	reorder
+
 	li	$2,2048			# 0x800
 	lw	$3,100($sp)
 	.set	noreorder
 	.set	nomacro
-	bne	$3,$2,$L280
-	lui	$2,%hi(nf_hooks+128)
+	bne	$3,$2,$L293
+	move	$4,$19
 	.set	macro
 	.set	reorder
 
+	lui	$2,%hi(nf_hooks+128)
 	lw	$3,%lo(nf_hooks+128)($2)
 	addiu	$2,$2,%lo(nf_hooks+128)
 	.set	noreorder
 	.set	nomacro
-	beq	$3,$2,$L280
-	lui	$2,%hi(init_net+236)
+	beq	$3,$2,$L293
+	move	$6,$21
 	.set	macro
 	.set	reorder
 
-	move	$4,$18
-	lw	$2,%lo(init_net+236)($2)
 	move	$5,$0
-	move	$6,$20
-	move	$7,$19
 	.set	noreorder
 	.set	nomacro
-	jal	ipt_do_table
-	sw	$2,16($sp)
+	jal	rtl_ipt_do_table
+	move	$7,$20
 	.set	macro
 	.set	reorder
 
-$L280:
-	lw	$2,144($18)
-	addiu	$21,$sp,40
-	move	$4,$21
-	move	$5,$0
+	move	$4,$19
+$L293:
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_mark
+	addiu	$23,$sp,40
+	.set	macro
+	.set	reorder
+
+	move	$4,$23
 	sw	$2,48($16)
+	move	$5,$0
+	lw	$2,20($18)
 	li	$6,14			# 0xe
-	lw	$2,20($17)
-	sw	$2,12($22)
-	lw	$2,24($17)
-	sh	$2,0($23)
-	lw	$2,4($17)
-	sw	$2,16($22)
-	lw	$2,8($17)
+	sw	$2,12($fp)
+	lw	$2,24($18)
+	lw	$8,80($sp)
+	sh	$2,0($8)
+	lw	$2,4($18)
+	sw	$2,16($fp)
+	lw	$2,8($18)
 	.set	noreorder
 	.set	nomacro
 	jal	memset
-	sh	$2,2($23)
+	sh	$2,2($8)
 	.set	macro
 	.set	reorder
 
+	move	$4,$19
 	.set	noreorder
 	.set	nomacro
-	beq	$19,$0,$L285
-	move	$5,$19
+	jal	rtl_set_skb_mark
+	move	$5,$0
 	.set	macro
 	.set	reorder
 
-	lw	$4,4($17)
 	.set	noreorder
 	.set	nomacro
-	jal	arp_req_get_ha
-	move	$6,$21
+	beq	$20,$0,$L251
+	move	$5,$20
+	.set	macro
+	.set	reorder
+
+	lw	$4,4($18)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_arp_req_get_ha
+	move	$6,$23
+	.set	macro
+	.set	reorder
+
+	.set	noreorder
+	.set	nomacro
+	bne	$2,$0,$L251
+	move	$4,$19
 	.set	macro
 	.set	reorder
 
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L285
+	jal	rtl_ppp_proto_check
 	addiu	$5,$sp,56
 	.set	macro
 	.set	reorder
 
-	lw	$4,176($18)
-	li	$6,2			# 0x2
+	move	$17,$2
+	li	$2,1			# 0x1
+	bne	$17,$2,$L252
 	.set	noreorder
 	.set	nomacro
-	jal	memcmp
-	addiu	$4,$4,-2
+	jal	rtl_skb_mac_header_was_set
+	move	$4,$19
 	.set	macro
 	.set	reorder
 
-	bne	$2,$0,$L286
-	lw	$3,160($18)
-	beq	$3,$0,$L286
-	lbu	$2,12($3)
-	lbu	$3,13($3)
-	sll	$2,$2,8
-	or	$3,$3,$2
-	li	$2,2048			# 0x800
-	beq	$3,$2,$L286
-	lw	$2,176($18)
-	addiu	$2,$2,-22
-	sw	$2,160($18)
-$L286:
-	lw	$4,160($18)
-	move	$5,$21
+	bne	$2,$17,$L252
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_eth_hdr
+	move	$4,$19
+	.set	macro
+	.set	reorder
+
+	lbu	$3,12($2)
+	lbu	$2,13($2)
+	sll	$3,$3,8
+	or	$2,$2,$3
+	li	$3,2048			# 0x800
+	.set	noreorder
+	.set	nomacro
+	beq	$2,$3,$L252
+	move	$4,$19
+	.set	macro
+	.set	reorder
+
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_skb_set_mac_header
+	li	$5,-22			# 0xffffffea
+	.set	macro
+	.set	reorder
+
+$L252:
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_eth_hdr
+	move	$4,$19
+	.set	macro
+	.set	reorder
+
+	move	$5,$23
+	move	$4,$2
 	.set	noreorder
 	.set	nomacro
 	jal	memcpy
@@ -1525,23 +1682,19 @@ $L286:
 	.set	macro
 	.set	reorder
 
-	addiu	$5,$19,320
-	lw	$4,160($18)
-	li	$6,6			# 0x6
+	move	$4,$19
 	.set	noreorder
 	.set	nomacro
-	jal	memcpy
-	addiu	$4,$4,6
+	jal	rtl_set_skb_smac
+	move	$5,$20
 	.set	macro
 	.set	reorder
 
-$L285:
-	sw	$0,144($18)
 	li	$2,2048			# 0x800
-	lw	$4,100($sp)
+	lw	$9,100($sp)
 	.set	noreorder
 	.set	nomacro
-	bne	$4,$2,$L295
+	bne	$9,$2,$L251
 	lui	$2,%hi(nf_hooks+160)
 	.set	macro
 	.set	reorder
@@ -1550,74 +1703,76 @@ $L285:
 	addiu	$2,$2,%lo(nf_hooks+160)
 	.set	noreorder
 	.set	nomacro
-	beq	$3,$2,$L295
-	lui	$2,%hi(init_net+236)
+	beq	$3,$2,$L251
+	move	$4,$19
 	.set	macro
 	.set	reorder
 
-	move	$4,$18
-	lw	$2,%lo(init_net+236)($2)
 	li	$5,4			# 0x4
-	move	$6,$20
-	move	$7,$19
+	move	$6,$21
 	.set	noreorder
 	.set	nomacro
-	jal	ipt_do_table
-	sw	$2,16($sp)
+	jal	rtl_ipt_do_table
+	move	$7,$20
+	.set	macro
+	.set	reorder
+
+$L251:
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_mark
+	move	$4,$19
 	.set	macro
 	.set	reorder
 
-$L295:
-	lw	$2,144($18)
 	sw	$2,52($16)
 	li	$2,6			# 0x6
-	lw	$5,72($sp)
+	lw	$3,76($sp)
 	.set	noreorder
 	.set	nomacro
-	bne	$5,$2,$L300
+	bne	$3,$2,$L257
 	lui	$2,%hi(nf_ct_udp_timeout_stream)
 	.set	macro
 	.set	reorder
 
-	lw	$2,160($sp)
-	lbu	$4,176($2)
-	jal	tcp_get_timeouts_by_state
+	lw	$4,160($sp)
+	jal	rtl_tcp_get_timeouts
 	.set	noreorder
 	.set	nomacro
-	j	$L339
+	j	$L291
 	sw	$2,60($16)
 	.set	macro
 	.set	reorder
 
-$L300:
+$L257:
 	lw	$2,%lo(nf_ct_udp_timeout_stream)($2)
 	sw	$2,60($16)
-$L339:
+$L291:
 	lui	$2,%hi(jiffies)
-	lw	$3,160($sp)
-	lw	$4,76($16)
-	sw	$3,56($16)
-	lw	$2,%lo(jiffies)($2)
+	lw	$4,160($sp)
 	lw	$3,72($16)
+	sw	$4,56($16)
+	lw	$2,%lo(jiffies)($2)
+	lw	$4,76($16)
 	.set	noreorder
 	.set	nomacro
-	beq	$3,$0,$L303
+	beq	$3,$0,$L260
 	sw	$2,40($16)
 	.set	macro
 	.set	reorder
 
 	.set	noreorder
 	.set	nomacro
-	j	$L304
+	j	$L261
 	sw	$4,76($3)
 	.set	macro
 	.set	reorder
 
-$L303:
+$L260:
 	lui	$5,%hi(path_list_free)
 	addiu	$2,$5,%lo(path_list_free)
 	sw	$4,4($2)
-$L304:
+$L261:
 	lw	$3,76($16)
 	lui	$5,%hi(path_list_free)
 	lw	$2,72($16)
@@ -1628,14 +1783,16 @@ $L304:
 	lui	$3,%hi(path_list_inuse)
 	lw	$2,8($5)
 	addiu	$3,$3,%lo(path_list_inuse)
-	sll	$4,$fp,1
-	addiu	$8,$16,64
+	lw	$8,72($sp)
 	addiu	$2,$2,-1
-	addu	$4,$4,$fp
 	sw	$2,8($5)
-	sll	$4,$4,2
+	sll	$4,$8,1
+	lw	$9,72($sp)
+	addiu	$8,$16,64
 	sw	$0,72($16)
 	lw	$2,4($3)
+	addu	$4,$4,$9
+	sll	$4,$4,2
 	sw	$2,76($16)
 	lw	$2,4($3)
 	sw	$16,0($2)
@@ -1664,19 +1821,32 @@ $L304:
 	lw	$2,8($4)
 	addiu	$2,$2,1
 	sw	$2,8($4)
-$L267:
-	lw	$4,160($18)
+$L242:
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_eth_hdr
+	move	$4,$19
+	.set	macro
+	.set	reorder
+
 	addiu	$5,$sp,24
 	li	$6,6			# 0x6
 	.set	noreorder
 	.set	nomacro
 	jal	memcpy
-	addiu	$4,$4,6
+	addiu	$4,$2,6
+	.set	macro
+	.set	reorder
+
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_eth_hdr
+	move	$4,$19
 	.set	macro
 	.set	reorder
 
 	addiu	$5,$sp,32
-	lw	$4,160($18)
+	move	$4,$2
 	.set	noreorder
 	.set	nomacro
 	jal	memcpy
@@ -1684,31 +1854,38 @@ $L267:
 	.set	macro
 	.set	reorder
 
-	lw	$2,104($sp)
-	sw	$2,144($18)
+	lw	$5,104($sp)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_set_skb_mark
+	move	$4,$19
+	.set	macro
+	.set	reorder
+
+	move	$4,$19
+	lw	$2,84($sp)
+	sw	$2,12($fp)
+	lw	$5,92($sp)
 	lw	$3,80($sp)
-	sw	$3,12($22)
-	lw	$4,88($sp)
-	sh	$4,0($23)
-	lw	$5,84($sp)
-	sw	$5,16($22)
-	lw	$2,92($sp)
-	sh	$2,2($23)
-	lw	$3,96($sp)
+	sh	$5,0($3)
+	lw	$8,88($sp)
+	sw	$8,16($fp)
+	lw	$9,96($sp)
 	.set	noreorder
 	.set	nomacro
-	beq	$19,$0,$L311
-	sw	$3,28($18)
+	jal	rtl_set_skb_dst
+	sh	$9,2($3)
 	.set	macro
 	.set	reorder
 
+	beq	$20,$0,$L264
 #APP
 	   
 
-	1:	ll	    $2, 452($19)		# atomic_sub		
+	1:	ll	    $2, 452($20)		# atomic_sub		
        nop                                             
 	subu	$2, 1					
-	sc	    $2, 452($19)					
+	sc	    $2, 452($20)					
 	beqz	$2, 2f					
 	.subsection 2					
 2:	b	1b					
@@ -1717,15 +1894,15 @@ $L267:
 	   
 
 #NO_APP
-$L311:
-	beq	$20,$0,$L314
+$L264:
+	beq	$21,$0,$L267
 #APP
 	   
 
-	1:	ll	    $2, 452($20)		# atomic_sub		
+	1:	ll	    $2, 452($21)		# atomic_sub		
        nop                                             
 	subu	$2, 1					
-	sc	    $2, 452($20)					
+	sc	    $2, 452($21)					
 	beqz	$2, 2f					
 	.subsection 2					
 2:	b	1b					
@@ -1734,53 +1911,57 @@ $L311:
 	   
 
 #NO_APP
-$L314:
-	lw	$4,76($sp)
-	xori	$2,$4,0x1
-	andi	$2,$2,0x1
-	beq	$2,$0,$L318
+	j	$L267
+$L212:
+#APP
+	raw_local_irq_restore	$22
+#NO_APP
 	.set	noreorder
 	.set	nomacro
-	j	$L337
-	move	$2,$4
+	j	$L193
+	li	$3,-1			# 0xffffffff
 	.set	macro
 	.set	reorder
 
-$L318:
-	lw	$2,76($sp)
-$L337:
+$L267:
 #APP
-	raw_local_irq_restore	$2
+	raw_local_irq_restore	$22
 #NO_APP
+	lw	$2,160($sp)
+	lb	$3,212($2)
+	li	$2,-1			# 0xffffffff
 	.set	noreorder
 	.set	nomacro
-	j	$L203
-	move	$2,$0
+	bne	$3,$2,$L193
+	move	$3,$0
 	.set	macro
 	.set	reorder
 
-$L213:
-	lw	$5,76($sp)
-	xori	$2,$5,0x1
-	andi	$2,$2,0x1
-	beq	$2,$0,$L325
+	lw	$3,76($sp)
+	li	$2,6			# 0x6
 	.set	noreorder
 	.set	nomacro
-	j	$L336
-	move	$2,$5
+	beq	$3,$2,$L284
+	li	$2,17			# 0x11
 	.set	macro
 	.set	reorder
 
-$L325:
-	lw	$2,76($sp)
-$L336:
-#APP
-	raw_local_irq_restore	$2
-#NO_APP
-	li	$2,-1			# 0xffffffff
-$L323:
-$L203:
+	.set	noreorder
+	.set	nomacro
+	bne	$3,$2,$L193
+	move	$3,$0
+	.set	macro
+	.set	reorder
+
+$L284:
+	lw	$4,160($sp)
+	jal	__conntrack_drop_check
+	lw	$4,160($sp)
+	sb	$2,212($4)
+	move	$3,$0
+$L193:
 	lw	$31,148($sp)
+	move	$2,$3
 	lw	$fp,144($sp)
 	lw	$23,140($sp)
 	lw	$22,136($sp)
@@ -1857,7 +2038,7 @@ rtk_delNaptConnection:
 	lw	$5,0($2)
 	.set	noreorder
 	.set	nomacro
-	beq	$5,$0,$L395
+	beq	$5,$0,$L349
 	lui	$2,%hi(napt_list_inuse)
 	.set	macro
 	.set	reorder
@@ -1866,47 +2047,47 @@ rtk_delNaptConnection:
 	addiu	$9,$2,%lo(napt_list_inuse)
 	lui	$2,%hi(napt_list_free)
 	addiu	$7,$2,%lo(napt_list_free)
-$L387:
+$L341:
 	lw	$2,4($5)
-	bne	$2,$22,$L346
+	bne	$2,$22,$L300
 	lw	$2,8($5)
-	bne	$2,$21,$L346
+	bne	$2,$21,$L300
 	lw	$2,12($5)
-	bne	$2,$20,$L346
+	bne	$2,$20,$L300
 	lw	$3,16($5)
 	lw	$2,12($16)
-	bne	$3,$2,$L346
+	bne	$3,$2,$L300
 	lw	$3,20($5)
 	lw	$2,16($16)
-	bne	$3,$2,$L346
+	bne	$3,$2,$L300
 	lw	$2,24($5)
-	bne	$2,$19,$L346
+	bne	$2,$19,$L300
 	lw	$2,28($5)
-	bne	$2,$18,$L346
+	bne	$2,$18,$L300
 	lw	$2,36($5)
 	sb	$0,0($5)
 	lw	$4,40($5)
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L349
+	beq	$2,$0,$L303
 	addu	$3,$8,$6
 	.set	macro
 	.set	reorder
 
 	.set	noreorder
 	.set	nomacro
-	j	$L350
+	j	$L304
 	sw	$4,40($2)
 	.set	macro
 	.set	reorder
 
-$L349:
+$L303:
 	lw	$2,%lo(table_napt)($10)
 	sll	$3,$3,2
 	lw	$2,0($2)
 	addu	$3,$3,$2
 	sw	$4,4($3)
-$L350:
+$L304:
 	lw	$2,36($5)
 	sll	$3,$6,1
 	lw	$4,40($5)
@@ -1922,17 +2103,17 @@ $L350:
 	sw	$2,8($3)
 	lw	$2,44($5)
 	lw	$3,48($5)
-	beq	$2,$0,$L352
+	beq	$2,$0,$L306
 	.set	noreorder
 	.set	nomacro
-	j	$L353
+	j	$L307
 	sw	$3,48($2)
 	.set	macro
 	.set	reorder
 
-$L352:
+$L306:
 	sw	$3,4($9)
-$L353:
+$L307:
 	lw	$3,48($5)
 	addiu	$4,$5,44
 	lw	$2,44($5)
@@ -1978,7 +2159,7 @@ $L353:
 	lw	$5,0($3)
 	.set	noreorder
 	.set	nomacro
-	beq	$5,$0,$L357
+	beq	$5,$0,$L311
 	move	$4,$2
 	.set	macro
 	.set	reorder
@@ -1989,43 +2170,43 @@ $L353:
 	addiu	$9,$24,%lo(path_list_inuse)
 	li	$14,1			# 0x1
 	move	$15,$12
-$L367:
+$L321:
 	lw	$3,4($5)
 	lw	$2,0($16)
-	bne	$3,$2,$L358
+	bne	$3,$2,$L312
 	lbu	$2,2($5)
-	bne	$2,$14,$L358
+	bne	$2,$14,$L312
 	lw	$2,16($5)
-	bne	$2,$8,$L358
+	bne	$2,$8,$L312
 	lw	$2,12($5)
-	bne	$2,$11,$L358
+	bne	$2,$11,$L312
 	lw	$3,24($5)
 	lw	$2,12($16)
-	bne	$3,$2,$L358
+	bne	$3,$2,$L312
 	lw	$3,28($5)
 	lw	$2,16($16)
-	bne	$3,$2,$L358
+	bne	$3,$2,$L312
 	lw	$2,20($5)
-	bne	$2,$7,$L358
+	bne	$2,$7,$L312
 	lw	$2,8($5)
-	bne	$2,$10,$L358
+	bne	$2,$10,$L312
 	lw	$2,64($5)
 	sb	$0,0($5)
 	lw	$3,68($5)
-	beq	$2,$0,$L361
+	beq	$2,$0,$L315
 	.set	noreorder
 	.set	nomacro
-	j	$L362
+	j	$L316
 	sw	$3,68($2)
 	.set	macro
 	.set	reorder
 
-$L361:
+$L315:
 	lw	$2,%lo(table_path)($12)
 	lw	$2,0($2)
 	addu	$2,$4,$2
 	sw	$3,4($2)
-$L362:
+$L316:
 	lw	$3,68($5)
 	lw	$2,64($5)
 	sw	$2,0($3)
@@ -2037,17 +2218,17 @@ $L362:
 	sw	$2,8($3)
 	lw	$3,72($5)
 	lw	$2,76($5)
-	beq	$3,$0,$L364
+	beq	$3,$0,$L318
 	.set	noreorder
 	.set	nomacro
-	j	$L365
+	j	$L319
 	sw	$2,76($3)
 	.set	macro
 	.set	reorder
 
-$L364:
+$L318:
 	sw	$2,4($9)
-$L365:
+$L319:
 	lw	$2,72($5)
 	addiu	$4,$5,72
 	lw	$3,76($5)
@@ -2065,15 +2246,15 @@ $L365:
 	addiu	$2,$2,1
 	.set	noreorder
 	.set	nomacro
-	j	$L357
+	j	$L311
 	sw	$2,8($6)
 	.set	macro
 	.set	reorder
 
-$L358:
+$L312:
 	lw	$5,64($5)
-	bne	$5,$0,$L367
-$L357:
+	bne	$5,$0,$L321
+$L311:
 	lw	$8,20($16)
 	lui	$10,%hi(table_path)
 	lw	$7,12($16)
@@ -2100,7 +2281,7 @@ $L357:
 	sll	$2,$2,2
 	addu	$3,$2,$3
 	lw	$5,0($3)
-	beq	$5,$0,$L370
+	beq	$5,$0,$L324
 	move	$4,$2
 	lui	$2,%hi(path_list_free)
 	addiu	$9,$24,%lo(path_list_inuse)
@@ -2108,43 +2289,43 @@ $L357:
 	move	$13,$4
 	li	$14,2			# 0x2
 	move	$15,$10
-$L380:
+$L334:
 	lw	$3,4($5)
 	lw	$2,0($16)
-	bne	$3,$2,$L371
+	bne	$3,$2,$L325
 	lbu	$2,2($5)
-	bne	$2,$14,$L371
+	bne	$2,$14,$L325
 	lw	$2,20($5)
-	bne	$2,$7,$L371
+	bne	$2,$7,$L325
 	lw	$2,8($5)
-	bne	$2,$11,$L371
+	bne	$2,$11,$L325
 	lw	$2,24($5)
-	bne	$2,$8,$L371
+	bne	$2,$8,$L325
 	lw	$2,28($5)
-	bne	$2,$12,$L371
+	bne	$2,$12,$L325
 	lw	$3,32($5)
 	lw	$2,4($16)
-	bne	$3,$2,$L371
+	bne	$3,$2,$L325
 	lw	$3,36($5)
 	lw	$2,8($16)
-	bne	$3,$2,$L371
+	bne	$3,$2,$L325
 	lw	$2,64($5)
 	sb	$0,0($5)
 	lw	$3,68($5)
-	beq	$2,$0,$L374
+	beq	$2,$0,$L328
 	.set	noreorder
 	.set	nomacro
-	j	$L375
+	j	$L329
 	sw	$3,68($2)
 	.set	macro
 	.set	reorder
 
-$L374:
+$L328:
 	lw	$2,%lo(table_path)($10)
 	lw	$2,0($2)
 	addu	$2,$4,$2
 	sw	$3,4($2)
-$L375:
+$L329:
 	lw	$3,68($5)
 	lw	$2,64($5)
 	sw	$2,0($3)
@@ -2156,17 +2337,17 @@ $L375:
 	sw	$2,8($3)
 	lw	$3,72($5)
 	lw	$2,76($5)
-	beq	$3,$0,$L377
+	beq	$3,$0,$L331
 	.set	noreorder
 	.set	nomacro
-	j	$L378
+	j	$L332
 	sw	$2,76($3)
 	.set	macro
 	.set	reorder
 
-$L377:
+$L331:
 	sw	$2,4($9)
-$L378:
+$L332:
 	lw	$2,72($5)
 	addiu	$4,$5,72
 	lw	$3,76($5)
@@ -2184,34 +2365,34 @@ $L378:
 	addiu	$2,$2,1
 	.set	noreorder
 	.set	nomacro
-	j	$L370
+	j	$L324
 	sw	$2,8($6)
 	.set	macro
 	.set	reorder
 
-$L371:
+$L325:
 	lw	$5,64($5)
-	bne	$5,$0,$L380
-$L370:
+	bne	$5,$0,$L334
+$L324:
 #APP
 	raw_local_irq_restore	$17
 #NO_APP
 	.set	noreorder
 	.set	nomacro
-	j	$L340
+	j	$L294
 	move	$2,$0
 	.set	macro
 	.set	reorder
 
-$L346:
+$L300:
 	lw	$5,36($5)
-	bne	$5,$0,$L387
-$L395:
+	bne	$5,$0,$L341
+$L349:
 #APP
 	raw_local_irq_restore	$17
 #NO_APP
 	li	$2,-4			# 0xfffffffc
-$L340:
+$L294:
 	lw	$31,56($sp)
 	lw	$23,52($sp)
 	lw	$22,48($sp)
@@ -2236,35 +2417,37 @@ $L340:
 	.type	rtk_idleNaptConnection, @function
 rtk_idleNaptConnection:
 	.set	nomips16
-	.frame	$sp,8,$31		# vars= 0, regs= 1/0, args= 0, gp= 0
-	.mask	0x00010000,-8
+	.frame	$sp,24,$31		# vars= 0, regs= 2/0, args= 16, gp= 0
+	.mask	0x80010000,-4
 	.fmask	0x00000000,0
 	.set	noreorder
 	.set	nomacro
 	
-	addiu	$sp,$sp,-8
-	move	$7,$4
-	sw	$16,0($sp)
-	li	$11,6			# 0x6
-	lw	$8,4($4)
+	addiu	$sp,$sp,-24
+	move	$8,$4
+	sw	$16,16($sp)
+	li	$13,6			# 0x6
+	sw	$31,20($sp)
 	lui	$16,%hi(path_table_list_max)
-	lw	$6,20($4)
+	lw	$10,4($4)
 	lui	$25,%hi(table_path)
-	lw	$13,8($4)
-	srl	$2,$8,8
-	srl	$3,$6,16
-	xor	$2,$2,$8
-	xor	$3,$3,$6
-	srl	$4,$13,4
-	lw	$12,0($7)
+	lw	$9,20($4)
+	move	$15,$5
+	lw	$14,8($4)
+	srl	$2,$10,8
+	srl	$3,$9,16
+	xor	$2,$2,$10
+	xor	$3,$3,$9
+	srl	$4,$14,4
+	lw	$12,0($8)
 	xor	$2,$2,$3
-	lw	$10,24($7)
+	lw	$11,24($8)
 	xor	$2,$2,$4
 	li	$3,17			# 0x11
 	xori	$4,$12,0x2
-	movn	$11,$3,$4		#conditional move  
-	xor	$2,$2,$10
+	movn	$13,$3,$4		#conditional move  
 	xor	$2,$2,$11
+	xor	$2,$2,$13
 	lw	$4,%lo(path_table_list_max)($16)
 	srl	$3,$2,12
 	xor	$2,$2,$3
@@ -2277,78 +2460,76 @@ rtk_idleNaptConnection:
 	sll	$2,$2,2
 	lui	$3,%hi(jiffies)
 	addu	$2,$2,$4
-	lw	$4,0($2)
-	lw	$14,%lo(jiffies)($3)
-	beq	$4,$0,$L403
+	lw	$24,%lo(jiffies)($3)
+	lw	$6,0($2)
+$L371:
+	beq	$6,$0,$L357
 	li	$2,-16777216			# 0xff000000
 
-	subu	$9,$14,$5
-	ori	$24,$2,0x100
-	ori	$15,$2,0xff00
-$L407:
-	lw	$2,4($4)
-	bne	$2,$12,$L404
-	nop
+	lw	$3,4($6)
+	ori	$4,$2,0xff00
+	bne	$3,$12,$L358
+	ori	$7,$2,0x100
 
-	lw	$2,0($4)
-	and	$2,$2,$15
-	bne	$2,$24,$L404
+	lw	$2,0($6)
+	and	$2,$2,$4
+	bne	$2,$7,$L358
 	nop
 
-	lw	$2,16($4)
-	bne	$2,$8,$L404
+	lw	$2,16($6)
+	bne	$2,$10,$L358
 	nop
 
-	lw	$2,12($4)
-	bne	$2,$13,$L404
+	lw	$2,12($6)
+	bne	$2,$14,$L358
 	nop
 
-	lw	$3,24($4)
-	lw	$2,12($7)
-	bne	$3,$2,$L404
+	lw	$3,24($6)
+	lw	$2,12($8)
+	bne	$3,$2,$L358
 	nop
 
-	lw	$3,28($4)
-	lw	$2,16($7)
-	bne	$3,$2,$L404
+	lw	$3,28($6)
+	lw	$2,16($8)
+	bne	$3,$2,$L358
 	nop
 
-	lw	$2,20($4)
-	bne	$2,$6,$L404
+	lw	$2,20($6)
+	bne	$2,$9,$L358
 	nop
 
-	lw	$2,8($4)
-	bne	$2,$10,$L404
-	nop
+	lw	$2,8($6)
+	bne	$2,$11,$L358
+	subu	$2,$24,$15
 
-	lw	$6,40($4)
-	subu	$2,$9,$6
-	bgez	$2,$L403
+	lw	$5,40($6)
+	subu	$2,$2,$5
+	bgez	$2,$L357
 	nop
 
-	j	$L417
+	j	$L373
 	nop
 
-$L404:
-	lw	$4,64($4)
-	bne	$4,$0,$L407
+$L358:
+	lw	$6,64($6)
+	j	$L371
 	nop
 
-$L403:
-	lw	$8,20($7)
-	lw	$6,12($7)
-	lw	$12,24($7)
-	srl	$2,$8,8
-	srl	$3,$6,16
-	xor	$2,$2,$8
-	xor	$3,$3,$6
-	srl	$4,$12,4
+$L357:
+	lw	$11,20($8)
+	lw	$10,12($8)
+	lw	$14,24($8)
+	srl	$2,$11,8
+	srl	$3,$10,16
+	xor	$2,$2,$11
+	xor	$3,$3,$10
+	srl	$4,$14,4
 	xor	$2,$2,$3
-	lw	$10,16($7)
+	lw	$12,16($8)
 	xor	$2,$2,$4
 	lw	$4,%lo(path_table_list_max)($16)
-	xor	$2,$2,$10
-	xor	$2,$2,$11
+	xor	$2,$2,$12
+	xor	$2,$2,$13
 	addiu	$4,$4,-1
 	srl	$3,$2,12
 	xor	$2,$2,$3
@@ -2359,74 +2540,73 @@ $L403:
 	lw	$3,0($3)
 	sll	$2,$2,2
 	addu	$2,$2,$3
-	lw	$4,0($2)
-	beq	$4,$0,$L410
+	lw	$6,0($2)
+$L372:
+	beq	$6,$0,$L364
 	li	$2,-16777216			# 0xff000000
 
-	subu	$9,$14,$5
-	ori	$13,$2,0x200
-	ori	$11,$2,0xff00
-$L414:
-	lw	$3,4($4)
-	lw	$2,0($7)
-	bne	$3,$2,$L411
-	nop
+	lw	$4,4($6)
+	lw	$3,0($8)
+	ori	$9,$2,0xff00
+	bne	$4,$3,$L365
+	ori	$7,$2,0x200
 
-	lw	$2,0($4)
-	and	$2,$2,$11
-	bne	$2,$13,$L411
+	lw	$2,0($6)
+	and	$2,$2,$9
+	bne	$2,$7,$L365
 	nop
 
-	lw	$2,20($4)
-	bne	$2,$6,$L411
+	lw	$2,20($6)
+	bne	$2,$10,$L365
 	nop
 
-	lw	$2,8($4)
-	bne	$2,$10,$L411
+	lw	$2,8($6)
+	bne	$2,$12,$L365
 	nop
 
-	lw	$2,24($4)
-	bne	$2,$8,$L411
+	lw	$2,24($6)
+	bne	$2,$11,$L365
 	nop
 
-	lw	$2,28($4)
-	bne	$2,$12,$L411
+	lw	$2,28($6)
+	bne	$2,$14,$L365
 	nop
 
-	lw	$3,32($4)
-	lw	$2,4($7)
-	bne	$3,$2,$L411
+	lw	$3,32($6)
+	lw	$2,4($8)
+	bne	$3,$2,$L365
 	nop
 
-	lw	$3,36($4)
-	lw	$2,8($7)
-	bne	$3,$2,$L411
-	nop
+	lw	$3,36($6)
+	lw	$2,8($8)
+	bne	$3,$2,$L365
+	subu	$2,$24,$15
 
-	lw	$6,40($4)
-	subu	$2,$9,$6
-	bgez	$2,$L410
+	lw	$5,40($6)
+	subu	$2,$2,$5
+	bgez	$2,$L364
 	nop
 
-$L417:
-	lw	$3,56($4)
-	addu	$2,$6,$5
-	li	$4,-1			# 0xffffffff
-	j	$L398
-	sw	$2,116($3)
+$L373:
+	lw	$4,56($6)
+	jal	rtl_set_ct_timeout_expires
+	addu	$5,$5,$15
 
-$L411:
-	lw	$4,64($4)
-	bne	$4,$0,$L414
+	j	$L352
+	li	$2,-1			# 0xffffffff
+
+$L365:
+	lw	$6,64($6)
+	j	$L372
 	nop
 
-$L410:
-	move	$4,$0
-$L398:
-	lw	$16,0($sp)
-	move	$2,$4
+$L364:
+	move	$2,$0
+$L352:
+	lw	$31,20($sp)
+	lw	$16,16($sp)
 	j	$31
-	addiu	$sp,$sp,8
+	addiu	$sp,$sp,24
 
 	.set	macro
 	.set	reorder
@@ -2438,107 +2618,185 @@ $L398:
 	.type	rtl_fpTimer_update, @function
 rtl_fpTimer_update:
 	.set	nomips16
-	.frame	$sp,72,$31		# vars= 32, regs= 5/0, args= 16, gp= 0
-	.mask	0x800f0000,-8
+	.frame	$sp,72,$31		# vars= 32, regs= 6/0, args= 16, gp= 0
+	.mask	0x801f0000,-4
 	.fmask	0x00000000,0
 	.set	noreorder
 	.set	nomacro
 	
 	addiu	$sp,$sp,-72
 	lui	$2,%hi(jiffies)
-	sw	$16,48($sp)
-	move	$16,$4
-	sw	$31,64($sp)
+	sw	$17,52($sp)
+	move	$5,$0
+	sw	$31,68($sp)
+	move	$17,$4
+	sw	$20,64($sp)
 	sw	$19,60($sp)
 	sw	$18,56($sp)
-	sw	$17,52($sp)
-	lbu	$3,50($4)
-	lw	$19,%lo(jiffies)($2)
-	li	$2,17			# 0x11
-	bne	$3,$2,$L419
-	li	$2,6			# 0x6
+	sw	$16,48($sp)
+	lw	$20,%lo(jiffies)($2)
+	jal	rtl_get_ct_protonum
+	nop
+
+	li	$3,17			# 0x11
+	bne	$2,$3,$L375
+	move	$4,$17
+
+	jal	rtl_get_ct_udp_status
+	li	$19,1			# 0x1
 
-	lw	$2,100($4)
 	andi	$2,$2,0x2
-	beq	$2,$0,$L420
-	li	$18,1			# 0x1
+	beq	$2,$0,$L376
+	lui	$2,%hi(nf_ct_udp_timeout)
 
 	lui	$2,%hi(nf_ct_udp_timeout_stream)
-	lw	$17,%lo(nf_ct_udp_timeout_stream)($2)
-	j	$L422
-	nop
+	lw	$18,%lo(nf_ct_udp_timeout_stream)($2)
+	j	$L390
+	move	$4,$17
+
+$L376:
+	lw	$18,%lo(nf_ct_udp_timeout)($2)
+	j	$L390
+	move	$4,$17
+
+$L375:
+	jal	rtl_get_ct_protonum
+	move	$5,$0
+
+	li	$3,6			# 0x6
+	bne	$2,$3,$L374
+	li	$2,-1			# 0xffffffff
+
+	jal	rtl_get_ct_tcp_state
+	move	$4,$17
+
+	sltu	$2,$2,6
+	beq	$2,$0,$L374
+	li	$2,-1			# 0xffffffff
+
+	move	$4,$17
+	jal	rtl_tcp_get_timeouts
+	li	$19,2			# 0x2
+
+	move	$18,$2
+	move	$4,$17
+$L390:
+	move	$5,$0
+	jal	rtl_get_ct_ip_by_dir
+	move	$6,$0
+
+	move	$4,$17
+	li	$5,1			# 0x1
+	li	$6,1			# 0x1
+	jal	rtl_get_ct_ip_by_dir
+	move	$16,$2
+
+	bne	$16,$2,$L381
+	move	$4,$17
+
+	li	$5,1			# 0x1
+	move	$6,$0
+	jal	rtl_get_ct_ip_by_dir
+	sw	$19,16($sp)
+
+	move	$4,$17
+	li	$5,1			# 0x1
+	move	$6,$0
+	jal	rtl_get_ct_port_by_dir
+	sw	$2,20($sp)
+
+	move	$4,$17
+	move	$5,$0
+	li	$6,1			# 0x1
+	jal	rtl_get_ct_ip_by_dir
+	sw	$2,24($sp)
+
+	move	$4,$17
+	move	$5,$0
+	li	$6,1			# 0x1
+	jal	rtl_get_ct_port_by_dir
+	sw	$2,28($sp)
+
+	move	$4,$17
+	move	$5,$0
+	move	$6,$0
+	jal	rtl_get_ct_ip_by_dir
+	sw	$2,32($sp)
+
+	move	$4,$17
+	j	$L389
+	move	$5,$0
 
-$L420:
-	lui	$2,%hi(nf_ct_udp_timeout)
-	lw	$17,%lo(nf_ct_udp_timeout)($2)
-	j	$L422
-	nop
+$L381:
+	move	$5,$0
+	jal	rtl_get_ct_ip_by_dir
+	li	$6,1			# 0x1
 
-$L419:
-	bne	$3,$2,$L418
-	li	$2,-1			# 0xffffffff
+	move	$4,$17
+	li	$5,1			# 0x1
+	move	$6,$0
+	jal	rtl_get_ct_ip_by_dir
+	move	$16,$2
 
-	lbu	$4,176($4)
-	sltu	$2,$4,6
-	beq	$2,$0,$L418
+	bne	$16,$2,$L374
 	li	$2,-1			# 0xffffffff
 
-	jal	tcp_get_timeouts_by_state
-	li	$18,2			# 0x2
+	move	$4,$17
+	move	$5,$0
+	move	$6,$0
+	jal	rtl_get_ct_ip_by_dir
+	sw	$19,16($sp)
 
-	move	$17,$2
-$L422:
-	lw	$10,12($16)
-	lw	$8,80($16)
-	lw	$9,60($16)
-	lw	$7,32($16)
-	bne	$10,$8,$L425
-	addiu	$4,$sp,16
+	move	$4,$17
+	move	$5,$0
+	move	$6,$0
+	jal	rtl_get_ct_port_by_dir
+	sw	$2,20($sp)
 
-	lhu	$2,76($16)
-	lhu	$3,48($16)
-	move	$5,$17
-	lhu	$6,28($16)
-	sw	$18,16($sp)
-	sw	$9,20($sp)
+	move	$4,$17
+	li	$5,1			# 0x1
+	li	$6,1			# 0x1
+	jal	rtl_get_ct_ip_by_dir
 	sw	$2,24($sp)
-	sw	$7,28($sp)
-	sw	$3,32($sp)
-	j	$L433
-	sw	$8,36($sp)
 
-$L425:
-	bne	$7,$9,$L418
-	li	$2,-1			# 0xffffffff
+	move	$4,$17
+	li	$5,1			# 0x1
+	li	$6,1			# 0x1
+	jal	rtl_get_ct_port_by_dir
+	sw	$2,28($sp)
+
+	move	$4,$17
+	li	$5,1			# 0x1
+	move	$6,$0
+	jal	rtl_get_ct_ip_by_dir
+	sw	$2,32($sp)
+
+	move	$4,$17
+	li	$5,1			# 0x1
+$L389:
+	move	$6,$0
+	jal	rtl_get_ct_port_by_dir
+	sw	$2,36($sp)
 
-	lhu	$2,28($16)
 	addiu	$4,$sp,16
-	lhu	$3,96($16)
-	move	$5,$17
-	lhu	$6,76($16)
-	sw	$18,16($sp)
-	sw	$10,20($sp)
-	sw	$2,24($sp)
-	sw	$8,28($sp)
-	sw	$3,32($sp)
-	sw	$7,36($sp)
-$L433:
+	move	$5,$18
 	jal	rtk_idleNaptConnection
-	sw	$6,40($sp)
+	sw	$2,40($sp)
 
-	beq	$2,$0,$L430
-	addu	$5,$19,$17
+	beq	$2,$0,$L386
+	addu	$5,$20,$18
 
 	jal	rtl_check_for_acc
-	move	$4,$16
+	move	$4,$17
 
-	j	$L418
+	j	$L374
 	move	$2,$0
 
-$L430:
+$L386:
 	li	$2,-1			# 0xffffffff
-$L418:
-	lw	$31,64($sp)
+$L374:
+	lw	$31,68($sp)
+	lw	$20,64($sp)
 	lw	$19,60($sp)
 	lw	$18,56($sp)
 	lw	$17,52($sp)
@@ -2563,71 +2821,71 @@ rtl_br_fdb_time_update:
 	.set	nomacro
 	
 	addiu	$sp,$sp,-40
-	move	$4,$0
+	sw	$17,28($sp)
+	move	$17,$4
 	sw	$16,24($sp)
+	move	$4,$0
 	move	$16,$5
 	move	$5,$6
-	li	$6,2			# 0x2
 	sw	$31,32($sp)
 	jal	rtl_get_hw_fdb_age
-	sw	$17,28($sp)
+	li	$6,2			# 0x2
 
 	move	$3,$2
+	sltu	$5,$2,301
 	li	$2,300			# 0x12c
-	beq	$3,$2,$L437
-	lui	$2,%hi(jiffies)
+	beq	$3,$2,$L394
+	move	$4,$16
 
-	sltu	$2,$3,301
-	beq	$2,$0,$L440
+	beq	$5,$0,$L397
 	li	$2,450			# 0x1c2
 
 	li	$2,150			# 0x96
-	beq	$3,$2,$L438
+	beq	$3,$2,$L395
 	lui	$2,%hi(jiffies)
 
-	j	$L435
+	j	$L392
 	nop
 
-$L440:
-	bne	$3,$2,$L435
-	lui	$2,%hi(jiffies)
+$L397:
+	bne	$3,$2,$L392
+	move	$4,$16
 
-	lw	$2,%lo(jiffies)($2)
-	j	$L435
-	sw	$2,24($16)
+	lui	$2,%hi(jiffies)
+	lw	$5,%lo(jiffies)($2)
+	j	$L399
+	nop
 
-$L437:
-	lw	$2,%lo(jiffies)($2)
-	j	$L445
-	addiu	$2,$2,-15000
+$L394:
+	lui	$2,%hi(jiffies)
+	lw	$5,%lo(jiffies)($2)
+	j	$L399
+	addiu	$5,$5,-15000
 
-$L438:
-	lw	$2,%lo(jiffies)($2)
-	addiu	$2,$2,-30000
-$L445:
-	sw	$2,24($16)
-$L435:
-	lbu	$2,1112($17)
-	beq	$2,$0,$L442
+$L395:
+	lw	$5,%lo(jiffies)($2)
+	addiu	$5,$5,-30000
+$L399:
+	jal	rtl_set_fdb_aging
 	nop
 
-	lw	$5,1080($17)
-	j	$L444
-	nop
+$L392:
+	jal	rtl_get_fdb_aging
+	move	$4,$16
+
+	move	$4,$17
+	jal	rtl_hold_time
+	move	$16,$2
 
-$L442:
-	lw	$5,1088($17)
-$L444:
-	lw	$2,24($16)
 	lui	$3,%hi(jiffies)
 	lw	$3,%lo(jiffies)($3)
-	addu	$2,$2,$5
-	subu	$3,$3,$2
+	addu	$16,$16,$2
+	lw	$31,32($sp)
 	li	$2,-1			# 0xffffffff
+	subu	$3,$3,$16
 	slt	$3,$3,0
-	lw	$31,32($sp)
-	movn	$2,$0,$3		#conditional move
 	lw	$17,28($sp)
+	movn	$2,$0,$3		#conditional move
 	lw	$16,24($sp)
 	j	$31
 	addiu	$sp,$sp,40
@@ -2674,55 +2932,55 @@ mark_path_invalid:
 	sll	$2,$2,2
 	addu	$2,$2,$3
 	lw	$4,0($2)
-	beq	$4,$0,$L469
+	beq	$4,$0,$L423
 	nop
 
 	li	$3,255			# 0xff
-$L454:
+$L408:
 	lw	$2,12($4)
-	bne	$2,$5,$L450
+	bne	$2,$5,$L404
 	nop
 
 	lw	$2,8($4)
-	bne	$2,$7,$L450
+	bne	$2,$7,$L404
 	nop
 
 	lw	$2,16($4)
-	bne	$2,$11,$L450
+	bne	$2,$11,$L404
 	nop
 
 	lw	$2,20($4)
-	bne	$2,$6,$L450
+	bne	$2,$6,$L404
 	nop
 
 	lbu	$2,0($4)
-	bne	$2,$3,$L450
+	bne	$2,$3,$L404
 	li	$2,1			# 0x1
 
 	lbu	$3,2($4)
-	beq	$3,$2,$L467
+	beq	$3,$2,$L421
 	sb	$0,0($4)
 
 	lw	$8,32($4)
 	lhu	$9,38($4)
-	j	$L449
+	j	$L403
 	nop
 
-$L450:
+$L404:
 	lw	$4,64($4)
-	bne	$4,$0,$L454
+	bne	$4,$0,$L408
 	nop
 
-$L470:
+$L424:
 	j	$31
 	nop
 
-$L449:
-	beq	$8,$0,$L470
+$L403:
+	beq	$8,$0,$L424
 	li	$2,1			# 0x1
 
 	lbu	$3,2($4)
-	bne	$3,$2,$L456
+	bne	$3,$2,$L410
 	srl	$3,$11,16
 
 	srl	$2,$6,8
@@ -2732,16 +2990,16 @@ $L449:
 	xor	$2,$2,$3
 	srl	$3,$7,4
 	xor	$2,$2,$3
-	j	$L468
+	j	$L422
 	xor	$2,$2,$9
 
-$L467:
+$L421:
 	lw	$8,24($4)
 	lhu	$9,30($4)
-	j	$L449
+	j	$L403
 	nop
 
-$L456:
+$L410:
 	srl	$2,$8,8
 	xor	$3,$3,$11
 	xor	$2,$2,$8
@@ -2749,7 +3007,7 @@ $L456:
 	srl	$3,$9,4
 	xor	$2,$2,$3
 	xor	$2,$2,$5
-$L468:
+$L422:
 	xor	$2,$2,$10
 	lw	$3,%lo(path_table_list_max)($12)
 	srl	$4,$2,12
@@ -2763,38 +3021,38 @@ $L468:
 	sll	$3,$3,2
 	addu	$3,$3,$2
 	lw	$4,0($3)
-	beq	$4,$0,$L469
+	beq	$4,$0,$L423
 	nop
 
 	li	$3,255			# 0xff
-$L464:
+$L418:
 	lw	$2,24($4)
-	bne	$2,$6,$L462
+	bne	$2,$6,$L416
 	nop
 
 	lw	$2,28($4)
-	bne	$2,$7,$L462
+	bne	$2,$7,$L416
 	nop
 
 	lw	$2,32($4)
-	bne	$2,$11,$L462
+	bne	$2,$11,$L416
 	nop
 
 	lw	$2,36($4)
-	bne	$2,$5,$L462
+	bne	$2,$5,$L416
 	nop
 
 	lbu	$2,0($4)
-	bne	$2,$3,$L462
+	bne	$2,$3,$L416
 	nop
 
 	sb	$0,0($4)
-$L462:
+$L416:
 	lw	$4,64($4)
-	bne	$4,$0,$L464
+	bne	$4,$0,$L418
 	nop
 
-$L469:
+$L423:
 	j	$31
 	nop
 
@@ -2808,36 +3066,107 @@ $L469:
 	.type	rtl_fp_mark_invalid, @function
 rtl_fp_mark_invalid:
 	.set	nomips16
-	.frame	$sp,32,$31		# vars= 0, regs= 2/0, args= 24, gp= 0
-	.mask	0x80010000,-4
+	.frame	$sp,72,$31		# vars= 8, regs= 10/0, args= 24, gp= 0
+	.mask	0xc0ff0000,-4
 	.fmask	0x00000000,0
 	.set	noreorder
 	.set	nomacro
 	
-	addiu	$sp,$sp,-32
-	sw	$31,28($sp)
-	sw	$16,24($sp)
+	addiu	$sp,$sp,-72
+	li	$5,1			# 0x1
+	sw	$16,32($sp)
+	move	$6,$0
 	move	$16,$4
-	lhu	$5,76($16)
-	lw	$6,80($16)
-	lhu	$7,96($16)
-	lbu	$2,98($16)
-	lw	$4,60($4)
+	sw	$31,68($sp)
+	sw	$fp,64($sp)
+	sw	$23,60($sp)
+	sw	$22,56($sp)
+	sw	$21,52($sp)
+	sw	$20,48($sp)
+	sw	$19,44($sp)
+	sw	$18,40($sp)
+	jal	rtl_get_ct_ip_by_dir
+	sw	$17,36($sp)
+
+	move	$4,$16
+	li	$5,1			# 0x1
+	li	$6,1			# 0x1
+	jal	rtl_get_ct_ip_by_dir
+	sw	$2,24($sp)
+
+	move	$4,$16
+	move	$5,$0
+	move	$6,$0
+	jal	rtl_get_ct_ip_by_dir
+	move	$fp,$2
+
+	move	$4,$16
+	move	$5,$0
+	li	$6,1			# 0x1
+	jal	rtl_get_ct_ip_by_dir
+	move	$23,$2
+
+	move	$4,$16
+	li	$5,1			# 0x1
+	move	$6,$0
+	jal	rtl_get_ct_port_by_dir
+	move	$22,$2
+
+	move	$4,$16
+	li	$5,1			# 0x1
+	li	$6,1			# 0x1
+	jal	rtl_get_ct_port_by_dir
+	move	$21,$2
+
+	move	$4,$16
+	move	$5,$0
+	move	$6,$0
+	jal	rtl_get_ct_port_by_dir
+	move	$20,$2
+
+	li	$6,1			# 0x1
+	move	$4,$16
+	move	$5,$0
+	jal	rtl_get_ct_port_by_dir
+	move	$19,$2
+
+	move	$4,$16
+	li	$5,1			# 0x1
+	jal	rtl_get_ct_protonum
+	move	$18,$2
+
+	move	$4,$16
+	move	$5,$0
+	jal	rtl_get_ct_protonum
+	move	$17,$2
+
+	move	$5,$21
+	lw	$4,24($sp)
+	move	$6,$fp
+	move	$7,$20
+	move	$16,$2
 	jal	mark_path_invalid
-	sw	$2,16($sp)
+	sw	$17,16($sp)
 
-	lw	$4,12($16)
-	lhu	$5,28($16)
-	lw	$6,32($16)
-	lhu	$7,48($16)
-	lbu	$2,50($16)
+	move	$4,$23
+	move	$5,$19
+	move	$6,$22
+	move	$7,$18
 	jal	mark_path_invalid
-	sw	$2,16($sp)
+	sw	$16,16($sp)
 
-	lw	$31,28($sp)
-	lw	$16,24($sp)
+	lw	$31,68($sp)
+	lw	$fp,64($sp)
+	lw	$23,60($sp)
+	lw	$22,56($sp)
+	lw	$21,52($sp)
+	lw	$20,48($sp)
+	lw	$19,44($sp)
+	lw	$18,40($sp)
+	lw	$17,36($sp)
+	lw	$16,32($sp)
 	j	$31
-	addiu	$sp,$sp,32
+	addiu	$sp,$sp,72
 
 	.set	macro
 	.set	reorder
@@ -2858,83 +3187,100 @@ enter_fast_path:
 	.fmask	0x00000000,0
 	addiu	$sp,$sp,-88
 	li	$2,1			# 0x1
-	sw	$23,76($sp)
-	move	$23,$0
-	sw	$21,68($sp)
 	sw	$31,84($sp)
-	sw	$fp,80($sp)
 	sw	$22,72($sp)
-	sw	$20,64($sp)
+	move	$22,$0
 	sw	$19,60($sp)
 	sw	$18,56($sp)
-	sw	$17,52($sp)
 	sw	$16,48($sp)
-	lw	$18,156($4)
-	sw	$2,32($sp)
-	li	$2,6			# 0x6
-	sw	$0,36($sp)
+	sw	$4,24($sp)
+	sw	$fp,80($sp)
+	sw	$23,76($sp)
+	sw	$21,68($sp)
+	sw	$20,64($sp)
+	sw	$17,52($sp)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_ip_hdr
+	sw	$2,36($sp)
+	.set	macro
+	.set	reorder
+
+	lw	$4,24($sp)
+	move	$18,$2
+	lbu	$19,9($2)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_dev_name
 	sw	$0,40($sp)
-	lbu	$19,9($18)
+	.set	macro
+	.set	reorder
+
+	move	$16,$2
+	li	$2,6			# 0x6
 	.set	noreorder
 	.set	nomacro
-	beq	$19,$2,$L475
-	move	$21,$4
+	beq	$19,$2,$L427
+	sw	$0,44($sp)
 	.set	macro
 	.set	reorder
 
 	li	$2,17			# 0x11
 	.set	noreorder
 	.set	nomacro
-	bne	$19,$2,$L472
-	move	$4,$0
+	bne	$19,$2,$L426
+	move	$5,$0
 	.set	macro
 	.set	reorder
 
-$L475:
+$L427:
 	lbu	$2,0($18)
 	move	$4,$18
-	move	$6,$21
+	lw	$6,24($sp)
 	andi	$2,$2,0xf
 	sll	$2,$2,2
-	addu	$22,$18,$2
+	addu	$21,$18,$2
 	.set	noreorder
 	.set	nomacro
 	jal	fast_path_pre_process_check
-	move	$5,$22
+	move	$5,$21
 	.set	macro
 	.set	reorder
 
-	move	$5,$2
 	move	$4,$2
+	move	$5,$2
 	li	$2,6			# 0x6
-	bne	$5,$2,$L472
-	lhu	$3,0($22)
-	lhu	$16,6($18)
+	.set	noreorder
+	.set	nomacro
+	bne	$4,$2,$L426
+	lui	$3,%hi($LC0)
+	.set	macro
+	.set	reorder
+
+	lhu	$2,0($21)
+	lhu	$17,6($18)
 	lw	$20,12($18)
-	lw	$fp,16($18)
-	sw	$3,24($sp)
-	lhu	$2,2($22)
+	lw	$23,16($18)
 	sw	$2,28($sp)
-	lw	$3,24($21)
+	lhu	$2,2($21)
 	.set	noreorder
 	.set	nomacro
-	bne	$19,$5,$L477
-	lui	$4,%hi($LC0)
+	bne	$19,$4,$L429
+	sw	$2,32($sp)
 	.set	macro
 	.set	reorder
 
-	addiu	$2,$4,%lo($LC0)
-	move	$5,$3
+	addiu	$2,$3,%lo($LC0)
 #APP
 	.set	noreorder
 	.set	noat
-	lbu	$3,($5)
+	lbu	$3,($16)
 1:	lbu	$1,($2)
-	addiu	$5,1
+	addiu	$16,1
 	bne	$1,$3,2f
 	addiu	$2,1
 	bnez	$3,1b
-	lbu	$3,($5)
+	lbu	$3,($16)
 	move	$3,$1
 2:	subu	$3,$1
 3:	.set	at
@@ -2942,43 +3288,43 @@ $L475:
 #NO_APP
 	.set	noreorder
 	.set	nomacro
-	beq	$3,$0,$L472
-	move	$4,$0
+	beq	$3,$0,$L426
+	move	$5,$0
 	.set	macro
 	.set	reorder
 
-	andi	$2,$16,0x3fff
+	andi	$2,$17,0x3fff
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L483
+	beq	$2,$0,$L435
 	li	$3,1			# 0x1
 	.set	macro
 	.set	reorder
 
-	xori	$2,$16,0x2000
+	xori	$2,$17,0x2000
 	sltu	$3,$2,1
-$L483:
+$L435:
 	li	$2,1			# 0x1
 	.set	noreorder
 	.set	nomacro
-	bne	$3,$2,$L484
+	bne	$3,$2,$L436
 	li	$2,65536			# 0x10000
 	.set	macro
 	.set	reorder
 
-	lw	$3,12($22)
+	lw	$3,12($21)
 	and	$2,$3,$2
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L485
+	beq	$2,$0,$L437
 	li	$2,393216			# 0x60000
 	.set	macro
 	.set	reorder
 
-	lw	$5,24($sp)
+	lw	$5,28($sp)
 	move	$4,$20
-	lw	$7,28($sp)
-	move	$6,$fp
+	lw	$7,32($sp)
+	move	$6,$23
 	.set	noreorder
 	.set	nomacro
 	jal	mark_path_invalid
@@ -2988,34 +3334,34 @@ $L483:
 
 	.set	noreorder
 	.set	nomacro
-	j	$L472
-	move	$4,$0
+	j	$L426
+	move	$5,$0
 	.set	macro
 	.set	reorder
 
-$L485:
+$L437:
 	and	$2,$3,$2
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L472
-	move	$4,$0
+	bne	$2,$0,$L426
+	move	$5,$0
 	.set	macro
 	.set	reorder
 
-$L484:
-	lw	$2,12($22)
+$L436:
+	lw	$2,12($21)
 	li	$3,1048576			# 0x100000
 	and	$2,$2,$3
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L488
+	beq	$2,$0,$L440
 	li	$2,40			# 0x28
 	.set	macro
 	.set	reorder
 
 	lhu	$3,2($18)
-	bne	$3,$2,$L488
-	move	$4,$21
+	bne	$3,$2,$L440
+	lw	$4,24($sp)
 	.set	noreorder
 	.set	nomacro
 	jal	skb_trim
@@ -3023,20 +3369,19 @@ $L484:
 	.set	macro
 	.set	reorder
 
-	j	$L488
-$L477:
-	addiu	$2,$4,%lo($LC0)
-	move	$5,$3
+	j	$L440
+$L429:
+	addiu	$2,$3,%lo($LC0)
 #APP
 	.set	noreorder
 	.set	noat
-	lbu	$3,($5)
+	lbu	$3,($16)
 1:	lbu	$1,($2)
-	addiu	$5,1
+	addiu	$16,1
 	bne	$1,$3,2f
 	addiu	$2,1
 	bnez	$3,1b
-	lbu	$3,($5)
+	lbu	$3,($16)
 	move	$3,$1
 2:	subu	$3,$1
 3:	.set	at
@@ -3044,50 +3389,49 @@ $L477:
 #NO_APP
 	.set	noreorder
 	.set	nomacro
-	beq	$3,$0,$L472
-	move	$4,$0
+	beq	$3,$0,$L426
+	move	$5,$0
 	.set	macro
 	.set	reorder
 
-$L488:
+$L440:
 	lhu	$2,6($18)
 	andi	$2,$2,0x3fff
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L651
-	srl	$3,$fp,16
+	beq	$2,$0,$L443
+	li	$2,8192			# 0x2000
 	.set	macro
 	.set	reorder
 
-	li	$2,8192			# 0x2000
 	.set	noreorder
 	.set	nomacro
-	bne	$16,$2,$L492
-	andi	$2,$16,0x2000
+	bne	$17,$2,$L444
+	andi	$2,$17,0x2000
 	.set	macro
 	.set	reorder
 
-	li	$2,1			# 0x1
+	li	$3,1			# 0x1
 	.set	noreorder
 	.set	nomacro
-	j	$L493
-	sw	$2,36($sp)
+	j	$L445
+	sw	$3,40($sp)
 	.set	macro
 	.set	reorder
 
-$L492:
+$L444:
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L493
-	andi	$3,$16,0x1fff
+	bne	$2,$0,$L445
+	andi	$3,$17,0x1fff
 	.set	macro
 	.set	reorder
 
-	lw	$4,40($sp)
+	lw	$4,44($sp)
 	li	$2,1			# 0x1
 	movn	$4,$2,$3		#conditional move
-	sw	$4,40($sp)
-$L493:
+	sw	$4,44($sp)
+$L445:
 	lw	$8,12($18)
 	andi	$6,$19,0x00ff
 	lw	$7,16($18)
@@ -3113,82 +3457,80 @@ $L493:
 	lw	$4,0($2)
 	.set	noreorder
 	.set	nomacro
-	beq	$4,$0,$L502
-	move	$23,$0
+	beq	$4,$0,$L454
+	move	$22,$0
 	.set	macro
 	.set	reorder
 
 	li	$3,1			# 0x1
-$L501:
+$L453:
 	lhu	$2,2($4)
-	bne	$2,$5,$L498
+	bne	$2,$5,$L450
 	lw	$2,4($4)
-	bne	$2,$8,$L498
+	bne	$2,$8,$L450
 	lw	$2,8($4)
-	bne	$2,$7,$L498
+	bne	$2,$7,$L450
 	lbu	$2,1($4)
-	bne	$2,$6,$L498
+	bne	$2,$6,$L450
 	lbu	$2,0($4)
-	beq	$2,$3,$L632
-$L498:
+	beq	$2,$3,$L583
+$L450:
 	lw	$4,40($4)
 	.set	noreorder
 	.set	nomacro
-	bne	$4,$0,$L501
-	move	$23,$0
+	bne	$4,$0,$L453
+	move	$22,$0
 	.set	macro
 	.set	reorder
 
-	j	$L502
-$L632:
+	j	$L454
+$L583:
 	.set	noreorder
 	.set	nomacro
-	beq	$4,$0,$L502
-	move	$23,$4
+	beq	$4,$0,$L454
+	move	$22,$4
 	.set	macro
 	.set	reorder
 
-	lhu	$5,12($4)
-	lw	$3,36($sp)
-	sw	$5,24($sp)
-	lhu	$2,14($4)
+	lhu	$2,12($4)
+	sw	$2,28($sp)
+	lhu	$3,14($4)
+	lw	$4,40($sp)
 	.set	noreorder
 	.set	nomacro
-	bne	$3,$0,$L491
-	sw	$2,28($sp)
+	bne	$4,$0,$L443
+	sw	$3,32($sp)
 	.set	macro
 	.set	reorder
 
 	.set	noreorder
 	.set	nomacro
-	j	$L491
-	sw	$0,32($sp)
+	j	$L443
+	sw	$0,36($sp)
 	.set	macro
 	.set	reorder
 
-$L502:
-	lw	$5,36($sp)
+$L454:
+	lw	$2,40($sp)
 	.set	noreorder
 	.set	nomacro
-	beq	$5,$0,$L472
-	move	$4,$0
+	beq	$2,$0,$L426
+	move	$5,$0
 	.set	macro
 	.set	reorder
 
-$L491:
-	srl	$3,$fp,16
-$L651:
+$L443:
+	lw	$4,28($sp)
 	srl	$2,$20,8
-	lw	$4,24($sp)
+	srl	$fp,$23,16
 	xor	$2,$2,$20
-	sw	$3,44($sp)
-	xor	$3,$3,$fp
+	xor	$3,$fp,$23
 	xor	$2,$2,$3
 	srl	$3,$4,4
-	lw	$5,28($sp)
+	xor	$2,$2,$3
+	lw	$3,32($sp)
 	xor	$2,$2,$3
 	lui	$3,%hi(path_table_list_max)
-	xor	$2,$2,$5
 	xor	$2,$2,$19
 	lw	$4,%lo(path_table_list_max)($3)
 	srl	$3,$2,12
@@ -3203,26 +3545,20 @@ $L651:
 	sll	$2,$2,2
 	addu	$2,$2,$3
 	lw	$16,0($2)
-$L637:
-	.set	noreorder
-	.set	nomacro
-	beq	$16,$0,$L631
-	move	$4,$18
-	.set	macro
-	.set	reorder
-
+$L590:
+	beq	$16,$0,$L582
 	lw	$2,12($16)
-	lw	$3,24($sp)
-	bne	$2,$3,$L509
-	lw	$2,8($16)
 	lw	$4,28($sp)
-	bne	$2,$4,$L509
+	bne	$2,$4,$L461
+	lw	$2,8($16)
+	lw	$3,32($sp)
+	bne	$2,$3,$L461
 	lw	$2,16($16)
-	bne	$2,$20,$L509
+	bne	$2,$20,$L461
 	lw	$2,20($16)
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$fp,$L509
+	bne	$2,$23,$L461
 	li	$2,255			# 0xff
 	.set	macro
 	.set	reorder
@@ -3230,7 +3566,7 @@ $L637:
 	lbu	$3,0($16)
 	.set	noreorder
 	.set	nomacro
-	bne	$3,$2,$L509
+	bne	$3,$2,$L461
 	li	$2,2			# 0x2
 	.set	macro
 	.set	reorder
@@ -3238,7 +3574,7 @@ $L637:
 	lw	$3,4($16)
 	.set	noreorder
 	.set	nomacro
-	bne	$3,$2,$L652
+	bne	$3,$2,$L600
 	li	$2,1			# 0x1
 	.set	macro
 	.set	reorder
@@ -3246,73 +3582,74 @@ $L637:
 	li	$2,6			# 0x6
 	.set	noreorder
 	.set	nomacro
-	beq	$19,$2,$L511
+	beq	$19,$2,$L463
 	li	$2,1			# 0x1
 	.set	macro
 	.set	reorder
 
-$L652:
+$L600:
 	.set	noreorder
 	.set	nomacro
-	bne	$3,$2,$L509
+	bne	$3,$2,$L461
 	li	$2,17			# 0x11
 	.set	macro
 	.set	reorder
 
-	bne	$19,$2,$L509
-$L511:
+	bne	$19,$2,$L461
+$L463:
+	lbu	$2,8($18)
+	sltu	$2,$2,2
+	.set	noreorder
+	.set	nomacro
+	bne	$2,$0,$L426
+	move	$5,$0
+	.set	macro
+	.set	reorder
+
 	lw	$5,32($16)
-	move	$4,$21
+	lw	$4,24($sp)
 	lbu	$7,1($18)
-	move	$6,$20
-	lw	$2,24($21)
 	.set	noreorder
 	.set	nomacro
-	jal	ip_route_input
-	sw	$2,16($sp)
+	jal	rtl_ip_route_input
+	move	$6,$20
 	.set	macro
 	.set	reorder
 
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L472
-	move	$4,$0
+	bne	$2,$0,$L426
+	move	$5,$0
 	.set	macro
 	.set	reorder
 
-	lw	$3,28($21)
-	lw	$2,48($3)
-	bne	$2,$0,$L516
-	lw	$2,44($3)
-	beq	$2,$0,$L644
-$L516:
-	lw	$2,72($3)
-	lw	$3,84($21)
-	sltu	$2,$2,$3
+	lw	$4,24($sp)
+	jal	rtl_skb_dst_check
+	li	$3,-1			# 0xffffffff
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L644
+	beq	$2,$3,$L586
 	li	$2,6			# 0x6
 	.set	macro
 	.set	reorder
 
 	.set	noreorder
 	.set	nomacro
-	beq	$19,$2,$L520
-	addiu	$17,$22,16
+	beq	$19,$2,$L469
+	addiu	$17,$21,16
 	.set	macro
 	.set	reorder
 
-	lhu	$3,6($22)
-	addiu	$2,$22,6
+	lhu	$3,6($21)
+	addiu	$2,$21,6
 	move	$17,$0
 	movn	$17,$2,$3		#conditional move  
-$L520:
-	lw	$5,36($sp)
+$L469:
+	lw	$4,40($sp)
 	.set	noreorder
 	.set	nomacro
-	beq	$5,$0,$L523
-	xor	$3,$20,$fp
+	beq	$4,$0,$L472
+	xor	$3,$20,$23
 	.set	macro
 	.set	reorder
 
@@ -3325,33 +3662,21 @@ $L520:
 	lui	$6,%hi(udp_cache_list_free)
 	xor	$3,$3,$4
 	addiu	$5,$5,-1
-	lw	$4,24($sp)
+	lw	$4,28($sp)
 	srl	$2,$3,8
 	xor	$2,$2,$9
 	andi	$10,$4,0xffff
 	xor	$3,$3,$2
-	lw	$4,28($sp)
+	lw	$4,32($sp)
 	and	$12,$3,$5
 	lw	$8,%lo(udp_cache_list_free)($6)
 	.set	noreorder
 	.set	nomacro
-	bne	$8,$0,$L526
+	beq	$8,$0,$L586
 	andi	$7,$4,0xffff
 	.set	macro
 	.set	reorder
 
-$L644:
-	lw	$4,28($21)
-	jal	dst_release
-	move	$4,$0
-	.set	noreorder
-	.set	nomacro
-	j	$L472
-	sw	$0,28($21)
-	.set	macro
-	.set	reorder
-
-$L526:
 	lw	$4,48($8)
 	li	$2,1
 	sh	$11,2($8)
@@ -3360,25 +3685,25 @@ $L526:
 	sh	$7,14($8)
 	sb	$2,0($8)
 	sw	$20,4($8)
-	sw	$fp,8($8)
+	sw	$23,8($8)
 	lw	$3,52($8)
 	.set	noreorder
 	.set	nomacro
-	beq	$4,$0,$L529
+	beq	$4,$0,$L478
 	addiu	$2,$6,%lo(udp_cache_list_free)
 	.set	macro
 	.set	reorder
 
 	.set	noreorder
 	.set	nomacro
-	j	$L530
+	j	$L479
 	sw	$3,52($4)
 	.set	macro
 	.set	reorder
 
-$L529:
+$L478:
 	sw	$3,4($2)
-$L530:
+$L479:
 	lw	$4,52($8)
 	addiu	$6,$6,%lo(udp_cache_list_free)
 	lw	$2,48($8)
@@ -3423,61 +3748,49 @@ $L530:
 	.set	macro
 	.set	reorder
 
-	.set	noreorder
-	.set	nomacro
-	j	$L650
-	move	$4,$21
-	.set	macro
-	.set	reorder
-
-$L523:
-	lw	$5,40($sp)
-	.set	noreorder
-	.set	nomacro
-	beq	$5,$0,$L650
-	move	$4,$21
-	.set	macro
-	.set	reorder
-
+	j	$L481
+$L472:
+	lw	$2,44($sp)
+	beq	$2,$0,$L481
 	.set	noreorder
 	.set	nomacro
 	jal	del_timer
-	addiu	$4,$23,16
+	addiu	$4,$22,16
 	.set	macro
 	.set	reorder
 
-	lw	$2,8($23)
-	lw	$3,4($23)
-	lhu	$4,2($23)
+	lw	$2,8($22)
+	lw	$3,4($22)
+	lhu	$4,2($22)
 	xor	$3,$3,$2
 	srl	$2,$3,16
 	xor	$2,$2,$4
 	xor	$3,$3,$2
 	lui	$2,%hi(max_udp_frag_entry)
-	lbu	$5,1($23)
+	lbu	$5,1($22)
 	srl	$4,$3,8
 	lw	$2,%lo(max_udp_frag_entry)($2)
 	xor	$4,$4,$5
-	lw	$6,40($23)
+	lw	$6,40($22)
 	xor	$3,$3,$4
 	addiu	$2,$2,-1
-	sb	$0,0($23)
-	lw	$4,44($23)
+	sb	$0,0($22)
+	lw	$4,44($22)
 	.set	noreorder
 	.set	nomacro
-	beq	$6,$0,$L536
+	beq	$6,$0,$L485
 	and	$5,$3,$2
 	.set	macro
 	.set	reorder
 
 	.set	noreorder
 	.set	nomacro
-	j	$L537
+	j	$L486
 	sw	$4,44($6)
 	.set	macro
 	.set	reorder
 
-$L536:
+$L485:
 	lui	$3,%hi(udp_cache_table)
 	sll	$2,$5,1
 	lw	$3,%lo(udp_cache_table)($3)
@@ -3486,13 +3799,13 @@ $L536:
 	lw	$3,0($3)
 	addu	$2,$2,$3
 	sw	$4,4($2)
-$L537:
-	lw	$4,44($23)
+$L486:
+	lw	$4,44($22)
 	sll	$3,$5,1
-	lw	$2,40($23)
+	lw	$2,40($22)
 	addu	$3,$3,$5
 	sll	$3,$3,2
-	addiu	$5,$23,48
+	addiu	$5,$22,48
 	sw	$2,0($4)
 	lui	$2,%hi(udp_cache_table)
 	lw	$2,%lo(udp_cache_table)($2)
@@ -3503,17 +3816,17 @@ $L537:
 	lw	$2,8($3)
 	addiu	$2,$2,-1
 	sw	$2,8($3)
-	sw	$0,48($23)
+	sw	$0,48($22)
 	lw	$2,4($4)
-	sw	$2,52($23)
+	sw	$2,52($22)
 	lw	$2,4($4)
-	sw	$23,0($2)
+	sw	$22,0($2)
 	lw	$2,8($4)
 	sw	$5,4($4)
 	addiu	$2,$2,1
 	sw	$2,8($4)
-	move	$4,$21
-$L650:
+$L481:
+	lw	$4,24($sp)
 	move	$5,$18
 	.set	noreorder
 	.set	nomacro
@@ -3522,42 +3835,42 @@ $L650:
 	.set	macro
 	.set	reorder
 
-	move	$5,$2
 	move	$4,$2
+	move	$5,$2
 	li	$2,6			# 0x6
-	bne	$5,$2,$L472
+	bne	$4,$2,$L426
 	lbu	$3,1($16)
 	sltu	$2,$3,13
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L602
+	beq	$2,$0,$L553
 	sll	$2,$3,2
 	.set	macro
 	.set	reorder
 
-	lui	$3,%hi($L625)
-	addiu	$3,$3,%lo($L625)
+	lui	$3,%hi($L576)
+	addiu	$3,$3,%lo($L576)
 	addu	$2,$2,$3
 	lw	$2,0($2)
 	j	$2
 	.rdata
 	.align	2
-$L625:
-	.word	$L542
-	.word	$L544
-	.word	$L559
-	.word	$L559
-	.word	$L573
-	.word	$L602
-	.word	$L602
-	.word	$L602
-	.word	$L588
-	.word	$L602
-	.word	$L602
-	.word	$L602
-	.word	$L588
+$L576:
+	.word	$L491
+	.word	$L493
+	.word	$L509
+	.word	$L509
+	.word	$L524
+	.word	$L553
+	.word	$L553
+	.word	$L553
+	.word	$L539
+	.word	$L553
+	.word	$L553
+	.word	$L553
+	.word	$L539
 	.section	.text.enter_fast_path
-$L544:
+$L493:
 	lw	$3,24($16)
 	srl	$2,$20,16
 	andi	$4,$20,0xffff
@@ -3570,7 +3883,7 @@ $L544:
 	addu	$4,$4,$2
 	.set	noreorder
 	.set	nomacro
-	bgez	$4,$L546
+	bgez	$4,$L495
 	andi	$2,$4,0xffff
 	.set	macro
 	.set	reorder
@@ -3584,30 +3897,30 @@ $L544:
 	nor	$2,$0,$4
 	.set	noreorder
 	.set	nomacro
-	j	$L545
+	j	$L494
 	sh	$2,10($18)
 	.set	macro
 	.set	reorder
 
-$L546:
+$L495:
 	sra	$3,$4,16
 	addu	$4,$3,$2
 	sra	$2,$4,16
 	addu	$4,$4,$2
 	sh	$4,10($18)
-$L545:
-	lw	$2,32($sp)
+$L494:
+	lw	$3,36($sp)
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L563
+	beq	$3,$0,$L513
 	li	$2,17			# 0x11
 	.set	macro
 	.set	reorder
 
-	bne	$19,$2,$L549
-	beq	$17,$0,$L563
+	bne	$19,$2,$L498
+	beq	$17,$0,$L513
 	lhu	$6,0($17)
-	beq	$6,$0,$L563
+	beq	$6,$0,$L513
 	lw	$2,12($18)
 	lw	$3,24($16)
 	srl	$4,$2,16
@@ -3617,14 +3930,41 @@ $L545:
 	subu	$5,$5,$2
 	srl	$3,$3,16
 	subu	$5,$5,$3
+	addu	$5,$5,$6
 	.set	noreorder
 	.set	nomacro
-	j	$L645
-	addu	$5,$5,$6
+	bgez	$5,$L501
+	andi	$2,$5,0xffff
 	.set	macro
 	.set	reorder
 
-$L549:
+	subu	$5,$0,$5
+	sra	$2,$5,16
+	andi	$3,$5,0xffff
+	addu	$5,$2,$3
+	sra	$2,$5,16
+	addu	$5,$5,$2
+	nor	$2,$0,$5
+	.set	noreorder
+	.set	nomacro
+	j	$L513
+	sh	$2,0($17)
+	.set	macro
+	.set	reorder
+
+$L501:
+	sra	$3,$5,16
+	addu	$5,$3,$2
+	sra	$2,$5,16
+	addu	$5,$5,$2
+	.set	noreorder
+	.set	nomacro
+	j	$L513
+	sh	$5,0($17)
+	.set	macro
+	.set	reorder
+
+$L498:
 	lw	$2,12($18)
 	lw	$3,24($16)
 	srl	$4,$2,16
@@ -3636,10 +3976,9 @@ $L549:
 	lhu	$2,0($17)
 	subu	$5,$5,$3
 	addu	$5,$5,$2
-$L645:
 	.set	noreorder
 	.set	nomacro
-	bgez	$5,$L556
+	bgez	$5,$L505
 	andi	$2,$5,0xffff
 	.set	macro
 	.set	reorder
@@ -3653,24 +3992,40 @@ $L645:
 	nor	$2,$0,$5
 	.set	noreorder
 	.set	nomacro
-	j	$L563
+	j	$L504
 	sh	$2,0($17)
 	.set	macro
 	.set	reorder
 
-$L556:
+$L505:
 	sra	$3,$5,16
 	addu	$5,$3,$2
 	sra	$2,$5,16
 	addu	$5,$5,$2
+	sh	$5,0($17)
+$L504:
+	lw	$2,12($21)
+	li	$3,1048576			# 0x100000
+	and	$2,$2,$3
 	.set	noreorder
 	.set	nomacro
-	j	$L563
-	sh	$5,0($17)
+	beq	$2,$0,$L513
+	li	$2,40			# 0x28
+	.set	macro
+	.set	reorder
+
+	lhu	$3,2($18)
+	bne	$3,$2,$L513
+	lw	$4,24($sp)
+	.set	noreorder
+	.set	nomacro
+	jal	skb_trim
+	li	$5,40			# 0x28
 	.set	macro
 	.set	reorder
 
-$L559:
+	j	$L513
+$L509:
 	lw	$3,24($16)
 	srl	$2,$20,16
 	andi	$4,$20,0xffff
@@ -3683,7 +4038,7 @@ $L559:
 	addu	$4,$4,$2
 	.set	noreorder
 	.set	nomacro
-	bgez	$4,$L561
+	bgez	$4,$L511
 	andi	$2,$4,0xffff
 	.set	macro
 	.set	reorder
@@ -3697,30 +4052,30 @@ $L559:
 	nor	$2,$0,$4
 	.set	noreorder
 	.set	nomacro
-	j	$L560
+	j	$L510
 	sh	$2,10($18)
 	.set	macro
 	.set	reorder
 
-$L561:
+$L511:
 	sra	$3,$4,16
 	addu	$4,$3,$2
 	sra	$2,$4,16
 	addu	$4,$4,$2
 	sh	$4,10($18)
-$L560:
-	lw	$3,32($sp)
+$L510:
+	lw	$4,36($sp)
 	.set	noreorder
 	.set	nomacro
-	beq	$3,$0,$L563
+	beq	$4,$0,$L513
 	li	$2,17			# 0x11
 	.set	macro
 	.set	reorder
 
-	bne	$19,$2,$L564
-	beq	$17,$0,$L569
+	bne	$19,$2,$L514
+	beq	$17,$0,$L519
 	lhu	$6,0($17)
-	beq	$6,$0,$L569
+	beq	$6,$0,$L519
 	lw	$2,12($18)
 	lw	$3,24($16)
 	srl	$4,$2,16
@@ -3729,19 +4084,46 @@ $L560:
 	andi	$2,$3,0xffff
 	subu	$5,$5,$2
 	srl	$3,$3,16
-	lhu	$4,0($22)
+	lhu	$4,0($21)
 	subu	$5,$5,$3
 	lw	$2,28($16)
 	addu	$5,$5,$4
 	subu	$5,$5,$2
+	addu	$5,$5,$6
 	.set	noreorder
 	.set	nomacro
-	j	$L646
-	addu	$5,$5,$6
+	bgez	$5,$L517
+	andi	$2,$5,0xffff
+	.set	macro
+	.set	reorder
+
+	subu	$5,$0,$5
+	sra	$2,$5,16
+	andi	$3,$5,0xffff
+	addu	$5,$2,$3
+	sra	$2,$5,16
+	addu	$5,$5,$2
+	nor	$2,$0,$5
+	.set	noreorder
+	.set	nomacro
+	j	$L519
+	sh	$2,0($17)
+	.set	macro
+	.set	reorder
+
+$L517:
+	sra	$3,$5,16
+	addu	$5,$3,$2
+	sra	$2,$5,16
+	addu	$5,$5,$2
+	.set	noreorder
+	.set	nomacro
+	j	$L519
+	sh	$5,0($17)
 	.set	macro
 	.set	reorder
 
-$L564:
+$L514:
 	lw	$2,12($18)
 	lw	$3,24($16)
 	srl	$4,$2,16
@@ -3750,17 +4132,16 @@ $L564:
 	andi	$2,$3,0xffff
 	subu	$5,$5,$2
 	srl	$3,$3,16
-	lhu	$2,0($22)
+	lhu	$2,0($21)
 	subu	$5,$5,$3
 	lw	$3,28($16)
 	addu	$5,$5,$2
 	lhu	$2,0($17)
 	subu	$5,$5,$3
 	addu	$5,$5,$2
-$L646:
 	.set	noreorder
 	.set	nomacro
-	bgez	$5,$L571
+	bgez	$5,$L521
 	andi	$2,$5,0xffff
 	.set	macro
 	.set	reorder
@@ -3774,43 +4155,63 @@ $L646:
 	nor	$2,$0,$5
 	.set	noreorder
 	.set	nomacro
-	j	$L569
+	j	$L520
 	sh	$2,0($17)
 	.set	macro
 	.set	reorder
 
-$L571:
+$L521:
 	sra	$3,$5,16
 	addu	$5,$3,$2
 	sra	$2,$5,16
 	addu	$5,$5,$2
 	sh	$5,0($17)
-$L569:
+$L520:
+	lw	$2,12($21)
+	li	$3,1048576			# 0x100000
+	and	$2,$2,$3
+	.set	noreorder
+	.set	nomacro
+	beq	$2,$0,$L519
+	li	$2,40			# 0x28
+	.set	macro
+	.set	reorder
+
+	lhu	$3,2($18)
+	bne	$3,$2,$L519
+	lw	$4,24($sp)
+	.set	noreorder
+	.set	nomacro
+	jal	skb_trim
+	li	$5,40			# 0x28
+	.set	macro
+	.set	reorder
+
+$L519:
 	lw	$2,28($16)
-	sh	$2,0($22)
-$L563:
+	sh	$2,0($21)
+$L513:
 	lw	$2,24($16)
 	.set	noreorder
 	.set	nomacro
-	j	$L542
+	j	$L491
 	sw	$2,12($18)
 	.set	macro
 	.set	reorder
 
-$L573:
+$L524:
 	lw	$2,32($16)
-	andi	$6,$fp,0xffff
-	lw	$5,44($sp)
+	andi	$6,$23,0xffff
+	addu	$4,$6,$fp
 	andi	$3,$2,0xffff
 	srl	$2,$2,16
-	addu	$4,$6,$5
 	subu	$4,$4,$3
 	lhu	$3,10($18)
 	subu	$4,$4,$2
 	addu	$4,$4,$3
 	.set	noreorder
 	.set	nomacro
-	bgez	$4,$L575
+	bgez	$4,$L526
 	andi	$2,$4,0xffff
 	.set	macro
 	.set	reorder
@@ -3824,53 +4225,57 @@ $L573:
 	nor	$2,$0,$4
 	.set	noreorder
 	.set	nomacro
-	j	$L574
+	j	$L525
 	sh	$2,10($18)
 	.set	macro
 	.set	reorder
 
-$L575:
+$L526:
 	sra	$3,$4,16
 	addu	$4,$3,$2
 	sra	$2,$4,16
 	addu	$4,$4,$2
 	sh	$4,10($18)
-$L574:
-	lw	$2,32($sp)
+$L525:
+	lw	$2,36($sp)
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L643
+	beq	$2,$0,$L594
 	li	$2,17			# 0x11
 	.set	macro
 	.set	reorder
 
-	bne	$19,$2,$L578
-	beq	$17,$0,$L643
+	bne	$19,$2,$L529
+	beq	$17,$0,$L594
 	lhu	$4,0($17)
-	beq	$4,$0,$L643
-	lw	$3,44($sp)
+	.set	noreorder
+	.set	nomacro
+	beq	$4,$0,$L594
+	addu	$6,$6,$fp
+	.set	macro
+	.set	reorder
+
 	lw	$2,32($16)
 	.set	noreorder
 	.set	nomacro
-	j	$L647
-	addu	$6,$6,$3
+	j	$L601
+	andi	$3,$2,0xffff
 	.set	macro
 	.set	reorder
 
-$L578:
-	lw	$4,44($sp)
+$L529:
 	lw	$2,32($16)
-	addu	$6,$6,$4
+	addu	$6,$6,$fp
 	lhu	$4,0($17)
-$L647:
 	andi	$3,$2,0xffff
+$L601:
 	srl	$2,$2,16
 	subu	$6,$6,$3
 	subu	$6,$6,$2
 	addu	$6,$6,$4
 	.set	noreorder
 	.set	nomacro
-	bgez	$6,$L585
+	bgez	$6,$L536
 	andi	$2,$6,0xffff
 	.set	macro
 	.set	reorder
@@ -3884,37 +4289,36 @@ $L647:
 	nor	$2,$0,$6
 	.set	noreorder
 	.set	nomacro
-	j	$L643
+	j	$L594
 	sh	$2,0($17)
 	.set	macro
 	.set	reorder
 
-$L585:
+$L536:
 	sra	$3,$6,16
 	addu	$6,$3,$2
 	sra	$2,$6,16
 	addu	$6,$6,$2
 	.set	noreorder
 	.set	nomacro
-	j	$L643
+	j	$L594
 	sh	$6,0($17)
 	.set	macro
 	.set	reorder
 
-$L588:
+$L539:
 	lw	$2,32($16)
-	andi	$6,$fp,0xffff
-	lw	$5,44($sp)
+	andi	$6,$23,0xffff
+	addu	$4,$6,$fp
 	andi	$3,$2,0xffff
 	srl	$2,$2,16
-	addu	$4,$6,$5
 	subu	$4,$4,$3
 	lhu	$3,10($18)
 	subu	$4,$4,$2
 	addu	$4,$4,$3
 	.set	noreorder
 	.set	nomacro
-	bgez	$4,$L590
+	bgez	$4,$L541
 	andi	$2,$4,0xffff
 	.set	macro
 	.set	reorder
@@ -3928,66 +4332,69 @@ $L588:
 	nor	$2,$0,$4
 	.set	noreorder
 	.set	nomacro
-	j	$L589
+	j	$L540
 	sh	$2,10($18)
 	.set	macro
 	.set	reorder
 
-$L590:
+$L541:
 	sra	$3,$4,16
 	addu	$4,$3,$2
 	sra	$2,$4,16
 	addu	$4,$4,$2
 	sh	$4,10($18)
-$L589:
-	lw	$2,32($sp)
+$L540:
+	lw	$3,36($sp)
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L643
+	beq	$3,$0,$L594
 	li	$2,17			# 0x11
 	.set	macro
 	.set	reorder
 
-	bne	$19,$2,$L593
-	beq	$17,$0,$L598
+	bne	$19,$2,$L544
+	beq	$17,$0,$L549
 	lhu	$5,0($17)
-	beq	$5,$0,$L598
+	.set	noreorder
+	.set	nomacro
+	beq	$5,$0,$L549
+	addu	$6,$6,$fp
+	.set	macro
+	.set	reorder
+
 	lw	$2,32($16)
-	lw	$3,44($sp)
-	lhu	$4,2($22)
-	addu	$6,$6,$3
+	lhu	$4,2($21)
 	andi	$3,$2,0xffff
-	subu	$6,$6,$3
 	srl	$2,$2,16
+	subu	$6,$6,$3
 	subu	$6,$6,$2
 	lw	$2,36($16)
 	addu	$6,$6,$4
 	subu	$6,$6,$2
 	.set	noreorder
 	.set	nomacro
-	j	$L648
+	j	$L597
 	addu	$6,$6,$5
 	.set	macro
 	.set	reorder
 
-$L593:
+$L544:
 	lw	$2,32($16)
-	lw	$4,44($sp)
+	addu	$6,$6,$fp
+	lhu	$4,2($21)
 	andi	$3,$2,0xffff
 	srl	$2,$2,16
-	addu	$6,$6,$4
 	subu	$6,$6,$3
-	lhu	$4,2($22)
 	subu	$6,$6,$2
 	lw	$3,36($16)
 	addu	$6,$6,$4
 	lhu	$2,0($17)
 	subu	$6,$6,$3
 	addu	$6,$6,$2
-$L648:
+$L597:
 	.set	noreorder
 	.set	nomacro
-	bgez	$6,$L600
+	bgez	$6,$L551
 	andi	$2,$6,0xffff
 	.set	macro
 	.set	reorder
@@ -4001,27 +4408,27 @@ $L648:
 	nor	$2,$0,$6
 	.set	noreorder
 	.set	nomacro
-	j	$L598
+	j	$L549
 	sh	$2,0($17)
 	.set	macro
 	.set	reorder
 
-$L600:
+$L551:
 	sra	$3,$6,16
 	addu	$6,$3,$2
 	sra	$2,$6,16
 	addu	$6,$6,$2
 	sh	$6,0($17)
-$L598:
+$L549:
 	lw	$2,36($16)
 	.set	noreorder
 	.set	nomacro
-	j	$L643
-	sh	$2,2($22)
+	j	$L594
+	sh	$2,2($21)
 	.set	macro
 	.set	reorder
 
-$L602:
+$L553:
 	lw	$2,24($16)
 	srl	$6,$20,16
 	andi	$4,$20,0xffff
@@ -4034,7 +4441,7 @@ $L602:
 	addu	$5,$5,$3
 	.set	noreorder
 	.set	nomacro
-	bgez	$5,$L604
+	bgez	$5,$L555
 	andi	$2,$5,0xffff
 	.set	macro
 	.set	reorder
@@ -4048,31 +4455,30 @@ $L602:
 	nor	$2,$0,$5
 	.set	noreorder
 	.set	nomacro
-	j	$L603
+	j	$L554
 	sh	$2,10($18)
 	.set	macro
 	.set	reorder
 
-$L604:
+$L555:
 	sra	$3,$5,16
 	addu	$5,$3,$2
 	sra	$2,$5,16
 	addu	$5,$5,$2
 	sh	$5,10($18)
-$L603:
+$L554:
 	lw	$2,32($16)
-	andi	$7,$fp,0xffff
-	lw	$3,44($sp)
-	addu	$5,$7,$3
+	andi	$7,$23,0xffff
+	addu	$5,$7,$fp
 	andi	$3,$2,0xffff
-	subu	$5,$5,$3
 	srl	$2,$2,16
+	subu	$5,$5,$3
 	lhu	$3,10($18)
 	subu	$5,$5,$2
 	addu	$5,$5,$3
 	.set	noreorder
 	.set	nomacro
-	bgez	$5,$L607
+	bgez	$5,$L558
 	andi	$2,$5,0xffff
 	.set	macro
 	.set	reorder
@@ -4086,38 +4492,38 @@ $L603:
 	nor	$2,$0,$5
 	.set	noreorder
 	.set	nomacro
-	j	$L606
+	j	$L557
 	sh	$2,10($18)
 	.set	macro
 	.set	reorder
 
-$L607:
+$L558:
 	sra	$3,$5,16
 	addu	$5,$3,$2
 	sra	$2,$5,16
 	addu	$5,$5,$2
 	sh	$5,10($18)
-$L606:
-	lw	$5,32($sp)
+$L557:
+	lw	$2,36($sp)
 	.set	noreorder
 	.set	nomacro
-	beq	$5,$0,$L609
+	beq	$2,$0,$L560
 	li	$2,17			# 0x11
 	.set	macro
 	.set	reorder
 
-	bne	$19,$2,$L610
-	beq	$17,$0,$L618
+	bne	$19,$2,$L561
+	beq	$17,$0,$L569
 	lhu	$5,0($17)
 	.set	noreorder
 	.set	nomacro
-	beq	$5,$0,$L618
+	beq	$5,$0,$L569
 	addu	$6,$4,$6
 	.set	macro
 	.set	reorder
 
 	lw	$2,24($16)
-	lhu	$4,0($22)
+	lhu	$4,0($21)
 	andi	$3,$2,0xffff
 	srl	$2,$2,16
 	subu	$6,$6,$3
@@ -4125,48 +4531,17 @@ $L606:
 	lw	$2,28($16)
 	addu	$6,$6,$4
 	subu	$6,$6,$2
-	addu	$6,$6,$5
-	.set	noreorder
-	.set	nomacro
-	bgez	$6,$L613
-	sra	$3,$6,16
-	.set	macro
-	.set	reorder
-
-	subu	$6,$0,$6
-	sra	$2,$6,16
-	andi	$3,$6,0xffff
-	addu	$6,$2,$3
-	sra	$2,$6,16
-	addu	$6,$6,$2
-	nor	$2,$0,$6
-	.set	noreorder
-	.set	nomacro
-	j	$L612
-	sh	$2,0($17)
-	.set	macro
-	.set	reorder
-
-$L613:
-	andi	$2,$6,0xffff
-	addu	$6,$3,$2
-	sra	$2,$6,16
-	addu	$6,$6,$2
-	sh	$6,0($17)
-$L612:
-	lw	$3,44($sp)
-	lw	$2,32($16)
 	.set	noreorder
 	.set	nomacro
-	j	$L649
-	addu	$6,$7,$3
+	j	$L599
+	addu	$6,$6,$5
 	.set	macro
 	.set	reorder
 
-$L610:
+$L561:
 	lw	$2,24($16)
 	addu	$6,$4,$6
-	lhu	$4,0($22)
+	lhu	$4,0($21)
 	andi	$3,$2,0xffff
 	srl	$2,$2,16
 	subu	$6,$6,$3
@@ -4176,9 +4551,10 @@ $L610:
 	lhu	$2,0($17)
 	subu	$6,$6,$3
 	addu	$6,$6,$2
+$L599:
 	.set	noreorder
 	.set	nomacro
-	bgez	$6,$L620
+	bgez	$6,$L571
 	andi	$2,$6,0xffff
 	.set	macro
 	.set	reorder
@@ -4192,26 +4568,24 @@ $L610:
 	nor	$2,$0,$6
 	.set	noreorder
 	.set	nomacro
-	j	$L619
+	j	$L570
 	sh	$2,0($17)
 	.set	macro
 	.set	reorder
 
-$L620:
+$L571:
 	sra	$3,$6,16
 	addu	$6,$3,$2
 	sra	$2,$6,16
 	addu	$6,$6,$2
 	sh	$6,0($17)
-$L619:
-	lw	$4,44($sp)
+$L570:
 	lw	$2,32($16)
-	addu	$6,$7,$4
-$L649:
+	addu	$6,$7,$fp
+	lhu	$4,2($21)
 	andi	$3,$2,0xffff
 	srl	$2,$2,16
 	subu	$6,$6,$3
-	lhu	$4,2($22)
 	subu	$6,$6,$2
 	lw	$3,36($16)
 	addu	$6,$6,$4
@@ -4220,7 +4594,7 @@ $L649:
 	addu	$6,$6,$2
 	.set	noreorder
 	.set	nomacro
-	bgez	$6,$L623
+	bgez	$6,$L574
 	andi	$2,$6,0xffff
 	.set	macro
 	.set	reorder
@@ -4234,51 +4608,54 @@ $L649:
 	nor	$2,$0,$6
 	.set	noreorder
 	.set	nomacro
-	j	$L618
+	j	$L569
 	sh	$2,0($17)
 	.set	macro
 	.set	reorder
 
-$L623:
+$L574:
 	sra	$3,$6,16
 	addu	$6,$3,$2
 	sra	$2,$6,16
 	addu	$6,$6,$2
 	sh	$6,0($17)
-$L618:
+$L569:
 	lw	$2,28($16)
-	sh	$2,0($22)
+	sh	$2,0($21)
 	lw	$2,36($16)
-	sh	$2,2($22)
-$L609:
+	sh	$2,2($21)
+$L560:
 	lw	$2,24($16)
 	sw	$2,12($18)
-$L643:
+$L594:
 	lw	$2,32($16)
 	sw	$2,16($18)
-$L542:
-	lw	$3,104($21)
-	li	$2,-805371904			# 0xcfff0000
-	ori	$2,$2,0xffff
-	and	$3,$3,$2
-	lw	$2,28($21)
-	sw	$3,104($21)
-	lw	$2,12($2)
-	sw	$2,24($21)
-	lw	$5,48($16)
-	lw	$6,52($16)
+$L491:
+	lw	$4,24($sp)
 	.set	noreorder
 	.set	nomacro
-	jal	fastpath_set_qos_mark
-	move	$4,$21
+	jal	rtl_set_skb_ip_summed
+	move	$5,$0
+	.set	macro
+	.set	reorder
+
+	lw	$4,24($sp)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_set_skb_dev
+	move	$5,$0
 	.set	macro
 	.set	reorder
 
+	lw	$4,24($sp)
+	lw	$5,48($16)
+	lw	$6,52($16)
+	jal	fastpath_set_qos_mark
 	lui	$2,%hi(jiffies)
 	lw	$2,%lo(jiffies)($2)
+	move	$5,$21
+	lw	$6,24($sp)
 	move	$4,$18
-	move	$5,$22
-	move	$6,$21
 	.set	noreorder
 	.set	nomacro
 	jal	fast_path_post_process_xmit_check
@@ -4289,33 +4666,29 @@ $L542:
 	li	$3,1			# 0x1
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$3,$L472
-	li	$4,1			# 0x1
+	beq	$2,$3,$L426
+	li	$5,1			# 0x1
 	.set	macro
 	.set	reorder
 
-	.set	noreorder
-	.set	nomacro
+	lw	$4,24($sp)
 	jal	ip_finish_output3
-	move	$4,$21
-	.set	macro
-	.set	reorder
-
 	.set	noreorder
 	.set	nomacro
-	j	$L472
-	li	$4,1			# 0x1
+	j	$L426
+	li	$5,1			# 0x1
 	.set	macro
 	.set	reorder
 
-$L509:
+$L461:
 	lw	$16,64($16)
-	j	$L637
-$L631:
-	lw	$2,24($21)
-	move	$5,$22
-	move	$6,$21
-	sw	$2,140($21)
+	j	$L590
+$L582:
+	lw	$4,24($sp)
+	jal	rtl_set_skb_inDev
+	move	$4,$18
+	lw	$6,24($sp)
+	move	$5,$21
 	lw	$31,84($sp)
 	lw	$fp,80($sp)
 	lw	$23,76($sp)
@@ -4333,9 +4706,13 @@ $L631:
 	.set	macro
 	.set	reorder
 
-$L472:
+$L586:
+	lw	$4,24($sp)
+	jal	rtl_dst_release
+	move	$5,$0
+$L426:
 	lw	$31,84($sp)
-	move	$2,$4
+	move	$2,$5
 	lw	$fp,80($sp)
 	lw	$23,76($sp)
 	lw	$22,72($sp)
@@ -4377,26 +4754,26 @@ fastpath_dump_napt_entry_num:
 	sw	$31,20($sp)
 	move	$16,$5
 	lw	$2,%lo(path_list_inuse)($2)
-$L666:
-	beq	$2,$0,$L663
+$L615:
+	beq	$2,$0,$L612
 	move	$6,$0
 
 	lw	$2,72($2)
-	j	$L666
+	j	$L615
 	addiu	$7,$7,1
 
-$L663:
+$L612:
 	lui	$2,%hi(napt_list_inuse)
 	lw	$2,%lo(napt_list_inuse)($2)
-$L667:
-	beq	$2,$0,$L665
+$L616:
+	beq	$2,$0,$L614
 	lui	$5,%hi($LC1)
 
 	lw	$2,44($2)
-	j	$L667
+	j	$L616
 	addiu	$6,$6,1
 
-$L665:
+$L614:
 	addu	$4,$4,$16
 	jal	sprintf
 	addiu	$5,$5,%lo($LC1)
@@ -4423,8 +4800,8 @@ init_table_napt:
 	.set	noreorder
 	.set	nomacro
 	
-$L673:
-$L714:
+$L622:
+$L663:
 	addiu	$sp,$sp,-64
 	lui	$2,%hi(malloc_sizes+4)
 	sw	$21,52($sp)
@@ -4444,11 +4821,11 @@ $L714:
 
 	li	$3,-1			# 0xffffffff
 	move	$17,$2
-	beq	$2,$0,$L668
+	beq	$2,$0,$L617
 	sw	$2,%lo(table_napt)($16)
 
-$L724:
-$L765:
+$L673:
+$L714:
 	lui	$2,%hi(napt_list_inuse)
 	lui	$20,%hi(napt_list_free)
 	sll	$4,$18,1
@@ -4470,22 +4847,22 @@ $L765:
 	sw	$2,0($17)
 	lw	$2,%lo(table_napt)($16)
 	lw	$2,0($2)
-	beq	$2,$0,$L668
+	beq	$2,$0,$L617
 	li	$3,-1			# 0xffffffff
 
-	j	$L768
+	j	$L717
 	move	$16,$0
 
-$L832:
-	j	$L668
+$L781:
+	j	$L617
 	li	$3,-2			# 0xfffffffe
 
-$L768:
-	blez	$18,$L829
+$L717:
+	blez	$18,$L778
 	nop
 
 	move	$4,$0
-$L773:
+$L722:
 	lw	$2,%lo(table_napt)($19)
 	addiu	$16,$16,1
 	slt	$3,$16,$18
@@ -4500,16 +4877,16 @@ $L773:
 	lw	$2,0($2)
 	addu	$2,$4,$2
 	addiu	$4,$4,12
-	bne	$3,$0,$L773
+	bne	$3,$0,$L722
 	sw	$2,4($2)
 
-$L829:
-	blez	$21,$L831
+$L778:
+	blez	$21,$L780
 	move	$16,$0
 
-$L827:
-$L781:
-$L822:
+$L776:
+$L730:
+$L771:
 	lui	$2,%hi(malloc_sizes+12)
 	li	$5,32			# 0x20
 	lw	$4,%lo(malloc_sizes+12)($2)
@@ -4519,7 +4896,7 @@ $L822:
 	addiu	$4,$20,%lo(napt_list_free)
 	move	$3,$2
 	addiu	$5,$2,44
-	beq	$2,$0,$L832
+	beq	$2,$0,$L781
 	slt	$6,$16,$21
 
 	sw	$0,44($2)
@@ -4530,12 +4907,12 @@ $L822:
 	lw	$2,8($4)
 	sw	$5,4($4)
 	addiu	$2,$2,1
-	bne	$6,$0,$L827
+	bne	$6,$0,$L776
 	sw	$2,8($4)
 
-$L831:
+$L780:
 	move	$3,$0
-$L668:
+$L617:
 	lw	$31,56($sp)
 	move	$2,$3
 	lw	$21,52($sp)
@@ -4563,8 +4940,8 @@ init_table_path:
 	.set	noreorder
 	.set	nomacro
 	
-$L838:
-$L879:
+$L787:
+$L828:
 	addiu	$sp,$sp,-64
 	lui	$2,%hi(malloc_sizes+4)
 	sw	$21,52($sp)
@@ -4584,11 +4961,11 @@ $L879:
 
 	li	$3,-1			# 0xffffffff
 	move	$17,$2
-	beq	$2,$0,$L833
+	beq	$2,$0,$L782
 	sw	$2,%lo(table_path)($16)
 
-$L889:
-$L930:
+$L838:
+$L879:
 	lui	$2,%hi(path_list_inuse)
 	lui	$20,%hi(path_list_free)
 	sll	$4,$18,1
@@ -4610,22 +4987,22 @@ $L930:
 	sw	$2,0($17)
 	lw	$2,%lo(table_path)($16)
 	lw	$2,0($2)
-	beq	$2,$0,$L833
+	beq	$2,$0,$L782
 	li	$3,-1			# 0xffffffff
 
-	j	$L933
+	j	$L882
 	move	$16,$0
 
-$L997:
-	j	$L833
+$L946:
+	j	$L782
 	li	$3,-2			# 0xfffffffe
 
-$L933:
-	blez	$18,$L994
+$L882:
+	blez	$18,$L943
 	nop
 
 	move	$4,$0
-$L938:
+$L887:
 	lw	$2,%lo(table_path)($19)
 	addiu	$16,$16,1
 	slt	$3,$16,$18
@@ -4640,16 +5017,16 @@ $L938:
 	lw	$2,0($2)
 	addu	$2,$4,$2
 	addiu	$4,$4,12
-	bne	$3,$0,$L938
+	bne	$3,$0,$L887
 	sw	$2,4($2)
 
-$L994:
-	blez	$21,$L996
+$L943:
+	blez	$21,$L945
 	move	$16,$0
 
-$L992:
-$L946:
-$L987:
+$L941:
+$L895:
+$L936:
 	lui	$2,%hi(malloc_sizes+20)
 	li	$5,32			# 0x20
 	lw	$4,%lo(malloc_sizes+20)($2)
@@ -4659,7 +5036,7 @@ $L987:
 	addiu	$4,$20,%lo(path_list_free)
 	move	$3,$2
 	addiu	$5,$2,72
-	beq	$2,$0,$L997
+	beq	$2,$0,$L946
 	slt	$6,$16,$21
 
 	sw	$0,72($2)
@@ -4670,12 +5047,12 @@ $L987:
 	lw	$2,8($4)
 	sw	$5,4($4)
 	addiu	$2,$2,1
-	bne	$6,$0,$L992
+	bne	$6,$0,$L941
 	sw	$2,8($4)
 
-$L996:
+$L945:
 	move	$3,$0
-$L833:
+$L782:
 	lw	$31,56($sp)
 	move	$2,$3
 	lw	$21,52($sp)
diff --git a/net/rtl/fastpath/98/filter.S b/net/rtl/fastpath/98/filter.S
index ea9dab8..35943ab 100644
--- a/net/rtl/fastpath/98/filter.S
+++ b/net/rtl/fastpath/98/filter.S
@@ -190,39 +190,42 @@ $LC3:
 	.type	need_filter, @function
 need_filter:
 	.set	nomips16
-	.frame	$sp,48,$31		# vars= 16, regs= 4/0, args= 16, gp= 0
-	.mask	0x80070000,-4
+	.frame	$sp,48,$31		# vars= 16, regs= 3/0, args= 16, gp= 0
+	.mask	0x80030000,-8
 	.fmask	0x00000000,0
 	addiu	$sp,$sp,-48
-	sw	$17,36($sp)
-	lui	$17,%hi(init_net)
 	sw	$16,32($sp)
+	sw	$17,36($sp)
+	sw	$31,40($sp)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_ip_hdr
 	lui	$16,%hi($LC0)
-	sw	$31,44($sp)
-	addiu	$5,$16,%lo($LC0)
-	sw	$18,40($sp)
-	lw	$18,156($4)
+	.set	macro
+	.set	reorder
+
+	addiu	$4,$16,%lo($LC0)
 	.set	noreorder
 	.set	nomacro
-	jal	__dev_get_by_name
-	addiu	$4,$17,%lo(init_net)
+	jal	rtl_get_dev_by_name
+	move	$17,$2
 	.set	macro
 	.set	reorder
 
-	beq	$2,$0,$L4
+	beq	$2,$0,$L2
 	lw	$2,292($2)
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L4
+	beq	$2,$0,$L2
 	sw	$2,16($sp)
 	.set	macro
 	.set	reorder
 
 	lw	$5,12($2)
-$L62:
+$L60:
 	.set	noreorder
 	.set	nomacro
-	beq	$5,$0,$L4
+	beq	$5,$0,$L2
 	addiu	$2,$16,%lo($LC0)
 	.set	macro
 	.set	reorder
@@ -243,19 +246,19 @@ $L62:
 3:	.set	at
 	.set	reorder
 #NO_APP
-	beq	$4,$0,$L10
+	beq	$4,$0,$L8
 	lw	$5,0($5)
-	j	$L62
-$L10:
+	j	$L60
+$L8:
 	.set	noreorder
 	.set	nomacro
-	beq	$5,$0,$L68
+	beq	$5,$0,$L66
 	lui	$16,%hi($LC1)
 	.set	macro
 	.set	reorder
 
 	lw	$3,20($5)
-	lw	$2,16($18)
+	lw	$2,16($17)
 	.set	noreorder
 	.set	nomacro
 	beq	$2,$3,$L1
@@ -263,38 +266,30 @@ $L10:
 	.set	macro
 	.set	reorder
 
-$L4:
+$L2:
 	lui	$16,%hi($LC1)
-$L68:
-	addiu	$4,$17,%lo(init_net)
-	addiu	$5,$16,%lo($LC1)
-	.set	noreorder
-	.set	nomacro
-	jal	__dev_get_by_name
-	lui	$17,%hi(init_net)
-	.set	macro
-	.set	reorder
-
+$L66:
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L17
-	addiu	$4,$17,%lo(init_net)
+	jal	rtl_get_dev_by_name
+	addiu	$4,$16,%lo($LC1)
 	.set	macro
 	.set	reorder
 
+	beq	$2,$0,$L15
 	lw	$2,292($2)
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L30
+	beq	$2,$0,$L28
 	sw	$2,20($sp)
 	.set	macro
 	.set	reorder
 
 	lw	$5,12($2)
-$L63:
+$L61:
 	.set	noreorder
 	.set	nomacro
-	beq	$5,$0,$L30
+	beq	$5,$0,$L28
 	addiu	$2,$16,%lo($LC1)
 	.set	macro
 	.set	reorder
@@ -315,49 +310,43 @@ $L63:
 3:	.set	at
 	.set	reorder
 #NO_APP
-	beq	$4,$0,$L23
+	beq	$4,$0,$L21
 	lw	$5,0($5)
-	j	$L63
-$L23:
+	j	$L61
+$L21:
 	.set	noreorder
 	.set	nomacro
-	beq	$5,$0,$L30
+	beq	$5,$0,$L28
 	move	$4,$0
 	.set	macro
 	.set	reorder
 
-	lw	$3,16($18)
+	lw	$3,16($17)
 	lw	$2,16($5)
-	j	$L67
-$L17:
+	j	$L65
+$L15:
 	lui	$16,%hi($LC2)
 	.set	noreorder
 	.set	nomacro
-	jal	__dev_get_by_name
-	addiu	$5,$16,%lo($LC2)
-	.set	macro
-	.set	reorder
-
-	.set	noreorder
-	.set	nomacro
-	beq	$2,$0,$L31
-	addiu	$4,$17,%lo(init_net)
+	jal	rtl_get_dev_by_name
+	addiu	$4,$16,%lo($LC2)
 	.set	macro
 	.set	reorder
 
+	beq	$2,$0,$L29
 	lw	$2,292($2)
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L30
+	beq	$2,$0,$L28
 	sw	$2,24($sp)
 	.set	macro
 	.set	reorder
 
 	lw	$5,12($2)
-$L64:
+$L62:
 	.set	noreorder
 	.set	nomacro
-	beq	$5,$0,$L30
+	beq	$5,$0,$L28
 	addiu	$2,$16,%lo($LC2)
 	.set	macro
 	.set	reorder
@@ -378,38 +367,32 @@ $L64:
 3:	.set	at
 	.set	reorder
 #NO_APP
-	beq	$4,$0,$L51
+	beq	$4,$0,$L49
 	lw	$5,0($5)
-	j	$L64
-$L31:
+	j	$L62
+$L29:
 	lui	$16,%hi($LC3)
 	.set	noreorder
 	.set	nomacro
-	jal	__dev_get_by_name
-	addiu	$5,$16,%lo($LC3)
-	.set	macro
-	.set	reorder
-
-	.set	noreorder
-	.set	nomacro
-	beq	$2,$0,$L1
-	li	$4,1			# 0x1
+	jal	rtl_get_dev_by_name
+	addiu	$4,$16,%lo($LC3)
 	.set	macro
 	.set	reorder
 
+	beq	$2,$0,$L28
 	lw	$2,292($2)
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L1
+	beq	$2,$0,$L28
 	sw	$2,28($sp)
 	.set	macro
 	.set	reorder
 
 	lw	$5,12($2)
-$L65:
+$L63:
 	.set	noreorder
 	.set	nomacro
-	beq	$5,$0,$L30
+	beq	$5,$0,$L28
 	addiu	$2,$16,%lo($LC3)
 	.set	macro
 	.set	reorder
@@ -430,27 +413,26 @@ $L65:
 3:	.set	at
 	.set	reorder
 #NO_APP
-	beq	$4,$0,$L51
+	beq	$4,$0,$L49
 	lw	$5,0($5)
-	j	$L65
-$L51:
+	j	$L63
+$L49:
 	.set	noreorder
 	.set	nomacro
-	beq	$5,$0,$L30
+	beq	$5,$0,$L28
 	move	$4,$0
 	.set	macro
 	.set	reorder
 
-	lw	$3,16($18)
+	lw	$3,16($17)
 	lw	$2,20($5)
-$L67:
+$L65:
 	beq	$3,$2,$L1
-$L30:
+$L28:
 	li	$4,1			# 0x1
 $L1:
-	lw	$31,44($sp)
+	lw	$31,40($sp)
 	move	$2,$4
-	lw	$18,40($sp)
 	lw	$17,36($sp)
 	lw	$16,32($sp)
 	.set	noreorder
@@ -476,42 +458,42 @@ str2hexnum:
 	
 	lbu	$3,0($4)
 	move	$7,$0
-$L82:
-	beq	$3,$0,$L81
+$L80:
+	beq	$3,$0,$L79
 	andi	$5,$3,0x00ff
 
 	addiu	$2,$5,-97
 	addiu	$3,$5,-48
 	sltu	$6,$2,6
 	sltu	$2,$3,10
-	beq	$2,$0,$L73
+	beq	$2,$0,$L71
 	addiu	$2,$5,-65
 
-	j	$L72
+	j	$L70
 	move	$5,$3
 
-$L73:
-	beq	$6,$0,$L75
+$L71:
+	beq	$6,$0,$L73
 	sltu	$2,$2,6
 
-	j	$L72
+	j	$L70
 	addiu	$5,$5,-87
 
-$L75:
-	bne	$2,$0,$L72
+$L73:
+	bne	$2,$0,$L70
 	addiu	$5,$5,-55
 
 	j	$31
 	li	$2,-1			# 0xffffffff
 
-$L72:
+$L70:
 	addiu	$4,$4,1
 	sll	$2,$7,4
 	lbu	$3,0($4)
-	j	$L82
+	j	$L80
 	addu	$7,$2,$5
 
-$L81:
+$L79:
 	j	$31
 	move	$2,$7
 
@@ -553,42 +535,42 @@ find_pattern:
 	sw	$31,52($sp)
 	sw	$0,0($21)
 	addu	$4,$19,$17
-$L110:
+$L108:
 	li	$2,13			# 0xd
 	lb	$5,0($4)
-	bne	$5,$2,$L87
+	bne	$5,$2,$L85
 	andi	$3,$16,0x1
 
-	beq	$3,$0,$L90
+	beq	$3,$0,$L88
 	addiu	$16,$16,1
 
-	j	$L106
+	j	$L104
 	move	$16,$0
 
-$L87:
+$L85:
 	li	$2,10			# 0xa
-	bne	$5,$2,$L91
+	bne	$5,$2,$L89
 	addiu	$16,$16,1
 
-	bne	$3,$0,$L109
+	bne	$3,$0,$L107
 	slt	$2,$16,4
 
-$L91:
-	j	$L106
+$L89:
+	j	$L104
 	move	$16,$0
 
-$L90:
+$L88:
 	slt	$2,$16,4
-$L109:
-	beq	$2,$0,$L83
+$L107:
+	beq	$2,$0,$L81
 	move	$2,$0
 
-$L106:
+$L104:
 	move	$5,$23
 	jal	memcmp
 	move	$6,$18
 
-	bne	$2,$0,$L86
+	bne	$2,$0,$L84
 	subu	$3,$22,$18
 
 	addu	$2,$17,$18
@@ -597,33 +579,33 @@ $L106:
 	move	$3,$2
 	addu	$2,$19,$2
 	lb	$2,0($2)
-$L108:
-	beq	$2,$20,$L105
+$L106:
+	beq	$2,$20,$L103
 	li	$2,1			# 0x1
 
 	sltu	$2,$22,$3
 	addiu	$3,$3,1
 	addiu	$5,$5,1
-	bne	$2,$0,$L85
+	bne	$2,$0,$L83
 	addu	$4,$19,$3
 
 	lb	$2,0($4)
-	j	$L108
+	j	$L106
 	nop
 
-$L105:
-	j	$L83
+$L103:
+	j	$L81
 	sw	$5,0($fp)
 
-$L86:
+$L84:
 	addiu	$17,$17,1
 	sltu	$2,$3,$17
-	beq	$2,$0,$L110
+	beq	$2,$0,$L108
 	addu	$4,$19,$17
 
-$L85:
-	move	$2,$0
 $L83:
+	move	$2,$0
+$L81:
 	lw	$31,52($sp)
 	lw	$fp,48($sp)
 	lw	$23,44($sp)
@@ -681,24 +663,32 @@ rtl_url_filter_fastpath:
 	sltu	$2,$2,2
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L111
+	bne	$2,$0,$L109
 	move	$4,$0
 	.set	macro
 	.set	reorder
 
-	lw	$16,156($16)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_ip_hdr
+	move	$4,$16
+	.set	macro
+	.set	reorder
+
+	lbu	$3,9($2)
+	move	$16,$2
 	li	$2,6			# 0x6
-	lbu	$3,9($16)
 	.set	noreorder
 	.set	nomacro
-	bne	$3,$2,$L111
-	lui	$3,%hi(malloc_sizes+68)
+	bne	$3,$2,$L109
+	move	$4,$0
 	.set	macro
 	.set	reorder
 
-$L121:
-$L162:
+$L117:
+$L158:
 	lbu	$2,0($16)
+	lui	$3,%hi(malloc_sizes+68)
 	lw	$4,%lo(malloc_sizes+68)($3)
 	li	$5,208			# 0xd0
 	andi	$2,$2,0xf
@@ -717,7 +707,7 @@ $L162:
 	move	$4,$0
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L111
+	beq	$2,$0,$L109
 	move	$17,$2
 	.set	macro
 	.set	reorder
@@ -739,7 +729,7 @@ $L162:
 
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L171
+	bne	$2,$0,$L167
 	lui	$6,%hi($LC5)
 	.set	macro
 	.set	reorder
@@ -760,12 +750,12 @@ $L162:
 	.set	macro
 	.set	reorder
 
-	beq	$2,$0,$L171
+	beq	$2,$0,$L167
 	lw	$2,40($sp)
 	lw	$4,44($sp)
 	.set	noreorder
 	.set	nomacro
-	beq	$4,$0,$L169
+	beq	$4,$0,$L165
 	addu	$3,$18,$2
 	.set	macro
 	.set	reorder
@@ -785,7 +775,7 @@ $L162:
 	.set	at
 	.set	reorder
 #NO_APP
-$L169:
+$L165:
 	lw	$2,44($sp)
 	move	$5,$16
 	addiu	$6,$21,%lo($LC4)
@@ -803,17 +793,17 @@ $L169:
 	.set	macro
 	.set	reorder
 
-	beq	$2,$0,$L171
+	beq	$2,$0,$L167
 	lw	$2,48($sp)
 	addiu	$5,$2,-9
 	.set	noreorder
 	.set	nomacro
-	bgtz	$5,$L170
+	bgtz	$5,$L166
 	sw	$5,48($sp)
 	.set	macro
 	.set	reorder
 
-$L171:
+$L167:
 	.set	noreorder
 	.set	nomacro
 	jal	kfree
@@ -823,12 +813,12 @@ $L171:
 
 	.set	noreorder
 	.set	nomacro
-	j	$L111
+	j	$L109
 	move	$4,$0
 	.set	macro
 	.set	reorder
 
-$L170:
+$L166:
 	lw	$3,44($sp)
 	lw	$2,40($sp)
 	addu	$3,$17,$3
@@ -871,37 +861,37 @@ $L170:
 	sltu	$16,$16,$2
 	.set	noreorder
 	.set	nomacro
-	bne	$16,$0,$L175
+	bne	$16,$0,$L171
 	move	$18,$2
 	.set	macro
 	.set	reorder
 
 	.set	noreorder
 	.set	nomacro
-	j	$L174
+	j	$L170
 	addu	$3,$17,$2
 	.set	macro
 	.set	reorder
 
-$L185:
+$L181:
 	.set	noreorder
 	.set	nomacro
-	j	$L175
+	j	$L171
 	li	$19,1			# 0x1
 	.set	macro
 	.set	reorder
 
-$L174:
+$L170:
 	lb	$2,0($3)
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L184
+	beq	$2,$0,$L180
 	move	$19,$0
 	.set	macro
 	.set	reorder
 
 	move	$16,$3
-$L181:
+$L177:
 	addu	$4,$17,$19
 	move	$5,$22
 	move	$6,$18
@@ -914,16 +904,16 @@ $L181:
 
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L185
+	beq	$2,$0,$L181
 	addiu	$19,$19,1
 	.set	macro
 	.set	reorder
 
 	lb	$2,0($16)
-	bne	$2,$0,$L181
-$L184:
+	bne	$2,$0,$L177
+$L180:
 	move	$19,$0
-$L175:
+$L171:
 	lui	$4,%hi(log_info)
 	lui	$5,%hi($LC6)
 	addiu	$4,$4,%lo(log_info)
@@ -943,7 +933,7 @@ $L175:
 	.set	reorder
 
 	sltu	$4,$0,$19
-$L111:
+$L109:
 	lw	$31,84($sp)
 	move	$2,$4
 	lw	$22,80($sp)
@@ -968,30 +958,47 @@ $L111:
 	.type	rtl_mac_filter_fastpath, @function
 rtl_mac_filter_fastpath:
 	.set	nomips16
-	.frame	$sp,0,$31		# vars= 0, regs= 0/0, args= 0, gp= 0
-	.mask	0x00000000,0
+	.frame	$sp,40,$31		# vars= 0, regs= 5/0, args= 16, gp= 0
+	.mask	0x800f0000,-8
 	.fmask	0x00000000,0
 	.set	noreorder
 	.set	nomacro
 	
-	lw	$7,160($4)
-	move	$6,$0
+	addiu	$sp,$sp,-40
+	sw	$19,28($sp)
+	move	$19,$4
+	sw	$18,24($sp)
+	move	$18,$5
+	sw	$17,20($sp)
+	move	$17,$0
+	sw	$31,32($sp)
+	sw	$16,16($sp)
+	addu	$2,$18,$17
 $L192:
-	addu	$2,$5,$6
-	addu	$3,$7,$6
-	lbu	$4,0($2)
-	lbu	$2,6($3)
-	bne	$4,$2,$L196
-	xori	$2,$6,0x6
-
-	addiu	$6,$6,1
-	slt	$2,$6,6
+	lbu	$16,0($2)
+	jal	rtl_skb_mac_header
+	move	$4,$19
+
+	addu	$2,$2,$17
+	lbu	$2,6($2)
+	bne	$16,$2,$L191
+	xori	$2,$17,0x6
+
+	addiu	$17,$17,1
+	slt	$2,$17,6
 	bne	$2,$0,$L192
-	xori	$2,$6,0x6
+	addu	$2,$18,$17
 
-$L196:
-	j	$31
+	xori	$2,$17,0x6
+$L191:
+	lw	$31,32($sp)
 	sltu	$2,$2,1
+	lw	$19,28($sp)
+	lw	$18,24($sp)
+	lw	$17,20($sp)
+	lw	$16,16($sp)
+	j	$31
+	addiu	$sp,$sp,40
 
 	.set	macro
 	.set	reorder
@@ -1002,30 +1009,37 @@ $L196:
 	.type	rtl_ip_range_filter_fastpath, @function
 rtl_ip_range_filter_fastpath:
 	.set	nomips16
-	.frame	$sp,0,$31		# vars= 0, regs= 0/0, args= 0, gp= 0
-	.mask	0x00000000,0
+	.frame	$sp,24,$31		# vars= 0, regs= 2/0, args= 16, gp= 0
+	.mask	0x80010000,-4
 	.fmask	0x00000000,0
 	.set	noreorder
 	.set	nomacro
 	
-	lw	$3,156($4)
-	move	$4,$5
-	lw	$2,0($5)
-	lw	$5,12($3)
+	addiu	$sp,$sp,-24
+	sw	$16,16($sp)
+	sw	$31,20($sp)
+	jal	rtl_ip_hdr
+	move	$16,$5
+
+	lw	$5,12($2)
+	lw	$2,0($16)
 	sltu	$2,$5,$2
-	bne	$2,$0,$L200
-	li	$6,1			# 0x1
+	bne	$2,$0,$L194
+	li	$3,1			# 0x1
 
-	lw	$2,4($4)
+	lw	$2,4($16)
 	sltu	$2,$2,$5
-	beq	$2,$0,$L197
+	beq	$2,$0,$L193
 	nop
 
-$L200:
-	move	$6,$0
-$L197:
+$L194:
+	move	$3,$0
+$L193:
+	lw	$31,20($sp)
+	move	$2,$3
+	lw	$16,16($sp)
 	j	$31
-	move	$2,$6
+	addiu	$sp,$sp,24
 
 	.set	macro
 	.set	reorder
@@ -1113,41 +1127,41 @@ rtl_schedule_filter_fastpath:
 	li	$2,1			# 0x1
 	sll	$2,$2,$9
 	andi	$4,$6,0x80
-	bne	$4,$0,$L203
+	bne	$4,$0,$L197
 	and	$3,$6,$2
 
-	beq	$3,$0,$L201
+	beq	$3,$0,$L195
 	move	$2,$0
 
-$L203:
+$L197:
 	lw	$2,0($16)
-	bne	$2,$0,$L206
+	bne	$2,$0,$L200
 	sltu	$3,$7,$2
 
 	lw	$2,4($16)
-	beq	$2,$0,$L205
+	beq	$2,$0,$L199
 	nop
 
-	j	$L208
+	j	$L202
 	sltu	$2,$2,$7
 
-$L206:
-	bne	$3,$0,$L201
+$L200:
+	bne	$3,$0,$L195
 	move	$2,$0
 
 	lw	$2,4($16)
 	sltu	$2,$2,$7
-$L208:
-	bne	$2,$0,$L202
+$L202:
+	bne	$2,$0,$L196
 	nop
 
-$L205:
-	j	$L201
+$L199:
+	j	$L195
 	li	$2,1			# 0x1
 
-$L202:
+$L196:
 	move	$2,$0
-$L201:
+$L195:
 	lw	$31,28($sp)
 	lw	$16,24($sp)
 	j	$31
@@ -1222,15 +1236,15 @@ filter_table_regist:
 	move	$19,$4
 	sw	$18,32($sp)
 	move	$18,$5
-	bne	$2,$0,$L213
+	bne	$2,$0,$L207
 	sw	$31,40($sp)
 
 	jal	filter_table_head_init
 	nop
 
-$L213:
-$L218:
-$L259:
+$L207:
+$L212:
+$L253:
 	lui	$2,%hi(malloc_sizes+4)
 	lw	$4,%lo(malloc_sizes+4)($2)
 	jal	kmem_cache_alloc
@@ -1309,8 +1323,8 @@ filter_table_read_proc:
 	.set	noreorder
 	.set	nomacro
 	
-$L271:
-$L312:
+$L265:
+$L306:
 	addiu	$sp,$sp,-88
 	lui	$2,%hi(malloc_sizes)
 	sw	$fp,80($sp)
@@ -1333,30 +1347,30 @@ $L312:
 	li	$5,208			# 0xd0
 
 	move	$19,$2
-	beq	$19,$0,$L266
+	beq	$19,$0,$L260
 	move	$2,$0
 
-$L320:
-$L361:
+$L314:
+$L355:
 	lw	$4,44($16)
 	jal	kmem_cache_alloc
 	li	$5,208			# 0xd0
 
-	bne	$2,$0,$L364
+	bne	$2,$0,$L358
 	move	$17,$2
 
 	jal	kfree
 	move	$4,$19
 
-	j	$L266
+	j	$L260
 	move	$2,$0
 
-$L364:
+$L358:
 	lui	$21,%hi(table_list_head)
 	lw	$18,%lo(table_list_head)($21)
 	addiu	$2,$21,%lo(table_list_head)
-$L403:
-	beq	$18,$2,$L391
+$L397:
+	beq	$18,$2,$L385
 	lui	$5,%hi($LC7)
 
 	lw	$7,24($18)
@@ -1368,31 +1382,31 @@ $L403:
 
 	li	$2,3			# 0x3
 	lw	$3,16($18)
-	beq	$3,$2,$L374
+	beq	$3,$2,$L368
 	sltu	$2,$3,4
 
-	beq	$2,$0,$L385
+	beq	$2,$0,$L379
 	li	$2,4			# 0x4
 
 	li	$2,2			# 0x2
-	beq	$3,$2,$L369
+	beq	$3,$2,$L363
 	lui	$5,%hi($LC15)
 
-	j	$L404
+	j	$L398
 	move	$4,$17
 
-$L385:
-	beq	$3,$2,$L379
+$L379:
+	beq	$3,$2,$L373
 	lui	$5,%hi($LC15)
 
-	j	$L384
+	j	$L378
 	move	$4,$17
 
-$L369:
+$L363:
 	lw	$16,8($18)
 	addiu	$20,$18,8
-$L399:
-	beq	$16,$20,$L367
+$L393:
+	beq	$16,$20,$L361
 	lui	$5,%hi($LC8)
 
 	lw	$6,20($16)
@@ -1424,14 +1438,14 @@ $L399:
 	move	$5,$17
 
 	lw	$16,0($16)
-	j	$L399
+	j	$L393
 	nop
 
-$L374:
+$L368:
 	lw	$16,8($18)
 	addiu	$20,$18,8
-$L400:
-	beq	$16,$20,$L367
+$L394:
+	beq	$16,$20,$L361
 	lui	$5,%hi($LC10)
 
 	lw	$6,20($16)
@@ -1454,14 +1468,14 @@ $L400:
 	move	$5,$17
 
 	lw	$16,0($16)
-	j	$L400
+	j	$L394
 	nop
 
-$L379:
+$L373:
 	lw	$16,8($18)
 	addiu	$20,$18,8
-$L401:
-	beq	$16,$20,$L367
+$L395:
+	beq	$16,$20,$L361
 	lui	$5,%hi($LC8)
 
 	lw	$6,20($16)
@@ -1504,11 +1518,11 @@ $L401:
 	move	$5,$17
 
 	lw	$16,0($16)
-	j	$L401
+	j	$L395
 	nop
 
-$L384:
-$L404:
+$L378:
+$L398:
 	jal	sprintf
 	addiu	$5,$5,%lo($LC15)
 
@@ -1516,12 +1530,12 @@ $L404:
 	jal	strcat
 	move	$5,$17
 
-$L367:
+$L361:
 	lw	$18,0($18)
-	j	$L403
+	j	$L397
 	addiu	$2,$21,%lo(table_list_head)
 
-$L391:
+$L385:
 	lui	$5,%hi($LC16)
 	move	$4,$fp
 	addiu	$5,$5,%lo($LC16)
@@ -1531,12 +1545,12 @@ $L391:
 	move	$16,$2
 	addu	$2,$22,$23
 	slt	$2,$2,$16
-	bne	$2,$0,$L387
+	bne	$2,$0,$L381
 	li	$3,1			# 0x1
 
 	lw	$2,104($sp)
 	sw	$3,0($2)
-$L387:
+$L381:
 	subu	$16,$16,$22
 	addu	$3,$fp,$22
 	slt	$2,$23,$16
@@ -1552,7 +1566,7 @@ $L387:
 	move	$4,$17
 
 	move	$2,$16
-$L266:
+$L260:
 	lw	$31,84($sp)
 	lw	$fp,80($sp)
 	lw	$23,76($sp)
@@ -1586,44 +1600,48 @@ scan_table:
 	sw	$23,44($sp)
 	move	$23,$5
 	sw	$22,40($sp)
-	li	$5,-1			# 0xffffffff
-	sw	$20,32($sp)
 	move	$22,$7
-	sw	$19,28($sp)
+	sw	$20,32($sp)
 	move	$20,$4
-	sw	$18,24($sp)
+	sw	$19,28($sp)
 	move	$19,$6
+	sw	$18,24($sp)
+	move	$18,$0
 	sw	$31,48($sp)
 	sw	$21,36($sp)
 	sw	$17,20($sp)
+	beq	$6,$0,$L435
 	sw	$16,16($sp)
+
 	lw	$2,28($6)
-	beq	$2,$0,$L405
-	move	$18,$0
+	beq	$2,$0,$L435
+	addiu	$21,$6,8
 
 	lw	$17,8($6)
-	addiu	$21,$6,8
-$L436:
-	beq	$17,$21,$L435
-	nop
+	beq	$17,$21,$L399
+	li	$5,-1			# 0xffffffff
 
+$L428:
 	lw	$3,16($17)
 	andi	$2,$3,0x1
-	bne	$2,$0,$L411
+	bne	$2,$0,$L406
 	move	$16,$17
 
 	lw	$2,20($17)
-	bne	$23,$2,$L409
+	bne	$23,$2,$L404
 	nop
 
-$L411:
+$L406:
 	andi	$2,$3,0x200
-	beq	$2,$0,$L412
+	beq	$2,$0,$L407
 	andi	$2,$3,0x100
 
 	andi	$2,$3,0x2
 	lw	$6,0($22)
-	beq	$2,$0,$L413
+	beq	$2,$0,$L408
+	nop
+
+	beq	$6,$0,$L435
 	move	$4,$20
 
 	lw	$5,20($16)
@@ -1631,67 +1649,75 @@ $L411:
 	move	$7,$6
 
 	move	$18,$2
-$L413:
-	beq	$18,$0,$L409
-	nop
-
-	j	$L405
+$L408:
+	beq	$18,$0,$L404
 	li	$5,1			# 0x1
 
-$L412:
-	bne	$2,$0,$L418
+	j	$L399
+	nop
+
+$L407:
+	bne	$2,$0,$L414
 	move	$4,$20
 
 	lw	$2,28($19)
 	jal	$2
 	addiu	$5,$16,28
 
-	beq	$2,$0,$L409
+	beq	$2,$0,$L404
 	nop
 
-$L418:
+$L414:
 	lw	$3,16($16)
 	andi	$2,$3,0x2
-	bne	$2,$0,$L419
-	move	$4,$20
-
+	bne	$2,$0,$L415
 	andi	$2,$3,0x1
+
 	j	$L438
 	li	$5,1			# 0x1
 
-$L419:
+$L415:
 	lw	$6,0($22)
+	beq	$6,$0,$L435
+	move	$4,$20
+
 	lw	$5,20($16)
 	jal	scan_table
 	move	$7,$6
 
-	beq	$2,$0,$L409
+	beq	$2,$0,$L404
 	move	$18,$2
 
 	lw	$3,16($16)
 	li	$5,1			# 0x1
 	andi	$2,$3,0x1
 $L438:
-	beq	$2,$0,$L405
+	beq	$2,$0,$L399
 	andi	$2,$3,0x8
 
-	j	$L405
+	j	$L399
 	sltu	$5,$2,1
 
-$L409:
+$L404:
 	lw	$17,0($17)
-	j	$L436
+	bne	$17,$21,$L428
 	nop
 
-$L435:
+	beq	$16,$0,$L399
+	li	$5,-1			# 0xffffffff
+
 	lw	$3,16($16)
 	andi	$2,$3,0x1
-	beq	$2,$0,$L405
+	beq	$2,$0,$L399
 	move	$5,$0
 
 	srl	$2,$3,3
+	j	$L399
 	andi	$5,$2,0x1
-$L405:
+
+$L435:
+	li	$5,-1			# 0xffffffff
+$L399:
 	lw	$31,48($sp)
 	move	$2,$5
 	lw	$23,44($sp)
@@ -1714,10 +1740,6 @@ $LC17:
 	.ascii	"[ip_range_filter]%d.%d.%d.%d ===> %d.%d.%d.%d  [Blocked]"
 	.ascii	"\n\000"
 	.align	2
-$LC20:
-	.ascii	"[schedule_filter]%d.%d.%d.%d ===> %d.%d.%d.%d  [Blocked]"
-	.ascii	"\n\000"
-	.align	2
 $LC18:
 	.ascii	"[mac_filter]%d.%d.%d.%d(%02x:%02x:%02x:%02x:%02x:%02x) ="
 	.ascii	"==> %d.%d.%d.%d [Blocked]\n\000"
@@ -1725,6 +1747,10 @@ $LC18:
 $LC19:
 	.ascii	"[url_key_filter]%d.%d.%d.%d ==> %d.%d.%d.%d(%s)  [Blocke"
 	.ascii	"d]\n\000"
+	.align	2
+$LC20:
+	.ascii	"[schedule_filter]%d.%d.%d.%d ===> %d.%d.%d.%d  [Blocked]"
+	.ascii	"\n\000"
 	.section	.text.log_fastFilter,"ax",@progbits
 	.align	2
 	.globl	log_fastFilter
@@ -1732,142 +1758,405 @@ $LC19:
 	.type	log_fastFilter, @function
 log_fastFilter:
 	.set	nomips16
-	.frame	$sp,88,$31		# vars= 8, regs= 3/0, args= 64, gp= 0
-	.mask	0x80030000,-8
+	.frame	$sp,176,$31		# vars= 8, regs= 8/0, args= 136, gp= 0
+	.mask	0x807f0000,-4
 	.fmask	0x00000000,0
 	.set	noreorder
 	.set	nomacro
 	
-	addiu	$sp,$sp,-88
-	sw	$16,72($sp)
+	addiu	$sp,$sp,-176
+	sw	$21,164($sp)
+	move	$21,$5
+	sw	$16,144($sp)
 	move	$16,$4
-	addiu	$4,$sp,64
-	sw	$17,76($sp)
-	sw	$31,80($sp)
+	addiu	$4,$sp,136
+	sw	$31,172($sp)
+	sw	$22,168($sp)
+	sw	$20,160($sp)
+	sw	$19,156($sp)
+	sw	$18,152($sp)
 	jal	do_gettimeofday
-	move	$17,$5
+	sw	$17,148($sp)
+
+	jal	rtl_ip_hdr
+	move	$4,$21
 
+	move	$4,$21
+	jal	rtl_eth_hdr
+	move	$22,$2
+
+	move	$3,$2
 	li	$2,2			# 0x2
-	lw	$13,156($17)
-	beq	$16,$2,$L444
+	beq	$16,$2,$L443
 	slt	$2,$16,3
 
-	beq	$2,$0,$L455
+	beq	$2,$0,$L452
 	li	$2,3			# 0x3
 
 	li	$2,1			# 0x1
-	beq	$16,$2,$L443
-	lui	$4,%hi($LC17)
+	beq	$16,$2,$L441
+	nop
 
-	j	$L442
+	j	$L440
 	nop
 
-$L455:
-	beq	$16,$2,$L451
+$L452:
+	beq	$16,$2,$L446
 	li	$2,4			# 0x4
 
-	beq	$16,$2,$L452
-	lui	$4,%hi($LC20)
+	beq	$16,$2,$L448
+	nop
 
-	j	$L442
+	j	$L440
 	nop
 
-$L443:
-	lw	$5,12($13)
-	j	$L457
+$L441:
+	beq	$22,$0,$L440
+	lui	$4,%hi($LC17)
+
+	lw	$5,12($22)
+	j	$L454
 	addiu	$4,$4,%lo($LC17)
 
-$L444:
-	lw	$2,160($17)
+$L443:
+	beq	$3,$0,$L440
+	nop
+
+	beq	$22,$0,$L440
+	nop
+
+	jal	rtl_eth_hdr
+	move	$4,$21
+
+	move	$4,$21
+	jal	rtl_eth_hdr
+	move	$16,$2
+
+	move	$4,$21
+	jal	rtl_eth_hdr
+	move	$17,$2
+
+	move	$4,$21
+	jal	rtl_eth_hdr
+	move	$18,$2
+
+	move	$4,$21
+	jal	rtl_eth_hdr
+	move	$19,$2
+
+	move	$4,$21
+	jal	rtl_eth_hdr
+	move	$20,$2
+
 	lui	$4,%hi($LC18)
-	lw	$5,12($13)
+	lw	$5,12($22)
 	addiu	$4,$4,%lo($LC18)
-	lbu	$12,11($2)
-	lbu	$11,6($2)
 	andi	$3,$5,0xff
-	lbu	$10,7($2)
 	srl	$6,$5,16
-	lbu	$9,8($2)
+	sw	$3,16($sp)
 	srl	$7,$5,8
-	lbu	$8,9($2)
+	lbu	$15,84($16)
 	srl	$5,$5,24
-	lbu	$2,10($2)
+	lbu	$9,85($16)
 	andi	$6,$6,0x00ff
-	sw	$3,16($sp)
+	lbu	$14,88($16)
+	sll	$15,$15,24
+	lbu	$8,89($16)
+	sll	$9,$9,16
+	lbu	$3,92($16)
+	sll	$14,$14,24
+	lbu	$12,93($16)
+	sll	$8,$8,16
+	lbu	$13,86($16)
+	or	$9,$9,$15
+	lbu	$10,90($16)
+	or	$8,$8,$14
+	lbu	$11,94($16)
+	sll	$3,$3,24
+	sll	$12,$12,16
+	sll	$13,$13,8
+	sll	$10,$10,8
+	or	$12,$12,$3
+	or	$13,$13,$9
+	or	$10,$10,$8
+	lbu	$9,87($16)
+	sll	$11,$11,8
+	lbu	$8,91($16)
+	or	$11,$11,$12
+	lbu	$3,95($16)
+	or	$9,$9,$13
+	or	$8,$8,$10
 	andi	$7,$7,0x00ff
-	sw	$11,20($sp)
-	sw	$10,24($sp)
-	sw	$9,28($sp)
-	sw	$8,32($sp)
-	sw	$2,36($sp)
-	sw	$12,40($sp)
-	lbu	$2,16($13)
-	sw	$2,44($sp)
-	lbu	$2,17($13)
-	sw	$2,48($sp)
-	lbu	$2,18($13)
-	sw	$2,52($sp)
-	lbu	$2,19($13)
+	or	$3,$3,$11
+	sw	$9,20($sp)
+	sw	$8,24($sp)
+	sw	$3,28($sp)
+	lbu	$3,96($16)
+	sb	$3,32($sp)
+	lbu	$3,97($16)
+	sb	$3,33($sp)
+	lbu	$15,98($17)
+	lbu	$9,99($17)
+	lbu	$14,102($17)
+	sll	$15,$15,24
+	lbu	$8,103($17)
+	sll	$9,$9,16
+	lbu	$3,106($17)
+	sll	$14,$14,24
+	lbu	$12,107($17)
+	sll	$8,$8,16
+	lbu	$13,100($17)
+	or	$9,$9,$15
+	lbu	$11,104($17)
+	or	$8,$8,$14
+	lbu	$10,108($17)
+	sll	$3,$3,24
+	sll	$12,$12,16
+	sll	$13,$13,8
+	sll	$11,$11,8
+	or	$12,$12,$3
+	or	$13,$13,$9
+	or	$11,$11,$8
+	lbu	$9,101($17)
+	sll	$10,$10,8
+	lbu	$8,105($17)
+	or	$10,$10,$12
+	lbu	$3,109($17)
+	or	$9,$9,$13
+	or	$8,$8,$11
+	or	$3,$3,$10
+	sw	$9,36($sp)
+	sw	$8,40($sp)
+	sw	$3,44($sp)
+	lbu	$3,110($17)
+	sb	$3,48($sp)
+	lbu	$3,111($17)
+	sb	$3,49($sp)
+	lbu	$15,112($18)
+	lbu	$9,113($18)
+	lbu	$14,116($18)
+	sll	$15,$15,24
+	lbu	$8,117($18)
+	sll	$9,$9,16
+	lbu	$3,120($18)
+	sll	$14,$14,24
+	lbu	$12,121($18)
+	sll	$8,$8,16
+	lbu	$13,114($18)
+	or	$9,$9,$15
+	lbu	$11,118($18)
+	or	$8,$8,$14
+	lbu	$10,122($18)
+	sll	$3,$3,24
+	sll	$12,$12,16
+	sll	$13,$13,8
+	sll	$11,$11,8
+	or	$12,$12,$3
+	or	$13,$13,$9
+	or	$11,$11,$8
+	lbu	$9,115($18)
+	sll	$10,$10,8
+	lbu	$8,119($18)
+	or	$10,$10,$12
+	lbu	$3,123($18)
+	or	$9,$9,$13
+	or	$8,$8,$11
+	or	$3,$3,$10
+	sw	$9,52($sp)
+	sw	$8,56($sp)
+	sw	$3,60($sp)
+	lbu	$3,124($18)
+	sb	$3,64($sp)
+	lbu	$3,125($18)
+	sb	$3,65($sp)
+	lbu	$15,126($19)
+	lbu	$9,127($19)
+	lbu	$14,130($19)
+	sll	$15,$15,24
+	lbu	$8,131($19)
+	sll	$9,$9,16
+	lbu	$3,134($19)
+	sll	$14,$14,24
+	lbu	$12,135($19)
+	sll	$8,$8,16
+	lbu	$13,128($19)
+	or	$9,$9,$15
+	lbu	$11,132($19)
+	or	$8,$8,$14
+	lbu	$10,136($19)
+	sll	$3,$3,24
+	sll	$12,$12,16
+	sll	$13,$13,8
+	sll	$11,$11,8
+	or	$12,$12,$3
+	or	$13,$13,$9
+	or	$11,$11,$8
+	lbu	$9,129($19)
+	sll	$10,$10,8
+	lbu	$8,133($19)
+	or	$10,$10,$12
+	lbu	$3,137($19)
+	or	$9,$9,$13
+	or	$8,$8,$11
+	or	$3,$3,$10
+	sw	$9,68($sp)
+	sw	$8,72($sp)
+	sw	$3,76($sp)
+	lbu	$3,138($19)
+	sb	$3,80($sp)
+	lbu	$3,139($19)
+	sb	$3,81($sp)
+	lbu	$15,140($20)
+	lbu	$9,141($20)
+	lbu	$14,144($20)
+	sll	$15,$15,24
+	lbu	$8,145($20)
+	sll	$9,$9,16
+	lbu	$3,148($20)
+	sll	$14,$14,24
+	lbu	$12,149($20)
+	sll	$8,$8,16
+	lbu	$13,142($20)
+	or	$9,$9,$15
+	lbu	$11,146($20)
+	or	$8,$8,$14
+	lbu	$10,150($20)
+	sll	$3,$3,24
+	sll	$12,$12,16
+	sll	$13,$13,8
+	sll	$11,$11,8
+	or	$12,$12,$3
+	or	$13,$13,$9
+	or	$11,$11,$8
+	lbu	$9,143($20)
+	sll	$10,$10,8
+	lbu	$8,147($20)
+	or	$10,$10,$12
+	lbu	$3,151($20)
+	or	$9,$9,$13
+	or	$8,$8,$11
+	or	$3,$3,$10
+	sw	$9,84($sp)
+	sw	$8,88($sp)
+	sw	$3,92($sp)
+	lbu	$3,152($20)
+	sb	$3,96($sp)
+	lbu	$3,153($20)
+	sb	$3,97($sp)
+	lbu	$15,154($2)
+	lbu	$9,155($2)
+	lbu	$14,158($2)
+	sll	$15,$15,24
+	lbu	$8,159($2)
+	sll	$9,$9,16
+	lbu	$3,162($2)
+	sll	$14,$14,24
+	lbu	$12,163($2)
+	sll	$8,$8,16
+	lbu	$13,156($2)
+	or	$9,$9,$15
+	lbu	$11,160($2)
+	or	$8,$8,$14
+	lbu	$10,164($2)
+	sll	$3,$3,24
+	sll	$12,$12,16
+	sll	$13,$13,8
+	sll	$11,$11,8
+	or	$12,$12,$3
+	or	$13,$13,$9
+	or	$11,$11,$8
+	lbu	$9,157($2)
+	sll	$10,$10,8
+	lbu	$8,161($2)
+	or	$10,$10,$12
+	lbu	$3,165($2)
+	or	$9,$9,$13
+	or	$8,$8,$11
+	or	$3,$3,$10
+	sw	$9,100($sp)
+	sw	$8,104($sp)
+	sw	$3,108($sp)
+	lbu	$3,166($2)
+	sb	$3,112($sp)
+	lbu	$2,167($2)
+	sb	$2,113($sp)
+	lbu	$2,16($22)
+	sw	$2,116($sp)
+	lbu	$2,17($22)
+	sw	$2,120($sp)
+	lbu	$2,18($22)
+	sw	$2,124($sp)
+	lbu	$2,19($22)
 	jal	scrlog_printk
-	sw	$2,56($sp)
+	sw	$2,128($sp)
 
-	j	$L442
+	j	$L440
 	nop
 
-$L451:
-	lw	$5,12($13)
+$L446:
+	beq	$22,$0,$L440
 	lui	$4,%hi($LC19)
+
+	lw	$5,12($22)
 	addiu	$4,$4,%lo($LC19)
 	andi	$2,$5,0xff
 	srl	$6,$5,16
 	sw	$2,16($sp)
 	srl	$7,$5,8
-	lbu	$2,16($13)
+	lbu	$2,16($22)
 	srl	$5,$5,24
 	andi	$6,$6,0x00ff
 	andi	$7,$7,0x00ff
 	sw	$2,20($sp)
-	lbu	$2,17($13)
+	lbu	$2,17($22)
 	sw	$2,24($sp)
-	lbu	$2,18($13)
+	lbu	$2,18($22)
 	sw	$2,28($sp)
 	lui	$2,%hi(log_info)
-	lbu	$3,19($13)
+	lbu	$3,19($22)
 	addiu	$2,$2,%lo(log_info)
 	sw	$2,36($sp)
-	j	$L456
+	j	$L453
 	sw	$3,32($sp)
 
-$L452:
-	lw	$5,12($13)
+$L448:
+	beq	$22,$0,$L440
+	lui	$4,%hi($LC20)
+
+	lw	$5,12($22)
 	addiu	$4,$4,%lo($LC20)
-$L457:
+$L454:
 	andi	$2,$5,0xff
 	srl	$6,$5,16
 	sw	$2,16($sp)
 	srl	$7,$5,8
-	lbu	$2,16($13)
+	lbu	$2,16($22)
 	srl	$5,$5,24
 	andi	$6,$6,0x00ff
 	andi	$7,$7,0x00ff
 	sw	$2,20($sp)
-	lbu	$2,17($13)
+	lbu	$2,17($22)
 	sw	$2,24($sp)
-	lbu	$2,18($13)
+	lbu	$2,18($22)
 	sw	$2,28($sp)
-	lbu	$2,19($13)
+	lbu	$2,19($22)
 	sw	$2,32($sp)
-$L456:
+$L453:
 	jal	scrlog_printk
 	nop
 
-$L442:
-	lw	$31,80($sp)
+$L440:
+	lw	$31,172($sp)
 	move	$2,$0
-	lw	$17,76($sp)
-	lw	$16,72($sp)
+	lw	$22,168($sp)
+	lw	$21,164($sp)
+	lw	$20,160($sp)
+	lw	$19,156($sp)
+	lw	$18,152($sp)
+	lw	$17,148($sp)
+	lw	$16,144($sp)
 	j	$31
-	addiu	$sp,$sp,88
+	addiu	$sp,$sp,176
 
 	.set	macro
 	.set	reorder
@@ -1893,11 +2182,11 @@ do_filter:
 	lw	$16,%lo(table_list_head)($17)
 	sw	$18,24($sp)
 	move	$18,$4
-	beq	$16,$2,$L468
+	beq	$16,$2,$L465
 	sw	$31,28($sp)
 
 	move	$4,$18
-$L469:
+$L466:
 	move	$6,$16
 	move	$7,$16
 	jal	scan_table
@@ -1905,33 +2194,33 @@ $L469:
 
 	move	$3,$2
 	li	$2,-1			# 0xffffffff
-	beq	$3,$2,$L468
+	beq	$3,$2,$L465
 	addiu	$4,$17,%lo(table_list_head)
 
 	li	$2,1			# 0x1
-	bne	$3,$2,$L461
+	bne	$3,$2,$L458
 	lui	$2,%hi(log_enable)
 
 	lw	$2,%lo(log_enable)($2)
-	beq	$2,$0,$L465
+	beq	$2,$0,$L462
 	nop
 
 	lw	$4,16($16)
 	jal	log_fastFilter
 	move	$5,$18
 
-$L465:
-	j	$L458
+$L462:
+	j	$L455
 	li	$2,1			# 0x1
 
-$L461:
+$L458:
 	lw	$16,0($16)
-	bne	$16,$4,$L469
+	bne	$16,$4,$L466
 	move	$4,$18
 
-$L468:
+$L465:
 	move	$2,$0
-$L458:
+$L455:
 	lw	$31,28($sp)
 	lw	$18,24($sp)
 	lw	$17,20($sp)
@@ -1958,10 +2247,13 @@ FilterWeb_v2:
 	addiu	$sp,$sp,-24
 	sw	$16,16($sp)
 	sw	$31,20($sp)
-	jal	need_filter
+	jal	rtl_ip_hdr
 	move	$16,$4
 
-	beq	$2,$0,$L474
+	jal	need_filter
+	move	$4,$16
+
+	beq	$2,$0,$L469
 	move	$4,$16
 
 	lw	$31,20($sp)
@@ -1969,7 +2261,7 @@ FilterWeb_v2:
 	j	do_filter
 	addiu	$sp,$sp,24
 
-$L474:
+$L469:
 	lw	$31,20($sp)
 	lw	$16,16($sp)
 	j	$31
@@ -2009,7 +2301,7 @@ filter_table_init:
 	lui	$5,%hi(res12)
 	move	$4,$2
 	sw	$2,%lo(res12)($5)
-	beq	$4,$0,$L476
+	beq	$4,$0,$L471
 	move	$2,$0
 
 	lui	$3,%hi(filter_table_read_proc)
@@ -2019,7 +2311,7 @@ filter_table_init:
 	lw	$4,%lo(res12)($5)
 	addiu	$3,$3,%lo(filter_table_write_proc)
 	sw	$3,68($4)
-$L476:
+$L471:
 	lw	$31,16($sp)
 	j	$31
 	addiu	$sp,$sp,24
@@ -2075,14 +2367,14 @@ filter_exit_fastpath:
 	lw	$2,%lo(res12)($16)
 	addiu	$4,$4,%lo($LC22)
 	sw	$31,20($sp)
-	beq	$2,$0,$L479
+	beq	$2,$0,$L474
 	move	$5,$2
 
 	jal	remove_proc_entry
 	nop
 
 	sw	$0,%lo(res12)($16)
-$L479:
+$L474:
 	lw	$31,20($sp)
 	lw	$16,16($sp)
 	j	$31
@@ -2101,62 +2393,98 @@ $LC23:
 	.type	GenerateTCPENDACK, @function
 GenerateTCPENDACK:
 	.set	nomips16
-	.frame	$sp,104,$31		# vars= 48, regs= 10/0, args= 16, gp= 0
+	.frame	$sp,112,$31		# vars= 56, regs= 10/0, args= 16, gp= 0
 	.mask	0xc0ff0000,-4
 	.fmask	0x00000000,0
-	addiu	$sp,$sp,-104
-	lui	$5,%hi($LC0)
-	sw	$fp,96($sp)
-	move	$fp,$4
-	lui	$4,%hi(init_net)
-	addiu	$5,$5,%lo($LC0)
-	addiu	$4,$4,%lo(init_net)
-	sw	$31,100($sp)
-	sw	$23,92($sp)
-	sw	$18,72($sp)
-	sw	$17,68($sp)
-	sw	$22,88($sp)
-	sw	$21,84($sp)
-	sw	$20,80($sp)
-	sw	$19,76($sp)
+	addiu	$sp,$sp,-112
+	sw	$4,112($sp)
+	lui	$4,%hi($LC0)
+	addiu	$4,$4,%lo($LC0)
+	sw	$31,108($sp)
+	sw	$23,100($sp)
+	sw	$20,88($sp)
+	sw	$18,80($sp)
+	sw	$16,72($sp)
+	sw	$fp,104($sp)
+	sw	$22,96($sp)
+	sw	$21,92($sp)
+	sw	$19,84($sp)
 	.set	noreorder
 	.set	nomacro
-	jal	__dev_get_by_name
-	sw	$16,64($sp)
+	jal	rtl_get_dev_by_name
+	sw	$17,76($sp)
 	.set	macro
 	.set	reorder
 
-	lui	$4,%hi(arp_tbl)
-	lw	$23,156($fp)
-	move	$6,$2
-	addiu	$4,$4,%lo(arp_tbl)
-	lbu	$2,0($23)
-	addiu	$5,$23,12
+	lw	$4,112($sp)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_ip_hdr
+	move	$16,$2
+	.set	macro
+	.set	reorder
+
+	move	$5,$16
+	move	$23,$2
+	lbu	$2,0($2)
+	addiu	$4,$23,12
 	andi	$2,$2,0xf
 	sll	$2,$2,2
 	.set	noreorder
 	.set	nomacro
-	jal	neigh_lookup
-	addu	$18,$23,$2
+	jal	rtl_neigh_lookup
+	addu	$20,$23,$2
 	.set	macro
 	.set	reorder
 
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L480
-	move	$17,$2
+	beq	$2,$0,$L475
+	move	$18,$2
 	.set	macro
 	.set	reorder
 
-	lw	$2,68($2)
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L480
-	move	$4,$fp
+	jal	rtl_get_hh_from_neigh
+	move	$4,$2
 	.set	macro
 	.set	reorder
 
+	.set	noreorder
+	.set	nomacro
+	bne	$2,$0,$L476
 	li	$5,32			# 0x20
+	.set	macro
+	.set	reorder
+
+#APP
+	   
+
+	1:	ll	$3, 72($18)		# atomic_sub_return	
+       nop                                             
+	subu	$2, $3, 1				
+	sc	$2, 72($18)					
+	beqz	$2, 2f					
+	subu	$2, $3, 1				
+	.subsection 2					
+2:	b	1b					
+	.previous					
+
+	   
+
+#NO_APP
+	bne	$2,$0,$L475
+	.set	noreorder
+	.set	nomacro
+	jal	neigh_destroy
+	move	$4,$18
+	.set	macro
+	.set	reorder
+
+	j	$L475
+$L476:
+	lw	$4,112($sp)
 	move	$6,$0
 	.set	noreorder
 	.set	nomacro
@@ -2167,11 +2495,36 @@ GenerateTCPENDACK:
 
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L485
+	bne	$2,$0,$L482
 	move	$22,$2
 	.set	macro
 	.set	reorder
 
+#APP
+	   
+
+	1:	ll	$3, 72($18)		# atomic_sub_return	
+       nop                                             
+	subu	$2, $3, 1				
+	sc	$2, 72($18)					
+	beqz	$2, 2f					
+	subu	$2, $3, 1				
+	.subsection 2					
+2:	b	1b					
+	.previous					
+
+	   
+
+#NO_APP
+	bne	$2,$0,$L483
+	.set	noreorder
+	.set	nomacro
+	jal	neigh_destroy
+	move	$4,$18
+	.set	macro
+	.set	reorder
+
+$L483:
 	lui	$4,%hi($LC23)
 	.set	noreorder
 	.set	nomacro
@@ -2180,9 +2533,15 @@ GenerateTCPENDACK:
 	.set	macro
 	.set	reorder
 
-	j	$L480
-$L485:
-	lw	$2,156($2)
+	j	$L475
+$L482:
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_ip_hdr
+	move	$4,$2
+	.set	macro
+	.set	reorder
+
 	move	$4,$22
 	lbu	$5,0($2)
 	andi	$5,$5,0xf
@@ -2202,34 +2561,70 @@ $L485:
 	.set	macro
 	.set	reorder
 
-	lw	$16,68($17)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_hh_from_neigh
+	move	$4,$18
+	.set	macro
+	.set	reorder
+
+	addiu	$4,$sp,64
+	move	$5,$2
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_lock_from_hh
+	move	$17,$2
+	.set	macro
+	.set	reorder
+
 	jal	local_bh_disable
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_data
+	move	$4,$22
+	.set	macro
+	.set	reorder
+
+	move	$4,$17
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_data_from_hh
+	addiu	$16,$2,-16
+	.set	macro
+	.set	reorder
+
 	li	$6,16			# 0x10
-	lw	$4,176($22)
-	addiu	$5,$16,20
+	move	$4,$16
 	.set	noreorder
 	.set	nomacro
 	jal	memcpy
-	addiu	$4,$4,-16
+	move	$5,$2
 	.set	macro
 	.set	reorder
 
 	jal	local_bh_enable
-	lhu	$5,10($16)
 	.set	noreorder
 	.set	nomacro
-	jal	skb_push
+	jal	rtl_get_len_from_hh
+	move	$4,$17
+	.set	macro
+	.set	reorder
+
 	move	$4,$22
+	.set	noreorder
+	.set	nomacro
+	jal	skb_push
+	move	$5,$2
 	.set	macro
 	.set	reorder
 
 #APP
 	   
 
-	1:	ll	$3, 72($17)		# atomic_sub_return	
+	1:	ll	$3, 72($18)		# atomic_sub_return	
        nop                                             
 	subu	$2, $3, 1				
-	sc	$2, 72($17)					
+	sc	$2, 72($18)					
 	beqz	$2, 2f					
 	subu	$2, $3, 1				
 	.subsection 2					
@@ -2239,39 +2634,45 @@ $L485:
 	   
 
 #NO_APP
-	bne	$2,$0,$L495
+	bne	$2,$0,$L494
 	.set	noreorder
 	.set	nomacro
 	jal	neigh_destroy
-	move	$4,$17
+	move	$4,$18
+	.set	macro
+	.set	reorder
+
+$L494:
+	move	$5,$0
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_set_skb_nfct
+	move	$4,$22
 	.set	macro
 	.set	reorder
 
-$L495:
-	sw	$0,112($22)
 	li	$19,268369920			# 0xfff0000
-	lhu	$2,2($18)
+	lhu	$2,2($20)
 	ori	$19,$19,0xffff
 	lw	$3,52($sp)
-	addiu	$20,$sp,40
+	lui	$fp,%hi(url_cache)
 	sh	$2,40($sp)
 	li	$2,1342177280			# 0x50000000
 	and	$3,$3,$19
-	move	$4,$20
+	addiu	$21,$fp,%lo(url_cache)
 	or	$3,$3,$2
-	lui	$2,%hi(url_cache)
-	lw	$9,8($18)
-	addiu	$21,$2,%lo(url_cache)
-	lhu	$8,0($18)
 	li	$2,-327680			# 0xfffb0000
-	lw	$5,4($18)
+	lw	$8,8($20)
 	ori	$2,$2,0xffff
+	lhu	$7,0($20)
+	move	$4,$22
+	lw	$5,4($20)
+	addiu	$20,$sp,40
 	sw	$3,52($sp)
-	move	$6,$0
 	sb	$0,53($sp)
 	addiu	$5,$5,1
 	lw	$3,52($sp)
-	lhu	$7,12($21)
+	lhu	$6,12($21)
 	and	$3,$3,$2
 	li	$2,1048576			# 0x100000
 	or	$3,$3,$2
@@ -2279,16 +2680,23 @@ $L495:
 	ori	$2,$2,0xffff
 	and	$3,$3,$2
 	sw	$3,52($sp)
-	sh	$8,42($sp)
-	sh	$7,54($sp)
-	sw	$9,44($sp)
+	sh	$7,42($sp)
+	sw	$8,44($sp)
 	sw	$5,48($sp)
+	sh	$6,54($sp)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_len
 	sh	$0,58($sp)
-	lw	$17,84($22)
-	sh	$0,56($sp)
-	addiu	$17,$17,-34
+	.set	macro
+	.set	reorder
+
+	move	$6,$0
+	addiu	$17,$2,-34
+	move	$4,$20
 	move	$5,$17
 	andi	$17,$17,0xffff
+	sh	$0,56($sp)
 	lw	$18,12($23)
 	lw	$16,16($23)
 	.set	noreorder
@@ -2298,7 +2706,7 @@ $L495:
 	.set	macro
 	.set	reorder
 
-	move	$5,$20
+	move	$4,$22
 #APP
 		.set	push		# csum_tcpudp_nofold
 	.set	noat		
@@ -2322,19 +2730,25 @@ $L495:
 	xori	$16, 0xffff	
 	.set	pop
 #NO_APP
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_data
 	sh	$16,56($sp)
-	li	$6,20			# 0x14
-	lw	$4,176($22)
+	.set	macro
+	.set	reorder
+
+	move	$5,$20
+	addiu	$4,$2,34
 	.set	noreorder
 	.set	nomacro
 	jal	memcpy
-	addiu	$4,$4,34
+	li	$6,20			# 0x14
 	.set	macro
 	.set	reorder
 
 	li	$2,1073741824			# 0x40000000
 	lw	$3,16($sp)
-	addiu	$7,$sp,16
+	move	$5,$0
 	lbu	$6,14($21)
 	and	$3,$3,$19
 	or	$3,$3,$2
@@ -2345,78 +2759,86 @@ $L495:
 	or	$3,$3,$2
 	sw	$3,16($sp)
 	lw	$2,12($23)
-	lw	$3,104($fp)
+	lw	$4,112($sp)
 	sw	$2,32($sp)
-	li	$2,-805371904			# 0xcfff0000
-	ori	$2,$2,0xffff
-	and	$3,$3,$2
-	lw	$5,16($23)
-	sw	$3,104($fp)
-	lui	$3,%hi(url_cache)
-	lhu	$2,%lo(url_cache)($3)
-	li	$3,40
-	sh	$3,18($sp)
-	addiu	$2,$2,1
-	sh	$2,20($sp)
 	li	$2,6			# 0x6
+	lw	$3,16($23)
+	sb	$2,25($sp)
+	sw	$3,28($sp)
+	sb	$6,24($sp)
 	sh	$0,22($sp)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_set_skb_ip_summed
 	sb	$0,17($sp)
+	.set	macro
+	.set	reorder
+
+	li	$2,40
+	lhu	$3,%lo(url_cache)($fp)
+	addiu	$6,$sp,16
+	sh	$2,18($sp)
+	addiu	$3,$3,1
+	sh	$3,20($sp)
 	lw	$3,16($sp)
 	lw	$4,20($sp)
-	sb	$2,25($sp)
 	srl	$2,$3,22
-	sb	$6,24($sp)
-	addu	$6,$3,$4
-	sh	$0,26($sp)
-	sltu	$4,$6,$4
-	lw	$3,24($sp)
-	addu	$6,$6,$4
+	addu	$5,$3,$4
 	andi	$2,$2,0x3c
-	addu	$6,$6,$3
-	addu	$8,$7,$2
-	sltu	$4,$6,$3
-	addiu	$7,$sp,32
-	addu	$6,$6,$4
-	addu	$6,$6,$5
-	sltu	$4,$6,$5
-	addu	$6,$6,$4
-	sw	$5,28($sp)
-$L499:
-	lw	$2,0($7)
-	addiu	$7,$7,4
-	addu	$6,$6,$2
-	sltu	$4,$6,$2
+	sh	$0,26($sp)
+	sltu	$4,$5,$4
+	addu	$7,$6,$2
+	addu	$5,$5,$4
+	lw	$2,24($sp)
+	addiu	$6,$sp,32
+	lw	$3,28($sp)
+	addu	$5,$5,$2
+	sltu	$4,$5,$2
+	addu	$5,$5,$4
+	addu	$5,$5,$3
+	sltu	$4,$5,$3
+	addu	$5,$5,$4
+$L498:
+	lw	$2,0($6)
+	addiu	$6,$6,4
+	addu	$5,$5,$2
+	sltu	$4,$5,$2
 	.set	noreorder
 	.set	nomacro
-	bne	$7,$8,$L499
-	addu	$6,$6,$4
+	bne	$6,$7,$L498
+	addu	$5,$5,$4
 	.set	macro
 	.set	reorder
 
+	move	$4,$22
 #APP
 		.set	push		# csum_fold
 	.set	noat		
-	sll	$1, $6, 16	
-	addu	$6, $1		
-	sltu	$1, $6, $1	
-	srl	$6, $6, 16	
-	addu	$6, $1		
-	xori	$6, 0xffff	
+	sll	$1, $5, 16	
+	addu	$5, $1		
+	sltu	$1, $5, $1	
+	srl	$5, $5, 16	
+	addu	$5, $1		
+	xori	$5, 0xffff	
 	.set	pop
 #NO_APP
-	sh	$6,26($sp)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_data
+	sh	$5,26($sp)
+	.set	macro
+	.set	reorder
+
 	addiu	$5,$sp,16
-	lw	$4,176($22)
-	li	$6,20			# 0x14
+	addiu	$4,$2,14
 	.set	noreorder
 	.set	nomacro
 	jal	memcpy
-	addiu	$4,$4,14
+	li	$6,20			# 0x14
 	.set	macro
 	.set	reorder
 
-	lui	$3,%hi(url_cache)
-	addiu	$2,$3,%lo(url_cache)
+	addiu	$2,$fp,%lo(url_cache)
 	move	$4,$22
 	.set	noreorder
 	.set	nomacro
@@ -2425,22 +2847,22 @@ $L499:
 	.set	macro
 	.set	reorder
 
-$L480:
-	lw	$31,100($sp)
+$L475:
+	lw	$31,108($sp)
 	move	$2,$0
-	lw	$fp,96($sp)
-	lw	$23,92($sp)
-	lw	$22,88($sp)
-	lw	$21,84($sp)
-	lw	$20,80($sp)
-	lw	$19,76($sp)
-	lw	$18,72($sp)
-	lw	$17,68($sp)
-	lw	$16,64($sp)
+	lw	$fp,104($sp)
+	lw	$23,100($sp)
+	lw	$22,96($sp)
+	lw	$21,92($sp)
+	lw	$20,88($sp)
+	lw	$19,84($sp)
+	lw	$18,80($sp)
+	lw	$17,76($sp)
+	lw	$16,72($sp)
 	.set	noreorder
 	.set	nomacro
 	j	$31
-	addiu	$sp,$sp,104
+	addiu	$sp,$sp,112
 	.set	macro
 	.set	reorder
 
@@ -2451,92 +2873,159 @@ $L480:
 	.type	GenerateTCPFINACK, @function
 GenerateTCPFINACK:
 	.set	nomips16
-	.frame	$sp,104,$31		# vars= 48, regs= 10/0, args= 16, gp= 0
+	.frame	$sp,112,$31		# vars= 56, regs= 10/0, args= 16, gp= 0
 	.mask	0xc0ff0000,-4
 	.fmask	0x00000000,0
-	addiu	$sp,$sp,-104
-	lui	$5,%hi($LC0)
-	sw	$fp,96($sp)
-	move	$fp,$4
-	lui	$4,%hi(init_net)
-	addiu	$5,$5,%lo($LC0)
-	addiu	$4,$4,%lo(init_net)
-	sw	$31,100($sp)
-	sw	$23,92($sp)
-	sw	$18,72($sp)
-	sw	$17,68($sp)
-	sw	$22,88($sp)
-	sw	$21,84($sp)
-	sw	$20,80($sp)
-	sw	$19,76($sp)
+	addiu	$sp,$sp,-112
+	sw	$4,112($sp)
+	lui	$4,%hi($LC0)
+	addiu	$4,$4,%lo($LC0)
+	sw	$31,108($sp)
+	sw	$23,100($sp)
+	sw	$20,88($sp)
+	sw	$18,80($sp)
+	sw	$16,72($sp)
+	sw	$fp,104($sp)
+	sw	$22,96($sp)
+	sw	$21,92($sp)
+	sw	$19,84($sp)
 	.set	noreorder
 	.set	nomacro
-	jal	__dev_get_by_name
-	sw	$16,64($sp)
+	jal	rtl_get_dev_by_name
+	sw	$17,76($sp)
 	.set	macro
 	.set	reorder
 
-	lui	$4,%hi(arp_tbl)
-	lw	$23,156($fp)
-	move	$6,$2
-	addiu	$4,$4,%lo(arp_tbl)
-	lbu	$2,0($23)
-	addiu	$5,$23,12
-	andi	$2,$2,0xf
-	sll	$2,$2,2
+	lw	$4,112($sp)
 	.set	noreorder
 	.set	nomacro
-	jal	neigh_lookup
-	addu	$18,$23,$2
+	jal	rtl_ip_hdr
+	move	$16,$2
 	.set	macro
 	.set	reorder
 
+	move	$5,$16
+	move	$23,$2
+	lbu	$2,0($2)
+	addiu	$4,$23,12
+	andi	$2,$2,0xf
+	sll	$2,$2,2
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L504
-	move	$17,$2
+	jal	rtl_neigh_lookup
+	addu	$20,$23,$2
 	.set	macro
 	.set	reorder
 
-	lw	$2,68($2)
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L504
-	move	$4,$fp
+	beq	$2,$0,$L503
+	move	$18,$2
 	.set	macro
 	.set	reorder
 
-	li	$5,32			# 0x20
-	move	$6,$0
 	.set	noreorder
 	.set	nomacro
-	jal	skb_copy_expand
-	li	$7,32			# 0x20
+	jal	rtl_get_hh_from_neigh
+	move	$4,$2
 	.set	macro
 	.set	reorder
 
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L509
-	move	$22,$2
+	bne	$2,$0,$L504
+	li	$5,32			# 0x20
 	.set	macro
 	.set	reorder
 
-	lui	$4,%hi($LC23)
-	.set	noreorder
-	.set	nomacro
-	jal	scrlog_printk
-	addiu	$4,$4,%lo($LC23)
-	.set	macro
-	.set	reorder
+#APP
+	   
 
-	j	$L504
-$L509:
-	lw	$2,156($2)
-	move	$4,$22
-	lbu	$5,0($2)
-	andi	$5,$5,0xf
-	sll	$5,$5,2
+	1:	ll	$3, 72($18)		# atomic_sub_return	
+       nop                                             
+	subu	$2, $3, 1				
+	sc	$2, 72($18)					
+	beqz	$2, 2f					
+	subu	$2, $3, 1				
+	.subsection 2					
+2:	b	1b					
+	.previous					
+
+	   
+
+#NO_APP
+	bne	$2,$0,$L503
+	.set	noreorder
+	.set	nomacro
+	jal	neigh_destroy
+	move	$4,$18
+	.set	macro
+	.set	reorder
+
+	j	$L503
+$L504:
+	lw	$4,112($sp)
+	move	$6,$0
+	.set	noreorder
+	.set	nomacro
+	jal	skb_copy_expand
+	li	$7,32			# 0x20
+	.set	macro
+	.set	reorder
+
+	.set	noreorder
+	.set	nomacro
+	bne	$2,$0,$L510
+	move	$22,$2
+	.set	macro
+	.set	reorder
+
+#APP
+	   
+
+	1:	ll	$3, 72($18)		# atomic_sub_return	
+       nop                                             
+	subu	$2, $3, 1				
+	sc	$2, 72($18)					
+	beqz	$2, 2f					
+	subu	$2, $3, 1				
+	.subsection 2					
+2:	b	1b					
+	.previous					
+
+	   
+
+#NO_APP
+	bne	$2,$0,$L511
+	.set	noreorder
+	.set	nomacro
+	jal	neigh_destroy
+	move	$4,$18
+	.set	macro
+	.set	reorder
+
+$L511:
+	lui	$4,%hi($LC23)
+	.set	noreorder
+	.set	nomacro
+	jal	scrlog_printk
+	addiu	$4,$4,%lo($LC23)
+	.set	macro
+	.set	reorder
+
+	j	$L503
+$L510:
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_ip_hdr
+	move	$4,$2
+	.set	macro
+	.set	reorder
+
+	move	$4,$22
+	lbu	$5,0($2)
+	andi	$5,$5,0xf
+	sll	$5,$5,2
 	.set	noreorder
 	.set	nomacro
 	jal	skb_trim
@@ -2552,34 +3041,70 @@ $L509:
 	.set	macro
 	.set	reorder
 
-	lw	$16,68($17)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_hh_from_neigh
+	move	$4,$18
+	.set	macro
+	.set	reorder
+
+	addiu	$4,$sp,64
+	move	$5,$2
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_lock_from_hh
+	move	$17,$2
+	.set	macro
+	.set	reorder
+
 	jal	local_bh_disable
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_data
+	move	$4,$22
+	.set	macro
+	.set	reorder
+
+	move	$4,$17
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_data_from_hh
+	addiu	$16,$2,-16
+	.set	macro
+	.set	reorder
+
 	li	$6,16			# 0x10
-	lw	$4,176($22)
-	addiu	$5,$16,20
+	move	$4,$16
 	.set	noreorder
 	.set	nomacro
 	jal	memcpy
-	addiu	$4,$4,-16
+	move	$5,$2
 	.set	macro
 	.set	reorder
 
 	jal	local_bh_enable
-	lhu	$5,10($16)
 	.set	noreorder
 	.set	nomacro
-	jal	skb_push
+	jal	rtl_get_len_from_hh
+	move	$4,$17
+	.set	macro
+	.set	reorder
+
 	move	$4,$22
+	.set	noreorder
+	.set	nomacro
+	jal	skb_push
+	move	$5,$2
 	.set	macro
 	.set	reorder
 
 #APP
 	   
 
-	1:	ll	$3, 72($17)		# atomic_sub_return	
+	1:	ll	$3, 72($18)		# atomic_sub_return	
        nop                                             
 	subu	$2, $3, 1				
-	sc	$2, 72($17)					
+	sc	$2, 72($18)					
 	beqz	$2, 2f					
 	subu	$2, $3, 1				
 	.subsection 2					
@@ -2589,35 +3114,41 @@ $L509:
 	   
 
 #NO_APP
-	bne	$2,$0,$L519
+	bne	$2,$0,$L522
 	.set	noreorder
 	.set	nomacro
 	jal	neigh_destroy
-	move	$4,$17
+	move	$4,$18
+	.set	macro
+	.set	reorder
+
+$L522:
+	move	$5,$0
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_set_skb_nfct
+	move	$4,$22
 	.set	macro
 	.set	reorder
 
-$L519:
-	sw	$0,112($22)
 	li	$19,268369920			# 0xfff0000
-	lhu	$2,2($18)
+	lhu	$2,2($20)
 	ori	$19,$19,0xffff
 	lw	$3,52($sp)
-	addiu	$20,$sp,40
+	lui	$fp,%hi(url_cache)
 	sh	$2,40($sp)
 	li	$2,1342177280			# 0x50000000
 	and	$3,$3,$19
-	move	$4,$20
+	addiu	$21,$fp,%lo(url_cache)
 	or	$3,$3,$2
-	lui	$2,%hi(url_cache)
-	lw	$8,8($18)
-	addiu	$21,$2,%lo(url_cache)
-	lw	$9,4($18)
 	li	$2,-327680			# 0xfffb0000
-	lhu	$7,0($18)
+	lw	$7,8($20)
 	ori	$2,$2,0xffff
+	lw	$8,4($20)
+	move	$4,$22
+	lhu	$6,0($20)
+	addiu	$20,$sp,40
 	sw	$3,52($sp)
-	move	$6,$0
 	sb	$0,53($sp)
 	lw	$3,52($sp)
 	lhu	$5,12($21)
@@ -2627,16 +3158,23 @@ $L519:
 	li	$2,65536			# 0x10000
 	or	$3,$3,$2
 	sw	$3,52($sp)
-	sh	$7,42($sp)
-	sw	$8,44($sp)
-	sw	$9,48($sp)
+	sw	$7,44($sp)
+	sw	$8,48($sp)
+	sh	$6,42($sp)
 	sh	$5,54($sp)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_len
 	sh	$0,58($sp)
-	lw	$17,84($22)
-	sh	$0,56($sp)
-	addiu	$17,$17,-34
+	.set	macro
+	.set	reorder
+
+	move	$6,$0
+	addiu	$17,$2,-34
+	move	$4,$20
 	move	$5,$17
 	andi	$17,$17,0xffff
+	sh	$0,56($sp)
 	lw	$18,12($23)
 	lw	$16,16($23)
 	.set	noreorder
@@ -2646,7 +3184,7 @@ $L519:
 	.set	macro
 	.set	reorder
 
-	move	$5,$20
+	move	$4,$22
 #APP
 		.set	push		# csum_tcpudp_nofold
 	.set	noat		
@@ -2670,19 +3208,25 @@ $L519:
 	xori	$16, 0xffff	
 	.set	pop
 #NO_APP
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_data
 	sh	$16,56($sp)
-	li	$6,20			# 0x14
-	lw	$4,176($22)
+	.set	macro
+	.set	reorder
+
+	move	$5,$20
+	addiu	$4,$2,34
 	.set	noreorder
 	.set	nomacro
 	jal	memcpy
-	addiu	$4,$4,34
+	li	$6,20			# 0x14
 	.set	macro
 	.set	reorder
 
 	li	$2,1073741824			# 0x40000000
 	lw	$3,16($sp)
-	addiu	$7,$sp,16
+	move	$5,$0
 	lbu	$6,14($21)
 	and	$3,$3,$19
 	or	$3,$3,$2
@@ -2693,78 +3237,86 @@ $L519:
 	or	$3,$3,$2
 	sw	$3,16($sp)
 	lw	$2,12($23)
-	lw	$3,104($fp)
+	lw	$4,112($sp)
 	sw	$2,32($sp)
-	li	$2,-805371904			# 0xcfff0000
-	ori	$2,$2,0xffff
-	and	$3,$3,$2
-	lw	$5,16($23)
-	sw	$3,104($fp)
-	lui	$3,%hi(url_cache)
-	lhu	$2,%lo(url_cache)($3)
-	li	$3,40
-	sh	$3,18($sp)
-	addiu	$2,$2,1
-	sh	$2,20($sp)
 	li	$2,6			# 0x6
+	lw	$3,16($23)
+	sb	$2,25($sp)
+	sw	$3,28($sp)
+	sb	$6,24($sp)
 	sh	$0,22($sp)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_set_skb_ip_summed
 	sb	$0,17($sp)
+	.set	macro
+	.set	reorder
+
+	li	$2,40
+	lhu	$3,%lo(url_cache)($fp)
+	addiu	$6,$sp,16
+	sh	$2,18($sp)
+	addiu	$3,$3,1
+	sh	$3,20($sp)
 	lw	$3,16($sp)
 	lw	$4,20($sp)
-	sb	$2,25($sp)
 	srl	$2,$3,22
-	sb	$6,24($sp)
-	addu	$6,$3,$4
-	sh	$0,26($sp)
-	sltu	$4,$6,$4
-	lw	$3,24($sp)
-	addu	$6,$6,$4
+	addu	$5,$3,$4
 	andi	$2,$2,0x3c
-	addu	$6,$6,$3
-	addu	$8,$7,$2
-	sltu	$4,$6,$3
-	addiu	$7,$sp,32
-	addu	$6,$6,$4
-	addu	$6,$6,$5
-	sltu	$4,$6,$5
-	addu	$6,$6,$4
-	sw	$5,28($sp)
-$L523:
-	lw	$2,0($7)
-	addiu	$7,$7,4
-	addu	$6,$6,$2
-	sltu	$4,$6,$2
+	sh	$0,26($sp)
+	sltu	$4,$5,$4
+	addu	$7,$6,$2
+	addu	$5,$5,$4
+	lw	$2,24($sp)
+	addiu	$6,$sp,32
+	lw	$3,28($sp)
+	addu	$5,$5,$2
+	sltu	$4,$5,$2
+	addu	$5,$5,$4
+	addu	$5,$5,$3
+	sltu	$4,$5,$3
+	addu	$5,$5,$4
+$L526:
+	lw	$2,0($6)
+	addiu	$6,$6,4
+	addu	$5,$5,$2
+	sltu	$4,$5,$2
 	.set	noreorder
 	.set	nomacro
-	bne	$7,$8,$L523
-	addu	$6,$6,$4
+	bne	$6,$7,$L526
+	addu	$5,$5,$4
 	.set	macro
 	.set	reorder
 
+	move	$4,$22
 #APP
 		.set	push		# csum_fold
 	.set	noat		
-	sll	$1, $6, 16	
-	addu	$6, $1		
-	sltu	$1, $6, $1	
-	srl	$6, $6, 16	
-	addu	$6, $1		
-	xori	$6, 0xffff	
+	sll	$1, $5, 16	
+	addu	$5, $1		
+	sltu	$1, $5, $1	
+	srl	$5, $5, 16	
+	addu	$5, $1		
+	xori	$5, 0xffff	
 	.set	pop
 #NO_APP
-	sh	$6,26($sp)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_data
+	sh	$5,26($sp)
+	.set	macro
+	.set	reorder
+
 	addiu	$5,$sp,16
-	lw	$4,176($22)
-	li	$6,20			# 0x14
+	addiu	$4,$2,14
 	.set	noreorder
 	.set	nomacro
 	jal	memcpy
-	addiu	$4,$4,14
+	li	$6,20			# 0x14
 	.set	macro
 	.set	reorder
 
-	lui	$2,%hi(url_cache)
-	addiu	$3,$2,%lo(url_cache)
+	addiu	$3,$fp,%lo(url_cache)
 	li	$2,1
 	move	$4,$22
 	sb	$2,16($3)
@@ -2775,22 +3327,22 @@ $L523:
 	.set	macro
 	.set	reorder
 
-$L504:
-	lw	$31,100($sp)
+$L503:
+	lw	$31,108($sp)
 	move	$2,$0
-	lw	$fp,96($sp)
-	lw	$23,92($sp)
-	lw	$22,88($sp)
-	lw	$21,84($sp)
-	lw	$20,80($sp)
-	lw	$19,76($sp)
-	lw	$18,72($sp)
-	lw	$17,68($sp)
-	lw	$16,64($sp)
+	lw	$fp,104($sp)
+	lw	$23,100($sp)
+	lw	$22,96($sp)
+	lw	$21,92($sp)
+	lw	$20,88($sp)
+	lw	$19,84($sp)
+	lw	$18,80($sp)
+	lw	$17,76($sp)
+	lw	$16,72($sp)
 	.set	noreorder
 	.set	nomacro
 	j	$31
-	addiu	$sp,$sp,104
+	addiu	$sp,$sp,112
 	.set	macro
 	.set	reorder
 
@@ -2812,63 +3364,98 @@ $LC24:
 	.type	GenerateHTTP401, @function
 GenerateHTTP401:
 	.set	nomips16
-	.frame	$sp,208,$31		# vars= 152, regs= 10/0, args= 16, gp= 0
+	.frame	$sp,216,$31		# vars= 160, regs= 10/0, args= 16, gp= 0
 	.mask	0xc0ff0000,-4
 	.fmask	0x00000000,0
-	addiu	$sp,$sp,-208
-	lui	$5,%hi($LC0)
-	sw	$4,208($sp)
-	lui	$4,%hi(init_net)
-	addiu	$5,$5,%lo($LC0)
-	addiu	$4,$4,%lo(init_net)
-	sw	$31,204($sp)
-	sw	$fp,200($sp)
-	sw	$22,192($sp)
-	sw	$17,172($sp)
-	sw	$23,196($sp)
-	sw	$21,188($sp)
-	sw	$20,184($sp)
-	sw	$19,180($sp)
-	sw	$18,176($sp)
-	.set	noreorder
-	.set	nomacro
-	jal	__dev_get_by_name
-	sw	$16,168($sp)
-	.set	macro
-	.set	reorder
-
-	lui	$4,%hi(arp_tbl)
-	lw	$3,208($sp)
-	move	$6,$2
-	addiu	$4,$4,%lo(arp_tbl)
-	lw	$fp,156($3)
-	lbu	$2,0($fp)
-	addiu	$5,$fp,12
+	addiu	$sp,$sp,-216
+	sw	$4,216($sp)
+	lui	$4,%hi($LC0)
+	addiu	$4,$4,%lo($LC0)
+	sw	$31,212($sp)
+	sw	$fp,208($sp)
+	sw	$21,196($sp)
+	sw	$18,184($sp)
+	sw	$16,176($sp)
+	sw	$23,204($sp)
+	sw	$22,200($sp)
+	sw	$20,192($sp)
+	sw	$19,188($sp)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_dev_by_name
+	sw	$17,180($sp)
+	.set	macro
+	.set	reorder
+
+	lw	$4,216($sp)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_ip_hdr
+	move	$16,$2
+	.set	macro
+	.set	reorder
+
+	move	$5,$16
+	move	$fp,$2
+	lbu	$2,0($2)
+	addiu	$4,$fp,12
 	andi	$2,$2,0xf
 	sll	$2,$2,2
 	.set	noreorder
 	.set	nomacro
-	jal	neigh_lookup
-	addu	$17,$fp,$2
+	jal	rtl_neigh_lookup
+	addu	$18,$fp,$2
 	.set	macro
 	.set	reorder
 
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L528
-	move	$22,$2
+	beq	$2,$0,$L531
+	move	$21,$2
+	.set	macro
+	.set	reorder
+
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_hh_from_neigh
+	move	$4,$2
 	.set	macro
 	.set	reorder
 
-	lw	$2,68($2)
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L528
+	bne	$2,$0,$L532
 	li	$5,32			# 0x20
 	.set	macro
 	.set	reorder
 
-	lw	$4,208($sp)
+#APP
+	   
+
+	1:	ll	$3, 72($21)		# atomic_sub_return	
+       nop                                             
+	subu	$2, $3, 1				
+	sc	$2, 72($21)					
+	beqz	$2, 2f					
+	subu	$2, $3, 1				
+	.subsection 2					
+2:	b	1b					
+	.previous					
+
+	   
+
+#NO_APP
+	bne	$2,$0,$L531
+	.set	noreorder
+	.set	nomacro
+	jal	neigh_destroy
+	move	$4,$21
+	.set	macro
+	.set	reorder
+
+	j	$L531
+$L532:
+	lw	$4,216($sp)
 	move	$6,$0
 	.set	noreorder
 	.set	nomacro
@@ -2879,15 +3466,26 @@ GenerateHTTP401:
 
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L580
+	beq	$2,$0,$L587
 	move	$23,$2
 	.set	macro
 	.set	reorder
 
-	lw	$2,156($2)
+	move	$4,$2
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_ip_hdr
+	li	$19,268369920			# 0xfff0000
+	.set	macro
+	.set	reorder
+
 	move	$4,$23
 	lbu	$5,0($2)
+	lui	$2,%hi(url_cache)
+	addiu	$20,$2,%lo(url_cache)
+	ori	$19,$19,0xffff
 	andi	$5,$5,0xf
+	addiu	$22,$sp,40
 	sll	$5,$5,2
 	.set	noreorder
 	.set	nomacro
@@ -2896,105 +3494,129 @@ GenerateHTTP401:
 	.set	macro
 	.set	reorder
 
-	move	$4,$23
+	move	$5,$0
 	.set	noreorder
 	.set	nomacro
 	jal	skb_put
-	move	$5,$0
+	move	$4,$23
+	.set	macro
+	.set	reorder
+
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_hh_from_neigh
+	move	$4,$21
+	.set	macro
+	.set	reorder
+
+	addiu	$4,$sp,168
+	move	$5,$2
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_lock_from_hh
+	move	$17,$2
 	.set	macro
 	.set	reorder
 
-	lw	$16,68($22)
 	jal	local_bh_disable
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_data
+	move	$4,$0
+	.set	macro
+	.set	reorder
+
+	move	$4,$17
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_data_from_hh
+	addiu	$16,$2,-16
+	.set	macro
+	.set	reorder
+
 	li	$6,16			# 0x10
-	lw	$4,176($23)
-	addiu	$5,$16,20
+	move	$4,$16
 	.set	noreorder
 	.set	nomacro
 	jal	memcpy
-	addiu	$4,$4,-16
+	move	$5,$2
 	.set	macro
 	.set	reorder
 
 	jal	local_bh_enable
-	lhu	$5,10($16)
 	.set	noreorder
 	.set	nomacro
-	jal	skb_push
-	move	$4,$23
+	jal	rtl_get_len_from_hh
+	move	$4,$17
 	.set	macro
 	.set	reorder
 
-#APP
-	   
-
-	1:	ll	$3, 72($22)		# atomic_sub_return	
-       nop                                             
-	subu	$2, $3, 1				
-	sc	$2, 72($22)					
-	beqz	$2, 2f					
-	subu	$2, $3, 1				
-	.subsection 2					
-2:	b	1b					
-	.previous					
+	move	$4,$23
+	.set	noreorder
+	.set	nomacro
+	jal	skb_push
+	move	$5,$2
+	.set	macro
+	.set	reorder
 
-	   
+	move	$5,$0
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_set_skb_nfct
+	move	$4,$0
+	.set	macro
+	.set	reorder
 
-#NO_APP
-	bne	$2,$0,$L543
+	lhu	$2,2($18)
+	lw	$3,8($18)
+	sh	$2,40($sp)
+	lhu	$2,0($18)
+	lw	$4,216($sp)
+	lw	$16,4($18)
+	sh	$2,42($sp)
 	.set	noreorder
 	.set	nomacro
-	jal	neigh_destroy
-	move	$4,$22
+	jal	rtl_get_skb_len
+	sw	$3,44($sp)
 	.set	macro
 	.set	reorder
 
-$L543:
-	sw	$0,112($23)
-	li	$19,268369920			# 0xfff0000
-	lhu	$2,2($17)
-	ori	$19,$19,0xffff
+	li	$4,1342177280			# 0x50000000
 	lw	$3,52($sp)
-	addiu	$21,$sp,40
-	sh	$2,40($sp)
-	li	$2,1342177280			# 0x50000000
+	addu	$2,$16,$2
+	addiu	$2,$2,-40
 	and	$3,$3,$19
-	move	$4,$21
-	or	$3,$3,$2
-	lui	$2,%hi(url_cache)
-	lw	$9,8($17)
-	addiu	$20,$2,%lo(url_cache)
-	lw	$6,4($17)
-	li	$2,-327680			# 0xfffb0000
-	lhu	$8,0($17)
-	ori	$2,$2,0xffff
+	or	$3,$3,$4
+	move	$4,$23
 	sw	$3,52($sp)
-	lw	$3,208($sp)
+	li	$3,-327680			# 0xfffb0000
 	sb	$0,53($sp)
-	lw	$5,84($3)
-	lw	$3,52($sp)
-	lhu	$7,12($20)
-	addu	$5,$6,$5
-	and	$3,$3,$2
-	li	$2,1048576			# 0x100000
-	or	$3,$3,$2
-	li	$2,-589824			# 0xfff70000
-	ori	$2,$2,0xffff
-	addiu	$5,$5,-40
-	and	$3,$3,$2
-	move	$6,$0
-	sw	$3,52($sp)
-	sh	$8,42($sp)
-	sh	$7,54($sp)
-	sw	$9,44($sp)
-	sw	$5,48($sp)
+	ori	$3,$3,0xffff
+	lw	$5,52($sp)
+	lhu	$6,12($20)
+	and	$5,$5,$3
+	li	$3,1048576			# 0x100000
+	or	$5,$5,$3
+	li	$3,-589824			# 0xfff70000
+	ori	$3,$3,0xffff
+	and	$5,$5,$3
+	sw	$5,52($sp)
+	sw	$2,48($sp)
+	sh	$6,54($sp)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_len
 	sh	$0,58($sp)
-	lw	$2,84($23)
-	sh	$0,56($sp)
+	.set	macro
+	.set	reorder
+
+	move	$6,$0
 	addiu	$2,$2,-34
+	move	$4,$22
+	sh	$0,56($sp)
 	move	$5,$2
-	andi	$17,$2,0xffff
 	lw	$18,12($fp)
+	andi	$17,$2,0xffff
 	lw	$16,16($fp)
 	.set	noreorder
 	.set	nomacro
@@ -3003,7 +3625,7 @@ $L543:
 	.set	macro
 	.set	reorder
 
-	move	$5,$21
+	move	$4,$23
 #APP
 		.set	push		# csum_tcpudp_nofold
 	.set	noat		
@@ -3027,19 +3649,25 @@ $L543:
 	xori	$16, 0xffff	
 	.set	pop
 #NO_APP
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_data
 	sh	$16,56($sp)
-	li	$6,20			# 0x14
-	lw	$4,176($23)
+	.set	macro
+	.set	reorder
+
+	move	$5,$22
+	addiu	$4,$2,34
 	.set	noreorder
 	.set	nomacro
 	jal	memcpy
-	addiu	$4,$4,34
+	li	$6,20			# 0x14
 	.set	macro
 	.set	reorder
 
 	li	$2,1073741824			# 0x40000000
 	lw	$3,16($sp)
-	addiu	$7,$sp,16
+	addiu	$6,$sp,16
 	sh	$0,22($sp)
 	and	$3,$3,$19
 	or	$3,$3,$2
@@ -3058,67 +3686,80 @@ $L543:
 	li	$2,6			# 0x6
 	sb	$0,17($sp)
 	lw	$3,16($sp)
-	lw	$4,20($sp)
 	lbu	$5,14($20)
-	addu	$6,$3,$4
-	sb	$2,25($sp)
-	sltu	$4,$6,$4
+	lw	$4,20($sp)
 	sb	$5,24($sp)
-	srl	$2,$3,22
+	addu	$5,$3,$4
+	sb	$2,25($sp)
+	sltu	$4,$5,$4
 	sh	$0,26($sp)
-	addu	$6,$6,$4
-	lw	$3,12($fp)
+	srl	$2,$3,22
+	addu	$5,$5,$4
 	andi	$2,$2,0x3c
+	lw	$3,12($fp)
 	lw	$4,24($sp)
 	sw	$3,32($sp)
-	addu	$3,$7,$2
-	addu	$6,$6,$4
-	addiu	$7,$sp,32
+	addu	$3,$6,$2
+	addu	$5,$5,$4
+	addiu	$6,$sp,32
 	lw	$2,16($fp)
-	sltu	$4,$6,$4
-	addu	$6,$6,$4
-	addu	$6,$6,$2
-	sltu	$4,$6,$2
-	addu	$6,$6,$4
+	sltu	$4,$5,$4
+	addu	$5,$5,$4
+	addu	$5,$5,$2
+	sltu	$4,$5,$2
+	addu	$5,$5,$4
 	sw	$2,28($sp)
-$L547:
-	lw	$2,0($7)
-	addiu	$7,$7,4
-	addu	$6,$6,$2
-	sltu	$4,$6,$2
+$L551:
+	lw	$2,0($6)
+	addiu	$6,$6,4
+	addu	$5,$5,$2
+	sltu	$4,$5,$2
 	.set	noreorder
 	.set	nomacro
-	bne	$7,$3,$L547
-	addu	$6,$6,$4
+	bne	$6,$3,$L551
+	addu	$5,$5,$4
 	.set	macro
 	.set	reorder
 
+	move	$4,$23
+	addiu	$fp,$sp,64
 #APP
 		.set	push		# csum_fold
 	.set	noat		
-	sll	$1, $6, 16	
-	addu	$6, $1		
-	sltu	$1, $6, $1	
-	srl	$6, $6, 16	
-	addu	$6, $1		
-	xori	$6, 0xffff	
+	sll	$1, $5, 16	
+	addu	$5, $1		
+	sltu	$1, $5, $1	
+	srl	$5, $5, 16	
+	addu	$5, $1		
+	xori	$5, 0xffff	
 	.set	pop
 #NO_APP
-	sh	$6,26($sp)
+	sh	$5,26($sp)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_data
+	lui	$18,%hi(block_message)
+	.set	macro
+	.set	reorder
+
 	addiu	$5,$sp,16
-	lw	$4,176($23)
 	li	$6,20			# 0x14
-	addiu	$fp,$sp,64
-	lui	$18,%hi(block_message)
 	.set	noreorder
 	.set	nomacro
-	jal	memcpy
-	addiu	$4,$4,14
+	jal	memcpy
+	addiu	$4,$2,14
+	.set	macro
+	.set	reorder
+
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_data
+	move	$4,$23
 	.set	macro
 	.set	reorder
 
 	move	$4,$fp
-	lw	$5,176($23)
+	move	$5,$2
 	.set	noreorder
 	.set	nomacro
 	jal	memcpy
@@ -3134,13 +3775,13 @@ $L547:
 	.set	reorder
 
 	lw	$4,%lo(block_message)($18)
-	bne	$4,$0,$L577
+	bne	$4,$0,$L583
 	lui	$4,%hi($LC24)
 	addiu	$4,$4,%lo($LC24)
-$L577:
+$L583:
 	jal	strlen
 	li	$5,32			# 0x20
-	lw	$4,208($sp)
+	lw	$4,216($sp)
 	move	$6,$2
 	.set	noreorder
 	.set	nomacro
@@ -3151,13 +3792,46 @@ $L577:
 
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L554
+	bne	$2,$0,$L558
 	move	$23,$2
 	.set	macro
 	.set	reorder
 
-$L580:
+	.set	noreorder
+	.set	nomacro
+	beq	$21,$0,$L588
+	lui	$4,%hi($LC23)
+	.set	macro
+	.set	reorder
+
+$L587:
+#APP
+	   
+
+	1:	ll	$3, 72($21)		# atomic_sub_return	
+       nop                                             
+	subu	$2, $3, 1				
+	sc	$2, 72($21)					
+	beqz	$2, 2f					
+	subu	$2, $3, 1				
+	.subsection 2					
+2:	b	1b					
+	.previous					
+
+	   
+
+#NO_APP
+	bne	$2,$0,$L559
+	.set	noreorder
+	.set	nomacro
+	jal	neigh_destroy
+	move	$4,$21
+	.set	macro
+	.set	reorder
+
+$L559:
 	lui	$4,%hi($LC23)
+$L588:
 	.set	noreorder
 	.set	nomacro
 	jal	scrlog_printk
@@ -3165,11 +3839,18 @@ $L580:
 	.set	macro
 	.set	reorder
 
-	j	$L528
-$L554:
-	lw	$20,156($2)
+	j	$L531
+$L558:
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_ip_hdr
 	move	$4,$2
-	lbu	$5,0($20)
+	.set	macro
+	.set	reorder
+
+	move	$4,$23
+	lbu	$5,0($2)
+	move	$20,$2
 	andi	$5,$5,0xf
 	sll	$5,$5,2
 	.set	noreorder
@@ -3180,10 +3861,10 @@ $L554:
 	.set	reorder
 
 	lw	$4,%lo(block_message)($18)
-	bne	$4,$0,$L578
+	bne	$4,$0,$L584
 	lui	$4,%hi($LC24)
 	addiu	$4,$4,%lo($LC24)
-$L578:
+$L584:
 	jal	strlen
 	move	$4,$23
 	.set	noreorder
@@ -3193,34 +3874,70 @@ $L578:
 	.set	macro
 	.set	reorder
 
-	lw	$16,68($22)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_hh_from_neigh
+	move	$4,$21
+	.set	macro
+	.set	reorder
+
+	addiu	$4,$sp,172
+	move	$5,$2
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_lock_from_hh
+	move	$17,$2
+	.set	macro
+	.set	reorder
+
 	jal	local_bh_disable
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_data
+	move	$4,$23
+	.set	macro
+	.set	reorder
+
+	move	$4,$17
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_data_from_hh
+	addiu	$16,$2,-16
+	.set	macro
+	.set	reorder
+
 	li	$6,16			# 0x10
-	lw	$4,176($23)
-	addiu	$5,$16,20
+	move	$4,$16
 	.set	noreorder
 	.set	nomacro
 	jal	memcpy
-	addiu	$4,$4,-16
+	move	$5,$2
 	.set	macro
 	.set	reorder
 
 	jal	local_bh_enable
-	lhu	$5,10($16)
 	.set	noreorder
 	.set	nomacro
-	jal	skb_push
+	jal	rtl_get_len_from_hh
+	move	$4,$17
+	.set	macro
+	.set	reorder
+
 	move	$4,$23
+	.set	noreorder
+	.set	nomacro
+	jal	skb_push
+	move	$5,$2
 	.set	macro
 	.set	reorder
 
 #APP
 	   
 
-	1:	ll	$3, 72($22)		# atomic_sub_return	
+	1:	ll	$3, 72($21)		# atomic_sub_return	
        nop                                             
 	subu	$2, $3, 1				
-	sc	$2, 72($22)					
+	sc	$2, 72($21)					
 	beqz	$2, 2f					
 	subu	$2, $3, 1				
 	.subsection 2					
@@ -3230,36 +3947,49 @@ $L578:
 	   
 
 #NO_APP
-	bne	$2,$0,$L566
+	.set	noreorder
+	.set	nomacro
+	bne	$2,$0,$L589
+	move	$4,$23
+	.set	macro
+	.set	reorder
+
 	.set	noreorder
 	.set	nomacro
 	jal	neigh_destroy
-	move	$4,$22
+	move	$4,$21
+	.set	macro
+	.set	reorder
+
+	move	$4,$23
+$L589:
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_set_skb_nfct
+	move	$5,$0
 	.set	macro
 	.set	reorder
 
-$L566:
-	sw	$0,112($23)
 	lbu	$2,0($20)
 	lw	$3,12($20)
 	lw	$4,16($20)
 	andi	$2,$2,0xf
 	sll	$2,$2,2
 	sw	$3,16($20)
-	addu	$21,$20,$2
+	addu	$22,$20,$2
 	sw	$4,12($20)
-	lhu	$4,0($21)
-	lhu	$3,2($21)
-	lw	$2,12($21)
-	sh	$3,0($21)
-	sh	$4,2($21)
+	lhu	$4,0($22)
+	lhu	$3,2($22)
+	lw	$2,12($22)
+	sh	$3,0($22)
+	sh	$4,2($22)
 	srl	$2,$2,28
 	lw	$4,%lo(block_message)($18)
 	sll	$2,$2,2
 	.set	noreorder
 	.set	nomacro
-	beq	$4,$0,$L567
-	addu	$17,$21,$2
+	beq	$4,$0,$L573
+	addu	$17,$22,$2
 	.set	macro
 	.set	reorder
 
@@ -3267,12 +3997,12 @@ $L566:
 	lw	$5,%lo(block_message)($18)
 	.set	noreorder
 	.set	nomacro
-	j	$L579
+	j	$L585
 	move	$4,$17
 	.set	macro
 	.set	reorder
 
-$L567:
+$L573:
 	lui	$16,%hi($LC24)
 	.set	noreorder
 	.set	nomacro
@@ -3283,7 +4013,7 @@ $L567:
 
 	move	$4,$17
 	addiu	$5,$16,%lo($LC24)
-$L579:
+$L585:
 	.set	noreorder
 	.set	nomacro
 	jal	memcpy
@@ -3292,24 +4022,28 @@ $L579:
 	.set	reorder
 
 	lui	$3,%hi(url_cache)
-	lw	$2,8($21)
+	lw	$2,8($22)
 	addiu	$19,$3,%lo(url_cache)
-	lw	$6,4($21)
-	move	$4,$21
-	sw	$2,4($21)
-	lw	$3,208($sp)
-	lw	$2,84($3)
-	addu	$2,$6,$2
-	move	$6,$0
+	lw	$4,216($sp)
+	lw	$16,4($22)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_len
+	sw	$2,4($22)
+	.set	macro
+	.set	reorder
+
+	move	$4,$23
+	addu	$2,$16,$2
 	addiu	$2,$2,-40
-	sw	$2,8($21)
+	sw	$2,8($22)
 	lhu	$2,12($19)
-	sb	$0,13($21)
-	sh	$2,14($21)
+	sb	$0,13($22)
+	sh	$2,14($22)
 	li	$2,-327680			# 0xfffb0000
-	lw	$3,12($21)
+	lw	$3,12($22)
 	ori	$2,$2,0xffff
-	sh	$0,18($21)
+	sh	$0,18($22)
 	and	$3,$3,$2
 	li	$2,1048576			# 0x100000
 	or	$3,$3,$2
@@ -3318,14 +4052,21 @@ $L579:
 	li	$2,-131072			# 0xfffe0000
 	ori	$2,$2,0xffff
 	and	$3,$3,$2
-	sw	$3,12($21)
-	lbu	$2,0($20)
-	lw	$3,84($23)
-	andi	$2,$2,0xf
-	sll	$2,$2,2
-	subu	$3,$3,$2
-	addiu	$2,$3,-14
-	sh	$0,16($21)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_len
+	sw	$3,12($22)
+	.set	macro
+	.set	reorder
+
+	move	$6,$0
+	lbu	$3,0($20)
+	move	$4,$22
+	sh	$0,16($22)
+	andi	$3,$3,0xf
+	sll	$3,$3,2
+	subu	$2,$2,$3
+	addiu	$2,$2,-14
 	move	$5,$2
 	andi	$17,$2,0xffff
 	lw	$18,12($20)
@@ -3337,7 +4078,7 @@ $L579:
 	.set	macro
 	.set	reorder
 
-	lui	$3,%hi(url_cache)
+	move	$4,$23
 #APP
 		.set	push		# csum_tcpudp_nofold
 	.set	noat		
@@ -3361,11 +4102,16 @@ $L579:
 	xori	$16, 0xffff	
 	.set	pop
 #NO_APP
-	sh	$16,16($21)
-	addiu	$6,$20,16
-	lw	$2,84($23)
-	lw	$5,12($20)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_len
+	sh	$16,16($22)
+	.set	macro
+	.set	reorder
+
+	lui	$3,%hi(url_cache)
 	addiu	$2,$2,-14
+	addiu	$6,$20,16
 	sh	$2,2($20)
 	lbu	$2,14($19)
 	sh	$0,6($20)
@@ -3380,29 +4126,29 @@ $L579:
 	sh	$0,10($20)
 	addu	$7,$20,$2
 	addu	$4,$4,$3
-	sltu	$3,$4,$3
+	sltu	$5,$4,$3
 	lw	$2,8($20)
-	addu	$4,$4,$3
+	addu	$4,$4,$5
+	lw	$3,12($20)
 	addu	$4,$4,$2
-	sltu	$3,$4,$2
-	addu	$4,$4,$3
+	sltu	$5,$4,$2
 	addu	$4,$4,$5
-	sltu	$3,$4,$5
 	addu	$4,$4,$3
-$L572:
+	sltu	$5,$4,$3
+	addu	$4,$4,$5
+$L578:
 	lw	$2,0($6)
 	addiu	$6,$6,4
 	addu	$4,$4,$2
-	sltu	$3,$4,$2
+	sltu	$5,$4,$2
 	.set	noreorder
 	.set	nomacro
-	bne	$6,$7,$L572
-	addu	$4,$4,$3
+	bne	$6,$7,$L578
+	addu	$4,$4,$5
 	.set	macro
 	.set	reorder
 
 	lui	$2,%hi(url_cache)
-	li	$6,54			# 0x36
 	addiu	$3,$2,%lo(url_cache)
 	li	$2,1
 #APP
@@ -3417,12 +4163,20 @@ $L572:
 	.set	pop
 #NO_APP
 	sh	$4,10($20)
+	move	$4,$23
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_get_skb_data
 	sb	$2,15($3)
-	lw	$5,176($23)
+	.set	macro
+	.set	reorder
+
+	move	$4,$fp
+	move	$5,$2
 	.set	noreorder
 	.set	nomacro
 	jal	memcpy
-	move	$4,$fp
+	li	$6,54			# 0x36
 	.set	macro
 	.set	reorder
 
@@ -3433,22 +4187,22 @@ $L572:
 	.set	macro
 	.set	reorder
 
-$L528:
-	lw	$31,204($sp)
+$L531:
+	lw	$31,212($sp)
 	move	$2,$0
-	lw	$fp,200($sp)
-	lw	$23,196($sp)
-	lw	$22,192($sp)
-	lw	$21,188($sp)
-	lw	$20,184($sp)
-	lw	$19,180($sp)
-	lw	$18,176($sp)
-	lw	$17,172($sp)
-	lw	$16,168($sp)
+	lw	$fp,208($sp)
+	lw	$23,204($sp)
+	lw	$22,200($sp)
+	lw	$21,196($sp)
+	lw	$20,192($sp)
+	lw	$19,188($sp)
+	lw	$18,184($sp)
+	lw	$17,180($sp)
+	lw	$16,176($sp)
 	.set	noreorder
 	.set	nomacro
 	j	$31
-	addiu	$sp,$sp,208
+	addiu	$sp,$sp,216
 	.set	macro
 	.set	reorder
 
@@ -3468,8 +4222,8 @@ strtoint:
 	
 	lbu	$3,0($4)
 	move	$7,$0
-$L589:
-	beq	$3,$0,$L583
+$L598:
+	beq	$3,$0,$L592
 	sll	$3,$3,24
 
 	sll	$2,$7,2
@@ -3478,14 +4232,14 @@ $L589:
 	addiu	$5,$3,-48
 	sll	$6,$2,1
 	sltu	$2,$5,10
-	beq	$2,$0,$L583
+	beq	$2,$0,$L592
 	addiu	$4,$4,1
 
 	lbu	$3,0($4)
-	j	$L589
+	j	$L598
 	addu	$7,$6,$5
 
-$L583:
+$L592:
 	j	$31
 	move	$2,$7
 
@@ -3509,9 +4263,9 @@ Add_Pattern_ACL_For_ContentFilter:
 	.mask	0x80010000,-4
 	.fmask	0x00000000,0
 	addiu	$sp,$sp,-80
+	move	$5,$0
 	li	$6,52			# 0x34
 	addiu	$4,$sp,16
-	move	$5,$0
 	sw	$31,76($sp)
 	.set	noreorder
 	.set	nomacro
@@ -3523,19 +4277,17 @@ Add_Pattern_ACL_For_ContentFilter:
 	li	$2,-125894656			# 0xf87f0000
 	lw	$3,52($sp)
 	ori	$2,$2,0xffff
-	lui	$4,%hi(init_net)
-	lui	$5,%hi($LC2)
+	lui	$4,%hi($LC2)
 	and	$3,$3,$2
 	li	$2,134152192			# 0x7ff0000
 	ori	$2,$2,0xffff
-	addiu	$4,$4,%lo(init_net)
+	addiu	$4,$4,%lo($LC2)
 	and	$3,$3,$2
 	li	$2,7340032			# 0x700000
 	or	$3,$3,$2
-	addiu	$5,$5,%lo($LC2)
 	.set	noreorder
 	.set	nomacro
-	jal	dev_get_by_name
+	jal	rtl_get_dev_by_name
 	sw	$3,52($sp)
 	.set	macro
 	.set	reorder
@@ -3543,7 +4295,7 @@ Add_Pattern_ACL_For_ContentFilter:
 	move	$16,$2
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L590
+	beq	$2,$0,$L599
 	move	$4,$2
 	.set	macro
 	.set	reorder
@@ -3567,13 +4319,13 @@ Add_Pattern_ACL_For_ContentFilter:
 	addiu	$5,$2,12
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L590
+	beq	$2,$0,$L599
 	addiu	$4,$sp,16
 	.set	macro
 	.set	reorder
 
 	jal	rtl865x_add_pattern_acl_for_contentFilter
-$L590:
+$L599:
 	lw	$31,76($sp)
 	move	$2,$0
 	lw	$16,72($sp)
@@ -3603,12 +4355,12 @@ filter_item_regist:
 	sw	$31,16($sp)
 	addiu	$2,$3,%lo(table_list_head)
 	lw	$6,%lo(table_list_head)($3)
-	beq	$6,$2,$L596
+	beq	$6,$2,$L605
 	li	$2,-1			# 0xffffffff
 
-$L604:
+$L613:
 	lw	$2,16($6)
-	bne	$2,$4,$L599
+	bne	$2,$4,$L608
 	addiu	$7,$3,%lo(table_list_head)
 
 	lw	$2,8($6)
@@ -3620,26 +4372,26 @@ $L604:
 	sw	$5,8($6)
 	addiu	$3,$2,1
 	li	$2,3			# 0x3
-	bne	$4,$2,$L603
+	bne	$4,$2,$L612
 	sw	$3,24($6)
 
 	li	$2,2			# 0x2
-	bne	$3,$2,$L603
+	bne	$3,$2,$L612
 	nop
 
 	jal	Add_Pattern_ACL_For_ContentFilter
 	nop
 
-$L603:
-	j	$L596
+$L612:
+	j	$L605
 	move	$2,$0
 
-$L599:
+$L608:
 	lw	$6,0($6)
-	bne	$6,$7,$L604
+	bne	$6,$7,$L613
 	li	$2,-1			# 0xffffffff
 
-$L596:
+$L605:
 	lw	$31,16($sp)
 	j	$31
 	addiu	$sp,$sp,24
@@ -3664,9 +4416,9 @@ Del_Pattern_ACL_For_ContentFilter:
 	.mask	0x80010000,-4
 	.fmask	0x00000000,0
 	addiu	$sp,$sp,-80
+	move	$5,$0
 	li	$6,52			# 0x34
 	addiu	$4,$sp,16
-	move	$5,$0
 	sw	$31,76($sp)
 	.set	noreorder
 	.set	nomacro
@@ -3678,20 +4430,18 @@ Del_Pattern_ACL_For_ContentFilter:
 	li	$2,-125894656			# 0xf87f0000
 	lw	$3,52($sp)
 	ori	$2,$2,0xffff
-	lui	$4,%hi(init_net)
-	lui	$5,%hi($LC0)
+	lui	$4,%hi($LC0)
 	and	$3,$3,$2
 	li	$2,25165824			# 0x1800000
 	or	$3,$3,$2
 	li	$2,134152192			# 0x7ff0000
 	ori	$2,$2,0xffff
-	addiu	$4,$4,%lo(init_net)
+	addiu	$4,$4,%lo($LC0)
 	and	$3,$3,$2
 	li	$2,268435456			# 0x10000000
 	or	$3,$3,$2
 	li	$2,-7405568			# 0xff8f0000
 	ori	$2,$2,0xffff
-	addiu	$5,$5,%lo($LC0)
 	and	$3,$3,$2
 	li	$2,6291456			# 0x600000
 	or	$3,$3,$2
@@ -3700,7 +4450,7 @@ Del_Pattern_ACL_For_ContentFilter:
 	ori	$2,$2,0x30
 	.set	noreorder
 	.set	nomacro
-	jal	dev_get_by_name
+	jal	rtl_get_dev_by_name
 	sw	$2,36($sp)
 	.set	macro
 	.set	reorder
@@ -3708,7 +4458,7 @@ Del_Pattern_ACL_For_ContentFilter:
 	move	$16,$2
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L607
+	beq	$2,$0,$L616
 	move	$4,$2
 	.set	macro
 	.set	reorder
@@ -3732,13 +4482,13 @@ Del_Pattern_ACL_For_ContentFilter:
 	addiu	$5,$2,12
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L607
+	beq	$2,$0,$L616
 	addiu	$4,$sp,16
 	.set	macro
 	.set	reorder
 
 	jal	rtl865x_del_pattern_acl_for_contentFilter
-$L607:
+$L616:
 	lw	$31,76($sp)
 	move	$2,$0
 	lw	$16,72($sp)
@@ -3774,15 +4524,15 @@ filter_table_flush:
 	sw	$18,24($sp)
 	sw	$17,20($sp)
 	lw	$20,0($16)
-	beq	$16,$2,$L632
+	beq	$16,$2,$L641
 	li	$3,1			# 0x1
 
-$L626:
+$L635:
 	lw	$6,8($16)
 	addiu	$18,$16,8
-$L631:
+$L640:
 	lw	$17,0($6)
-	beq	$6,$18,$L630
+	beq	$6,$18,$L639
 	li	$2,1048576			# 0x100000
 
 	lw	$5,4($6)
@@ -3800,23 +4550,23 @@ $L631:
 	move	$6,$17
 	lw	$2,24($16)
 	addiu	$2,$2,-1
-	j	$L631
+	j	$L640
 	sw	$2,24($16)
 
-$L630:
+$L639:
 	lw	$3,16($16)
 	li	$2,3			# 0x3
-	bne	$3,$2,$L623
+	bne	$3,$2,$L632
 	li	$2,1			# 0x1
 
 	lw	$3,24($16)
-	bne	$3,$2,$L623
+	bne	$3,$2,$L632
 	nop
 
 	jal	Del_Pattern_ACL_For_ContentFilter
 	nop
 
-$L623:
+$L632:
 	lw	$3,0($16)
 	li	$2,1048576			# 0x100000
 	lw	$5,4($16)
@@ -3835,11 +4585,11 @@ $L623:
 	lw	$2,24($3)
 	lw	$20,0($20)
 	addiu	$2,$2,-1
-	bne	$16,$3,$L626
+	bne	$16,$3,$L635
 	sw	$2,24($3)
 
 	li	$3,1			# 0x1
-$L632:
+$L641:
 	lui	$4,%hi(filter_rule_num)
 	lw	$31,36($sp)
 	move	$2,$0
@@ -3894,8 +4644,8 @@ filter_table_write_proc:
 	.frame	$sp,96,$31		# vars= 48, regs= 8/0, args= 16, gp= 0
 	.mask	0x807f0000,-4
 	.fmask	0x00000000,0
-$L638:
-$L679:
+$L647:
+$L688:
 	addiu	$sp,$sp,-96
 	lui	$2,%hi(malloc_sizes+60)
 	sw	$20,80($sp)
@@ -3919,7 +4669,7 @@ $L679:
 	move	$19,$2
 	.set	noreorder
 	.set	nomacro
-	beq	$19,$0,$L633
+	beq	$19,$0,$L642
 	li	$2,-14			# 0xfffffff2
 	.set	macro
 	.set	reorder
@@ -3944,7 +4694,7 @@ $L679:
 
 	.set	noreorder
 	.set	nomacro
-	beq	$17,$0,$L947
+	beq	$17,$0,$L956
 	addu	$3,$17,$20
 	.set	macro
 	.set	reorder
@@ -3956,7 +4706,7 @@ $L679:
 	and	$2,$2,$3
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L684
+	bne	$2,$0,$L693
 	move	$6,$20
 	.set	macro
 	.set	reorder
@@ -3971,11 +4721,11 @@ $L679:
 	.set	at
 	.set	reorder
 #NO_APP
-$L684:
-	bne	$6,$0,$L947
+$L693:
+	bne	$6,$0,$L956
 	.set	noreorder
 	.set	nomacro
-	beq	$20,$0,$L953
+	beq	$20,$0,$L962
 	move	$4,$7
 	.set	macro
 	.set	reorder
@@ -3998,7 +4748,7 @@ $L684:
 	.set	reorder
 #NO_APP
 	move	$4,$7
-$L953:
+$L962:
 	.set	noreorder
 	.set	nomacro
 	jal	strlen
@@ -4026,7 +4776,7 @@ $L953:
 
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L693
+	bne	$2,$0,$L702
 	lui	$16,%hi($LC29)
 	.set	macro
 	.set	reorder
@@ -4042,7 +4792,7 @@ $L953:
 
 	sw	$2,48($sp)
 	addiu	$5,$16,%lo($LC28)
-$L954:
+$L963:
 	.set	noreorder
 	.set	nomacro
 	jal	strsep
@@ -4073,13 +4823,13 @@ $L954:
 	lw	$2,40($sp)
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L954
+	bne	$2,$0,$L963
 	addiu	$5,$16,%lo($LC28)
 	.set	macro
 	.set	reorder
 
-	j	$L951
-$L693:
+	j	$L960
+$L702:
 	.set	noreorder
 	.set	nomacro
 	jal	strlen
@@ -4098,7 +4848,7 @@ $L693:
 
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L698
+	bne	$2,$0,$L707
 	lui	$16,%hi($LC30)
 	.set	macro
 	.set	reorder
@@ -4110,8 +4860,8 @@ $L693:
 	.set	macro
 	.set	reorder
 
-	j	$L951
-$L698:
+	j	$L960
+$L707:
 	.set	noreorder
 	.set	nomacro
 	jal	strlen
@@ -4130,7 +4880,7 @@ $L698:
 
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L700
+	bne	$2,$0,$L709
 	li	$3,1			# 0x1
 	.set	macro
 	.set	reorder
@@ -4138,12 +4888,12 @@ $L698:
 	lui	$2,%hi(log_enable)
 	.set	noreorder
 	.set	nomacro
-	j	$L951
+	j	$L960
 	sw	$3,%lo(log_enable)($2)
 	.set	macro
 	.set	reorder
 
-$L700:
+$L709:
 	lui	$16,%hi($LC31)
 	.set	noreorder
 	.set	nomacro
@@ -4163,7 +4913,7 @@ $L700:
 
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L951
+	bne	$2,$0,$L960
 	lui	$5,%hi($LC32)
 	.set	macro
 	.set	reorder
@@ -4178,7 +4928,7 @@ $L700:
 
 	sw	$2,44($sp)
 	lui	$5,%hi($LC33)
-$L961:
+$L970:
 	addiu	$4,$sp,40
 	.set	noreorder
 	.set	nomacro
@@ -4189,7 +4939,7 @@ $L961:
 
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L951
+	beq	$2,$0,$L960
 	sw	$2,44($sp)
 	.set	macro
 	.set	reorder
@@ -4206,7 +4956,7 @@ $L961:
 
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L955
+	bne	$2,$0,$L964
 	lui	$22,%hi($LC34)
 	.set	macro
 	.set	reorder
@@ -4214,8 +4964,8 @@ $L961:
 	lw	$4,44($sp)
 	jal	strlen
 	li	$3,1			# 0x1
-	beq	$2,$3,$L951
-$L955:
+	beq	$2,$3,$L960
+$L964:
 	addiu	$4,$sp,44
 	.set	noreorder
 	.set	nomacro
@@ -4233,9 +4983,9 @@ $L955:
 	.set	reorder
 
 	li	$3,-1			# 0xffffffff
-	beq	$2,$3,$L951
+	beq	$2,$3,$L960
 	addiu	$4,$sp,44
-$L960:
+$L969:
 	addiu	$5,$22,%lo($LC34)
 	.set	noreorder
 	.set	nomacro
@@ -4282,14 +5032,14 @@ $L960:
 	li	$2,2			# 0x2
 	.set	noreorder
 	.set	nomacro
-	beq	$16,$2,$L769
+	beq	$16,$2,$L778
 	slt	$2,$16,3
 	.set	macro
 	.set	reorder
 
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L946
+	beq	$2,$0,$L955
 	li	$2,3			# 0x3
 	.set	macro
 	.set	reorder
@@ -4297,32 +5047,32 @@ $L960:
 	li	$2,1			# 0x1
 	.set	noreorder
 	.set	nomacro
-	beq	$16,$2,$L956
+	beq	$16,$2,$L965
 	lui	$2,%hi(malloc_sizes+20)
 	.set	macro
 	.set	reorder
 
-	j	$L711
-$L946:
+	j	$L720
+$L955:
 	.set	noreorder
 	.set	nomacro
-	beq	$16,$2,$L826
+	beq	$16,$2,$L835
 	li	$2,4			# 0x4
 	.set	macro
 	.set	reorder
 
 	.set	noreorder
 	.set	nomacro
-	beq	$16,$2,$L957
+	beq	$16,$2,$L966
 	lui	$2,%hi(malloc_sizes+20)
 	.set	macro
 	.set	reorder
 
-	j	$L711
-$L714:
-$L721:
-$L762:
-$L956:
+	j	$L720
+$L723:
+$L730:
+$L771:
+$L965:
 	lw	$4,%lo(malloc_sizes+20)($2)
 	.set	noreorder
 	.set	nomacro
@@ -4336,7 +5086,7 @@ $L956:
 	addiu	$4,$sp,48
 	.set	noreorder
 	.set	nomacro
-	beq	$16,$0,$L951
+	beq	$16,$0,$L960
 	addiu	$2,$2,8
 	.set	macro
 	.set	reorder
@@ -4411,15 +5161,15 @@ $L956:
 	lw	$2,48($sp)
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L714
+	bne	$2,$0,$L723
 	lui	$2,%hi(malloc_sizes+20)
 	.set	macro
 	.set	reorder
 
-	j	$L711
-$L769:
-$L774:
-$L815:
+	j	$L720
+$L778:
+$L783:
+$L824:
 	lui	$2,%hi(malloc_sizes+20)
 	lw	$4,%lo(malloc_sizes+20)($2)
 	.set	noreorder
@@ -4431,7 +5181,7 @@ $L815:
 
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L951
+	beq	$2,$0,$L960
 	move	$17,$2
 	.set	macro
 	.set	reorder
@@ -4457,7 +5207,7 @@ $L815:
 
 	sw	$2,56($sp)
 	lui	$5,%hi($LC36)
-$L958:
+$L967:
 	addiu	$4,$sp,56
 	addiu	$5,$5,%lo($LC36)
 	.set	noreorder
@@ -4479,7 +5229,7 @@ $L958:
 	lw	$2,56($sp)
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L958
+	bne	$2,$0,$L967
 	lui	$5,%hi($LC36)
 	.set	macro
 	.set	reorder
@@ -4492,12 +5242,12 @@ $L958:
 	.set	macro
 	.set	reorder
 
-	j	$L711
-$L826:
-$L833:
-$L874:
+	j	$L720
+$L835:
+$L842:
+$L883:
 	lui	$2,%hi(malloc_sizes+20)
-$L959:
+$L968:
 	lw	$4,%lo(malloc_sizes+20)($2)
 	.set	noreorder
 	.set	nomacro
@@ -4510,7 +5260,7 @@ $L959:
 	move	$16,$2
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L951
+	beq	$2,$0,$L960
 	addiu	$4,$sp,48
 	.set	macro
 	.set	reorder
@@ -4520,7 +5270,7 @@ $L959:
 	lb	$2,0($2)
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L828
+	beq	$2,$0,$L837
 	addiu	$3,$16,8
 	.set	macro
 	.set	reorder
@@ -4539,7 +5289,7 @@ $L959:
 	sltu	$2,$2,41
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L883
+	beq	$2,$0,$L892
 	li	$5,39			# 0x27
 	.set	macro
 	.set	reorder
@@ -4547,11 +5297,11 @@ $L959:
 	lw	$4,56($sp)
 	jal	strlen
 	move	$5,$2
-$L883:
+$L892:
 	lw	$4,56($sp)
 	.set	noreorder
 	.set	nomacro
-	beq	$5,$0,$L885
+	beq	$5,$0,$L894
 	addiu	$3,$16,28
 	.set	macro
 	.set	reorder
@@ -4571,7 +5321,7 @@ $L883:
 	.set	at
 	.set	reorder
 #NO_APP
-$L885:
+$L894:
 	addu	$2,$5,$16
 	li	$4,3			# 0x3
 	move	$5,$16
@@ -4582,20 +5332,20 @@ $L885:
 	.set	macro
 	.set	reorder
 
-$L828:
+$L837:
 	lw	$2,48($sp)
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L959
+	bne	$2,$0,$L968
 	lui	$2,%hi(malloc_sizes+20)
 	.set	macro
 	.set	reorder
 
-	j	$L711
-$L887:
-$L894:
-$L935:
-$L957:
+	j	$L720
+$L896:
+$L903:
+$L944:
+$L966:
 	li	$5,208			# 0xd0
 	lw	$4,%lo(malloc_sizes+20)($2)
 	.set	noreorder
@@ -4610,7 +5360,7 @@ $L957:
 	addiu	$4,$sp,48
 	.set	noreorder
 	.set	nomacro
-	beq	$16,$0,$L951
+	beq	$16,$0,$L960
 	addiu	$2,$2,8
 	.set	macro
 	.set	reorder
@@ -4659,19 +5409,19 @@ $L957:
 	move	$4,$2
 	sw	$2,56($sp)
 	lw	$2,60($sp)
-	bne	$2,$0,$L942
+	bne	$2,$0,$L951
 	jal	str2hexnum
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L952
+	beq	$2,$0,$L961
 	li	$2,1440			# 0x5a0
 	.set	macro
 	.set	reorder
 
-$L942:
+$L951:
 	lw	$4,56($sp)
 	jal	str2hexnum
-$L952:
+$L961:
 	li	$6,4			# 0x4
 	addiu	$4,$16,32
 	addiu	$5,$sp,60
@@ -4703,14 +5453,14 @@ $L952:
 	li	$6,4			# 0x4
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L944
+	bne	$2,$0,$L953
 	sw	$2,60($sp)
 	.set	macro
 	.set	reorder
 
 	li	$2,255			# 0xff
 	sw	$2,60($sp)
-$L944:
+$L953:
 	jal	memcpy
 	move	$5,$16
 	.set	noreorder
@@ -4723,16 +5473,16 @@ $L944:
 	lw	$2,48($sp)
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L887
+	bne	$2,$0,$L896
 	lui	$2,%hi(malloc_sizes+20)
 	.set	macro
 	.set	reorder
 
-$L711:
+$L720:
 	lw	$2,44($sp)
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L960
+	bne	$2,$0,$L969
 	addiu	$4,$sp,44
 	.set	macro
 	.set	reorder
@@ -4744,12 +5494,12 @@ $L711:
 	lw	$2,40($sp)
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L961
+	bne	$2,$0,$L970
 	lui	$5,%hi($LC33)
 	.set	macro
 	.set	reorder
 
-$L951:
+$L960:
 	.set	noreorder
 	.set	nomacro
 	jal	kfree
@@ -4759,12 +5509,12 @@ $L951:
 
 	.set	noreorder
 	.set	nomacro
-	j	$L633
+	j	$L642
 	move	$2,$20
 	.set	macro
 	.set	reorder
 
-$L947:
+$L956:
 	.set	noreorder
 	.set	nomacro
 	jal	kfree
@@ -4773,7 +5523,7 @@ $L947:
 	.set	reorder
 
 	li	$2,-14			# 0xfffffff2
-$L633:
+$L642:
 	lw	$31,92($sp)
 	lw	$22,88($sp)
 	lw	$21,84($sp)
@@ -4815,24 +5565,24 @@ dos_pkt_locate:
 	sll	$4,$4,2
 	lw	$3,0($3)
 	addiu	$2,$2,%lo(dos_pkt)
-	bne	$6,$3,$L963
+	bne	$6,$3,$L972
 	addu	$4,$4,$2
 
 	lw	$2,24($4)
-	bne	$2,$6,$L969
+	bne	$2,$6,$L978
 	move	$5,$0
 
-	j	$L962
+	j	$L971
 	sb	$0,0($4)
 
-$L963:
+$L972:
 	lw	$2,24($4)
-$L969:
-	beq	$2,$6,$L968
+$L978:
+	beq	$2,$6,$L977
 	move	$5,$0
 
 	lb	$2,0($4)
-	bne	$2,$0,$L962
+	bne	$2,$0,$L971
 	nop
 
 	lui	$2,%hi(cur_p_pkt)
@@ -4840,19 +5590,19 @@ $L969:
 	sw	$4,%lo(cur_p_pkt)($2)
 	li	$2,1
 	sw	$6,24($4)
-	j	$L962
+	j	$L971
 	sb	$2,0($4)
 
-$L968:
+$L977:
 	lb	$3,0($4)
 	li	$2,1			# 0x1
-	bne	$3,$2,$L962
+	bne	$3,$2,$L971
 	nop
 
 	lui	$2,%hi(cur_p_pkt)
 	li	$5,1			# 0x1
 	sw	$4,%lo(cur_p_pkt)($2)
-$L962:
+$L971:
 	j	$31
 	move	$2,$5
 
@@ -4946,34 +5696,34 @@ dos_timer_fn:
 	sw	$17,44($sp)
 	sw	$16,40($sp)
 	lw	$5,%lo(item)($6)
-	beq	$5,$0,$L971
+	beq	$5,$0,$L980
 	lui	$2,%hi(block_time)
 
 	lui	$4,%hi(block_count)
 	lw	$3,%lo(block_time)($2)
 	lw	$2,%lo(block_count)($4)
 	slt	$2,$2,$3
-	bne	$2,$0,$L1020
+	bne	$2,$0,$L1029
 	lui	$2,%hi(block)
 
 	sw	$0,%lo(block)($2)
 	sw	$0,%lo(block_count)($4)
 	lui	$2,%hi(block)
-$L1020:
+$L1029:
 	lw	$3,%lo(block)($2)
 	li	$2,1			# 0x1
-	bne	$3,$2,$L1021
+	bne	$3,$2,$L1030
 	andi	$2,$5,0x1e
 
 	lw	$2,%lo(block_count)($4)
 	addiu	$2,$2,1
 	sw	$2,%lo(block_count)($4)
 	andi	$2,$5,0x1e
-$L1021:
+$L1030:
 	move	$8,$0
 	move	$9,$0
 	move	$10,$0
-	beq	$2,$0,$L987
+	beq	$2,$0,$L996
 	move	$12,$0
 
 	lw	$3,%lo(item)($6)
@@ -4985,14 +5735,14 @@ $L1021:
 	andi	$13,$3,0x4
 	andi	$11,$3,0x8
 	li	$7,1023			# 0x3ff
-$L982:
+$L991:
 	lbu	$4,0($5)
 	sll	$2,$4,24
 	sra	$2,$2,24
-	bne	$2,$6,$L1022
+	bne	$2,$6,$L1031
 	sll	$2,$4,24
 
-	beq	$14,$0,$L1023
+	beq	$14,$0,$L1032
 	sra	$2,$2,24
 
 	lw	$2,4($5)
@@ -5000,13 +5750,13 @@ $L982:
 	addu	$2,$8,$2
 	movn	$8,$2,$3		#conditional move  
 	sll	$2,$4,24
-$L1022:
+$L1031:
 	sra	$2,$2,24
-$L1023:
-	bne	$2,$6,$L1024
+$L1032:
+	bne	$2,$6,$L1033
 	sll	$2,$4,24
 
-	beq	$13,$0,$L1025
+	beq	$13,$0,$L1034
 	sra	$2,$2,24
 
 	lw	$2,8($5)
@@ -5014,13 +5764,13 @@ $L1023:
 	addu	$2,$9,$2
 	movn	$9,$2,$3		#conditional move  
 	sll	$2,$4,24
-$L1024:
+$L1033:
 	sra	$2,$2,24
-$L1025:
-	bne	$2,$6,$L1026
+$L1034:
+	bne	$2,$6,$L1035
 	sll	$2,$4,24
 
-	beq	$11,$0,$L1027
+	beq	$11,$0,$L1036
 	sra	$2,$2,24
 
 	lw	$2,12($5)
@@ -5028,105 +5778,105 @@ $L1025:
 	addu	$2,$10,$2
 	movn	$10,$2,$3		#conditional move  
 	sll	$2,$4,24
-$L1026:
+$L1035:
 	sra	$2,$2,24
-$L1027:
-	bne	$2,$6,$L977
+$L1036:
+	bne	$2,$6,$L986
 	nop
 
-	beq	$15,$0,$L977
+	beq	$15,$0,$L986
 	nop
 
 	lw	$2,16($5)
 	slt	$3,$0,$2
 	addu	$2,$12,$2
 	movn	$12,$2,$3		#conditional move  
-$L977:
+$L986:
 	addiu	$7,$7,-1
-	bgez	$7,$L982
+	bgez	$7,$L991
 	addiu	$5,$5,36
 
 	lui	$2,%hi(whole_syn_threshold)
 	lw	$3,%lo(whole_syn_threshold)($2)
 	slt	$2,$3,$8
-	beq	$2,$0,$L1028
+	beq	$2,$0,$L1037
 	lui	$2,%hi(whole_fin_threshold)
 
 	lui	$2,%hi(item)
 	lw	$2,%lo(item)($2)
 	andi	$2,$2,0x2
-	beq	$2,$0,$L1028
+	beq	$2,$0,$L1037
 	lui	$2,%hi(whole_fin_threshold)
 
-	blez	$3,$L1028
+	blez	$3,$L1037
 	lui	$3,%hi(LogFlag)
 
 	lw	$2,%lo(LogFlag)($3)
 	ori	$2,$2,0x2
 	sw	$2,%lo(LogFlag)($3)
 	lui	$2,%hi(whole_fin_threshold)
-$L1028:
+$L1037:
 	lw	$3,%lo(whole_fin_threshold)($2)
 	slt	$2,$3,$9
-	beq	$2,$0,$L1029
+	beq	$2,$0,$L1038
 	lui	$2,%hi(whole_udp_threshold)
 
 	lui	$2,%hi(item)
 	lw	$2,%lo(item)($2)
 	andi	$2,$2,0x4
-	beq	$2,$0,$L1029
+	beq	$2,$0,$L1038
 	lui	$2,%hi(whole_udp_threshold)
 
-	blez	$3,$L1029
+	blez	$3,$L1038
 	lui	$3,%hi(LogFlag)
 
 	lw	$2,%lo(LogFlag)($3)
 	ori	$2,$2,0x4
 	sw	$2,%lo(LogFlag)($3)
 	lui	$2,%hi(whole_udp_threshold)
-$L1029:
+$L1038:
 	lw	$3,%lo(whole_udp_threshold)($2)
 	slt	$2,$3,$10
-	beq	$2,$0,$L1030
+	beq	$2,$0,$L1039
 	lui	$2,%hi(whole_icmp_threshold)
 
 	lui	$2,%hi(item)
 	lw	$2,%lo(item)($2)
 	andi	$2,$2,0x8
-	beq	$2,$0,$L1030
+	beq	$2,$0,$L1039
 	lui	$2,%hi(whole_icmp_threshold)
 
-	blez	$3,$L1030
+	blez	$3,$L1039
 	lui	$3,%hi(LogFlag)
 
 	lw	$2,%lo(LogFlag)($3)
 	ori	$2,$2,0x8
 	sw	$2,%lo(LogFlag)($3)
 	lui	$2,%hi(whole_icmp_threshold)
-$L1030:
+$L1039:
 	lw	$3,%lo(whole_icmp_threshold)($2)
 	slt	$2,$3,$12
-	beq	$2,$0,$L1031
+	beq	$2,$0,$L1040
 	lui	$17,%hi(LogFlag)
 
 	lui	$2,%hi(item)
 	lw	$2,%lo(item)($2)
 	andi	$2,$2,0x10
-	beq	$2,$0,$L1031
+	beq	$2,$0,$L1040
 	nop
 
-	blez	$3,$L1031
+	blez	$3,$L1040
 	lui	$3,%hi(LogFlag)
 
 	lw	$2,%lo(LogFlag)($3)
 	ori	$2,$2,0x10
 	sw	$2,%lo(LogFlag)($3)
-$L987:
+$L996:
 	lui	$17,%hi(LogFlag)
-$L1031:
+$L1040:
 	lw	$16,%lo(LogFlag)($17)
 	andi	$2,$16,0x2
-	beq	$2,$0,$L1032
+	beq	$2,$0,$L1041
 	andi	$2,$16,0x4
 
 	lui	$4,%hi($LC37)
@@ -5134,8 +5884,8 @@ $L1031:
 	addiu	$4,$4,%lo($LC37)
 
 	andi	$2,$16,0x4
-$L1032:
-	beq	$2,$0,$L1033
+$L1041:
+	beq	$2,$0,$L1042
 	andi	$2,$16,0x8
 
 	lui	$4,%hi($LC38)
@@ -5143,8 +5893,8 @@ $L1032:
 	addiu	$4,$4,%lo($LC38)
 
 	andi	$2,$16,0x8
-$L1033:
-	beq	$2,$0,$L1034
+$L1042:
+	beq	$2,$0,$L1043
 	andi	$2,$16,0x10
 
 	lui	$4,%hi($LC39)
@@ -5152,8 +5902,8 @@ $L1033:
 	addiu	$4,$4,%lo($LC39)
 
 	andi	$2,$16,0x10
-$L1034:
-	beq	$2,$0,$L1035
+$L1043:
+	beq	$2,$0,$L1044
 	andi	$2,$16,0x20
 
 	lui	$4,%hi($LC40)
@@ -5161,8 +5911,8 @@ $L1034:
 	addiu	$4,$4,%lo($LC40)
 
 	andi	$2,$16,0x20
-$L1035:
-	beq	$2,$0,$L1036
+$L1044:
+	beq	$2,$0,$L1045
 	andi	$2,$16,0x40
 
 	lui	$2,%hi(attack_saddr+4)
@@ -5191,8 +5941,8 @@ $L1035:
 	sw	$2,32($sp)
 
 	andi	$2,$16,0x40
-$L1036:
-	beq	$2,$0,$L1037
+$L1045:
+	beq	$2,$0,$L1046
 	andi	$2,$16,0x80
 
 	lui	$2,%hi(attack_saddr+8)
@@ -5221,8 +5971,8 @@ $L1036:
 	sw	$2,32($sp)
 
 	andi	$2,$16,0x80
-$L1037:
-	beq	$2,$0,$L1038
+$L1046:
+	beq	$2,$0,$L1047
 	andi	$2,$16,0x100
 
 	lui	$2,%hi(attack_saddr+12)
@@ -5251,8 +6001,8 @@ $L1037:
 	sw	$2,32($sp)
 
 	andi	$2,$16,0x100
-$L1038:
-	beq	$2,$0,$L1039
+$L1047:
+	beq	$2,$0,$L1048
 	andi	$2,$16,0x200
 
 	lui	$2,%hi(attack_saddr+16)
@@ -5281,8 +6031,8 @@ $L1038:
 	sw	$2,32($sp)
 
 	andi	$2,$16,0x200
-$L1039:
-	beq	$2,$0,$L1040
+$L1048:
+	beq	$2,$0,$L1049
 	andi	$2,$16,0x8000
 
 	lui	$2,%hi(attack_saddr+20)
@@ -5311,8 +6061,8 @@ $L1039:
 	sw	$2,32($sp)
 
 	andi	$2,$16,0x8000
-$L1040:
-	beq	$2,$0,$L1041
+$L1049:
+	beq	$2,$0,$L1050
 	li	$2,65536			# 0x10000
 
 	lui	$2,%hi(attack_saddr+44)
@@ -5341,9 +6091,9 @@ $L1040:
 	sw	$2,32($sp)
 
 	li	$2,65536			# 0x10000
-$L1041:
+$L1050:
 	and	$2,$16,$2
-	beq	$2,$0,$L1042
+	beq	$2,$0,$L1051
 	andi	$2,$16,0x800
 
 	lui	$2,%hi(attack_saddr+48)
@@ -5372,8 +6122,8 @@ $L1041:
 	sw	$2,32($sp)
 
 	andi	$2,$16,0x800
-$L1042:
-	beq	$2,$0,$L1043
+$L1051:
+	beq	$2,$0,$L1052
 	li	$2,262144			# 0x40000
 
 	lui	$2,%hi(attack_saddr+28)
@@ -5402,9 +6152,9 @@ $L1042:
 	sw	$2,32($sp)
 
 	li	$2,262144			# 0x40000
-$L1043:
+$L1052:
 	and	$2,$16,$2
-	beq	$2,$0,$L1044
+	beq	$2,$0,$L1053
 	li	$2,131072			# 0x20000
 
 	lui	$2,%hi(attack_saddr+56)
@@ -5433,9 +6183,9 @@ $L1043:
 	sw	$2,32($sp)
 
 	li	$2,131072			# 0x20000
-$L1044:
+$L1053:
 	and	$2,$16,$2
-	beq	$2,$0,$L1045
+	beq	$2,$0,$L1054
 	andi	$2,$16,0x4000
 
 	lui	$2,%hi(attack_saddr+52)
@@ -5464,8 +6214,8 @@ $L1044:
 	sw	$2,32($sp)
 
 	andi	$2,$16,0x4000
-$L1045:
-	beq	$2,$0,$L1046
+$L1054:
+	beq	$2,$0,$L1055
 	andi	$2,$16,0x400
 
 	lui	$2,%hi(attack_saddr+40)
@@ -5494,8 +6244,8 @@ $L1045:
 	sw	$2,32($sp)
 
 	andi	$2,$16,0x400
-$L1046:
-	beq	$2,$0,$L1047
+$L1055:
+	beq	$2,$0,$L1056
 	andi	$2,$16,0x1000
 
 	lui	$2,%hi(attack_saddr+24)
@@ -5524,8 +6274,8 @@ $L1046:
 	sw	$2,32($sp)
 
 	andi	$2,$16,0x1000
-$L1047:
-	beq	$2,$0,$L1048
+$L1056:
+	beq	$2,$0,$L1057
 	andi	$2,$16,0x2000
 
 	lui	$2,%hi(attack_saddr+32)
@@ -5554,8 +6304,8 @@ $L1047:
 	sw	$2,32($sp)
 
 	andi	$2,$16,0x2000
-$L1048:
-	beq	$2,$0,$L1005
+$L1057:
+	beq	$2,$0,$L1014
 	nop
 
 	lui	$2,%hi(attack_saddr+36)
@@ -5583,12 +6333,12 @@ $L1048:
 	jal	scrlog_printk
 	sw	$2,32($sp)
 
-$L1005:
+$L1014:
 	lui	$2,%hi(dos_pkt)
 	li	$3,1023			# 0x3ff
 	sw	$0,%lo(LogFlag)($17)
 	addiu	$2,$2,%lo(dos_pkt)
-$L1010:
+$L1019:
 	addiu	$3,$3,-1
 	sb	$0,0($2)
 	sw	$0,24($2)
@@ -5597,37 +6347,37 @@ $L1010:
 	sw	$0,12($2)
 	sw	$0,16($2)
 	sw	$0,20($2)
-	bgez	$3,$L1010
+	bgez	$3,$L1019
 	addiu	$2,$2,36
 
-$L971:
+$L980:
 	lui	$6,%hi(none_dos_drop_pkt_cnt)
 	lw	$2,%lo(none_dos_drop_pkt_cnt)($6)
 	sltu	$2,$2,3001
-	bne	$2,$0,$L1012
+	bne	$2,$0,$L1021
 	lui	$4,%hi(item_backup)
 
 	lui	$4,%hi(item)
 	lw	$3,%lo(item)($4)
-	beq	$3,$0,$L1049
+	beq	$3,$0,$L1058
 	lui	$2,%hi(jiffies)
 
 	lui	$2,%hi(item_backup)
 	sw	$3,%lo(item_backup)($2)
-	j	$L1014
+	j	$L1023
 	sw	$0,%lo(item)($4)
 
-$L1012:
+$L1021:
 	lw	$3,%lo(item_backup)($4)
-	beq	$3,$0,$L1049
+	beq	$3,$0,$L1058
 	lui	$2,%hi(jiffies)
 
 	lui	$2,%hi(item)
 	sw	$3,%lo(item)($2)
 	sw	$0,%lo(item_backup)($4)
-$L1014:
+$L1023:
 	lui	$2,%hi(jiffies)
-$L1049:
+$L1058:
 	lui	$4,%hi(dos_timer)
 	lw	$5,%lo(jiffies)($2)
 	addiu	$4,$4,%lo(dos_timer)
@@ -5677,13 +6427,13 @@ dos_read_proc:
 	subu	$4,$4,$17
 	slt	$3,$16,$4
 	movn	$4,$16,$3		#conditional move
-	bne	$2,$0,$L1051
+	bne	$2,$0,$L1060
 	slt	$5,$4,0
 
 	lw	$2,56($sp)
 	li	$3,1			# 0x1
 	sw	$3,0($2)
-$L1051:
+$L1060:
 	sw	$18,0($19)
 	move	$2,$0
 	lw	$31,32($sp)
@@ -5717,15 +6467,15 @@ strtok:
 	move	$17,$5
 	sw	$16,16($sp)
 	move	$16,$4
-	bne	$4,$0,$L1056
+	bne	$4,$0,$L1065
 	sw	$31,24($sp)
 
 	lui	$2,%hi(___strtok)
 	lw	$16,%lo(___strtok)($2)
-	beq	$16,$0,$L1054
+	beq	$16,$0,$L1063
 	nop
 
-$L1056:
+$L1065:
 	jal	strspn
 	move	$4,$16
 
@@ -5733,32 +6483,32 @@ $L1056:
 	addu	$16,$16,$2
 	move	$3,$0
 	lb	$2,0($16)
-	bne	$2,$0,$L1057
+	bne	$2,$0,$L1066
 	move	$4,$16
 
 	lui	$2,%hi(___strtok)
-	j	$L1054
+	j	$L1063
 	sw	$0,%lo(___strtok)($2)
 
-$L1057:
+$L1066:
 	jal	strpbrk
 	nop
 
-	beq	$2,$0,$L1058
+	beq	$2,$0,$L1067
 	move	$3,$2
 
 	lb	$2,0($2)
-	beq	$2,$0,$L1059
+	beq	$2,$0,$L1068
 	lui	$2,%hi(___strtok)
 
 	sb	$0,0($3)
 	addiu	$3,$3,1
-$L1058:
+$L1067:
 	lui	$2,%hi(___strtok)
-$L1059:
+$L1068:
 	sw	$3,%lo(___strtok)($2)
 	move	$3,$16
-$L1054:
+$L1063:
 	lw	$31,24($sp)
 	move	$2,$3
 	lw	$17,20($sp)
@@ -5790,14 +6540,14 @@ dos_write_proc:
 	addiu	$17,$sp,16
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L1060
+	bne	$2,$0,$L1069
 	sw	$16,96($sp)
 	.set	macro
 	.set	reorder
 
 	.set	noreorder
 	.set	nomacro
-	beq	$5,$0,$L1062
+	beq	$5,$0,$L1071
 	addiu	$3,$5,80
 	.set	macro
 	.set	reorder
@@ -5808,7 +6558,7 @@ dos_write_proc:
 	lui	$3,%hi(dos_flag)
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L1062
+	bne	$2,$0,$L1071
 	addiu	$3,$3,%lo(dos_flag)
 	.set	macro
 	.set	reorder
@@ -5825,7 +6575,7 @@ dos_write_proc:
 #NO_APP
 	.set	noreorder
 	.set	nomacro
-	bne	$6,$0,$L1062
+	bne	$6,$0,$L1071
 	li	$2,80			# 0x50
 	.set	macro
 	.set	reorder
@@ -5847,12 +6597,12 @@ dos_write_proc:
 #NO_APP
 	.set	noreorder
 	.set	nomacro
-	j	$L1091
+	j	$L1100
 	lui	$5,%hi($LC28)
 	.set	macro
 	.set	reorder
 
-$L1090:
+$L1099:
 	move	$4,$16
 	move	$5,$0
 	move	$6,$0
@@ -5868,44 +6618,44 @@ $L1090:
 	sltu	$2,$3,13
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L1092
+	beq	$2,$0,$L1101
 	addiu	$2,$18,1
 	.set	macro
 	.set	reorder
 
 	sll	$2,$3,2
-	lui	$3,%hi($L1089)
-	addiu	$3,$3,%lo($L1089)
+	lui	$3,%hi($L1098)
+	addiu	$3,$3,%lo($L1098)
 	addu	$2,$2,$3
 	lw	$2,0($2)
 	j	$2
 	.rdata
 	.align	2
-$L1089:
-	.word	$L1075
-	.word	$L1076
-	.word	$L1077
-	.word	$L1078
-	.word	$L1079
-	.word	$L1080
-	.word	$L1081
-	.word	$L1082
-	.word	$L1083
+$L1098:
 	.word	$L1084
 	.word	$L1085
 	.word	$L1086
 	.word	$L1087
+	.word	$L1088
+	.word	$L1089
+	.word	$L1090
+	.word	$L1091
+	.word	$L1092
+	.word	$L1093
+	.word	$L1094
+	.word	$L1095
+	.word	$L1096
 	.section	.text.dos_write_proc
-$L1075:
+$L1084:
 	lui	$2,%hi(op_mode)
 	.set	noreorder
 	.set	nomacro
-	j	$L1074
+	j	$L1083
 	sb	$4,%lo(op_mode)($2)
 	.set	macro
 	.set	reorder
 
-$L1076:
+$L1085:
 	move	$4,$16
 	move	$5,$0
 	.set	noreorder
@@ -5918,12 +6668,12 @@ $L1076:
 	lui	$3,%hi(lan_addr)
 	.set	noreorder
 	.set	nomacro
-	j	$L1074
+	j	$L1083
 	sw	$2,%lo(lan_addr)($3)
 	.set	macro
 	.set	reorder
 
-$L1077:
+$L1086:
 	move	$4,$16
 	move	$5,$0
 	.set	noreorder
@@ -5936,103 +6686,103 @@ $L1077:
 	lui	$3,%hi(lan_mask)
 	.set	noreorder
 	.set	nomacro
-	j	$L1074
+	j	$L1083
 	sw	$2,%lo(lan_mask)($3)
 	.set	macro
 	.set	reorder
 
-$L1078:
+$L1087:
 	lui	$2,%hi(item)
 	sw	$4,%lo(item)($2)
 	lui	$2,%hi(item_backup)
 	.set	noreorder
 	.set	nomacro
-	j	$L1074
+	j	$L1083
 	sw	$0,%lo(item_backup)($2)
 	.set	macro
 	.set	reorder
 
-$L1079:
+$L1088:
 	lui	$2,%hi(whole_syn_threshold)
 	.set	noreorder
 	.set	nomacro
-	j	$L1074
+	j	$L1083
 	sw	$4,%lo(whole_syn_threshold)($2)
 	.set	macro
 	.set	reorder
 
-$L1080:
+$L1089:
 	lui	$2,%hi(whole_fin_threshold)
 	.set	noreorder
 	.set	nomacro
-	j	$L1074
+	j	$L1083
 	sw	$4,%lo(whole_fin_threshold)($2)
 	.set	macro
 	.set	reorder
 
-$L1081:
+$L1090:
 	lui	$2,%hi(whole_udp_threshold)
 	.set	noreorder
 	.set	nomacro
-	j	$L1074
+	j	$L1083
 	sw	$4,%lo(whole_udp_threshold)($2)
 	.set	macro
 	.set	reorder
 
-$L1082:
+$L1091:
 	lui	$2,%hi(whole_icmp_threshold)
 	.set	noreorder
 	.set	nomacro
-	j	$L1074
+	j	$L1083
 	sw	$4,%lo(whole_icmp_threshold)($2)
 	.set	macro
 	.set	reorder
 
-$L1083:
+$L1092:
 	lui	$2,%hi(per_syn_threshold)
 	.set	noreorder
 	.set	nomacro
-	j	$L1074
+	j	$L1083
 	sw	$4,%lo(per_syn_threshold)($2)
 	.set	macro
 	.set	reorder
 
-$L1084:
+$L1093:
 	lui	$2,%hi(per_fin_threshold)
 	.set	noreorder
 	.set	nomacro
-	j	$L1074
+	j	$L1083
 	sw	$4,%lo(per_fin_threshold)($2)
 	.set	macro
 	.set	reorder
 
-$L1085:
+$L1094:
 	lui	$2,%hi(per_udp_threshold)
 	.set	noreorder
 	.set	nomacro
-	j	$L1074
+	j	$L1083
 	sw	$4,%lo(per_udp_threshold)($2)
 	.set	macro
 	.set	reorder
 
-$L1086:
+$L1095:
 	lui	$2,%hi(per_icmp_threshold)
 	.set	noreorder
 	.set	nomacro
-	j	$L1074
+	j	$L1083
 	sw	$4,%lo(per_icmp_threshold)($2)
 	.set	macro
 	.set	reorder
 
-$L1087:
+$L1096:
 	lui	$2,%hi(block_time)
 	sw	$4,%lo(block_time)($2)
-$L1074:
+$L1083:
 	addiu	$2,$18,1
-$L1092:
+$L1101:
 	andi	$18,$2,0x00ff
 	lui	$5,%hi($LC28)
-$L1091:
+$L1100:
 	move	$4,$17
 	.set	noreorder
 	.set	nomacro
@@ -6043,21 +6793,21 @@ $L1091:
 
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L1090
+	bne	$2,$0,$L1099
 	move	$16,$2
 	.set	macro
 	.set	reorder
 
 	.set	noreorder
 	.set	nomacro
-	j	$L1060
+	j	$L1069
 	move	$3,$19
 	.set	macro
 	.set	reorder
 
-$L1062:
+$L1071:
 	li	$3,-14			# 0xfffffff2
-$L1060:
+$L1069:
 	lw	$31,112($sp)
 	move	$2,$3
 	lw	$19,108($sp)
@@ -6138,14 +6888,14 @@ unregister_customRspStr:
 	lui	$16,%hi(block_message)
 	lw	$2,%lo(block_message)($16)
 	sw	$31,20($sp)
-	beq	$2,$0,$L1095
+	beq	$2,$0,$L1104
 	move	$4,$2
 
 	jal	kfree
 	nop
 
 	sw	$0,%lo(block_message)($16)
-$L1095:
+$L1104:
 	lw	$31,20($sp)
 	lw	$16,16($sp)
 	j	$31
@@ -6175,11 +6925,11 @@ register_customRspStr:
 	jal	unregister_customRspStr
 	lui	$17,%hi($LC24)
 
-	beq	$16,$0,$L1098
+	beq	$16,$0,$L1107
 	move	$4,$16
 
-$L1103:
-$L1144:
+$L1112:
+$L1153:
 	jal	strlen
 	nop
 
@@ -6190,12 +6940,12 @@ $L1144:
 	lui	$5,%hi($LC6)
 	move	$4,$2
 	addiu	$5,$5,%lo($LC6)
-	j	$L1199
+	j	$L1208
 	move	$6,$16
 
-$L1098:
-$L1153:
-$L1194:
+$L1107:
+$L1162:
+$L1203:
 	jal	strlen
 	addiu	$4,$17,%lo($LC24)
 
@@ -6207,15 +6957,15 @@ $L1194:
 	move	$4,$2
 	addiu	$5,$5,%lo($LC6)
 	addiu	$6,$17,%lo($LC24)
-$L1199:
+$L1208:
 	lui	$3,%hi(block_message)
-	beq	$2,$0,$L1097
+	beq	$2,$0,$L1106
 	sw	$2,%lo(block_message)($3)
 
 	jal	sprintf
 	nop
 
-$L1097:
+$L1106:
 	lw	$31,40($sp)
 	lw	$17,36($sp)
 	lw	$16,32($sp)
@@ -6238,35 +6988,35 @@ register_customRspHook:
 	.set	noreorder
 	.set	nomacro
 	
-	beq	$4,$0,$L1201
+	beq	$4,$0,$L1210
 	lui	$3,%hi(fast_path_cusRsp401_func)
 
-	j	$L1202
+	j	$L1211
 	sw	$4,%lo(fast_path_cusRsp401_func)($3)
 
-$L1201:
+$L1210:
 	lui	$2,%hi(GenerateHTTP401)
 	addiu	$2,$2,%lo(GenerateHTTP401)
 	sw	$2,%lo(fast_path_cusRsp401_func)($3)
-$L1202:
-	beq	$5,$0,$L1203
+$L1211:
+	beq	$5,$0,$L1212
 	lui	$3,%hi(fast_path_cusRspTCPFinAck_func)
 
-	j	$L1204
+	j	$L1213
 	sw	$5,%lo(fast_path_cusRspTCPFinAck_func)($3)
 
-$L1203:
+$L1212:
 	lui	$2,%hi(GenerateTCPFINACK)
 	addiu	$2,$2,%lo(GenerateTCPFINACK)
 	sw	$2,%lo(fast_path_cusRspTCPFinAck_func)($3)
-$L1204:
-	beq	$6,$0,$L1205
+$L1213:
+	beq	$6,$0,$L1214
 	lui	$3,%hi(fast_path_cusRspTCPEndAck_func)
 
 	j	$31
 	sw	$6,%lo(fast_path_cusRspTCPEndAck_func)($3)
 
-$L1205:
+$L1214:
 	lui	$2,%hi(GenerateTCPENDACK)
 	addiu	$2,$2,%lo(GenerateTCPENDACK)
 	j	$31
@@ -6324,434 +7074,445 @@ filter_enter:
 	sw	$19,28($sp)
 	sw	$18,24($sp)
 	sw	$17,20($sp)
-	bne	$2,$0,$L1209
+	bne	$2,$0,$L1218
 	sw	$16,16($sp)
 
 	lui	$2,%hi(table_list_head+24)
 	lw	$2,%lo(table_list_head+24)($2)
 	sltu	$2,$2,2
-	bne	$2,$0,$L1317
+	bne	$2,$0,$L1322
 	lui	$3,%hi(none_dos_drop_pkt_cnt)
 
-$L1209:
-	lw	$2,104($23)
-	li	$3,14680064			# 0xe00000
-	and	$2,$2,$3
-	bne	$2,$0,$L1208
-	li	$5,4			# 0x4
+$L1218:
+	jal	rtl_get_skb_type
+	move	$4,$23
 
-	lhu	$3,106($23)
-	li	$2,2048			# 0x800
-	bne	$3,$2,$L1208
-	lui	$2,%hi(table_list_head+24)
+	bne	$2,$0,$L1217
+	li	$4,4			# 0x4
+
+	jal	rtl_get_skb_protocol
+	move	$4,$23
+
+	li	$3,2048			# 0x800
+	bne	$2,$3,$L1217
+	li	$4,4			# 0x4
 
+	lui	$2,%hi(table_list_head+24)
 	lw	$2,%lo(table_list_head+24)($2)
 	sltu	$2,$2,2
-	bne	$2,$0,$L1212
+	bne	$2,$0,$L1221
 	nop
 
 	jal	FilterWeb_v2
 	move	$4,$23
 
-	beq	$2,$0,$L1213
+	beq	$2,$0,$L1222
 	lui	$3,%hi(fast_path_cusRsp401_func)
 
 	lw	$2,%lo(fast_path_cusRsp401_func)($3)
-	j	$L1316
+	j	$L1321
 	nop
 
-$L1213:
+$L1222:
 	lw	$2,%lo(fast_path_cusRsp401_func)($3)
-	beq	$2,$0,$L1212
+	beq	$2,$0,$L1221
 	lui	$2,%hi(url_cache)
 
 	li	$4,1			# 0x1
 	addiu	$3,$2,%lo(url_cache)
 	lbu	$2,15($3)
-	bne	$2,$4,$L1218
+	bne	$2,$4,$L1227
 	lui	$2,%hi(fast_path_cusRspTCPFinAck_func)
 
 	lw	$2,%lo(fast_path_cusRspTCPFinAck_func)($2)
-	j	$L1316
+	j	$L1321
 	nop
 
-$L1218:
+$L1227:
 	lbu	$2,16($3)
-	bne	$2,$4,$L1212
+	bne	$2,$4,$L1221
 	lui	$2,%hi(fast_path_cusRspTCPEndAck_func)
 
 	lw	$2,%lo(fast_path_cusRspTCPEndAck_func)($2)
-$L1316:
-	beq	$2,$0,$L1222
+$L1321:
+	beq	$2,$0,$L1231
 	nop
 
 	jal	$2
 	move	$4,$23
 
-$L1222:
-	j	$L1208
-	move	$5,$0
+$L1231:
+	j	$L1217
+	move	$4,$0
 
-$L1212:
+$L1221:
 	lw	$2,%lo(item)($21)
 	andi	$2,$2,0x1
-	beq	$2,$0,$L1223
+	beq	$2,$0,$L1232
 	lui	$22,%hi(item)
 
-	lw	$17,156($23)
-	lui	$16,%hi(init_net)
-	lui	$5,%hi($LC1)
-	addiu	$4,$16,%lo(init_net)
-	lbu	$2,0($17)
-	addiu	$5,$5,%lo($LC1)
+	move	$4,$23
+	jal	rtl_ip_hdr
 	lui	$20,%hi(wan_ppp_dev)
-	move	$18,$0
+
+	lui	$4,%hi($LC1)
+	move	$16,$2
+	addiu	$4,$4,%lo($LC1)
+	lbu	$2,0($2)
+	lui	$19,%hi(wan_dev)
+	move	$17,$0
 	andi	$2,$2,0xf
 	sll	$2,$2,2
-	jal	__dev_get_by_name
-	addu	$19,$17,$2
+	jal	rtl_get_dev_by_name
+	addu	$18,$16,$2
 
-	lui	$5,%hi($LC2)
-	addiu	$4,$16,%lo(init_net)
-	addiu	$5,$5,%lo($LC2)
-	jal	__dev_get_by_name
+	lui	$4,%hi($LC2)
+	addiu	$4,$4,%lo($LC2)
+	jal	rtl_get_dev_by_name
 	sw	$2,%lo(wan_ppp_dev)($20)
 
-	move	$4,$2
-	lui	$2,%hi(wan_dev)
-	sw	$4,%lo(wan_dev)($2)
-	lw	$3,24($23)
-	beq	$3,$0,$L1223
+	move	$4,$23
+	jal	rtl_get_skb_dev
+	sw	$2,%lo(wan_dev)($19)
+
+	beq	$2,$0,$L1232
 	nop
 
-	beq	$3,$4,$L1228
+	jal	rtl_get_skb_dev
+	move	$4,$23
+
+	lw	$3,%lo(wan_dev)($19)
+	beq	$2,$3,$L1235
 	nop
 
-	lw	$2,%lo(wan_ppp_dev)($20)
-	bne	$3,$2,$L1223
+	jal	rtl_get_skb_dev
+	move	$4,$23
+
+	lw	$3,%lo(wan_ppp_dev)($20)
+	bne	$2,$3,$L1232
 	nop
 
-$L1228:
+$L1235:
 	lw	$2,%lo(item)($22)
 	andi	$2,$2,0x3fe
-	beq	$2,$0,$L1318
+	beq	$2,$0,$L1323
 	lui	$6,%hi(item)
 
 	jal	dos_pkt_locate
-	move	$4,$17
+	move	$4,$16
 
-	beq	$2,$0,$L1318
+	beq	$2,$0,$L1323
 	lui	$6,%hi(item)
 
 	lw	$6,%lo(item)($22)
 	andi	$2,$6,0x22
-	beq	$2,$0,$L1231
+	beq	$2,$0,$L1238
 	lui	$3,%hi(cur_p_pkt)
 
-	lbu	$2,9($17)
+	lbu	$2,9($16)
 	lw	$5,%lo(cur_p_pkt)($3)
 	li	$3,6			# 0x6
-	bne	$2,$3,$L1232
+	bne	$2,$3,$L1239
 	li	$3,2			# 0x2
 
-	lbu	$2,13($19)
+	lbu	$2,13($18)
 	andi	$2,$2,0x3f
-	bne	$2,$3,$L1232
+	bne	$2,$3,$L1239
 	lui	$7,%hi(block)
 
 	li	$2,1			# 0x1
 	lw	$3,%lo(block)($7)
-	bne	$3,$2,$L1233
+	bne	$3,$2,$L1240
 	lui	$2,%hi(attack_saddr+4)
 
 	lw	$3,%lo(attack_saddr+4)($2)
-	lw	$2,12($17)
-	beq	$3,$2,$L1234
+	lw	$2,12($16)
+	beq	$3,$2,$L1241
 	li	$4,-1			# 0xffffffff
 
-$L1233:
+$L1240:
 	lw	$2,4($5)
 	lui	$3,%hi(per_syn_threshold)
 	addiu	$2,$2,1
 	sw	$2,4($5)
 	lw	$3,%lo(per_syn_threshold)($3)
 	slt	$2,$3,$2
-	beq	$2,$0,$L1232
+	beq	$2,$0,$L1239
 	andi	$2,$6,0x20
 
-	beq	$2,$0,$L1234
+	beq	$2,$0,$L1241
 	move	$4,$0
 
-	blez	$3,$L1234
+	blez	$3,$L1241
 	lui	$2,%hi(attack_saddr+4)
 
-	lw	$3,12($17)
+	lw	$3,12($16)
 	lui	$5,%hi(LogFlag)
 	sw	$3,%lo(attack_saddr+4)($2)
 	lui	$2,%hi(attack_daddr+4)
-	lw	$4,16($17)
+	lw	$4,16($16)
 	lw	$3,%lo(LogFlag)($5)
 	sw	$4,%lo(attack_daddr+4)($2)
 	li	$2,1			# 0x1
 	ori	$3,$3,0x20
 	sw	$2,%lo(block)($7)
 	sw	$3,%lo(LogFlag)($5)
-$L1232:
+$L1239:
 	move	$4,$0
-$L1234:
-	move	$18,$4
-$L1231:
+$L1241:
+	move	$17,$4
+$L1238:
 	lw	$6,%lo(item)($21)
 	andi	$2,$6,0x44
-	beq	$2,$0,$L1319
+	beq	$2,$0,$L1324
 	andi	$2,$6,0x88
 
 	lui	$3,%hi(cur_p_pkt)
-	lbu	$2,9($17)
+	lbu	$2,9($16)
 	lw	$5,%lo(cur_p_pkt)($3)
 	li	$3,6			# 0x6
-	bne	$2,$3,$L1239
+	bne	$2,$3,$L1246
 	move	$4,$0
 
-	lbu	$2,13($19)
+	lbu	$2,13($18)
 	andi	$3,$2,0x3f
 	li	$2,1			# 0x1
-	bne	$3,$2,$L1239
+	bne	$3,$2,$L1246
 	lui	$7,%hi(block)
 
 	lw	$2,%lo(block)($7)
-	bne	$2,$3,$L1238
+	bne	$2,$3,$L1245
 	lui	$2,%hi(attack_saddr+8)
 
 	lw	$3,%lo(attack_saddr+8)($2)
-	lw	$2,12($17)
-	beq	$3,$2,$L1239
+	lw	$2,12($16)
+	beq	$3,$2,$L1246
 	li	$4,-1			# 0xffffffff
 
-$L1238:
+$L1245:
 	lw	$2,8($5)
 	lui	$3,%hi(per_fin_threshold)
 	addiu	$2,$2,1
 	sw	$2,8($5)
 	lw	$3,%lo(per_fin_threshold)($3)
 	slt	$2,$3,$2
-	beq	$2,$0,$L1237
+	beq	$2,$0,$L1244
 	andi	$2,$6,0x40
 
-	beq	$2,$0,$L1239
+	beq	$2,$0,$L1246
 	move	$4,$0
 
-	blez	$3,$L1239
+	blez	$3,$L1246
 	lui	$2,%hi(attack_saddr+8)
 
-	lw	$3,12($17)
+	lw	$3,12($16)
 	lui	$5,%hi(LogFlag)
 	sw	$3,%lo(attack_saddr+8)($2)
 	lui	$2,%hi(attack_daddr+8)
-	lw	$4,16($17)
+	lw	$4,16($16)
 	lw	$3,%lo(LogFlag)($5)
 	sw	$4,%lo(attack_daddr+8)($2)
 	li	$2,1			# 0x1
 	ori	$3,$3,0x40
 	sw	$2,%lo(block)($7)
 	sw	$3,%lo(LogFlag)($5)
-$L1237:
+$L1244:
 	move	$4,$0
-$L1239:
-	or	$18,$18,$4
+$L1246:
+	or	$17,$17,$4
 	lw	$6,%lo(item)($21)
 	andi	$2,$6,0x88
-$L1319:
-	beq	$2,$0,$L1241
+$L1324:
+	beq	$2,$0,$L1248
 	lui	$3,%hi(cur_p_pkt)
 
-	lbu	$2,9($17)
+	lbu	$2,9($16)
 	lw	$5,%lo(cur_p_pkt)($3)
 	li	$3,17			# 0x11
-	bne	$2,$3,$L1244
+	bne	$2,$3,$L1251
 	move	$4,$0
 
 	lui	$7,%hi(block)
 	li	$2,1			# 0x1
 	lw	$3,%lo(block)($7)
-	bne	$3,$2,$L1243
+	bne	$3,$2,$L1250
 	lui	$2,%hi(attack_saddr+12)
 
 	lw	$3,%lo(attack_saddr+12)($2)
-	lw	$2,12($17)
-	beq	$3,$2,$L1244
+	lw	$2,12($16)
+	beq	$3,$2,$L1251
 	li	$4,-1			# 0xffffffff
 
-$L1243:
+$L1250:
 	lw	$2,12($5)
 	lui	$3,%hi(per_udp_threshold)
 	addiu	$2,$2,1
 	sw	$2,12($5)
 	lw	$3,%lo(per_udp_threshold)($3)
 	slt	$2,$3,$2
-	beq	$2,$0,$L1242
+	beq	$2,$0,$L1249
 	andi	$2,$6,0x80
 
-	beq	$2,$0,$L1244
+	beq	$2,$0,$L1251
 	move	$4,$0
 
-	blez	$3,$L1244
+	blez	$3,$L1251
 	lui	$2,%hi(attack_saddr+12)
 
-	lw	$3,12($17)
+	lw	$3,12($16)
 	lui	$5,%hi(LogFlag)
 	sw	$3,%lo(attack_saddr+12)($2)
 	lui	$2,%hi(attack_daddr+12)
-	lw	$4,16($17)
+	lw	$4,16($16)
 	lw	$3,%lo(LogFlag)($5)
 	sw	$4,%lo(attack_daddr+12)($2)
 	li	$2,1			# 0x1
 	ori	$3,$3,0x80
 	sw	$2,%lo(block)($7)
 	sw	$3,%lo(LogFlag)($5)
-$L1242:
+$L1249:
 	move	$4,$0
-$L1244:
-	or	$18,$18,$4
-$L1241:
+$L1251:
+	or	$17,$17,$4
+$L1248:
 	lw	$6,%lo(item)($21)
 	andi	$2,$6,0x110
-	beq	$2,$0,$L1246
+	beq	$2,$0,$L1253
 	lui	$2,%hi(cur_p_pkt)
 
-	lbu	$3,9($17)
+	lbu	$3,9($16)
 	lw	$5,%lo(cur_p_pkt)($2)
 	li	$2,1			# 0x1
-	bne	$3,$2,$L1249
+	bne	$3,$2,$L1256
 	move	$4,$0
 
 	lui	$7,%hi(block)
 	lw	$2,%lo(block)($7)
-	bne	$2,$3,$L1248
+	bne	$2,$3,$L1255
 	lui	$2,%hi(attack_saddr+16)
 
 	lw	$3,%lo(attack_saddr+16)($2)
-	lw	$2,12($17)
-	beq	$3,$2,$L1249
+	lw	$2,12($16)
+	beq	$3,$2,$L1256
 	li	$4,-1			# 0xffffffff
 
-$L1248:
+$L1255:
 	lw	$2,16($5)
 	lui	$3,%hi(per_icmp_threshold)
 	addiu	$2,$2,1
 	sw	$2,16($5)
 	lw	$3,%lo(per_icmp_threshold)($3)
 	slt	$2,$3,$2
-	beq	$2,$0,$L1247
+	beq	$2,$0,$L1254
 	andi	$2,$6,0x100
 
-	beq	$2,$0,$L1249
+	beq	$2,$0,$L1256
 	move	$4,$0
 
-	blez	$3,$L1249
+	blez	$3,$L1256
 	lui	$2,%hi(attack_saddr+16)
 
-	lw	$3,12($17)
+	lw	$3,12($16)
 	lui	$5,%hi(LogFlag)
 	sw	$3,%lo(attack_saddr+16)($2)
 	lui	$2,%hi(attack_daddr+16)
-	lw	$4,16($17)
+	lw	$4,16($16)
 	lw	$3,%lo(LogFlag)($5)
 	sw	$4,%lo(attack_daddr+16)($2)
 	li	$2,1			# 0x1
 	ori	$3,$3,0x100
 	sw	$2,%lo(block)($7)
 	sw	$3,%lo(LogFlag)($5)
-$L1247:
+$L1254:
 	move	$4,$0
-$L1249:
-	or	$18,$18,$4
-$L1246:
+$L1256:
+	or	$17,$17,$4
+$L1253:
 	lw	$2,%lo(item)($21)
 	andi	$2,$2,0x200
-	beq	$2,$0,$L1320
+	beq	$2,$0,$L1325
 	lui	$2,%hi(item)
 
 	lui	$3,%hi(cur_p_pkt)
-	lbu	$2,9($17)
+	lbu	$2,9($16)
 	lw	$4,%lo(cur_p_pkt)($3)
 	li	$3,6			# 0x6
-	bne	$2,$3,$L1252
+	bne	$2,$3,$L1259
 	nop
 
 	lhu	$5,32($4)
 	andi	$3,$5,0xffff
-	beq	$3,$0,$L1253
+	beq	$3,$0,$L1260
 	nop
 
-	lhu	$2,2($19)
-	beq	$3,$2,$L1253
+	lhu	$2,2($18)
+	beq	$3,$2,$L1260
 	nop
 
 	lw	$2,20($4)
 	addiu	$2,$2,1
 	sw	$2,20($4)
-$L1253:
-	bne	$5,$0,$L1252
+$L1260:
+	bne	$5,$0,$L1259
 	nop
 
-	lhu	$2,2($19)
+	lhu	$2,2($18)
 	sh	$2,32($4)
-$L1252:
-	lbu	$3,9($17)
+$L1259:
+	lbu	$3,9($16)
 	li	$2,17			# 0x11
-	bne	$3,$2,$L1255
+	bne	$3,$2,$L1262
 	nop
 
 	lhu	$5,32($4)
 	andi	$3,$5,0xffff
-	beq	$3,$0,$L1256
+	beq	$3,$0,$L1263
 	nop
 
-	lhu	$2,2($19)
-	beq	$3,$2,$L1256
+	lhu	$2,2($18)
+	beq	$3,$2,$L1263
 	nop
 
 	lw	$2,20($4)
 	addiu	$2,$2,1
 	sw	$2,20($4)
-$L1256:
-	bne	$5,$0,$L1255
+$L1263:
+	bne	$5,$0,$L1262
 	nop
 
-	lhu	$2,2($19)
+	lhu	$2,2($18)
 	sh	$2,32($4)
-$L1255:
+$L1262:
 	lw	$2,%lo(item)($21)
 	li	$3,8388608			# 0x800000
 	and	$2,$2,$3
-	beq	$2,$0,$L1258
+	beq	$2,$0,$L1265
 	nop
 
 	lw	$2,20($4)
 	slt	$2,$2,11
-	bne	$2,$0,$L1258
+	bne	$2,$0,$L1265
 	lui	$3,%hi(LogFlag)
 
 	lw	$2,%lo(LogFlag)($3)
 	ori	$2,$2,0x200
 	sw	$2,%lo(LogFlag)($3)
 	lui	$2,%hi(attack_saddr+20)
-	lw	$3,12($17)
+	lw	$3,12($16)
 	sw	$3,%lo(attack_saddr+20)($2)
 	lui	$2,%hi(attack_daddr+20)
-	lw	$3,16($17)
+	lw	$3,16($16)
 	sw	$3,%lo(attack_daddr+20)($2)
-$L1258:
+$L1265:
 	lw	$2,%lo(item)($21)
 	li	$3,8388608			# 0x800000
 	and	$2,$2,$3
-	bne	$2,$0,$L1320
+	bne	$2,$0,$L1325
 	lui	$2,%hi(item)
 
 	lw	$2,20($4)
 	slt	$2,$2,201
-	bne	$2,$0,$L1320
+	bne	$2,$0,$L1325
 	lui	$2,%hi(item)
 
 	lui	$3,%hi(LogFlag)
@@ -6759,35 +7520,35 @@ $L1258:
 	ori	$2,$2,0x200
 	sw	$2,%lo(LogFlag)($3)
 	lui	$2,%hi(attack_saddr+20)
-	lw	$3,12($17)
+	lw	$3,12($16)
 	sw	$3,%lo(attack_saddr+20)($2)
 	lui	$2,%hi(attack_daddr+20)
-	lw	$3,16($17)
+	lw	$3,16($16)
 	sw	$3,%lo(attack_daddr+20)($2)
 	lui	$2,%hi(item)
-$L1320:
+$L1325:
 	li	$3,4194304			# 0x400000
 	lw	$2,%lo(item)($2)
 	and	$2,$2,$3
-	movz	$18,$0,$2		#conditional move
+	movz	$17,$0,$2		#conditional move
 	lui	$6,%hi(item)
-$L1318:
+$L1323:
 	lw	$2,%lo(item)($6)
 	andi	$2,$2,0x8000
-	beq	$2,$0,$L1262
+	beq	$2,$0,$L1269
 	li	$2,6			# 0x6
 
-	lbu	$3,9($17)
-	bne	$3,$2,$L1265
+	lbu	$3,9($16)
+	bne	$3,$2,$L1272
 	move	$4,$0
 
-	lbu	$2,13($19)
+	lbu	$2,13($18)
 	lui	$3,%hi(_tcpDosScanBitmap)
 	addiu	$3,$3,%lo(_tcpDosScanBitmap)
 	andi	$2,$2,0x3f
 	addu	$2,$2,$3
 	lb	$2,0($2)
-	beq	$2,$0,$L1263
+	beq	$2,$0,$L1270
 	lui	$3,%hi(LogFlag)
 
 	li	$4,-1			# 0xffffffff
@@ -6795,73 +7556,73 @@ $L1318:
 	ori	$2,$2,0x8000
 	sw	$2,%lo(LogFlag)($3)
 	lui	$2,%hi(attack_saddr+44)
-	lw	$3,12($17)
+	lw	$3,12($16)
 	sw	$3,%lo(attack_saddr+44)($2)
 	lui	$2,%hi(attack_daddr+44)
-	lw	$3,16($17)
+	lw	$3,16($16)
 	sw	$3,%lo(attack_daddr+44)($2)
-$L1263:
-$L1265:
-	or	$18,$18,$4
-$L1262:
+$L1270:
+$L1272:
+	or	$17,$17,$4
+$L1269:
 	lw	$2,%lo(item)($6)
 	li	$5,65536			# 0x10000
 	and	$2,$2,$5
-	beq	$2,$0,$L1266
+	beq	$2,$0,$L1273
 	li	$2,6			# 0x6
 
-	lbu	$3,9($17)
-	bne	$3,$2,$L1269
+	lbu	$3,9($16)
+	bne	$3,$2,$L1276
 	move	$4,$0
 
-	lbu	$2,13($19)
+	lbu	$2,13($18)
 	li	$3,2			# 0x2
 	andi	$2,$2,0x3f
-	bne	$2,$3,$L1269
+	bne	$2,$3,$L1276
 	nop
 
-	lbu	$2,0($17)
-	lw	$3,12($19)
+	lbu	$2,0($16)
+	lw	$3,12($18)
 	andi	$2,$2,0xf
-	lhu	$4,2($17)
+	lhu	$4,2($16)
 	sll	$2,$2,2
 	srl	$3,$3,28
 	subu	$4,$4,$2
 	sll	$3,$3,2
-	bne	$4,$3,$L1321
+	bne	$4,$3,$L1326
 	lui	$3,%hi(LogFlag)
 
-	lhu	$2,6($17)
+	lhu	$2,6($16)
 	andi	$2,$2,0x2000
-	beq	$2,$0,$L1267
+	beq	$2,$0,$L1274
 	nop
 
-$L1321:
+$L1326:
 	li	$4,-1			# 0xffffffff
 	lw	$2,%lo(LogFlag)($3)
 	or	$2,$2,$5
 	sw	$2,%lo(LogFlag)($3)
 	lui	$2,%hi(attack_saddr+48)
-	lw	$3,12($17)
+	lw	$3,12($16)
 	sw	$3,%lo(attack_saddr+48)($2)
 	lui	$2,%hi(attack_daddr+48)
-	lw	$3,16($17)
-	j	$L1269
+	lw	$3,16($16)
+	j	$L1276
 	sw	$3,%lo(attack_daddr+48)($2)
 
-$L1267:
+$L1274:
 	move	$4,$0
-$L1269:
-	or	$18,$18,$4
-$L1266:
+$L1276:
+	or	$17,$17,$4
+$L1273:
 	lw	$2,%lo(item)($6)
 	andi	$2,$2,0x800
-	beq	$2,$0,$L1271
+	beq	$2,$0,$L1278
 	nop
 
-	lw	$3,12($17)
-	lw	$2,16($17)
-	bne	$3,$2,$L1273
+	lw	$3,12($16)
+	lw	$2,16($16)
+	bne	$3,$2,$L1280
 	move	$4,$0
 
 	lui	$3,%hi(LogFlag)
@@ -6870,89 +7631,89 @@ $L1266:
 	ori	$2,$2,0x800
 	sw	$2,%lo(LogFlag)($3)
 	lui	$2,%hi(attack_saddr+28)
-	lw	$3,12($17)
+	lw	$3,12($16)
 	sw	$3,%lo(attack_saddr+28)($2)
 	lui	$2,%hi(attack_daddr+28)
-	lw	$3,16($17)
+	lw	$3,16($16)
 	sw	$3,%lo(attack_daddr+28)($2)
-$L1273:
-	or	$18,$18,$4
-$L1271:
+$L1280:
+	or	$17,$17,$4
+$L1278:
 	lw	$2,%lo(item)($6)
 	li	$3,262144			# 0x40000
 	and	$2,$2,$3
-	beq	$2,$0,$L1274
+	beq	$2,$0,$L1281
 	li	$2,17			# 0x11
 
-	lbu	$3,9($17)
-	bne	$3,$2,$L1278
+	lbu	$3,9($16)
+	bne	$3,$2,$L1285
 	move	$5,$0
 
-	lhu	$2,2($19)
+	lhu	$2,2($18)
 	li	$5,7			# 0x7
-	beq	$2,$5,$L1322
+	beq	$2,$5,$L1327
 	lui	$4,%hi(LogFlag)
 
-	beq	$2,$3,$L1277
+	beq	$2,$3,$L1284
 	li	$4,19			# 0x13
 
-	beq	$2,$4,$L1277
+	beq	$2,$4,$L1284
 	nop
 
-	lhu	$2,0($19)
-	beq	$2,$5,$L1277
+	lhu	$2,0($18)
+	beq	$2,$5,$L1284
 	nop
 
-	beq	$2,$3,$L1277
+	beq	$2,$3,$L1284
 	nop
 
-	bne	$2,$4,$L1275
+	bne	$2,$4,$L1282
 	nop
 
-$L1277:
+$L1284:
 	lui	$4,%hi(LogFlag)
-$L1322:
+$L1327:
 	li	$3,262144			# 0x40000
 	lw	$2,%lo(LogFlag)($4)
 	li	$5,-1			# 0xffffffff
 	or	$2,$2,$3
 	sw	$2,%lo(LogFlag)($4)
 	lui	$2,%hi(attack_saddr+56)
-	lw	$3,12($17)
+	lw	$3,12($16)
 	sw	$3,%lo(attack_saddr+56)($2)
 	lui	$2,%hi(attack_daddr+56)
-	lw	$3,16($17)
-	j	$L1278
+	lw	$3,16($16)
+	j	$L1285
 	sw	$3,%lo(attack_daddr+56)($2)
 
-$L1275:
+$L1282:
 	move	$5,$0
-$L1278:
-	or	$18,$18,$5
-$L1274:
+$L1285:
+	or	$17,$17,$5
+$L1281:
 	lw	$2,%lo(item)($6)
 	li	$5,131072			# 0x20000
 	and	$2,$2,$5
-	beq	$2,$0,$L1279
+	beq	$2,$0,$L1286
 	li	$2,17			# 0x11
 
-	lbu	$3,9($17)
-	bne	$3,$2,$L1283
+	lbu	$3,9($16)
+	bne	$3,$2,$L1290
 	move	$4,$0
 
-	lhu	$2,6($17)
+	lhu	$2,6($16)
 	andi	$2,$2,0x3fff
-	bne	$2,$0,$L1283
+	bne	$2,$0,$L1290
 	nop
 
-	lbu	$2,0($17)
-	lhu	$4,2($17)
+	lbu	$2,0($16)
+	lhu	$4,2($16)
 	andi	$2,$2,0xf
 	sll	$2,$2,2
-	lhu	$3,4($19)
+	lhu	$3,4($18)
 	subu	$4,$4,$2
 	slt	$3,$3,$4
-	beq	$3,$0,$L1280
+	beq	$3,$0,$L1287
 	lui	$3,%hi(LogFlag)
 
 	li	$4,-1			# 0xffffffff
@@ -6960,41 +7721,41 @@ $L1274:
 	or	$2,$2,$5
 	sw	$2,%lo(LogFlag)($3)
 	lui	$2,%hi(attack_saddr+52)
-	lw	$3,12($17)
+	lw	$3,12($16)
 	sw	$3,%lo(attack_saddr+52)($2)
 	lui	$2,%hi(attack_daddr+52)
-	lw	$3,16($17)
-	j	$L1283
+	lw	$3,16($16)
+	j	$L1290
 	sw	$3,%lo(attack_daddr+52)($2)
 
-$L1280:
+$L1287:
 	move	$4,$0
-$L1283:
-	or	$18,$18,$4
-$L1279:
+$L1290:
+	or	$17,$17,$4
+$L1286:
 	lw	$2,%lo(item)($6)
 	andi	$2,$2,0x4000
-	beq	$2,$0,$L1284
+	beq	$2,$0,$L1291
 	nop
 
-	lhu	$3,6($17)
+	lhu	$3,6($16)
 	andi	$2,$3,0x2000
-	bne	$2,$0,$L1287
+	bne	$2,$0,$L1294
 	move	$4,$0
 
 	andi	$3,$3,0x1fff
-	beq	$3,$0,$L1287
+	beq	$3,$0,$L1294
 	sll	$3,$3,3
 
-	lbu	$2,0($17)
-	lhu	$4,2($17)
+	lbu	$2,0($16)
+	lhu	$4,2($16)
 	andi	$2,$2,0xf
 	sll	$2,$2,2
 	addu	$3,$3,$4
 	subu	$3,$3,$2
 	li	$2,65535			# 0xffff
 	sltu	$2,$2,$3
-	beq	$2,$0,$L1285
+	beq	$2,$0,$L1292
 	lui	$3,%hi(LogFlag)
 
 	li	$4,-1			# 0xffffffff
@@ -7002,44 +7763,44 @@ $L1279:
 	ori	$2,$2,0x4000
 	sw	$2,%lo(LogFlag)($3)
 	lui	$2,%hi(attack_saddr+40)
-	lw	$3,12($17)
+	lw	$3,12($16)
 	sw	$3,%lo(attack_saddr+40)($2)
 	lui	$2,%hi(attack_daddr+40)
-	lw	$3,16($17)
-	j	$L1287
+	lw	$3,16($16)
+	j	$L1294
 	sw	$3,%lo(attack_daddr+40)($2)
 
-$L1285:
+$L1292:
 	move	$4,$0
-$L1287:
-	or	$18,$18,$4
-$L1284:
+$L1294:
+	or	$17,$17,$4
+$L1291:
 	lw	$2,%lo(item)($6)
 	andi	$2,$2,0x400
-	beq	$2,$0,$L1288
+	beq	$2,$0,$L1295
 	nop
 
-	lbu	$2,0($17)
-	lbu	$3,9($17)
+	lbu	$2,0($16)
+	lbu	$3,9($16)
 	andi	$2,$2,0xf
 	sll	$2,$2,2
-	addu	$4,$17,$2
+	addu	$4,$16,$2
 	li	$2,1			# 0x1
-	bne	$3,$2,$L1289
+	bne	$3,$2,$L1296
 	li	$2,8			# 0x8
 
 	lbu	$3,0($4)
-	bne	$3,$2,$L1291
+	bne	$3,$2,$L1298
 	move	$4,$0
 
 	lui	$2,%hi(lan_mask)
 	lw	$4,%lo(lan_mask)($2)
 	lui	$2,%hi(lan_addr)
 	lw	$3,%lo(lan_addr)($2)
-	lw	$2,12($17)
+	lw	$2,12($16)
 	and	$3,$3,$4
 	and	$2,$2,$4
-	bne	$2,$3,$L1289
+	bne	$2,$3,$L1296
 	lui	$3,%hi(LogFlag)
 
 	li	$4,-1			# 0xffffffff
@@ -7047,35 +7808,35 @@ $L1284:
 	ori	$2,$2,0x400
 	sw	$2,%lo(LogFlag)($3)
 	lui	$2,%hi(attack_saddr+24)
-	lw	$3,12($17)
+	lw	$3,12($16)
 	sw	$3,%lo(attack_saddr+24)($2)
 	lui	$2,%hi(attack_daddr+24)
-	lw	$3,16($17)
-	j	$L1291
+	lw	$3,16($16)
+	j	$L1298
 	sw	$3,%lo(attack_daddr+24)($2)
 
-$L1289:
+$L1296:
 	move	$4,$0
-$L1291:
-	or	$18,$18,$4
-$L1288:
+$L1298:
+	or	$17,$17,$4
+$L1295:
 	lw	$2,%lo(item)($6)
 	andi	$2,$2,0x1000
-	beq	$2,$0,$L1292
+	beq	$2,$0,$L1299
 	lui	$2,%hi(lan_mask)
 
 	lw	$4,%lo(lan_mask)($2)
 	lui	$2,%hi(lan_addr)
 	lw	$3,%lo(lan_addr)($2)
-	lw	$2,12($17)
+	lw	$2,12($16)
 	and	$3,$3,$4
 	and	$2,$2,$4
-	bne	$2,$3,$L1294
+	bne	$2,$3,$L1301
 	move	$4,$0
 
-	lbu	$3,9($17)
+	lbu	$3,9($16)
 	li	$2,1			# 0x1
-	beq	$3,$2,$L1294
+	beq	$3,$2,$L1301
 	lui	$3,%hi(LogFlag)
 
 	li	$4,-1			# 0xffffffff
@@ -7083,105 +7844,107 @@ $L1288:
 	ori	$2,$2,0x1000
 	sw	$2,%lo(LogFlag)($3)
 	lui	$2,%hi(attack_saddr+32)
-	lw	$3,12($17)
+	lw	$3,12($16)
 	sw	$3,%lo(attack_saddr+32)($2)
 	lui	$2,%hi(attack_daddr+32)
-	lw	$3,16($17)
+	lw	$3,16($16)
 	sw	$3,%lo(attack_daddr+32)($2)
-$L1294:
-	or	$18,$18,$4
-$L1292:
+$L1301:
+	or	$17,$17,$4
+$L1299:
 	lw	$2,%lo(item)($6)
 	andi	$2,$2,0x2000
-	beq	$2,$0,$L1227
+	beq	$2,$0,$L1234
 	nop
 
 	jal	dos_pkt_locate
-	move	$4,$17
+	move	$4,$16
 
-	beq	$2,$0,$L1298
+	beq	$2,$0,$L1305
 	move	$4,$0
 
 	lui	$2,%hi(cur_p_pkt)
 	lw	$5,%lo(cur_p_pkt)($2)
-	lhu	$7,4($17)
+	lhu	$7,4($16)
 	lhu	$3,28($5)
 	andi	$2,$7,0xffff
-	beq	$2,$3,$L1299
+	beq	$2,$3,$L1306
 	nop
 
-	bne	$3,$0,$L1298
+	bne	$3,$0,$L1305
 	nop
 
-$L1299:
-	lhu	$4,6($17)
+$L1306:
+	lhu	$4,6($16)
 	andi	$2,$4,0x3fff
-	beq	$2,$0,$L1300
+	beq	$2,$0,$L1307
 	andi	$2,$4,0x1fff
 
 	lhu	$6,30($5)
 	sll	$2,$2,3
 	andi	$3,$6,0xffff
 	slt	$2,$2,$3
-	bne	$2,$0,$L1301
+	bne	$2,$0,$L1308
 	andi	$2,$4,0x2000
 
-	bne	$2,$0,$L1302
+	bne	$2,$0,$L1309
 	nop
 
 	sh	$0,30($5)
-	j	$L1300
+	j	$L1307
 	sh	$0,28($5)
 
-$L1302:
+$L1309:
 	sh	$7,28($5)
-	lbu	$2,0($17)
-	lhu	$3,2($17)
+	lbu	$2,0($16)
+	lhu	$3,2($16)
 	andi	$2,$2,0xf
 	addu	$3,$6,$3
 	sll	$2,$2,2
 	subu	$3,$3,$2
-	j	$L1300
+	j	$L1307
 	sh	$3,30($5)
 
-$L1301:
+$L1308:
 	lui	$3,%hi(LogFlag)
 	li	$4,-1			# 0xffffffff
 	lw	$2,%lo(LogFlag)($3)
 	ori	$2,$2,0x2000
 	sw	$2,%lo(LogFlag)($3)
 	lui	$2,%hi(attack_saddr+36)
-	lw	$3,12($17)
+	lw	$3,12($16)
 	sw	$3,%lo(attack_saddr+36)($2)
 	lui	$2,%hi(attack_daddr+36)
-	lw	$3,16($17)
-	j	$L1298
+	lw	$3,16($16)
+	j	$L1305
 	sw	$3,%lo(attack_daddr+36)($2)
 
-$L1300:
+$L1307:
 	move	$4,$0
-$L1298:
-	or	$18,$18,$4
-$L1227:
-	bne	$18,$0,$L1208
-	move	$5,$0
+$L1305:
+	or	$17,$17,$4
+$L1234:
+	bne	$17,$0,$L1217
+	move	$4,$0
+
+$L1232:
+	jal	rtl_ip_hdr
+	move	$4,$23
 
-$L1223:
-	lw	$2,156($23)
 	lbu	$3,9($2)
 	li	$2,1			# 0x1
-	beq	$3,$2,$L1208
-	li	$5,4			# 0x4
+	beq	$3,$2,$L1217
+	li	$4,4			# 0x4
 
 	lui	$3,%hi(none_dos_drop_pkt_cnt)
-$L1317:
-	li	$5,1			# 0x1
+$L1322:
+	li	$4,1			# 0x1
 	lw	$2,%lo(none_dos_drop_pkt_cnt)($3)
 	addiu	$2,$2,1
 	sw	$2,%lo(none_dos_drop_pkt_cnt)($3)
-$L1208:
+$L1217:
 	lw	$31,48($sp)
-	move	$2,$5
+	move	$2,$4
 	lw	$23,44($sp)
 	lw	$22,40($sp)
 	lw	$21,36($sp)
@@ -7236,7 +7999,7 @@ filter_init:
 	move	$6,$0
 	addiu	$4,$17,%lo(dos_timer)
 	move	$5,$0
-	beq	$2,$0,$L1324
+	beq	$2,$0,$L1329
 	sw	$2,%lo(res3)($7)
 
 	lui	$2,%hi(dos_read_proc)
@@ -7246,7 +8009,7 @@ filter_init:
 	lw	$3,%lo(res3)($7)
 	addiu	$2,$2,%lo(dos_write_proc)
 	sw	$2,68($3)
-$L1324:
+$L1329:
 	jal	init_timer_key
 	nop
 
@@ -7316,14 +8079,14 @@ filter_exit:
 	sw	$31,20($sp)
 	addiu	$4,$4,%lo($LC55)
 	lw	$2,%lo(res3)($16)
-	beq	$2,$0,$L1326
+	beq	$2,$0,$L1331
 	move	$5,$2
 
 	jal	remove_proc_entry
 	nop
 
 	sw	$0,%lo(res3)($16)
-$L1326:
+$L1331:
 	lui	$4,%hi(dos_timer)
 	jal	del_timer
 	addiu	$4,$4,%lo(dos_timer)
@@ -7389,10 +8152,18 @@ table_list_head:
 	.comm	attack_daddr,56,4
 	.local	dos_flag
 	.comm	dos_flag,80,4
-	.local	wan_dev
-	.comm	wan_dev,4,4
-	.local	wan_ppp_dev
-	.comm	wan_ppp_dev,4,4
+	.globl	wan_dev
+	.align	2
+	.type	wan_dev, @object
+	.size	wan_dev, 4
+wan_dev:
+	.space	4
+	.globl	wan_ppp_dev
+	.align	2
+	.type	wan_ppp_dev, @object
+	.size	wan_ppp_dev, 4
+wan_ppp_dev:
+	.space	4
 	.globl	___strtok
 	.align	2
 	.type	___strtok, @object
diff --git a/net/rtl/fastpath/Makefile b/net/rtl/fastpath/Makefile
index 4d68e21..2ef943d 100644
--- a/net/rtl/fastpath/Makefile
+++ b/net/rtl/fastpath/Makefile
@@ -3,22 +3,28 @@
 #
 
 #EXTRA_CFLAGS += -I $(DIR_LINUX)/drivers/net/rtl819x
-EXTRA_CFLAGS += -I $(TOPDIR)/net
+EXTRA_CFLAGS += -I $(DIR_LINUX)/net
 EXTRA_CFLAGS += -D__KERNEL__
 #EXTRA_CFLAGS += -Wno-implicit -Werror
 
-ifeq ($(CONFIG_RTL_8198),y)
-TARGET = 98
-else
-TARGET = 96C
+ifeq ($(CONFIG_RTL_819XD),y)
+TARGET = 9xD
+endif
+
+ifeq ($(CONFIG_RTL_8196E),y)
+TARGET = 96E
 endif
 
-ifeq ($(CONFIG_MODEL_RTL8198_MP),y)
-TARGET = 98_MP
+ifeq ($(CONFIG_RTL_8196C),y)
+TARGET = 96E
+endif
+
+ifeq ($(CONFIG_RTL_8198),y)
+TARGET = 98
 endif
 
-ifeq ($(CONFIG_MODEL_RTL8196C_MP),y)
-TARGET = 96C_MP
+ifeq "$(CONFIG_MODEL_RTL89xxC_SDK)" "y"
+EXTRA_CFLAGS += --save-temps
 endif
 
 ifeq ($(CONFIG_RTL_IPTABLES_FAST_PATH),m)
diff --git a/net/rtl/fastpath/fast_l2tp_core.h b/net/rtl/fastpath/fast_l2tp_core.h
index 73313b1..63b09d6 100644
--- a/net/rtl/fastpath/fast_l2tp_core.h
+++ b/net/rtl/fastpath/fast_l2tp_core.h
@@ -1,16 +1,16 @@
-#ifndef FAST_L2TP_CORE_H
-#define FAST_L2TP_CORE_H
-
-#include <linux/skbuff.h>
-
-int __init fast_l2tp_init(void);
-void __exit fast_l2tp_exit(void);
-void event_ppp_dev_down(const char *name);
-int fast_l2tp_to_wan(struct sk_buff *skb);
-void fast_l2tp_rx(struct sk_buff *skb);
-void l2tp_tx_id(struct sk_buff *skb);
-void (*l2tp_tx_id_hook)(struct sk_buff *skb);
-unsigned long get_fast_l2tp_lastxmit(void);
-int fast_l2tp_fw;
-#endif
-
+#ifndef FAST_L2TP_CORE_H
+#define FAST_L2TP_CORE_H
+
+#include <linux/skbuff.h>
+
+int __init fast_l2tp_init(void);
+void __exit fast_l2tp_exit(void);
+void event_ppp_dev_down(const char *name);
+int fast_l2tp_to_wan(void *skb);
+void fast_l2tp_rx(void *skb);
+void l2tp_tx_id(void *skb);
+void (*l2tp_tx_id_hook)(void *skb);
+unsigned long get_fast_l2tp_lastxmit(void);
+int fast_l2tp_fw;
+#endif
+
diff --git a/net/rtl/fastpath/fastpath_common.c b/net/rtl/fastpath/fastpath_common.c
index 4f17c5b..842add9 100644
--- a/net/rtl/fastpath/fastpath_common.c
+++ b/net/rtl/fastpath/fastpath_common.c
@@ -10,25 +10,90 @@
 #endif
 
 #if defined (FAST_PPTP) || defined(FAST_L2TP)
-	#include <net/ip.h> 
+	#include <net/ip.h>
 #endif
 
 #if defined(CONFIG_NET_SCHED)
 #include <linux/netfilter_ipv4/ip_tables.h>
 extern int gQosEnabled;
 #endif
+#include <net/rtl/features/rtl_features.h>
 
 #include <net/rtl/fastpath/fastpath_core.h>
 #if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
 #include <net/rtl/features/rtl_features.h>
 #endif
 #include <net/rtl/rtl865x_nat.h>
+#include <net/rtl/features/rtl_ps_log.h>
 
 #if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
 static int	rtl_fp_gc_rx_threshold;
 #endif
 static int fast_nat_fw = 1;
 
+
+#if defined(IMPROVE_QOS) || defined(CONFIG_RTL_HW_QOS_SUPPORT)
+#include <net/arp.h>
+#include <net/rtl/rtl865x_netif.h>
+//To query hardware address based on IP through arp table of dev
+int arp_req_get_ha(__be32 queryIP, struct net_device *dev, unsigned char * resHwAddr)
+{
+	__be32 ip = queryIP;
+	struct neighbour *neigh;
+	int err = -ENXIO;
+
+	neigh = neigh_lookup(&arp_tbl, &ip, dev);
+	if (neigh) {
+		read_lock_bh(&neigh->lock);
+		memcpy(resHwAddr, neigh->ha, dev->addr_len);
+		read_unlock_bh(&neigh->lock);
+		neigh_release(neigh);
+		err = 0;
+	}
+	//else
+	//{
+	//	resHwAddr=NULL;
+	//}
+
+	return err;
+}
+//EXPORT_SYMBOL(arp_req_get_ha);
+#endif
+
+
+#if defined(FAST_PATH_SPI_ENABLED)
+int fast_spi =1;
+static struct proc_dir_entry *res_spi=NULL;
+static int spi_read_proc(char *page, char **start, off_t off,
+		     int count, int *eof, void *data)
+{
+	int len = 0;
+
+	len = sprintf(page, "fast_spi %s\n", fast_spi==1?"Enabled":"Disabled");
+
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+	return len;
+
+}
+static int spi_write_proc(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+	unsigned char tmpbuf[16];
+
+	memset(tmpbuf, 0, sizeof(tmpbuf));
+	if (buffer && !copy_from_user(tmpbuf, buffer, count))
+		sscanf(tmpbuf, "%d", &fast_spi);
+
+	return count;
+}
+
+#endif
+
+
 #if defined(CONFIG_PROC_FS)
 static struct proc_dir_entry *res1=NULL;
 static int read_proc(char *page, char **start, off_t off,
@@ -53,11 +118,11 @@ static int read_proc(char *page, char **start, off_t off,
 }
 static int write_proc(struct file *file, const char *buffer,
 		      unsigned long count, void *data)
-{      
+{
 	unsigned char tmpbuf[16];
 	struct net *net;
-	
-	if (count < 2) 
+
+	if (count < 2)
 		return -EFAULT;
 
 	memset(tmpbuf, 0, sizeof(tmpbuf));
@@ -65,13 +130,15 @@ static int write_proc(struct file *file, const char *buffer,
 		if (tmpbuf[0] == '2'&&count==2){
 			/* first byte == 2, second byte == "enter" */
 			for_each_net(net) {
-				nf_conntrack_flush(net, 0, 0);		//clean conntrack table		
+				nf_conntrack_flush(net, 0, 0);		//clean conntrack table
 			}
-			#if defined(CONFIG_RTL_LAYERED_DRIVER_L4) && defined(CONFIG_RTL_8198)
+			#if defined(CONFIG_RTL_LAYERED_DRIVER_L4)
+			#if defined(CONFIG_RTL_8198) || defined (CONFIG_RTL_8196CT)
 			rtl865x_nat_reinit();
 			/* the following 2 values MUST set behind reinit nat module	*/
-			rtl_nat_expire_interval_update(RTL865X_PROTOCOL_TCP, tcp_get_timeouts_by_state(TCP_CONNTRACK_ESTABLISHED));
-			rtl_nat_expire_interval_update(RTL865X_PROTOCOL_UDP, nf_ct_udp_timeout>nf_ct_udp_timeout_stream?nf_ct_udp_timeout:nf_ct_udp_timeout_stream);
+			//rtl_nat_expire_interval_update(RTL865X_PROTOCOL_TCP, tcp_get_timeouts_by_state(TCP_CONNTRACK_ESTABLISHED));
+			//rtl_nat_expire_interval_update(RTL865X_PROTOCOL_UDP, nf_ct_udp_timeout>nf_ct_udp_timeout_stream?nf_ct_udp_timeout:nf_ct_udp_timeout_stream);
+			#endif
 			#endif
 		}else{
 			sscanf(tmpbuf, "%d", &fast_nat_fw);
@@ -81,17 +148,17 @@ static int write_proc(struct file *file, const char *buffer,
 			}
 			#endif
 		}
-		return count;     
+		return count;
 	}
-	  
+
 	return -EFAULT;
 }
 #endif
 
-#if	defined(CONFIG_RTL_HW_QOS_SUPPORT) 
+#if	defined(CONFIG_RTL_HW_QOS_SUPPORT)
 int32 rtl_qosGetSkbMarkByNaptEntry(rtl865x_napt_entry *naptEntry, rtl865x_qos_mark *qosMark, struct sk_buff *pskb)
 {
-	struct iphdr *iph;	
+	struct iphdr *iph;
 	struct tcphdr *tcphupuh;  //just keep one , don't care tcp or udp //
 	u_int ori_saddr, ori_daddr;
 	u_short ori_sport, ori_dport;
@@ -104,7 +171,7 @@ int32 rtl_qosGetSkbMarkByNaptEntry(rtl865x_napt_entry *naptEntry, rtl865x_qos_ma
 	unsigned long irq_flags;
 	uint32 preMark, postMark;
 
-	if(pskb==NULL)				
+	if(pskb==NULL)
 		return FAILED;
 
 	//initial
@@ -133,7 +200,7 @@ int32 rtl_qosGetSkbMarkByNaptEntry(rtl865x_napt_entry *naptEntry, rtl865x_qos_ma
 	ori_daddr=iph->daddr;
 	ori_dport=tcphupuh->dest;
 
-	/* for dst mac match, please refer to the xt_mac.c */	
+	/* for dst mac match, please refer to the xt_mac.c */
 	dst_tmp = pskb->dst;
 	pskb->dst = NULL;
 
@@ -150,7 +217,7 @@ int32 rtl_qosGetSkbMarkByNaptEntry(rtl865x_napt_entry *naptEntry, rtl865x_qos_ma
 
 	memset(resMac,0,14);
 	if((lanDev!=NULL)&&(arp_req_get_ha(naptEntry->intIp,lanDev,resMac)==0))
-	{					
+	{
 		//Patch for pppoe wantype: run udp chariot
 		//bak skb mac header
 		if((memcmp(pskb->data-2, pppProto,2)==0)	//equal 0x0021
@@ -159,7 +226,7 @@ int32 rtl_qosGetSkbMarkByNaptEntry(rtl865x_napt_entry *naptEntry, rtl865x_qos_ma
 		{
 				skb_set_mac_header(pskb, -22);
 		}
-		
+
 		//Replace source mac addr to check uplink mark
 		memcpy(eth_hdr(pskb)->h_source,resMac, ETH_ALEN);
 		memcpy(eth_hdr(pskb)->h_dest,lanDev->dev_addr, ETH_ALEN);
@@ -172,10 +239,10 @@ int32 rtl_qosGetSkbMarkByNaptEntry(rtl865x_napt_entry *naptEntry, rtl865x_qos_ma
 			dev_net(lanDev)->ipv4.iptable_mangle);
 	}
 
-	DEBUGP_API("[%s][%d]:[%s][%s][%s][%s][%d]\n", __FUNCTION__, __LINE__, 
-					lanDev?lanDev->name:"NULL", 
-					wanDev?wanDev->name:"NULL", 
-					pskb->inDev?pskb->inDev->name:"NULL", 
+	DEBUGP_API("[%s][%d]:[%s][%s][%s][%s][%d]\n", __FUNCTION__, __LINE__,
+					lanDev?lanDev->name:"NULL",
+					wanDev?wanDev->name:"NULL",
+					pskb->inDev?pskb->inDev->name:"NULL",
 					pskb->dev?pskb->dev->name:"NULL", pskb->mark);
 	preMark = pskb->mark;
 
@@ -196,7 +263,7 @@ int32 rtl_qosGetSkbMarkByNaptEntry(rtl865x_napt_entry *naptEntry, rtl865x_qos_ma
 		{
 				skb_set_mac_header(pskb, -22);
 		}
-		
+
 		//Replace source mac addr to check uplink mark
 		memcpy(eth_hdr(pskb)->h_dest,resMac, ETH_ALEN);
 		memcpy(eth_hdr(pskb)->h_source,wanDev->dev_addr, ETH_ALEN);
@@ -208,10 +275,10 @@ int32 rtl_qosGetSkbMarkByNaptEntry(rtl865x_napt_entry *naptEntry, rtl865x_qos_ma
 			ipt_do_table(pskb, NF_IP_POST_ROUTING, lanDev, wanDev,\
 			dev_net(wanDev)->ipv4.iptable_mangle);
 	}
-	DEBUGP_API("[%s][%d]:[%s][%s][%s][%s][%d]\n", __FUNCTION__, __LINE__, 
-					lanDev?lanDev->name:"NULL", 
-					wanDev?wanDev->name:"NULL", 
-					pskb->inDev?pskb->inDev->name:"NULL", 
+	DEBUGP_API("[%s][%d]:[%s][%s][%s][%s][%d]\n", __FUNCTION__, __LINE__,
+					lanDev?lanDev->name:"NULL",
+					wanDev?wanDev->name:"NULL",
+					pskb->inDev?pskb->inDev->name:"NULL",
 					pskb->dev?pskb->dev->name:"NULL", pskb->mark);
 	postMark= pskb->mark;
 	}
@@ -232,7 +299,7 @@ int32 rtl_qosGetSkbMarkByNaptEntry(rtl865x_napt_entry *naptEntry, rtl865x_qos_ma
 
 		memset(resMac,0,14);
 		if((wanDev!=NULL)&&(arp_req_get_ha(naptEntry->remIp,wanDev,resMac)==0))
-		{						
+		{
 			//Patch for pppoe wantype: run udp chariot
 			if((memcmp(pskb->data-2, pppProto,2)==0)	//equal 0x0021
 				&&(skb_mac_header_was_set(pskb)==1)
@@ -240,22 +307,22 @@ int32 rtl_qosGetSkbMarkByNaptEntry(rtl865x_napt_entry *naptEntry, rtl865x_qos_ma
 			{
 				skb_set_mac_header(pskb, -22);
 			}
-			
+
 			//Replace source mac addr to check uplink mark
 			memcpy(eth_hdr(pskb)->h_source,resMac, ETH_ALEN);
 			memcpy(eth_hdr(pskb)->h_dest, wanDev->dev_addr, ETH_ALEN);
 		}
-		
+
 		pskb->mark=0;//initial
 		if(proto == ETH_P_IP){
 			(list_empty(&nf_hooks[PF_INET][NF_IP_PRE_ROUTING]))?: \
 				ipt_do_table(pskb, NF_IP_PRE_ROUTING, wanDev,lanDev,\
 				dev_net(wanDev)->ipv4.iptable_mangle);
 		}
-		DEBUGP_API("[%s][%d]:[%s][%s][%s][%s][%d]\n", __FUNCTION__, __LINE__, 
-						lanDev?lanDev->name:"NULL", 
-						wanDev?wanDev->name:"NULL", 
-						pskb->inDev?pskb->inDev->name:"NULL", 
+		DEBUGP_API("[%s][%d]:[%s][%s][%s][%s][%d]\n", __FUNCTION__, __LINE__,
+						lanDev?lanDev->name:"NULL",
+						wanDev?wanDev->name:"NULL",
+						pskb->inDev?pskb->inDev->name:"NULL",
 						pskb->dev?pskb->dev->name:"NULL", pskb->mark);
 		preMark = pskb->mark;
 
@@ -286,10 +353,10 @@ int32 rtl_qosGetSkbMarkByNaptEntry(rtl865x_napt_entry *naptEntry, rtl865x_qos_ma
 				ipt_do_table(pskb, NF_IP_POST_ROUTING, wanDev, lanDev,\
 				dev_net(lanDev)->ipv4.iptable_mangle);
 		}
-		DEBUGP_API("[%s][%d]:[%s][%s][%s][%s][%d]\n", __FUNCTION__, __LINE__, 
-						lanDev?lanDev->name:"NULL", 
-						wanDev?wanDev->name:"NULL", 
-						pskb->inDev?pskb->inDev->name:"NULL", 
+		DEBUGP_API("[%s][%d]:[%s][%s][%s][%s][%d]\n", __FUNCTION__, __LINE__,
+						lanDev?lanDev->name:"NULL",
+						wanDev?wanDev->name:"NULL",
+						pskb->inDev?pskb->inDev->name:"NULL",
 						pskb->dev?pskb->dev->name:"NULL", pskb->mark);
 		postMark= pskb->mark;
 	}
@@ -314,7 +381,7 @@ int32 rtl_qosGetSkbMarkByNaptEntry(rtl865x_napt_entry *naptEntry, rtl865x_qos_ma
 
 	if(lanDev)
 		dev_put(lanDev);
-	
+
 	if(wanDev)
 		dev_put(wanDev);
 
@@ -335,7 +402,7 @@ static inline void enter_fast_path_fast_l2tp_pre_process(struct sk_buff *skb)
 	struct net_device *l2tprx_dev;
 	struct in_device *skbIn_dev;
 	struct net_device *skbNetDevice;
-	
+
 	if(fast_l2tp_fw){
 		l2tprx_dev = skb->dev;
 		skbIn_dev = (struct in_device *)skb->dev->ip_ptr;
@@ -418,7 +485,7 @@ int fast_path_pre_process_check(struct iphdr *iph, struct tcphdr *tcphupuh, stru
 		return rtl_fp_gc_status_check(iph, tcphupuh, skb);
 	}
 	#endif
-	
+
 	return NET_RX_PASSBY;
 }
 
@@ -426,9 +493,9 @@ int fast_path_pre_process_check(struct iphdr *iph, struct tcphdr *tcphupuh, stru
 #if	defined(FAST_L2TP)
 static inline int enter_fast_path_fast_l2tp_post_process(struct sk_buff *skb)
 {
-	if (fast_l2tp_fw && skb->dev && (!memcmp(skb->dev->name, RTL_FASTPATH_PPP0_DEV_NAME, 4)) ) 
+	if (fast_l2tp_fw && skb->dev && (!memcmp(skb->dev->name, RTL_FASTPATH_PPP0_DEV_NAME, 4)) )
 	{
-		if (fast_l2tp_to_wan(skb)) // success
+		if (fast_l2tp_to_wan((void*)skb)) // success
 		{
 			return NET_RX_DROP;
 		}
@@ -437,15 +504,462 @@ static inline int enter_fast_path_fast_l2tp_post_process(struct sk_buff *skb)
 }
 #endif
 
+#if defined(FASTPTH_INDEPENDENCE_KERNEL)
+struct dst_entry *dst_tmp = NULL;
+
+/*As these API are used in fastpath, so skb will be check as valid, I will not check
+skb again*/
+
+unsigned int rtl_get_skb_len(struct sk_buff *skb)
+{
+	return skb->len;
+}
+
+__be16 rtl_get_skb_protocol(struct sk_buff *skb)
+{
+	return skb->protocol;
+}
+
+unsigned char rtl_get_skb_type(struct sk_buff *skb)
+{
+	return skb->pkt_type;
+}
+
+char *rtl_get_skb_dev_name(struct sk_buff *skb)
+{
+	return skb->dev->name;
+}
+
+__wsum rtl_get_skb_csum(struct sk_buff *skb)
+{
+	return skb->csum;
+}
+
+unsigned char *rtl_skb_mac_header(struct sk_buff * skb)
+{
+	return skb_mac_header(skb);
+}
+
+
+int rtl_ppp_proto_check(struct sk_buff *skb, unsigned char* ppp_proto)
+{
+	if(memcmp(skb->data-2, ppp_proto,2)==0)
+		return 1;
+	else
+		return 0;
+}
+
+unsigned int rtl_ipt_do_table(struct sk_buff * skb, unsigned int hook, void *in, void *out)
+{
+	struct net_device *out_dev = (struct net_device *)out;
+	struct net_device *in_dev;
+
+	if(in == NULL)
+		in_dev = skb->dev;
+	else
+		in_dev = (struct net_device *)in;
+
+	return ipt_do_table(skb, hook, in_dev, out_dev, dev_net(skb->dev)->ipv4.iptable_mangle);
+}
+
+int rtl_ip_route_input(struct sk_buff  *skb, __be32 daddr, __be32 saddr, u8 tos)
+{
+	return ip_route_input(skb, daddr, saddr, tos, skb->dev);
+}
+
+int rtl_skb_dst_check(struct sk_buff *skb)
+{
+	int ret = SUCCESS;
+
+	if( !(skb->dst->hh || skb->dst->neighbour)  ||skb->len > dst_mtu(skb->dst))
+		ret = FAILED;
+
+	return ret;
+}
+
+void rtl_set_skb_ip_summed(struct sk_buff *skb, int value)
+{
+	skb->ip_summed = value;
+	return;
+}
+
+void rtl_dst_release(struct sk_buff *skb)
+{
+	dst_release(skb->dst);
+	skb->dst = NULL;
+
+	return;
+}
+
+void rtl_set_skb_dev(struct sk_buff *skb, struct net_device *dev)
+{
+	if(dev == NULL)
+		skb->dev = skb->dst->dev;
+	else
+		skb->dev = dev;
+
+	return;
+}
+
+void rtl_set_skb_inDev(struct sk_buff *skb)
+{
+
+	skb->inDev = skb->dev;
+
+	return;
+}
+
+__u32 rtl_get_skb_mark(struct sk_buff *skb)
+{
+	return skb->mark;
+}
+
+void rtl_set_skb_mark(struct sk_buff *skb, unsigned int value)
+{
+	skb->mark = value;
+
+	return;
+}
+
+
+void rtl_store_skb_dst(struct sk_buff *skb)
+{
+	dst_tmp = skb->dst;
+
+	skb->dst = NULL;
+
+	return;
+}
+
+void rtl_set_skb_dst(struct sk_buff *skb)
+{
+	skb->dst = dst_tmp;
+
+	return;
+}
+
+int rtl_tcp_get_timeouts(void *ptr)
+{
+	struct nf_conn *ct = (struct nf_conn *)ptr;
+
+	return tcp_get_timeouts_by_state(ct->proto.tcp.state);
+}
+
+int rtl_arp_req_get_ha(__be32 queryIP, void *device, unsigned char * resHwAddr)
+{
+	struct net_device *dev = (struct net_device *)device;
+
+	return arp_req_get_ha(queryIP, dev, resHwAddr);
+}
+
+void rtl_set_skb_dmac(struct sk_buff *skb, void *device)
+{
+	struct net_device *dev = (struct net_device *)device;
+
+	memcpy(eth_hdr(skb)->h_dest, dev->dev_addr, ETH_ALEN);
+
+	return;
+}
+
+void rtl_set_skb_smac(struct sk_buff *skb, void *device)
+{
+	struct net_device *dev = (struct net_device *)device;
+
+	memcpy(eth_hdr(skb)->h_source, dev->dev_addr, ETH_ALEN);
+
+	return;
+}
+
+
+u_int8_t rtl_get_ct_protonum(void *ct_ptr, enum ip_conntrack_dir dir)
+{
+	struct nf_conn *ct = (struct nf_conn *)ct_ptr;
+
+	return ct->tuplehash[dir].tuple.dst.protonum;
+}
+
+unsigned long rtl_get_ct_udp_status(void *ct_ptr)
+{
+	struct nf_conn *ct = (struct nf_conn *)ct_ptr;
+
+	return ct->status;
+}
+
+u_int8_t rtl_get_ct_tcp_state(void *ct_ptr)
+{
+	struct nf_conn *ct = (struct nf_conn *)ct_ptr;
+
+	return ct->proto.tcp.state;
+}
+
+/*flag = 0 for src; flag = 1 for dst*/
+__be32 rtl_get_ct_ip_by_dir(void *ct_ptr, enum ip_conntrack_dir dir, int flag)
+{
+	struct nf_conn *ct = (struct nf_conn *)ct_ptr;
+
+	if(dir == IP_CT_DIR_ORIGINAL)
+	{
+		if(flag == 0)
+			return ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;
+		else if(flag == 1)
+			return ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip;
+	}
+	else if(dir == IP_CT_DIR_REPLY)
+	{
+		if(flag == 0)
+			return ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3.ip;
+		else if(flag == 1)
+			return ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip;
+	}
+}
+
+/*flag = 0 for src; flag = 1 for dst*/
+__be16 rtl_get_ct_port_by_dir(void *ct_ptr, enum ip_conntrack_dir dir, int flag)
+{
+	struct nf_conn *ct = (struct nf_conn *)ct_ptr;
+
+	if(dir == IP_CT_DIR_ORIGINAL)
+	{
+		if(flag == 0)
+			return ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.all;
+		else if(flag == 1)
+			return ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u.all;
+
+	}
+	else if(dir == IP_CT_DIR_REPLY)
+	{
+		if(flag == 0)
+			return ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u.all;
+		else if(flag == 1)
+			return ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u.all;
+	}
+}
+
+void rtl_set_ct_timeout_expires(void *ct_ptr, unsigned long value)
+{
+	struct nf_conn *ct = (struct nf_conn *)ct_ptr;
+
+	ct->timeout.expires = value;
+
+	return;
+}
+
+unsigned long rtl_hold_time(void *br_ptr)
+{
+	struct net_bridge *br = (struct net_bridge *)br_ptr;
+
+	return br->topology_change ? br->forward_delay : br->ageing_time;
+}
+
+void rtl_set_fdb_aging(void *fdb_ptr, unsigned long value)
+{
+	struct net_bridge_fdb_entry *fdb = (struct net_bridge_fdb_entry *)fdb_ptr;
+
+	fdb->ageing_timer = value;
+
+	return;
+}
+
+unsigned long rtl_get_fdb_aging(void *fdb_ptr)
+{
+	struct net_bridge_fdb_entry *fdb = (struct net_bridge_fdb_entry *)fdb_ptr;
+
+	return fdb->ageing_timer;
+}
+
+struct iphdr *rtl_ip_hdr(struct sk_buff *skb)
+{
+	return ip_hdr(skb);
+}
+
+struct ethhdr *rtl_eth_hdr(struct sk_buff *skb)
+{
+	return eth_hdr(skb);
+}
+
+int rtl_skb_mac_header_was_set(struct sk_buff *skb)
+{
+	return skb_mac_header_was_set(skb);
+}
+
+
+void rtl_skb_set_mac_header(struct sk_buff *skb, int offset)
+{
+	return skb_set_mac_header(skb, offset);
+}
+
+struct net_device * rtl_get_dev_by_name(char *name)
+{
+	return __dev_get_by_name(&init_net, name);
+}
+
+struct net_device *rtl_get_skb_dev(struct sk_buff* skb)
+{
+	return skb->dev;
+}
+
+unsigned char *rtl_get_skb_data(struct sk_buff* skb)
+{
+	return skb->data;
+}
+
+void rtl_skb_reset_network_header(struct sk_buff *skb)
+{
+	return skb_reset_network_header(skb);
+}
+
+void rtl_skb_reset_transport_header(struct sk_buff *skb)
+{
+	return skb_reset_transport_header(skb);
+}
+
+
+int rtl_call_skb_ndo_start_xmit(struct sk_buff *skb)
+{
+	return skb->dev->netdev_ops->ndo_start_xmit(skb,skb->dev);
+}
+
+char *rtl_get_ppp_dev_name(struct net_device *ppp_dev)
+{
+	return ppp_dev->name;
+}
+
+void * rtl_get_ppp_dev_priv(struct net_device *ppp_dev)
+{
+	return ppp_dev->priv;
+}
+
+void rtl_inc_ppp_stats(struct ppp *ppp, int act, int len)
+{
+	if(act == 0){	//rx
+		ppp->stats.rx_packets ++;
+		ppp->stats.rx_bytes += len;
+	}else if(act == 1){ //tx
+		ppp->stats.tx_packets ++;
+		ppp->stats.tx_bytes += len;
+	}
+
+	return;
+}
+
+void *rtl_set_skb_data(struct sk_buff *skb, int offset, int action)
+{
+	if(action == 1)
+		skb->data -= offset;
+	else if(action == 0)
+		skb->data += offset;
+
+	return;
+}
+
+void *rtl_set_skb_tail(struct sk_buff *skb, int offset, int action)
+{
+	if(action == 1)
+		skb->tail -= offset;
+	else if(action == 0)
+		skb->tail += offset;
+
+	return;
+}
+
+struct sk_buff *rtl_ppp_receive_nonmp_frame(struct ppp *ppp, struct sk_buff *skb, int is_fast_fw)
+{
+	return ppp_receive_nonmp_frame(ppp, skb, is_fast_fw);
+}
+
+int rtl_ppp_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	return ppp_start_xmit(skb, dev);
+}
+
+void rtl_set_skb_cb(struct sk_buff *skb, char *value, int len)
+{
+	memcpy(skb->cb, value, len);
+
+	return;
+}
+
+int rtl_ppp_vj_check(struct ppp* ppp)
+{
+	if(ppp->vj && !((ppp->xstate & SC_COMP_RUN) && ppp->xc_state))
+		return 1;
+	else
+		return 0;
+}
+
+void *rtl_get_ppp_xmit_pending(struct ppp* ppp)
+{
+	return (void*)ppp->xmit_pending;
+}
+
+void rtl_set_ppp_xmit_pending(struct ppp* ppp, struct sk_buff* skb)
+{
+	ppp->xmit_pending = skb;
+
+	return;
+}
+
+void rtl_set_skb_nfct(struct sk_buff *skb, void *value)
+{
+	skb->nfct = value;
+
+	return;
+}
+
+struct neighbour *rtl_neigh_lookup(const void *pkey, struct net_device *dev)
+{
+	return neigh_lookup(&arp_tbl, pkey, dev);
+}
+
+struct hh_cache *rtl_get_hh_from_neigh(struct neighbour *neigh)
+{
+	return neigh->hh;
+}
+
+seqlock_t rtl_get_lock_from_hh(struct hh_cache * hh)
+{
+	return hh->hh_lock;
+}
+
+unsigned short rtl_get_len_from_hh(struct hh_cache * hh)
+{
+	return hh->hh_len;
+}
+
+unsigned long *rtl_get_data_from_hh(struct hh_cache * hh)
+{
+	return hh->hh_data;
+}
+
+unsigned int rtl_skb_headroom(struct sk_buff *skb)
+{
+	return skb_headroom(skb);
+}
+
+int rtl_skb_cloned(struct sk_buff *skb)
+{
+	return skb_cloned(skb);
+}
+
+int rtl_skb_shared(const struct sk_buff *skb)
+{
+	return skb_shared(skb);
+}
+
+#endif
+
+
 int fast_path_before_nat_check(struct sk_buff *skb, struct iphdr *iph, uint32 iphProtocol)
 {
 	#if defined(RTL_FP_CHECK_SPI_ENABLED) || defined(FAST_PATH_SPI_ENABLED)
 	int	ret;
 	#endif
-	#if defined(FAST_PATH_SPI_ENABLED)		
+	#if defined(FAST_PATH_SPI_ENABLED)
 	unsigned int dataoff;
+	if(fast_spi == 0)
+		return NET_RX_PASSBY;
 	#endif
-	
+
 	#if defined(RTL_FP_CHECK_SPI_ENABLED)
 	ret = nf_conntrack_in(dev_net(skb->dev), PF_INET, NF_INET_PRE_ROUTING, skb);
 	switch (ret)
@@ -460,19 +974,19 @@ int fast_path_before_nat_check(struct sk_buff *skb, struct iphdr *iph, uint32 ip
 	}
 	#endif
 
-	#if defined(FAST_PATH_SPI_ENABLED)		
-	if (iphProtocol== IPPROTO_TCP){ 	
+	#if defined(FAST_PATH_SPI_ENABLED)
+	if (iphProtocol== IPPROTO_TCP){
 		dataoff = skb_network_offset(skb) + (iph->ihl<<2);
 		ret = rtl_nf_conntrack_in(dev_net(skb->dev), dataoff, NF_INET_PRE_ROUTING, skb);
-		switch (ret){			
-			case	NF_DROP:				
-				kfree_skb(skb); 			
-				return NET_RX_DROP; 		
-			case	NF_ACCEPT:				
-				break;			
-			default:				
-				return NET_RX_DROP; 	
-			}		
+		switch (ret){
+			case	NF_DROP:
+				kfree_skb(skb);
+				return NET_RX_DROP;
+			case	NF_ACCEPT:
+				break;
+			default:
+				return NET_RX_DROP;
+			}
 	}
 	#endif
 
@@ -491,24 +1005,24 @@ int fast_path_post_process_xmit_check(struct iphdr *iph, struct tcphdr *tcphupuh
 int fast_path_post_process_return_check(struct iphdr *iph, struct tcphdr *tcphupuh, struct sk_buff *skb)
 {
 	#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
-	if (iph->protocol==IPPROTO_UDP) 
+	if (iph->protocol==IPPROTO_UDP)
 		return rtl_fp_gc_status_check(iph, tcphupuh, skb);
 	#endif
-	
+
 	return NET_RX_SUCCESS;
-	
+
 }
 
 int32 rtl_fp_dev_queue_xmit_check(struct sk_buff *skb, struct net_device *dev)
 {
 	#ifdef FAST_L2TP
-	if (l2tp_tx_id_hook != NULL)			
-		l2tp_tx_id_hook(skb);			
+	if (l2tp_tx_id_hook != NULL)
+		l2tp_tx_id_hook((void*)skb);
 	#endif
 
 	#ifdef FAST_PPTP
 	if (sync_tx_pptp_gre_seqno_hook != NULL)
-		sync_tx_pptp_gre_seqno_hook(skb);			
+		sync_tx_pptp_gre_seqno_hook(skb);
 	#endif
 
 	return SUCCESS;
@@ -518,10 +1032,10 @@ int32 rtl_fp_dev_hard_start_xmit_check(struct sk_buff *skb, struct net_device *d
 {
 #if	defined(FAST_L2TP)
 	#if	defined(CONFIG_NET_SCHED)
-	if(!gQosEnabled)	
+	if(!gQosEnabled)
 	#endif
-	if (l2tp_tx_id_hook != NULL)			
-		l2tp_tx_id_hook(skb);
+	if (l2tp_tx_id_hook != NULL)
+		l2tp_tx_id_hook((void*)skb);
 #endif
 
 #if defined (CONFIG_RTL_LOCAL_PUBLIC)
@@ -557,7 +1071,7 @@ int ip_finish_output3(struct sk_buff *skb)
 				ipt_do_table(skb, NF_IP_POST_ROUTING, skb->dev, NULL, \
 				dev_net(skb->dev)->ipv4.iptable_mangle);
 		}
-    }        
+    }
 #endif
 #endif
 
@@ -571,21 +1085,21 @@ int ip_finish_output3(struct sk_buff *skb)
 #endif
 		skb_push(skb, hh->hh_len);
 
-#ifdef FAST_L2TP		
+#ifdef FAST_L2TP
 		if (fast_l2tp_fw)
-			l2tp_tx_id(skb);
-#endif		
+			l2tp_tx_id((void*)skb);
+#endif
 
 		if (skb->dev->flags & IFF_UP) {
 #if defined(CONFIG_NET_SCHED)
 			if (gQosEnabled) {
 				// call dev_queue_xmit() instead of hard_start_xmit(), because I want the packets be sent through Traffic Control module
 				dev_queue_xmit(skb);
-				return 0;	
-			} else            
-#endif            
+				return 0;
+			} else
+#endif
 			{
-			
+
 		#if defined(CONFIG_BRIDGE)
 				/*	In order to improve performance
 				*	We'd like to directly xmit and bypass the bridge check
@@ -609,7 +1123,7 @@ int ip_finish_output3(struct sk_buff *skb)
 					if(!skb->dev->netdev_ops->ndo_start_xmit(skb,skb->dev))
 						return 0;
 				}
-			}            
+			}
 		}
 //------------------------------- david+2007-05-25
 
@@ -617,7 +1131,7 @@ int ip_finish_output3(struct sk_buff *skb)
 		return dst->neighbour->output(skb);
 	}
 
-#if 0	
+#if 0
 	if (net_ratelimit())
 		printk(KERN_DEBUG "ip_finish_output3: No header cache and no neighbour!\n");
 #endif
@@ -633,14 +1147,15 @@ int FastPath_Enter(struct sk_buff **pskb)
 	skb=*pskb;
 	//skb->nh.raw = skb->data;
 	skb->transport_header=skb->data;
-	skb->network_header = skb->data;	
+	skb->network_header = skb->data;
 	//skb_reset_network_header(skb);
-	
+
 //hyking:
 //bug fix:when port filter is enable,application will disable fast_nat_fw,at this moment,url filter is abnormal...
 #if defined (DOS_FILTER) || defined (URL_FILTER)
-		ret = filter_enter(skb);
+		ret = filter_enter((void*)skb);
 		if (ret == NF_DROP) {
+			LOG_INFO("%s filter pkt, drop it\n", __FUNCTION__);
 			kfree_skb(skb);
 			ret = 1;
 			goto out;
@@ -689,31 +1204,32 @@ int FastPath_Enter(struct sk_buff **pskb)
 		}
 #endif
 
-#ifdef FAST_PPTP	
+#ifdef FAST_PPTP
 	if (fast_pptp_fw) {
-		fast_pptp_filter(skb);
-		ret = fast_pptp_to_lan(&skb);
+		fast_pptp_filter((void*)skb);
+		ret = fast_pptp_to_lan((void*)&skb);
 		if (ret < 0)	// error, skb has been free
 		{
 			ret = 1;
 			goto out;
 		}
 		*pskb=skb;
-	}	
+	}
 #endif
 
 #ifdef FAST_L2TP
-	if (fast_l2tp_fw) 
-		fast_l2tp_rx(skb);
+	if (fast_l2tp_fw)
+		fast_l2tp_rx((void*)skb);
 #endif
 
 
-	ret = enter_fast_path(skb);
+	ret = enter_fast_path((void*)skb);
+
 #if 0
 	if(ret != NET_RX_DROP)
 	{
 		struct tcphdr *tcpudph;
-		printk("-------%s(%d),ret(%d), src(0x%x),dst(0x%x)\n",__FUNCTION__,__LINE__,ret,ip_hdr(skb)->saddr,ip_hdr(skb)->daddr);
+		printk("-------%s(%d),ret(%d), src(0x%x),dst(0x%x), len is %d, version is %d\n",__FUNCTION__,__LINE__,ret,ip_hdr(skb)->saddr,ip_hdr(skb)->daddr, ip_hdr(skb)->ihl, ip_hdr(skb)->version);
 		if(ip_hdr(skb)->protocol == IPPROTO_TCP)
 		{
 			tcpudph = (struct tcphdr*)((__u32 *)skb->data + ip_hdr(skb)->ihl);
@@ -722,13 +1238,14 @@ int FastPath_Enter(struct sk_buff **pskb)
 	}
 #endif
 #ifdef FAST_PPTP
-	if (fast_pptp_fw && ret == 0 && ip_hdr(skb)->protocol == IPPROTO_GRE && skb->len > sizeof(struct iphdr)&& pptp_tcp_finished==1) 
-		if(Check_GRE_rx_net_device(skb))
+	if (fast_pptp_fw && ret == 0 && ip_hdr(skb)->protocol == IPPROTO_GRE && skb->len > sizeof(struct iphdr)&& pptp_tcp_finished==1)
+		if(Check_GRE_rx_net_device((void*)skb))
 		{
-			fast_pptp_sync_rx_seq(skb);
+			fast_pptp_sync_rx_seq((void*)skb);
 		}
 #endif
 
+
 out:
 	return ret;
 }
@@ -757,7 +1274,7 @@ static int __init fastpath_init(void)
 	/* proc file for debug */
 	init_fastpath_debug_proc();
 	#endif	/* DEBUG_PROCFILE */
-	
+
 	#ifndef NO_ARP_USED
 	/* Arp-Table Init */
 	ret=init_table_arp(ARP_TABLE_LIST_MAX,ARP_TABLE_ENTRY_MAX);
@@ -765,7 +1282,7 @@ static int __init fastpath_init(void)
 		DEBUGP_SYS("init_table_arp Failed!\n");
 	}
 	#endif
-	
+
 	#ifndef DEL_ROUTE_TBL
 	/* Route-Table Init */
 	ret=init_table_route(ROUTE_TABLE_LIST_MAX, ROUTE_TABLE_ENTRY_MAX);
@@ -788,7 +1305,7 @@ static int __init fastpath_init(void)
 	if(ret!=0) {
 		DEBUGP_SYS("init_table_path Failed!\n");
 	}
-	
+
 	#ifdef CONFIG_UDP_FRAG_CACHE
 	if(!udp_fragCache_init(MAX_UDP_FRAG_ENTRY))
 		return -1;
@@ -814,10 +1331,19 @@ static int __init fastpath_init(void)
 	}
 	#endif
 
+
+	#if defined(FAST_PATH_SPI_ENABLED)
+	res_spi = create_proc_entry("fast_spi",0,NULL);
+	if(res_spi){
+		res_spi->read_proc = spi_read_proc;
+		res_spi->write_proc = spi_write_proc;
+	}
+	#endif
+
 	#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
 	rtl_fp_gc_rx_threshold = RTL_FP_SESSION_LEVEL3_ALLOW_COUNT;
 	#endif
-	
+
 	return 0;
 }
 
@@ -853,11 +1379,19 @@ static void __exit fastpath_exit(void)
 
 #ifdef CONFIG_PROC_FS
 	if (res1) {
-		remove_proc_entry("fast_nat", res1);		
+		remove_proc_entry("fast_nat", res1);
 		res1 = NULL;
 	}
 #endif
 
+#if defined(FAST_PATH_SPI_ENABLED)
+		if(res_spi){
+			remove_proc_entry("fast_spi", res_spi);
+			res_spi = NULL;
+		}
+#endif
+
+
 	//printk("%s %s removed!\n", MODULE_NAME, MODULE_VERSION);
 }
 
diff --git a/net/rtl/features/98/rtl_nf_connGC.S b/net/rtl/features/98/rtl_nf_connGC.S
index 38babad..7dda2ba 100644
--- a/net/rtl/features/98/rtl_nf_connGC.S
+++ b/net/rtl/features/98/rtl_nf_connGC.S
@@ -91,16 +91,16 @@ drop_priority:
 	.half	120
 	.byte	11
 	.space	1
-	.half	60
+	.half	85
 	.byte	1
 	.space	1
-	.half	90
+	.half	110
 	.byte	2
 	.space	1
 	.half	30
 	.byte	12
 	.space	1
-	.half	20
+	.half	10
 	.byte	3
 	.space	1
 	.half	120
@@ -294,13 +294,13 @@ $L8:
 	beq	$2,$0,$L16
 	lui	$2,%hi(rtl_newGC_session_status_flags)
 
-	lui	$2,%hi(init_net+468)
-	lw	$3,%lo(init_net+468)($2)
-	lw	$2,%lo(rtl_nf_conntrack_threshold)($4)
-	slt	$2,$2,$3
-	beq	$2,$0,$L9
-	lui	$4,%hi(rtl_newGC_session_status_flags)
+	jal	rtl_gc_threshold_check
+	move	$4,$0
+
+	bne	$2,$0,$L9
+	lui	$2,%hi(rtl_newGC_session_status_flags)
 
+	lui	$4,%hi(rtl_newGC_session_status_flags)
 	li	$3,3			# 0x3
 	lw	$2,%lo(rtl_newGC_session_status_flags)($4)
 	beq	$2,$3,$L3
@@ -314,7 +314,6 @@ $L8:
 	sw	$2,%lo(rtl_newGC_session_status_time)($3)
 
 $L9:
-	lui	$2,%hi(rtl_newGC_session_status_flags)
 $L16:
 	sw	$0,%lo(rtl_newGC_session_status_flags)($2)
 $L3:
@@ -403,13 +402,13 @@ $L24:
 	beq	$2,$0,$L32
 	lui	$2,%hi(rtl_newGC_session_status_flags)
 
-	lui	$2,%hi(init_net+468)
-	lw	$3,%lo(init_net+468)($2)
-	lw	$2,%lo(rtl_nf_conntrack_threshold)($4)
-	slt	$2,$2,$3
-	beq	$2,$0,$L25
-	lui	$4,%hi(rtl_newGC_session_status_flags)
+	jal	rtl_gc_threshold_check
+	move	$4,$0
+
+	bne	$2,$0,$L25
+	lui	$2,%hi(rtl_newGC_session_status_flags)
 
+	lui	$4,%hi(rtl_newGC_session_status_flags)
 	li	$3,3			# 0x3
 	lw	$2,%lo(rtl_newGC_session_status_flags)($4)
 	beq	$2,$3,$L19
@@ -423,7 +422,6 @@ $L24:
 	sw	$2,%lo(rtl_newGC_session_status_time)($3)
 
 $L25:
-	lui	$2,%hi(rtl_newGC_session_status_flags)
 $L32:
 	sw	$0,%lo(rtl_newGC_session_status_flags)($2)
 $L19:
@@ -452,56 +450,44 @@ clean_from_lists:
 	sw	$17,20($sp)
 	move	$17,$5
 	sw	$16,16($sp)
-	addiu	$5,$4,4
+	move	$5,$0
 	sw	$31,24($sp)
-	move	$16,$4
-	lw	$3,4($4)
-	lw	$4,4($5)
-	andi	$2,$3,0x1
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L38
-	sw	$3,0($4)
+	jal	rtl_hlist_nulls_del_rcu
+	move	$16,$4
 	.set	macro
 	.set	reorder
 
-	sw	$4,4($3)
-$L38:
-	li	$2,2097152			# 0x200000
-	addiu	$6,$16,52
-	ori	$7,$2,0x200
-	sw	$7,4($5)
-	lw	$3,52($16)
-	lw	$4,4($6)
-	andi	$2,$3,0x1
+	move	$4,$16
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L42
-	sw	$3,0($4)
+	jal	rtl_hlist_nulls_del_rcu
+	li	$5,1			# 0x1
 	.set	macro
 	.set	reorder
 
-	sw	$4,4($3)
-$L42:
+	jal	local_bh_disable
+	move	$4,$16
 	.set	noreorder
 	.set	nomacro
-	jal	local_bh_disable
-	sw	$7,4($6)
+	jal	rtl_new_gc_get_ct_protonum
+	move	$5,$0
 	.set	macro
 	.set	reorder
 
+	move	$3,$2
 	li	$2,6			# 0x6
-	lbu	$3,50($16)
 	.set	noreorder
 	.set	nomacro
-	beq	$3,$2,$L48
+	beq	$3,$2,$L40
 	slt	$2,$3,7
 	.set	macro
 	.set	reorder
 
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L54
+	beq	$2,$0,$L46
 	li	$2,17			# 0x11
 	.set	macro
 	.set	reorder
@@ -509,22 +495,22 @@ $L42:
 	li	$2,1			# 0x1
 	.set	noreorder
 	.set	nomacro
-	beq	$3,$2,$L52
-	li	$2,6			# 0x6
+	beq	$3,$2,$L44
+	move	$4,$16
 	.set	macro
 	.set	reorder
 
-	j	$L65
-$L54:
+	j	$L55
+$L46:
 	.set	noreorder
 	.set	nomacro
-	beq	$3,$2,$L50
-	lui	$2,%hi(prot_counters+8)
+	beq	$3,$2,$L42
+	move	$4,$16
 	.set	macro
 	.set	reorder
 
-	j	$L47
-$L48:
+	j	$L55
+$L40:
 	lui	$2,%hi(prot_counters+4)
 #APP
 	   
@@ -539,8 +525,9 @@ $L48:
 	.previous					
 
 #NO_APP
-	j	$L64
-$L50:
+	j	$L54
+$L42:
+	lui	$2,%hi(prot_counters+8)
 #APP
 	   
 
@@ -554,8 +541,8 @@ $L50:
 	.previous					
 
 #NO_APP
-	j	$L64
-$L52:
+	j	$L54
+$L44:
 	lui	$2,%hi(prot_counters)
 #APP
 	   
@@ -570,25 +557,44 @@ $L52:
 	.previous					
 
 #NO_APP
-$L64:
+$L54:
 #APP
 	   
 
 #NO_APP
-$L47:
-	lbu	$3,50($16)
-	li	$2,6			# 0x6
-$L65:
+	move	$4,$16
+$L55:
 	.set	noreorder
 	.set	nomacro
-	beq	$3,$2,$L56
-	li	$2,17			# 0x11
+	jal	rtl_new_gc_get_ct_protonum
+	move	$5,$0
 	.set	macro
 	.set	reorder
 
-	bne	$3,$2,$L63
-$L56:
+	li	$3,6			# 0x6
+	.set	noreorder
+	.set	nomacro
+	beq	$2,$3,$L56
+	move	$4,$16
+	.set	macro
+	.set	reorder
+
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_new_gc_get_ct_protonum
+	move	$5,$0
+	.set	macro
+	.set	reorder
+
+	li	$3,17			# 0x11
+	.set	noreorder
+	.set	nomacro
+	bne	$2,$3,$L53
 	move	$4,$16
+	.set	macro
+	.set	reorder
+
+$L56:
 	.set	noreorder
 	.set	nomacro
 	jal	clean_from_lists_hooks
@@ -596,42 +602,42 @@ $L56:
 	.set	macro
 	.set	reorder
 
-	addiu	$5,$16,204
-	lw	$4,4($5)
-	li	$2,1048576			# 0x100000
-	lw	$3,204($16)
-	ori	$2,$2,0x100
-	sw	$3,0($4)
-	sw	$2,204($16)
-	li	$2,2097152			# 0x200000
-	ori	$2,$2,0x200
-	sw	$4,4($3)
-	sw	$2,4($5)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_list_del
+	move	$4,$16
+	.set	macro
+	.set	reorder
+
 	lui	$2,%hi(nf_conntrack_max)
 	lw	$2,%lo(nf_conntrack_max)($2)
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L66
+	beq	$2,$0,$L57
 	lui	$2,%hi(rtl_newGC_session_status_flags)
 	.set	macro
 	.set	reorder
 
-	lui	$2,%hi(rtl_nf_conntrack_threshold)
-	lw	$3,468($17)
-	lw	$2,%lo(rtl_nf_conntrack_threshold)($2)
-	slt	$2,$2,$3
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L59
-	lui	$4,%hi(rtl_newGC_session_status_flags)
+	jal	rtl_gc_threshold_check
+	move	$4,$17
+	.set	macro
+	.set	reorder
+
+	.set	noreorder
+	.set	nomacro
+	bne	$2,$0,$L49
+	lui	$2,%hi(rtl_newGC_session_status_flags)
 	.set	macro
 	.set	reorder
 
+	lui	$4,%hi(rtl_newGC_session_status_flags)
 	li	$3,3			# 0x3
 	lw	$2,%lo(rtl_newGC_session_status_flags)($4)
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$3,$L63
+	beq	$2,$3,$L53
 	lui	$2,%hi(jiffies)
 	.set	macro
 	.set	reorder
@@ -642,16 +648,15 @@ $L56:
 	addiu	$2,$2,1
 	.set	noreorder
 	.set	nomacro
-	j	$L63
+	j	$L53
 	sw	$2,%lo(rtl_newGC_session_status_time)($3)
 	.set	macro
 	.set	reorder
 
-$L59:
-	lui	$2,%hi(rtl_newGC_session_status_flags)
-$L66:
+$L49:
+$L57:
 	sw	$0,%lo(rtl_newGC_session_status_flags)($2)
-$L63:
+$L53:
 	jal	local_bh_enable
 	move	$4,$16
 	lw	$31,24($sp)
@@ -684,7 +689,7 @@ rtl_death_action:
 	lw	$3,200($4)
 	.set	noreorder
 	.set	nomacro
-	beq	$3,$0,$L74
+	beq	$3,$0,$L65
 	move	$16,$4
 	.set	macro
 	.set	reorder
@@ -692,33 +697,36 @@ rtl_death_action:
 	lbu	$2,8($3)
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L74
+	beq	$2,$0,$L65
 	addu	$3,$3,$2
 	.set	macro
 	.set	reorder
 
-	beq	$3,$0,$L74
+	beq	$3,$0,$L65
 	lw	$2,0($3)
-	beq	$2,$0,$L74
+	beq	$2,$0,$L65
 	lw	$2,64($2)
-	beq	$2,$0,$L74
+	beq	$2,$0,$L65
 	jal	$2
-$L74:
+$L65:
 	jal	local_bh_disable
-	move	$5,$17
-	lw	$3,488($17)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_nf_ct_stat_inc
+	move	$4,$17
+	.set	macro
+	.set	reorder
+
 	move	$4,$16
-	lw	$2,24($3)
-	addiu	$2,$2,1
 	.set	noreorder
 	.set	nomacro
 	jal	clean_from_lists
-	sw	$2,24($3)
+	move	$5,$17
 	.set	macro
 	.set	reorder
 
 	jal	local_bh_enable
-	beq	$16,$0,$L67
+	beq	$16,$0,$L58
 #APP
 	   
 
@@ -737,7 +745,7 @@ $L74:
 #NO_APP
 	.set	noreorder
 	.set	nomacro
-	bne	$2,$0,$L67
+	bne	$2,$0,$L58
 	move	$4,$16
 	.set	macro
 	.set	reorder
@@ -752,7 +760,7 @@ $L74:
 	.set	macro
 	.set	reorder
 
-$L67:
+$L58:
 	lw	$31,24($sp)
 	lw	$17,20($sp)
 	lw	$16,16($sp)
@@ -771,143 +779,177 @@ $L67:
 	.type	rtl_connGC_addList, @function
 rtl_connGC_addList:
 	.set	nomips16
-	.frame	$sp,0,$31		# vars= 0, regs= 0/0, args= 0, gp= 0
-	.mask	0x00000000,0
+	.frame	$sp,32,$31		# vars= 0, regs= 3/0, args= 16, gp= 0
+	.mask	0x80030000,-8
 	.fmask	0x00000000,0
-	lw	$2,156($4)
-	beq	$2,$0,$L94
-	lbu	$3,9($2)
+	addiu	$sp,$sp,-32
+	sw	$17,20($sp)
+	move	$17,$5
+	sw	$16,16($sp)
+	sw	$31,24($sp)
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_new_gc_ip_hdr
+	move	$16,$4
+	.set	macro
+	.set	reorder
+
+	beq	$2,$0,$L85
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_new_gc_get_skb_protocol
+	move	$4,$16
+	.set	macro
+	.set	reorder
+
+	move	$3,$2
 	li	$2,6			# 0x6
 	.set	noreorder
 	.set	nomacro
-	beq	$3,$2,$L99
+	beq	$3,$2,$L88
 	slt	$2,$3,7
 	.set	macro
 	.set	reorder
 
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L116
+	beq	$2,$0,$L97
 	li	$2,17			# 0x11
 	.set	macro
 	.set	reorder
 
 	li	$2,1			# 0x1
-	beq	$3,$2,$L112
 	.set	noreorder
 	.set	nomacro
-	j	$31
-	move	$2,$0
+	beq	$3,$2,$L95
+	lui	$2,%hi(prot_counters)
 	.set	macro
 	.set	reorder
 
-$L116:
+	j	$L85
+$L97:
+	beq	$3,$2,$L91
+	j	$L85
+$L88:
 	.set	noreorder
 	.set	nomacro
-	beq	$3,$2,$L104
-	move	$2,$0
+	jal	rtl_new_gc_get_ct_tcp_state
+	move	$4,$17
 	.set	macro
 	.set	reorder
 
-	j	$L119
-$L99:
-	lbu	$3,176($5)
-	lui	$2,%hi(Tcp_State_Hash_Head)
-	addiu	$2,$2,%lo(Tcp_State_Hash_Head)
-	sll	$3,$3,3
-	addu	$3,$3,$2
-	lw	$4,4($3)
-	beq	$4,$0,$L100
-	lw	$3,4($4)
-	addiu	$2,$5,204
-	sw	$4,204($5)
-	sw	$2,4($4)
-	sw	$2,0($3)
-	sw	$3,4($2)
-$L100:
+	lui	$3,%hi(Tcp_State_Hash_Head)
+	sll	$2,$2,3
+	addiu	$3,$3,%lo(Tcp_State_Hash_Head)
+	addu	$2,$2,$3
+	lw	$2,4($2)
+	.set	noreorder
+	.set	nomacro
+	beq	$2,$0,$L100
 	lui	$2,%hi(prot_counters+4)
+	.set	macro
+	.set	reorder
+
+	move	$4,$17
+	li	$5,1			# 0x1
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_list_add_tail
+	move	$6,$0
+	.set	macro
+	.set	reorder
+
+	lui	$2,%hi(prot_counters+4)
+$L100:
 #APP
 	   
 
-		.set	mips3					
-1:	ll	$3, %lo(prot_counters+4)($2)		# atomic_add		
+	1:	ll	$3, %lo(prot_counters+4)($2)		# atomic_add    
        nop                                             
 	addu	$3, 1					
-	sc	$3, %lo(prot_counters+4)($2)					
+	sc	$3, %lo(prot_counters+4)($2)                      
 	beqz	$3, 2f					
 	.subsection 2					
-2:	b	1b					
-	.previous					
-	.set	mips0					
+2:	b	1b                          
+	.previous                       
 
 #NO_APP
-	j	$L118
-$L104:
-	lw	$2,100($5)
-	addiu	$4,$5,204
+	j	$L99
+$L91:
+	.set	noreorder
+	.set	nomacro
+	jal	rtl_new_gc_get_ct_udp_status
+	move	$4,$17
+	.set	macro
+	.set	reorder
+
 	andi	$2,$2,0x2
 	.set	noreorder
 	.set	nomacro
-	beq	$2,$0,$L105
-	lui	$3,%hi(Udp_State_Hash_Head)
+	beq	$2,$0,$L92
+	move	$4,$17
+	.set	macro
+	.set	reorder
+
+	li	$5,2			# 0x2
+	.set	noreorder
+	.set	nomacro
+	j	$L98
+	li	$6,1			# 0x1
 	.set	macro
 	.set	reorder
 
-	addiu	$2,$3,%lo(Udp_State_Hash_Head)
-	lw	$2,12($2)
-	j	$L117
-$L105:
-	addiu	$2,$3,%lo(Udp_State_Hash_Head)
-	lw	$2,4($2)
-$L117:
-	lw	$3,4($2)
-	sw	$2,204($5)
-	sw	$4,4($2)
+$L92:
+	li	$5,2			# 0x2
+	move	$6,$0
+$L98:
+	jal	rtl_list_add_tail
 	lui	$2,%hi(prot_counters+8)
-	sw	$4,0($3)
-	sw	$3,4($4)
 #APP
 	   
 
-		.set	mips3					
-1:	ll	$3, %lo(prot_counters+8)($2)		# atomic_add		
+	1:	ll	$3, %lo(prot_counters+8)($2)		# atomic_add    
        nop                                             
 	addu	$3, 1					
-	sc	$3, %lo(prot_counters+8)($2)					
+	sc	$3, %lo(prot_counters+8)($2)                      
 	beqz	$3, 2f					
 	.subsection 2					
-2:	b	1b					
-	.previous					
-	.set	mips0					
+2:	b	1b                          
+	.previous                       
 
 #NO_APP
-	j	$L118
-$L112:
-	lui	$2,%hi(prot_counters)
+	j	$L99
+$L95:
 #APP
 	   
 
-		.set	mips3					
-1:	ll	$4, %lo(prot_counters)($2)		# atomic_add		
+	1:	ll	$4, %lo(prot_counters)($2)		# atomic_add    
        nop                                             
 	addu	$4, $3					
-	sc	$4, %lo(prot_counters)($2)					
+	sc	$4, %lo(prot_counters)($2)                      
 	beqz	$4, 2f					
 	.subsection 2					
-2:	b	1b					
-	.previous					
-	.set	mips0					
+2:	b	1b                          
+	.previous                       
 
 #NO_APP
-$L118:
+$L99:
 #APP
 	   
 
 #NO_APP
-$L94:
+$L85:
+	lw	$31,24($sp)
 	move	$2,$0
-$L119:
+	lw	$17,20($sp)
+	lw	$16,16($sp)
+	.set	noreorder
+	.set	nomacro
 	j	$31
+	addiu	$sp,$sp,32
+	.set	macro
+	.set	reorder
+
 	.end	rtl_connGC_addList
 	.section	.text.__nf_ct_refresh_acct_proto,"ax",@progbits
 	.align	2
@@ -916,962 +958,939 @@ $L119:
 	.type	__nf_ct_refresh_acct_proto, @function
 __nf_ct_refresh_acct_proto:
 	.set	nomips16
-	.frame	$sp,64,$31		# vars= 8, regs= 7/0, args= 24, gp= 0
-	.mask	0x803f0000,-8
+	.frame	$sp,56,$31		# vars= 8, regs= 6/0, args= 24, gp= 0
+	.mask	0x801f0000,-4
 	.fmask	0x00000000,0
 	.set	noreorder
 	.set	nomacro
 	
-	addiu	$sp,$sp,-64
-	sw	$17,36($sp)
-	move	$17,$4
-	sw	$21,52($sp)
-	move	$21,$6
+	addiu	$sp,$sp,-56
+	sw	$16,32($sp)
+	move	$16,$4
 	sw	$20,48($sp)
-	move	$20,$5
+	move	$20,$6
 	sw	$19,44($sp)
+	move	$19,$5
 	sw	$18,40($sp)
-	sw	$31,56($sp)
-	sw	$16,32($sp)
+	sw	$17,36($sp)
+	sw	$31,52($sp)
 	sw	$0,24($sp)
-	lbu	$18,87($sp)
+	lbu	$17,79($sp)
 	jal	local_bh_disable
-	move	$19,$7
+	move	$18,$7
 
-	lw	$2,100($17)
-	srl	$2,$2,10
-	andi	$2,$2,0x1
-	bne	$2,$0,$L156
-	nop
+	move	$4,$16
+	jal	rtl_test_bit
+	li	$5,10			# 0xa
 
-	lw	$2,100($17)
-	srl	$2,$2,3
-	andi	$2,$2,0x1
-	bne	$2,$0,$L129
-	li	$2,8			# 0x8
+	beq	$2,$0,$L121
+	move	$4,$16
+
+	jal	rtl_test_bit
+	li	$5,3			# 0x3
+
+	li	$3,-1			# 0xffffffff
+	bne	$2,$3,$L108
+	move	$5,$18
 
-	sw	$19,116($17)
-	j	$L132
+	jal	rtl_new_gc_set_ct_timeout_expires
+	move	$4,$16
+
+	li	$2,8			# 0x8
+	j	$L109
 	sw	$2,24($sp)
 
-$L129:
-	addiu	$16,$17,108
-	jal	del_timer
+$L108:
+	jal	rtl_del_ct_timer
 	move	$4,$16
 
-	beq	$2,$0,$L132
+	beq	$2,$0,$L109
 	lui	$2,%hi(jiffies)
 
 	move	$4,$16
-	lw	$2,%lo(jiffies)($2)
-	addu	$2,$2,$19
-	jal	add_timer
-	sw	$2,116($17)
+	lw	$5,%lo(jiffies)($2)
+	jal	rtl_new_gc_set_ct_timeout_expires
+	addu	$5,$5,$18
+
+	jal	rtl_add_ct_timer
+	move	$4,$16
 
 	li	$2,8			# 0x8
 	sw	$2,24($sp)
 	li	$2,6			# 0x6
-	beq	$18,$2,$L135
+	beq	$17,$2,$L112
 	li	$2,17			# 0x11
 
-	beq	$18,$2,$L140
+	beq	$17,$2,$L113
 	nop
 
-	j	$L132
+	j	$L109
 	nop
 
-$L135:
-	lw	$3,92($sp)
-	lui	$2,%hi(Tcp_State_Hash_Head)
-	addiu	$4,$17,204
-	addiu	$2,$2,%lo(Tcp_State_Hash_Head)
-	sll	$3,$3,3
-	lw	$6,4($4)
-	addu	$3,$3,$2
-	lw	$5,204($17)
-	lw	$2,4($3)
-	sw	$6,4($5)
-	lw	$3,4($2)
-	sw	$5,0($6)
-	sw	$4,4($2)
-	sw	$2,204($17)
-	sw	$3,4($4)
-	j	$L132
-	sw	$4,0($3)
-
-$L140:
-	lw	$2,100($17)
-	lw	$6,204($17)
+$L112:
+	lw	$6,84($sp)
+	move	$4,$16
+	j	$L120
+	li	$5,1			# 0x1
+
+$L113:
+	jal	rtl_new_gc_get_ct_udp_status
+	move	$4,$16
+
 	andi	$2,$2,0x2
-	beq	$2,$0,$L141
-	addiu	$5,$17,204
-
-	lui	$3,%hi(udp_assured_list)
-	lw	$2,4($5)
-	j	$L155
-	addiu	$3,$3,%lo(udp_assured_list)
-
-$L141:
-	lui	$3,%hi(udp_unreply_list)
-	lw	$2,4($5)
-	addiu	$3,$3,%lo(udp_unreply_list)
-$L155:
-	sw	$2,4($6)
-	lw	$4,4($3)
-	sw	$6,0($2)
-	sw	$5,4($3)
-	sw	$3,204($17)
-	sw	$4,4($5)
-	sw	$5,0($4)
-$L132:
-	lw	$7,80($sp)
+	beq	$2,$0,$L114
+	move	$4,$16
+
+	li	$5,2			# 0x2
+	j	$L120
+	li	$6,1			# 0x1
+
+$L114:
+	li	$5,2			# 0x2
+	move	$6,$0
+$L120:
+	jal	rtl_list_move_tail
+	nop
+
+$L109:
+	lw	$7,72($sp)
 	addiu	$2,$sp,24
-	move	$4,$17
-	move	$5,$20
-	move	$6,$21
+	move	$4,$16
+	move	$5,$19
+	move	$6,$20
 	jal	__nf_ct_refresh_acct_proto_hooks
 	sw	$2,16($sp)
 
-$L156:
+$L121:
 	jal	local_bh_enable
 	nop
 
-	lw	$31,56($sp)
-	lw	$21,52($sp)
+	lw	$31,52($sp)
 	lw	$20,48($sp)
 	lw	$19,44($sp)
 	lw	$18,40($sp)
 	lw	$17,36($sp)
 	lw	$16,32($sp)
 	j	$31
-	addiu	$sp,$sp,64
+	addiu	$sp,$sp,56
 
 	.set	macro
 	.set	reorder
 	.end	__nf_ct_refresh_acct_proto
-	.section	.text.drop_one_conntrack,"ax",@progbits
+	.section	.text.__conntrack_drop_check,"ax",@progbits
 	.align	2
-	.globl	drop_one_conntrack
-	.ent	drop_one_conntrack
-	.type	drop_one_conntrack, @function
-drop_one_conntrack:
+	.globl	__conntrack_drop_check
+	.ent	__conntrack_drop_check
+	.type	__conntrack_drop_check, @function
+__conntrack_drop_check:
 	.set	nomips16
-	.frame	$sp,64,$31		# vars= 0, regs= 9/0, args= 24, gp= 0
+	.frame	$sp,56,$31		# vars= 0, regs= 9/0, args= 16, gp= 0
 	.mask	0x80ff0000,-8
 	.fmask	0x00000000,0
 	.set	noreorder
 	.set	nomacro
 	
-	addiu	$sp,$sp,-64
-	sw	$31,56($sp)
-	sw	$23,52($sp)
-	sw	$22,48($sp)
-	sw	$21,44($sp)
-	sw	$20,40($sp)
-	sw	$19,36($sp)
-	sw	$18,32($sp)
-	sw	$17,28($sp)
-	sw	$16,24($sp)
-	lhu	$3,16($4)
-	sltu	$2,$3,1024
-	bne	$2,$0,$L157
-	li	$2,1			# 0x1
+	addiu	$sp,$sp,-56
+	move	$5,$0
+	sw	$16,16($sp)
+	move	$16,$4
+	sw	$31,48($sp)
+	sw	$23,44($sp)
+	sw	$22,40($sp)
+	sw	$21,36($sp)
+	sw	$20,32($sp)
+	sw	$19,28($sp)
+	sw	$18,24($sp)
+	jal	rtl_new_gc_get_ct_protonum
+	sw	$17,20($sp)
 
-	li	$6,8080			# 0x1f90
-	beq	$3,$6,$L157
-	nop
+	move	$4,$16
+	move	$5,$0
+	jal	rtl_new_gc_get_ct_port_by_dir
+	move	$6,$0
 
-	lhu	$3,36($4)
-	sltu	$2,$3,1024
-	bne	$2,$0,$L157
-	li	$2,1			# 0x1
+	move	$4,$16
+	move	$5,$0
+	li	$6,1			# 0x1
+	jal	rtl_new_gc_get_ct_port_by_dir
+	move	$23,$2
+
+	move	$4,$16
+	li	$5,1			# 0x1
+	move	$6,$0
+	jal	rtl_new_gc_get_ct_port_by_dir
+	move	$22,$2
+
+	move	$4,$16
+	li	$5,1			# 0x1
+	li	$6,1			# 0x1
+	jal	rtl_new_gc_get_ct_port_by_dir
+	move	$21,$2
+
+	move	$4,$16
+	move	$5,$0
+	move	$6,$0
+	jal	rtl_new_gc_get_ct_ip_by_dir
+	move	$20,$2
+
+	move	$4,$16
+	move	$5,$0
+	li	$6,1			# 0x1
+	jal	rtl_new_gc_get_ct_ip_by_dir
+	move	$19,$2
+
+	move	$4,$16
+	li	$5,1			# 0x1
+	move	$6,$0
+	jal	rtl_new_gc_get_ct_ip_by_dir
+	move	$17,$2
+
+	move	$4,$16
+	li	$5,1			# 0x1
+	li	$6,1			# 0x1
+	jal	rtl_new_gc_get_ct_ip_by_dir
+	move	$18,$2
 
-	beq	$3,$6,$L157
+	li	$5,-268435456			# 0xf0000000
+	move	$3,$2
+	li	$4,-536870912			# 0xe0000000
+	and	$2,$17,$5
+	beq	$2,$4,$L124
+	and	$2,$3,$5
+
+	beq	$2,$4,$L122
+	li	$2,-1			# 0xffffffff
+
+	bne	$19,$3,$L127
+	sltu	$2,$23,1024
+
+	beq	$17,$18,$L124
 	nop
 
-	lhu	$3,16($5)
-	sltu	$2,$3,1024
-	bne	$2,$0,$L157
-	li	$2,1			# 0x1
+$L127:
+	bne	$2,$0,$L122
+	li	$2,-1			# 0xffffffff
+
+	sltu	$2,$22,1024
+	bne	$2,$0,$L122
+	li	$2,-1			# 0xffffffff
+
+	sltu	$2,$21,1024
+	bne	$2,$0,$L122
+	li	$2,-1			# 0xffffffff
+
+	sltu	$2,$20,1024
+	bne	$2,$0,$L124
+	li	$3,8080			# 0x1f90
 
-	beq	$3,$6,$L157
+	beq	$23,$3,$L124
 	nop
 
-	lhu	$3,36($5)
-	sltu	$2,$3,1024
-	bne	$2,$0,$L157
-	li	$2,1			# 0x1
+	beq	$22,$3,$L124
+	nop
 
-	beq	$3,$6,$L157
-	li	$7,-268435456			# 0xf0000000
+	beq	$21,$3,$L122
+	li	$2,-1			# 0xffffffff
+
+	bne	$20,$3,$L122
+	move	$2,$0
 
-	lw	$3,20($4)
-	li	$8,-536870912			# 0xe0000000
-	and	$2,$3,$7
-	lw	$4,0($4)
-	beq	$2,$8,$L394
-	li	$6,-1			# 0xffffffff
+$L124:
+	li	$2,-1			# 0xffffffff
+$L122:
+	lw	$31,48($sp)
+	lw	$23,44($sp)
+	lw	$22,40($sp)
+	lw	$21,36($sp)
+	lw	$20,32($sp)
+	lw	$19,28($sp)
+	lw	$18,24($sp)
+	lw	$17,20($sp)
+	lw	$16,16($sp)
+	j	$31
+	addiu	$sp,$sp,56
 
-	beq	$3,$6,$L157
+	.set	macro
+	.set	reorder
+	.end	__conntrack_drop_check
+	.section	.text.isReservedConntrack,"ax",@progbits
+	.align	2
+	.globl	isReservedConntrack
+	.ent	isReservedConntrack
+	.type	isReservedConntrack, @function
+isReservedConntrack:
+	.set	nomips16
+	.frame	$sp,0,$31		# vars= 0, regs= 0/0, args= 0, gp= 0
+	.mask	0x00000000,0
+	.fmask	0x00000000,0
+	.set	noreorder
+	.set	nomacro
+	
+	lbu	$3,38($4)
 	li	$2,1			# 0x1
+	beq	$3,$2,$L128
+	li	$7,1			# 0x1
+
+	lw	$6,20($4)
+	li	$8,-268435456			# 0xf0000000
+	li	$9,-536870912			# 0xe0000000
+	and	$2,$6,$8
+	lw	$3,0($4)
+	beq	$2,$9,$L139
+	li	$7,-1			# 0xffffffff
+
+	beq	$6,$7,$L139
+	nop
 
-	beq	$4,$0,$L157
+	beq	$3,$0,$L139
 	nop
 
 	lw	$3,20($5)
-	lw	$5,0($5)
-	and	$2,$3,$7
-	beq	$2,$8,$L157
-	li	$2,1			# 0x1
+	lw	$6,0($5)
+	and	$2,$3,$8
+	beq	$2,$9,$L139
+	nop
 
-	beq	$3,$6,$L157
+	beq	$3,$7,$L139
 	nop
 
-	beq	$5,$0,$L157
-	lui	$3,%hi(prot_counters+4)
+	beq	$6,$0,$L139
+	li	$3,80			# 0x50
 
+	lhu	$2,16($4)
+	beq	$2,$3,$L139
+	li	$6,8080			# 0x1f90
+
+	beq	$2,$6,$L139
+	nop
+
+	lhu	$4,36($4)
+	beq	$4,$3,$L139
+	nop
+
+	beq	$4,$6,$L139
+	nop
+
+	lhu	$2,16($5)
+	beq	$2,$3,$L139
+	nop
+
+	beq	$2,$6,$L139
+	nop
+
+	lhu	$5,36($5)
+	beq	$5,$3,$L156
+	li	$7,1			# 0x1
+
+	bne	$5,$6,$L128
+	move	$7,$0
+
+$L139:
+	li	$7,1			# 0x1
+$L128:
+$L156:
+	j	$31
+	move	$2,$7
+
+	.set	macro
+	.set	reorder
+	.end	isReservedConntrack
+	.section	.text.drop_one_conntrack,"ax",@progbits
+	.align	2
+	.globl	drop_one_conntrack
+	.ent	drop_one_conntrack
+	.type	drop_one_conntrack, @function
+drop_one_conntrack:
+	.set	nomips16
+	.frame	$sp,64,$31		# vars= 0, regs= 10/0, args= 24, gp= 0
+	.mask	0xc0ff0000,-4
+	.fmask	0x00000000,0
+	.set	noreorder
+	.set	nomacro
+	
+	addiu	$sp,$sp,-64
 	lui	$2,%hi(_prot_limit+4)
+	sw	$31,60($sp)
+	lui	$3,%hi(prot_counters+4)
+	sw	$fp,56($sp)
+	sw	$23,52($sp)
+	sw	$22,48($sp)
+	sw	$21,44($sp)
+	sw	$20,40($sp)
+	sw	$19,36($sp)
+	sw	$18,32($sp)
+	sw	$17,28($sp)
+	sw	$16,24($sp)
 	lw	$2,%lo(_prot_limit+4)($2)
 	lw	$3,%lo(prot_counters+4)($3)
 	slt	$2,$2,$3
-	beq	$2,$0,$L447
+	beq	$2,$0,$L343
 	lui	$2,%hi(_prot_limit+8)
 
+	lui	$20,%hi(drop_priority_max_idx)
 	jal	local_bh_disable
 	move	$19,$0
 
+	lw	$2,%lo(drop_priority_max_idx)($20)
+	blez	$2,$L304
 	lui	$3,%hi(drop_priority)
-$L449:
+
+$L344:
 	sll	$2,$19,2
 	addiu	$3,$3,%lo(drop_priority)
 	addu	$2,$2,$3
 	lbu	$3,0($2)
 	sltu	$2,$3,10
-	beq	$2,$0,$L186
+	beq	$2,$0,$L164
 	lui	$2,%hi(Tcp_State_Hash_Head)
 
 	sll	$3,$3,3
 	addiu	$2,$2,%lo(Tcp_State_Hash_Head)
 	addu	$3,$3,$2
 	lw	$18,4($3)
-	lw	$4,0($18)
-	beq	$4,$18,$L186
-	move	$17,$4
+	lw	$2,0($18)
+	beq	$2,$18,$L164
+	move	$17,$2
 
-$L437:
-	beq	$17,$18,$L186
+$L332:
+	beq	$17,$18,$L164
 	addiu	$16,$17,-204
 
-	li	$12,-268435456			# 0xf0000000
-	lw	$6,32($16)
-	li	$11,-536870912			# 0xe0000000
-	lhu	$10,28($16)
-	and	$2,$6,$12
-	lhu	$7,48($16)
-	lhu	$8,76($16)
-	lhu	$9,96($16)
-	lw	$4,12($16)
-	lw	$5,60($16)
-	lw	$3,80($16)
-	beq	$2,$11,$L192
-	and	$2,$3,$12
-
-	beq	$2,$11,$L192
-	nop
-
-	bne	$4,$3,$L448
-	sltu	$2,$10,1024
-
-	beq	$6,$5,$L192
-	nop
-
-$L448:
-	bne	$2,$0,$L192
-	sltu	$2,$7,1024
-
-	bne	$2,$0,$L192
-	sltu	$2,$8,1024
-
-	bne	$2,$0,$L192
-	sltu	$2,$9,1024
-
-	bne	$2,$0,$L192
-	li	$2,8080			# 0x1f90
-
-	beq	$10,$2,$L192
-	nop
+	li	$2,-1			# 0xffffffff
+	lb	$3,212($16)
+	bne	$3,$2,$L171
+	move	$4,$16
 
-	beq	$7,$2,$L192
+	jal	__conntrack_drop_check
 	nop
 
-	beq	$8,$2,$L192
-	nop
+	sb	$2,212($16)
+$L171:
+	lb	$2,212($16)
+	bne	$2,$0,$L170
+	move	$4,$16
 
-	beq	$9,$2,$L192
+	jal	rtl_del_ct_timer
 	nop
 
-	jal	del_timer
-	addiu	$4,$17,-96
-
-	bne	$2,$0,$L412
+	bne	$2,$0,$L318
 	nop
 
-$L192:
+$L170:
 	lw	$17,0($17)
-	j	$L437
+	j	$L332
 	nop
 
-$L186:
+$L164:
+	lw	$2,%lo(drop_priority_max_idx)($20)
 	addiu	$19,$19,1
-	sltu	$2,$19,10
-	bne	$2,$0,$L449
+	slt	$2,$19,$2
+	bne	$2,$0,$L344
 	lui	$3,%hi(drop_priority)
 
+$L304:
 	jal	local_bh_enable
 	nop
 
 	lui	$2,%hi(_prot_limit+8)
-$L447:
+$L343:
 	lui	$3,%hi(prot_counters+8)
 	lw	$2,%lo(_prot_limit+8)($2)
 	lw	$3,%lo(prot_counters+8)($3)
 	slt	$2,$2,$3
-	beq	$2,$0,$L216
-	nop
+	beq	$2,$0,$L182
+	lui	$fp,%hi(drop_priority_max_idx)
 
+	lui	$20,%hi(drop_priority_max_idx)
 	jal	local_bh_disable
 	move	$19,$0
 
+	lw	$2,%lo(drop_priority_max_idx)($20)
+	blez	$2,$L307
 	lui	$3,%hi(drop_priority)
-$L451:
+
+$L345:
 	sll	$2,$19,2
 	addiu	$3,$3,%lo(drop_priority)
 	addu	$2,$2,$3
 	lbu	$3,0($2)
 	sltu	$2,$3,11
-	bne	$2,$0,$L222
+	bne	$2,$0,$L188
 	lui	$2,%hi(Udp_State_Hash_Head)
 
 	sll	$3,$3,3
 	addiu	$2,$2,%lo(Udp_State_Hash_Head)
 	addu	$3,$3,$2
 	lw	$18,-84($3)
-	lw	$4,0($18)
-	beq	$4,$18,$L222
-	move	$17,$4
+	lw	$2,0($18)
+	beq	$2,$18,$L188
+	move	$17,$2
 
-$L438:
-	beq	$17,$18,$L222
+$L333:
+	beq	$17,$18,$L188
 	addiu	$16,$17,-204
 
-	li	$12,-268435456			# 0xf0000000
-	lw	$6,32($16)
-	li	$11,-536870912			# 0xe0000000
-	lhu	$10,28($16)
-	and	$2,$6,$12
-	lhu	$7,48($16)
-	lhu	$8,76($16)
-	lhu	$9,96($16)
-	lw	$4,12($16)
-	lw	$5,60($16)
-	lw	$3,80($16)
-	beq	$2,$11,$L228
-	and	$2,$3,$12
-
-	beq	$2,$11,$L228
-	nop
-
-	bne	$4,$3,$L450
-	sltu	$2,$10,1024
-
-	beq	$6,$5,$L228
-	nop
-
-$L450:
-	bne	$2,$0,$L228
-	sltu	$2,$7,1024
-
-	bne	$2,$0,$L228
-	sltu	$2,$8,1024
-
-	bne	$2,$0,$L228
-	sltu	$2,$9,1024
-
-	bne	$2,$0,$L228
-	li	$2,8080			# 0x1f90
-
-	beq	$10,$2,$L228
-	nop
+	li	$2,-1			# 0xffffffff
+	lb	$3,212($16)
+	bne	$3,$2,$L195
+	move	$4,$16
 
-	beq	$7,$2,$L228
+	jal	__conntrack_drop_check
 	nop
 
-	beq	$8,$2,$L228
-	nop
+	sb	$2,212($16)
+$L195:
+	lb	$2,212($16)
+	bne	$2,$0,$L194
+	move	$4,$16
 
-	beq	$9,$2,$L228
+	jal	rtl_del_ct_timer
 	nop
 
-	jal	del_timer
-	addiu	$4,$17,-96
-
-	bne	$2,$0,$L412
+	bne	$2,$0,$L318
 	nop
 
-$L228:
+$L194:
 	lw	$17,0($17)
-	j	$L438
+	j	$L333
 	nop
 
-$L222:
+$L188:
+	lw	$2,%lo(drop_priority_max_idx)($20)
 	addiu	$19,$19,1
-	sltu	$2,$19,10
-	bne	$2,$0,$L451
+	slt	$2,$19,$2
+	bne	$2,$0,$L345
 	lui	$3,%hi(drop_priority)
 
+$L307:
 	jal	local_bh_enable
-	nop
+	lui	$fp,%hi(drop_priority_max_idx)
 
-	j	$L216
+	j	$L341
 	nop
 
-$L412:
+$L318:
 	jal	local_bh_enable
 	nop
 
 	jal	rtl_death_action
 	move	$4,$16
 
-	j	$L446
+	j	$L342
 	lui	$4,%hi(rtl_newGC_session_status_flags)
 
-$L216:
+$L182:
+$L341:
 	jal	local_bh_disable
 	move	$19,$0
 
+	lw	$2,%lo(drop_priority_max_idx)($fp)
+	blez	$2,$L310
 	lui	$22,%hi(drop_priority)
-$L456:
+
+$L346:
 	sll	$21,$19,2
 	addiu	$2,$22,%lo(drop_priority)
 	addu	$2,$21,$2
 	lbu	$2,0($2)
 	sltu	$3,$2,10
-	beq	$3,$0,$L260
+	beq	$3,$0,$L214
 	sll	$4,$2,3
 
 	lui	$2,%hi(Tcp_State_Hash_Head)
 	addiu	$2,$2,%lo(Tcp_State_Hash_Head)
 	addu	$2,$4,$2
 	lw	$18,4($2)
-	lw	$4,0($18)
-	beq	$4,$18,$L293
+	lw	$2,0($18)
+	beq	$2,$18,$L235
 	li	$23,3			# 0x3
 
-	move	$17,$4
+	move	$17,$2
 	move	$20,$0
-$L439:
-	beq	$17,$18,$L293
+$L334:
+	beq	$17,$18,$L235
 	addiu	$16,$17,-204
 
-	li	$12,-268435456			# 0xf0000000
-	lw	$6,32($16)
-	li	$11,-536870912			# 0xe0000000
-	and	$2,$6,$12
-	lhu	$7,28($16)
-	lhu	$8,48($16)
-	lhu	$9,76($16)
-	lhu	$10,96($16)
-	lw	$4,12($16)
-	lw	$5,60($16)
-	lw	$3,80($16)
-	beq	$2,$11,$L266
+	li	$2,-1			# 0xffffffff
+	lb	$3,212($16)
+	move	$4,$16
+	bne	$3,$2,$L221
 	addiu	$20,$20,1
 
-	and	$2,$3,$12
-	beq	$2,$11,$L266
-	nop
-
-	bne	$4,$3,$L452
-	sltu	$2,$7,1024
-
-	beq	$6,$5,$L266
-	nop
-
-$L452:
-	bne	$2,$0,$L266
-	sltu	$2,$8,1024
-
-	bne	$2,$0,$L266
-	sltu	$2,$9,1024
-
-	bne	$2,$0,$L266
-	sltu	$2,$10,1024
-
-	bne	$2,$0,$L266
-	li	$2,8080			# 0x1f90
-
-	beq	$7,$2,$L266
+	jal	__conntrack_drop_check
 	nop
 
-	beq	$8,$2,$L266
-	nop
+	sb	$2,212($16)
+$L221:
+	lb	$2,212($16)
+	bne	$2,$0,$L220
+	move	$4,$16
 
-	beq	$9,$2,$L266
+	jal	rtl_get_ct_timer_expires
 	nop
 
-	beq	$10,$2,$L266
-	lui	$2,%hi(jiffies)
-
+	lui	$3,%hi(jiffies)
+	lw	$5,%lo(jiffies)($3)
 	addiu	$3,$22,%lo(drop_priority)
-	lw	$4,%lo(jiffies)($2)
 	addu	$3,$21,$3
-	lw	$2,116($16)
+	subu	$2,$2,$5
 	lhu	$3,2($3)
-	subu	$2,$2,$4
 	srl	$2,$2,7
 	sltu	$3,$3,$2
-	bne	$3,$0,$L453
-	slt	$2,$20,1025
-
-	jal	del_timer
-	addiu	$4,$17,-96
+	bne	$3,$0,$L223
+	move	$4,$16
 
-	beq	$2,$0,$L453
-	slt	$2,$20,1025
+	jal	rtl_del_ct_timer
+	nop
 
 	move	$4,$16
 	move	$5,$19
 	move	$6,$0
+	beq	$2,$0,$L223
 	li	$7,1			# 0x1
+
 	jal	__drop_one_conntrack_process_hooks1
 	sw	$23,16($sp)
 
+	move	$4,$16
 	move	$3,$2
 	li	$2,1			# 0x1
-	beq	$3,$2,$L413
-	li	$2,2			# 0x2
-
-	beq	$3,$2,$L440
 	move	$5,$19
-
-	move	$4,$16
 	move	$6,$0
+	beq	$3,$2,$L319
 	li	$7,1			# 0x1
+
+	li	$2,2			# 0x2
+	beq	$3,$2,$L246
+	li	$3,1			# 0x1
+
 	jal	__drop_one_conntrack_process_hooks2
 	sw	$23,16($sp)
 
-	slt	$2,$20,1025
-$L453:
-	beq	$2,$0,$L316
+$L223:
+	slt	$2,$20,129
+	beq	$2,$0,$L246
 	move	$3,$0
 
-$L266:
+$L220:
 	lw	$17,0($17)
-	j	$L439
+	j	$L334
 	nop
 
-$L413:
+$L319:
 	jal	local_bh_enable
 	nop
 
 	jal	rtl_death_action
 	move	$4,$16
 
-$L440:
-	j	$L316
+	j	$L246
 	li	$3,1			# 0x1
 
-$L260:
+$L214:
 	lui	$2,%hi(Udp_State_Hash_Head)
 	addiu	$2,$2,%lo(Udp_State_Hash_Head)
 	addu	$2,$4,$2
 	lw	$18,-84($2)
-	lw	$4,0($18)
-	beq	$4,$18,$L293
+	lw	$2,0($18)
+	beq	$2,$18,$L235
 	li	$23,12			# 0xc
 
-	move	$17,$4
+	move	$17,$2
 	move	$20,$0
-$L441:
-	beq	$17,$18,$L293
+$L336:
+	beq	$17,$18,$L235
 	addiu	$16,$17,-204
 
-	li	$12,-268435456			# 0xf0000000
-	lw	$6,32($16)
-	li	$11,-536870912			# 0xe0000000
-	and	$2,$6,$12
-	lhu	$7,28($16)
-	lhu	$8,48($16)
-	lhu	$9,76($16)
-	lhu	$10,96($16)
-	lw	$4,12($16)
-	lw	$5,60($16)
-	lw	$3,80($16)
-	beq	$2,$11,$L297
+	li	$2,-1			# 0xffffffff
+	lb	$3,212($16)
+	move	$4,$16
+	bne	$3,$2,$L240
 	addiu	$20,$20,1
 
-	and	$2,$3,$12
-	beq	$2,$11,$L297
+	jal	__conntrack_drop_check
 	nop
 
-	bne	$4,$3,$L454
-	sltu	$2,$7,1024
-
-	beq	$6,$5,$L297
-	nop
-
-$L454:
-	bne	$2,$0,$L297
-	sltu	$2,$8,1024
-
-	bne	$2,$0,$L297
-	sltu	$2,$9,1024
-
-	bne	$2,$0,$L297
-	sltu	$2,$10,1024
-
-	bne	$2,$0,$L297
-	li	$2,8080			# 0x1f90
-
-	beq	$7,$2,$L297
-	nop
-
-	beq	$8,$2,$L297
-	nop
+	sb	$2,212($16)
+$L240:
+	lb	$2,212($16)
+	bne	$2,$0,$L239
+	move	$4,$16
 
-	beq	$9,$2,$L297
+	jal	rtl_get_ct_timer_expires
 	nop
 
-	beq	$10,$2,$L297
-	lui	$2,%hi(jiffies)
-
+	lui	$3,%hi(jiffies)
+	lw	$5,%lo(jiffies)($3)
 	addiu	$3,$22,%lo(drop_priority)
-	lw	$4,%lo(jiffies)($2)
 	addu	$3,$21,$3
-	lw	$2,116($16)
+	subu	$2,$2,$5
 	lhu	$3,2($3)
-	subu	$2,$2,$4
 	srl	$2,$2,7
 	sltu	$3,$3,$2
-	bne	$3,$0,$L455
-	slt	$2,$20,1025
-
-	jal	del_timer
-	addiu	$4,$17,-96
+	bne	$3,$0,$L242
+	move	$4,$16
 
-	beq	$2,$0,$L455
-	slt	$2,$20,1025
+	jal	rtl_del_ct_timer
+	nop
 
 	move	$4,$16
 	move	$5,$19
 	move	$6,$0
+	beq	$2,$0,$L242
 	li	$7,1			# 0x1
+
 	jal	__drop_one_conntrack_process_hooks1
 	sw	$23,16($sp)
 
+	move	$4,$16
 	move	$3,$2
 	li	$2,1			# 0x1
-	beq	$3,$2,$L413
-	li	$2,2			# 0x2
-
-	beq	$3,$2,$L440
 	move	$5,$19
-
-	move	$4,$16
 	move	$6,$0
+	beq	$3,$2,$L319
 	li	$7,1			# 0x1
+
+	li	$2,2			# 0x2
+	beq	$3,$2,$L246
+	li	$3,1			# 0x1
+
 	jal	__drop_one_conntrack_process_hooks2
 	sw	$23,16($sp)
 
-	slt	$2,$20,1025
-$L455:
-	beq	$2,$0,$L316
+$L242:
+	slt	$2,$20,129
+	beq	$2,$0,$L246
 	move	$3,$0
 
-$L297:
+$L239:
 	lw	$17,0($17)
-	j	$L441
+	j	$L336
 	nop
 
-$L293:
+$L235:
 	move	$3,$0
-$L316:
+$L246:
 	li	$2,1			# 0x1
-	beq	$3,$2,$L253
+	beq	$3,$2,$L207
 	addiu	$19,$19,1
 
-	sltu	$2,$19,10
-	bne	$2,$0,$L456
+	lw	$2,%lo(drop_priority_max_idx)($fp)
+	slt	$2,$19,$2
+	bne	$2,$0,$L346
 	lui	$22,%hi(drop_priority)
 
+$L310:
 	jal	local_bh_enable
-	move	$19,$0
+	lui	$fp,%hi(drop_priority_max_idx)
 
 	jal	local_bh_disable
+	move	$19,$0
+
+	lw	$2,%lo(drop_priority_max_idx)($fp)
+	blez	$2,$L314
 	lui	$22,%hi(drop_priority)
 
-$L461:
+$L347:
 	sll	$21,$19,2
 	addiu	$2,$22,%lo(drop_priority)
 	addu	$2,$21,$2
 	lbu	$2,0($2)
 	sltu	$3,$2,10
-	beq	$3,$0,$L330
+	beq	$3,$0,$L260
 	sll	$4,$2,3
 
 	lui	$2,%hi(Tcp_State_Hash_Head)
 	addiu	$2,$2,%lo(Tcp_State_Hash_Head)
 	addu	$2,$4,$2
 	lw	$18,4($2)
-	lw	$4,0($18)
-	beq	$4,$18,$L363
+	lw	$2,0($18)
+	beq	$2,$18,$L281
 	li	$23,3			# 0x3
 
-	move	$17,$4
+	move	$17,$2
 	move	$20,$0
-$L442:
-	beq	$17,$18,$L363
+$L337:
+	beq	$17,$18,$L281
 	addiu	$16,$17,-204
 
-	li	$12,-268435456			# 0xf0000000
-	lw	$6,32($16)
-	li	$11,-536870912			# 0xe0000000
-	and	$2,$6,$12
-	lhu	$7,28($16)
-	lhu	$8,48($16)
-	lhu	$9,76($16)
-	lhu	$10,96($16)
-	lw	$4,12($16)
-	lw	$5,60($16)
-	lw	$3,80($16)
-	beq	$2,$11,$L336
+	li	$2,-1			# 0xffffffff
+	lb	$3,212($16)
+	move	$4,$16
+	bne	$3,$2,$L267
 	addiu	$20,$20,1
 
-	and	$2,$3,$12
-	beq	$2,$11,$L336
-	nop
-
-	bne	$4,$3,$L457
-	sltu	$2,$7,1024
-
-	beq	$6,$5,$L336
-	nop
-
-$L457:
-	bne	$2,$0,$L336
-	sltu	$2,$8,1024
-
-	bne	$2,$0,$L336
-	sltu	$2,$9,1024
-
-	bne	$2,$0,$L336
-	sltu	$2,$10,1024
-
-	bne	$2,$0,$L336
-	li	$2,8080			# 0x1f90
-
-	beq	$7,$2,$L336
+	jal	__conntrack_drop_check
 	nop
 
-	beq	$8,$2,$L336
-	nop
+	sb	$2,212($16)
+$L267:
+	lb	$2,212($16)
+	bne	$2,$0,$L266
+	move	$4,$16
 
-	beq	$9,$2,$L336
+	jal	rtl_get_ct_timer_expires
 	nop
 
-	beq	$10,$2,$L336
-	lui	$2,%hi(jiffies)
-
+	lui	$3,%hi(jiffies)
+	lw	$5,%lo(jiffies)($3)
 	addiu	$3,$22,%lo(drop_priority)
-	lw	$4,%lo(jiffies)($2)
 	addu	$3,$21,$3
-	lw	$2,116($16)
+	subu	$2,$2,$5
 	lhu	$3,2($3)
-	subu	$2,$2,$4
 	srl	$2,$2,9
 	sltu	$3,$3,$2
-	bne	$3,$0,$L458
-	slt	$2,$20,1025
-
-	jal	del_timer
-	addiu	$4,$17,-96
+	bne	$3,$0,$L269
+	move	$4,$16
 
-	beq	$2,$0,$L458
-	slt	$2,$20,1025
+	jal	rtl_del_ct_timer
+	nop
 
 	move	$4,$16
 	move	$5,$19
 	li	$6,2			# 0x2
+	beq	$2,$0,$L269
 	move	$7,$0
+
 	jal	__drop_one_conntrack_process_hooks1
 	sw	$23,16($sp)
 
+	move	$4,$16
 	move	$3,$2
 	li	$2,1			# 0x1
-	beq	$3,$2,$L418
-	li	$2,2			# 0x2
-
-	beq	$3,$2,$L443
 	move	$5,$19
-
-	move	$4,$16
 	li	$6,2			# 0x2
+	beq	$3,$2,$L324
 	move	$7,$0
+
+	li	$2,2			# 0x2
+	beq	$3,$2,$L292
+	li	$3,1			# 0x1
+
 	jal	__drop_one_conntrack_process_hooks2
 	sw	$23,16($sp)
 
-	slt	$2,$20,1025
-$L458:
-	beq	$2,$0,$L386
+$L269:
+	slt	$2,$20,129
+	beq	$2,$0,$L292
 	move	$3,$0
 
-$L336:
+$L266:
 	lw	$17,0($17)
-	j	$L442
+	j	$L337
 	nop
 
-$L418:
+$L324:
 	jal	local_bh_enable
 	nop
 
 	jal	rtl_death_action
 	move	$4,$16
 
-$L443:
-	j	$L386
+	j	$L292
 	li	$3,1			# 0x1
 
-$L330:
+$L260:
 	lui	$2,%hi(Udp_State_Hash_Head)
 	addiu	$2,$2,%lo(Udp_State_Hash_Head)
 	addu	$2,$4,$2
 	lw	$18,-84($2)
-	lw	$4,0($18)
-	beq	$4,$18,$L363
+	lw	$2,0($18)
+	beq	$2,$18,$L281
 	li	$23,12			# 0xc
 
-	move	$17,$4
+	move	$17,$2
 	move	$20,$0
-$L444:
-	beq	$17,$18,$L363
+$L339:
+	beq	$17,$18,$L281
 	addiu	$16,$17,-204
 
-	li	$12,-268435456			# 0xf0000000
-	lw	$6,32($16)
-	li	$11,-536870912			# 0xe0000000
-	and	$2,$6,$12
-	lhu	$7,28($16)
-	lhu	$8,48($16)
-	lhu	$9,76($16)
-	lhu	$10,96($16)
-	lw	$4,12($16)
-	lw	$5,60($16)
-	lw	$3,80($16)
-	beq	$2,$11,$L367
+	li	$2,-1			# 0xffffffff
+	lb	$3,212($16)
+	move	$4,$16
+	bne	$3,$2,$L286
 	addiu	$20,$20,1
 
-	and	$2,$3,$12
-	beq	$2,$11,$L367
-	nop
-
-	bne	$4,$3,$L459
-	sltu	$2,$7,1024
-
-	beq	$6,$5,$L367
-	nop
-
-$L459:
-	bne	$2,$0,$L367
-	sltu	$2,$8,1024
-
-	bne	$2,$0,$L367
-	sltu	$2,$9,1024
-
-	bne	$2,$0,$L367
-	sltu	$2,$10,1024
-
-	bne	$2,$0,$L367
-	li	$2,8080			# 0x1f90
-
-	beq	$7,$2,$L367
+	jal	__conntrack_drop_check
 	nop
 
-	beq	$8,$2,$L367
-	nop
+	sb	$2,212($16)
+$L286:
+	lb	$2,212($16)
+	bne	$2,$0,$L285
+	move	$4,$16
 
-	beq	$9,$2,$L367
+	jal	rtl_get_ct_timer_expires
 	nop
 
-	beq	$10,$2,$L367
-	lui	$2,%hi(jiffies)
-
+	lui	$3,%hi(jiffies)
+	lw	$5,%lo(jiffies)($3)
 	addiu	$3,$22,%lo(drop_priority)
-	lw	$4,%lo(jiffies)($2)
 	addu	$3,$21,$3
-	lw	$2,116($16)
+	subu	$2,$2,$5
 	lhu	$3,2($3)
-	subu	$2,$2,$4
 	srl	$2,$2,9
 	sltu	$3,$3,$2
-	bne	$3,$0,$L460
-	slt	$2,$20,1025
-
-	jal	del_timer
-	addiu	$4,$17,-96
+	bne	$3,$0,$L288
+	move	$4,$16
 
-	beq	$2,$0,$L460
-	slt	$2,$20,1025
+	jal	rtl_del_ct_timer
+	nop
 
 	move	$4,$16
 	move	$5,$19
 	li	$6,2			# 0x2
+	beq	$2,$0,$L288
 	move	$7,$0
+
 	jal	__drop_one_conntrack_process_hooks1
 	sw	$23,16($sp)
 
+	move	$4,$16
 	move	$3,$2
 	li	$2,1			# 0x1
-	beq	$3,$2,$L418
-	li	$2,2			# 0x2
-
-	beq	$3,$2,$L443
 	move	$5,$19
-
-	move	$4,$16
 	li	$6,2			# 0x2
+	beq	$3,$2,$L324
 	move	$7,$0
+
+	li	$2,2			# 0x2
+	beq	$3,$2,$L292
+	li	$3,1			# 0x1
+
 	jal	__drop_one_conntrack_process_hooks2
 	sw	$23,16($sp)
 
-	slt	$2,$20,1025
-$L460:
-	beq	$2,$0,$L386
+$L288:
+	slt	$2,$20,129
+	beq	$2,$0,$L292
 	move	$3,$0
 
-$L367:
+$L285:
 	lw	$17,0($17)
-	j	$L444
+	j	$L339
 	nop
 
-$L363:
+$L281:
 	move	$3,$0
-$L386:
+$L292:
 	li	$2,1			# 0x1
-	beq	$3,$2,$L253
+	beq	$3,$2,$L207
 	addiu	$19,$19,1
 
-	sltu	$2,$19,10
-	bne	$2,$0,$L461
+	lw	$2,%lo(drop_priority_max_idx)($fp)
+	slt	$2,$19,$2
+	bne	$2,$0,$L347
 	lui	$22,%hi(drop_priority)
 
-	j	$L436
+	j	$L314
 	nop
 
-$L253:
+$L207:
 	lui	$4,%hi(rtl_newGC_session_status_flags)
-$L446:
+$L342:
 	lw	$2,%lo(rtl_newGC_session_status_flags)($4)
-	bne	$2,$0,$L394
+	bne	$2,$0,$L300
 	nop
 
 	lui	$2,%hi(jiffies)
@@ -1881,18 +1900,18 @@ $L446:
 	lui	$2,%hi(rtl_newGC_session_status_time)
 	addiu	$3,$3,1
 	sw	$3,%lo(rtl_newGC_session_status_time)($2)
-$L394:
+$L300:
 	j	$L157
 	li	$2,1			# 0x1
 
-$L436:
+$L314:
 	jal	local_bh_enable
 	nop
 
 	lui	$4,%hi(rtl_newGC_session_status_flags)
 	lw	$2,%lo(rtl_newGC_session_status_flags)($4)
 	li	$3,1			# 0x1
-	beq	$2,$3,$L396
+	beq	$2,$3,$L302
 	lui	$2,%hi(jiffies)
 
 	lw	$2,%lo(jiffies)($2)
@@ -1900,10 +1919,11 @@ $L436:
 	lui	$3,%hi(rtl_newGC_session_status_time)
 	addiu	$2,$2,200
 	sw	$2,%lo(rtl_newGC_session_status_time)($3)
-$L396:
+$L302:
 	move	$2,$0
 $L157:
-	lw	$31,56($sp)
+	lw	$31,60($sp)
+	lw	$fp,56($sp)
 	lw	$23,52($sp)
 	lw	$22,48($sp)
 	lw	$21,44($sp)
@@ -1925,45 +1945,46 @@ $L157:
 	.type	rtl_nf_conn_GC_init, @function
 rtl_nf_conn_GC_init:
 	.set	nomips16
-	.frame	$sp,24,$31		# vars= 0, regs= 2/0, args= 16, gp= 0
-	.mask	0x80010000,-4
+	.frame	$sp,32,$31		# vars= 0, regs= 3/0, args= 16, gp= 0
+	.mask	0x80030000,-8
 	.fmask	0x00000000,0
 	.set	noreorder
 	.set	nomacro
 	
 	lui	$2,%hi(Tcp_State_Hash_Head)
-	addiu	$sp,$sp,-24
+	addiu	$sp,$sp,-32
 	addiu	$2,$2,%lo(Tcp_State_Hash_Head)
 	li	$5,10			# 0xa
-	sw	$31,20($sp)
+	sw	$31,24($sp)
 	addiu	$2,$2,4
+	sw	$17,20($sp)
 	sw	$16,16($sp)
-$L468:
+$L354:
 	lw	$3,0($2)
 	addiu	$5,$5,-1
-	beq	$3,$0,$L465
+	beq	$3,$0,$L351
 	addiu	$2,$2,8
 
 	sw	$3,4($3)
 	sw	$3,0($3)
-$L465:
-	bgez	$5,$L468
+$L351:
+	bgez	$5,$L354
 	nop
 
 	lui	$2,%hi(Udp_State_Hash_Head)
 	li	$5,1			# 0x1
 	addiu	$2,$2,%lo(Udp_State_Hash_Head)
 	addiu	$2,$2,4
-$L474:
+$L360:
 	lw	$3,0($2)
 	addiu	$5,$5,-1
-	beq	$3,$0,$L471
+	beq	$3,$0,$L357
 	addiu	$2,$2,8
 
 	sw	$3,4($3)
 	sw	$3,0($3)
-$L471:
-	bgez	$5,$L474
+$L357:
+	bgez	$5,$L360
 	lui	$16,%hi(prot_limit)
 
 	move	$5,$0
@@ -1977,47 +1998,50 @@ $L471:
 	addiu	$6,$2,%lo(_prot_limit)
 	move	$5,$0
 	sll	$2,$5,2
-$L497:
+$L383:
 	addiu	$5,$5,1
 	addu	$4,$2,$6
 	slt	$3,$5,3
 	addu	$2,$2,$7
 	sw	$0,0($2)
 	sw	$0,0($4)
-	bne	$3,$0,$L497
+	bne	$3,$0,$L383
 	sll	$2,$5,2
 
 	lui	$2,%hi(nf_conntrack_max)
-	addiu	$3,$16,%lo(prot_limit)
+	li	$3,10			# 0xa
 	lw	$6,%lo(nf_conntrack_max)($2)
 	lui	$2,%hi(_prot_limit)
-	addiu	$10,$2,%lo(_prot_limit)
+	addiu	$9,$2,%lo(_prot_limit)
+	lui	$2,%hi(drop_priority_max_idx)
+	sw	$3,%lo(drop_priority_max_idx)($2)
 	li	$2,2			# 0x2
 	sw	$2,%lo(prot_limit)($16)
-	li	$2,90			# 0x5a
-	sw	$2,4($3)
 	li	$2,1374355456			# 0x51eb0000
-	lui	$7,%hi(rtl_newGC_session_status_flags)
-	ori	$8,$2,0x851f
+	addiu	$4,$16,%lo(prot_limit)
+	ori	$7,$2,0x851f
+	li	$2,90			# 0x5a
+	lui	$17,%hi(rtl_newGC_session_status_flags)
+	sw	$2,4($4)
 	li	$2,60			# 0x3c
-	move	$9,$3
-	sw	$2,8($3)
+	move	$8,$4
 	move	$5,$0
-	sw	$0,%lo(rtl_newGC_session_status_flags)($7)
+	sw	$2,8($4)
+	sw	$0,%lo(rtl_newGC_session_status_flags)($17)
 	sll	$3,$5,2
-$L498:
+$L384:
 	addiu	$5,$5,1
-	addu	$2,$3,$9
+	addu	$2,$3,$8
 	slt	$4,$5,3
 	lw	$2,0($2)
-	addu	$3,$3,$10
+	addu	$3,$3,$9
 	mult	$6,$2
 	mflo	$2
-	multu	$2,$8
+	multu	$2,$7
 	mfhi	$2
 	srl	$2,$2,5
 	sw	$2,0($3)
-	bne	$4,$0,$L498
+	bne	$4,$0,$L384
 	sll	$3,$5,2
 
 	li	$3,-859045888			# 0xcccc0000
@@ -2029,45 +2053,46 @@ $L498:
 	srl	$2,$2,2
 	subu	$3,$6,$2
 	sltu	$3,$3,65
-	bne	$3,$0,$L484
+	bne	$3,$0,$L370
 	sw	$2,%lo(rtl_nf_conntrack_threshold)($4)
 
 	addiu	$2,$6,-64
 	sw	$2,%lo(rtl_nf_conntrack_threshold)($4)
-$L484:
+$L370:
 	lui	$2,%hi(nf_conntrack_max)
 	lw	$2,%lo(nf_conntrack_max)($2)
-	beq	$2,$0,$L485
-	lui	$2,%hi(init_net+468)
+	beq	$2,$0,$L371
+	nop
 
-	lw	$3,%lo(init_net+468)($2)
-	lw	$2,%lo(rtl_nf_conntrack_threshold)($4)
-	slt	$2,$2,$3
-	beq	$2,$0,$L485
+	jal	rtl_gc_threshold_check
+	move	$4,$0
+
+	bne	$2,$0,$L371
 	li	$3,3			# 0x3
 
-	lw	$2,%lo(rtl_newGC_session_status_flags)($7)
-	beq	$2,$3,$L488
+	lw	$2,%lo(rtl_newGC_session_status_flags)($17)
+	beq	$2,$3,$L374
 	lui	$2,%hi(jiffies)
 
 	lw	$2,%lo(jiffies)($2)
-	sw	$3,%lo(rtl_newGC_session_status_flags)($7)
+	sw	$3,%lo(rtl_newGC_session_status_flags)($17)
 	lui	$3,%hi(rtl_newGC_session_status_time)
 	addiu	$2,$2,1
-	j	$L488
+	j	$L374
 	sw	$2,%lo(rtl_newGC_session_status_time)($3)
 
-$L485:
-	sw	$0,%lo(rtl_newGC_session_status_flags)($7)
-$L488:
+$L371:
+	sw	$0,%lo(rtl_newGC_session_status_flags)($17)
+$L374:
 	jal	rtl_nf_conn_GC_init_hooks
 	nop
 
 	move	$2,$0
-	lw	$31,20($sp)
+	lw	$31,24($sp)
+	lw	$17,20($sp)
 	lw	$16,16($sp)
 	j	$31
-	addiu	$sp,$sp,24
+	addiu	$sp,$sp,32
 
 	.set	macro
 	.set	reorder
@@ -2079,6 +2104,12 @@ $L488:
 	.size	rtl_nf_conntrack_threshold, 4
 rtl_nf_conntrack_threshold:
 	.space	4
+	.globl	drop_priority_max_idx
+	.align	2
+	.type	drop_priority_max_idx, @object
+	.size	drop_priority_max_idx, 4
+drop_priority_max_idx:
+	.space	4
 	.globl	rtl_newGC_session_status_flags
 	.section	.dram-fwd,"aw",@progbits
 	.align	2
diff --git a/net/rtl/features/Makefile b/net/rtl/features/Makefile
index 1e34bfa..229e483 100644
--- a/net/rtl/features/Makefile
+++ b/net/rtl/features/Makefile
@@ -3,17 +3,27 @@
 #
  
 #EXTRA_CFLAGS += -I $(DIR_LINUX)/drivers/net/rtl819x
-EXTRA_CFLAGS += -I $(TOPDIR)/net
+EXTRA_CFLAGS += -I $(DIR_LINUX)/net
 EXTRA_CFLAGS += -D__KERNEL__
 #EXTRA_CFLAGS += -Wno-implicit -Werror
 
 #EXTRA_CFLAGS += -DCONFIG_RTK_IPTABLES_FAST_PATH
 #EXTRA_CFLAGS += -DCONFIG_FAST_PATH_MODULE
 
+ifeq ($(CONFIG_RTL_819XD),y)
+TARGET = 9xD
+endif
+
+ifeq ($(CONFIG_RTL_8196E),y)
+TARGET = 96E
+endif
+
 ifeq ($(CONFIG_RTL_8198),y)
 TARGET = 98
-else
-TARGET = 96C
+endif
+
+ifeq ($(CONFIG_RTL_8196C),y)
+TARGET = 96E
 endif
  
 EFEATURES_OBJ=rtl_features.o rtl_ps_hooks.o
diff --git a/net/rtl/features/rtl_features.c b/net/rtl/features/rtl_features.c
index a07ceca..1cc8abb 100644
--- a/net/rtl/features/rtl_features.c
+++ b/net/rtl/features/rtl_features.c
@@ -10,7 +10,7 @@
 #include <linux/ip.h>
 #include <linux/tcp.h>
 
-#if defined(CONFIG_PROC_FS) 
+#if defined(CONFIG_PROC_FS)
 #include <linux/proc_fs.h>
 #endif
 
@@ -69,7 +69,7 @@ extern int rtl865x_curOpMode;
 __DRAM_GEN int gQosEnabled;
 #endif
 
-#ifdef CONFIG_RTL_HARDWARE_NAT 
+#ifdef CONFIG_RTL_HARDWARE_NAT
 /*2007-12-19*/
 #ifdef CONFIG_RTL_LAYERED_DRIVER_L3
 #include <net/rtl/rtl865x_ip_api.h>
@@ -84,8 +84,8 @@ __DRAM_GEN int gQosEnabled;
 enum LR_RESULT (*FastPath_hook4)( rtl_fp_napt_entry *fpNaptEntry)=NULL;
 enum LR_RESULT (*FastPath_hook6)( rtl_fp_napt_entry *fpNaptEntry,
 #if defined(IMPROVE_QOS)
-									struct sk_buff *pskb, struct nf_conn *ct, 
-#endif								
+									struct sk_buff *pskb, struct nf_conn *ct,
+#endif
                                                                enum NP_FLAGS flags)=NULL;
 enum LR_RESULT (*FastPath_hook11)(rtl_fp_napt_entry *fpNaptEntry, uint32 interval)=NULL;
 int (*fast_path_hook)(struct sk_buff **pskb) = NULL;
@@ -96,16 +96,18 @@ EXPORT_SYMBOL(fast_path_hook);
 #endif
 
 #ifdef FAST_PPTP
-	void (*sync_tx_pptp_gre_seqno_hook)(struct sk_buff *skb) = NULL;	
+	void (*sync_tx_pptp_gre_seqno_hook)(struct sk_buff *skb) = NULL;
 #ifdef CONFIG_FAST_PATH_MODULE
 EXPORT_SYMBOL(sync_tx_pptp_gre_seqno_hook);
 #endif
 #endif
 
+int routerTypeFlag = 0;
+
 #if	defined(CONFIG_RTL_HARDWARE_NAT)
 __DRAM_GEN int gHwNatEnabled;
 
-int rtl865x_handle_nat(struct nf_conn *ct, int act, struct sk_buff *skb)
+int32 rtl865x_handle_nat(struct nf_conn *ct, int act, struct sk_buff *skb)
 {
 	struct nf_conn_nat *nat;
 	u_int32_t sip, dip, gip;
@@ -121,13 +123,15 @@ int rtl865x_handle_nat(struct nf_conn *ct, int act, struct sk_buff *skb)
 #if defined(CONFIG_RTL_LAYERED_DRIVER_L4)
 	rtl865x_napt_entry rtl865xNaptEntry;
 	rtl865x_priority rtl865xPrio;
+	#if defined(CONFIG_RTL_HW_QOS_SUPPORT)
 	rtl865x_qos_mark rtl865xQosMark;
+	#endif
 #endif
 
 	if (gHwNatEnabled!=1)
 		return -1;
 
-	proto = (ct->tuplehash[0].tuple.dst.protonum==IPPROTO_TCP)? 1: 0;
+	proto = (ct->tuplehash[0].tuple.dst.protonum==IPPROTO_TCP)?RTL865X_PROTOCOL_TCP:RTL865X_PROTOCOL_UDP;
 
 	if (ct->status & IPS_SRC_NAT)
 	{ /* outbound flow */
@@ -137,7 +141,7 @@ int rtl865x_handle_nat(struct nf_conn *ct, int act, struct sk_buff *skb)
 		sp  	= (proto)? ct->tuplehash[0].tuple.src.u.tcp.port: ct->tuplehash[0].tuple.src.u.udp.port;
 		dp  	= (proto)? ct->tuplehash[0].tuple.dst.u.tcp.port: ct->tuplehash[0].tuple.dst.u.udp.port;
 		gp  	= (proto)? ct->tuplehash[1].tuple.dst.u.tcp.port: ct->tuplehash[1].tuple.dst.u.udp.port;
-	} 
+	}
 	else if (ct->status & IPS_DST_NAT)
 	{ /* inbound flow */
 		sip	= ct->tuplehash[1].tuple.src.u3.ip;
@@ -147,7 +151,7 @@ int rtl865x_handle_nat(struct nf_conn *ct, int act, struct sk_buff *skb)
 		dp  	= (proto)? ct->tuplehash[1].tuple.dst.u.tcp.port: ct->tuplehash[1].tuple.dst.u.udp.port;
 		gp  	= (proto)? ct->tuplehash[0].tuple.dst.u.tcp.port: ct->tuplehash[0].tuple.dst.u.udp.port;
 	}
-	else 
+	else
 		return -1;
 
 	/* do not add hardware NAPT table if protocol is UDP and source IP address is equal to gateway IP address */
@@ -170,13 +174,10 @@ int rtl865x_handle_nat(struct nf_conn *ct, int act, struct sk_buff *skb)
 		rtl865xNaptEntry.extPort=gp;
 		rtl865xNaptEntry.remIp=dip;
 		rtl865xNaptEntry.remPort=dp;
-		
+
 		timeval = rtl865x_naptSync(&rtl865xNaptEntry, 0);
 #endif
-		if (timeval > 0)
-			return 0;
-		else
-			return -1;
+		return timeval;
 	}
 	else if (act == 0) {
 		/* delete */
@@ -189,7 +190,7 @@ int rtl865x_handle_nat(struct nf_conn *ct, int act, struct sk_buff *skb)
 		rtl865xNaptEntry.extPort=gp;
 		rtl865xNaptEntry.remIp=dip;
 		rtl865xNaptEntry.remPort=dp;
-		
+
 		rc = rtl865x_delNaptConnection(&rtl865xNaptEntry);
 #endif
 	}
@@ -265,11 +266,11 @@ int rtl865x_handle_nat(struct nf_conn *ct, int act, struct sk_buff *skb)
 	#ifdef CONFIG_HARDWARE_NAT_DEBUG
 	/*2007-12-19*/
 	DEBUGP("%s:%d:(%s): errno=%d\n %s (%u.%u.%u.%u:%u -> %u.%u.%u.%u:%u) g:(%u.%u.%u.%u:%u)\n",
-			__FUNCTION__,__LINE__,((is_add)?"add_nat": "del_nat"), rc, ((proto)? "tcp": "udp"), 
-			NIPQUAD(sip), sp, NIPQUAD(dip), dp, NIPQUAD(gip), gp);	
+			__FUNCTION__,__LINE__,((is_add)?"add_nat": "del_nat"), rc, ((proto)? "tcp": "udp"),
+			NIPQUAD(sip), sp, NIPQUAD(dip), dp, NIPQUAD(gip), gp);
 	#endif
 
-	return 0;	
+	return 0;
 }
 
 /* return value:
@@ -278,23 +279,24 @@ int rtl865x_handle_nat(struct nf_conn *ct, int act, struct sk_buff *skb)
 */
 int rtl_hwnat_timer_update(struct nf_conn *ct)
 {
-	unsigned long expires, now;
+	unsigned long expires, now, elasped;
 	struct nf_conn_nat *nat;
 
 	if (gHwNatEnabled!=1)
 		return FAILED;
-	
-	nat = nfct_nat(ct);	
+
+	nat = nfct_nat(ct);
 	if (nat==NULL || nat->hw_acc!=1)
 		return FAILED;
-	
+
 	now = jiffies;
 	//read_lock_bh(&nf_conntrack_lock);
 	if (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.protonum == IPPROTO_UDP)	{
-		if(ct->status & IPS_SEEN_REPLY)
+		if(ct->status & IPS_SEEN_REPLY) {
 			expires = nf_ct_udp_timeout_stream;
-		else
-			expires = nf_ct_udp_timeout;	
+		} else {
+			expires = nf_ct_udp_timeout;
+		}
 	} else if (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.protonum == IPPROTO_TCP &&
 		ct->proto.tcp.state < TCP_CONNTRACK_LAST_ACK) {
 		expires = tcp_get_timeouts_by_state(ct->proto.tcp.state);
@@ -303,45 +305,67 @@ int rtl_hwnat_timer_update(struct nf_conn *ct)
 		return FAILED;
 	}
 	//read_unlock_bh(&nf_conntrack_lock);
-	
-	if (!rtl865x_handle_nat(ct, 2, NULL)) {
+
+	elasped = rtl865x_handle_nat(ct, 2, NULL);
+	if (elasped>=0 && (elasped*HZ)<expires) {
 		/* update ct expires time */
-		ct->timeout.expires = now+expires;
-		rtl_check_for_acc(ct, (now+expires));
+		ct->timeout.expires = now+(expires-(elasped*HZ));
+		rtl_check_for_acc(ct, ct->timeout.expires);
 		return SUCCESS;
-	} else
+	} else {
 		return FAILED;
+	}
 
 }
 #endif
 
-
-#if defined(CONFIG_RTL_IPTABLES_FAST_PATH) || defined(CONFIG_RTL_HARDWARE_NAT)
-int smart_count=0;
-unsigned long smart_count_start_timer;
-unsigned int _br0_ip;
-unsigned int _br0_mask;
-static void get_br0_ip_mask(void)
+int get_dev_ip_mask(const char * name, unsigned int *ip, unsigned int *mask)
 {
-	struct in_device *in_dev;	
+	struct in_device *in_dev;
 	struct net_device *landev;
 	struct in_ifaddr *ifap = NULL;
 	
-      	if ((landev = __dev_get_by_name(&init_net, RTL_PS_BR0_DEV_NAME)) != NULL){
+	if((name == NULL) || (ip==NULL) || (mask == NULL)) 
+	{
+		return -1;
+	}
+	
+	if ((landev = __dev_get_by_name(&init_net, name)) != NULL)
+	{
 		in_dev=(struct in_device *)(landev->ip_ptr);
-		if (in_dev != NULL) {
-			for (ifap=in_dev->ifa_list; ifap != NULL; ifap=ifap->ifa_next) {
-				if (strcmp(RTL_PS_BR0_DEV_NAME, ifap->ifa_label) == 0){
-					_br0_ip = ifap->ifa_address;
-					_br0_mask = ifap->ifa_mask;
-					return; 
+		if (in_dev != NULL) 
+		{
+			for (ifap=in_dev->ifa_list; ifap != NULL; ifap=ifap->ifa_next)
+			{
+				if (strcmp(name, ifap->ifa_label) == 0)
+				{
+					*ip = ifap->ifa_address;
+					*mask = ifap->ifa_mask;
+					return 0;
 				}
 			}
-			
+
 		}
-	}	
+	}
+
+	return -1;
 }
 
+
+#if defined(CONFIG_RTL_IPTABLES_FAST_PATH) || defined(CONFIG_RTL_HARDWARE_NAT) || defined(CONFIG_RTL_WLAN_DOS_FILTER)
+unsigned int _br0_ip;
+unsigned int _br0_mask;
+static void get_br0_ip_mask(void)
+{
+
+	get_dev_ip_mask(RTL_PS_BR0_DEV_NAME, &_br0_ip, &_br0_mask);
+}
+#endif
+
+#if defined(CONFIG_RTL_IPTABLES_FAST_PATH) || defined(CONFIG_RTL_HARDWARE_NAT)
+int smart_count=0;
+unsigned long smart_count_start_timer;
+
 /* return value:
 	FAILED:			ct should be delete
 	SUCCESS:		ct should NOT be delete.
@@ -352,10 +376,13 @@ void rtl_delConnCache(struct nf_conn *ct)
 	enum NP_PROTOCOL protocol;
 	rtl_fp_napt_entry rtlFpNaptEntry;
 	#endif
-	#ifdef CONFIG_RTL_HARDWARE_NAT 
+	#ifdef CONFIG_RTL_HARDWARE_NAT
 	struct nf_conn_nat *nat;
 	#endif
-
+#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+	if (ct->removed == 1) // this ct's fastpath entry was already deleted.
+		return;
+#endif
 	if (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.protonum == IPPROTO_TCP) {
 		#if defined(CONFIG_RTL_IPTABLES_FAST_PATH)
 		protocol = NP_TCP;
@@ -377,7 +404,7 @@ void rtl_delConnCache(struct nf_conn *ct)
 	#endif
 
 	#if defined(CONFIG_RTL_IPTABLES_FAST_PATH)
-	if(ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip 
+	if(ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip
 		   == ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip) {
 		   /*case  WAN->LAN(BC->AB) use C|A-B*/
 
@@ -388,16 +415,16 @@ void rtl_delConnCache(struct nf_conn *ct)
 		rtlFpNaptEntry.extPort=ntohs(ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u.all);
 		rtlFpNaptEntry.remIp=ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;
 		rtlFpNaptEntry.remPort=ntohs(ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.all);
-			
+
 		#ifdef CONFIG_FAST_PATH_MODULE
 		if(FastPath_hook4!=NULL)
 		{
-			FastPath_hook4(&rtlFpNaptEntry) ;	
+			FastPath_hook4(&rtlFpNaptEntry) ;
 		}
 		#else
-		rtk_delNaptConnection(&rtlFpNaptEntry) ;		
+		rtk_delNaptConnection(&rtlFpNaptEntry) ;
 		#endif
-	}	else if (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip 
+	}	else if (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip
 			== ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3.ip) {
 		/*case  LAN->WAN(AB->BC) use A|C-B*/
 
@@ -408,7 +435,7 @@ void rtl_delConnCache(struct nf_conn *ct)
 		rtlFpNaptEntry.extPort=ntohs(ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u.all);
 		rtlFpNaptEntry.remIp=ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3.ip;
 		rtlFpNaptEntry.remPort=ntohs(ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u.all);
-		
+
 		#ifdef CONFIG_FAST_PATH_MODULE
 		if(FastPath_hook4!=NULL)
 		{
@@ -419,6 +446,10 @@ void rtl_delConnCache(struct nf_conn *ct)
 		#endif
 	}
 	#endif
+
+#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+	ct->removed = 1; // set this ct has delete fastpath entry
+#endif
 	spin_unlock_bh(&nf_conntrack_lock);
 }
 
@@ -453,7 +484,7 @@ int32 rtl_connCache_timer_update(struct nf_conn *ct)
 	spin_lock_bh(&nf_conntrack_lock);
 	if (time_after_eq(jiffies, ct->timeout.expires)) {
 		#if defined(CONFIG_RTL_IPTABLES_FAST_PATH)
-		if (SUCCESS==rtl_fpTimer_update(ct)) {
+		if (SUCCESS==rtl_fpTimer_update((void*)ct)) {
 			add_timer(&ct->timeout);
 			spin_unlock_bh(&nf_conntrack_lock);
 			return SUCCESS;
@@ -472,14 +503,14 @@ int32 rtl_connCache_timer_update(struct nf_conn *ct)
 	return FAILED;
 }
 
-#if defined(IMPROVE_QOS) 
+#if defined(IMPROVE_QOS)
 /*
  * ### for iperf application test ###
  * the behavior of iperf UDP test is LAN PC (client) will burst UDP from LAN to WAN (by one way),
  * WAN PC (server) will only send one UDP packet (statistics) at the end of test.
  * so the fastpath or hardware NAT will create link at the end of test.
  *
- * the purpose for adding the following code is to create fastpath or hardware NAT link 
+ * the purpose for adding the following code is to create fastpath or hardware NAT link
  * when we only get one packet from LAN to WAN in UDP case.
  */
 static inline int32 rtl_addConnCheck(struct nf_conn *ct, struct iphdr *iph, struct sk_buff *skb)
@@ -495,17 +526,17 @@ static inline int32 rtl_addConnCheck(struct nf_conn *ct, struct iphdr *iph, stru
 	sip = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;
 	dip = ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3.ip;
 	create_conn = FALSE;
-	
-	if (((ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip 
+
+	if (((ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip
 			 == ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3.ip) ||
-			(ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip 
+			(ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip
 			 == ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip))
 	#if defined(UNNUMBER_IP)
 		 && (is_unnumber_ip(dip)==FALSE)
 	#endif
 	) {
 		/* UDP and "LAN to WAN" */
-		/* ignore some cases:  
+		/* ignore some cases:
 		 *	1. sip = br0's ip -----> (ex. sip 192.168.1.254 ==> dip 239.255.255.250)
 		 * 	2. (sip & br0's mask) != (br0's ip & br0's mask) -----> sip is not in br0's subnet
 		 *	3. (dip & br0's mask) =  (br0's ip & br0's mask) -----> dip is in br0's subnet
@@ -513,7 +544,7 @@ static inline int32 rtl_addConnCheck(struct nf_conn *ct, struct iphdr *iph, stru
 		 *	5. sip != gip
 		 */
 		if (iph->protocol == IPPROTO_UDP) {
-			if ((ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip 
+			if ((ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip
 					 == ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3.ip)&&
 				(sip != _br0_ip) &&
 				((sip & _br0_mask) == (_br0_ip & _br0_mask)) &&
@@ -521,7 +552,7 @@ static inline int32 rtl_addConnCheck(struct nf_conn *ct, struct iphdr *iph, stru
 				((dip & 0xf0000000) != 0xe0000000) &&
 				(sip != (ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip))) {
 				create_conn = TRUE;
-			} else if ((ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip 
+			} else if ((ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip
 					 	== ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip)&&
 					 ((sip & _br0_mask) != (_br0_ip & _br0_mask))&&
 					 ((dip & _br0_mask) == (_br0_ip & _br0_mask))&&
@@ -530,19 +561,19 @@ static inline int32 rtl_addConnCheck(struct nf_conn *ct, struct iphdr *iph, stru
 			}
 		} else if (iph->protocol == IPPROTO_TCP) {
 			tcph=(void *) iph + iph->ihl*4;
-			if (!tcph->fin && !tcph->syn && !tcph->rst && tcph->psh==1 && 
-				tcph->ack ==1 &&  
+			if (!tcph->fin && !tcph->syn && !tcph->rst && tcph->psh==1 &&
+				tcph->ack ==1 &&
 				(((ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip==ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3.ip) &&
 				(iph->daddr !=_br0_ip) && ((sip & _br0_mask) == (_br0_ip & _br0_mask)) &&
 				((dip & _br0_mask) != (_br0_ip & _br0_mask)) && (sip != (ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip)))||
 				((ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip==ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip) &&
-				((sip & _br0_mask) != (_br0_ip & _br0_mask)) && 
+				((sip & _br0_mask) != (_br0_ip & _br0_mask)) &&
 				((dip & _br0_mask) == (_br0_ip & _br0_mask))&& (sip == iph->saddr)))) {
 
 				if (smart_count==0) {
 					smart_count_start_timer = jiffies+HZ;
 				}
-				
+
 				if (time_after(jiffies, smart_count_start_timer)) {
 					smart_count_start_timer = jiffies+HZ;
 					smart_count=0;
@@ -559,8 +590,8 @@ static inline int32 rtl_addConnCheck(struct nf_conn *ct, struct iphdr *iph, stru
 		}
 
 #if defined(UNNUMBER_IP)
-		if ((!create_conn) 
-			&& (is_unnumber_ip(sip)==TRUE)) 
+		if ((!create_conn)
+			&& (is_unnumber_ip(sip)==TRUE))
 			){
 				create_conn = TRUE;
 		}
@@ -586,16 +617,16 @@ void rtl_addConnCache(struct nf_conn *ct, struct sk_buff *skb)
 	iph=ip_hdr(skb);
 	if (iph->protocol== IPPROTO_TCP) {
 		assured = ((ct->proto.tcp.state==TCP_CONNTRACK_ESTABLISHED)&&
-					(test_bit(IPS_DST_NAT_DONE_BIT, &ct->status) || 
+					(test_bit(IPS_DST_NAT_DONE_BIT, &ct->status) ||
 					test_bit(IPS_SRC_NAT_DONE_BIT, &ct->status)));
 
 		#if defined(CONFIG_RTL_IPTABLES_FAST_PATH)
 		protocol = NP_TCP;
 		#endif
 	} else if (iph->protocol== IPPROTO_UDP) {
-		assured = (test_bit(IPS_DST_NAT_DONE_BIT, &ct->status) || 
+		assured = (test_bit(IPS_DST_NAT_DONE_BIT, &ct->status) ||
 				test_bit(IPS_SRC_NAT_DONE_BIT, &ct->status));
-		
+
 		#if defined(CONFIG_RTL_IPTABLES_FAST_PATH)
 		protocol = NP_UDP;
 		#endif
@@ -603,23 +634,23 @@ void rtl_addConnCache(struct nf_conn *ct, struct sk_buff *skb)
 		return;
 	}
 
-	
+
 	if (!assured) {
 	        create_conn = rtl_addConnCheck(ct, iph, skb);
 	} else
 		create_conn = 0;
 
 	#if defined(CONFIG_RTL_IPTABLES_FAST_PATH)
-	/*1.add "!(ct->helper)" to fix ftp-cmd type packet 
-	  2.add identify case LAN->WAN(AB->BC) or WAN->LAN(BC->AB) 
+	/*1.add "!(ct->helper)" to fix ftp-cmd type packet
+	  2.add identify case LAN->WAN(AB->BC) or WAN->LAN(BC->AB)
 	  3.add !(ct->nat.info.helper) for best ALG avoid
 	  */
 	if (assured || create_conn) {
-		if(ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip 
+		if(ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip
 			== ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip) {
 			/*case BC->AB*/
 			/* wan->lan */
-			
+
 			rtlFpNaptEntry.protocol=protocol;
 			rtlFpNaptEntry.intIp=ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3.ip;
 			rtlFpNaptEntry.intPort=ntohs(ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u.all);
@@ -627,20 +658,20 @@ void rtl_addConnCache(struct nf_conn *ct, struct sk_buff *skb)
 			rtlFpNaptEntry.extPort=ntohs(ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u.all);
 			rtlFpNaptEntry.remIp=ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;
 			rtlFpNaptEntry.remPort=ntohs(ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.all);
-			
+
 			#ifdef CONFIG_FAST_PATH_MODULE
 			if(FastPath_hook6!=NULL)
 			{
 				FastPath_hook6(&rtlFpNaptEntry,
-					skb, ct, 
-					NP_NONE);					
+					skb, ct,
+					NP_NONE);
 			}
 			#else
 			rtk_addNaptConnection(&rtlFpNaptEntry,
-				skb, ct, 
-				NP_NONE);		
+				(void *)skb, (void*)ct,
+				NP_NONE);
 			#endif
-		} else if (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip 
+		} else if (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip
 			== ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3.ip) {
 			/*case AB->BC*/
 			/* lan->wan */
@@ -652,17 +683,17 @@ void rtl_addConnCache(struct nf_conn *ct, struct sk_buff *skb)
 			rtlFpNaptEntry.extPort=ntohs(ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u.all);
 			rtlFpNaptEntry.remIp=ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3.ip;
 			rtlFpNaptEntry.remPort=ntohs(ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u.all);
-			
+
 			#ifdef CONFIG_FAST_PATH_MODULE
 			if(FastPath_hook6!=NULL)
 			{
 				FastPath_hook6(&rtlFpNaptEntry,
-					skb, ct, 
+					skb, ct,
 					NP_NONE);
 			}
 			#else
 			rtk_addNaptConnection(&rtlFpNaptEntry,
-				skb, ct, 
+				skb, ct,
 				NP_NONE);
 			#endif
 		}
@@ -679,14 +710,18 @@ void rtl_addConnCache(struct nf_conn *ct, struct sk_buff *skb)
 	}
 	#endif
 }
-#else	/* !defined(IMPROVE_QOS)  */
+
+#endif  /* defined(IMPROVE_QOS)  */
+
+#if defined(CONFIG_RTL_IPTABLES_FAST_PATH)
+#if !defined(IMPROVE_QOS) ||defined(CONFIG_RTL_ROUTER_FAST_PATH)
 /*
  * ### for iperf application test ###
  * the behavior of iperf UDP test is LAN PC (client) will burst UDP from LAN to WAN (by one way),
  * WAN PC (server) will only send one UDP packet (statistics) at the end of test.
  * so the fastpath or hardware NAT will create link at the end of test.
  *
- * the purpose for adding the following code is to create fastpath or hardware NAT link 
+ * the purpose for adding the following code is to create fastpath or hardware NAT link
  * when we only get one packet from LAN to WAN in UDP case.
  */
 static int32 rtl_fpAddConnCheck(struct nf_conn *ct, struct iphdr *iph, struct sk_buff *skb)
@@ -700,8 +735,8 @@ static int32 rtl_fpAddConnCheck(struct nf_conn *ct, struct iphdr *iph, struct sk
 	sip = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;
 	dip = ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3.ip;
 	create_conn = FALSE;
-	
-	if ((ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip 
+
+	if ((ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip
 		 == ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3.ip)
 	#if defined(UNNUMBER_IP)
 		 && (is_unnumber_ip(dip)==FALSE)
@@ -710,10 +745,12 @@ static int32 rtl_fpAddConnCheck(struct nf_conn *ct, struct iphdr *iph, struct sk
 		/* lan -> wan */
 		if (iph->protocol == IPPROTO_UDP &&
 			(sip != _br0_ip) &&
-			((sip & _br0_mask) == (_br0_ip & _br0_mask)) &&
-			((dip & _br0_mask) != (_br0_ip & _br0_mask)) &&
+			((((sip & _br0_mask) == (_br0_ip & _br0_mask)) &&
+			((dip & _br0_mask) != (_br0_ip & _br0_mask))) ||
+			(((sip & _br0_mask) != (_br0_ip & _br0_mask))&&
+			((dip & _br0_mask) == (_br0_ip & _br0_mask))))&&
 			(!IS_CLASSD_ADDR(dip)) &&
-			(sip != (ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip))
+			((routerTypeFlag == 1) ||(sip != (ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip)))
 			) {
 			create_conn = TRUE;
 			/* copied from last 2 line of this function **/
@@ -724,14 +761,18 @@ static int32 rtl_fpAddConnCheck(struct nf_conn *ct, struct iphdr *iph, struct sk
 			set_bit(IPS_ASSURED_BIT, &ct->status);
 		} else if (iph->protocol == IPPROTO_TCP) {
 			tcph=(void *) iph + iph->ihl*4;
-			if (!tcph->fin && !tcph->syn && !tcph->rst && tcph->psh==1 && 
-				tcph->ack ==TRUE &&  (iph->daddr !=_br0_ip) && ((sip & _br0_mask) == (_br0_ip & _br0_mask)) &&
-				((dip & _br0_mask) != (_br0_ip & _br0_mask)) && (sip != (ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip))) { 
-
+			if (!tcph->fin && !tcph->syn && !tcph->rst && tcph->psh==1 &&
+				tcph->ack ==TRUE &&  (iph->daddr !=_br0_ip) &&
+				((((sip & _br0_mask) == (_br0_ip & _br0_mask)) &&
+				((dip & _br0_mask) != (_br0_ip & _br0_mask))) ||
+				(((sip & _br0_mask) != (_br0_ip & _br0_mask))&&
+				((dip & _br0_mask) == (_br0_ip & _br0_mask))))&&
+				((routerTypeFlag == 1) || (sip != (ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip)))
+				) {
 				if (smart_count==0) {
 					smart_count_start_timer = jiffies+HZ;
 				}
-				
+
 				if (time_after(jiffies, smart_count_start_timer)) {
 					smart_count_start_timer = jiffies+HZ;
 					smart_count=0;
@@ -748,8 +789,8 @@ static int32 rtl_fpAddConnCheck(struct nf_conn *ct, struct iphdr *iph, struct sk
 		}
 
 #if defined(UNNUMBER_IP)
-		if ((!create_conn) 
-			&& (is_unnumber_ip(sip)==TRUE)) 
+		if ((!create_conn)
+			&& (is_unnumber_ip(sip)==TRUE))
 			){
 				create_conn = TRUE;
 		}
@@ -769,13 +810,13 @@ void rtl_fpAddConnCache(struct nf_conn *ct, struct sk_buff *skb)
 
 	if (nfct_help(ct))
 		return;
-	
+
 	iph=ip_hdr(skb);
 	create_conn = rtl_fpAddConnCheck(ct, iph, skb);
 	assured = test_bit(IPS_ASSURED_BIT, &ct->status);
-	
-	/*1.add "!(ct->helper)" to fix ftp-cmd type packet 
-	  2.add identify case LAN->WAN(AB->BC) or WAN->LAN(BC->AB) 
+
+	/*1.add "!(ct->helper)" to fix ftp-cmd type packet
+	  2.add identify case LAN->WAN(AB->BC) or WAN->LAN(BC->AB)
 	  3.add !(ct->nat.info.helper) for best ALG avoid
 	  */
 
@@ -787,8 +828,13 @@ void rtl_fpAddConnCache(struct nf_conn *ct, struct sk_buff *skb)
 			protocol = NP_UDP;
 		}
 
-		if(ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip 
-			== ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip) {
+
+#if !defined(IMPROVE_QOS)
+	if(((!rtl_isRouterType(ct)) && rtl_isNatTypeWantoLan(ct)) ||rtl_isRouterTypeWantoLan(ct))
+#else
+	if(rtl_isRouterTypeWantoLan(ct))
+#endif
+		{
 			/*case BC->AB*/
 			/* wan->lan */
 
@@ -799,19 +845,30 @@ void rtl_fpAddConnCache(struct nf_conn *ct, struct sk_buff *skb)
 			rtlFpNaptEntry.extPort=ntohs(ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u.all);
 			rtlFpNaptEntry.remIp=ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;
 			rtlFpNaptEntry.remPort=ntohs(ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.all);
-			
+
 			#ifdef CONFIG_FAST_PATH_MODULE
 			if(FastPath_hook6!=NULL)
 			{
 				FastPath_hook6(&rtlFpNaptEntry,
-					NP_NONE);					
+				#if defined(IMPROVE_QOS)
+				skb, ct,
+				#endif
+					NP_NONE);
 			}
 			#else
 			rtk_addNaptConnection(&rtlFpNaptEntry,
-				NP_NONE);		
+							#if defined(IMPROVE_QOS)
+							(void*)skb, (void*)ct,
+							#endif
+							NP_NONE);
 			#endif
-		} else if (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip 
-			== ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3.ip) {
+		}
+#if !defined(IMPROVE_QOS)
+	else if(((!rtl_isRouterType(ct)) && rtl_isNatTypeLantoWan(ct)) ||rtl_isRouterTypeLantoWan(ct))
+#else
+	else if(rtl_isRouterTypeLantoWan(ct))
+#endif
+		{
 			/*case AB->BC*/
 			/* lan->wan */
 
@@ -822,15 +879,21 @@ void rtl_fpAddConnCache(struct nf_conn *ct, struct sk_buff *skb)
 			rtlFpNaptEntry.extPort=ntohs(ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u.all);
 			rtlFpNaptEntry.remIp=ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3.ip;
 			rtlFpNaptEntry.remPort=ntohs(ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u.all);
-			
+
 			#ifdef CONFIG_FAST_PATH_MODULE
 			if(FastPath_hook6!=NULL)
 			{
 				FastPath_hook6(&rtlFpNaptEntry,
+					#if defined(IMPROVE_QOS)
+					skb, ct,
+					#endif
 					NP_NONE);
 			}
 			#else
 			rtk_addNaptConnection(&rtlFpNaptEntry,
+				#if defined(IMPROVE_QOS)
+				skb, ct,
+				#endif
 				NP_NONE);
 			#endif
 		}
@@ -838,10 +901,11 @@ void rtl_fpAddConnCache(struct nf_conn *ct, struct sk_buff *skb)
 
 }
 #endif	/* defined(IMPROVE_QOS)  */
-
+#endif
 #endif
 
-#if defined(CONFIG_PROC_FS) && defined(CONFIG_RTL_HARDWARE_NAT )
+
+#if defined(CONFIG_PROC_FS) && defined(CONFIG_RTL_HARDWARE_NAT)
 static struct proc_dir_entry *proc_hw_nat=NULL;
 static char gHwNatSetting[16];
 //extern unsigned int ldst, lmask, wdst, wmask;
@@ -864,18 +928,24 @@ static int hw_nat_read_proc(char *page, char **start, off_t off,
 static int hw_nat_write_proc(struct file *file, const char *buffer,
 		      unsigned long count, void *data)
 {
-	if (count < 2) 
+	if (count < 2)
 		return -EFAULT;
 
 	if (buffer && !copy_from_user(&gHwNatSetting, buffer, 8)) {
-		if (gHwNatSetting[0] == '0') { /* hardware NAT disabled, operation mode = gateway */
+		if ((gHwNatSetting[0] == '-')&&(gHwNatSetting[1] == '1') ) { /* hardware NAT disabled, operation mode = gateway */
 			gHwNatEnabled = 0;
-			rtl865x_nat_reinit();			
+			rtl865x_nat_reinit();
+			rtl865x_changeOpMode(GATEWAY_MODE);
+			//rtl8651_setAsicOperationLayer(4);
+		}
+		else if (gHwNatSetting[0] == '0') { /* hardware NAT disabled, operation mode = gateway */
+			gHwNatEnabled = 0;
+			rtl865x_nat_reinit();
 			rtl865x_reChangeOpMode();
 			//rtl8651_setAsicOperationLayer(4);
 		}
 		else if (gHwNatSetting[0] == '1') { /* hardware NAT enabled, operation mode = gateway */
-			
+
 			rtl865x_changeOpMode(GATEWAY_MODE);
 			//rtl8651_setAsicOperationLayer(4);
 			gHwNatEnabled = 1;
@@ -902,7 +972,15 @@ static int hw_nat_write_proc(struct file *file, const char *buffer,
 		else if (gHwNatSetting[0] == '9') {
 			get_br0_ip_mask();
 		}
+		else if(gHwNatSetting[0] == '7'){
+			routerTypeFlag = 1;
+		}
 		#endif
+	
+		if((count>0)&& (count<sizeof(gHwNatSetting)))
+		{
+			gHwNatSetting[count]=0;
+		}
 		return count;
 	}
 	return -EFAULT;
@@ -931,9 +1009,9 @@ static int sw_nat_read_proc(char *page, char **start, off_t off,
 static int sw_nat_write_proc(struct file *file, const char *buffer,
 		      unsigned long count, void *data)
 {
-	if (count < 2) 
+	if (count < 2)
 		return -EFAULT;
-      
+
 	if (buffer && !copy_from_user(&gSwNatSetting, buffer, 8)) {
 		if (gSwNatSetting[0] == '0'){  /* operation mode = GATEWAY */
 			//SoftNAT_OP_Mode(2);
@@ -949,11 +1027,26 @@ static int sw_nat_write_proc(struct file *file, const char *buffer,
 			rtl865x_changeOpMode(WISP_MODE);
 			//rtl8651_setAsicOperationLayer(2);
 		}
-#if defined(CONFIG_RTL_HARDWARE_NAT) || defined(CONFIG_RTL_IPTABLES_FAST_PATH)
+#if defined(CONFIG_RTL_HARDWARE_NAT) || defined(CONFIG_RTL_IPTABLES_FAST_PATH) || defined(CONFIG_RTL_WLAN_DOS_FILTER)
 		else if(gSwNatSetting[0] == '9'){
 			get_br0_ip_mask();
 		}
+		else if(gSwNatSetting[0] == '7'){
+			routerTypeFlag = 1;
+		}
+#endif
+
+#ifdef CONFIG_RTL_WLAN_DOS_FILTER
+		else if(gSwNatSetting[0] == 'a') {
+			extern int wlan_dos_filter_enabled;
+			wlan_dos_filter_enabled = 0;
+		}
+		else if(gSwNatSetting[0] == 'b') {
+			extern int wlan_dos_filter_enabled;
+			wlan_dos_filter_enabled = 1;
+		}
 #endif
+
 		return count;
 	}
 	return -EFAULT;
@@ -968,9 +1061,8 @@ int32 rtl_nat_init(void)
 	if (proc_hw_nat) {
 		proc_hw_nat->read_proc = hw_nat_read_proc;
 		proc_hw_nat->write_proc = hw_nat_write_proc;
-	}  
+	}
 	#endif
-
 	#if defined(CONFIG_PROC_FS) && !defined(CONFIG_RTL_HARDWARE_NAT)
 	proc_sw_nat = create_proc_entry("sw_nat", 0, NULL);
 	if (proc_sw_nat) {
@@ -992,7 +1084,7 @@ extern int rtl865x_curOpMode;
 struct net_device *rtl865x_getWanDev(void )
 {
 	struct net_device * wanDev=NULL;
-	
+
 	if(rtl865x_curOpMode==GATEWAY_MODE)
 	{
 #if defined(CONFIG_RTL_PUBLIC_SSID)
@@ -1005,7 +1097,7 @@ struct net_device *rtl865x_getWanDev(void )
 			//Try eth1 then
 			wanDev=dev_get_by_name(&init_net,RTL_PS_WAN0_DEV_NAME);
 		}
-#endif		
+#endif
 	}
 	else if(rtl865x_curOpMode==WISP_MODE)
 	{
@@ -1021,9 +1113,9 @@ struct net_device *rtl865x_getWanDev(void )
 		wanDev=dev_get_by_name(&init_net,RTL_BR_WAN_DEVICE_NAME);
 #else
 		wanDev=dev_get_by_name(&init_net,RTL_PS_BR0_DEV_NAME);
-#endif		
+#endif
 	}
-	
+
 	return wanDev;
 }
 
@@ -1043,7 +1135,7 @@ int rtl865x_attainDevType(unsigned char *devName, unsigned int *isLanDev, unsign
 	if(rtl865x_curOpMode==GATEWAY_MODE)
 	{
 #if defined(CONFIG_RTL_PUBLIC_SSID)
-		if(strncmp(devName, RTL_PS_WAN0_DEV_NAME, 4) ==0 || strncmp(devName, RTL_GW_WAN_DEVICE_NAME, 3) ==0 || 
+		if(strncmp(devName, RTL_PS_WAN0_DEV_NAME, 4) ==0 || strncmp(devName, RTL_GW_WAN_DEVICE_NAME, 3) ==0 ||
 			rtl865x_from_public_ssid_device(devName)
 			)
 #else
@@ -1052,8 +1144,8 @@ int rtl865x_attainDevType(unsigned char *devName, unsigned int *isLanDev, unsign
 		{
 			*isWanDev=1;
 		}
-		else if(	(strncmp(devName, RTL_PS_BR0_DEV_NAME, 3) ==0)||	
-				(strncmp(devName, RTL_PS_ETH_NAME, 3) ==0) || 	
+		else if(	(strncmp(devName, RTL_PS_BR0_DEV_NAME, 3) ==0)||
+				(strncmp(devName, RTL_PS_ETH_NAME, 3) ==0) ||
 				(strncmp(devName, RTL_PS_WLAN_NAME, 4) ==0))
 		{
 			*isLanDev=1;
@@ -1062,7 +1154,7 @@ int rtl865x_attainDevType(unsigned char *devName, unsigned int *isLanDev, unsign
 		{
 			return -1;
 		}
-		
+
 	}
 	else if(rtl865x_curOpMode==WISP_MODE)
 	{
@@ -1097,7 +1189,7 @@ int rtl865x_attainDevType(unsigned char *devName, unsigned int *isLanDev, unsign
 	{
 		return -1;
 	}
-	
+
 	return 0;
 }
 #endif
@@ -1107,12 +1199,12 @@ int rtl865x_localPublicRx(struct sk_buff *skb)
 {
 	struct rtl865x_pktInfo pktInfo;
 	unsigned int rxFromLan, rxFromWan;
-	
+
 	if(rtl865x_localPublicEnabled() ==0)
 	{
 		goto end_of_local_public_rx;
 	}
-	
+
 	if(rtl865x_attainDevType(skb->dev->name, &rxFromLan, &rxFromWan))
 	{
 		return NET_RX_SUCCESS;
@@ -1126,10 +1218,10 @@ int rtl865x_localPublicRx(struct sk_buff *skb)
 	#if 0
 	printk("%s:%d,skb->dev->name is %s,rxFromLan is %d,rxFromWan is %d\n",__FUNCTION__,__LINE__,skb->dev->name,rxFromLan,rxFromWan);
 	printk("EtherType: 0x%x\n", *((uint16*)&skb->mac.raw[12]));
-	printk("%x:%x:%x:%x:%x:%x ==> %x:%x:%x:%x:%x:%x \n\n", 
+	printk("%x:%x:%x:%x:%x:%x ==> %x:%x:%x:%x:%x:%x \n\n",
 	skb->mac.raw[6], skb->mac.raw[7], skb->mac.raw[8],
-	skb->mac.raw[9], skb->mac.raw[10], skb->mac.raw[11], 
-	skb->mac.raw[0], skb->mac.raw[1], skb->mac.raw[2], 
+	skb->mac.raw[9], skb->mac.raw[10], skb->mac.raw[11],
+	skb->mac.raw[0], skb->mac.raw[1], skb->mac.raw[2],
 	skb->mac.raw[3], skb->mac.raw[4], skb->mac.raw[5]);
 	#endif
 	if(rxFromWan)
@@ -1140,7 +1232,7 @@ int rtl865x_localPublicRx(struct sk_buff *skb)
 		pktInfo.data=skb_mac_header(skb);
 		pktInfo.action=RX_WAN_PACKET;
 		rtl865x_checkLocalPublic(&pktInfo);
-	
+
 		if(pktInfo.fromLocalPublic==1)
 		{
 			kfree_skb(skb);
@@ -1148,12 +1240,12 @@ int rtl865x_localPublicRx(struct sk_buff *skb)
 		}
 		else if(pktInfo.toLocalPublic==1)
 		{
-	
+
 			skb->pkt_type=PACKET_HOST;
 			//printk("%s:%d,pktInfo.fromLocalPublic is %d,pktInfo.toLocalPublic is %d\n",__FUNCTION__,__LINE__,pktInfo.fromLocalPublic,pktInfo.toLocalPublic );
 			memcpy(eth_hdr(skb)->h_dest, skb->dev->dev_addr, 6);
 		 }
-		
+
 	}
 	else if (rxFromLan)
 	{
@@ -1169,7 +1261,7 @@ int rtl865x_localPublicRx(struct sk_buff *skb)
 			skb->fromLocalPublic=1;
 			skb->srcLocalPublicIp=pktInfo.srcIp;
 			//if(pktInfo.toLocalPublic==1)
-			{			
+			{
 				skb->pkt_type=PACKET_HOST;
 				memcpy(eth_hdr(skb)->h_dest, skb->dev->dev_addr, 6);
 				#if 0
@@ -1179,13 +1271,13 @@ int rtl865x_localPublicRx(struct sk_buff *skb)
 					dest[0],dest[1],dest[2],dest[3],dest[4],dest[5],
 					src[0],src[1],src[2],src[3],src[4],src[5]);
 				#endif
-				
+
 			}
 		}
-		
+
 	}
 	skb->localPublicFlags = 0x1;
-	
+
 end_of_local_public_rx:
 	return NET_RX_SUCCESS;
 }
@@ -1197,14 +1289,14 @@ int rtl865x_localPublicTx(struct sk_buff *skb, struct net_device *dev)
 	{
 		return NET_RX_SUCCESS;
 	}
-	
+
 	if(txToWan)
-	{	
+	{
 		if((skb->fromLocalPublic==1) && (skb->srcLocalPublicIp!=0))
 		{
 			rtl865x_getLocalPublicMac(skb->srcLocalPublicIp, eth_hdr(skb)->h_source);
 		}
-			
+
 	}
 	else if (txToLan)
 	{
@@ -1218,31 +1310,31 @@ int rtl865x_localPublicTx(struct sk_buff *skb, struct net_device *dev)
 
 int rtl865x_getDevIpAndNetmask(struct net_device * dev, unsigned int *ipAddr, unsigned int *netMask )
 {
-	struct in_device *in_dev;	
+	struct in_device *in_dev;
 	struct in_ifaddr *ifap = NULL;
 
 	if((dev==NULL) || (ipAddr==NULL) || (netMask==NULL))
 	{
 		return FAILED;
 	}
-	
+
 	*ipAddr=0;
 	*netMask=0;
-   
-	in_dev=(struct net_device *)(dev->ip_ptr);
+
+	in_dev=(struct in_device *)(dev->ip_ptr);
 	if (in_dev != NULL) {
 		for (ifap=in_dev->ifa_list; ifap != NULL; ifap=ifap->ifa_next) {
 			if (strcmp(dev->name, ifap->ifa_label) == 0){
 				*ipAddr = ifap->ifa_address;
 				*netMask = ifap->ifa_mask;
-				return SUCCESS; 
+				return SUCCESS;
 			}
 		}
-		
+
 	}
-	
+
 	return FAILED;
-		
+
 }
 
 
@@ -1286,7 +1378,7 @@ static int qos_read_proc(char *page, char **start, off_t off,
 static int qos_write_proc(struct file *file, const char *buffer,
 		      unsigned long count, void *data)
 {
-      if ( gQosSetting==NULL || count < 2) 
+      if ( gQosSetting==NULL || count < 2)
 	    return -EFAULT;
 
       if (buffer && !copy_from_user(gQosSetting, buffer, count)) {
@@ -1322,10 +1414,10 @@ int32 rtl_qos_init(void)
 		proc_qos->write_proc = qos_write_proc;
 	}
 	#endif
-	gQosSetting = kmalloc(RTL_QOS_PROC_MAX_LEN, GFP_KERNEL);
+	gQosSetting = kmalloc(RTL_QOS_PROC_MAX_LEN, GFP_ATOMIC);
 	memset(gQosSetting, 0, RTL_QOS_PROC_MAX_LEN);
 	gQosEnabled = 0;
-	
+
 	return SUCCESS;
 }
 
@@ -1340,11 +1432,11 @@ int32 rtl_qos_cleanup(void)
 
 #if defined(CONFIG_RTL_FAST_BRIDGE)
 int32 rtl_fb_add_br_entry(skb)
-{	
+{
 	struct net_bridge_fdb_entry *dst;
 	const unsigned char *dest = eth_hdr(skb)->h_dest;
 	if (!is_multicast_ether_addr(dest))
-	{					
+	{
 		dst = __br_fdb_get(skb->dev->br_port->br, dest);
 		if(dst != NULL && dst->dst->dev == skb->dev)
 		{
@@ -1413,7 +1505,7 @@ rtl_resolve_normal_ct(struct net *net,
 
 	/* look for tuple match */
 	h = nf_conntrack_find_get(net, &tuple);
-	
+
 	if (!h) {
 		//h = init_conntrack(net, &tuple, l3proto, l4proto, skb, dataoff);
 		//if (!h)
@@ -1487,7 +1579,7 @@ rtl_nf_conntrack_in(struct net *net, unsigned int dataoff, unsigned int hooknum,
 	}
 
 	NF_CT_ASSERT(skb->nfct);
-	
+
 
 	th = skb_header_pointer(skb, dataoff, sizeof(_tcph), &_tcph);
 	BUG_ON(th == NULL);
@@ -1536,7 +1628,7 @@ int get_hookNum(struct ipt_entry *e, unsigned char *base, const unsigned int val
 #ifdef CONFIG_RTL_LAYERED_DRIVER_L3
 	u32 arp_ip = htonl(*((u32 *)n->primary_key));
 	int rc;
-	
+
 	rc = add? rtl865x_addArp(arp_ip, (void *)n->ha): rtl865x_delArp(arp_ip);
 #endif
 	return 0;
@@ -1572,16 +1664,16 @@ rtl_masq_if rtl_masq_info[RTL_MULTIPLE_WAN_NUM];
 
 rtl_masq_if *rtl_get_masq_info_by_devName(const char* name)
 {
-	int i;	
+	int i;
 	if(name == NULL)
 		return NULL;
-	
+
 	for(i = 0; i < RTL_MULTIPLE_WAN_NUM;i++)
 	{
 		if(rtl_masq_info[i].valid == 1 &&strcmp(rtl_masq_info[i].ifName,name) == 0)
 			return &rtl_masq_info[i];
 	}
-	
+
 	return NULL;
 }
 
@@ -1590,7 +1682,7 @@ int rtl_add_masq_info(const char *name,int ipAddr)
 	int i;
 	if(strlen(name) >=IFNAMSIZ || ipAddr ==0)
 		return FAILED;
-	
+
 	for(i = 0; i < RTL_MULTIPLE_WAN_NUM;i++)
 	{
 		if(rtl_masq_info[i].valid == 0)
@@ -1604,7 +1696,7 @@ int rtl_add_masq_info(const char *name,int ipAddr)
 	rtl_masq_info[i].ipAddr = ipAddr;
 	memcpy(rtl_masq_info[i].ifName,name,strlen(name));
 	rtl_masq_info[i].ifName[strlen(name)] ='\0';
-	return SUCCESS;	
+	return SUCCESS;
 }
 
 int rtl_init_masq_info(void)
@@ -1614,7 +1706,7 @@ int rtl_init_masq_info(void)
 	{
 		memset(&rtl_masq_info[i],0,sizeof(rtl_masq_if));
 	}
-	
+
 	return SUCCESS;
 }
 
@@ -1643,26 +1735,26 @@ static int rtl_get_masquerade_netif(struct xt_table_info *private,struct ipt_ent
 	struct ipt_entry_target *t;
 	struct net_device *dev;
 	char masq_name[IFNAMSIZ]={'\0'};
-	
+
 	if(masq_entry && masq_entry->ip.outiface[0] !='\0')
-	{			
+	{
 		memcpy(masq_name, masq_entry->ip.outiface, IFNAMSIZ);
 		//return 0;
 	}
-	else	
+	else
 	{
 		table_base = private->entries[smp_processor_id()];
-		e = get_entry(table_base, private->hook_entry[NF_INET_POST_ROUTING]);		
-		back = get_entry(table_base, private->underflow[NF_INET_POST_ROUTING]);		
-		
+		e = get_entry(table_base, private->hook_entry[NF_INET_POST_ROUTING]);
+		back = get_entry(table_base, private->underflow[NF_INET_POST_ROUTING]);
+
 		//clear masq_name;
-		memset(masq_name,0,IFNAMSIZ);		
+		memset(masq_name,0,IFNAMSIZ);
 		while(e)
 		{
-		
+
 			if(e == masq_entry)
 				break;
-			
+
 			//record the entry's outif name
 			if(e->ip.outiface[0] !='\0')
 				memcpy(masq_name,e->ip.outiface,IFNAMSIZ);
@@ -1678,26 +1770,26 @@ static int rtl_get_masquerade_netif(struct xt_table_info *private,struct ipt_ent
 				memset(masq_name,0,IFNAMSIZ);
 				break;
 			}
-			
+
 			/* Standard target? */
-			if (!t->u.kernel.target->target) 
+			if (!t->u.kernel.target->target)
 			{
 				int v;
-				v = ((struct ipt_standard_target *)t)->verdict;				
-				
+				v = ((struct ipt_standard_target *)t)->verdict;
+
 				if (v < 0 )
 				{
 					if(v == IPT_RETURN)
 					{
 						e = back;
-						back = get_entry(table_base, back->comefrom);						
+						back = get_entry(table_base, back->comefrom);
 					}
 					else
 					{
 						e = (void *)e + e->next_offset;
 					}
 
-					continue;				
+					continue;
 				}
 
 				//jump ?
@@ -1713,34 +1805,34 @@ static int rtl_get_masquerade_netif(struct xt_table_info *private,struct ipt_ent
 				}
 				e = get_entry(table_base, v);
 				continue;
-			} 
-			
+			}
+
 			/*user define target?*/
 			e = (void *)e + e->next_offset;
-		}		
-		
+		}
+
 	}
 
 	if(masq_name[0] !='\0')
 	{
 		struct in_ifaddr *ina;
 		dev = __dev_get_by_name(&init_net,masq_name);
-		if ((dev)&&(dev->ip_ptr)) 
-		{ 		
-				
+		if ((dev)&&(dev->ip_ptr))
+		{
+
 			ina=(struct in_ifaddr *)(((struct in_device *)(dev->ip_ptr))->ifa_list);
-			if (ina!=NULL) 
+			if (ina!=NULL)
 			{
 				rtl_add_masq_info(masq_name,ina->ifa_local);
 			}
 		}
 	}
-		
+
 
 	return 0;
 }
 
-static int rtl_check_for_masquerade_entry(struct ipt_entry *e,  
+static int rtl_check_for_masquerade_entry(struct ipt_entry *e,
 	unsigned char *base,
 	const char *name,
 	unsigned int size,
@@ -1751,20 +1843,20 @@ static int rtl_check_for_masquerade_entry(struct ipt_entry *e,
 	struct ipt_entry_target *t;
 	unsigned int hook;
 	int ret = 0;
-	
-	t = ipt_get_target(e);	
-	if ( !t) 
-	{		
+
+	t = ipt_get_target(e);
+	if ( !t)
+	{
 		goto err;
 	}
 
-	hook = get_hookNum(e,base,valid_hooks,hook_entries);		
+	hook = get_hookNum(e,base,valid_hooks,hook_entries);
 	if ((hook == NF_INET_POST_ROUTING) &&
-		((strcmp(t->u.kernel.target->name, "MASQUERADE") == 0))) 
-		{			
-			rtl_get_masquerade_netif(private,e);	
+		((strcmp(t->u.kernel.target->name, "MASQUERADE") == 0)))
+		{
+			rtl_get_masquerade_netif(private,e);
 		}
- err:	
+ err:
 	return ret;
 }
 
@@ -1788,7 +1880,7 @@ int rtl_check_for_extern_ip(const char *name,
 			rtl865x_addIp(0,rtl_masq_info[i].ipAddr,IP_TYPE_NAPT);
 		}
 	}
-	
+
 	return 0;
 }
 
@@ -1803,33 +1895,33 @@ int rtl_check_for_extern_ip(const char *name,
 			rtl865x_delIp(rtl_masq_info[i].ipAddr);
 		}
 	}
-	
+
 	return SUCCESS;
 }
 
 int32 rtl_update_ip_tables(char *name,  unsigned long event, struct in_ifaddr *ina)
 {
 	rtl_masq_if *entry;
-	
+
 	/*2007-12-19*/
 	#ifdef CONFIG_HARDWARE_NAT_DEBUG
 		/*2007-12-19*/
 		printk("%s:%d\n",__FUNCTION__,__LINE__);
-	#endif	
+	#endif
 	if (ina==NULL)
 		return SUCCESS;
-	
+
 	entry = rtl_get_masq_info_by_devName(name);
 	if (entry!=NULL)
 	{
-		if (event == NETDEV_UP ) 
+		if (event == NETDEV_UP )
 		{
 			rtl865x_addIp(0,(u32)(ina->ifa_local),IP_TYPE_NAPT);
 			//update the ip address
 			entry->ipAddr = ina->ifa_local;
 		}
-		else if(event == NETDEV_DOWN) 
-		{				
+		else if(event == NETDEV_DOWN)
+		{
 			if(rtl865x_delIp(ina->ifa_local)==SUCCESS)
 			{
 				rtl865x_nat_init();
@@ -1847,7 +1939,7 @@ int32 rtl_fn_insert(struct fib_table *tb, struct fib_config *cfg, struct fib_inf
 	unsigned int srcIp,srcMask;
 	struct net_device *netif;
 	char *dev_t;
-	
+
 	/*2007-12-19*/
 	if ((tb->tb_id == RT_TABLE_MAIN) && (gHwNatEnabled !=0)) {
 		if(cfg->fc_oif) {
@@ -1861,8 +1953,8 @@ int32 rtl_fn_insert(struct fib_table *tb, struct fib_config *cfg, struct fib_inf
 		ipMask = inet_make_mask(cfg->fc_dst_len);
 		ipGw = cfg->fc_gw;
 		rtl865x_getDevIpAndNetmask(netif,&srcIp,&srcMask);
-		if (!ipDst || (!MULTICAST(ipDst) && !LOOPBACK(ipDst) && (ipDst != 0xffffffff))) 
-		{ 
+		if (!ipDst || (!MULTICAST(ipDst) && !LOOPBACK(ipDst) && (ipDst != 0xffffffff)))
+		{
 			#ifdef CONFIG_RTL_LAYERED_DRIVER_L3
 			//printk("-------------------%s(%d)\n",__FUNCTION__,__LINE__);
 			rc = rtl865x_addRoute(ipDst,ipMask,ipGw,dev_t,srcIp);
@@ -1870,7 +1962,7 @@ int32 rtl_fn_insert(struct fib_table *tb, struct fib_config *cfg, struct fib_inf
 			#endif
 	        	#ifdef CONFIG_HARDWARE_NAT_DEBUG
 			/*2007-12-19*/
-			printk("%s:%d:(%s): dst:%u.%u.%u.%u/%u, gw:%u.%u.%u.%u, dev: %s, errno=%d\n", 
+			printk("%s:%d:(%s): dst:%u.%u.%u.%u/%u, gw:%u.%u.%u.%u, dev: %s, errno=%d\n",
 				__FUNCTION__,__LINE__,"add_rt",  NIPQUAD(ipDst), cfg->fc_dst_len, NIPQUAD(ipGw), dev_t? dev_t: "null", rc
 		);
 		#endif
@@ -1885,13 +1977,13 @@ int32 rtl_fn_delete(struct fib_table *tb, struct fib_config *cfg)
 {
 	int rc;
 	unsigned int ipDst, ipMask;
-	
+
 	/*2007-12-19*/
 	if (tb->tb_id == RT_TABLE_MAIN) {
 		ipDst = cfg->fc_dst;
 		ipMask =  inet_make_mask(cfg->fc_dst_len);
-		
-		if (!ipDst || (!MULTICAST(ipDst) && !LOOPBACK(ipDst) && (ipDst != 0xffffffff))) { 
+
+		if (!ipDst || (!MULTICAST(ipDst) && !LOOPBACK(ipDst) && (ipDst != 0xffffffff))) {
 			rc = 0;
 			#ifdef CONFIG_RTL_LAYERED_DRIVER_L3
 			rc = rtl865x_delRoute(ipDst, ipMask);
@@ -1907,11 +1999,11 @@ int32 rtl_fn_flush(int	 fz_order, int idx, u32 tb_id, u32 fn_key)
 	int rc;
 	unsigned int ipDst, ipMask;
 	/*2007-12-19*/
-	if (tb_id==RT_TABLE_MAIN) {			
+	if (tb_id==RT_TABLE_MAIN) {
 		ipDst =fn_key;
 		ipMask = inet_make_mask(fz_order);
 
-		if (!ipDst || (!MULTICAST(ipDst) && !LOOPBACK(ipDst) && (ipDst != 0xffffffff))) { 
+		if (!ipDst || (!MULTICAST(ipDst) && !LOOPBACK(ipDst) && (ipDst != 0xffffffff))) {
 			rc = 0;
 			#ifdef CONFIG_RTL_LAYERED_DRIVER_L3
 			rc = rtl865x_delRoute(ipDst, ipMask);
@@ -1924,12 +2016,21 @@ int32 rtl_fn_flush(int	 fz_order, int idx, u32 tb_id, u32 fn_key)
 
 int32 rtl_ip_vs_conn_expire_check(struct ip_vs_conn *cp)
 {
-	int timeval;
+	int elapsed;
+	u_int32_t expires;
 	rtl865x_napt_entry rtl865xNaptEntry;
 
+	if (cp->protocol==IPPROTO_UDP)	{
+		expires = nf_ct_udp_timeout;
+	} else if (cp->protocol==IPPROTO_TCP) {
+		expires = tcp_get_timeouts_by_state(cp->state);	/* does cp->state right here? */
+	} else {
+		return FAILED;
+	}
+
 /*   chhuang:
 	printk("ip_vs_conn_expire: c:(%u.%u.%u.%u:%d), v:(%u.%u.%u.%u:%d), \n\td:(%u.%u.%u.%u:%d), p:(%x), f: %x, s: %x\n",
-			NIPQUAD(cp->caddr), cp->cport, NIPQUAD(cp->vaddr), cp->vport, NIPQUAD(cp->daddr), cp->dport, 
+			NIPQUAD(cp->caddr), cp->cport, NIPQUAD(cp->vaddr), cp->vport, NIPQUAD(cp->daddr), cp->dport,
 			cp->protocol, cp->flags, cp->state);
 */
 	if (cp->hw_acc) {
@@ -1941,21 +2042,21 @@ int32 rtl_ip_vs_conn_expire_check(struct ip_vs_conn *cp)
 		rtl865xNaptEntry.remIp=cp->caddr.ip;
 		rtl865xNaptEntry.remPort=cp->cport;
 
-		timeval = rtl865x_naptSync(&rtl865xNaptEntry, 0);
-		
-		if (timeval > 0 && (cp->protocol==IPPROTO_UDP))
+		elapsed = rtl865x_naptSync(&rtl865xNaptEntry, 0);
+
+		if (elapsed >= 0 && (cp->protocol==IPPROTO_UDP))
 		{
-			cp->timer.expires = jiffies + (timeval)*HZ;
+			cp->timer.expires = jiffies + (expires-elapsed)*HZ;
 			add_timer(&cp->timer);
 			#ifdef CONFIG_HARDWARE_NAT_DEBUG
 			/*2007-12-19*/
 			printk("%s:%d:(%s): expired time = %d\n %s (%u.%u.%u.%u:%u -> %u.%u.%u.%u:%u) g:(%u.%u.%u.%u:%u)\n",
 					__FUNCTION__,__LINE__,"poll_nat", timeval, (cp->protocol==IPPROTO_TCP)? "tcp": "udp",
-					NIPQUAD(cp->daddr), cp->dport, NIPQUAD(cp->caddr), cp->cport, 
+					NIPQUAD(cp->daddr), cp->dport, NIPQUAD(cp->caddr), cp->cport,
 					NIPQUAD(cp->vaddr), cp->vport
 			);
 			#endif
-		
+
 			return FAILED;
 		}
 	}
@@ -1980,7 +2081,7 @@ int32 rtl_ip_vs_conn_expire_check_delete(struct ip_vs_conn *cp)
 		rtl865xNaptEntry.remPort=cp->cport;
 
 		rc = rtl865x_delNaptConnection(&rtl865xNaptEntry);
-		
+
 		#ifdef CONFIG_HARDWARE_NAT_DEBUG
 		/*2007-12-19*/
 		printk("%s:%d:(%s): errno=%d\n %s (%u.%u.%u.%u:%u -> %u.%u.%u.%u:%u) g:(%u.%u.%u.%u:%u)\n",
@@ -2010,15 +2111,15 @@ int32 rtl_tcp_state_transition_check(struct ip_vs_conn *cp, int direction, const
 	/*2007-12-19*/
 	/*
 	printk("ip_vs_set_state: c:(%u.%u.%u.%u:%d), v:(%u.%u.%u.%u:%d), \n\td:(%u.%u.%u.%u:%d), p:(%x), f: %x, s: %x, master: %s\n\tapp_data: %x, app: %x\n",
-		NIPQUAD(cp->caddr), cp->cport, NIPQUAD(cp->vaddr), cp->vport, NIPQUAD(cp->daddr), cp->dport, cp->protocol, cp->flags, cp->state, 
+		NIPQUAD(cp->caddr), cp->cport, NIPQUAD(cp->vaddr), cp->vport, NIPQUAD(cp->daddr), cp->dport, cp->protocol, cp->flags, cp->state,
 		cp->control? "yes": "no", cp->app_data, cp->app);
 	*/
 	#if 0
 	if (!cp->hw_acc && !cp->app &&
-		cp->state==IP_VS_S_ESTABLISHED) 
+		cp->state==IP_VS_S_ESTABLISHED)
 	#else
 	if (!cp->hw_acc && !cp->app &&
-		cp->state==IP_VS_TCP_S_ESTABLISHED) 
+		cp->state==IP_VS_TCP_S_ESTABLISHED)
 	#endif
 	{
 		int rc;
@@ -2038,7 +2139,7 @@ int32 rtl_tcp_state_transition_check(struct ip_vs_conn *cp, int direction, const
 			rtl865xQosMark.downlinkMark=0;	//Initial
 			rtl865xQosMark.uplinkMark=0;	//Initial
 			ret=rtl_qosGetSkbMarkByNaptEntry(&rtl865xNaptEntry, &rtl865xQosMark, skb);
-		
+
 			lanDev=rtl865x_getLanDev();
 			wanDev=rtl865x_getWanDev();
 			rtl865xPrio.downlinkPrio=rtl_qosGetPriorityByMark(lanDev->name, rtl865xQosMark.downlinkMark);
@@ -2055,7 +2156,7 @@ int32 rtl_tcp_state_transition_check(struct ip_vs_conn *cp, int direction, const
 			rtl865xPrio.downlinkPrio=0;
 			rtl865xPrio.uplinkPrio=0;
 		}
-		
+
 		#if defined(CONFIG_RTL_LAYERED_DRIVER_L4)
 		rtl865xNaptEntry.protocol=RTL865X_PROTOCOL_TCP;
 		rtl865xNaptEntry.intIp=cp->daddr.ip;
@@ -2091,7 +2192,7 @@ int32 rtl_udp_state_transition_check(struct ip_vs_conn *cp, int direction, const
 	#endif
 
 	/*2007-12-19*/
-	if (!cp->hw_acc && !cp->app) 
+	if (!cp->hw_acc && !cp->app)
 	{
 		int rc;
 		rc = 0;
@@ -2109,7 +2210,7 @@ int32 rtl_udp_state_transition_check(struct ip_vs_conn *cp, int direction, const
 			rtl865xQosMark.downlinkMark=0;	//Initial
 			rtl865xQosMark.uplinkMark=0;	//Initial
 			ret=rtl_qosGetSkbMarkByNaptEntry(&rtl865xNaptEntry, &rtl865xQosMark, skb);
-			
+
 			lanDev=rtl865x_getLanDev();
 			wanDev=rtl865x_getWanDev();
 			rtl865xPrio.downlinkPrio=rtl_qosGetPriorityByMark(lanDev->name, rtl865xQosMark.downlinkMark);
@@ -2126,7 +2227,7 @@ int32 rtl_udp_state_transition_check(struct ip_vs_conn *cp, int direction, const
 			rtl865xPrio.downlinkPrio=0;
 			rtl865xPrio.uplinkPrio=0;
 		}
-		
+
 		#if defined(CONFIG_RTL_LAYERED_DRIVER_L4)
 		rtl865xNaptEntry.protocol=RTL865X_PROTOCOL_UDP;
 		rtl865xNaptEntry.intIp=cp->daddr.ip;
@@ -2150,7 +2251,7 @@ int32 rtl_udp_state_transition_check(struct ip_vs_conn *cp, int direction, const
 	}
 }
 
-#endif 
+#endif
 
 #if defined(CONFIG_PROC_FS) && defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
 static struct proc_dir_entry *proc_gc_overflow_timout=NULL;
@@ -2173,14 +2274,14 @@ static int gc_overflow_timout_write_proc(struct file *file, const char *buffer,
 		      unsigned long count, void *data)
 {
 	uint32 tmpBuf[32];
-	
-      if (count < 2) 
+
+      if (count < 2)
 	    return -EFAULT;
 
       if (buffer && !copy_from_user(tmpBuf, buffer, count)) {
 	    tmpBuf[count-1]=0;
 	    rtl_gc_overflow_timout=simple_strtol((const char *)tmpBuf, NULL, 0);
-	
+
 	    return count;
       }
       return -EFAULT;
@@ -2196,4 +2297,315 @@ void gc_overflow_timout_proc_init(void)
 }
 #endif
 
+#if defined(CONFIG_RTL_LOG_DEBUG)
+struct RTL_LOG_PRINT_MASK
+/*{
+	uint32 ERROR:1;
+	uint32 WARN:1;
+	uint32 INFO:1;
+}*/ RTL_LogTypeMask;
+struct RTL_LOG_ERROR_MASK
+/*{
+	uint32 MEM:1;
+	uint32 SKB:1;
+}*/RTL_LogErrorMask;
+struct RTL_LOG_MODULE_MASK
+/*{
+	uint8 NIC:1;
+	uint8 WIRELESS:1;
+	uint8 PROSTACK:1;
+}*/RTL_LogModuleMask;
+uint32 RTL_LogRatelimit=1;
+
+static struct proc_dir_entry *proc_log_print_control=NULL;
+static struct proc_dir_entry *proc_printMask=NULL;
+static struct proc_dir_entry *proc_errMask=NULL;
+static struct proc_dir_entry *proc_printModule=NULL;
+static struct proc_dir_entry *proc_print_rateLimit=NULL;
+const char *print_Mask_ID="typeMask";
+const char *print_errMask_ID="errMask";
+const char *print_rateLimit_ID="rateLimit_enable";
+const char *print_module_ID="module_mask";
+
+static int print_log_read_proc(char *page, char **start, off_t off,
+		     int count, int *eof, void *data)
+{
+	int len;
+
+	if(0==strcmp(data, print_Mask_ID))
+	{
+		len = sprintf(page, "RTL_LogTypeMask(0x%x)\n\tbit means:\n\t ERROR %d\n\t WARN %d \n\t INFO %d \n", \
+						*(uint32 *)&RTL_LogTypeMask, RTL_LogTypeMask.ERROR, RTL_LogTypeMask.WARN, RTL_LogTypeMask.INFO);
+	}
+	else if(0==strcmp(data, print_errMask_ID))
+	{
+		len = sprintf(page, "RTL_LogErrorMask(0x%x)\n\tbit means:\n\t MEM %d\n\t SKB %d \n", \
+						*(uint32 *)&RTL_LogErrorMask, RTL_LogErrorMask.MEM, RTL_LogErrorMask.SKB);
+	}
+	else if(0==strcmp(data, print_rateLimit_ID))
+	{
+		len = sprintf(page, "rate_limit %d \n", RTL_LogRatelimit);
+	}
+	else if(0==strcmp(data, print_module_ID))
+	{
+		len = sprintf(page, "RTL_LogModuleMask(0x%x)\n\tbit means:\n\t NIC %d\n\t WIRELESS %d \n\t PROSTACK %d \n", \
+			  *(uint32 *)&RTL_LogModuleMask, RTL_LogModuleMask.NIC, RTL_LogModuleMask.WIRELESS, RTL_LogModuleMask.PROSTACK);
+	}
+
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+	return len;
+}
+
+static int print_log_write_proc(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+	unsigned char tmpBuf[32];
+	int tmp;
+	if (count < 2)
+		return -EFAULT;
+
+	if (!buffer || copy_from_user(tmpBuf, buffer, count)) {
+		return -EFAULT;
+	}
+
+	if(0==strcmp(data, print_Mask_ID))
+	{
+		sscanf(tmpBuf, "%x", &tmp);
+		*(uint32 *)&RTL_LogTypeMask=tmp;
+	}
+	else if(0==strcmp(data, print_errMask_ID))
+	{
+		sscanf(tmpBuf, "%x", &tmp);
+		*(uint32 *)&RTL_LogErrorMask=tmp;
+	}
+	else if(0==strcmp(data, print_rateLimit_ID))
+	{
+		tmpBuf[count-1]=0;
+		RTL_LogRatelimit=simple_strtol((const char *)tmpBuf, NULL, 0);
+	}
+	else if(0==strcmp(data, print_module_ID))
+	{
+		sscanf(tmpBuf, "%x", &tmp);
+		*(uint32 *)&RTL_LogModuleMask=tmp;
+	}
+
+	return count;
+}
+void log_print_proc_init(void)
+{
+	RTL_LogTypeMask.ERROR=1;
+		RTL_LogErrorMask.MEM=1;
+		RTL_LogErrorMask.SKB=1;
+
+	RTL_LogTypeMask.WARN=1;
+	RTL_LogTypeMask.INFO=0;
+
+	RTL_LogModuleMask.NIC=1;
+	RTL_LogModuleMask.WIRELESS=1;
+	RTL_LogModuleMask.PROSTACK=1;
+
+	RTL_LogRatelimit=1;
+
+	proc_log_print_control= proc_mkdir("log_print_control",NULL);
+	if(proc_log_print_control)
+	{
+
+		proc_printMask = create_proc_entry(print_Mask_ID, 0, proc_log_print_control);
+		if (proc_printMask) {
+			proc_printMask->read_proc = print_log_read_proc;
+			proc_printMask->write_proc = print_log_write_proc;
+			proc_printMask->data = (void *)print_Mask_ID;
+		}
+
+		proc_errMask = create_proc_entry(print_errMask_ID, 0, proc_log_print_control);
+		if (proc_errMask) {
+			proc_errMask->read_proc = print_log_read_proc;
+			proc_errMask->write_proc = print_log_write_proc;
+			proc_errMask->data = (void *)print_errMask_ID;
+		}
+
+		proc_print_rateLimit = create_proc_entry(print_rateLimit_ID, 0, proc_log_print_control);
+		if (proc_print_rateLimit) {
+			proc_print_rateLimit->read_proc = print_log_read_proc;
+			proc_print_rateLimit->write_proc = print_log_write_proc;
+			proc_print_rateLimit->data = (void *)print_rateLimit_ID;
+		}
+
+		proc_printModule = create_proc_entry(print_module_ID, 0, proc_log_print_control);
+		if (proc_printModule) {
+			proc_printModule->read_proc = print_log_read_proc;
+			proc_printModule->write_proc = print_log_write_proc;
+			proc_printModule->data = (void *)print_module_ID;
+		}
+	}
+}
+#endif
+
+#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW) //CONFIG_RTL_GC_INDEPENDENCE_ON_KERNEL
+int rtl_gc_threshold_check(struct net* net)
+{
+	int ret = FAILED;
+
+	if(net == NULL){
+		if(atomic_read(&(init_net.ct.count)) > rtl_nf_conntrack_threshold)
+			ret = SUCCESS;
+	}else{
+		if(atomic_read(&net->ct.count) > rtl_nf_conntrack_threshold)
+			ret = SUCCESS;
+	}
+
+	return ret;
+}
+
+void rtl_list_del(struct nf_conn* ct)
+{
+	return	list_del(&ct->state_tuple);
+}
+
+void rtl_hlist_nulls_del_rcu(struct nf_conn* ct, enum ip_conntrack_dir dir)
+{
+	return	hlist_nulls_del_rcu(&ct->tuplehash[dir].hnnode);
+}
+
+void rtl_list_add_tail(struct nf_conn* ct, int proto, int flag)
+{
+	if(proto == PROT_UDP)
+		return list_add_tail(&ct->state_tuple,Udp_State_Hash_Head[flag].state_hash);
+	else if(proto == PROT_TCP)
+		return list_add_tail(&ct->state_tuple,Tcp_State_Hash_Head[ct->proto.tcp.state].state_hash);
+}
+
+
+int rtl_test_bit(struct nf_conn* ct, int num)
+{
+	if(test_bit(num, &ct->status))
+		return SUCCESS;
+	else
+		return FAILED;
+}
+
+int rtl_del_ct_timer(struct nf_conn *ct)
+{
+	return del_timer(&ct->timeout);
+}
+
+void rtl_add_ct_timer(struct nf_conn *ct)
+{
+	return add_timer(&ct->timeout);
+}
+
+void rtl_list_move_tail(struct nf_conn *ct, int proto, int state)
+{
+	if(proto == PROT_UDP)
+		return list_move_tail(&ct->state_tuple, Udp_State_Hash_Head[state].state_hash);
+	else if(proto == PROT_TCP)
+		return list_move_tail(&ct->state_tuple, Tcp_State_Hash_Head[(enum tcp_conntrack)state].state_hash);
+}
+
+unsigned long rtl_get_ct_timer_expires(struct nf_conn* ct)
+{
+	return ct->timeout.expires;
+}
+
+void rtl_nf_ct_stat_inc(struct net* net)
+{
+	NF_CT_STAT_INC(net, delete_list);
+
+	return;
+}
+
+int rtl_skb_network_offset(struct sk_buff *skb)
+{
+	return skb_network_offset(skb);
+}
+
+u_int8_t rtl_new_gc_get_ct_protonum(void *ct_ptr, enum ip_conntrack_dir dir)
+{
+	struct nf_conn *ct = (struct nf_conn *)ct_ptr;
+
+	return ct->tuplehash[dir].tuple.dst.protonum;
+}
+
+struct iphdr *rtl_new_gc_ip_hdr(struct sk_buff *skb)
+{
+	return ip_hdr(skb);
+}
+
+__be16 rtl_new_gc_get_skb_protocol(struct sk_buff *skb)
+{
+	return skb->protocol;
+}
+
+unsigned long rtl_new_gc_get_ct_udp_status(void *ct_ptr)
+{
+	struct nf_conn *ct = (struct nf_conn *)ct_ptr;
+
+	return ct->status;
+}
+
+u_int8_t rtl_new_gc_get_ct_tcp_state(void *ct_ptr)
+{
+	struct nf_conn *ct = (struct nf_conn *)ct_ptr;
+
+	return ct->proto.tcp.state;
+}
+
+void rtl_new_gc_set_ct_timeout_expires(void *ct_ptr, unsigned long value)
+{
+	struct nf_conn *ct = (struct nf_conn *)ct_ptr;
+
+	ct->timeout.expires = value;
+
+	return;
+}
+
+/*flag = 0 for src; flag = 1 for dst*/
+__be32 rtl_new_gc_get_ct_ip_by_dir(void *ct_ptr, enum ip_conntrack_dir dir, int flag)
+{
+	struct nf_conn *ct = (struct nf_conn *)ct_ptr;
+
+	if(dir == IP_CT_DIR_ORIGINAL)
+	{
+		if(flag == 0)
+			return ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;
+		else if(flag == 1)
+			return ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip;
+	}
+	else if(dir == IP_CT_DIR_REPLY)
+	{
+		if(flag == 0)
+			return ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3.ip;
+		else if(flag == 1)
+			return ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip;
+	}
+}
+
+/*flag = 0 for src; flag = 1 for dst*/
+__be16 rtl_new_gc_get_ct_port_by_dir(void *ct_ptr, enum ip_conntrack_dir dir, int flag)
+{
+	struct nf_conn *ct = (struct nf_conn *)ct_ptr;
+
+	if(dir == IP_CT_DIR_ORIGINAL)
+	{
+		if(flag == 0)
+			return ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.all;
+		else if(flag == 1)
+			return ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u.all;
+
+	}
+	else if(dir == IP_CT_DIR_REPLY)
+	{
+		if(flag == 0)
+			return ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u.all;
+		else if(flag == 1)
+			return ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u.all;
+	}
+}
+
+#endif
+
 
diff --git a/net/rtl/features/rtl_ps_hooks.c b/net/rtl/features/rtl_ps_hooks.c
index 8be0017..47c40f6 100644
--- a/net/rtl/features/rtl_ps_hooks.c
+++ b/net/rtl/features/rtl_ps_hooks.c
@@ -33,12 +33,20 @@
 #include <net/rtl/rtl865x_arp_api.h>
 #endif
 
+#ifdef CONFIG_RTL_LAYERED_DRIVER_L2
+#include <net/rtl/rtl865x_fdb_api.h>
+#endif
+
 #if defined(CONFIG_RTL_HW_QOS_SUPPORT) && defined(CONFIG_RTL_HARDWARE_NAT)
 #include <net/rtl/rtl865x_netif.h>
 #include <net/rtl/rtl865x_outputQueue.h>
 #endif
 
-#ifdef CONFIG_RTL_HARDWARE_NAT 
+#if defined (CONFIG_RTL865X_LANPORT_RESTRICTION)
+#include <net/rtl/features/lan_restrict.h>
+#endif
+
+#ifdef CONFIG_RTL_HARDWARE_NAT
 //#define CONFIG_HARDWARE_NAT_DEBUG
 #ifdef CONFIG_RTL_LAYERED_DRIVER_L3
 #include <net/rtl/rtl865x_ppp.h>
@@ -48,7 +56,7 @@
 extern int gHwNatEnabled;
 #endif
 
-#ifdef CONFIG_RTL_HARDWARE_NAT 
+#ifdef CONFIG_RTL_HARDWARE_NAT
 /*2007-12-19*/
 #ifdef CONFIG_RTL_LAYERED_DRIVER_L3
 #include <net/rtl/rtl865x_ip_api.h>
@@ -64,18 +72,21 @@ extern unsigned int hw_napt_ip;
 enum LR_RESULT (*FastPath_hook5)( ipaddr_t ip, ether_addr_t* mac, enum ARP_FLAGS flags )=NULL;
 enum LR_RESULT (*FastPath_hook7)( ipaddr_t ip )=NULL;
 enum LR_RESULT (*FastPath_hook8)( ipaddr_t ip, ether_addr_t* mac, enum ARP_FLAGS flags )=NULL;
-EXPORT_SYMBOL(FastPath_hook8);      
-EXPORT_SYMBOL(FastPath_hook7);        
-EXPORT_SYMBOL(FastPath_hook5);  
+EXPORT_SYMBOL(FastPath_hook8);
+EXPORT_SYMBOL(FastPath_hook7);
+EXPORT_SYMBOL(FastPath_hook5);
 #endif
 
-
 int32 rtl_nf_conntrack_in_hooks(rtl_nf_conntrack_inso_s *info)
 {
-	#if !defined(IMPROVE_QOS) && defined(CONFIG_RTL_IPTABLES_FAST_PATH)
-	rtl_fpAddConnCache(info->ct, info->skb);
+#if defined(CONFIG_RTL_IPTABLES_FAST_PATH)
+	#if !defined(IMPROVE_QOS)
+			rtl_fpAddConnCache(info->ct, info->skb);
+	#elif defined(CONFIG_RTL_ROUTER_FAST_PATH)
+			if(routerTypeFlag == 1)
+				rtl_fpAddConnCache(info->ct, info->skb);
 	#endif
-
+#endif
 	return RTL_PS_HOOKS_CONTINUE;
 }
 
@@ -105,7 +116,7 @@ int32 rtl_nf_conntrack_destroy_hooks(rtl_nf_conntrack_inso_s *info)
 int32 rtl_nf_conntrack_confirm_hooks(rtl_nf_conntrack_inso_s *info)
 {
 	#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
-	rtl_connGC_addList(info->skb, info->ct);
+	rtl_connGC_addList((void*)info->skb, (void*)info->ct);
 	#endif
 
 	return RTL_PS_HOOKS_CONTINUE;
@@ -149,6 +160,41 @@ int32 rtl_nf_nat_packet_hooks(rtl_nf_conntrack_inso_s *info)
 	return RTL_PS_HOOKS_CONTINUE;
 }
 
+#ifdef CONFIG_RTL_WLAN_DOS_FILTER
+#define RTL_WLAN_NAME "wlan"
+#define TCP_SYN 2
+#define _MAX_SYN_THRESHOLD 		400
+#define _WLAN_BLOCK_TIME			20	// unit: seconds
+
+int wlan_syn_cnt=0;
+int wlan_block=0, wlan_block_count=0;
+unsigned int dbg_wlan_dos_block_pkt_num=0;
+unsigned char block_source_mac[6];
+int wlan_dos_filter_enabled = 1;
+
+extern unsigned int _br0_ip;
+
+#ifdef CONFIG_RTL8192CD
+extern int issue_disassoc_from_kernel(void *priv, unsigned char *mac);
+#endif
+
+static struct timer_list wlan_dos_timer;
+static void wlan_dos_timer_fn(unsigned long arg)
+{	
+	wlan_syn_cnt = 0;
+
+	if(wlan_block_count >=_WLAN_BLOCK_TIME) {		
+		wlan_block=0;
+		wlan_block_count=0;
+	}
+	if(wlan_block == 1)
+		wlan_block_count++;
+	
+      	mod_timer(&wlan_dos_timer, jiffies + HZ);
+}
+
+#endif
+
 int32 rtl_nat_init_hooks(void)
 {
 	rtl_nat_init();
@@ -156,6 +202,14 @@ int32 rtl_nat_init_hooks(void)
 	rtl_qos_init();
 	#endif
 
+#ifdef CONFIG_RTL_WLAN_DOS_FILTER
+      init_timer(&wlan_dos_timer);
+      wlan_dos_timer.expires  = jiffies + HZ;
+      wlan_dos_timer.data     = 0L;
+      wlan_dos_timer.function = wlan_dos_timer_fn;
+      mod_timer(&wlan_dos_timer, jiffies + HZ);
+	#endif
+
 	return RTL_PS_HOOKS_CONTINUE;
 }
 
@@ -205,7 +259,7 @@ int32 rtl_fn_hash_delete_hooks(struct fib_table *tb, struct fib_config *cfg)
 	#if defined(CONFIG_RTL_HARDWARE_NAT)
 	rtl_fn_delete(tb, cfg);
 	#endif
-	
+
 	return RTL_PS_HOOKS_CONTINUE;
 }
 
@@ -252,6 +306,76 @@ int32 rtl_dev_hard_start_xmit_hooks(struct sk_buff *skb, struct net_device *dev,
 	return RTL_PS_HOOKS_CONTINUE;
 }
 
+#ifdef CONFIG_RTL_WLAN_DOS_FILTER
+
+static int  filter_dos_wlan(struct sk_buff *skb)
+{
+	struct iphdr *iph;
+	struct tcphdr *tcph;	
+	unsigned char *tflag;		
+	int ret=NF_ACCEPT;
+	
+	iph=ip_hdr(skb);
+	tcph=(void *) iph + iph->ihl*4;
+	tflag=(void *) tcph + 13;
+
+     	//wlan_dev=__dev_get_by_name(&init_net,RTL_PS_WLAN0_DEV_NAME);	// wlan0
+     	//wlan_dev=__dev_get_by_name(&init_net,RTL_PS_LAN_P0_DEV_NAME);	// eth0
+
+	//if(skb->dev && (skb->dev == wlan_dev))
+
+	if ((skb->dev) &&	(!strncmp(skb->dev->name, RTL_WLAN_NAME, 4)))	// wlan0, wlan1, wlan0-va0, ... and so on
+	{
+		if ((iph->protocol==IPPROTO_TCP) && ((*tflag & 0x3f)==TCP_SYN) && (iph->daddr == _br0_ip))		// xdos.exe 192.168.1.254 0-65535
+		{	
+			//if(wlan_block==1 && attack_daddr2==iph->daddr) {
+			if ((wlan_block==1) && (memcmp(block_source_mac, &(skb->mac_header[6]), 6) == 0)) {
+				dbg_wlan_dos_block_pkt_num++;
+				ret = NF_DROP;
+			}
+			else {
+	      			wlan_syn_cnt++;
+			
+				if(wlan_syn_cnt > _MAX_SYN_THRESHOLD)
+				{
+					//attack_daddr2=iph->daddr;
+					wlan_block=1;
+
+#ifdef CONFIG_RTL8192CD
+					issue_disassoc_from_kernel((void *) skb->dev->priv, &(skb->mac_header[6]));
+#endif
+					memcpy(block_source_mac, &(skb->mac_header[6]), 6);
+				}
+			}
+		}
+			
+	}
+
+	return (ret);
+}
+
+int filter_dos_wlan_enter(struct sk_buff **pskb)
+{
+	int ret;
+	struct sk_buff *skb;
+
+	skb=*pskb;
+	skb->transport_header=skb->data;
+	skb->network_header = skb->data;
+
+	ret = filter_dos_wlan((void*)skb);
+	if (ret == NF_DROP) {
+		kfree_skb(skb);
+		ret = NET_RX_DROP;
+	}
+	else {
+		ret = NET_RX_SUCCESS;
+	}
+
+	return ret;
+}
+#endif
+
 int32 rtl_netif_receive_skb_hooks(struct sk_buff **pskb)
 {
 	int	ret;
@@ -261,6 +385,13 @@ int32 rtl_netif_receive_skb_hooks(struct sk_buff **pskb)
 		ret = RTL_PS_HOOKS_RETURN;
 	} else
 	#endif
+
+	#ifdef CONFIG_RTL_WLAN_DOS_FILTER
+	if (wlan_dos_filter_enabled && filter_dos_wlan_enter(pskb)== NET_RX_DROP) {
+		ret = RTL_PS_HOOKS_RETURN;
+	} else
+	#endif
+	
 	#if defined(CONFIG_RTL_IPTABLES_FAST_PATH)
 	if (FastPath_Enter(pskb)== NET_RX_DROP) {
 		ret = RTL_PS_HOOKS_RETURN;
@@ -278,7 +409,7 @@ int32 rtl_br_dev_queue_push_xmit_before_xmit_hooks(struct sk_buff *skb)
 	#if defined(CONFIG_RTL_FAST_BRIDGE)
 	rtl_fb_add_br_entry(skb);
 	#endif
-	
+
 	return RTL_PS_HOOKS_CONTINUE;
 }
 
@@ -310,7 +441,7 @@ int32 rtl_neigh_flush_dev_hooks(struct neigh_table *tbl, struct net_device *dev,
 	#endif
 	}
 	#endif
-	
+
 	return RTL_PS_HOOKS_CONTINUE;
 }
 
@@ -342,7 +473,7 @@ int32 rtl_neigh_update_hooks(struct neighbour *neigh, const u8 *lladdr, uint8 ol
 		}
 		#else
 		rtk_modifyArp(*(u32*)neigh->primary_key, (ether_addr_t*)lladdr, ARP_NONE);
-		#endif			
+		#endif
 	}
 	#endif
 
@@ -393,7 +524,7 @@ int32  rtl_neigh_periodic_timer_hooks(struct neighbour *n,  unsigned int  refres
 
 	if (!(n->nud_state & NUD_VALID))
 		return RTL_PS_HOOKS_CONTINUE;
-	
+
 	ret = RTL_PS_HOOKS_CONTINUE;
 	#if defined(CONFIG_RTL_HARDWARE_NAT) && defined(CONFIG_RTL_LAYERED_DRIVER)  && defined(CONFIG_RTL_LAYERED_DRIVER_L3)
 	if (rtl865x_arpSync(htonl(*((u32 *)n->primary_key)), refresh)>0) {
@@ -401,7 +532,7 @@ int32  rtl_neigh_periodic_timer_hooks(struct neighbour *n,  unsigned int  refres
 		n->dead=0;
 		ret = RTL_PS_HOOKS_BREAK;
 	}
-	else 
+	else
 	#endif
 
 	#if defined(CONFIG_RTL_IPTABLES_FAST_PATH)
@@ -425,7 +556,7 @@ int32 rtl_neigh_timer_handler_pre_update_hooks(struct neighbour *neigh, unsigned
 	#if defined(CONFIG_RTL_HARDWARE_NAT) && defined(CONFIG_RTL_LAYERED_DRIVER)  && defined(CONFIG_RTL_LAYERED_DRIVER_L3)
 	int32	tval;
 	#endif
-	
+
 	if (state & NUD_REACHABLE) {
 		#if defined(CONFIG_RTL_IPTABLES_FAST_PATH)
 		if (neigh->nud_state & NUD_VALID) {
@@ -442,13 +573,13 @@ int32 rtl_neigh_timer_handler_pre_update_hooks(struct neighbour *neigh, unsigned
 
 		#if defined(CONFIG_RTL_HARDWARE_NAT) && defined(CONFIG_RTL_LAYERED_DRIVER)  && defined(CONFIG_RTL_LAYERED_DRIVER_L3)
 		tval = rtl865x_arpSync(htonl(*((u32 *)neigh->primary_key)), 0);
-		if (tval > 0) 
+		if (tval > 0)
 		{
 			neigh->confirmed = jiffies;
 		}
 		#if 0
 		printk("%s:%d: ip:%u.%u.%u.%u, mac:%x:%x:%x:%x:%x:%x, tval is %d\n",
-		__FUNCTION__,__LINE__,NIPQUAD(htonl(*((u32 *)neigh->primary_key))), neigh->ha[0], neigh->ha[1], 
+		__FUNCTION__,__LINE__,NIPQUAD(htonl(*((u32 *)neigh->primary_key))), neigh->ha[0], neigh->ha[1],
 		neigh->ha[2], neigh->ha[3], neigh->ha[4], neigh->ha[5],tval);
 		#endif
 		#endif
@@ -456,13 +587,13 @@ int32 rtl_neigh_timer_handler_pre_update_hooks(struct neighbour *neigh, unsigned
 	} else if (state & NUD_DELAY) {
 		#if defined(CONFIG_RTL_HARDWARE_NAT) && defined(CONFIG_RTL_LAYERED_DRIVER)  && defined(CONFIG_RTL_LAYERED_DRIVER_L3)
 		tval = rtl865x_arpSync(htonl(*((u32 *)neigh->primary_key)), 0);
-		if (tval > 0) 
+		if (tval > 0)
 		{
 			neigh->confirmed = jiffies;
 		}
 		#if 0
 		printk("%s:%d: ip:%u.%u.%u.%u, mac:%x:%x:%x:%x:%x:%x, tval is %d",
-		__FUNCTION__,__LINE__,NIPQUAD(htonl(*((u32 *)neigh->primary_key))), neigh->ha[0], neigh->ha[1], 
+		__FUNCTION__,__LINE__,NIPQUAD(htonl(*((u32 *)neigh->primary_key))), neigh->ha[0], neigh->ha[1],
 		neigh->ha[2], neigh->ha[3], neigh->ha[4], neigh->ha[5],tval);
 		#endif
 		#endif
@@ -480,8 +611,8 @@ int32 rtl_neigh_timer_handler_during_update_hooks(struct neighbour *neigh, unsig
 			/*delete asic arp entry*/
 			syn_asic_arp(neigh, 0);
 			#if 0
-			printk("%s:%d: ip:%u.%u.%u.%u, mac:%x:%x:%x:%x:%x:%x\n", 
-			__FUNCTION__,__LINE__,NIPQUAD(htonl(*((u32 *)neigh->primary_key))), neigh->ha[0], neigh->ha[1], 
+			printk("%s:%d: ip:%u.%u.%u.%u, mac:%x:%x:%x:%x:%x:%x\n",
+			__FUNCTION__,__LINE__,NIPQUAD(htonl(*((u32 *)neigh->primary_key))), neigh->ha[0], neigh->ha[1],
 			neigh->ha[2], neigh->ha[3], neigh->ha[4],neigh->ha[5]);
 			#endif
 		}
@@ -550,7 +681,7 @@ int32 rtl_neigh_init_hooks(void)
 #if defined(CONFIG_BRIDGE)
 int32 rtl___br_fdb_get_timeout_hooks(struct net_bridge *br, struct net_bridge_fdb_entry *fdb, const unsigned char *addr)
 {
-	#if defined(CONFIG_RTL_IPTABLES_FAST_PATH)
+	#if defined(CONFIG_RTL_IPTABLES_FAST_PATH) || defined(CONFIG_RTL_FASTBRIDGE)
 	if (rtl_br_fdb_time_update((void*)br, (void*)fdb, addr)==FAILED) {
 		return RTL_PS_HOOKS_BREAK;
 	}
@@ -600,12 +731,12 @@ int32 rtl_translate_table_hooks(const char *name,
 		const unsigned int *hook_entries,
 		const unsigned int *underflows)
 {
-#if defined(CONFIG_RTL_HARDWARE_NAT)	
+#if defined(CONFIG_RTL_HARDWARE_NAT)
 	//hyking:check masquerade and add ip
 	if(strcmp(name,"nat") == 0)
 	{
 		rtl_flush_extern_ip();
-		rtl_init_masq_info();	
+		rtl_init_masq_info();
 		rtl_check_for_extern_ip(name,valid_hooks,newinfo,entry0,size,number,hook_entries,underflows);
 	}
 #endif
@@ -618,7 +749,7 @@ int32 rtl_ip_tables_init_hooks(void)
 	#if defined(CONFIG_RTL_HARDWARE_NAT)
 	rtl_init_masq_info();
 	#endif
-	
+
 	return RTL_PS_HOOKS_CONTINUE;
 }
 
@@ -645,7 +776,7 @@ int32 rtl_ip_vs_conn_expire_hooks2(struct ip_vs_conn *cp)
 
 	return RTL_PS_HOOKS_CONTINUE;
 }
- 
+
 #if defined(CONFIG_IP_VS_PROTO_TCP)
 int32 rtl_tcp_state_transition_hooks(struct ip_vs_conn *cp, int direction, const struct sk_buff *skb, struct ip_vs_protocol *pp)
 {
@@ -678,7 +809,7 @@ int rtl_ct_seq_show_hooks(struct seq_file *s, struct nf_conn *ct)
 
 	nat = nfct_nat(ct);
 	if(seq_printf(s,"[%s] ",nat->hw_acc?state[0]:state[1]) != 0)
-		return RTL_PS_HOOKS_BREAK;		
+		return RTL_PS_HOOKS_BREAK;
 	#endif
 	return RTL_PS_HOOKS_CONTINUE;
 }
@@ -709,7 +840,7 @@ int32 rtl_dst_alloc_gc_post_check1_hooks(struct dst_ops * ops)
 #if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
 	rtl_gc_overflow_timeout=jiffies+rtl_gc_overflow_timout;
 #endif
-	
+
 	return RTL_PS_HOOKS_CONTINUE;
 }
 
@@ -719,7 +850,7 @@ int32 rtl_dst_alloc_gc_post_check2_hooks(struct dst_ops * ops, struct dst_entry
 #if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
 	rtl_gc_overflow_timeout=0;
 #endif
-	
+
 	return RTL_PS_HOOKS_CONTINUE;
 }
 
@@ -735,16 +866,16 @@ int32 clean_from_lists_hooks(struct nf_conn *ct, struct net *net)
 }
 
 // hooks in __nf_ct_refresh_acct_proto at rtl_nf_connGC.c
-int32 __nf_ct_refresh_acct_proto_hooks(struct nf_conn *ct, 
+int32 __nf_ct_refresh_acct_proto_hooks(struct nf_conn *ct,
 					enum ip_conntrack_info ctinfo,
-					const struct sk_buff *skb, 
+					const struct sk_buff *skb,
 					int do_acct,
 					int *event)
 {
 #ifdef CONFIG_IP_NF_CT_ACCT
 	if (do_acct) {
 		ct->counters[CTINFO2DIR(ctinfo)].packets++;
-		ct->counters[CTINFO2DIR(ctinfo)].bytes += 
+		ct->counters[CTINFO2DIR(ctinfo)].bytes +=
 						ntohs(skb->nh.iph->tot_len);
 		if ((ct->counters[CTINFO2DIR(ctinfo)].packets & 0x80000000)
 		    || (ct->counters[CTINFO2DIR(ctinfo)].bytes & 0x80000000))
@@ -761,9 +892,9 @@ int32 __drop_one_conntrack_process_hooks1(struct nf_conn* ct, int dropPrioIdx, i
 #if defined(CONFIG_RTL_IPTABLES_FAST_PATH) || defined(CONFIG_RTL_HARDWARE_NAT)
 	if (checkFlags==TRUE && drop_priority[dropPrioIdx].state==tcpUdpState) {
 		#if defined(CONFIG_RTL_IPTABLES_FAST_PATH)
-		if (FAILED==rtl_fpTimer_update(ct)) {
+		if (FAILED==rtl_fpTimer_update((void*)ct)) {
 			read_unlock_bh(&nf_conntrack_lock);
-			rtl_death_action(ct);
+			rtl_death_action((void*)ct);
 			return RTL_PS_HOOKS_RETURN;
 		}
 		#endif
@@ -771,7 +902,7 @@ int32 __drop_one_conntrack_process_hooks1(struct nf_conn* ct, int dropPrioIdx, i
 		#if defined(CONFIG_RTL_HARDWARE_NAT)
 		if (FAILED==rtl_hwnat_timer_update(ct)) {
 			read_unlock_bh(&nf_conntrack_lock);
-			rtl_death_action(ct);
+			rtl_death_action((void*)ct);
 			return RTL_PS_HOOKS_RETURN;
 		}
 		#endif
@@ -786,7 +917,7 @@ int32 __drop_one_conntrack_process_hooks1(struct nf_conn* ct, int dropPrioIdx, i
 #endif
 	{
 		read_unlock_bh(&nf_conntrack_lock);
-		rtl_death_action(ct);
+		rtl_death_action((void*)ct);
 		return RTL_PS_HOOKS_RETURN;
 	}
 
@@ -819,9 +950,28 @@ int32 rtl_nf_conn_GC_init_hooks(void)
 
 
 #if defined(CONFIG_BRIDGE)
+int32 rtl_fdb_create_hooks(struct net_bridge_fdb_entry *fdb,const unsigned char *addr)
+{
+#if defined(CONFIG_RTL_LAYERED_DRIVER) && defined(CONFIG_RTL_LAYERED_DRIVER_L2)
+	#if defined (CONFIG_RTL865X_LANPORT_RESTRICTION)
+		if (fdb->is_static == 0)
+		{
+			rtl865x_addAuthFDBEntry_hooks(addr);
+		}
+
+	#else
+	//fdb->ageing_timer = 300*HZ;
+		rtl865x_addFDBEntry(addr);
+	#endif
+#endif
+
+return RTL_PS_HOOKS_CONTINUE;
+
+}
 int32 rtl_fdb_delete_hooks(struct net_bridge_fdb_entry *f)
 {
-#if defined(CONFIG_RTL_LAYERED_DRIVER) && defined(CONFIG_RTL_LAYERED_DRIVER_L2) && defined(CONFIG_RTL865X_SYNC_L2)
+
+#if defined(CONFIG_RTL_LAYERED_DRIVER) && defined(CONFIG_RTL_LAYERED_DRIVER_L2) //&& defined(CONFIG_RTL865X_SYNC_L2)
 	#if defined (CONFIG_RTL865X_LANPORT_RESTRICTION)
 	rtl865x_delAuthLanFDBEntry(RTL865x_L2_TYPEII, f->addr.addr);
 	#else
@@ -835,7 +985,8 @@ int32 rtl_fdb_delete_hooks(struct net_bridge_fdb_entry *f)
 	return RTL_PS_HOOKS_CONTINUE;
 }
 
-int32 rtl_br_fdb_cleanup_hooks(struct net_bridge *br, struct net_bridge_fdb_entry *f)
+
+int32 rtl_br_fdb_cleanup_hooks(struct net_bridge *br, struct net_bridge_fdb_entry *f, unsigned long delay)
 {
 	#if defined(CONFIG_RTL_FASTBRIDGE)
 	unsigned long	fb_aging;
@@ -846,8 +997,16 @@ int32 rtl_br_fdb_cleanup_hooks(struct net_bridge *br, struct net_bridge_fdb_entr
 	unsigned long hw_aging;
 	#endif
 
-	#if defined(CONFIG_RTL_LAYERED_DRIVER) && defined(CONFIG_RTL_LAYERED_DRIVER_L2) && defined(CONFIG_RTL865X_SYNC_L2)			
-		port_num= -100
+	/*printk("timelist as follow:(s)jiffies:%ld,f->ageing_timer:%ld,delay:%ld",jiffies/HZ,f->ageing_timer/HZ,delay/HZ);*/
+	if (time_after(f->ageing_timer, jiffies))
+	{
+		DEBUG_PRINT("\nf->ageing_timer AFTER jiffies:addr is :%x,%x,%x,%x,%x,%x\n",f->addr.addr[0],f->addr.addr[1],f->addr.addr[2],f->addr.addr[3],f->addr.addr[4],f->addr.addr[5]);
+		DEBUG_PRINT("time list:jiffies:%ld,hw_aging:%ld,f->ageing_timer:%ld\n",jiffies/HZ,hw_aging/HZ,f->ageing_timer/HZ );
+		return RTL_PS_HOOKS_BREAK;
+	}
+
+	#if defined(CONFIG_RTL_LAYERED_DRIVER) && defined(CONFIG_RTL_LAYERED_DRIVER_L2) && defined(CONFIG_RTL865X_SYNC_L2)
+		port_num= -100;
 		ret = rtl865x_arrangeFdbEntry(f->addr.addr, &port_num);
 
 		switch (ret) {
@@ -857,29 +1016,40 @@ int32 rtl_br_fdb_cleanup_hooks(struct net_bridge *br, struct net_bridge_fdb_entr
 			case RTL865X_FDBENTRY_300SEC:
 				hw_aging = jiffies -150*HZ;
 				break;
-			case RTL865X_FDBENTRY_150SEC:	
+			case RTL865X_FDBENTRY_150SEC:
 				hw_aging = jiffies -300*HZ;
 				break;
 			case RTL865X_FDBENTRY_TIMEOUT:
 			case FAILED:
 			default:
-				hw_aging = jiffies - (br->forward_delay<<1);
-				break;					
+				hw_aging =jiffies -450*HZ;
+				break;
 		}
 
+		ret = 0;
 		if(time_before_eq(f->ageing_timer,  hw_aging))
+		{
+			/*fresh f->ageing_timer*/
 			f->ageing_timer = hw_aging;
+		}
 	#endif
 
 	#if defined(CONFIG_RTL_FASTBRIDGE)
 		fb_aging = rtl_fb_get_entry_lastused(f->addr.addr);
 		if(time_before_eq(f->ageing_timer,  fb_aging))
+		{
 			f->ageing_timer = fb_aging;
+		}
 	#endif
 
-	return RTL_PS_HOOKS_CONTINUE;
+	if (ret==0) {
+		return RTL_PS_HOOKS_CONTINUE;
+	} else {
+		return RTL_PS_HOOKS_BREAK;
+	}
 }
 
+
 #endif	/*	defined(CONFIG_BRIDGE)	*/
 
-	
+
diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c
index b759106..5ce639f 100644
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -2422,7 +2422,7 @@ static int nl80211_set_reg(struct sk_buff *skb, struct genl_info *info)
 		if (rule_idx > NL80211_MAX_SUPP_REG_RULES) {
 			r = -EINVAL;
 			goto bad_reg;
-		}
+	}
 	}
 
 	BUG_ON(rule_idx != num_rules);
diff --git a/rtkload/Makefile b/rtkload/Makefile
index b3f5602..235673b 100644
--- a/rtkload/Makefile
+++ b/rtkload/Makefile
@@ -1,7 +1,7 @@
 # The kernel tree you do builds in.
 # Uncomment if you're building for the emulator
 include ../.config
-#include ../../.config	# to check toolchain CONFIG_RSDK_rsdk-1.5.4-5281-EB-2.6.30-0.9.30.3-uls-101110
+include ../../.config	# to check toolchain CONFIG_RSDK_rsdk-1.5.4-5281-EB-2.6.30-0.9.30.3-uls-101110
 DOQUIET = false
 #DOQUIET = true 
 #EMULATOR = true
@@ -13,6 +13,7 @@ CVIMG=./cvimg
 else
 CVIMG=$(DIR_USERS)/goahead-2.1.1/LINUX/cvimg
 endif
+.NOTPARALLEL : all
 else
 CVIMG=$(DIR_USERS)/boa/tools/cvimg
 endif
diff --git a/rtkload/hfload.h b/rtkload/hfload.h
index a9da81e..6d15ec6 100644
--- a/rtkload/hfload.h
+++ b/rtkload/hfload.h
@@ -48,7 +48,7 @@ extern int file_offset;
 
 #ifdef CONFIG_RTK_VOIP
 	#undef FREEMEM_END
-	#define FREEMEM_END	0x81000000
+	#define FREEMEM_END	0x82000000
 #endif
 
 // david -----------------
diff --git a/security/Kconfig b/security/Kconfig
index d23c839..d0e6a78 100644
--- a/security/Kconfig
+++ b/security/Kconfig
@@ -110,7 +110,7 @@ config SECURITY_ROOTPLUG
 
 	  See <http://www.linuxjournal.com/article.php?sid=6279> for
 	  more information about this module.
-
+	  
 	  If you are unsure how to answer this question, answer N.
 
 source security/selinux/Kconfig
diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 2a2c2ca..5b827a1 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -892,7 +892,7 @@ int snd_interval_list(struct snd_interval *i, unsigned int count, unsigned int *
 			continue;
 		list_range.min = min(list_range.min, list[k]);
 		list_range.max = max(list_range.max, list[k]);
-        }
+                }
 	return snd_interval_refine(i, &list_range);
 }
 
diff --git a/sound/pci/intel8x0.c b/sound/pci/intel8x0.c
index 8aa5687..6a98668 100644
--- a/sound/pci/intel8x0.c
+++ b/sound/pci/intel8x0.c
@@ -1083,7 +1083,7 @@ static snd_pcm_uframes_t snd_intel8x0_pcm_pointer(struct snd_pcm_substream *subs
 			 */
 			if (pos_base == last_base)
 				ptr = ichdev->last_pos;
-		}
+	}
 	}
 	ichdev->last_pos = ptr;
 	spin_unlock(&chip->reg_lock);
